#. TRANSLATORS: def Inspect.Algebra.format(d, w)
#: lib/inspect/algebra.ex:486 
msgid ""
"The formatting function.\n"
"\n"
"Takes the maximum width and a document to print as its arguments\n"
"and returns an IO data representation of the best layout for the\n"
"document to fit in the given width.\n"
msgstr ""
#. TRANSLATORS: def Inspect.Algebra.surround(left, doc, right)
#: lib/inspect/algebra.ex:410 
msgid ""
"Surrounds a document with characters.\n"
"\n"
"Puts the document between left and right enclosing and nesting it.\n"
"The document is marked as a group, to show the maximum as possible\n"
"concisely together.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.surround \"[\", Inspect.Algebra.glue(\"a\", \"b\"), \"]\"\n"
"    iex> Inspect.Algebra.format(doc, 3)\n"
"    [\"[\", \"a\", \"\\n \", \"b\", \"]\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Inspect.Algebra.empty()
#: lib/inspect/algebra.ex:228 
msgid ""
"Returns a document entity used to represent nothingness.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Inspect.Algebra.empty\n"
"    :doc_nil\n"
"\n"
msgstr ""
#. TRANSLATORS: def Inspect.Algebra.break(s)
#: lib/inspect/algebra.ex:298 
msgid ""
"Document entity representing a break.\n"
"\n"
"This break can be rendered as a linebreak or as spaces,\n"
"depending on the `mode` of the chosen layout or the provided\n"
"separator.\n"
"\n"
"## Examples\n"
"\n"
"Let's glue two docs together with a break and then render it:\n"
"\n"
"    iex> doc = Inspect.Algebra.glue(\"a\", \" \", \"b\")\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"a\", \" \", \"b\"]\n"
"\n"
"Notice the break was represented as is, because we haven't reached\n"
"a line limit. Once we do, it is replaced by a newline:\n"
"\n"
"    iex> doc = Inspect.Algebra.glue(String.duplicate(\"a\", 20), \" \", \"b\")\n"
"    iex> Inspect.Algebra.format(doc, 10)\n"
"    [\"aaaaaaaaaaaaaaaaaaaa\", \"\\n\", \"b\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Inspect.Algebra.group(d)
#: lib/inspect/algebra.ex:344 
msgid ""
"Returns a group containing the specified document.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.group(\n"
"    ...>   Inspect.Algebra.concat(\n"
"    ...>     Inspect.Algebra.group(\n"
"    ...>       Inspect.Algebra.concat(\n"
"    ...>         \"Hello,\",\n"
"    ...>         Inspect.Algebra.concat(\n"
"    ...>           Inspect.Algebra.break,\n"
"    ...>           \"A\"\n"
"    ...>         )\n"
"    ...>       )\n"
"    ...>     ),\n"
"    ...>     Inspect.Algebra.concat(\n"
"    ...>       Inspect.Algebra.break,\n"
"    ...>       \"B\"\n"
"    ...>     )\n"
"    ...> ))\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"Hello,\", \" \", \"A\", \" \", \"B\"]\n"
"    iex> Inspect.Algebra.format(doc, 6)\n"
"    [\"Hello,\", \"\\n\", \"A\", \" \", \"B\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Inspect.Algebra.nest(x, i)
#: lib/inspect/algebra.ex:266 
msgid ""
"Nests document entity `x` positions deep.\n"
"\n"
"Nesting will be appended to the line breaks.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.nest(Inspect.Algebra.glue(\"hello\", \"world\"), 5)\n"
"    iex> Inspect.Algebra.format(doc, 5)\n"
"    [\"hello\", \"\\n     \", \"world\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Inspect.Algebra.surround_many(left, docs, right, opts, fun, separator \\ ",")
#: lib/inspect/algebra.ex:439 
msgid ""
"Maps and glues a collection of items.\n"
"\n"
"It uses the given left and right as surrounding and a separator for\n"
"each item. A limit can be passed which, once reached, stops gluing\n"
"and outputs \"...\" instead.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.surround_many(\"[\", Enum.to_list(1..5), \"]\",\n"
"    ...>         %Inspect.Opts{limit: :infinity}, fn i, _opts -> to_string(i) end)\n"
"    iex> Inspect.Algebra.format(doc, 5) |> IO.iodata_to_binary\n"
"    \"[1,\\n 2,\\n 3,\\n 4,\\n 5]\"\n"
"\n"
"    iex> doc = Inspect.Algebra.surround_many(\"[\", Enum.to_list(1..5), \"]\",\n"
"    ...>         %Inspect.Opts{limit: 3}, fn i, _opts -> to_string(i) end)\n"
"    iex> Inspect.Algebra.format(doc, 20) |> IO.iodata_to_binary\n"
"    \"[1, 2, 3, ...]\"\n"
"\n"
"    iex> doc = Inspect.Algebra.surround_many(\"[\", Enum.to_list(1..5), \"]\",\n"
"    ...>         %Inspect.Opts{limit: 3}, fn i, _opts -> to_string(i) end, \"!\")\n"
"    iex> Inspect.Algebra.format(doc, 20) |> IO.iodata_to_binary\n"
"    \"[1! 2! 3! ...]\"\n"
msgstr ""
#. TRANSLATORS: def Inspect.Algebra.space(x, y)
#: lib/inspect/algebra.ex:359 
msgid ""
"Inserts a mandatory single space between two document entities.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.space \"Hughes\", \"Wadler\"\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"Hughes\", \" \", \"Wadler\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Inspect.Algebra.line(x, y)
#: lib/inspect/algebra.ex:372 
msgid ""
"Inserts a mandatory linebreak between two document entities.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.line \"Hughes\", \"Wadler\"\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"Hughes\", \"\\n\", \"Wadler\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Inspect.Algebra.glue(x, g, y)
#: lib/inspect/algebra.ex:314 
msgid ""
"Inserts a break, passed as the second argument, between two docs,\n"
"the first and the third arguments.\n"
msgstr ""
#. TRANSLATORS: def Inspect.Algebra.glue(x, y)
#: lib/inspect/algebra.ex:307 
msgid ""
"Inserts a break between two docs. See `break/1` for more info.\n"
msgstr ""
#. TRANSLATORS: def Inspect.Algebra.folddoc(list1, f)
#: lib/inspect/algebra.ex:389 
msgid ""
"Folds a list of document entities into a document entity\n"
"using a function that is passed as the first argument.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = [\"A\", \"B\"]\n"
"    iex> doc = Inspect.Algebra.folddoc(doc, fn(x,y) ->\n"
"    ...>   Inspect.Algebra.concat [x, \"!\", y]\n"
"    ...> end)\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"A\", \"!\", \"B\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.Inspect.Opts Summary
#: lib/inspect/algebra.ex:1 
msgid ""
"Defines the Inspect.Opts used by the Inspect protocol.\n"
"\n"
"The following fields are available:\n"
"\n"
"  * `:structs` - when false, structs are not formatted by the inspect\n"
"    protocol, they are instead printed as maps, defaults to true.\n"
"\n"
"  * `:binaries` - when `:as_strings` all binaries will be printed as strings,\n"
"    non-printable bytes will be escaped.\n"
"\n"
"    When `:as_binaries` all binaries will be printed in bit syntax.\n"
"\n"
"    When the default `:infer`, the binary will be printed as a string if it\n"
"    is printable, otherwise in bit syntax.\n"
"\n"
"  * `:char_lists` - when `:as_char_lists` all lists will be printed as char\n"
"    lists, non-printable elements will be escaped.\n"
"\n"
"    When `:as_lists` all lists will be printed as lists.\n"
"\n"
"    When the default `:infer`, the list will be printed as a char list if it\n"
"    is printable, otherwise as list.\n"
"\n"
"  * `:limit` - limits the number of items that are printed for tuples,\n"
"    bitstrings, and lists, does not apply to strings nor char lists, defaults\n"
"    to 50.\n"
"\n"
"  * `:pretty` - if set to true enables pretty printing, defaults to false.\n"
"\n"
"  * `:width` - defaults to the 80 characters, used when pretty is true or\n"
"    when printing to IO devices.\n"
"\n"
"  * `:base` - print integers as :binary, :octal, :decimal, or :hex, defaults\n"
"    to :decimal\n"
"\n"
msgstr ""
#. TRANSLATORS: def Inspect.Algebra.concat(x, y)
#: lib/inspect/algebra.ex:241 
msgid ""
"Concatenates two document entities.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.concat \"hello\", \"world\"\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"hello\", \"world\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Inspect.Algebra.concat(docs)
#: lib/inspect/algebra.ex:249 
msgid ""
"Concatenates a list of documents.\n"
msgstr ""
#. TRANSLATORS: def Inspect.Algebra.to_doc(map, opts)
#: lib/inspect/algebra.ex:182 
msgid ""
"Converts an Elixir structure to an algebra document\n"
"according to the inspect protocol.\n"
msgstr ""
#. TRANSLATORS: Elixir.Inspect.Algebra Summary
#: lib/inspect/algebra.ex:58 
msgid ""
"A set of functions for creating and manipulating algebra\n"
"documents, as described in [\"Strictly Pretty\" (2000) by Christian Lindig][0].\n"
"\n"
"An algebra document is represented by an `Inspect.Algebra` node\n"
"or a regular string.\n"
"\n"
"    iex> Inspect.Algebra.empty\n"
"    :doc_nil\n"
"\n"
"    iex> \"foo\"\n"
"    \"foo\"\n"
"\n"
"With the functions in this module, we can concatenate different\n"
"elements together and render them:\n"
"\n"
"    iex> doc = Inspect.Algebra.concat(Inspect.Algebra.empty, \"foo\")\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"foo\"]\n"
"\n"
"The functions `nest/2`, `space/2` and `line/2` help you put the\n"
"document together into a rigid structure. However, the document\n"
"algebra gets interesting when using functions like `break/2`, which\n"
"converts the given string into a line break depending on how much space\n"
"there is to print. Let's glue two docs together with a break and then\n"
"render it:\n"
"\n"
"    iex> doc = Inspect.Algebra.glue(\"a\", \" \", \"b\")\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"a\", \" \", \"b\"]\n"
"\n"
"Notice the break was represented as is, because we haven't reached\n"
"a line limit. Once we do, it is replaced by a newline:\n"
"\n"
"    iex> doc = Inspect.Algebra.glue(String.duplicate(\"a\", 20), \" \", \"b\")\n"
"    iex> Inspect.Algebra.format(doc, 10)\n"
"    [\"aaaaaaaaaaaaaaaaaaaa\", \"\\n\", \"b\"]\n"
"\n"
"Finally, this module also contains Elixir related functions, a bit\n"
"tied to Elixir formatting, namely `surround/3` and `surround_many/5`.\n"
"\n"
"## Implementation details\n"
"\n"
"The original Haskell implementation of the algorithm by [Wadler][1]\n"
"relies on lazy evaluation to unfold document groups on two alternatives:\n"
"`:flat` (breaks as spaces) and `:break` (breaks as newlines).\n"
"Implementing the same logic in a strict language such as Elixir leads\n"
"to an exponential growth of possible documents, unless document groups\n"
"are encoded explictly as `:flat` or `:break`. Those groups are then reduced\n"
"to a simple document, where the layout is already decided, per [Lindig][0].\n"
"\n"
"This implementation slightly changes the semantic of Lindig's algorithm\n"
"to allow elements that belong to the same group to be printed together\n"
"in the same line, even if they do not fit the line fully. This was achieved\n"
"by changing `:break` to mean a possible break and `:flat` to force a flat\n"
"structure. Then deciding if a break works as a newline is just a matter\n"
"of checking if we have enough space until the next break that is not\n"
"inside a group (which is still flat).\n"
"\n"
"Custom pretty printers can be implemented using the documents returned\n"
"by this module and by providing their own rendering functions.\n"
"\n"
"  [0]: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.2200\n"
"  [1]: http://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf\n"
"\n"
msgstr ""
