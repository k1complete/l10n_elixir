msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2015-09-16 11:02+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: def Inspect.Algebra.format(d, w)
#: lib/inspect/algebra.ex:511
msgid ""
"The formatting function.\n"
"\n"
"Takes the maximum width and a document to print as its arguments\n"
"and returns an IO data representation of the best layout for the\n"
"document to fit in the given width.\n"
msgstr ""
"フォーマット関数です。\n"
"\n"
"最大幅とその引数で表示するドキュメントをとり、その幅にフィットするドキュ\n"
"メントのためのベストレイアウトのIOデータ表現を返します。\n"

#. TRANSLATORS: def Inspect.Algebra.surround(left, doc, right)
#: lib/inspect/algebra.ex:421
msgid ""
"Surrounds a document with characters.\n"
"\n"
"Puts the document between left and right enclosing and nesting it.\n"
"The document is marked as a group, to show the maximum as possible\n"
"concisely together.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.surround \"[\", Inspect.Algebra.glue(\"a\", "
"\"b\"), \"]\"\n"
"    iex> Inspect.Algebra.format(doc, 3)\n"
"    [\"[\", \"a\", \"\\n \", \"b\", \"]\"]\n"
"\n"
msgstr ""
"文字列でドキュメントを囲みます。\n"
"\n"
"documentを囲み入れ込になっている、leftとrightの間に置きます。\n"
"グループとしてドキュメントはマークされます。そして、\n"
"一緒に簡潔になるように、最大限表示します。\n"
"\n"
"## 例\n"
"\n"
"    iex> doc = Inspect.Algebra.surround \"[\", Inspect.Algebra.glue(\"a\", "
"\"b\"), \"]\"\n"
"    iex> Inspect.Algebra.format(doc, 3)\n"
"    [\"[\", \"a\", \"\\n \", \"b\", \"]\"]\n"
"\n"

#. TRANSLATORS: def Inspect.Algebra.empty()
#: lib/inspect/algebra.ex:243
msgid ""
"Returns a document entity used to represent nothingness.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Inspect.Algebra.empty\n"
"    :doc_nil\n"
"\n"
msgstr ""
"無を代表するのに用いられるドキュメントエントリを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Inspect.Algebra.empty\n"
"    :doc_nil\n"
"\n"

#. TRANSLATORS: def Inspect.Algebra.group(d)
#: lib/inspect/algebra.ex:341
msgid ""
"Returns a group containing the specified document.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.group(\n"
"    ...>   Inspect.Algebra.concat(\n"
"    ...>     Inspect.Algebra.group(\n"
"    ...>       Inspect.Algebra.concat(\n"
"    ...>         \"Hello,\",\n"
"    ...>         Inspect.Algebra.concat(\n"
"    ...>           Inspect.Algebra.break,\n"
"    ...>           \"A\"\n"
"    ...>         )\n"
"    ...>       )\n"
"    ...>     ),\n"
"    ...>     Inspect.Algebra.concat(\n"
"    ...>       Inspect.Algebra.break,\n"
"    ...>       \"B\"\n"
"    ...>     )\n"
"    ...> ))\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"Hello,\", \" \", \"A\", \" \", \"B\"]\n"
"    iex> Inspect.Algebra.format(doc, 6)\n"
"    [\"Hello,\", \"\\n\", \"A\", \" \", \"B\"]\n"
"\n"
msgstr ""
"指定されたドキュメントを含むグループを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> doc = Inspect.Algebra.group(\n"
"    ...>   Inspect.Algebra.concat(\n"
"    ...>     Inspect.Algebra.group(\n"
"    ...>       Inspect.Algebra.concat(\n"
"    ...>         \"Hello,\",\n"
"    ...>         Inspect.Algebra.concat(\n"
"    ...>           Inspect.Algebra.break,\n"
"    ...>           \"A\"\n"
"    ...>         )\n"
"    ...>       )\n"
"    ...>     ),\n"
"    ...>     Inspect.Algebra.concat(\n"
"    ...>       Inspect.Algebra.break,\n"
"    ...>       \"B\"\n"
"    ...>     )\n"
"    ...> ))\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"Hello,\", \" \", \"A\", \" \", \"B\"]\n"
"    iex> Inspect.Algebra.format(doc, 6)\n"
"    [\"Hello,\", \"\\n\", \"A\", \" \", \"B\"]\n"
"\n"

#. TRANSLATORS: Elixir.Inspect.Error Summary
#: lib/inspect/algebra.ex:66
msgid "Raised when a struct cannot be inspected.\n"
msgstr "構造体のinspectが出来無かった時に上ります。\n"

#. TRANSLATORS: def Inspect.Algebra.nest(x, i)
#: lib/inspect/algebra.ex:278
msgid ""
"Nests document entity `x` positions deep.\n"
"\n"
"Nesting will be appended to the line breaks.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.nest(Inspect.Algebra.glue(\"hello\", \"world"
"\"), 5)\n"
"    iex> Inspect.Algebra.format(doc, 5)\n"
"    [\"hello\", \"\\n     \", \"world\"]\n"
"\n"
msgstr ""
"ドキュメントエンティティの位置を`x`だけ深くネストする。\n"
"\n"
"ネストには改行が追加されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> doc = Inspect.Algebra.nest(Inspect.Algebra.glue(\"hello\", \"world"
"\"), 5)\n"
"    iex> Inspect.Algebra.format(doc, 5)\n"
"    [\"hello\", \"\\n     \", \"world\"]\n"
"\n"

#. TRANSLATORS: def Inspect.Algebra.surround_many(left, docs, right, opts, fun, separator \\ ",")
#: lib/inspect/algebra.ex:440
msgid ""
"Maps and glues a collection of items.\n"
"\n"
"It uses the given left and right as surrounding and a separator for\n"
"each item. A limit can be passed which, once reached, stops gluing\n"
"and outputs \"...\" instead.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.surround_many(\"[\", Enum.to_list(1..5), "
"\"]\",\n"
"    ...>         %Inspect.Opts{limit: :infinity}, fn i, _opts -> "
"to_string(i) end)\n"
"    iex> Inspect.Algebra.format(doc, 5) |> IO.iodata_to_binary\n"
"    \"[1,\\n 2,\\n 3,\\n 4,\\n 5]\"\n"
"\n"
"    iex> doc = Inspect.Algebra.surround_many(\"[\", Enum.to_list(1..5), "
"\"]\",\n"
"    ...>         %Inspect.Opts{limit: 3}, fn i, _opts -> to_string(i) end)\n"
"    iex> Inspect.Algebra.format(doc, 20) |> IO.iodata_to_binary\n"
"    \"[1, 2, 3, ...]\"\n"
"\n"
"    iex> doc = Inspect.Algebra.surround_many(\"[\", Enum.to_list(1..5), "
"\"]\",\n"
"    ...>         %Inspect.Opts{limit: 3}, fn i, _opts -> to_string(i) end, "
"\"!\")\n"
"    iex> Inspect.Algebra.format(doc, 20) |> IO.iodata_to_binary\n"
"    \"[1! 2! 3! ...]\"\n"
msgstr ""
"アイテムのコレクションをマップして接着します。\n"
"\n"
"周囲として与えられたleft、rightと、それぞれのアイテムのseparatorを\n"
"使います。\n"
"\n"
"制限に一度到達すると、接着を止め、\"...\"を替わりに出力します。\n"
"この制限は渡すことができます。\n"
"\n"
"## 例\n"
"\n"
"    iex> doc = Inspect.Algebra.surround_many(\"[\", Enum.to_list(1..5), "
"\"]\",\n"
"    ...>         %Inspect.Opts{limit: :infinity}, fn i, _opts -> "
"to_string(i) end)\n"
"    iex> Inspect.Algebra.format(doc, 5) |> IO.iodata_to_binary\n"
"    \"[1,\\n 2,\\n 3,\\n 4,\\n 5]\"\n"
"\n"
"    iex> doc = Inspect.Algebra.surround_many(\"[\", Enum.to_list(1..5), "
"\"]\",\n"
"    ...>         %Inspect.Opts{limit: 3}, fn i, _opts -> to_string(i) end)\n"
"    iex> Inspect.Algebra.format(doc, 20) |> IO.iodata_to_binary\n"
"    \"[1, 2, 3, ...]\"\n"
"\n"
"    iex> doc = Inspect.Algebra.surround_many(\"[\", Enum.to_list(1..5), "
"\"]\",\n"
"    ...>         %Inspect.Opts{limit: 3}, fn i, _opts -> to_string(i) end, "
"\"!\")\n"
"    iex> Inspect.Algebra.format(doc, 20) |> IO.iodata_to_binary\n"
"    \"[1! 2! 3! ...]\"\n"

#. TRANSLATORS: def Inspect.Algebra.space(x, y)
#: lib/inspect/algebra.ex:373
msgid ""
"Inserts a mandatory single space between two document entities.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.space \"Hughes\", \"Wadler\"\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"Hughes\", \" \", \"Wadler\"]\n"
"\n"
msgstr ""
"二つのドキュメントエンティティの間に必須の一つの空白を挿入します。\n"
"\n"
"## 例\n"
"\n"
"    iex> doc = Inspect.Algebra.space \"Hughes\", \"Wadler\"\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"Hughes\", \" \", \"Wadler\"]\n"
"\n"

#. TRANSLATORS: def Inspect.Algebra.line(x, y)
#: lib/inspect/algebra.ex:386
msgid ""
"Inserts a mandatory linebreak between two document entities.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.line \"Hughes\", \"Wadler\"\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"Hughes\", \"\\n\", \"Wadler\"]\n"
"\n"
msgstr ""
"二つのドキュメントエンティティの間に必須の一つの改行を挿入します。\n"
"\n"
"## 例\n"
"\n"
"    iex> doc = Inspect.Algebra.line \"Hughes\", \"Wadler\"\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"Hughes\", \"\\n\", \"Wadler\"]\n"
"\n"

#. TRANSLATORS: def Inspect.Algebra.glue(x, g, y)
#: lib/inspect/algebra.ex:334
msgid ""
"Inserts a break, passed as the second argument, between two docs,\n"
"the first and the third arguments.\n"
msgstr ""
"1番目と3番目の引数で示された二つのドキュメントの間に、2番目の引数として\n"
"パスされたブレークを挿入します。\n"

#. TRANSLATORS: def Inspect.Algebra.glue(x, y)
#: lib/inspect/algebra.ex:328
msgid "Inserts a break between two docs. See `break/1` for more info.\n"
msgstr ""
"二つのドキュメントの間にブレークを挿入します。\n"
"詳細は`break/1`を参照してください。\n"

#. TRANSLATORS: def Inspect.Algebra.fold_doc(list, fun)
#: lib/inspect/algebra.ex:399
msgid ""
"Folds a list of document entities into a document entity\n"
"using a function that is passed as the first argument.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = [\"A\", \"B\"]\n"
"    iex> doc = Inspect.Algebra.fold_doc(doc, fn(x, y) ->\n"
"    ...>   Inspect.Algebra.concat [x, \"!\", y]\n"
"    ...> end)\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"A\", \"!\", \"B\"]\n"
"\n"
msgstr ""
"ドキュメントエンティティのリストを、ドキュメントエンディティに、関数を\n"
"使ってフォールドします。関数には、ドキュメントエンティティを最初の引数とし\n"
"て渡します。\n"
"\n"
"## 例\n"
"\n"
"    iex> doc = [\"A\", \"B\"]\n"
"    iex> doc = Inspect.Algebra.fold_doc(doc, fn(x,y) ->\n"
"    ...>   Inspect.Algebra.concat [x, \"!\", y]\n"
"    ...> end)\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"A\", \"!\", \"B\"]\n"
"\n"

#. TRANSLATORS: def Inspect.Algebra.break(s)
#: lib/inspect/algebra.ex:299
msgid ""
"Document entity representing a break.\n"
"\n"
"This break can be rendered as a linebreak or as spaces,\n"
"depending on the `mode` of the chosen layout or the provided\n"
"separator.\n"
"\n"
"## Examples\n"
"\n"
"Let's glue two docs together with a break and then render it:\n"
"\n"
"    iex> doc = Inspect.Algebra.glue(\"a\", \" \", \"b\")\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"a\", \" \", \"b\"]\n"
"\n"
"Notice the break was represented as is, because we haven't reached\n"
"a line limit. Once we do, it is replaced by a newline:\n"
"\n"
"    iex> doc = Inspect.Algebra.glue(String.duplicate(\"a\", 20), \" \", \"b"
"\")\n"
"    iex> Inspect.Algebra.format(doc, 10)\n"
"    [\"aaaaaaaaaaaaaaaaaaaa\", \"\\n\", \"b\"]\n"
"\n"
msgstr ""
"ドキュメントエンティティのブレークを意味します。\n"
"\n"
"このブレークは、選ばれたレイアウトのモードか提供されたセパレータに従っ\n"
"て、ラインブレークかスペースとして生成されます。\n"
"\n"
"## 例\n"
"\n"
"ブレークと一緒に二つのdocを接着して、それをレンダリンクしてみます:\n"
"\n"
"    iex> doc = Inspect.Algebra.glue(\"a\", \" \", \"b\")\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"a\", \" \", \"b\"]\n"
"\n"
"行の制限に達しなかったので、ブレークが現状のまま表現されたことに注意し\n"
"てください。一旦そうすれば、改行文字と置換されます:\n"
"\n"
"    iex> doc = Inspect.Algebra.glue(String.duplicate(\"a\", 20), \" \", \"b"
"\")\n"
"    iex> Inspect.Algebra.format(doc, 10)\n"
"    [\"aaaaaaaaaaaaaaaaaaaa\", \"\\n\", \"b\"]\n"
"\n"

#. TRANSLATORS: Elixir.Inspect.Opts Summary
#: lib/inspect/algebra.ex:2
msgid ""
"Defines the Inspect.Opts used by the Inspect protocol.\n"
"\n"
"The following fields are available:\n"
"\n"
"  * `:structs` - when `false`, structs are not formatted by the inspect\n"
"    protocol, they are instead printed as maps, defaults to `true`.\n"
"\n"
"  * `:binaries` - when `:as_strings` all binaries will be printed as "
"strings,\n"
"    non-printable bytes will be escaped.\n"
"\n"
"    When `:as_binaries` all binaries will be printed in bit syntax.\n"
"\n"
"    When the default `:infer`, the binary will be printed as a string if it\n"
"    is printable, otherwise in bit syntax.\n"
"\n"
"  * `:char_lists` - when `:as_char_lists` all lists will be printed as char\n"
"    lists, non-printable elements will be escaped.\n"
"\n"
"    When `:as_lists` all lists will be printed as lists.\n"
"\n"
"    When the default `:infer`, the list will be printed as a char list if "
"it\n"
"    is printable, otherwise as list.\n"
"\n"
"  * `:limit` - limits the number of items that are printed for tuples,\n"
"    bitstrings, and lists, does not apply to strings nor char lists, "
"defaults\n"
"    to 50.\n"
"\n"
"  * `:pretty` - if set to `true` enables pretty printing, defaults to "
"`false`.\n"
"\n"
"  * `:width` - defaults to the 80 characters, used when pretty is `true` or\n"
"    when printing to IO devices.\n"
"\n"
"  * `:base` - print integers as :binary, :octal, :decimal, or :hex, "
"defaults\n"
"    to :decimal\n"
"\n"
"  * `:safe` - when `false`, failures while inspecting structs will be "
"raised\n"
"    as errors instead of being wrapped in the Inspect.Error exception. This\n"
"    is useful when debugging failures and crashes for custom inspect\n"
"    implementations\n"
"\n"
msgstr ""
"Inspectプロトコルで使われる、Inspect.Optsを定義します。\n"
"\n"
"以下のフィールドが有効です:\n"
"\n"
"  * `:structs` -  `false`の時、構造体はinspectプロトコルで\n"
"    フォーマットされません。代りにマップとして表示されます。\n"
"    デフォルトは`true`です。\n"
"\n"
"  * `:binaries` -  `:as_strings`の時、全てのバイナリは文字列として\n"
"    表示され、印字不能なバイトはエスケープされます。\n"
"\n"
"    `:as_binaries`の時、全てのバイナリはビット構文で表示されます。\n"
"\n"
"    デフォルトの`:infer`の時、バイナリはそれが印字可能なら\n"
"    文字列として表示され、さもなければビット構文になります。\n"
"\n"
"  * `:char_lists` -  `:as_char_lists`の時、全てのリストは文字リストとして\n"
"    表示され、印字不能な要素はエスケープされます。\n"
"\n"
"    `:as_lists`の時、全てのリストは、リストとして表示されます。\n"
"\n"
"    デフォルトの`:infer`の時、リストはそれが印字可能なら文字リストして\n"
"    表示され、さもなければリストとして表示されます。\n"
"\n"
"  * `:limit` - タプル、ビットストリング、リストを表示する\n"
"    要素の数を制限します。文字列、文字リストは適用されません。\n"
"    デフォルトは50です。\n"
"\n"
"  * `:pretty` -  `true`にセットすると、プリティプリンティングを\n"
"     有効にします。デフォルトは`false`です。\n"
"\n"
"  * `:width` -  デフォルトは80文字です。prettyが`true`か、\n"
"    IOデバイスへのプリント時に使われます。\n"
"\n"
"  * `:base` -  整数を:binary, :octal, :decimal, :hexとして表示します。\n"
"    デフォルトは:decimalです\n"
"\n"
"  * `:safe` - `false`の時、構造体のinspectをしている間の失敗は、\n"
"    Inspect.Error例外でラッピングするかわりに、エラーとなります。\n"
"    カスタムinspect実装のデバッグ時に失敗とクラッシュが便利です。\n"

#. TRANSLATORS: def Inspect.Algebra.concat(docs)
#: lib/inspect/algebra.ex:270
msgid "Concatenates a list of documents.\n"
msgstr "ドキュメントのリストを連結します。\n"

#. TRANSLATORS: def Inspect.Algebra.concat(x, y)
#: lib/inspect/algebra.ex:255
msgid ""
"Concatenates two document entities.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.concat \"hello\", \"world\"\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"hello\", \"world\"]\n"
"\n"
msgstr ""
"二つのドキュメントエンティティを連結します。\n"
"\n"
"## 例\n"
"\n"
"    iex> doc = Inspect.Algebra.concat \"hello\", \"world\"\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"hello\", \"world\"]\n"
"\n"

#. TRANSLATORS: Elixir.Inspect.Algebra Summary
#: lib/inspect/algebra.ex:73
msgid ""
"A set of functions for creating and manipulating algebra\n"
"documents, as described in [\"Strictly Pretty\" (2000) by Christian Lindig]"
"[0].\n"
"\n"
"An algebra document is represented by an `Inspect.Algebra` node\n"
"or a regular string.\n"
"\n"
"    iex> Inspect.Algebra.empty\n"
"    :doc_nil\n"
"\n"
"    iex> \"foo\"\n"
"    \"foo\"\n"
"\n"
"With the functions in this module, we can concatenate different\n"
"elements together and render them:\n"
"\n"
"    iex> doc = Inspect.Algebra.concat(Inspect.Algebra.empty, \"foo\")\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"foo\"]\n"
"\n"
"The functions `nest/2`, `space/2` and `line/2` help you put the\n"
"document together into a rigid structure. However, the document\n"
"algebra gets interesting when using functions like `break/2`, which\n"
"converts the given string into a line break depending on how much space\n"
"there is to print. Let's glue two docs together with a break and then\n"
"render it:\n"
"\n"
"    iex> doc = Inspect.Algebra.glue(\"a\", \" \", \"b\")\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"a\", \" \", \"b\"]\n"
"\n"
"Notice the break was represented as is, because we haven't reached\n"
"a line limit. Once we do, it is replaced by a newline:\n"
"\n"
"    iex> doc = Inspect.Algebra.glue(String.duplicate(\"a\", 20), \" \", \"b"
"\")\n"
"    iex> Inspect.Algebra.format(doc, 10)\n"
"    [\"aaaaaaaaaaaaaaaaaaaa\", \"\\n\", \"b\"]\n"
"\n"
"Finally, this module also contains Elixir related functions, a bit\n"
"tied to Elixir formatting, namely `surround/3` and `surround_many/5`.\n"
"\n"
"## Implementation details\n"
"\n"
"The original Haskell implementation of the algorithm by [Wadler][1]\n"
"relies on lazy evaluation to unfold document groups on two alternatives:\n"
"`:flat` (breaks as spaces) and `:break` (breaks as newlines).\n"
"Implementing the same logic in a strict language such as Elixir leads\n"
"to an exponential growth of possible documents, unless document groups\n"
"are encoded explictly as `:flat` or `:break`. Those groups are then reduced\n"
"to a simple document, where the layout is already decided, per [Lindig][0].\n"
"\n"
"This implementation slightly changes the semantic of Lindig's algorithm\n"
"to allow elements that belong to the same group to be printed together\n"
"in the same line, even if they do not fit the line fully. This was achieved\n"
"by changing `:break` to mean a possible break and `:flat` to force a flat\n"
"structure. Then deciding if a break works as a newline is just a matter\n"
"of checking if we have enough space until the next break that is not\n"
"inside a group (which is still flat).\n"
"\n"
"Custom pretty printers can be implemented using the documents returned\n"
"by this module and by providing their own rendering functions.\n"
"\n"
"  [0]: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.2200\n"
"  [1]: http://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf\n"
"\n"
msgstr ""
"[\"Strictly Pretty\" (2000) by Christian Lindig][0]で記述された、\n"
"Algebraドキュメントを作成、操作するための一組の関数です。\n"
"\n"
"Algebraドキュメントは、\n"
"`Inspect.Algebra`ノードか標準の文字列により表現されます。\n"
"\n"
"    iex> Inspect.Algebra.empty\n"
"    :doc_nil\n"
"\n"
"    iex> \"foo\"\n"
"    \"foo\"\n"
"\n"
"このモジュールの関数で、ころなる要素を一緒に連結したり、レンダリング\n"
"できます:\n"
"\n"
"    iex> doc = Inspect.Algebra.concat(Inspect.Algebra.empty, \"foo\")\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"foo\"]\n"
"\n"
"`nest/2`、`space/2`、`line/2`関数は、\n"
"あなたが堅い構造にドキュメントをまとめるのを助けます。\n"
"しかしながら、このスペースがどのくらい印字することになっているかに\n"
"依存して、与えられた文字列に改行を入れ変換することに、\n"
"algebraドキュメントが興味をもつとき、`break/2`のような関数を\n"
"使用します。\n"
"breakとともに二つのドキュメントを接着し、それからそれをレンダリング\n"
"してみましょう:\n"
"\n"
"    iex> doc = Inspect.Algebra.glue(\"a\", \" \", \"b\")\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"a\", \" \", \"b\"]\n"
"\n"
"breakはそのまま表現されたことに注意してください。というのは、\n"
"行制限に達していなかったからです。もう一度、こんどは改行で置き換えられます:\n"
"\n"
"    iex> doc = Inspect.Algebra.glue(String.duplicate(\"a\", 20), \" \", \"b\")\n"
"    iex> Inspect.Algebra.format(doc, 10)\n"
"    [\"aaaaaaaaaaaaaaaaaaaa\", \"\\n\", \"b\"]\n"
"\n"
"最後に、このモジュールはElixir関連の関数も含みます。Elixirのフォーマッ\n"
"トと結び付く、`surround/3`と`surround_many/5`といった名前の若干の関数で\n"
"す。\n"
"\n"
"## 実装の詳細\n"
"\n"
"[Wadler][1]によるアルゴリズムのオリジナルのHaskel実装は、二つの選択肢の\n"
"上でドキュメントグループを展開するために遅延評価に頼っています:\n"
"`:flat`(スペースとしてbreak)と`:break`(改行としてbreak)。ドキュメントグ\n"
"ループが`:flat`か`:break`として明示的にエンコードされていない限り、\n"
"Elixirのようなstrictな言語で同じロジックを実装することは可能性のあるド\n"
"キュメントの指数関数的成長に至ります。それらのグループは、それから、レ\n"
"イアウトはすでに[Lindig][0] によって決定されている、単一のドキュメント\n"
"に簡約されます。\n"
"\n"
"例えそれらが完全にはラインに合わないにしても、同じグループに属する要素\n"
"を、同じラインで印字されることを許すために、この実装は、Lindingのアルゴ\n"
"リズムの意味論を僅かに変ました。\n"
"これは有り得るbreakを意味するように`:break`を変更し、\n"
"`:flat`はフラットな構造を強制することを意味するよう変更することで、\n"
"達成されました。\n"
"それから、breakという単語が改行として働くかどうかについて決めることが、\n"
"ちょうどグループ(まだflat)の中にない、次のbreakまで十分なスペースを\n"
"もっているかどうかのチェックの問題です。\n"
"\n"
"このモジュールで返されるドキュメントを使って、そして、彼ら自身のレンダ\n"
"リング関数を提供することにより、カスタムのプリティプリンタを実装するこ\n"
"とができます。\n"
"\n"
"  [0]: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.2200\n"
"  [1]: http://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf\n"
"\n"

#. TRANSLATORS: def Inspect.Algebra.to_doc(map, opts)
#: lib/inspect/algebra.ex:191
msgid ""
"Converts an Elixir structure to an algebra document\n"
"according to the inspect protocol.\n"
msgstr ""
"Elixirの構造を、Inspectプロトコルに従って、\n"
"algebraドキュメントに変換します。\n"
