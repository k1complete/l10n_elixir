msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2015-05-20 21:55+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: @type spec
#: lib/supervisor/spec.ex:0
msgid "The supervisor specification"
msgstr "スーパバイザの仕様(specification)"

#. TRANSLATORS: @type worker
#: lib/supervisor/spec.ex:0
msgid "Supported worker values"
msgstr "workerでサポートされる値"

#. TRANSLATORS: @type strategy
#: lib/supervisor/spec.ex:0
msgid "Supported strategies"
msgstr "strategyでサポートされる値"

#. TRANSLATORS: @type shutdown
#: lib/supervisor/spec.ex:0
msgid "Supported shutdown values"
msgstr "shutdownでサポートされる値"

#. TRANSLATORS: @type restart
#: lib/supervisor/spec.ex:0
msgid "Supported restart values"
msgstr "restartでサポートされる値"

#. TRANSLATORS: @type modules
#: lib/supervisor/spec.ex:0
msgid "Supported module values"
msgstr "moduleでサポートされる値"

#. TRANSLATORS: @type child_id
#: lib/supervisor/spec.ex:0
msgid "Supported id values"
msgstr "idでサポートされる値"

#. TRANSLATORS: def Supervisor.Spec.supervise(children, options)
#: lib/supervisor/spec.ex:130
msgid ""
"Receives a list of children (workers or supervisors) to\n"
"supervise and a set of options.\n"
"\n"
"Returns a tuple containing the supervisor specification.\n"
"\n"
"## Examples\n"
"\n"
"    supervise children, strategy: :one_for_one\n"
"\n"
"## Options\n"
"\n"
"  * `:strategy` - the restart strategy option. It can be either\n"
"    `:one_for_one`, `:rest_for_one`, `:one_for_all`, or\n"
"    `:simple_one_for_one`. You can learn more about strategies\n"
"    in the `Supervisor` module docs.\n"
"\n"
"  * `:max_restarts` - the maximum amount of restarts allowed in\n"
"    a time frame. Defaults to 3.\n"
"\n"
"  * `:max_seconds` - the time frame in which `:max_restarts` applies.\n"
"    Defaults to 5.\n"
"\n"
"The `:strategy` option is required and by default maximum 3 restarts\n"
"are allowed within 5 seconds. Please check the `Supervisor` module for\n"
"a complete description of the available strategies.\n"
msgstr ""
"監督対象の子(workerかsupervisor)のリストと、オプション\n"
"を受け取ります。\n"
"\n"
"スーパバイザ仕様を含んだタプルを返します。\n"
"\n"
"## 例\n"
"\n"
"    supervise children, strategy: :one_for_one\n"
"\n"
"## Options\n"
"\n"
"  * `:strategy` - 再起動戦略オプション。取り得る値は、\n"
"    `:one_for_one`、 `:rest_for_one`、 `:one_for_all`、あるいは\n"
"    `:simple_one_for_one`です。`Supervisor`モジュールドキュメントで\n"
"     戦略についてより多く学ぶことができます。\n"
"\n"
"  * `:max_restarts` - 1フレームの間の再起動の回数の最大値です。\n"
"     デフォルトは3です。\n"
"\n"
"  * `:max_seconds` - `:max_restarts`を適用する1フレームの秒数です。\n"
"     デフォルトは5です。\n"
"\n"
"`:strategy`オプションは必要とされます。そして、デフォルトでは5秒\n"
"間に3回のリスタートが許されます。有効な戦略の完全な説明は、\n"
"`Supervisor`モジュールをチェックしてください。\n"

#. TRANSLATORS: def Supervisor.Spec.worker(module, args, options \\ [])
#: lib/supervisor/spec.ex:186
msgid ""
"Defines the given `module` as a worker which will be started\n"
"with the given arguments.\n"
"\n"
"    worker ExUnit.Runner, [], restart: :permanent\n"
"\n"
"By default, the function `start_link` is invoked on the given\n"
"module. Overall, the default values for the options are:\n"
"\n"
"    [id: module,\n"
"     function: :start_link,\n"
"     restart: :permanent,\n"
"     shutdown: 5000,\n"
"     modules: [module]]\n"
"\n"
"Check `Supervisor.Spec` module docs for more information on\n"
"the options.\n"
msgstr ""
"与えられた引数で開始するワーカーとして、\n"
"与えられた`module`を定義します。\n"
"\n"
"    worker ExUnit.Runner, [], restart: :permanent\n"
"\n"
"デフォルトで、`start_link`関数が与えられたモジュールで\n"
"起動されます。全体として、オプションのデフォルト値は以下の通りです:\n"
"\n"
"    [id: module,\n"
"     function: :start_link,\n"
"     restart: :permanent,\n"
"     shutdown: 5000,\n"
"     modules: [module]]\n"
"\n"
"オプションの詳細は `Supervisor.Spec` モジュールドキュメントを\n"
"チェックしてください。\n"

#. TRANSLATORS: def Supervisor.Spec.supervisor(module, args, options \\ [])
#: lib/supervisor/spec.ex:210
msgid ""
"Defines the given `module` as a supervisor which will be started\n"
"with the given arguments.\n"
"\n"
"    supervisor ExUnit.Runner, [], restart: :permanent\n"
"\n"
"By default, the function `start_link` is invoked on the given\n"
"module. Overall, the default values for the options are:\n"
"\n"
"    [id: module,\n"
"     function: :start_link,\n"
"     restart: :permanent,\n"
"     shutdown: :infinity,\n"
"     modules: [module]]\n"
"\n"
"Check `Supervisor.Spec` module docs for more information on\n"
"the options.\n"
msgstr ""
"与えられた引数で開始するスーパバイザとして、\n"
"与えられた`module`を定義します。\n"
"\n"
"    supervisor ExUnit.Runner, [], restart: :permanent\n"
"\n"
"デフォルトで、`start_link`関数が与えられたモジュールで\n"
"起動されます。全体として、オプションのデフォルト値は以下の通りです:\n"
"\n"
"    [id: module,\n"
"     function: :start_link,\n"
"     restart: :permanent,\n"
"     shutdown: :infinity,\n"
"     modules: [module]]\n"
"\n"
"オプションの詳細は `Supervisor.Spec` モジュールドキュメントを\n"
"チェックしてください。\n"

#. TRANSLATORS: Elixir.Supervisor.Spec Summary
#: lib/supervisor/spec.ex:2
msgid ""
"Convenience functions for defining a supervision specification.\n"
"\n"
"## Example\n"
"\n"
"By using the functions in this module one can define a supervisor\n"
"and start it with `Supervisor.start_link/2`:\n"
"\n"
"    import Supervisor.Spec\n"
"\n"
"    children = [\n"
"      worker(MyWorker, [arg1, arg2, arg3]),\n"
"      supervisor(MySupervisor, [arg1])\n"
"    ]\n"
"\n"
"    Supervisor.start_link(children, strategy: :one_for_one)\n"
"\n"
"In many situations, it may be handy to define supervisors backed\n"
"by a module:\n"
"\n"
"    defmodule MySupervisor do\n"
"      use Supervisor\n"
"\n"
"      def start_link(arg) do\n"
"        Supervisor.start_link(__MODULE__, arg)\n"
"      end\n"
"\n"
"      def init(arg) do\n"
"        children = [\n"
"          worker(MyWorker, [arg], restart: :temporary)\n"
"        ]\n"
"\n"
"        supervise(children, strategy: :simple_one_for_one)\n"
"      end\n"
"    end\n"
"\n"
"Notice in this case we don't have to explicitly import\n"
"`Supervisor.Spec` as `use Supervisor` automatically does so.\n"
"\n"
"Explicit supervisors as above are required when there is a need to:\n"
"\n"
"  1. Partially change the supervision tree during hot-code swaps.\n"
"\n"
"  2. Define supervisors inside other supervisors.\n"
"\n"
"  3. Perform actions inside the supervision `init/1` callback.\n"
"\n"
"     For example, you may want to start an ETS table that is linked to\n"
"     the supervisor (i.e. if the supervision tree needs to be restarted,\n"
"     the ETS table must be restarted too).\n"
"\n"
"## Supervisor and worker options\n"
"\n"
"In the example above, we have defined workers and supervisors\n"
"and each accepts the following options:\n"
"\n"
"  * `:id` - a name used to identify the child specification\n"
"    internally by the supervisor; defaults to the given module\n"
"    name\n"
"\n"
"  * `:function` - the function to invoke on the child to start it\n"
"\n"
"  * `:restart` - defines when the child process should restart\n"
"\n"
"  * `:shutdown` - defines how a child process should be terminated\n"
"\n"
"  * `:modules` - it should be a list with one element `[module]`,\n"
"    where module is the name of the callback module only if the\n"
"    child process is a `Supervisor` or `GenServer`; if the child\n"
"    process is a `GenEvent`, modules should be `:dynamic`\n"
"\n"
"### Restart values (:restart)\n"
"\n"
"The following restart values are supported:\n"
"\n"
"  * `:permanent` - the child process is always restarted\n"
"\n"
"  * `:temporary` - the child process is never restarted (not even\n"
"    when the supervisor's strategy is `:rest_for_one` or `:one_for_all`)\n"
"\n"
"  * `:transient` - the child process is restarted only if it\n"
"    terminates abnormally, i.e. with another exit reason than\n"
"    `:normal`, `:shutdown` or `{:shutdown, term}`\n"
"\n"
"### Shutdown values (:shutdown)\n"
"\n"
"The following shutdown values are supported:\n"
"\n"
"  * `:brutal_kill` - the child process is unconditionally terminated\n"
"    using `exit(child, :kill)`.\n"
"\n"
"  * `:infinity` - if the child process is a supervisor, it is a mechanism\n"
"    to give the subtree enough time to shutdown. It can also be used with\n"
"    workers with care.\n"
"\n"
"  * Finally, it can also be any integer meaning that the supervisor tells\n"
"    the child process to terminate by calling `Process.exit(child, :"
"shutdown)`\n"
"    and then waits for an exit signal back. If no exit signal is received\n"
"    within the specified time (in milliseconds), the child process is\n"
"    unconditionally terminated using `Process.exit(child, :kill)`.\n"
msgstr ""
"supervision仕様を定義するのに、便利な関数です。\n"
"\n"
"## 例\n"
"\n"
"このモジュールの関数を使うことによって、スーババイザの定義と、\n"
"`Supervisor.start_link/2`で開始することができます:\n"
"\n"
"    import Supervisor.Spec\n"
"\n"
"    children = [\n"
"      worker(MyWorker, [arg1, arg2, arg3]),\n"
"      supervisor(MySupervisor, [arg1])\n"
"    ]\n"
"\n"
"    Supervisor.start_link(children, strategy: :one_for_one)\n"
"\n"
"多くのシチュエーションで、一つのモジュールにより\n"
"支持されるスーパーバイザを定義することは、便利です:\n"
"\n"
"    defmodule MySupervisor do\n"
"      use Supervisor\n"
"\n"
"      def start_link(arg) do\n"
"        Supervisor.start_link(__MODULE__, arg)\n"
"      end\n"
"\n"
"      def init(arg) do\n"
"        children = [\n"
"          worker(MyWorker, [arg], restart: :temporary)\n"
"        ]\n"
"\n"
"        supervise(children, strategy: :simple_one_for_one)\n"
"      end\n"
"    end\n"
"\n"
"この場合、\n"
"明示的に`Supervicor.Spec`をインポートする必要がないことに\n"
"注意してください。`use Supervisor`が自動的に行ってくれます。\n"
"\n"
"以下の必要があるとき、上記の明示的なスーパバイザは要求されます。\n"
"\n"
"  1. ホットコードスワップ中にsupervisionツリーを部分的に変更する。\n"
"\n"
"  2. 他のスーパバイザの内側で、スーパバイザを定義する。\n"
"\n"
"  3. supervisionの`init/1`コールバックの内側でアクションを実行する。\n"
"\n"
"     例えば、スーパバイザにリンクされたETSテーブルを開始したいかも\n"
"     しれません(即ち、スーバビジョンツリーが再起動される必要があるなら、\n"
"     ETSテーブルもまた、再起動されなければなりません)。\n"
"\n"
"## supervisor と worker オプション\n"
"\n"
"上の例で、workerと、supervisorを定義し、それぞれは以下のオプションを\n"
"以下のオプションを受け付けます:\n"
"\n"
"  * `:id` - スーパバイザにより内部的に、\n"
"    子プロセス仕様を定義するために使う名前; デフォルトは与えられた\n"
"    モジュール名\n"
"\n"
"  * `:function` - 子プロセスを開始したときに起動する関数\n"
"\n"
"  * `:restart` -  子プロセスを再起動すべきときの定義\n"
"\n"
"  * `:shutdown` -  どのように子プロセスが終了されるべきかの定義\n"
"\n"
"  * `:modules` -   1要素の`[module]`のようなリストであるべきで、\n"
"     moduleは、子プロセスが`Supervisor`か`GenServer`ならば、\n"
"     コールバックモジュールの名前で、子プロセスが`GenEvent`なら、\n"
"     moduleは`:dynamic`でなければなりません。\n"
"\n"
"### Restart values (:restart)\n"
"\n"
"restart の値は以下がサポートされています:\n"
"\n"
"  * `:permanent` - 子プロセスは常に再起動されます\n"
"\n"
"  * `:temporary` - 子プロセスは決して再起動されません(\n"
"     スーパバイザの戦略が`rest_for_one`、`:one_for_all`のときも)\n"
"\n"
"  * `:transient` - 異常終了(即ち、`:normal`, `:shutdown`, \n"
"    `{:shutdown, term}`以外ののexit reason)したときだけ、\n"
"    子プロセスは再起動されます。\n"
"\n"
"### Shutdown values (:shutdown)\n"
"\n"
"以下のshutdown値がサポートされます:\n"
"\n"
"  * `:brutal_kill` - `exit(child, :kill)`を使い、子プロセスは無条件で\n"
"     終了されます。\n"
"\n"
"  * `:infinity` - 子プロセスがsupervisorなら、サブツリーにshutdownに\n"
"    十分な時間を与えるメカニズムです。注意してworkerに対して使われる\n"
"    こともあります。\n"
"\n"
"  * 最後に、スーパバイザが子プロセスに\n"
"    呼び出し`Process.exit(child, :shutdown)`によて終了するようにいい、\n"
"    それから、exitシグナルバックを待つことは、任意の整数で有り得ます。\n"
"    もしexitシグナルが指定された時間(ミリ秒)に受信されないなら、\n"
"    子プロセスは無条件に`Process.exit(child, :kill)`を使って終了\n"
"    されます。\n"
