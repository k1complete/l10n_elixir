#. TRANSLATORS: def GenEvent.ack_notify(manager, event)
#: lib/gen_event.ex:550 
msgid ""
"Sends a ack event notification to the event `manager`.\n"
"\n"
"In other words, this function only returns `:ok` as soon as the\n"
"event manager starts processing this event, but it does not wait\n"
"for event handlers to process the sent event.\n"
"\n"
"See `notify/2` for more info. Note this function is specific\n"
"to Elixir's GenEvent and does not work with Erlang ones.\n"
msgstr ""
#. TRANSLATORS: @type manager
#: lib/gen_event.ex:0 
msgid ""
"The event manager reference"
msgstr ""
#. TRANSLATORS: def GenEvent.notify(manager, event)
#: lib/gen_event.ex:501 
msgid ""
"Sends an event notification to the event `manager`.\n"
"\n"
"The event manager will call `handle_event/2` for each\n"
"installed event handler.\n"
"\n"
"`notify` is asynchronous and will return immediately after the\n"
"notification is sent. `notify` will not fail even if the specified\n"
"event manager does not exist, unless it is specified as an atom.\n"
msgstr ""
#. TRANSLATORS: def GenEvent.sync_notify(manager, event)
#: lib/gen_event.ex:537 
msgid ""
"Sends a sync event notification to the event `manager`.\n"
"\n"
"In other words, this function only returns `:ok` after the event manager\n"
"invokes the `handle_event/2` callback on each installed event handler.\n"
"\n"
"See `notify/2` for more info.\n"
msgstr ""
#. TRANSLATORS: @type name
#: lib/gen_event.ex:0 
msgid ""
"The GenEvent manager name"
msgstr ""
#. TRANSLATORS: def GenEvent.stop(manager)
#: lib/gen_event.ex:639 
msgid ""
"Terminates the event `manager`.\n"
"\n"
"Before terminating, the event manager will call `terminate(:stop, ...)`\n"
"for each installed event handler.\n"
msgstr ""
#. TRANSLATORS: def GenEvent.start_link(options \\ [])
#: lib/gen_event.ex:370 
msgid ""
"Starts an event manager linked to the current process.\n"
"\n"
"This is often used to start the `GenEvent` as part of a supervision tree.\n"
"\n"
"It accepts the `:name` option which is described under the `Name Registration`\n"
"section in the `GenServer` module docs.\n"
"\n"
"If the event manager is successfully created and initialized, the function\n"
"returns `{:ok, pid}`, where pid is the pid of the server. If a process with \n"
"the specified server name already exists, the function returns\n"
"`{:error, {:already_started, pid}}` with the pid of that process.\n"
"\n"
"Note that a `GenEvent` started with `start_link/1` is linked to the\n"
"parent process and will exit not only on crashes but also if the parent\n"
"process exits with `:normal` reason.\n"
msgstr ""
#. TRANSLATORS: @type handler
#: lib/gen_event.ex:0 
msgid ""
"Supported values for new handlers"
msgstr ""
#. TRANSLATORS: def GenEvent.start(options \\ [])
#: lib/gen_event.ex:392 
msgid ""
"Starts an event manager process without links (outside of a supervision tree).\n"
"\n"
"See `start_link/1` for more information.\n"
msgstr ""
#. TRANSLATORS: def GenEvent.stream(manager, options \\ [])
#: lib/gen_event.ex:415 
msgid ""
"Returns a stream that consumes events from the `manager`.\n"
"\n"
"The stream is a `GenEvent` struct that implements the `Enumerable`\n"
"protocol. Consumption of events only begins when enumeration starts.\n"
"\n"
"Note streaming is specific to Elixir's GenEvent and does not work\n"
"with Erlang ones.\n"
"\n"
"## Options\n"
"\n"
"  * `:timeout` - raises if no event arrives in X milliseconds\n"
"    (defaults to `:infinity`)\n"
"\n"
msgstr ""
#. TRANSLATORS: def GenEvent.which_handlers(manager)
#: lib/gen_event.ex:631 
msgid ""
"Returns a list of all event handlers installed in the `manager`.\n"
msgstr ""
#. TRANSLATORS: def GenEvent.swap_handler(manager, handler1, args1, handler2, args2)
#: lib/gen_event.ex:600 
msgid ""
"Replaces an old event handler with a new one in the event `manager`.\n"
"\n"
"First, the old event handler is deleted by calling `terminate/2` with\n"
"the given `args1` and collects the return value. Then the new event handler\n"
"is added and initiated by calling `init({args2, term})`, where `term` is the\n"
"return value of calling `terminate/2` in the old handler. This makes it\n"
"possible to transfer information from one handler to another.\n"
"\n"
"The new handler will be added even if the specified old event handler\n"
"is not installed or if the handler fails to terminate with a given reason\n"
"in which case `state = {:error, term}`.\n"
"\n"
"If `init/1` in the second handler returns a correct value, this\n"
"function returns `:ok`.\n"
msgstr ""
#. TRANSLATORS: def GenEvent.swap_mon_handler(manager, handler1, args1, handler2, args2)
#: lib/gen_event.ex:621 
msgid ""
"Replaces an old event handler with a new monitored one in the event `manager`.\n"
"\n"
"Read the docs for `add_mon_handler/3` and `swap_handler/5` for more information.\n"
msgstr ""
#. TRANSLATORS: def GenEvent.remove_handler(manager, handler, args)
#: lib/gen_event.ex:588 
msgid ""
"Removes an event handler from the event `manager`.\n"
"\n"
"The event manager will call `terminate/2` to terminate the event handler\n"
"and return the callback value. If the specified event handler is not\n"
"installed, the function returns `{:error, :not_found}`.\n"
msgstr ""
#. TRANSLATORS: def GenEvent.call(manager, handler, request, timeout \\ 5000)
#: lib/gen_event.ex:565 
msgid ""
"Makes a synchronous call to the event `handler` installed in `manager`.\n"
"\n"
"The given `request` is sent and the caller waits until a reply arrives or\n"
"a timeout occurs. The event manager will call `handle_call/2` to handle\n"
"the request.\n"
"\n"
"The return value `reply` is defined in the return value of `handle_call/2`.\n"
"If the specified event handler is not installed, the function returns\n"
"`{:error, :not_found}`.\n"
msgstr ""
#. TRANSLATORS: def GenEvent.add_handler(manager, handler, args)
#: lib/gen_event.ex:437 
msgid ""
"Adds a new event handler to the event `manager`.\n"
"\n"
"The event manager will call the `init/1` callback with `args` to\n"
"initiate the event handler and its internal state.\n"
"\n"
"If `init/1` returns a correct value indicating successful completion,\n"
"the event manager adds the event handler and this function returns\n"
"`:ok`. If the callback fails with `reason` or returns `{:error, reason}`,\n"
"the event handler is ignored and this function returns `{:error, reason}`.\n"
"\n"
"If the given handler was previously installed at the manager, this\n"
"function returns `{:error, :already_present}`.\n"
msgstr ""
#. TRANSLATORS: def GenEvent.add_mon_handler(manager, handler, args)
#: lib/gen_event.ex:456 
msgid ""
"Adds a monitored event handler to the event `manager`.\n"
"\n"
"Expects the same input and returns the same values as `add_handler/3`.\n"
"\n"
"## Monitored handlers\n"
"\n"
"A monitored handler implies the calling process will now be monitored\n"
"by the GenEvent manager.\n"
"\n"
"If the calling process later terminates with `reason`, the event manager\n"
"will delete the event handler by calling the `terminate/2` callback with\n"
"`{:stop, reason}` as argument. If the event handler later is deleted,\n"
"the event manager sends a message `{:gen_event_EXIT, handler, reason}`\n"
"to the calling process. Reason is one of the following:\n"
"\n"
"  * `:normal` - if the event handler has been removed due to a call to\n"
"    `remove_handler/3`, or `:remove_handler` has been returned by a callback\n"
"    function\n"
"\n"
"  * `:shutdown` - if the event handler has been removed because the event\n"
"    manager is terminating\n"
"\n"
"  * `{:swapped, new_handler, pid}` - if the process pid has replaced the\n"
"    event handler by another\n"
"\n"
"  * a term - if the event handler is removed due to an error. Which term\n"
"    depends on the error\n"
"\n"
"Keep in mind that the `{:gen_event_EXIT, handler, reason}` message is not\n"
"guaranteed to be delivered in case the manager crashes. If you want to\n"
"guarantee the message is delivered, you have two options:\n"
"\n"
"  * monitor the event manager\n"
"  * link to the event manager and then set `Process.flag(:trap_exit, true)`\n"
"    in your handler callback\n"
"\n"
"Finally, this functionality only works with GenEvent started via this\n"
"module (it is not backwards compatible with Erlang's `:gen_event`).\n"
msgstr ""
#. TRANSLATORS: Elixir.GenEvent Summary
#: lib/gen_event.ex:2 
msgid ""
"A behaviour module for implementing event handling functionality.\n"
"\n"
"The event handling model consists of a generic event manager\n"
"process with an arbitrary number of event handlers which are\n"
"added and deleted dynamically.\n"
"\n"
"An event manager implemented using this module will have a standard\n"
"set of interface functions and include functionality for tracing and\n"
"error reporting. It will also fit into a supervision tree.\n"
"\n"
"## Example\n"
"\n"
"There are many use cases for event handlers. For example, a logging\n"
"system can be built using event handlers where each log message is\n"
"an event and different event handlers can be plugged to handle the\n"
"log messages. One handler may print error messages on the terminal,\n"
"another can write it to a file, while a third one can keep the\n"
"messages in memory (like a buffer) until they are read.\n"
"\n"
"As an example, let's have a GenEvent that accumulates messages until\n"
"they are collected by an explicit call.\n"
"\n"
"    defmodule LoggerHandler do\n"
"      use GenEvent\n"
"\n"
"      # Callbacks\n"
"\n"
"      def handle_event({:log, x}, messages) do\n"
"        {:ok, [x|messages]}\n"
"      end\n"
"\n"
"      def handle_call(:messages, messages) do\n"
"        {:ok, Enum.reverse(messages), []}\n"
"      end\n"
"    end\n"
"\n"
"    {:ok, pid} = GenEvent.start_link([])\n"
"\n"
"    GenEvent.add_handler(pid, LoggerHandler, [])\n"
"    #=> :ok\n"
"\n"
"    GenEvent.notify(pid, {:log, 1})\n"
"    #=> :ok\n"
"\n"
"    GenEvent.notify(pid, {:log, 2})\n"
"    #=> :ok\n"
"\n"
"    GenEvent.call(pid, LoggerHandler, :messages)\n"
"    #=> [1, 2]\n"
"\n"
"    GenEvent.call(pid, LoggerHandler, :messages)\n"
"    #=> []\n"
"\n"
"We start a new event manager by calling `GenEvent.start_link/1`.\n"
"Notifications can be sent to the event manager which will then\n"
"invoke `handle_event/2` for each registered handler.\n"
"\n"
"We can add new handlers with `add_handler/3` and `add_mon_handler/3`.\n"
"Calls can also be made to specific handlers by using `call/3`.\n"
"\n"
"## Callbacks\n"
"\n"
"There are 6 callbacks required to be implemented in a `GenEvent`. By\n"
"adding `use GenEvent` to your module, Elixir will automatically define\n"
"all 6 callbacks for you, leaving it up to you to implement the ones\n"
"you want to customize.\n"
"\n"
"  * `handle_call(msg, state)` - invoked when a `call/3` is done to a specific\n"
"    handler.\n"
"\n"
"    It must return:\n"
"\n"
"    -  `{:ok, reply, new_state}`\n"
"    -  `{:ok, reply, new_state, :hibernate}`\n"
"    -  `{:remove_handler, reply}`\n"
"\n"
"  * `handle_info(msg, state)` - invoked to handle all other messages which\n"
"    are received by the process. Must return the same values as\n"
"    `handle_event/2`.\n"
"\n"
"  * `terminate(reason, state)` - called when the event handler is removed or\n"
"    the event manager is terminating. It can return any term.\n"
"\n"
"    The reason is one of:\n"
"\n"
"    -  `:stop` - manager is terminating\n"
"    -  `{:stop, reason}` - monitored process terminated (for monitored handlers)\n"
"    -  `:remove_handler` - handler is being removed\n"
"    -  `{:error, term}` - handler crashed or returned a bad value\n"
"    -  `term` - any term passed to functions like `GenEvent.remove_handler/3`\n"
"\n"
"  * `code_change(old_vsn, state, extra)` - called when the application\n"
"    code is being upgraded live (hot code swapping).\n"
"\n"
"    It must return:\n"
"\n"
"    -  `{:ok, new_state}`\n"
"\n"
"## Name Registration\n"
"\n"
"A GenEvent is bound to the same name registration rules as a `GenServer`.\n"
"Read more about it in the `GenServer` docs.\n"
"\n"
"## Modes\n"
"\n"
"GenEvent stream supports three different notifications.\n"
"\n"
"On `GenEvent.ack_notify/2`, the manager acknowledges each event,\n"
"providing backpressure, but processing of the message happens\n"
"asynchronously.\n"
"\n"
"On `GenEvent.sync_notify/2`, the manager acknowledges an event\n"
"just after it was processed by all event handlers.\n"
"\n"
"On `GenEvent.notify/2`, all events are processed asynchronously and\n"
"there is no ack (which means there is no backpressure).\n"
"\n"
"## Streaming\n"
"\n"
"`GenEvent` messages can be streamed with the help of `stream/2`.\n"
"You will need to start another process to consume the stream:\n"
"\n"
"    Task.start_link fn ->\n"
"      stream = GenEvent.stream(pid)\n"
"\n"
"      # Discard the next 3 events\n"
"      _ = Enum.drop(stream, 3)\n"
"\n"
"      # Print all remaining events\n"
"      for event <- stream do\n"
"        IO.inspect event\n"
"      end\n"
"    end\n"
"\n"
"Now call `GenEvent.notify/2` multiple times. You will see the\n"
"first three events will be skipped while the rest will be\n"
"continuously printed.\n"
"\n"
"## Learn more and compatibility\n"
"\n"
"If you wish to find out more about gen events, Elixir getting started\n"
"guides provide a tutorial-like introduction. The documentation and links\n"
"in Erlang can also provide extra insight.\n"
"\n"
"  * http://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html\n"
"  * http://www.erlang.org/doc/man/gen_event.html\n"
"  * http://learnyousomeerlang.com/event-handlers\n"
"\n"
"Keep in mind though Elixir and Erlang gen events are not 100% compatible.\n"
"The `:gen_event.add_sup_handler/3` is not supported by Elixir's GenEvent,\n"
"which in turn supports `GenEvent.add_mon_handler/3`.\n"
"\n"
"The benefits of the monitoring approach are described in the \"Don't drink\n"
"too much kool aid\" section of the \"Learn you some Erlang\" link above. Due\n"
"to those changes, Elixir's GenEvent does not trap exits by default.\n"
"\n"
"Furthermore, Elixir's also normalizes the `{:error, _}` tuples returned\n"
"by many functions, in order to be more consistent with themselves and\n"
"the `GenServer` module.\n"
msgstr ""
