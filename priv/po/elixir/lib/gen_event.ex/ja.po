msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2015-05-20 21:54+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: def GenEvent.ack_notify(manager, event)
#: lib/gen_event.ex:425
msgid ""
"Sends a ack event notification to the event `manager`.\n"
"\n"
"In other words, this function only returns `:ok` as soon as the\n"
"event manager starts processing this event, but it does not wait\n"
"for event handlers to process the sent event.\n"
"\n"
"See `notify/2` for more info. Note this function is specific\n"
"to Elixir's GenEvent and does not work with Erlang ones.\n"
msgstr ""
"同期イベント通知をイベント`manager`へ送信します。\n"
"\n"
"言い替えると、この関数は、イベントマネージャで各々のインストールされた\n"
"イベントハンドラ`handle_event/2`が呼び出されたあと、`:ok`を返すだけです。\n"
"しかし、イベントハンドラがプロセスへイベントを送信するのを\n"
"待ちません。\n"
"\n"
"更なる情報は、`notify/2`を参照してください。この関数は、Elixirの\n"
"GenEvent特有で、Erlangのものと一緒には動作しません。\n"

#. TRANSLATORS: @type name
#: lib/gen_event.ex:0
msgid "The GenEvent manager name"
msgstr "GenEvent managerの名前"

#. TRANSLATORS: @type manager
#: lib/gen_event.ex:0
msgid "The event manager reference"
msgstr "イベントマネージャのリファレンス"

#. TRANSLATORS: def GenEvent.stop(manager)
#: lib/gen_event.ex:510
msgid ""
"Terminates the event `manager`.\n"
"\n"
"Before terminating, the event manager will call `terminate(:stop, ...)`\n"
"for each installed event handler.\n"
msgstr ""
"イベント`manager`を終了します。\n"
"\n"
"終了する前に、イベントマネージャは、インストールされたイベントハンドラ\n"
"それぞれの`terminate(:stop, ...)`を呼び出します。\n"

#. TRANSLATORS: @type handler
#: lib/gen_event.ex:0
msgid "Supported values for new handlers"
msgstr "新しいハンドラでサポートされる値"

#. TRANSLATORS: def GenEvent.which_handlers(manager)
#: lib/gen_event.ex:499
msgid "Returns a list of all event handlers installed in the `manager`.\n"
msgstr ""
"`manager`にインストールされている全てのイベントハンドラの\n"
"リストを返します。\n"

#. TRANSLATORS: def GenEvent.swap_handler(manager, handler1, args1, handler2, args2)
#: lib/gen_event.ex:481
msgid ""
"Replaces an old event handler with a new one in the event `manager`.\n"
"\n"
"First, the old event handler is deleted by calling `terminate/2` with\n"
"the given `args1` and collects the return value. Then the new event handler\n"
"is added and initiated by calling `init({args2, state}), where term is the\n"
"return value of calling `terminate/2` in the old handler. This makes it\n"
"possible to transfer information from one handler to another.\n"
"\n"
"The new handler will be added even if the specified old event handler\n"
"is not installed or if the handler fails to terminate with a given reason\n"
"in which case `state = {:error, term}`.\n"
"\n"
"If `init/1` in the second handler returns a correct value, this\n"
"function returns `:ok`.\n"
msgstr ""
"イベント`manager`において、古いイベントハンドラを、新しいそれに入れ替えま"
"す。\n"
"\n"
"最初に、古いイベントハンドラは、与えられた`args1`で\n"
"`terminate/2`を呼び出して、削除されます。\n"
"そして戻値を収集します。\n"
"それから、新しいイベントハンドラが追加され、\n"
"`init({args2, term})`を呼びだして初期化します。\n"
"ここでtermは古いハンドラで`terminate/2`の戻値です。\n"
"これは、一方のハンドラからもう一方へ転送することが出来ることを\n"
"意味します。\n"
"\n"
"もし指定された古いイベントハンドラがインストールされていないなら、\n"
"あるいは、もしハンドラが終了に失敗し、`state = {:error, term}`と\n"
"なったら、新しいハンドラが追加されます。\n"
"\n"
"もし二つめのハンドラで`init/1`が正しい値を返せば、この関数は`:ok`を\n"
"返します。\n"

#. TRANSLATORS: def GenEvent.swap_mon_handler(manager, handler1, args1, handler2, args2)
#: lib/gen_event.ex:491
msgid ""
"Replaces an old event handler with a new monitored one in the event "
"`manager`.\n"
"\n"
"Read the docs for `add_mon_handler/3` and `swap_handler/5` for more "
"information.\n"
msgstr ""
"イベント`manager`で、古いイベントマネージャを新しいモニタされた\n"
"イベントハンドラで置き換えます。\n"
"\n"
"詳細は、`add_mon_handler/3`と`swap_handler/5`のドキュメントを参照してく\n"
"ださい。\n"

#. TRANSLATORS: def GenEvent.remove_handler(manager, handler, args)
#: lib/gen_event.ex:460
msgid ""
"Removes an event handler from the event `manager`.\n"
"\n"
"The event manager will call `terminate/2` to terminate the event handler\n"
"and return the callback value. If the specified event handler is not\n"
"installed, the function returns `{:error, :not_found}`.\n"
msgstr ""
"イベントマネージャ`manager`からイベントハンドラを削除します。\n"
"\n"
"イベントマネージャはイベントハンドラを終了し、コールバック値を返すため\n"
"に`terminate/2`を呼び出すでしょう。もし指定されたイベントハンドラがイン\n"
"ストールされていないなら、この関数は`{:error, :not_found}`を返し\n"
"ます。\n"

#. TRANSLATORS: def GenEvent.call(manager, handler, request, timeout \\ 5000)
#: lib/gen_event.ex:441
msgid ""
"Makes a synchronous call to the event `handler` installed in `manager`.\n"
"\n"
"The given `request` is sent and the caller waits until a reply arrives or\n"
"a timeout occurs. The event manager will call `handle_call/2` to handle\n"
"the request.\n"
"\n"
"The return value `reply` is defined in the return value of `handle_call/2`.\n"
"If the specified event handler is not installed, the function returns\n"
"`{:error, :not_found}`.\n"
msgstr ""
"`manager`にインストールされた、イベント`handler`を同期的に呼び出します。\n"
"\n"
"与えられた`request`は送信され、呼び出し側は応答が到着するか、タイムアウ\n"
"トが起きるまで待ちます。イベントマネージャは、リクエストをハンドルする\n"
"ために、`handle_call/2`を呼び出します。\n"
"\n"
"戻り値`reply`は`handle_call/2`で定義された戻り値です。もし指定されたイ\n"
"ベントハンドラがインストールされていないなら、関数は`{:error,\n"
":not_found}`を返します。\n"

#. TRANSLATORS: def GenEvent.start(options \\ [])
#: lib/gen_event.ex:262
msgid ""
"Starts an event manager process without links (outside of a supervision "
"tree).\n"
"\n"
"See `start_link/1` for more information.\n"
msgstr ""
"イベントマネージャプロセスをリンクせずに(監督ツリーの外側で)開始します。\n"
"\n"
"詳細は `start_link/1` を参照してください。\n"

#. TRANSLATORS: def GenEvent.start_link(options \\ [])
#: lib/gen_event.ex:252
msgid ""
"Starts an event manager linked to the current process.\n"
"\n"
"This is often used to start the `GenEvent` as part of a supervision tree.\n"
"\n"
"It accepts the `:name` option which is described under the `Name "
"Registration`\n"
"section in the `GenServer` module docs.\n"
"\n"
"If the event manager is successfully created and initialized, the function\n"
"returns `{:ok, pid}`, where pid is the pid of the server. If there already\n"
"exists a process with the specified server name, the function returns\n"
"`{:error, {:already_started, pid}}` with the pid of that process.\n"
"\n"
"Note that a `GenEvent` started with `start_link/1` is linked to the\n"
"parent process and will exit not only on crashes but also if the parent\n"
"process exits with `:normal` reason.\n"
msgstr ""
"イベントマネージャを現在のプロセスにリンクさせて開始します。\n"
"\n"
"これは、しばしば監督ツリーの一部として、`GenEvent`を開始するのに\n"
"使われます。\n"
"\n"
"`:name`オプションを受け付けます。内容は`GenServer`モジュールドキュメン\n"
"トの`Name Registration`セクションに記述されています。\n"
"\n"
"もしイベントマネージャがうまく作成されて、初期化されたら、\n"
"pidをサーバのプロセス識別子として、関数は`{:ok, pid}`を返します。\n"
"もし指定されたサーバの名前で既にプロセスが存在したら、そのプロセスの\n"
"プロセス識別子をpidとして、関数は`{:error, {:already_started, pid}}`\n"
"を返します。\n"
"\n"
"`start_link/1`で開始した`GenEvent`は親プロセスにリンクされていて、\n"
"親プロセスがクラッシュした場合だけでなく、`:normal` reasonで\n"
"終了した場合にも、終了することに注意してください。\n"

#. TRANSLATORS: def GenEvent.notify(manager, event)
#: lib/gen_event.ex:376
msgid ""
"Sends an event notification to the event `manager`.\n"
"\n"
"The event manager will call `handle_event/2` for each\n"
"installed event handler.\n"
"\n"
"`notify` is asynchronous and will return immediately after the\n"
"notification is sent. `notify` will not fail even if the specified\n"
"event manager does not exist, unless it is specified as an atom.\n"
msgstr ""
"イベント`manager`へイベント通知を送ります。\n"
"\n"
"イベントマネージャはそれぞれインストールされたイベントハンドラのために\n"
"`handle_event/2`を呼び出します。\n"
"\n"
"`notify`は非同期で通知を送信したらす直ちに戻ります。`notify`はもし\n"
"`name`(アトム)として指定されないかぎり、指定されたイベントマネージャが\n"
"存在しないときでも失敗しないでしょう。\n"

#. TRANSLATORS: def GenEvent.sync_notify(manager, event)
#: lib/gen_event.ex:410
msgid ""
"Sends a sync event notification to the event `manager`.\n"
"\n"
"In other words, this function only returns `:ok` after the event manager\n"
"invokes the `handle_event/2` on each installed event handler.\n"
"\n"
"See `notify/2` for more info.\n"
msgstr ""
"同期イベント通知をイベント`manager`へ送信します。\n"
"\n"
"言い替えると、この関数は、イベントマネージャで各々のインストールされた\n"
"イベントハンドラ`handle_event/2`が呼び出されたあと、`:ok`を返すだけです。\n"
"\n"
"更なる情報は、`notify/2`を参照してください。\n"

#. TRANSLATORS: def GenEvent.add_handler(manager, handler, args)
#: lib/gen_event.ex:316
msgid ""
"Adds a new event handler to the event `manager`.\n"
"\n"
"The event manager will call the `init/1` callback with `args` to\n"
"initiate the event handler and its internal state.\n"
"\n"
"If `init/1` returns a correct value indicating successful completion,\n"
"the event manager adds the event handler and this function returns\n"
"`:ok`. If the callback fails with `reason` or returns `{:error, reason}`,\n"
"the event handler is ignored and this function returns `{:error, reason}`.\n"
"\n"
"If the given handler was previously installed at the manager, this\n"
"function returns `{:error, :already_present}`.\n"
msgstr ""
"イベント`manager`へ新しいイベントハンドラを追加します。\n"
"\n"
"イベントマネージャは、イベントハンドラと内部ステートの初期化を\n"
"するために、`args`で`init/1`コールバックを呼び出します。\"\n"
"\n"
"`init/1`が完全に成功したことを示す正しい値を返したら、イベント\n"
"マネージャはそのイベントハンドラを追加し、この関数は`:ok`を返します。\n"
"もしコールバックが`reason`で失敗したり、`{:error, reason}`を返したら、\n"
"イベントハンドラは無視され、この関数は`{:error, reason}`を返します。\n"
"\n"
"もし与えられたハンドラが、マネージャにより前にインストールされて\n"
"いたら、この関数は`{:error, :already_present}`を返します。\n"

#. TRANSLATORS: def GenEvent.add_mon_handler(manager, handler, args)
#: lib/gen_event.ex:361
msgid ""
"Adds a monitored event handler to the event `manager`.\n"
"\n"
"Expects the same input and returns the same values as `add_handler/3`.\n"
"\n"
"## Monitored handlers\n"
"\n"
"A monitored handler implies the calling process will now be monitored\n"
"by the GenEvent manager.\n"
"\n"
"If the calling process later terminates with `reason`, the event manager\n"
"will delete the event handler by calling the `terminate/2` callback with\n"
"`{:stop, reason}` as argument. If the event handler later is deleted,\n"
"the event manager sends a message `{:gen_event_EXIT, handler, reason}`\n"
"to the calling process. Reason is one of the following:\n"
"\n"
"  * `:normal` - if the event handler has been removed due to a call to\n"
"    `remove_handler/3`, or `:remove_handler` has been returned by a "
"callback\n"
"    function\n"
"\n"
"  * `:shutdown` - if the event handler has been removed because the event\n"
"    manager is terminating\n"
"\n"
"  * `{:swapped, new_handler, pid}` - if the process pid has replaced the\n"
"    event handler by another\n"
"\n"
"  * a term - if the event handler is removed due to an error. Which term\n"
"    depends on the error\n"
"\n"
"Keep in mind that the `{:gen_event_EXIT, handler, reason}` message is not\n"
"guaranteed to be delivered in case the manager crashes. If you want to\n"
"guarantee the message is delivered, you have two options:\n"
"\n"
"  * monitor the event manager\n"
"  * link to the event manager and then set `Process.flag(:trap_exit, true)`\n"
"    in your handler callback\n"
"\n"
"Finally, this functionality only works with GenEvent started via this\n"
"module (it is not backwards compatible with Erlang's `:gen_event`).\n"
msgstr ""
"モニタされたイベントハンドラをイベント`manager`に追加します。\n"
"\n"
"`add_handler/3`と同じ入力と戻値を期待します。\n"
"\n"
"## Monitored handlers\n"
"\n"
"呼出し側プロセスが現在、GenEventマネージャによりモニタされている\n"
"ことを、モニタされたハンドラは意味します。\n"
"\n"
"もし呼出し側プロセスが後で`reason`で終了したら、イベントマネージャは、\n"
"引数として`{:stop, reason}`とともに、`terminate/2`コールバックを\n"
"呼び出すことにより、イベントハンドラを削除します。\n"
"\n"
"もしイベントハンドラが後で削除されたら、イベントマネージャは、\n"
"`{:gen_event_EXIT,handler, reason}`メッセージを、呼出し側プロセス\n"
"へ送信します。reasonは以下のいずれかです:\n"
"\n"
"  * `:normal` - イベントハンドラが、`remove_handler/3`の呼び出しにより\n"
"     削除されたか、あるいは、コールバック関数により、`:remove_handler`が\n"
"     戻されたか\n"
"\n"
"  * `:shutdown` - イベントマネージャが終了したことによりイベント\n"
"     ハンドラが削除された\n"
"\n"
"  * `{:swapped, new_handler, pid}` - 他のプロセスにより、イベント\n"
"     ハンドラのpidが置き換えられた\n"
"\n"
"  * a term - エラーによりイベントハンドラが削除された。termは\n"
"    エラーに依ります。\n"
"\n"
"マネージャがクラッシュする場合に、`{:gen_event_EXIT, handler, reason}`\n"
"メッセージが、届けられる保証がないことを、心にとめてください。\n"
"もしメッセージが届けられることを保証したいなら、二つのオプションが\n"
"あります:\n"
"\n"
"  * イベントマネージャをモニタします\n"
"  * イベントマネージャをリンクし、ハンドラコールバックで、\n"
"    `Process.flag(:trap_exit, true)`をセットします\n"
"\n"
"最後に、この機能は、このモジュールにより開始されるGenEventでのみ\n"
"動作します(Erlangの`:gen_event`との後方互換性はありません)。\n"

#. TRANSLATORS: def GenEvent.stream(manager, options \\ [])
#: lib/gen_event.ex:295
msgid ""
"Returns a stream that consumes events from the `manager`.\n"
"\n"
"The stream is a `GenEvent` struct that implements the `Enumerable`\n"
"protocol. Consumption of events only begins when enumeration starts.\n"
"\n"
"Note streaming is specific to Elixir's GenEvent and does not work\n"
"with Erlang ones.\n"
"\n"
"## Options\n"
"\n"
"  * `:timeout` - raises if no event arrives in X milliseconds\n"
"    (defaults to `:infinity`)\n"
"\n"
msgstr ""
"`manager`からのイベントを消費するストリームを返します。\n"
"\n"
"ストリームは`GenEvent`構造体で`Enumerable`プロトコルの実装です。\n"
"イベントの消費は数え上げの開始をしたときにだけ始まります。\n"
"\n"
"ストリーミングはElixirのGenEvent特有であり、Erlangでは\n"
"動作しないことに注意してください。\n"
"\n"
"## オプション\n"
"\n"
"  * `:timeout` - Xミリ秒の間にイベントが到着しないと\n"
"                 例外を上げます(デフォルトは `:infinity`)\n"
"\n"

#. TRANSLATORS: Elixir.GenEvent Summary
#: lib/gen_event.ex:1
msgid ""
"A behaviour module for implementing event handling functionality.\n"
"\n"
"The event handling model consists of a generic event manager\n"
"process with an arbitrary number of event handlers which are\n"
"added and deleted dynamically.\n"
"\n"
"An event manager implemented using this module will have a standard\n"
"set of interface functions and include functionality for tracing and\n"
"error reporting. It will also fit into a supervision tree.\n"
"\n"
"## Example\n"
"\n"
"There are many use cases for event handlers. For example, a logging\n"
"system can be built using event handlers where each log message is\n"
"an event and different event handlers can be plugged to handle the\n"
"log messages. One handler may print error messages on the terminal,\n"
"another can write it to a file, while a third one can keep the\n"
"messages in memory (like a buffer) until they are read.\n"
"\n"
"As an example, let's have a GenEvent that accumulates messages until\n"
"they are collected by an explicit call.\n"
"\n"
"    defmodule LoggerHandler do\n"
"      use GenEvent\n"
"\n"
"      # Callbacks\n"
"\n"
"      def handle_event({:log, x}, messages) do\n"
"        {:ok, [x|messages]}\n"
"      end\n"
"\n"
"      def handle_call(:messages, messages) do\n"
"        {:ok, Enum.reverse(messages), []}\n"
"      end\n"
"    end\n"
"\n"
"    {:ok, pid} = GenEvent.start_link()\n"
"\n"
"    GenEvent.add_handler(pid, LoggerHandler, [])\n"
"    #=> :ok\n"
"\n"
"    GenEvent.notify(pid, {:log, 1})\n"
"    #=> :ok\n"
"\n"
"    GenEvent.notify(pid, {:log, 2})\n"
"    #=> :ok\n"
"\n"
"    GenEvent.call(pid, LoggerHandler, :messages)\n"
"    #=> [1, 2]\n"
"\n"
"    GenEvent.call(pid, LoggerHandler, :messages)\n"
"    #=> []\n"
"\n"
"We start a new event manager by calling `GenEvent.start_link/0`.\n"
"Notifications can be sent to the event manager which will then\n"
"invoke `handle_event/2` for each registered handler.\n"
"\n"
"We can add new handlers with `add_handler/3` and `add_mon_handler/3`.\n"
"Calls can also be made to specific handlers by using `call/3`.\n"
"\n"
"## Callbacks\n"
"\n"
"There are 6 callbacks required to be implemented in a `GenEvent`. By\n"
"adding `use GenEvent` to your module, Elixir will automatically define\n"
"all 6 callbacks for you, leaving it up to you to implement the ones\n"
"you want to customize. The callbacks are:\n"
"\n"
"  * `init(args)` - invoked when the event handler is added.\n"
"\n"
"    It must return:\n"
"\n"
"    -  `{:ok, state}`\n"
"    -  `{:ok, state, :hibernate}`\n"
"    -  `{:error, reason}`\n"
"\n"
"  * `handle_event(msg, state)` - invoked whenever an event is sent via\n"
"    `notify/2`, `ack_notify/2` or `sync_notify/2`.\n"
"\n"
"    It must return:\n"
"\n"
"    -  `{:ok, new_state}`\n"
"    -  `{:ok, new_state, :hibernate}`\n"
"    -  `:remove_handler`\n"
"\n"
"  * `handle_call(msg, state)` - invoked when a `call/3` is done to a "
"specific\n"
"    handler.\n"
"\n"
"    It must return:\n"
"\n"
"    -  `{:ok, reply, new_state}`\n"
"    -  `{:ok, reply, new_state, :hibernate}`\n"
"    -  `{:remove_handler, reply}`\n"
"\n"
"  * `handle_info(msg, state)` - invoked to handle all other messages which\n"
"    are received by the process. Must return the same values as\n"
"    `handle_event/2`.\n"
"\n"
"  * `terminate(reason, state)` - called when the event handler is removed "
"or\n"
"    the event manager is terminating. It can return any term.\n"
"\n"
"    The reason is one of:\n"
"\n"
"    -  `:stop` - manager is terminating\n"
"    -  `{:stop, reason}` - monitored process terminated (for monitored "
"handlers)\n"
"    -  `:remove_handler` - handler is being removed\n"
"    -  `{:error, term}` - handler crashed or returned a bad value\n"
"    -  `term` - any term passed to functions like `GenEvent."
"remove_handler/2`\n"
"\n"
"  * `code_change(old_vsn, state, extra)` - called when the application\n"
"    code is being upgraded live (hot code swapping).\n"
"\n"
"    It must return:\n"
"\n"
"    -  `{:ok, new_state}`\n"
"\n"
"## Name Registration\n"
"\n"
"A GenEvent is bound to the same name registration rules as a `GenServer`.\n"
"Read more about it in the `GenServer` docs.\n"
"\n"
"## Modes\n"
"\n"
"GenEvent stream supports three different notifications.\n"
"\n"
"On `GenEvent.ack_notify/2`, the manager acknowledges each event,\n"
"providing back pressure, but processing of the message happens\n"
"asynchronously.\n"
"\n"
"On `GenEvent.sync_notify/2`, the manager acknowledges an event\n"
"just after it was processed by all event handlers.\n"
"\n"
"On `GenEvent.notify/2`, all events are processed asynchronously and\n"
"there is no ack (which means there is no backpressure).\n"
"\n"
"## Streaming\n"
"\n"
"`GenEvent` messages can be streamed with the help of `stream/2`.\n"
"Here are some examples:\n"
"\n"
"    stream = GenEvent.stream(pid)\n"
"\n"
"    # Discard the next 10 events\n"
"    _ = Enum.drop(stream, 10)\n"
"\n"
"    # Print all remaining events\n"
"    for event <- stream do\n"
"      IO.inspect event\n"
"    end\n"
"\n"
"## Learn more and compatibility\n"
"\n"
"If you wish to find out more about gen events, Elixir getting started\n"
"guides provide a tutorial-like introduction. The documentation and links\n"
"in Erlang can also provide extra insight.\n"
"\n"
"  * http://elixir-lang.org/getting_started/mix_otp/1.html\n"
"  * http://www.erlang.org/doc/man/gen_event.html\n"
"  * http://learnyousomeerlang.com/event-handlers\n"
"\n"
"Keep in mind though Elixir and Erlang gen events are not 100% compatible.\n"
"The `:gen_event.add_sup_handler/3` is not supported by Elixir's GenEvent,\n"
"which in turn supports `GenEvent.add_mon_handler/3`.\n"
"\n"
"The benefits of the monitoring approach are described in the \"Don't drink\n"
"too much kool aid\" section of the \"Learn you some Erlang\" link above. "
"Due\n"
"to those changes, Elixir's GenEvent does not trap exits by default.\n"
"\n"
"Furthermore, Elixir's also normalizes the `{:error, _}` tuples returned\n"
"by many functions, in order to be more consistent with themselves and\n"
"the `GenServer` module.\n"
msgstr ""
"イベントハンドリング機能を実装するためのビヘイビアモジュールです。\n"
"\n"
"動的に追加・削除を行われる、任意の数のイベントハンドラで、\n"
"イベント処理モデルは一般的なイベントマネージャプロセスから\n"
"なります。\n"
"\n"
"このモジュールを用いて実装されるイベントマネージャは、標準的な\n"
"インタフェース関数のセットを持ち、トレースとエラーレポートの為の\n"
"機能を含みます。\n"
"それはsupervisionツリーにも適合します。\n"
"\n"
"## Example\n"
"\n"
"イベントハンドラのための多くのユースケースがあります。例えば、\n"
"各のログメッセージがイベントであるイベントハンドラを用いて、\n"
"ログシステムは構築することができ、異るログメッセージを処理する\n"
"イベントハンドラをプラグすることも出来ます。\n"
"一つのハンドラはエラーメッセージをターミナルに印字し、\n"
"もう一つのものはファイルに書き込み、第3のものは(バッファのような)\n"
"メモリに、それらが読まれるまで、保存しておくことが出来ます。\n"
"\n"
"例として、明示的に呼び出すまで、メッセージを集めるGenEventを作ってみま\n"
"しょう。\n"
"\n"
"    defmodule LoggerHandler do\n"
"      use GenEvent\n"
"\n"
"      # Callbacks\n"
"\n"
"      def handle_event({:log, x}, messages) do\n"
"        {:ok, [x|messages]}\n"
"      end\n"
"\n"
"      def handle_call(:messages, messages) do\n"
"        {:ok, Enum.reverse(messages), []}\n"
"      end\n"
"    end\n"
"\n"
"    {:ok, pid} = GenEvent.start_link()\n"
"\n"
"    GenEvent.add_handler(pid, LoggerHandler, [])\n"
"    #=> :ok\n"
"\n"
"    GenEvent.notify(pid, {:log, 1})\n"
"    #=> :ok\n"
"\n"
"    GenEvent.notify(pid, {:log, 2})\n"
"    #=> :ok\n"
"\n"
"    GenEvent.call(pid, LoggerHandler, :messages)\n"
"    #=> [1, 2]\n"
"\n"
"    GenEvent.call(pid, LoggerHandler, :messages)\n"
"    #=> []\n"
"\n"
"私達は`GenEvent.start_link/0`を呼ぶことで、新しいイベントマネージャを\n"
"開始します。\n"
"それから、登録されたハンドラ毎に`handle_event/2`を実行するイベント\n"
"マネージャに通知を送ることができます。\n"
"\n"
"私達は`add_handler/3`と`add_mon_handler/3`で新しいハンドラを\n"
"追加します。\n"
"`call/3`を使って特定のハンドラを呼び出すことができます。\n"
"\n"
"## Callbacks\n"
"\n"
"`GenEvent`で実装することが要求されている6個のコールバックがあります。\n"
"`use GenEvent`をあなたのモジュールに追加することにより、Elixir自動的に\n"
"6個のコールバックを定義し、カスタマイズしたいものの実装をあなたに任せます。\n"
"コールバックは:\n"
"\n"
"  * `init(args)` - イベントハンドラが追加されたとき起動されます。\n"
"\n"
"    以下を返さなければなりません:\n"
"\n"
"    -  `{:ok, state}`\n"
"    -  `{:ok, state, :hibernate}`\n"
"    -  `{:error, reason}`\n"
"\n"
"  * `handle_event(msg, state)` - イベントが`notify/2`か\n"
"     `ack_notiry/2'か、`sync_notify/2`により送られたときは\n"
"     何時でも起動されます。\n"
"\n"
"    以下を返さなければなりません:\n"
"\n"
"    -  `{:ok, new_state}`\n"
"    -  `{:ok, new_state, :hibernate}`\n"
"    -  `:remove_handler`\n"
"\n"
"  * `handle_call(msg, state)` - `call/3`が特定のハンドラにされたとき、\n"
"     起動されます。\n"
"\n"
"    以下を返さなければなりません:\n"
"\n"
"    -  `{:ok, reply, new_state}`\n"
"    -  `{:ok, reply, new_state, :hibernate}`\n"
"    -  `{:remove_handler, reply}`\n"
"\n"
"  * `handle_info(msg, state)` - プロセスで受信した他の全てのメッセージを\n"
"    ハンドルするために起動されます。`handle_event/2`と同じ値を返さなければ\n"
"    なりません。\n"
"\n"
"  * `terminate(reason, state)` - イベントハンドラが削除される、あるいは、\n"
"    イベントマネージャが終了されるときに呼び出されます。任意の語を\n"
"    返すことができます。reasonは以下の何れかです:\n"
"\n"
"    -  `:stop` - マネージャが終了します\n"
"    -  `{:stop, reason}` - モニタされたプロセスが終了されました(\n"
"       モニタされたハンドラによって)\n"
"    -  `:remove_handler` - ハンドラが削除されました\n"
"    -  `{:error, term}` - ハンドラがクラッシュしたか、\n"
"       異常な値を返しました\n"
"    -  `term` - 任意のtermは`GenEvent.remove_handler/2`のような関数へ\n"
"       渡されます\n"
"\n"
"  * `code_change(old_vsn, state, extra)` - アプリケーションコードが\n"
"    ライブアップグレード(ホットコードスワッピング)されるときに\n"
"    呼び出されます。\n"
"\n"
"    以下を返さなければなりません:\n"
"\n"
"    -  `{:ok, new_state}`\n"
"\n"
"## Name Registration\n"
"\n"
"GenEventは`GenServer`と同じ名前登録規則に従います。\n"
"それについてはの詳細は、`GenServer`のドキュメントを参照してください。\n"
"\n"
"## Modes\n"
"\n"
"GenEventストリームは3つの異る通知をサポートします。\n"
"\n"
"`GenEvent.ack_notiry/2`では、マネージャがそれぞれのイベントをack\n"
"するバックプレッシャーを提供しますが、メッセージの処理は非同期で\n"
"起ります。\n"
"\n"
"`GenEvent.sync_notiry/2`では、マネージャが、全てのイベントハンド\n"
"ラにより処理されたあと、それぞれのイベントをackします。\n"
"\n"
"`GenEvent.notify/2`では、全てのイベントは非同期で処理され、\n"
"ackはありません(バックプレッシャーがないことを意味します)。\n"
"\n"
"## Streaming\n"
"\n"
"`GenEvent`メッセージは`stream/2`の助けを借りて、ストリーム化\n"
"出来ます。いくつかの例です:\n"
"\n"
"    stream = GenEvent.stream(pid)\n"
"\n"
"    # Discard the next 10 events\n"
"    _ = Enum.drop(stream, 10)\n"
"\n"
"    # Print all remaining events\n"
"    for event <- stream do\n"
"      IO.inspect event\n"
"    end\n"
"\n"
"\n"
"## Learn more and compatibility\n"
"\n"
"gen eventについてもっと知りたいなら、Elixir getting started guide\n"
"がチュートリアルライクの導入を提供します。Erlangのドキュメントとリンク\n"
"もまた、追加の洞察を提供することができます。\n"
"\n"
"  * http://elixir-lang.org/getting_started/mix_otp/1.html\n"
"  * http://www.erlang.org/doc/man/gen_event.html\n"
"  * http://learnyousomeerlang.com/event-handlers\n"
"\n"
"ElixirとErlangのgen eventは100%の互換性がないことを心に留めてお\n"
"いてください。\n"
"`:gen_event.add_sup_handler/3`はElixirのGenEventではサポートされません、\n"
"代わりに`GenEvent.add_mon_handler/3`をサポートします。\n"
"\n"
"モニタアプローチの利点は上のリンク \"Learn you some Erlang\" の \"Don't\n"
"drink too much kool aid\" セクションに記述されています。それらの変更によ\n"
"り、ElixirのGenEventはデフォルトではexitをトラップしません。\n"
"\n"
"さらにまた、Elixirは、`GenEvent`モジュールにあわせるために、\n"
"多くの関数により返される`{:error, _}`タプルを正規化します。\n"
