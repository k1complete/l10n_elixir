#. TRANSLATORS: Elixir.URI Summary
#: lib/uri.ex:1 
msgid ""
"Utilities for working with and creating URIs.\n"
msgstr ""
#. TRANSLATORS: def URI.default_port(scheme, port)
#: lib/uri.ex:63 
msgid ""
"Registers a scheme with a default port.\n"
"\n"
"It is recommended for this function to be invoked in your\n"
"application start callback in case you want to register\n"
"new URIs.\n"
msgstr ""
#. TRANSLATORS: def URI.decode(uri)
#: lib/uri.ex:238 
msgid ""
"Percent-unescapes a URI.\n"
"\n"
"## Examples\n"
"\n"
"    iex> URI.decode(\"http%3A%2F%2Felixir-lang.org\")\n"
"    \"http://elixir-lang.org\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def URI.encode(str, predicate \\ &(char_unescaped? / 1))
#: lib/uri.ex:196 
msgid ""
"Percent-escapes a URI.\n"
"Accepts `predicate` function as an argument to specify if char can be left as is.\n"
"\n"
"## Example\n"
"\n"
"    iex> URI.encode(\"ftp://s-ite.tld/?value=put it+й\")\n"
"    \"ftp://s-ite.tld/?value=put%20it+%D0%B9\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def URI.encode_query(l)
#: lib/uri.ex:85 
msgid ""
"Encodes an enumerable into a query string.\n"
"\n"
"Takes an enumerable (containing a sequence of two-item tuples)\n"
"and returns a string of the form \"key1=value1&key2=value2...\" where\n"
"keys and values are URL encoded as per `encode/2`.\n"
"\n"
"Keys and values can be any term that implements the `String.Chars`\n"
"protocol, except lists which are explicitly forbidden.\n"
"\n"
"## Examples\n"
"\n"
"    iex> hd = %{\"foo\" => 1, \"bar\" => 2}\n"
"    iex> URI.encode_query(hd)\n"
"    \"bar=2&foo=1\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def URI.encode_www_form(str)
#: lib/uri.ex:209 
msgid ""
"Encodes a string as \"x-www-urlencoded\".\n"
"\n"
"## Example\n"
"\n"
"    iex> URI.encode_www_form(\"put: it+й\")\n"
"    \"put%3A+it%2B%D0%B9\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def URI.parse(uri)
#: lib/uri.ex:311 
msgid ""
"Parses a well-formed URI reference into its components.\n"
"\n"
"Note this function expects a well-formed URI and does not perform\n"
"any validation. See the examples section below of how `URI.parse/1`\n"
"can be used to parse a wide range of relative URIs.\n"
"\n"
"This function uses the parsing regular expression as defined\n"
"in the Appendix B of RFC3986.\n"
"\n"
"When a URI is given without a port, the values registered via\n"
"`URI.default_port/1` and `URI.default_port/2` are used.\n"
"\n"
"## Examples\n"
"\n"
"    iex> URI.parse(\"http://elixir-lang.org/\")\n"
"    %URI{scheme: \"http\", path: \"/\", query: nil, fragment: nil,\n"
"         authority: \"elixir-lang.org\", userinfo: nil,\n"
"         host: \"elixir-lang.org\", port: 80}\n"
"\n"
"    iex> URI.parse(\"//elixir-lang.org/\")\n"
"    %URI{authority: \"elixir-lang.org\", fragment: nil, host: \"elixir-lang.org\",\n"
"         path: \"/\", port: nil, query: nil, scheme: nil, userinfo: nil}\n"
"\n"
"    iex> URI.parse(\"/foo/bar\")\n"
"    %URI{authority: nil, fragment: nil, host: nil, path: \"/foo/bar\",\n"
"         port: nil, query: nil, scheme: nil, userinfo: nil}\n"
"\n"
"    iex> URI.parse(\"foo/bar\")\n"
"    %URI{authority: nil, fragment: nil, host: nil, path: \"foo/bar\",\n"
"         port: nil, query: nil, scheme: nil, userinfo: nil}\n"
"\n"
msgstr ""
#. TRANSLATORS: def URI.normalize_scheme(scheme)
#: lib/uri.ex:26 
msgid ""
"Normalizes the scheme according to the spec by downcasing it.\n"
msgstr ""
#. TRANSLATORS: def URI.decode_www_form(str)
#: lib/uri.ex:254 
msgid ""
"Decodes a string as \"x-www-urlencoded\".\n"
"\n"
"## Examples\n"
"\n"
"    iex> URI.decode_www_form(\"%3Call+in%2F\")\n"
"    \"<all in/\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def URI.decode_query(q, dict \\ %{})
#: lib/uri.ex:102 
msgid ""
"Decodes a query string into a dictionary (by default uses a map).\n"
"\n"
"Given a query string of the form \"key1=value1&key2=value2...\", produces a\n"
"map with one entry for each key-value pair. Each key and value will be a\n"
"binary. Keys and values will be percent-unescaped.\n"
"\n"
"Use `query_decoder/1` if you want to iterate over each value manually.\n"
"\n"
"## Examples\n"
"\n"
"    iex> URI.decode_query(\"foo=1&bar=2\")\n"
"    %{\"bar\" => \"2\", \"foo\" => \"1\"}\n"
"\n"
msgstr ""
#. TRANSLATORS: def URI.char_unescaped?(c)
#: lib/uri.ex:182 
msgid ""
"Checks if the character is allowed unescaped in a URI.\n"
"\n"
"This is the default used by `URI.encode/2` where both\n"
"reserved and unreserved characters are kept unescaped.\n"
msgstr ""
#. TRANSLATORS: def URI.char_unreserved?(c)
#: lib/uri.ex:169 
msgid ""
"Checks if the character is a \"unreserved\" character in a URI.\n"
"\n"
"Unreserved characters are specified in RFC3986, section 2.3.\n"
msgstr ""
#. TRANSLATORS: def URI.char_reserved?(c)
#: lib/uri.ex:160 
msgid ""
"Checks if the character is a \"reserved\" character in a URI.\n"
"\n"
"Reserved characters are specified in RFC3986, section 2.2.\n"
msgstr ""
#. TRANSLATORS: def URI.default_port(scheme)
#: lib/uri.ex:27 
msgid ""
"Returns the default port for a given scheme.\n"
"\n"
"If the scheme is unknown to URI, returns `nil`.\n"
"Any scheme may be registered via `default_port/2`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> URI.default_port(\"ftp\")\n"
"    21\n"
"\n"
"    iex> URI.default_port(\"ponzi\")\n"
"    nil\n"
"\n"
msgstr ""
#. TRANSLATORS: def URI.query_decoder(q)
#: lib/uri.ex:116 
msgid ""
"Returns an iterator function over the query string that decodes\n"
"the query string in steps.\n"
"\n"
"## Examples\n"
"\n"
"    iex> URI.query_decoder(\"foo=1&bar=2\") |> Enum.map &(&1)\n"
"    [{\"foo\", \"1\"}, {\"bar\", \"2\"}]\n"
"\n"
msgstr ""
