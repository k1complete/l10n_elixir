msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2015-09-17 18:58+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: Elixir.URI Summary
#: lib/uri.ex:2
msgid "Utilities for working with and creating URIs.\n"
msgstr "URIの作成と動作についてのユーティリティです。\n"

#. TRANSLATORS: def URI.default_port(scheme)
#: lib/uri.ex:14
msgid ""
"Returns the default port for a given scheme.\n"
"\n"
"If the scheme is unknown to URI, returns `nil`.\n"
"Any scheme may be registered via `default_port/2`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> URI.default_port(\"ftp\")\n"
"    21\n"
"\n"
"    iex> URI.default_port(\"ponzi\")\n"
"    nil\n"
"\n"
msgstr ""
"与えられたプロトコルスキームのデフォルトポートを返します。\n"
"\n"
"もしスキームがURIにとって知られていないなら、`nil`を返します。\n"
"任意のスキームは`default_port/2`で登録することができます。\n"
"\n"
"## 例\n"
"\n"
"    iex> URI.default_port(\"ftp\")\n"
"    21\n"
"\n"
"    iex> URI.default_port(\"ponzi\")\n"
"    nil\n"
"\n"

#. TRANSLATORS: def URI.query_decoder(q)
#: lib/uri.ex:85
msgid ""
"Returns an iterator function over the query string that decodes\n"
"the query string in steps.\n"
"\n"
"## Examples\n"
"\n"
"    iex> URI.query_decoder(\"foo=1&bar=2\") |> Enum.map(&(&1))\n"
"    [{\"foo\", \"1\"}, {\"bar\", \"2\"}]\n"
"\n"
msgstr ""
"query stringを一つずつデコードする、\n"
"イテレータ関数を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> URI.query_decoder(\"foo=1&bar=2\") |> Enum.map &(&1)\n"
"    [{\"foo\", \"1\"}, {\"bar\", \"2\"}]\n"
"\n"

#. TRANSLATORS: def URI.default_port(scheme, port)
#: lib/uri.ex:33
msgid ""
"Registers a scheme with a default port.\n"
"\n"
"It is recommended for this function to be invoked in your\n"
"application start callback in case you want to register\n"
"new URIs.\n"
msgstr ""
"スキームのデフォルトポートを登録します。\n"
"\n"
"新しいURIを登録したい場合に備えて、この関数があなたの\n"
"アプリケーションのstartコールバックで実行されることは\n"
"推奨されます。\n"

#. TRANSLATORS: def URI.encode_query(l)
#: lib/uri.ex:44
msgid ""
"Encodes an enumerable into a query string.\n"
"\n"
"Takes an enumerable (containing a sequence of two-item tuples)\n"
"and returns a string of the form \"key1=value1&key2=value2...\" where\n"
"keys and values are URL encoded as per `encode/2`.\n"
"\n"
"Keys and values can be any term that implements the `String.Chars`\n"
"protocol, except lists which are explicitly forbidden.\n"
"\n"
"## Examples\n"
"\n"
"    iex> hd = %{\"foo\" => 1, \"bar\" => 2}\n"
"    iex> URI.encode_query(hd)\n"
"    \"bar=2&foo=1\"\n"
"\n"
msgstr ""
"enumerableをquery stringにエンコードします。\n"
"\n"
"enumerable(2アイテムのタプルのシーケンスを含みます)をとり、\n"
"キーと値がそれぞれ、`encode/2`によりURLエンコードされた、\n"
"フォーム\"key1_value1&key2=value2...\"の文字列を返します。\n"
"\n"
"キーと値は、明確に禁じられているリストを除く、`String.Chars`プロトコル\n"
"を実装した任意のタームが使えます。\n"
"\n"
"## 例\n"
"\n"
"    iex> hd = %{\"foo\" => 1, \"bar\" => 2}\n"
"    iex> URI.encode_query(hd)\n"
"    \"bar=2&foo=1\"\n"
"\n"

#. TRANSLATORS: def URI.encode_www_form(str)
#: lib/uri.ex:179
msgid ""
"Encodes a string as \"x-www-urlencoded\".\n"
"\n"
"## Example\n"
"\n"
"    iex> URI.encode_www_form(\"put: it+й\")\n"
"    \"put%3A+it%2B%D0%B9\"\n"
"\n"
msgstr ""
"\"x-www-urlencoded\"として文字列をエンコードします。\n"
"\n"
"## 例\n"
"\n"
"    iex> URI.encode_www_form(\"put: it+й\")\n"
"    \"put%3A+it%2B%D0%B9\"\n"
"\n"

#. TRANSLATORS: def URI.decode_www_form(str)
#: lib/uri.ex:224
msgid ""
"Decodes a string as \"x-www-urlencoded\".\n"
"\n"
"## Examples\n"
"\n"
"    iex> URI.decode_www_form(\"%3Call+in%2F\")\n"
"    \"<all in/\"\n"
"\n"
msgstr ""
"\"x-www-urlencoded\"として文字列をデコードします。\n"
"\n"
"## 例\n"
"\n"
"    iex> URI.decode_www_form(\"%3Call+in%2F\")\n"
"    \"<all in/\"\n"
"\n"

#. TRANSLATORS: def URI.decode_query(q, dict \\ %{})
#: lib/uri.ex:63
msgid ""
"Decodes a query string into a dictionary (by default uses a map).\n"
"\n"
"Given a query string of the form \"key1=value1&key2=value2...\", produces a\n"
"map with one entry for each key-value pair. Each key and value will be a\n"
"binary. Keys and values will be percent-unescaped.\n"
"\n"
"Use `query_decoder/1` if you want to iterate over each value manually.\n"
"\n"
"## Examples\n"
"\n"
"    iex> URI.decode_query(\"foo=1&bar=2\")\n"
"    %{\"bar\" => \"2\", \"foo\" => \"1\"}\n"
"\n"
msgstr ""
"query stringを辞書(デフォルトではmapを使います)にデコードします。\n"
"\n"
"\"key1=value1&key2=value2...\"形式のquery stringがあれば、\n"
"キー-バリューペア毎に一つのエントリとなるマップを生成します。\n"
"キーと値それぞれはバイナリです。キーと値はパーセントアンエスケープされま"
"す。\n"
"\n"
"それぞれの値を手動で繰り返したいなら、`query_decoder/1`を使ってください。\n"
"\n"
"## 例\n"
"\n"
"    iex> URI.decode_query(\"foo=1&bar=2\")\n"
"    %{\"bar\" => \"2\", \"foo\" => \"1\"}\n"
"\n"

#. TRANSLATORS: def URI.decode(uri)
#: lib/uri.ex:208
msgid ""
"Percent-unescapes a URI.\n"
"\n"
"## Examples\n"
"\n"
"    iex> URI.decode(\"http%3A%2F%2Felixir-lang.org\")\n"
"    \"http://elixir-lang.org\"\n"
"\n"
msgstr ""
"URIをパーセントアンエスケープします。\n"
"\n"
"## 例\n"
"\n"
"    iex> URI.decode(\"http%3A%2F%2Felixir-lang.org\")\n"
"    \"http://elixir-lang.org\"\n"
"\n"

#. TRANSLATORS: def URI.encode(str, predicate \\ &char_unescaped?/1)
#: lib/uri.ex:165
msgid ""
"Percent-escapes a URI.\n"
"Accepts `predicate` function as an argument to specify if char can be left "
"as is.\n"
"\n"
"## Example\n"
"\n"
"    iex> URI.encode(\"ftp://s-ite.tld/?value=put it+й\")\n"
"    \"ftp://s-ite.tld/?value=put%20it+%D0%B9\"\n"
"\n"
msgstr ""
"URIをパーセントエスケープします。\n"
"文字が現状のまま残されるかどうかを決めるための1引数の`predicate`関数\n"
"を受け付けます。\n"
"\n"
"## 例\n"
"\n"
"    iex> URI.encode(\"ftp://s-ite.tld/?value=put it+й\")\n"
"    \"ftp://s-ite.tld/?value=put%20it+%D0%B9\"\n"
"\n"

#. TRANSLATORS: def URI.parse(uri)
#: lib/uri.ex:259
msgid ""
"Parses a well-formed URI reference into its components.\n"
"\n"
"Note this function expects a well-formed URI and does not perform\n"
"any validation. See the examples section below of how `URI.parse/1`\n"
"can be used to parse a wide range of relative URIs.\n"
"\n"
"This function uses the parsing regular expression as defined\n"
"in the [Appendix B of RFC3986](http://tools.ietf.org/html/rfc3986#appendix-"
"B).\n"
"\n"
"When a URI is given without a port, the values registered via\n"
"`URI.default_port/1` and `URI.default_port/2` are used.\n"
"\n"
"## Examples\n"
"\n"
"    iex> URI.parse(\"http://elixir-lang.org/\")\n"
"    %URI{scheme: \"http\", path: \"/\", query: nil, fragment: nil,\n"
"         authority: \"elixir-lang.org\", userinfo: nil,\n"
"         host: \"elixir-lang.org\", port: 80}\n"
"\n"
"    iex> URI.parse(\"//elixir-lang.org/\")\n"
"    %URI{authority: \"elixir-lang.org\", fragment: nil, host: \"elixir-lang."
"org\",\n"
"         path: \"/\", port: nil, query: nil, scheme: nil, userinfo: nil}\n"
"\n"
"    iex> URI.parse(\"/foo/bar\")\n"
"    %URI{authority: nil, fragment: nil, host: nil, path: \"/foo/bar\",\n"
"         port: nil, query: nil, scheme: nil, userinfo: nil}\n"
"\n"
"    iex> URI.parse(\"foo/bar\")\n"
"    %URI{authority: nil, fragment: nil, host: nil, path: \"foo/bar\",\n"
"         port: nil, query: nil, scheme: nil, userinfo: nil}\n"
"\n"
msgstr ""
"well-formdedなURI参照を構成要素にパースします。\n"
"\n"
"この関数はwell-formedなURIを期待していて、如何なるバリデーショ\n"
"ンも実施しないことに注意してください。`URI.parse/1`がどのよう\n"
"に広範囲の相対URIをパースするのに用いられるか下の例のセクショ\n"
"ンを参照してください。\n"
"\n"
"この関数は、[RFC3986のAppendix B]\n"
"(http://tools.ietf.org/html/rfc3986#appendix-B)\n"
"で定義された正規表現を用いてパースします。\n"
"\n"
"URIにポートが与えられないとき、`URI.default_port/1`と\n"
"`URI.default_port/2`で登録された値が使われます。\n"
"\n"
"## 例\n"
"\n"
"    iex> URI.parse(\"http://elixir-lang.org/\")\n"
"    %URI{scheme: \"http\", path: \"/\", query: nil, fragment: nil,\n"
"         authority: \"elixir-lang.org\", userinfo: nil,\n"
"         host: \"elixir-lang.org\", port: 80}\n"
"\n"
"    iex> URI.parse(\"//elixir-lang.org/\")\n"
"    %URI{authority: \"elixir-lang.org\", fragment: nil, host: \"elixir-lang."
"org\",\n"
"         path: \"/\", port: nil, query: nil, scheme: nil, userinfo: nil}\n"
"\n"
"    iex> URI.parse(\"/foo/bar\")\n"
"    %URI{authority: nil, fragment: nil, host: nil, path: \"/foo/bar\",\n"
"         port: nil, query: nil, scheme: nil, userinfo: nil}\n"
"\n"
"    iex> URI.parse(\"foo/bar\")\n"
"    %URI{authority: nil, fragment: nil, host: nil, path: \"foo/bar\",\n"
"         port: nil, query: nil, scheme: nil, userinfo: nil}\n"
"\n"

#. TRANSLATORS: def URI.to_string(uri)
#: lib/uri.ex:346
msgid ""
"Converts the URI to string.\n"
"\n"
"    iex> URI.to_string(URI.parse(\"http://google.com\"))\n"
"    \"http://google.com\"\n"
msgstr ""
"URLを文字列に変換します。\n"
"\n"
"    iex> URI.to_string(URI.parse(\"http://google.com\"))\n"
"    \"http://google.com\"\n"

#. TRANSLATORS: def URI.char_unescaped?(c)
#: lib/uri.ex:155
msgid ""
"Checks if the character is allowed unescaped in a URI.\n"
"\n"
"This is the default used by `URI.encode/2` where both\n"
"reserved and unreserved characters are kept unescaped.\n"
msgstr ""
"文字がURIでアンエスケープが許されるかどうかをチェックします。\n"
"\n"
"予約、実予約文字の両方がアンエスケープでおかれるように、\n"
"これはデフォルトで`URI.encode/2`によって使われます。\n"

#. TRANSLATORS: def URI.char_unreserved?(c)
#: lib/uri.ex:143
msgid ""
"Checks if the character is a \"unreserved\" character in a URI.\n"
"\n"
"Unreserved characters are specified in [RFC3986, section 2.3](http://tools."
"ietf.org/html/rfc3986#section-2.3).\n"
msgstr ""
"文字が、URIの\"非予約(unreserved)\"文字かどうかをチェックします。\n"
"\n"
"非予約(unreserved)文字は、 \n"
"[RFC3986, section 2.3](http://tools.ietf.org/html/rfc3986#section-2.3)\n"
"に定められています。\n"

#. TRANSLATORS: def URI.char_reserved?(c)
#: lib/uri.ex:134
msgid ""
"Checks if the character is a \"reserved\" character in a URI.\n"
"\n"
"Reserved characters are specified in [RFC3986, section 2.2](http://tools."
"ietf.org/html/rfc3986#section-2.2).\n"
msgstr ""
"文字が、URIの\"予約(reserved)\"文字かどうかをチェックします。\n"
"\n"
"予約(reserved)文字は、 \n"
"[RFC3986, section 2.2](http://tools.ietf.org/html/rfc3986#section-2.2)\n"
"に定められています。\n"

#~ msgid "Normalizes the scheme according to the spec by downcasing it.\n"
#~ msgstr "小文字化することにより仕様に従って、schemeを正規化します。\n"
