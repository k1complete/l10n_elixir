msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2015-12-14 14:18+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: Elixir.Inspect Summary
#: lib/inspect.ex:5
msgid ""
"The `Inspect` protocol is responsible for converting any Elixir\n"
"data structure into an algebra document. This document is then\n"
"formatted, either in pretty printing format or a regular one.\n"
"\n"
"The `inspect/2` function receives the entity to be inspected\n"
"followed by the inspecting options, represented by the struct\n"
"`Inspect.Opts`.\n"
"\n"
"Inspection is done using the functions available in `Inspect.Algebra`.\n"
"\n"
"## Examples\n"
"\n"
"Many times, inspecting a structure can be implemented in function\n"
"of existing entities. For example, here is `MapSet`'s `inspect`\n"
"implementation:\n"
"\n"
"    defimpl Inspect, for: MapSet do\n"
"      import Inspect.Algebra\n"
"\n"
"      def inspect(dict, opts) do\n"
"        concat [\"#MapSet<\", to_doc(MapSet.to_list(dict), opts), \">\"]\n"
"      end\n"
"    end\n"
"\n"
"The `concat` function comes from `Inspect.Algebra` and it\n"
"concatenates algebra documents together. In the example above,\n"
"it is concatenating the string `\"MapSet<\"` (all strings are\n"
"valid algebra documents that keep their formatting when pretty\n"
"printed), the document returned by `Inspect.Algebra.to_doc/2` and the\n"
"other string `\">\"`.\n"
"\n"
"Since regular strings are valid entities in an algebra document,\n"
"an implementation of inspect may simply return a string,\n"
"although that will devoid it of any pretty-printing.\n"
"\n"
"## Error handling\n"
"\n"
"In case there is an error while your structure is being inspected,\n"
"Elixir will raise an `ArgumentError` error and will automatically fall back\n"
"to a raw representation for printing the structure.\n"
"\n"
"You can however access the underlying error by invoking the Inspect\n"
"implementation directly. For example, to test Inspect.MapSet above,\n"
"you can invoke it as:\n"
"\n"
"    Inspect.MapSet.inspect(MapSet.new, Inspect.Opts.new)\n"
"\n"
msgstr ""
"`Inspect`プロトコルは、任意のElixirデータ構造を、代数学ドキュメントに変\n"
"換する役割りを果します。このドキュメントはプリティプリンティング\n"
"か標準の物のいずれかにフォーマットされます。\n"
"\n"
"`inspect/2`関数は`Inspect.Opts`構造体ににより表現されたインスペクト\n"
"オプションによりインスペクトされるエンティティを受け取ります。\n"
"\n"
"インスペクトは`Inspect.Algebra`で利用できる関数を使用して行われます。\n"
"\n"
"## 例\n"
"\n"
"しばしば、構造を調べることは、既存のエンティティの\n"
"関数で実装されることができます。例えば、`MapSet`の`inspect`実装は\n"
"こうです:\n"
"\n"
"    defimpl Inspect, for: MapSet do\n"
"      import Inspect.Algebra\n"
"\n"
"      def inspect(dict, opts) do\n"
"        concat [\"#MapSet<\", to_doc(MapSet.to_list(dict), opts), \">\"]\n"
"      end\n"
"    end\n"
"\n"
"`concat`関数は`Inspect.Algebra`から来ていて、それは一緒に代数学ドキュメ\n"
"ントを連結します。上の例では、文字列`\"MapSet<\"`(全ての文字列はプリティ\n"
"プリントされた時に書式が保持される有効なAlgebraです)と、\n"
"`Inspect.Algebra.to_doc/2`関数の戻値と、文字列`\">\"`とが連結されます。\n"
"\n"
"普通の文字列は代数学ドキュメントの有効なエンティティですので、調査の実\n"
"装は任意のプリティプリンティングを取り去り、単に文字列を返すかもしれま\n"
"せん。\n"
"\n"
"## エラーハンドリング\n"
"\n"
"あなたの構造体の調査中にエラーがあった場合、Elixirは\n"
"`ArgumentError`エラーを上げ、自動的に構造体のraw表現に\n"
"フォールバックします。\n"
"\n"
"しかしながら、Inspect実装を直接実行することで根底にあるエラーにアクセス\n"
"することができます。例えば、上のInspect.MapSetをテストするために、\n"
"それを実行することができます:\n"
"\n"
"    Inspect.MapSet.inspect(MapSet.new, Inspect.Opts.new)\n"
"\n"
