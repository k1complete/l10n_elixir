msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2015-12-12 22:23+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: def Agent.cast(agent, fun)
#: lib/agent.ex:271
msgid ""
"Performs a cast (fire and forget) operation on the agent state.\n"
"\n"
"The function `fun` is sent to the `agent` which invokes the function\n"
"passing the agent state. The function must return the new state.\n"
"\n"
"Note that `cast` returns `:ok` immediately, regardless of whether the\n"
"destination node or agent exists.\n"
msgstr ""
"エージェントのステートでキャスト(発火して忘れる)オペレーションを実行しま"
"す。\n"
"\n"
"関数`fun`は`agent`に送られ、エージェントステートを渡されて実行されます。\n"
"関数は新しいステートを返さなければなりません。\n"
"\n"
"送信先のノードあるいはエージェントの存在の有無に拘わらず、`cast`は\n"
"`:ok`を直ちに返すことに注意してください。\n"

#. TRANSLATORS: @type name
#: lib/agent.ex:111
msgid "The agent name"
msgstr "エージェントの名前"

#. TRANSLATORS: @type agent
#: lib/agent.ex:114
msgid "The agent reference"
msgstr "エージェントのリファレンス"

#. TRANSLATORS: def Agent.update(agent, fun, timeout \\ 5000)
#: lib/agent.ex:245
msgid ""
"Updates the agent state.\n"
"\n"
"The function `fun` is sent to the `agent` which invokes the function\n"
"passing the agent state. The function must return the new state.\n"
"\n"
"A timeout can also be specified (it has a default value of 5000).\n"
"This function always returns `:ok`.\n"
msgstr ""
"エージェントステートを更新します。\n"
"\n"
"エージェントステートを関数にわたしてその関数を呼び出す`agent`へ\n"
"`fun`関数は送信されます。\n"
"関数は新しいステートを返さなければなりません。\n"
"\n"
"タイムアウトを指定することもできます(デフォルト値は5000です)。\n"
"この関数は常に`:ok`を返します。\n"

#. TRANSLATORS: def Agent.stop(agent, reason \\ :normal, timeout \\ :infinity)
#: lib/agent.ex:297
msgid ""
"Stops the agent with the given `reason`.\n"
"\n"
"It returns `:ok` if the server terminates with the given\n"
"reason, if it terminates with another reason, the call will\n"
"exit.\n"
"\n"
"This function keeps OTP semantics regarding error reporting.\n"
"If the reason is any other than `:normal`, `:shutdown` or\n"
"`{:shutdown, _}`, an error report will be logged.\n"
msgstr ""
"与えられた`reason`でエージェントを停止します。\n"
"\n"
"もしサーバが与えられたreasonで終了したら `:ok` を返し、\n"
"他の reason で終了したら exit を呼びます。\n"
"\n"
"この関数は OTPのエラーレポーティングのセマンティクスを\n"
"尊重します。`:normal`, `:shutdown` あるいは `{:shutdown, _}`\n"
"以外の reason なら、エラーレポートはログされるでしょう。\n"

#. TRANSLATORS: def Agent.update(agent, module, fun, args, timeout \\ 5000)
#: lib/agent.ex:259
msgid ""
"Updates the agent state.\n"
"\n"
"Same as `update/3` but a module, function and args are expected\n"
"instead of an anonymous function. The state is added as first\n"
"argument to the given list of args.\n"
msgstr ""
"エージェントステートを更新します。\n"
"\n"
"`update/3`と同じですが、無名関数のかわりにモジュール、関数、引数を指定\n"
"します。ステートは与えられた引数リストの最初の引数として追加されます。\n"

#. TRANSLATORS: @type state
#: lib/agent.ex:117
msgid "The agent state"
msgstr "エージェントのステート"

#. TRANSLATORS: def Agent.start_link(fun, options \\ [])
#: lib/agent.ex:120
msgid ""
"Starts an agent linked to the current process with the given function.\n"
"\n"
"This is often used to start the agent as part of a supervision tree.\n"
"\n"
"Once the agent is spawned, the given function is invoked and its return\n"
"value is used as the agent state. Note that `start_link` does not return\n"
"until the given function has returned.\n"
"\n"
"## Options\n"
"\n"
"The `:name` option is used for registration as described in the module\n"
"documentation.\n"
"\n"
"If the `:timeout` option is present, the agent is allowed to spend at most\n"
"the given number of milliseconds on initialization or it will be terminated\n"
"and the start function will return `{:error, :timeout}`.\n"
"\n"
"If the `:debug` option is present, the corresponding function in the\n"
"[`:sys` module](http://www.erlang.org/doc/man/sys.html) will be invoked.\n"
"\n"
"If the `:spawn_opt` option is present, its value will be passed as options\n"
"to the underlying process as in `Process.spawn/4`.\n"
"\n"
"## Return values\n"
"\n"
"If the server is successfully created and initialized, the function returns\n"
"`{:ok, pid}`, where `pid` is the pid of the server. If an agent with the\n"
"specified name already exists, the function returns\n"
"`{:error, {:already_started, pid}}` with the pid of that process.\n"
"\n"
"If the given function callback fails with `reason`, the function returns\n"
"`{:error, reason}`.\n"
msgstr ""
"与えられた関数で、現在のプロセスにリンクされたエージェントを開始します。\n"
"\n"
"これは、しばしば監督ツリーの一部としてエージェントを開始するために\n"
"使われます。\n"
"\n"
"一旦エージェントが生成されると、与えられた関数は実行され、\n"
"その戻値はエージェントのステートとして使われます。`start_link`は、\n"
"与えられた関数が戻るまでは、戻って来ないことに注意してください。\n"
"\n"
"## オプション\n"
"\n"
"`:name`オプションはモジュールドキュメントで記載されているように、\n"
"登録の為に使われます。\n"
"\n"
"`:timeout`オプションがあると、エージェントは、最大\n"
"初期値として与えられたミリセカンド秒間起動に時間をかけることを\n"
"許可します。あるいは、エージェントの起動は終了させられて、\n"
"スタート関数は`{:error, :timeout}`を返します。\n"
"\n"
"`:debug`オプションがあると、[`:sys` モジュール](http://www.erlang.org/doc/"
"man/sys.html) で対応する関数が起動されます。\n"
"\n"
"`:spawn_opt`があると、その値は`Process.spawn/4`のように根底にある\n"
"プロセスまでオプションとして渡されます。\n"
"\n"
"## 戻値\n"
"\n"
"もしサーバがうまく作成されて、初期化されたら、関数は、pidをサーバのプロ\n"
"セス識別子として`{:ok, pid}`を返します。もし与えられた名前でエージェン\n"
"トが既に存在したら、そのプロセスのプロセス識別子をpidとして、関数は\n"
"`{:error, {:already_started, pid}}`を返します。\n"
"\n"
"もし与えられたコールバック関数が`reason`で失敗したら、\n"
"関数は`{:error, reason}`を返します。\n"

#. TRANSLATORS: Elixir.Agent Summary
#: lib/agent.ex:2
msgid ""
"Agents are a simple abstraction around state.\n"
"\n"
"Often in Elixir there is a need to share or store state that\n"
"must be accessed from different processes or by the same process\n"
"at different points in time.\n"
"\n"
"The Agent module provides a basic server implementation that\n"
"allows state to be retrieved and updated via a simple API.\n"
"\n"
"## Examples\n"
"\n"
"For example, in the Mix tool that ships with Elixir, we need\n"
"to keep a set of all tasks executed by a given project. Since\n"
"this set is shared, we can implement it with an Agent:\n"
"\n"
"    defmodule Mix.TasksServer do\n"
"      def start_link do\n"
"        Agent.start_link(fn -> MapSet.new end, name: __MODULE__)\n"
"      end\n"
"\n"
"      @doc \"Checks if the task has already executed\"\n"
"      def executed?(task, project) do\n"
"        item = {task, project}\n"
"        Agent.get(__MODULE__, fn set ->\n"
"          item in set\n"
"        end)\n"
"      end\n"
"\n"
"      @doc \"Marks a task as executed\"\n"
"      def put_task(task, project) do\n"
"        item = {task, project}\n"
"        Agent.update(__MODULE__, &MapSet.put(&1, item))\n"
"      end\n"
"\n"
"      @doc \"Resets the executed tasks and returns the previous list of tasks"
"\"\n"
"      def take_all() do\n"
"        Agent.get_and_update(__MODULE__, fn set ->\n"
"          {Enum.into(set, []), MapSet.new}\n"
"        end)\n"
"      end\n"
"    end\n"
"\n"
"Note that agents still provide a segregation between the\n"
"client and server APIs, as seen in GenServers. In particular,\n"
"all code inside the function passed to the agent is executed\n"
"by the agent. This distinction is important because you may\n"
"want to avoid expensive operations inside the agent, as it will\n"
"effectively block the agent until the request is fulfilled.\n"
"\n"
"Consider these two examples:\n"
"\n"
"    # Compute in the agent/server\n"
"    def get_something(agent) do\n"
"      Agent.get(agent, fn state -> do_something_expensive(state) end)\n"
"    end\n"
"\n"
"    # Compute in the agent/client\n"
"    def get_something(agent) do\n"
"      Agent.get(agent, &(&1)) |> do_something_expensive()\n"
"    end\n"
"\n"
"The first function blocks the agent. The second function copies\n"
"all the state to the client and then executes the operation in the\n"
"client. The difference is whether the data is large enough to require\n"
"processing in the server, at least initially, or small enough to be\n"
"sent to the client cheaply.\n"
"\n"
"## Name Registration\n"
"\n"
"An Agent is bound to the same name registration rules as GenServers.\n"
"Read more about it in the `GenServer` docs.\n"
"\n"
"## A word on distributed agents\n"
"\n"
"It is important to consider the limitations of distributed agents. Agents\n"
"provide two APIs, one that works with anonymous functions and another\n"
"that expects an explicit module, function, and arguments.\n"
"\n"
"In a distributed setup with multiple nodes, the API that accepts anonymous\n"
"functions only works if the caller (client) and the agent have the same\n"
"version of the caller module.\n"
"\n"
"Keep in mind this issue also shows up when performing \"rolling upgrades\"\n"
"with agents. By rolling upgrades we mean the following situation: you wish\n"
"to deploy a new version of your software by *shutting down* some of your\n"
"nodes and replacing them with nodes running a new version of the software.\n"
"In this setup, part of your environment will have one version of a given\n"
"module and the other part another version (the newer one) of the same "
"module.\n"
"\n"
"The best solution is to simply use the explicit module, function, and "
"arguments\n"
"APIs when working with distributed agents.\n"
"\n"
"## Hot code swapping\n"
"\n"
"An agent can have its code hot swapped live by simply passing a module,\n"
"function, and args tuple to the update instruction. For example, imagine\n"
"you have an agent named `:sample` and you want to convert its inner state\n"
"from some dict structure to a map. It can be done with the following\n"
"instruction:\n"
"\n"
"    {:update, :sample, {:advanced, {Enum, :into, [%{}]}}}\n"
"\n"
"The agent's state will be added to the given list as the first argument.\n"
msgstr ""
"Agentはステートまわりの単純な抽象です。\n"
"\n"
"Elixirではしばしば、異るプロセスから、または、同じプロセスの\n"
"異る時点により、アクセスされなければならないステートを、\n"
"保存または共有する必要があります。\n"
"\n"
"Agentモジュールは、シンプルなAPIによりステートを取り出したり更新される\n"
"のを許す、基本的なサーバ実装を提供します。\n"
"\n"
"## 例\n"
"\n"
"例えば、Elixirに同梱されているMixツールでは、与えられたプロジェクトによ\n"
"り実行された全てのタスクの集合を、保持しておく必要があります。\n"
"この集合が共有されるので、それをAgentで実装できます:\n"
"\n"
"    defmodule Mix.TasksServer do\n"
"      def start_link do\n"
"        Agent.start_link(fn -> HashSet.new end, name: __MODULE__)\n"
"      end\n"
"\n"
"      @doc \"Checks if the task has already executed\"\n"
"      def executed?(task, project) do\n"
"        item = {task, project}\n"
"        Agent.get(__MODULE__, fn set ->\n"
"          item in set\n"
"        end)\n"
"      end\n"
"\n"
"      @doc \"Marks a task as executed\"\n"
"      def put_task(task, project) do\n"
"        item = {task, project}\n"
"        Agent.update(__MODULE__, &Set.put(&1, item))\n"
"      end\n"
"\n"
"      @doc \"Resets the executed tasks and return the previous list of tasks"
"\"\n"
"      def take_all() do\n"
"        Agent.get_and_update(__MODULE__, fn set ->\n"
"          {Enum.into(set, []), HashSet.new}\n"
"        end)\n"
"      end\n"
"    end\n"
"\n"
"GenServerで見られるように、まだエージェントはクライアントとサーバAPIの\n"
"間で分離を提供する点に注意してください。特に、エージェントに渡される関\n"
"数の内側の全てのコードはエージェントによって実行されます。要求が満され\n"
"るまで、それがエージェントを効果的にブロックするため、高価なオペレーショ\n"
"ンを避けたいと、あなたは思うかもしれないので、この区別は重要です。\n"
"\n"
"二つの例を考えてみてください:\n"
"\n"
"    # Compute in the agent/server\n"
"    def get_something(agent) do\n"
"      Agent.get(agent, fn state -> do_something_expensive(state) end)\n"
"    end\n"
"\n"
"    # Compute in the agent/client\n"
"    def get_something(agent) do\n"
"      Agent.get(agent, &(&1)) |> do_something_expensive()\n"
"    end\n"
"\n"
"第2のものが全てのステートをクライアントへコピーして、\n"
"クライアントでオペレーションを実行する間、最初のものはエージェントを\n"
"ブロックします。\n"
"データが安くクライアントに送信されるのに十分に小さいか、\n"
"サーバで要求を処理(あるいは少なくとも初期処理)するのに十分に大きいかの、\n"
"これは正にトレードオフです。\n"
"\n"
"## Name Registration\n"
"\n"
"AgentはGenServerと同じ名前登録規則に束縛されます。\n"
"それについては`GenServer`のドキュメントを参照してください。\n"
"\n"
"## A word on distributed agents\n"
"\n"
"分散されたエージェントの制限を考慮することは重要です。Agentは、\n"
"二つのAPIを提供します。一つは無名関数で動くものと、もう一つは\n"
"明示的なモジュール、関数、引数を期待するものです。\n"
"\n"
"複数のノードによる分散セットアップにおいて、呼び出し側(クライアント)と\n"
"エージェントが呼び出し側と同じバージョンのモジュールをもっていれば、\n"
"そのときだけ、無名関数を受け付けるAPIは動作します。\n"
"\n"
"エージェントで\"ローリングアップグレード\"を実行する時にも、この問題が表\n"
"れることを心にとめておいてください。ローリングアップグレードにより、以\n"
"下のシチュエーションを意味しています:あなたは、ノードの幾つかを*シャッ\n"
"トダウン*して、ソフトウエアの新しいバージョンを走らせているノードと入れ\n"
"替えることによって、ソフトウエアの新しいバージョンをデプロイしたい。こ\n"
"のセットアップにおいて、あなたの環境の一部は与えられたモジュールの一つ\n"
"のバージョンを持ち、他の一部は、同じモジュールのもう一つのバージョン(よ\n"
"り新しいもの)を持ちます。\n"
"\n"
"最高の解決策は、単に、分散されたエージェントで動かすとき、明示的なモ\n"
"ジュール、関数、引数APIを使うことです。\n"
"\n"
"## Hot code swapping\n"
"\n"
"エージェントは、単にupdate命令にモジュール、関数、引数タプルを送ること\n"
"で、ホットコードスワッピングができます。例えば、`:sample`と名付けられた\n"
"エージェントを持っていて、その内部ステートのいくつかをdict構造から\n"
"mapへ変換したいとします。以下の命令でそれができます:\n"
"\n"
"    {:update, :sample, {:advanced, {Enum, :into, [%{}]}}}\n"
"\n"
"エージェントのステートは最初の引数として与えられたリストに\n"
"加えられます。\n"

#. TRANSLATORS: def Agent.start(module, fun, args, options \\ [])
#: lib/agent.ex:181
msgid ""
"Starts an agent with the given module function and arguments.\n"
"\n"
"Similar to `start/2` but a module, function and args are expected\n"
"instead of an anonymous function.\n"
msgstr ""
"与えられたモジュールと関数、引数でエージェントを開始します。\n"
"\n"
"`start/2`と似ていますが、無名関数の替わりに、\n"
"モジュール、関数、引数を期待しています。\n"

#. TRANSLATORS: def Agent.cast(agent, module, fun, args)
#: lib/agent.ex:285
msgid ""
"Performs a cast (fire and forget) operation on the agent state.\n"
"\n"
"Same as `cast/2` but a module, function and args are expected\n"
"instead of an anonymous function. The state is added as first\n"
"argument to the given list of args.\n"
msgstr ""
"エージェントのステートでキャスト(発火して忘れる)オペレーションを実行しま"
"す。\n"
"\n"
"`cast/2`と同じですが、無名関数のかわりに、モジュール、関数、引数を明示\n"
"してます。ステートは与えられた引数リストの最初に追加されます。関数\n"
"`fun`は`agent`に送られ、エージェントステートを渡されて実行されます。\n"

#. TRANSLATORS: def Agent.get(agent, fun, timeout \\ 5000)
#: lib/agent.ex:192
msgid ""
"Gets an agent value via the given function.\n"
"\n"
"The function `fun` is sent to the `agent` which invokes the function\n"
"passing the agent state. The result of the function invocation is\n"
"returned.\n"
"\n"
"A timeout can also be specified (it has a default value of 5000).\n"
msgstr ""
"与えられた関数によってエージェントの値を取得します。\n"
"\n"
"`fun`関数は、エージェントステートを渡して実行する`agent`に送られます。\n"
"関数の実行結果が返されます。\n"
"\n"
"タイムアウトも指定することができます(デフォルト値は5000です)。\n"

#. TRANSLATORS: def Agent.get(agent, module, fun, args, timeout \\ 5000)
#: lib/agent.ex:206
msgid ""
"Gets an agent value via the given function.\n"
"\n"
"Same as `get/3` but a module, function and args are expected\n"
"instead of an anonymous function. The state is added as first\n"
"argument to the given list of args.\n"
msgstr ""
"与えられた関数によってエージェントの値を取得します。\n"
"\n"
"`get/3`と同じですが、無名関数の替りに、モジュール、関数、そ\n"
"して引数が期待されます。ステートは与えられた引数リストの最初の引数とし\n"
"て追加されます。\n"

#. TRANSLATORS: def Agent.get_and_update(agent, module, fun, args, timeout \\ 5000)
#: lib/agent.ex:233
msgid ""
"Gets and updates the agent state in one operation.\n"
"\n"
"Same as `get_and_update/3` but a module, function and args are expected\n"
"instead of an anonymous function. The state is added as first\n"
"argument to the given list of args.\n"
msgstr ""
"一つのオペレーションで、エージェントステートを取得して更新します。\n"
"\n"
"`get_and_update/3`と同じですが、無名関数の替りに、モジュール、関数、そ\n"
"して引数が期待されます。ステートは与えられた引数リストの最初の引数とし\n"
"て追加されます。\n"

#. TRANSLATORS: def Agent.start(fun, options \\ [])
#: lib/agent.ex:171
msgid ""
"Starts an agent process without links (outside of a supervision tree).\n"
"\n"
"See `start_link/2` for more information.\n"
msgstr ""
"エージェントプロセスをリンクなし(監督ツリーの外側)で開始します。\n"
"\n"
"詳細は `start_link/2` を参照してください。\n"

#. TRANSLATORS: def Agent.get_and_update(agent, fun, timeout \\ 5000)
#: lib/agent.ex:218
msgid ""
"Gets and updates the agent state in one operation.\n"
"\n"
"The function `fun` is sent to the `agent` which invokes the function\n"
"passing the agent state. The function must return a tuple with two\n"
"elements, the first being the value to return (i.e. the `get` value)\n"
"and the second one is the new state.\n"
"\n"
"A timeout can also be specified (it has a default value of 5000).\n"
msgstr ""
"一つのオペレーションで、エージェントステートを取得して更新します。\n"
"\n"
"`fun`関数は、エージェントステートを渡して実行する`agent`に送られます。\n"
"関数は、最初の要素は返される値(即ち`get`した値)で、二つめの要素は\n"
"新しいステートとなる、二つの要素のタプルを返さなくてはなりません。\n"
"\n"
"タイムアウトも指定することができます(デフォルト値は5000です)。\n"

#. TRANSLATORS: def Agent.start_link(module, fun, args, options \\ [])
#: lib/agent.ex:159
msgid ""
"Starts an agent linked to the current process with the given module\n"
"function and arguments.\n"
"\n"
"Same as `start_link/2` but a module, function and args are expected\n"
"instead of an anonymous function.\n"
msgstr ""
"与えられたモジュール、関数、引数で現在のプロセスにリンクされた\n"
"エージェントを開始します。\n"
"\n"
"`start_link/2`と同じですが、無名関数の替わりに、モジュール、関数、引数\n"
"を期待しています。\n"
