#. TRANSLATORS: @type name
#: lib/agent.ex:111 
msgid ""
"The agent name"
msgstr ""
#. TRANSLATORS: @type agent
#: lib/agent.ex:114 
msgid ""
"The agent reference"
msgstr ""
#. TRANSLATORS: def Agent.update(agent, fun, timeout \\ 5000)
#: lib/agent.ex:245 
msgid ""
"Updates the agent state.\n"
"\n"
"The function `fun` is sent to the `agent` which invokes the function\n"
"passing the agent state. The function must return the new state.\n"
"\n"
"A timeout can also be specified (it has a default value of 5000).\n"
"This function always returns `:ok`.\n"
msgstr ""
#. TRANSLATORS: def Agent.cast(agent, fun)
#: lib/agent.ex:271 
msgid ""
"Performs a cast (fire and forget) operation on the agent state.\n"
"\n"
"The function `fun` is sent to the `agent` which invokes the function\n"
"passing the agent state. The function must return the new state.\n"
"\n"
"Note that `cast` returns `:ok` immediately, regardless of whether the\n"
"destination node or agent exists.\n"
msgstr ""
#. TRANSLATORS: def Agent.stop(agent, reason \\ :normal, timeout \\ :infinity)
#: lib/agent.ex:297 
msgid ""
"Stops the agent with the given `reason`.\n"
"\n"
"It returns `:ok` if the server terminates with the given\n"
"reason, if it terminates with another reason, the call will\n"
"exit.\n"
"\n"
"This function keeps OTP semantics regarding error reporting.\n"
"If the reason is any other than `:normal`, `:shutdown` or\n"
"`{:shutdown, _}`, an error report will be logged.\n"
msgstr ""
#. TRANSLATORS: def Agent.update(agent, module, fun, args, timeout \\ 5000)
#: lib/agent.ex:259 
msgid ""
"Updates the agent state.\n"
"\n"
"Same as `update/3` but a module, function and args are expected\n"
"instead of an anonymous function. The state is added as first\n"
"argument to the given list of args.\n"
msgstr ""
#. TRANSLATORS: @type state
#: lib/agent.ex:117 
msgid ""
"The agent state"
msgstr ""
#. TRANSLATORS: def Agent.start_link(fun, options \\ [])
#: lib/agent.ex:120 
msgid ""
"Starts an agent linked to the current process with the given function.\n"
"\n"
"This is often used to start the agent as part of a supervision tree.\n"
"\n"
"Once the agent is spawned, the given function is invoked and its return\n"
"value is used as the agent state. Note that `start_link` does not return\n"
"until the given function has returned.\n"
"\n"
"## Options\n"
"\n"
"The `:name` option is used for registration as described in the module\n"
"documentation.\n"
"\n"
"If the `:timeout` option is present, the agent is allowed to spend at most\n"
"the given number of milliseconds on initialization or it will be terminated\n"
"and the start function will return `{:error, :timeout}`.\n"
"\n"
"If the `:debug` option is present, the corresponding function in the\n"
"[`:sys` module](http://www.erlang.org/doc/man/sys.html) will be invoked.\n"
"\n"
"If the `:spawn_opt` option is present, its value will be passed as options\n"
"to the underlying process as in `Process.spawn/4`.\n"
"\n"
"## Return values\n"
"\n"
"If the server is successfully created and initialized, the function returns\n"
"`{:ok, pid}`, where `pid` is the pid of the server. If an agent with the\n"
"specified name already exists, the function returns\n"
"`{:error, {:already_started, pid}}` with the pid of that process.\n"
"\n"
"If the given function callback fails with `reason`, the function returns\n"
"`{:error, reason}`.\n"
msgstr ""
#. TRANSLATORS: def Agent.get(agent, fun, timeout \\ 5000)
#: lib/agent.ex:192 
msgid ""
"Gets an agent value via the given function.\n"
"\n"
"The function `fun` is sent to the `agent` which invokes the function\n"
"passing the agent state. The result of the function invocation is\n"
"returned.\n"
"\n"
"A timeout can also be specified (it has a default value of 5000).\n"
msgstr ""
#. TRANSLATORS: def Agent.get(agent, module, fun, args, timeout \\ 5000)
#: lib/agent.ex:206 
msgid ""
"Gets an agent value via the given function.\n"
"\n"
"Same as `get/3` but a module, function and args are expected\n"
"instead of an anonymous function. The state is added as first\n"
"argument to the given list of args.\n"
msgstr ""
#. TRANSLATORS: Elixir.Agent Summary
#: lib/agent.ex:2 
msgid ""
"Agents are a simple abstraction around state.\n"
"\n"
"Often in Elixir there is a need to share or store state that\n"
"must be accessed from different processes or by the same process\n"
"at different points in time.\n"
"\n"
"The Agent module provides a basic server implementation that\n"
"allows state to be retrieved and updated via a simple API.\n"
"\n"
"## Examples\n"
"\n"
"For example, in the Mix tool that ships with Elixir, we need\n"
"to keep a set of all tasks executed by a given project. Since\n"
"this set is shared, we can implement it with an Agent:\n"
"\n"
"    defmodule Mix.TasksServer do\n"
"      def start_link do\n"
"        Agent.start_link(fn -> MapSet.new end, name: __MODULE__)\n"
"      end\n"
"\n"
"      @doc \"Checks if the task has already executed\"\n"
"      def executed?(task, project) do\n"
"        item = {task, project}\n"
"        Agent.get(__MODULE__, fn set ->\n"
"          item in set\n"
"        end)\n"
"      end\n"
"\n"
"      @doc \"Marks a task as executed\"\n"
"      def put_task(task, project) do\n"
"        item = {task, project}\n"
"        Agent.update(__MODULE__, &MapSet.put(&1, item))\n"
"      end\n"
"\n"
"      @doc \"Resets the executed tasks and returns the previous list of tasks\"\n"
"      def take_all() do\n"
"        Agent.get_and_update(__MODULE__, fn set ->\n"
"          {Enum.into(set, []), MapSet.new}\n"
"        end)\n"
"      end\n"
"    end\n"
"\n"
"Note that agents still provide a segregation between the\n"
"client and server APIs, as seen in GenServers. In particular,\n"
"all code inside the function passed to the agent is executed\n"
"by the agent. This distinction is important because you may\n"
"want to avoid expensive operations inside the agent, as it will\n"
"effectively block the agent until the request is fulfilled.\n"
"\n"
"Consider these two examples:\n"
"\n"
"    # Compute in the agent/server\n"
"    def get_something(agent) do\n"
"      Agent.get(agent, fn state -> do_something_expensive(state) end)\n"
"    end\n"
"\n"
"    # Compute in the agent/client\n"
"    def get_something(agent) do\n"
"      Agent.get(agent, &(&1)) |> do_something_expensive()\n"
"    end\n"
"\n"
"The first function blocks the agent. The second function copies\n"
"all the state to the client and then executes the operation in the\n"
"client. The difference is whether the data is large enough to require\n"
"processing in the server, at least initially, or small enough to be\n"
"sent to the client cheaply.\n"
"\n"
"## Name Registration\n"
"\n"
"An Agent is bound to the same name registration rules as GenServers.\n"
"Read more about it in the `GenServer` docs.\n"
"\n"
"## A word on distributed agents\n"
"\n"
"It is important to consider the limitations of distributed agents. Agents\n"
"provide two APIs, one that works with anonymous functions and another\n"
"that expects an explicit module, function, and arguments.\n"
"\n"
"In a distributed setup with multiple nodes, the API that accepts anonymous\n"
"functions only works if the caller (client) and the agent have the same\n"
"version of the caller module.\n"
"\n"
"Keep in mind this issue also shows up when performing \"rolling upgrades\"\n"
"with agents. By rolling upgrades we mean the following situation: you wish\n"
"to deploy a new version of your software by *shutting down* some of your\n"
"nodes and replacing them with nodes running a new version of the software.\n"
"In this setup, part of your environment will have one version of a given\n"
"module and the other part another version (the newer one) of the same module.\n"
"\n"
"The best solution is to simply use the explicit module, function, and arguments\n"
"APIs when working with distributed agents.\n"
"\n"
"## Hot code swapping\n"
"\n"
"An agent can have its code hot swapped live by simply passing a module,\n"
"function, and args tuple to the update instruction. For example, imagine\n"
"you have an agent named `:sample` and you want to convert its inner state\n"
"from some dict structure to a map. It can be done with the following\n"
"instruction:\n"
"\n"
"    {:update, :sample, {:advanced, {Enum, :into, [%{}]}}}\n"
"\n"
"The agent's state will be added to the given list as the first argument.\n"
msgstr ""
#. TRANSLATORS: def Agent.start(module, fun, args, options \\ [])
#: lib/agent.ex:181 
msgid ""
"Starts an agent with the given module function and arguments.\n"
"\n"
"Similar to `start/2` but a module, function and args are expected\n"
"instead of an anonymous function.\n"
msgstr ""
#. TRANSLATORS: def Agent.cast(agent, module, fun, args)
#: lib/agent.ex:285 
msgid ""
"Performs a cast (fire and forget) operation on the agent state.\n"
"\n"
"Same as `cast/2` but a module, function and args are expected\n"
"instead of an anonymous function. The state is added as first\n"
"argument to the given list of args.\n"
msgstr ""
#. TRANSLATORS: def Agent.get_and_update(agent, module, fun, args, timeout \\ 5000)
#: lib/agent.ex:233 
msgid ""
"Gets and updates the agent state in one operation.\n"
"\n"
"Same as `get_and_update/3` but a module, function and args are expected\n"
"instead of an anonymous function. The state is added as first\n"
"argument to the given list of args.\n"
msgstr ""
#. TRANSLATORS: def Agent.start(fun, options \\ [])
#: lib/agent.ex:171 
msgid ""
"Starts an agent process without links (outside of a supervision tree).\n"
"\n"
"See `start_link/2` for more information.\n"
msgstr ""
#. TRANSLATORS: def Agent.get_and_update(agent, fun, timeout \\ 5000)
#: lib/agent.ex:218 
msgid ""
"Gets and updates the agent state in one operation.\n"
"\n"
"The function `fun` is sent to the `agent` which invokes the function\n"
"passing the agent state. The function must return a tuple with two\n"
"elements, the first being the value to return (i.e. the `get` value)\n"
"and the second one is the new state.\n"
"\n"
"A timeout can also be specified (it has a default value of 5000).\n"
msgstr ""
#. TRANSLATORS: def Agent.start_link(module, fun, args, options \\ [])
#: lib/agent.ex:159 
msgid ""
"Starts an agent linked to the current process with the given module\n"
"function and arguments.\n"
"\n"
"Same as `start_link/2` but a module, function and args are expected\n"
"instead of an anonymous function.\n"
msgstr ""
