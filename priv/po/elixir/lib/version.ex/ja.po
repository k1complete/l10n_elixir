msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2016-04-02 22:50+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: def Version.compile_requirement(req)
#: lib/version.ex:281
msgid ""
"Compiles a requirement to its internal representation with\n"
"`:ets.match_spec_compile/1` for faster matching.\n"
"\n"
"The internal representation is opaque and can not be converted to external\n"
"term format and then back again without losing its properties (meaning it\n"
"can not be sent to a process on another node and still remain a valid\n"
"compiled match_spec, nor can it be stored on disk).\n"
msgstr ""
"必要条件をマッチを高速化するため、\n"
"`:ets.match_spec_compile/1`によって内部表現にコンパイルし\n"
"ます。\n"
"\n"
"内部表現は不透明で、その特性を失うことなく再び外部のター\n"
"ムフォーマットに変換できません(これは、有効なコンパイル済み\n"
"match_specのまま、他のノードのプロセスに送ることができな\n"
"く、ディスクに保存することも出来ないことを意味します)。\n"

#. TRANSLATORS: def Version.parse!(string)
#: lib/version.ex:236
msgid ""
"Parses a version string into a `Version`.\n"
"\n"
"If `string` is an invalid version, an `InvalidVersionError` is raised.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Version.parse!(\"2.0.1-alpha1\")\n"
"    #Version<2.0.1-alpha1>\n"
"\n"
"    iex> Version.parse!(\"2.0-alpha1\")\n"
"    ** (Version.InvalidVersionError) 2.0-alpha1\n"
"\n"
msgstr ""
"バージョン文字列を`Version`にパースします。\n"
"\n"
"もし`string`が不正なバージョンなら、`InvalidVersionError`が\n"
"上ります。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Version.parse!(\"2.0.1-alpha1\")\n"
"    #Version<2.0.1-alpha1>\n"
"\n"
"    iex> Version.parse!(\"2.0-alpha1\")\n"
"    ** (Version.InvalidVersionError) 2.0-alpha1\n"
"\n"

#. TRANSLATORS: Elixir.Version Summary
#: lib/version.ex:2
msgid ""
"Functions for parsing and matching versions against requirements.\n"
"\n"
"A version is a string in a specific format or a `Version`\n"
"generated after parsing via `Version.parse/1`.\n"
"\n"
"`Version` parsing and requirements follow\n"
"[SemVer 2.0 schema](http://semver.org/).\n"
"\n"
"## Versions\n"
"\n"
"In a nutshell, a version is represented by three numbers:\n"
"\n"
"    MAJOR.MINOR.PATCH\n"
"\n"
"Pre-releases are supported by appending `-[0-9A-Za-z-\\.]`:\n"
"\n"
"    \"1.0.0-alpha.3\"\n"
"\n"
"Build information can be added by appending `+[0-9A-Za-z-\\.]`:\n"
"\n"
"    \"1.0.0-alpha.3+20130417140000\"\n"
"\n"
"## Struct\n"
"\n"
"The version is represented by the Version struct and fields\n"
"are named according to Semver: `:major`, `:minor`, `:patch`,\n"
"`:pre` and `:build`.\n"
"\n"
"## Requirements\n"
"\n"
"Requirements allow you to specify which versions of a given\n"
"dependency you are willing to work against. It supports common\n"
"operators like `>=`, `<=`, `>`, `==` and friends that\n"
"work as one would expect:\n"
"\n"
"    # Only version 2.0.0\n"
"    \"== 2.0.0\"\n"
"\n"
"    # Anything later than 2.0.0\n"
"    \"> 2.0.0\"\n"
"\n"
"Requirements also support `and` and `or` for complex conditions:\n"
"\n"
"    # 2.0.0 and later until 2.1.0\n"
"    \">= 2.0.0 and < 2.1.0\"\n"
"\n"
"Since the example above is such a common requirement, it can\n"
"be expressed as:\n"
"\n"
"    \"~> 2.0.0\"\n"
"\n"
"`~>` will never include pre-release versions of its upper bound.\n"
"It can also be used to set an upper bound on only the major\n"
"version part. See the table below for `~>` requirements and\n"
"their corresponding translation.\n"
"\n"
"`~>`           | Translation\n"
":------------- | :---------------------\n"
"`~> 2.0.0`     | `>= 2.0.0 and < 2.1.0`\n"
"`~> 2.1.2`     | `>= 2.1.2 and < 2.2.0`\n"
"`~> 2.1.3-dev` | `>= 2.1.3-dev and < 2.2.0`\n"
"`~> 2.0`       | `>= 2.0.0 and < 3.0.0`\n"
"`~> 2.1`       | `>= 2.1.0 and < 3.0.0`\n"
"\n"
"When `allow_pre: false` is set the requirement will not match a\n"
"pre-release version unless the operand is a pre-release version.\n"
"The default is to allow always allow pre-releases but note that in\n"
"Hex `:allow_pre` is set to `false.` See the table below for examples.\n"
"\n"
"Requirement    | Version     | `:allow_pre` | Matches\n"
":------------- | :---------- | :----------- | :------\n"
"`~> 2.0`       | `2.1.0`     | -            | `true`\n"
"`~> 2.0`       | `3.0.0`     | -            | `false`\n"
"`~> 2.0.0`     | `2.0.1`     | -            | `true`\n"
"`~> 2.0.0`     | `2.1.0`     | -            | `false`\n"
"`~> 2.1.2`     | `2.1.3-dev` | `true`       | `true`\n"
"`~> 2.1.2`     | `2.1.3-dev` | `false`      | `false`\n"
"`~> 2.1-dev`   | `2.2.0-dev` | `false`      | `true`\n"
"`~> 2.1.2-dev` | `2.1.3-dev` | `false`      | `true`\n"
"`>= 2.1.0`     | `2.2.0-dev` | `false`      | `false`\n"
"`>= 2.1.0-dev` | `2.2.3-dev` | `true`       | `true`\n"
"\n"
msgstr ""
"バージョンを必要条件に対してパースとマッチングをする関数です。\n"
"\n"
"バージョンは指定されたフォーマットの文字列または、\n"
"`Version.parse/1`によってパースされて生成された、`Version`で\n"
"す。\n"
"\n"
"`Version`のパースと要求条件は [SemVer 2.0\n"
"schema](http://semver.org/) に従います。\n"
"\n"
"## Versions\n"
"\n"
"簡単に言えば、バージョンは3つの番号により与えられます:\n"
"\n"
"    MAJOR.MINOR.PATCH\n"
"\n"
"`-[0-9A-Za-z-\\.]`を追加することによって、プレリリースがサポートされます:\n"
"\n"
"    \"1.0.0-alpha.3\"\n"
"\n"
"`+[0-9A-Za-z-\\.]`の追加によってビルドインフォメーションを付け加えること\n"
"が出来ます:\n"
"\n"
"    \"1.0.0-alpha.3+20130417140000\"\n"
"\n"
"## Struct\n"
"\n"
"バージョンはVersion構造体により表現され、Semverに従って\n"
"名付けられたフィールドを持っています: `:major`, `:minor`, `:patch`, \n"
"`:pre`, `:build`\n"
"\n"
"## Requirements\n"
"\n"
"必要条件は、与えられた依存関係のどのバージョンに対して対応する気がある\n"
"かを、指定することが出来ます。`>=`, `<=`, `>`, `==`とその仲間のような、\n"
"人が動くと予想するような一般的なオペレータをサポートしています:\n"
"\n"
"    # Only version 2.0.0\n"
"    \"== 2.0.0\"\n"
"\n"
"    # Anything later than 2.0.0\n"
"    \"> 2.0.0\"\n"
"\n"
"必要条件は複雑な条件のため、`and`や`or`もサポートしています:\n"
"\n"
"    # 2.0.0 and later until 2.1.0\n"
"    \">= 2.0.0 and < 2.1.0\"\n"
"\n"
"上記の例は、一般的な必要条件なので、以下のように表現できます:\n"
"\n"
"    \"~> 2.0.0\"\n"
"\n"
"`~>` はプレリリースの上位バージョンを決して含みません。上限を\n"
"major バージョン 部分にセットすることもできます。以下の表は\n"
"`~>` の条件とそれらに対応する変換表です。\n"
"\n"
"`~>`           | Translation\n"
":------------- | :---------------------\n"
"`~> 2.0.0`     | `>= 2.0.0 and < 2.1.0`\n"
"`~> 2.1.2`     | `>= 2.1.2 and < 2.2.0`\n"
"`~> 2.1.3-dev` | `>= 2.1.3-dev and < 2.2.0`\n"
"`~> 2.0`       | `>= 2.0.0 and < 3.0.0`\n"
"`~> 2.1`       | `>= 2.1.0 and < 3.0.0`\n"
"\n"
"`allow_pre: false`がセットされたとき、必要条件は、\n"
"オペランドがプレリリースバージョンでない限り、\n"
"プレリリースバージョンにはマッチしません。\n"
"デフォルトは常にプレリリースを許しますが、Hexでは\n"
"`:allow_pre`が`false`にセットされていることに\n"
"注意してください。例として下の表を参照してください。\n"
"\n"
"Requirement    | Version     | `:allow_pre` | Matches\n"
":------------- | :---------- | :----------- | :------\n"
"`~> 2.0`       | `2.1.0`     | -            | `true`\n"
"`~> 2.0`       | `3.0.0`     | -            | `false`\n"
"`~> 2.0.0`     | `2.0.1`     | -            | `true`\n"
"`~> 2.0.0`     | `2.1.0`     | -            | `false`\n"
"`~> 2.1.2`     | `2.1.3-dev` | `true`       | `true`\n"
"`~> 2.1.2`     | `2.1.3-dev` | `false`      | `false`\n"
"`~> 2.1-dev`   | `2.2.0-dev` | `false`      | `true`\n"
"`~> 2.1.2-dev` | `2.1.3-dev` | `false`      | `true`\n"
"`>= 2.1.0`     | `2.2.0-dev` | `false`      | `false`\n"
"`>= 2.1.0-dev` | `2.2.3-dev` | `true`       | `true`\n"
"\n"

#. TRANSLATORS: def Version.parse(string)
#: lib/version.ex:211
msgid ""
"Parses a version string into a `Version`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> {:ok, version} = Version.parse(\"2.0.1-alpha1\")\n"
"    iex> version\n"
"    #Version<2.0.1-alpha1>\n"
"\n"
"    iex> Version.parse(\"2.0-alpha1\")\n"
"    :error\n"
"\n"
msgstr ""
"バージョン文字列を`Version`にパースします。\n"
"\n"
"## 例\n"
"\n"
"    iex> {:ok, version} = Version.parse(\"2.0.1-alpha1\")\n"
"    iex> version\n"
"    #Version<2.0.1-alpha1>\n"
"\n"
"    iex> Version.parse(\"2.0-alpha1\")\n"
"    :error\n"
"\n"

#. TRANSLATORS: def Version.match?(version, requirement, opts \\ [])
#: lib/version.ex:121
msgid ""
"Checks if the given version matches the specification.\n"
"\n"
"Returns `true` if `version` satisfies `requirement`, `false` otherwise.\n"
"Raises a `Version.InvalidRequirementError` exception if `requirement` is "
"not\n"
"parsable, or `Version.InvalidVersionError` if `version` is not parsable.\n"
"If given an already parsed version and requirement this function won't\n"
"raise.\n"
"\n"
"## Options\n"
"\n"
"  * `:allow_pre` - when `false` pre-release versions will not match\n"
"    unless the operand is a pre-release version, see the table above\n"
"    for examples  (default: `true`);\n"
"\n"
"## Examples\n"
"\n"
"    iex> Version.match?(\"2.0.0\", \">1.0.0\")\n"
"    true\n"
"\n"
"    iex> Version.match?(\"2.0.0\", \"==1.0.0\")\n"
"    false\n"
"\n"
"    iex> Version.match?(\"foo\", \"==1.0.0\")\n"
"    ** (Version.InvalidVersionError) foo\n"
"\n"
"    iex> Version.match?(\"2.0.0\", \"== ==1.0.0\")\n"
"    ** (Version.InvalidRequirementError) == ==1.0.0\n"
"\n"
msgstr ""
"与えられたバージョンが仕様にマッチするかチェックします。\n"
"\n"
"`version`が`requirement`を満足するなら`true`を返し、さもなけ\n"
"れば、`false`を返します。もし`requirement`がパースできないな\n"
"ら、`Version.InvalidRequirementError`例外を上げます。あるいは、\n"
"もし`version`がパースできないなら、\n"
"`Version.InvalidVersionError`を上げます。もし既にバースされた\n"
"versionとrequirementが与えらえれたら、この関数は例外を上げま\n"
"せん。\n"
"\n"
"## Options\n"
"\n"
"  * `:allow_pre` - `false`の時、プレリリースバージョンについて、\n"
"    オペランドがプレリリースバージョンでない限り、マッチ\n"
"    しません。上の例の表を参照してください(デフォルト: true);\n"
"\n"
"## Examples\n"
"\n"
"    iex> Version.match?(\"2.0.0\", \">1.0.0\")\n"
"    true\n"
"\n"
"    iex> Version.match?(\"2.0.0\", \"==1.0.0\")\n"
"    false\n"
"\n"
"    iex> Version.match?(\"foo\", \"==1.0.0\")\n"
"    ** (Version.InvalidVersionError) foo\n"
"\n"
"    iex> Version.match?(\"2.0.0\", \"== ==1.0.0\")\n"
"    ** (Version.InvalidRequirementError) == ==1.0.0\n"
"\n"

#. TRANSLATORS: def Version.parse_requirement(string)
#: lib/version.ex:258
msgid ""
"Parses a version requirement string into a `Version.Requirement`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> {:ok, req} = Version.parse_requirement(\"== 2.0.1\")\n"
"    iex> req\n"
"    #Version.Requirement<== 2.0.1>\n"
"\n"
"    iex> Version.parse_requirement(\"== == 2.0.1\")\n"
"    :error\n"
"\n"
msgstr ""
"バージョン要求文字列を`Version.Requirement`にパースします。\n"
"\n"
"## 例\n"
"\n"
"    iex> {:ok, req} = Version.parse_requirement(\"== 2.0.1\")\n"
"    iex> req\n"
"    #Version.Requirement<== 2.0.1>\n"
"\n"
"    iex> Version.parse_requirement(\"== == 2.0.1\")\n"
"    :error\n"
"\n"

#. TRANSLATORS: def Version.compare(version1, version2)
#: lib/version.ex:174
msgid ""
"Compares two versions. Returns `:gt` if first version is greater than\n"
"the second and `:lt` for vice versa. If the two versions are equal `:eq`\n"
"is returned\n"
"\n"
"Raises a `Version.InvalidVersionError` exception if `version` is not "
"parsable.\n"
"If given an already parsed version this function won't raise.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Version.compare(\"2.0.1-alpha1\", \"2.0.0\")\n"
"    :gt\n"
"\n"
"    iex> Version.compare(\"2.0.1+build0\", \"2.0.1\")\n"
"    :eq\n"
"\n"
"    iex> Version.compare(\"invalid\", \"2.0.1\")\n"
"    ** (Version.InvalidVersionError) invalid\n"
"\n"
msgstr ""
"二つのバージョンを比較します。もし、最初のバージョンが二つめ\n"
"より大きいなら、`:gt`を返し、反対なら`:lt`を返します。もし二\n"
"つのバージョンが等しいなら、`:eq`が返されます。\n"
"\n"
"もし`version`が解析不能なら、`Version.InvalidVersionError`例\n"
"外を上げます。もし既に解析されたバージョンが与えられたら、こ\n"
"の関数は例外を上げません。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Version.compare(\"2.0.1-alpha1\", \"2.0.0\")\n"
"    :gt\n"
"\n"
"    iex> Version.compare(\"2.0.1+build0\", \"2.0.1\")\n"
"    :eq\n"
"\n"
"    iex> Version.compare(\"invalid\", \"2.0.1\")\n"
"    ** (Version.InvalidVersionError) invalid\n"
"\n"
