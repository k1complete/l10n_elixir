#. TRANSLATORS: defmacro Record.defrecord(name, tag \\ nil, kv)
#: lib/record.ex:131 
msgid ""
"Defines a set of macros to create and access a record.\n"
"\n"
"The macros are going to have `name`, a tag (which defaults)\n"
"to the name if none is given, and a set of fields given by\n"
"`kv`.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule User do\n"
"      require Record\n"
"      Record.defrecord :user, [name: \"meg\", age: \"25\"]\n"
"    end\n"
"\n"
"In the example above, a set of macros named `user` but with different\n"
"arities will be defined to manipulate the underlying record:\n"
"\n"
"    # To create records\n"
"    record = user()        #=> {:user, \"meg\", 25}\n"
"    record = user(age: 26) #=> {:user, \"meg\", 26}\n"
"\n"
"    # To get a field from the record\n"
"    user(record, :name) #=> \"meg\"\n"
"\n"
"    # To update the record\n"
"    user(record, age: 26) #=> {:user, \"meg\", 26}\n"
"\n"
"    # Convert a record to a keyword list\n"
"    user(record) #=> [name: \"meg\", age: 26]\n"
"\n"
"The generated macros can also be used in order to pattern match on records and\n"
"to bind variables during the match:\n"
"\n"
"    record = user() #=> {:user, \"meg\", 25}\n"
"\n"
"    user(name: name) = record\n"
"    name #=> \"meg\"\n"
"\n"
"By default, Elixir uses the record name as the first element of\n"
"the tuple (the tag). But it can be changed to something else:\n"
"\n"
"    defmodule User do\n"
"      require Record\n"
"      Record.defrecord :user, User, name: nil\n"
"    end\n"
"\n"
"    require User\n"
"    User.user() #=> {User, nil}\n"
"\n"
"## Defining extracted records with anonymous functions\n"
"\n"
"If a record defines an anonymous function, an `ArgumentError`\n"
"will occur if you attempt to create a record with it.\n"
"This can occur unintentionally when defining a record after extracting\n"
"it from an Erlang library that uses anonymous functions for defaults.\n"
"\n"
"    Record.defrecord :my_rec, Record.extract(...)\n"
"    #=> ** (ArgumentError) invalid value for record field fun_field,\n"
"    cannot escape #Function<12.90072148/2 in :erl_eval.expr/5>.\n"
"\n"
"To work around this error, redefine the field with your own &M.f/a function,\n"
"like so:\n"
"\n"
"    defmodule MyRec do\n"
"      require Record\n"
"      Record.defrecord :my_rec, Record.extract(...) |> Keyword.merge(fun_field: &__MODULE__.foo/2)\n"
"      def foo(bar, baz), do: IO.inspect({bar, baz})\n"
"    end\n"
msgstr ""
#. TRANSLATORS: def Record.extract(name, opts)
#: lib/record.ex:39 
msgid ""
"Extracts record information from an Erlang file.\n"
"\n"
"Returns a quoted expression containing the fields as a list\n"
"of tuples. It expects the record name to be an atom and the\n"
"library path to be a string at expansion time.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Record.extract(:file_info, from_lib: \"kernel/include/file.hrl\")\n"
"    [size: :undefined, type: :undefined, access: :undefined, atime: :undefined,\n"
"     mtime: :undefined, ctime: :undefined, mode: :undefined, links: :undefined,\n"
"     major_device: :undefined, minor_device: :undefined, inode: :undefined,\n"
"     uid: :undefined, gid: :undefined]\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Record.defrecordp(name, tag \\ nil, kv)
#: lib/record.ex:215 
msgid ""
"Same as `defrecord/3` but generates private macros.\n"
msgstr ""
#. TRANSLATORS: defmacro Record.is_record(data, kind)
#: lib/record.ex:72 
msgid ""
"Checks if the given `data` is a record of `kind`.\n"
"\n"
"This is implemented as a macro so it can be used in guard clauses.\n"
"\n"
"## Examples\n"
"\n"
"    iex> record = {User, \"john\", 27}\n"
"    iex> Record.is_record(record, User)\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: def Record.extract_all(opts)
#: lib/record.ex:59 
msgid ""
"Extracts all records information from an Erlang file.\n"
"\n"
"Returns a keyword list containing extracted record names as keys, and\n"
"lists of tuples describing the fields as values. It expects a named\n"
"argument :from or :from_lib, which correspond to *include* or\n"
"*include_lib* attribute from Erlang modules, respectively.\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.Record Summary
#: lib/record.ex:2 
msgid ""
"Module to work with, define and import records.\n"
"\n"
"Records are simply tuples where the first element is an atom:\n"
"\n"
"    iex> Record.is_record {User, \"john\", 27}\n"
"    true\n"
"\n"
"This module provides conveniences for working with records at\n"
"compilation time, where compile-time field names are used to\n"
"manipulate the tuples, providing fast operations on top of\n"
"the tuples' compact structure.\n"
"\n"
"In Elixir, records are used mostly in two situations:\n"
"\n"
"  1. to work with short, internal data\n"
"  2. to interface with Erlang records\n"
"\n"
"The macros `defrecord/3` and `defrecordp/3` can be used to create\n"
"records while `extract/2` can be used to extract records from Erlang\n"
"files.\n"
"\n"
"## Types\n"
"\n"
"Types can be defined for tuples with the `record/2` macro (only available\n"
"in typespecs). Like with the generated record macros it will expand to\n"
"a tuple.\n"
"\n"
"    defmodule MyModule do\n"
"      require Record\n"
"      Record.defrecord :user, name: \"john\", age: 25\n"
"\n"
"      @type user :: record(:user, name: String.t, age: integer)\n"
"      # expands to: \"@type user :: {:user, String.t, integer}\"\n"
"    end\n"
msgstr ""
#. TRANSLATORS: defmacro Record.is_record(data)
#: lib/record.ex:100 
msgid ""
"Checks if the given `data` is a record.\n"
"\n"
"This is implemented as a macro so it can be used in guard clauses.\n"
"\n"
"## Examples\n"
"\n"
"    iex> record = {User, \"john\", 27}\n"
"    iex> Record.is_record(record)\n"
"    true\n"
"    iex> tuple = {}\n"
"    iex> Record.is_record(tuple)\n"
"    false\n"
"\n"
msgstr ""
