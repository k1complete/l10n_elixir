msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2015-12-24 22:54+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: defmacro Record.defrecord(name, tag \\ nil, kv)
#: lib/record.ex:131
#, fuzzy
msgid ""
"Defines a set of macros to create and access a record.\n"
"\n"
"The macros are going to have `name`, a tag (which defaults)\n"
"to the name if none is given, and a set of fields given by\n"
"`kv`.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule User do\n"
"      require Record\n"
"      Record.defrecord :user, [name: \"meg\", age: \"25\"]\n"
"    end\n"
"\n"
"In the example above, a set of macros named `user` but with different\n"
"arities will be defined to manipulate the underlying record:\n"
"\n"
"    # To create records\n"
"    record = user()        #=> {:user, \"meg\", 25}\n"
"    record = user(age: 26) #=> {:user, \"meg\", 26}\n"
"\n"
"    # To get a field from the record\n"
"    user(record, :name) #=> \"meg\"\n"
"\n"
"    # To update the record\n"
"    user(record, age: 26) #=> {:user, \"meg\", 26}\n"
"\n"
"    # Convert a record to a keyword list\n"
"    user(record) #=> [name: \"meg\", age: 26]\n"
"\n"
"The generated macros can also be used in order to pattern match on records "
"and\n"
"to bind variables during the match:\n"
"\n"
"    record = user() #=> {:user, \"meg\", 25}\n"
"\n"
"    user(name: name) = record\n"
"    name #=> \"meg\"\n"
"\n"
"By default, Elixir uses the record name as the first element of\n"
"the tuple (the tag). But it can be changed to something else:\n"
"\n"
"    defmodule User do\n"
"      require Record\n"
"      Record.defrecord :user, User, name: nil\n"
"    end\n"
"\n"
"    require User\n"
"    User.user() #=> {User, nil}\n"
"\n"
"## Defining extracted records with anonymous functions\n"
"\n"
"If a record defines an anonymous function, an `ArgumentError`\n"
"will occur if you attempt to create a record with it.\n"
"This can occur unintentionally when defining a record after extracting\n"
"it from an Erlang library that uses anonymous functions for defaults.\n"
"\n"
"    Record.defrecord :my_rec, Record.extract(...)\n"
"    #=> ** (ArgumentError) invalid value for record field fun_field,\n"
"    cannot escape #Function<12.90072148/2 in :erl_eval.expr/5>.\n"
"\n"
"To work around this error, redefine the field with your own &M.f/a "
"function,\n"
"like so:\n"
"\n"
"    defmodule MyRec do\n"
"      require Record\n"
"      Record.defrecord :my_rec, Record.extract(...) |> Keyword."
"merge(fun_field: &__MODULE__.foo/2)\n"
"      def foo(bar, baz), do: IO.inspect({bar, baz})\n"
"    end\n"
msgstr ""
"レコードを作成し、アクセスする為の一組のマクロを定義します。\n"
"\n"
"マクロは`name`、与えられなければ(デフォルトで)名前と同じタグ、\n"
"`kv`により与えられた一組のフィールドを持ちます。\n"
"\n"
"## 例\n"
"\n"
"    defmodule User do\n"
"      require Record\n"
"      Record.defrecord :user, [name: \"meg\", age: \"25\"]\n"
"    end\n"
"\n"
"上の例で、一組のマクロは`user`と名付けられたが、\n"
"異るアリティで下にあるレコードを操作するために\n"
"定義されます:\n"
"\n"
"    # To create records\n"
"    record = user()        #=> {:user, \"meg\", 25}\n"
"    record = user(age: 26) #=> {:user, \"meg\", 26}\n"
"\n"
"    # To get a field from the record\n"
"    user(record, :name) #=> \"meg\"\n"
"\n"
"    # To update the record\n"
"    user(record, age: 26) #=> {:user, \"meg\", 26}\n"
"\n"
"    # Convert a record to a keyword list\n"
"    user(record) #=> [name: \"meg\", age: 26]\n"
"\n"
"生成されたマクロをレコードのパターンマッチやその中の変数\n"
"束縛に使うこともできます:\n"
"\n"
"    record = user() #=> {:user, \"meg\", 25}\n"
"\n"
"    user(name: name) = record\n"
"    name #=> \"meg\"\n"
"\n"
"\n"
"デフォルトで、Elixirはタプルの最初の要素(タグ)としてレコード名を\n"
"使用します。しかし、何か他のものに変えることもできます:\n"
"\n"
"    defmodule User do\n"
"      require Record\n"
"      Record.defrecord :user, User, name: nil\n"
"    end\n"
"\n"
"    require User\n"
"    User.user() #=> {User, nil}\n"
"\n"
"## Defining extracted records with anonymous functions\n"
"\n"
"レコードで無名関数を定義すると、そのレコードを生成すると\n"
"ArgumentErrorが起きます。\n"
"これは\n"
"デフォルトとして無名関数をErlangライブラリが使うもの\n"
"があり、そこから抽出してレコードを定義するとき、意図せず\n"
"起きえます。\n"
"\n"
"    Record.defrecord :my_rec, Record.extract(...)\n"
"    #=> ** (ArgumentError) invalid value for record field fun_field,\n"
"    cannot escape #Function<12.90072148/2 in :erl_eval.expr/5>.\n"
"\n"
"このエラーのワークアラウンドは、そのフィールドを\n"
"&M.f/a関数で再定義することです:\n"
"\n"
"    defmodule MyRec do\n"
"      require Record\n"
"      Record.defrecord :my_rec, Record.extract(...) |> Keyword."
"merge(fun_field: &__MODULE__.foo/2)\n"
"      def foo(bar, baz), do: IO.inspect({bar, baz})\n"
"    end\n"

#. TRANSLATORS: def Record.extract(name, opts)
#: lib/record.ex:39
msgid ""
"Extracts record information from an Erlang file.\n"
"\n"
"Returns a quoted expression containing the fields as a list\n"
"of tuples. It expects the record name to be an atom and the\n"
"library path to be a string at expansion time.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Record.extract(:file_info, from_lib: \"kernel/include/file.hrl\")\n"
"    [size: :undefined, type: :undefined, access: :undefined, atime: :"
"undefined,\n"
"     mtime: :undefined, ctime: :undefined, mode: :undefined, links: :"
"undefined,\n"
"     major_device: :undefined, minor_device: :undefined, inode: :undefined,\n"
"     uid: :undefined, gid: :undefined]\n"
"\n"
msgstr ""
"Erlangファイルからレコード情報を抽出します。\n"
"\n"
"タプルのリストとしてのフィールドを含む、quoteされた式を返します。レコー\n"
"ド名としてアトムを期待し、ライブラリパスは展開時に文字列として期待しま\n"
"す。\n"
"\n"
"## 例\n"
"\n"
"    iex> Record.extract(:file_info, from_lib: \"kernel/include/file.hrl\")\n"
"    [size: :undefined, type: :undefined, access: :undefined, atime: :"
"undefined,\n"
"     mtime: :undefined, ctime: :undefined, mode: :undefined, links: :"
"undefined,\n"
"     major_device: :undefined, minor_device: :undefined, inode: :undefined,\n"
"     uid: :undefined, gid: :undefined]\n"
"\n"

#. TRANSLATORS: defmacro Record.defrecordp(name, tag \\ nil, kv)
#: lib/record.ex:215
msgid "Same as `defrecord/3` but generates private macros.\n"
msgstr "`defrecord/3`と同じですが、プライベートマクロを生成します。\n"

#. TRANSLATORS: defmacro Record.is_record(data, kind)
#: lib/record.ex:72
msgid ""
"Checks if the given `data` is a record of `kind`.\n"
"\n"
"This is implemented as a macro so it can be used in guard clauses.\n"
"\n"
"## Examples\n"
"\n"
"    iex> record = {User, \"john\", 27}\n"
"    iex> Record.is_record(record, User)\n"
"    true\n"
"\n"
msgstr ""
"与えらえれた`data`が`kind`のレコードかどうかをチェックします。\n"
"\n"
"ガード節で使うことができるように、これはマクロとして実装されています。\n"
"\n"
"## 例\n"
"\n"
"    iex> record = {User, \"john\", 27}\n"
"    iex> Record.is_record(record, User)\n"
"    true\n"
"\n"

#. TRANSLATORS: def Record.extract_all(opts)
#: lib/record.ex:59
msgid ""
"Extracts all records information from an Erlang file.\n"
"\n"
"Returns a keyword list containing extracted record names as keys, and\n"
"lists of tuples describing the fields as values. It expects a named\n"
"argument :from or :from_lib, which correspond to *include* or\n"
"*include_lib* attribute from Erlang modules, respectively.\n"
"\n"
msgstr ""
"Erlangファイルからレコード情報を全て抽出します。\n"
"\n"
"キーとして抽出されたレコード名で、値として\n"
"フィールドを記述したタプルのリストとなる、\n"
"キーワードリストを返します。\n"
"Erlangモジュールからの *include* あるいは\n"
"*include_lib* 属性に由来する、 名前付き引数 :from または \n"
":from_lib を期待します。\n"
"\n"

#. TRANSLATORS: Elixir.Record Summary
#: lib/record.ex:2
msgid ""
"Module to work with, define and import records.\n"
"\n"
"Records are simply tuples where the first element is an atom:\n"
"\n"
"    iex> Record.is_record {User, \"john\", 27}\n"
"    true\n"
"\n"
"This module provides conveniences for working with records at\n"
"compilation time, where compile-time field names are used to\n"
"manipulate the tuples, providing fast operations on top of\n"
"the tuples' compact structure.\n"
"\n"
"In Elixir, records are used mostly in two situations:\n"
"\n"
"  1. to work with short, internal data\n"
"  2. to interface with Erlang records\n"
"\n"
"The macros `defrecord/3` and `defrecordp/3` can be used to create\n"
"records while `extract/2` can be used to extract records from Erlang\n"
"files.\n"
"\n"
"## Types\n"
"\n"
"Types can be defined for tuples with the `record/2` macro (only available\n"
"in typespecs). Like with the generated record macros it will expand to\n"
"a tuple.\n"
"\n"
"    defmodule MyModule do\n"
"      require Record\n"
"      Record.defrecord :user, name: \"john\", age: 25\n"
"\n"
"      @type user :: record(:user, name: String.t, age: integer)\n"
"      # expands to: \"@type user :: {:user, String.t, integer}\"\n"
"    end\n"
msgstr ""
"レコードを使用し、定義し、インポートするためのモジュールです。\n"
"\n"
"レコードは、最初の要素がアトムである、単なるタプルです:\n"
"\n"
"    iex> Record.record? {User, \"john\", 27}\n"
"    true\n"
"\n"
"このモジュールは、コンパイル時に以下の様な利便性を提供します。レコード\n"
"利用に対する、コンパイル時のフィールド名はタプルを操作するのに使われま\n"
"す。そして、タプル上のコンパクトな構造で素早い操作を提供します。\n"
"\n"
"Elixirでは、レコードは専ら二つのシチュエーションで使われます:\n"
"\n"
"  1. 小さな、内部データとしての利用\n"
"  2. Erlangレコードへのインタフェース\n"
"\n"
"Erlangファイルからレコードを抽出するのに`extract/2`を使い、レコードを作\n"
"成するために、マクロ`defrecord/3`と`defrecordp/3`を使うことができます。\n"
"\n"
"## タイプ\n"
"\n"
"タイプは`record/2`マクロでタプルに定義されます(typespecとして有効なだけで"
"す)。\n"
"レコードを生成するマクロのように、タプルに展開されます。\n"
"\n"
"    defmodule MyModule do\n"
"      require Record\n"
"      Record.defrecord :user name: \"john\", age: 25\n"
"\n"
"      @type user :: record(:user, name: String.t, age: integer)\n"
"      # expands to: \"@type user :: {:user, String.t, integer}\"\n"
"    end\n"

#. TRANSLATORS: defmacro Record.is_record(data)
#: lib/record.ex:100
msgid ""
"Checks if the given `data` is a record.\n"
"\n"
"This is implemented as a macro so it can be used in guard clauses.\n"
"\n"
"## Examples\n"
"\n"
"    iex> record = {User, \"john\", 27}\n"
"    iex> Record.is_record(record)\n"
"    true\n"
"    iex> tuple = {}\n"
"    iex> Record.is_record(tuple)\n"
"    false\n"
"\n"
msgstr ""
"与えらえれた`data`がレコードかどうかをチェックします。\n"
"\n"
"ガード節で使うことができるように、これはマクロとして実装されています。\n"
"\n"
"## 例\n"
"\n"
"    iex> record = {User, \"john\", 27}\n"
"    iex> Record.is_record(record)\n"
"    true\n"
"    iex> tuple = {}\n"
"    iex> Record.is_record(tuple)\n"
"    false\n"
"\n"
