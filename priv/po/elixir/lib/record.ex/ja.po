msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2015-05-20 21:54+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: Elixir.Record Summary
#: lib/record.ex:1
msgid ""
"Module to work, define and import records.\n"
"\n"
"Records are simply tuples where the first element is an atom:\n"
"\n"
"    iex> Record.is_record {User, \"john\", 27}\n"
"    true\n"
"\n"
"This module provides conveniences for working with records at\n"
"compilation time, where compile-time field names are used to\n"
"manipulate the tuples, providing fast operations on top of\n"
"the tuples compact structure.\n"
"\n"
"In Elixir, records are used mostly in two situations:\n"
"\n"
"  1. to work with short, internal data\n"
"  2. to interface with Erlang records\n"
"\n"
"The macros `defrecord/3` and `defrecordp/3` can be used to create\n"
"records while `extract/2` can be used to extract records from Erlang\n"
"files.\n"
"\n"
"## Types\n"
"\n"
"Types can be defined for tuples with the `record/2` macro (only available\n"
"in typespecs). Like with the generated record macros it will expand to\n"
"a tuple.\n"
"\n"
"    defmodule MyModule do\n"
"      require Record\n"
"      Record.defrecord :user, name: \"john\", age: 25\n"
"\n"
"      @type user :: record(:user, name: String.t, age: integer)\n"
"      # expands to: `@type user :: {:user, String.t, integer}`\n"
"    end\n"
msgstr ""
"レコードを使用し、定義し、インポートするためのモジュールです。\n"
"\n"
"レコードは、最初の要素がアトムである、単なるタプルです:\n"
"\n"
"    iex> Record.record? {User, \"john\", 27}\n"
"    true\n"
"\n"
"このモジュールは、コンパイル時に以下の様な利便性を提供します。レコード\n"
"利用に対する、コンパイル時のフィールド名はタプルを操作するのに使われま\n"
"す。そして、タプル上のコンパクトな構造で素早い操作を提供します。\n"
"\n"
"Elixirでは、レコードは専ら二つのシチュエーションで使われます:\n"
"\n"
"  1. 小さな、内部データとしての利用\n"
"  2. Erlangレコードへのインタフェース\n"
"\n"
"Erlangファイルからレコードを抽出するのに`extract/2`を使い、レコードを作\n"
"成するために、マクロ`defrecord/3`と`defrecordp/3`を使うことができます。\n"
"\n"
"## タイプ\n"
"\n"
"タイプは`record/2`マクロでタプルに定義されます(typespecとして有効なだけで"
"す)。\n"
"レコードを生成するマクロのように、タプルに展開されます。\n"
"\n"
"    defmodule MyModule do\n"
"      require Record\n"
"      Record.defrecord :user name: \"john\", age: 25\n"
"\n"
"      @type user :: record(:user, name: String.t, age: integer)\n"
"      # expands to: `@type user :: {:user, String.t, integer}`\n"
"    end\n"

#. TRANSLATORS: defmacro Record.extract(name, opts)
#: lib/record.ex:55
msgid ""
"Extracts record information from an Erlang file.\n"
"\n"
"Returns a quoted expression containing the fields as a list\n"
"of tuples. It expects the record name to be an atom and the\n"
"library path to be a string at expansion time.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Record.extract(:file_info, from_lib: \"kernel/include/file.hrl\")\n"
"    [size: :undefined, type: :undefined, access: :undefined, atime: :"
"undefined,\n"
"     mtime: :undefined, ctime: :undefined, mode: :undefined, links: :"
"undefined,\n"
"     major_device: :undefined, minor_device: :undefined, inode: :undefined,\n"
"     uid: :undefined, gid: :undefined]\n"
"\n"
msgstr ""
"Erlangファイルからレコード情報を抽出します。\n"
"\n"
"タプルのリストとしてのフィールドを含む、quoteされた式を返します。レコー\n"
"ド名としてアトムを期待し、ライブラリパスは展開時に文字列として期待しま\n"
"す。\n"
"\n"
"## 例\n"
"\n"
"    iex> Record.extract(:file_info, from_lib: \"kernel/include/file.hrl\")\n"
"    [size: :undefined, type: :undefined, access: :undefined, atime: :"
"undefined,\n"
"     mtime: :undefined, ctime: :undefined, mode: :undefined, links: :"
"undefined,\n"
"     major_device: :undefined, minor_device: :undefined, inode: :undefined,\n"
"     uid: :undefined, gid: :undefined]\n"
"\n"

#. TRANSLATORS: defmacro Record.defrecord(name, tag \\ nil, kv)
#: lib/record.ex:160
msgid ""
"Defines a set of macros to create and access a record.\n"
"\n"
"The macros are going to have `name`, a tag (which defaults)\n"
"to the name if none is given, and a set of fields given by\n"
"`kv`.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule User do\n"
"      require Record\n"
"      Record.defrecord :user, [name: \"meg\", age: \"25\"]\n"
"    end\n"
"\n"
"In the example above, a set of macros named `user` but with different\n"
"arities will be defined to manipulate the underlying record:\n"
"\n"
"    # To create records\n"
"    record = user()        #=> {:user, \"meg\", 25}\n"
"    record = user(age: 26) #=> {:user, \"meg\", 26}\n"
"\n"
"    # To get a field from the record\n"
"    user(record, :name) #=> \"meg\"\n"
"\n"
"    # To update the record\n"
"    user(record, age: 26) #=> {:user, \"meg\", 26}\n"
"\n"
"    # Convert a record to a keyword list\n"
"    user(record) #=> [name: \"meg\", age: 26]\n"
"\n"
"By default, Elixir uses the record name as the first element of\n"
"the tuple (the tag). But it can be changed to something else:\n"
"\n"
"    defmodule User do\n"
"      require Record\n"
"      Record.defrecord :user, User, name: nil\n"
"    end\n"
"\n"
"    require User\n"
"    User.user() #=> {User, nil}\n"
"\n"
msgstr ""
"レコードを作成し、アクセスする為の一組のマクロを定義します。\n"
"\n"
"マクロは`name`、与えられなければ(デフォルトで)名前と同じタグ、\n"
"`kv`により与えられた一組のフィールドを持ちます。\n"
"\n"
"## 例\n"
"\n"
"    defmodule User do\n"
"      require Record\n"
"      Record.defrecord :user, [name: \"meg\", age: \"25\"]\n"
"    end\n"
"\n"
"上の例で、一組のマクロは`user`と名付けられたが、\n"
"異るアリティで下にあるレコードを操作するために\n"
"定義されます:\n"
"\n"
"    # To create records\n"
"    record = user()        #=> {:user, \"meg\", 25}\n"
"    record = user(age: 26) #=> {:user, \"meg\", 26}\n"
"\n"
"    # To get a field from the record\n"
"    user(record, :name) #=> \"meg\"\n"
"\n"
"    # To update the record\n"
"    user(record, age: 26) #=> {:user, \"meg\", 26}\n"
"\n"
"    # Convert a record to a keyword list\n"
"    user(record) #=> [name: \"meg\", age: 26]\n"
"\n"
"デフォルトで、Elixirはタプルの最初の要素(タグ)としてレコード名を\n"
"使用します。しかし、何か他のものに変えることもできます:\n"
"\n"
"    defmodule User do\n"
"      require Record\n"
"      Record.defrecord :user, User, name: nil\n"
"    end\n"
"\n"
"    require User\n"
"    User.user() #=> {User, nil}\n"
"\n"

#. TRANSLATORS: defmacro Record.is_record(data)
#: lib/record.ex:102
msgid ""
"Checks if the given `data` is a record.\n"
"\n"
"This is implemented as a macro so it can be used in guard clauses.\n"
"\n"
"## Examples\n"
"\n"
"    iex> record = {User, \"john\", 27}\n"
"    iex> Record.is_record(record)\n"
"    true\n"
"    iex> tuple = {}\n"
"    iex> Record.is_record(tuple)\n"
"    false\n"
"\n"
msgstr ""
"与えらえれた`data`がレコードかどうかをチェックします。\n"
"\n"
"ガード節で使うことができるように、これはマクロとして実装されています。\n"
"\n"
"## 例\n"
"\n"
"    iex> record = {User, \"john\", 27}\n"
"    iex> Record.is_record(record)\n"
"    true\n"
"    iex> tuple = {}\n"
"    iex> Record.is_record(tuple)\n"
"    false\n"
"\n"

#. TRANSLATORS: defmacro Record.is_record(data, kind)
#: lib/record.ex:71
msgid ""
"Checks if the given `data` is a record of `kind`.\n"
"\n"
"This is implemented as a macro so it can be used in guard clauses.\n"
"\n"
"## Examples\n"
"\n"
"    iex> record = {User, \"john\", 27}\n"
"    iex> Record.is_record(record, User)\n"
"    true\n"
"\n"
msgstr ""
"与えらえれた`data`が`kind`のレコードかどうかをチェックします。\n"
"\n"
"ガード節で使うことができるように、これはマクロとして実装されています。\n"
"\n"
"## 例\n"
"\n"
"    iex> record = {User, \"john\", 27}\n"
"    iex> Record.is_record(record, User)\n"
"    true\n"
"\n"

#. TRANSLATORS: defmacro Record.defrecordp(name, tag \\ nil, kv)
#: lib/record.ex:178
msgid "Same as `defrecord/3` but generates private macros.\n"
msgstr "`defrecord/3`と同じですが、プライベートマクロを生成します。\n"
