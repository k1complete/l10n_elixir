msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2015-09-12 17:07+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: @type kind
#: lib/exception.ex:20
msgid "The kind handled by formatting functions"
msgstr "書式整形関数によりハンドルされます"

#. TRANSLATORS: @type t
#: lib/exception.ex:17
msgid "The exception type"
msgstr "例外のタイプ"

#. TRANSLATORS: def Exception.exception?(term)
#: lib/exception.ex:34
msgid "Returns `true` if the given `term` is an exception.\n"
msgstr "与えられた`term`が例外ならtrueを返します。\n"

#. TRANSLATORS: def Exception.format_fa(fun, arity)
#: lib/exception.ex:389
msgid ""
"Receives an anonymous function and arity and formats it as\n"
"shown in stacktraces. The arity may also be a list of arguments.\n"
"\n"
"## Examples\n"
"\n"
"    Exception.format_fa(fn -> end, 1)\n"
"    #=> \"#Function<...>/1\"\n"
"\n"
msgstr ""
"無名関数とアリティを受け取り、スタックトレースに表示されるように\n"
"フォーマットします。アリティは引数のリストかもしれません。\n"
"\n"
"## 例\n"
"\n"
"    Exception.format_fa(fn -> end, 1)\n"
"    #=> \"#Function<...>/1\"\n"
"\n"

#. TRANSLATORS: def Exception.format_stacktrace_entry(entry)
#: lib/exception.ex:336
msgid "Receives a stacktrace entry and formats it into a string.\n"
msgstr "スタックトレースエントリを受け取り、文字列にフォーマットします。\n"

#. TRANSLATORS: def Exception.format_mfa(module, fun, arity)
#: lib/exception.ex:403
msgid ""
"Receives a module, fun and arity and formats it\n"
"as shown in stacktraces. The arity may also be a list\n"
"of arguments.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Exception.format_mfa Foo, :bar, 1\n"
"    \"Foo.bar/1\"\n"
"\n"
"    iex> Exception.format_mfa Foo, :bar, []\n"
"    \"Foo.bar()\"\n"
"\n"
"    iex> Exception.format_mfa nil, :bar, []\n"
"    \"nil.bar()\"\n"
"\n"
"Anonymous functions are reported as -func/arity-anonfn-count-,\n"
"where func is the name of the enclosing function. Convert to\n"
"\"anonymous fn in func/arity\"\n"
msgstr ""
"モジュール、関数とアリティを受け取り、それを\n"
"スタックトレースに表示されるようにフォーマットします。\n"
"アリティは引数のリストかもしれません。\n"
"\n"
"## 例\n"
"\n"
"    iex> Exception.format_mfa Foo, :bar, 1\n"
"    \"Foo.bar/1\"\n"
"\n"
"    iex> Exception.format_mfa Foo, :bar, []\n"
"    \"Foo.bar()\"\n"
"\n"
"    iex> Exception.format_mfa nil, :bar, []\n"
"    \"nil.bar()\"\n"
"\n"
"無名関数は-func/arity-anonfn-count-としてレポートされます。\n"
"funcは囲んでいる関数の名前です。無名関数を、func/airtyに変換します。\n"

#. TRANSLATORS: def Exception.format(kind, payload, stacktrace \\ nil)
#: lib/exception.ex:128
msgid ""
"Normalizes and formats throw/errors/exits and stacktrace.\n"
"\n"
"It relies on `format_banner/3` and `format_stacktrace/1`\n"
"to generate the final format.\n"
"\n"
"Note that `{:EXIT, pid}` do not generate a stacktrace though\n"
"(as they are retrieved as messages without stacktraces).\n"
msgstr ""
"throw/errors/exitsとスタックトレースを正規化してフォーマットします。\n"
"\n"
"それは`format_banner/3`と`format_stacktrace/1`が最終的な\n"
"フォーマットを生成することをあてにします。\n"
"\n"
"しかし、`{:EXIT, pid}`はスタックトレースを生成しない(それらはスタックト\n"
"レースのないメッセージとして取り出されます)ことに、注意してください。\n"

#. TRANSLATORS: def Exception.format_banner(kind, exception, stacktrace \\ nil)
#: lib/exception.ex:95
msgid ""
"Normalizes and formats any throw, error and exit.\n"
"\n"
"The message is formatted and displayed in the same\n"
"format as used by Elixir's CLI.\n"
"\n"
"The third argument, a stacktrace, is optional. If it is\n"
"not supplied `System.stacktrace/0` will sometimes be used\n"
"to get additional information for the `kind` `:error`. If\n"
"the stacktrace is unknown and `System.stacktrace/0` would\n"
"not return the stacktrace corresponding to the exception\n"
"an empty stacktrace, `[]`, must be used.\n"
msgstr ""
"任意のthrow、errors、exitを正規化してフォーマットします。\n"
"\n"
"メッセージはフォーマットされ、ElixirのCLIによって使われる\n"
"フォーマットと同じように、表示されます。\n"
"\n"
"第3引数のstacktraceはオプションです。もしそれがなければ、\n"
"`System.stacktrace/0`は、`kind` `:error`の追加の情報を得るために時々使\n"
"われます。もし、stacktraceが知られていなくて、`System.stacktrace/0`が例\n"
"外と一致したスタックトレースを返さないならば、空のスタックトレース\n"
"`[]`が使われなければならない。\n"

#. TRANSLATORS: def Exception.normalize(kind, payload, stacktrace \\ nil)
#: lib/exception.ex:61
msgid ""
"Normalizes an exception, converting Erlang exceptions\n"
"to Elixir exceptions.\n"
"\n"
"It takes the `kind` spilled by `catch` as an argument and\n"
"normalizes only `:error`, returning the untouched payload\n"
"for others.\n"
"\n"
"The third argument, a stacktrace, is optional. If it is\n"
"not supplied `System.stacktrace/0` will sometimes be used\n"
"to get additional information for the `kind` `:error`. If\n"
"the stacktrace is unknown and `System.stacktrace/0` would\n"
"not return the stacktrace corresponding to the exception\n"
"an empty stacktrace, `[]`, must be used.\n"
msgstr ""
"例外をErlangの例外をElixirの例外へ変換して、正規化ます。\n"
"\n"
"\n"
"`catch`により流出した`kind`をとり、`:error`だけを\n"
"正規化します。他のペイロードには手をつけずに返します。\n"
"第3引数のstacktraceはオプションです。もしそれがなければ、\n"
"`System.stacktrace/0`は、`kind` `:error`の追加の情報を得るために時々使\n"
"われます。もし、stacktraceが知られていなくて、`System.stacktrace/0`が例\n"
"外と一致したスタックトレースを返さないならば、空のスタックトレース\n"
"`[]`が使われなければならない。\n"

#. TRANSLATORS: def Exception.message(exception)
#: lib/exception.ex:44
msgid "Gets the message for an exception.\n"
msgstr "例外のメッセージを取得します。\n"

#. TRANSLATORS: def Exception.format_stacktrace(trace \\ nil)
#: lib/exception.ex:372
msgid ""
"Formats the stacktrace.\n"
"\n"
"A stacktrace must be given as an argument. If not, the stacktrace\n"
"is retrieved from `Process.info/2`.\n"
msgstr ""
"スタックトレースをフォーマットします。\n"
"\n"
"スタックトレースは一つの引数として与えられなければなりません。\n"
"もしそうでないなら、スタックトレースは`Process.info/2`から取得されます。\n"

#. TRANSLATORS: def Exception.format_file_line(file, line)
#: lib/exception.ex:447
msgid ""
"Formats the given file and line as shown in stacktraces.\n"
"If any of the values are `nil`, they are omitted.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Exception.format_file_line(\"foo\", 1)\n"
"    \"foo:1:\"\n"
"\n"
"    iex> Exception.format_file_line(\"foo\", nil)\n"
"    \"foo:\"\n"
"\n"
"    iex> Exception.format_file_line(nil, nil)\n"
"    \"\"\n"
"\n"
msgstr ""
"与えられたファイルと行番号を、スタックトレースで見えるように\n"
"フォーマットします。\n"
"何れかの値が`nil`なら、省略されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Exception.format_file_line(\"foo\", 1)\n"
"    \"foo:1:\"\n"
"\n"
"    iex> Exception.format_file_line(\"foo\", nil)\n"
"    \"foo:\"\n"
"\n"
"    iex> Exception.format_file_line(nil, nil)\n"
"    \"\"\n"
"\n"

#. TRANSLATORS: def Exception.format_exit(reason)
#: lib/exception.ex:155
msgid ""
"Formats an exit, returns a string.\n"
"\n"
"Often there are errors/exceptions inside exits. Exits are often\n"
"wrapped by the caller and provide stacktraces too. This function\n"
"formats exits in a way to nicely show the exit reason, caller\n"
"and stacktrace.\n"
msgstr ""
"exitのreasonをフォーマットし、文字列を返します。\n"
"\n"
"しばしばエラーや例外がexitの内部であります。exitはしばしば呼び出し側\n"
"によりラップされ、スタックトレースも提供されます。この関数はexitの\n"
"reason、呼び出し側、スタックトレースを上手く示す方法でフォーマットしま\n"
"す。\n"

#. TRANSLATORS: Elixir.Exception Summary
#: lib/exception.ex:2
msgid ""
"Functions to format throw/catch/exit and exceptions.\n"
"\n"
"Note that stacktraces in Elixir are updated on throw,\n"
"errors and exits. For example, at any given moment,\n"
"`System.stacktrace/0` will return the stacktrace for the\n"
"last throw/error/exit that occurred in the current process.\n"
"\n"
"Do not rely on the particular format returned by the `format`\n"
"functions in this module. They may be changed in future releases\n"
"in order to better suit Elixir's tool chain. In other words,\n"
"by using the functions in this module it is guaranteed you will\n"
"format exceptions as in the current Elixir version being used.\n"
msgstr ""
"throw/catch/exitと例外をフォーマットする関数です。\n"
"\n"
"Elixirのスタックトレースは、throw、error, exitで更新されること\n"
"に、気を付けてください。例えば、与えられた任意の瞬間に、\n"
"`System.stacktrace/0`は、現在のプロセスで最後に起った\n"
"throw/error/exitのスタックトレースを返します。\n"
"\n"
"このモジュールの`format`関数によって返される特定のフォーマット\n"
"に頼ってはいけません。それらは、Elixirのツールチェインによりよ\n"
"く合せるために、将来のリリースにおいて変更されるかもしれません。\n"
"言い替えると、このモジュールの関数を用いることによって、現在使\n"
"われているのElixirのバージョンに合せて例外をフォーマットするこ\n"
"とが保証されます。\n"
