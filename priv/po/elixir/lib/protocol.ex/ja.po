msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2015-12-10 22:26+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: Elixir.Protocol Summary
#: lib/protocol.ex:2
msgid "Functions for working with protocols.\n"
msgstr "プロトコルで動く関数です。\n"

#. TRANSLATORS: def Protocol.assert_impl!(protocol, base)
#: lib/protocol.ex:82
msgid ""
"Checks if the given module is loaded and is an implementation\n"
"of the given protocol.\n"
"\n"
"Returns `:ok` if so, otherwise raises ArgumentError.\n"
msgstr ""
"与えられたモジュールがロードされ、与えられたプロトコルを\n"
"実装しているかチェックします。\n"
"\n"
"もしそうなら`:ok`を返し、さもなくばArgumentErrorを上げます。\n"

#. TRANSLATORS: defmacro Protocol.derive(protocol, module, options \\ [])
#: lib/protocol.ex:117
msgid "Derives the `protocol` for `module` with the given options.\n"
msgstr "与えられたオプションで、`module`のために`protocol`を導出します。\n"

#. TRANSLATORS: defmacro Protocol.def(signature)
#: lib/protocol.ex:6
msgid ""
"Defines a new protocol function.\n"
"\n"
"Protocols do not allow functions to be defined directly, instead, the\n"
"regular `Kernel.def/*` macros are replaced by this macro which\n"
"defines the protocol functions with the appropriate callbacks.\n"
msgstr ""
"新しいプロトコル関数を定義します。\n"
"\n"
"プロトコルは関数を直接定義することは許されていません。代りに、\n"
"適切なコールバックでプロトコル関数を定義するこのマクロと、\n"
"標準の`Kernel.def/*`マクロが取り替えられます。\n"

#. TRANSLATORS: def Protocol.extract_impls(protocol, paths)
#: lib/protocol.ex:158
msgid ""
"Extracts all types implemented for the given protocol from\n"
"the given paths.\n"
"\n"
"The paths can be either a char list or a string. Internally\n"
"they are worked on as char lists, so passing them as lists\n"
"avoid extra conversion.\n"
"\n"
"Does not load any of the implementations.\n"
"\n"
"## Examples\n"
"\n"
"    # Get Elixir's ebin and retrieve all protocols\n"
"    iex> path = :code.lib_dir(:elixir, :ebin)\n"
"    iex> mods = Protocol.extract_impls(Enumerable, [path])\n"
"    iex> List in mods\n"
"    true\n"
"\n"
msgstr ""
"与えられたパスから与えられたプロトコルの為に実装される\n"
"全てのタイプを抽出します。\n"
"\n"
"パスは文字のリストでも文字列でもよいです。内部的には文字のリストとして\n"
"動きますので、リストを渡すと、余分な変換は無視されます。\n"
"\n"
"どんな実装もロードはされません。\n"
"\n"
"## 例\n"
"\n"
"    # Get Elixir's ebin and retrieve all protocols\n"
"    iex> path = :code.lib_dir(:elixir, :ebin)\n"
"    iex> mods = Protocol.extract_impls(Enumerable, [path])\n"
"    iex> List in mods\n"
"    true\n"
"\n"

#. TRANSLATORS: def Protocol.assert_protocol!(module)
#: lib/protocol.ex:56
msgid ""
"Checks if the given module is loaded and is protocol.\n"
"\n"
"Returns `:ok` if so, otherwise raises ArgumentError.\n"
msgstr ""
"与えられたモジュールがロードされ、プロトコルかどうかをチェックします。\n"
"\n"
"もしそうなら`:ok`を返し、さもなくばArgumentErrorを上げます。\n"

#. TRANSLATORS: def Protocol.extract_protocols(paths)
#: lib/protocol.ex:129
msgid ""
"Extracts all protocols from the given paths.\n"
"\n"
"The paths can be either a char list or a string. Internally\n"
"they are worked on as char lists, so passing them as lists\n"
"avoid extra conversion.\n"
"\n"
"Does not load any of the protocols.\n"
"\n"
"## Examples\n"
"\n"
"    # Get Elixir's ebin and retrieve all protocols\n"
"    iex> path = :code.lib_dir(:elixir, :ebin)\n"
"    iex> mods = Protocol.extract_protocols([path])\n"
"    iex> Enumerable in mods\n"
"    true\n"
"\n"
msgstr ""
"与えられたパスから全てのプロトコルを抽出します。\n"
"\n"
"パスは文字のリストでも文字列でもよいです。内部的には文字のリストとして\n"
"動きますので、リストを渡すと、余分な変換は無視されます。\n"
"\n"
"どんな実装もロードはされません。\n"
"\n"
"## 例\n"
"\n"
"    # Elixirのebinディレクトリを取得し、全てのプロトコルを取り出します。\n"
"    iex> path = :code.lib_dir(:elixir, :ebin)\n"
"    iex> mods = Protocol.extract_protocols([path])\n"
"    iex> Enumerable in mods\n"
"    true\n"
"\n"

#. TRANSLATORS: def Protocol.consolidated?(protocol)
#: lib/protocol.ex:220
msgid "Returns `true` if the protocol was consolidated.\n"
msgstr "プロトコルが統合(consolidate)されていれば`true`を返します。\n"

#. TRANSLATORS: def Protocol.consolidate(protocol, types)
#: lib/protocol.ex:228
msgid ""
"Receives a protocol and a list of implementations and\n"
"consolidates the given protocol.\n"
"\n"
"Consolidation happens by changing the protocol `impl_for`\n"
"in the abstract format to have fast lookup rules. Usually\n"
"the list of implementations to use during consolidation\n"
"are retrieved with the help of `extract_impls/2`.\n"
"\n"
"It returns the updated version of the protocol bytecode.\n"
"A given bytecode or protocol implementation can be checked\n"
"to be consolidated or not by analyzing the protocol\n"
"attribute:\n"
"\n"
"    Protocol.consolidated?(Enumerable)\n"
"\n"
"If the first element of the tuple is `true`, it means\n"
"the protocol was consolidated.\n"
"\n"
"This function does not load the protocol at any point\n"
"nor loads the new bytecode for the compiled module.\n"
"However each implementation must be available and\n"
"it will be loaded.\n"
msgstr ""
"プロトコルと実装のリストを受け取り、与えられたプロトコルを\n"
"統合します。\n"
"\n"
"速い検索規則を持つために抽象的なフォーマットで\n"
"`impl_for`プロトコルを変更することにより統合は起きます。\n"
"通常、統合の間の実装のリストは`extract_impls/2`の助けを得て\n"
"検索されます。\n"
"\n"
"プロトコルバイトコードの更新版を返します。与えられたバイトコードまたは\n"
"プロトコル実装は、統合されたかどうかをプロトコルアトリビュートを分析す\n"
"ることで、チェックできます:\n"
"\n"
"\n"
"    Protocol.consolidated?(Enumerable)\n"
"\n"
"もしタプルの最初の要素が`true`ならプロトコルは統合されたことを意味します。\n"
"\n"
"この関数はいかなるプロトコルもロードしませんし、コンパイルされたモジュー\n"
"ルの新しいバイトコードもロードしません。しかしながら、それぞれの実装は\n"
"有効にされるはずで、それはロードされるでしょう。\n"
