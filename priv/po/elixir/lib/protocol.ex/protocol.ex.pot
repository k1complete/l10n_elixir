#. TRANSLATORS: Elixir.Protocol Summary
#: lib/protocol.ex:2 
msgid ""
"Functions for working with protocols.\n"
msgstr ""
#. TRANSLATORS: def Protocol.assert_impl!(protocol, base)
#: lib/protocol.ex:82 
msgid ""
"Checks if the given module is loaded and is an implementation\n"
"of the given protocol.\n"
"\n"
"Returns `:ok` if so, otherwise raises ArgumentError.\n"
msgstr ""
#. TRANSLATORS: defmacro Protocol.derive(protocol, module, options \\ [])
#: lib/protocol.ex:117 
msgid ""
"Derives the `protocol` for `module` with the given options.\n"
msgstr ""
#. TRANSLATORS: defmacro Protocol.def(signature)
#: lib/protocol.ex:6 
msgid ""
"Defines a new protocol function.\n"
"\n"
"Protocols do not allow functions to be defined directly, instead, the\n"
"regular `Kernel.def/*` macros are replaced by this macro which\n"
"defines the protocol functions with the appropriate callbacks.\n"
msgstr ""
#. TRANSLATORS: def Protocol.extract_impls(protocol, paths)
#: lib/protocol.ex:158 
msgid ""
"Extracts all types implemented for the given protocol from\n"
"the given paths.\n"
"\n"
"The paths can be either a char list or a string. Internally\n"
"they are worked on as char lists, so passing them as lists\n"
"avoid extra conversion.\n"
"\n"
"Does not load any of the implementations.\n"
"\n"
"## Examples\n"
"\n"
"    # Get Elixir's ebin and retrieve all protocols\n"
"    iex> path = :code.lib_dir(:elixir, :ebin)\n"
"    iex> mods = Protocol.extract_impls(Enumerable, [path])\n"
"    iex> List in mods\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: def Protocol.assert_protocol!(module)
#: lib/protocol.ex:56 
msgid ""
"Checks if the given module is loaded and is protocol.\n"
"\n"
"Returns `:ok` if so, otherwise raises ArgumentError.\n"
msgstr ""
#. TRANSLATORS: def Protocol.extract_protocols(paths)
#: lib/protocol.ex:129 
msgid ""
"Extracts all protocols from the given paths.\n"
"\n"
"The paths can be either a char list or a string. Internally\n"
"they are worked on as char lists, so passing them as lists\n"
"avoid extra conversion.\n"
"\n"
"Does not load any of the protocols.\n"
"\n"
"## Examples\n"
"\n"
"    # Get Elixir's ebin and retrieve all protocols\n"
"    iex> path = :code.lib_dir(:elixir, :ebin)\n"
"    iex> mods = Protocol.extract_protocols([path])\n"
"    iex> Enumerable in mods\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: def Protocol.consolidated?(protocol)
#: lib/protocol.ex:220 
msgid ""
"Returns `true` if the protocol was consolidated.\n"
msgstr ""
#. TRANSLATORS: def Protocol.consolidate(protocol, types)
#: lib/protocol.ex:228 
msgid ""
"Receives a protocol and a list of implementations and\n"
"consolidates the given protocol.\n"
"\n"
"Consolidation happens by changing the protocol `impl_for`\n"
"in the abstract format to have fast lookup rules. Usually\n"
"the list of implementations to use during consolidation\n"
"are retrieved with the help of `extract_impls/2`.\n"
"\n"
"It returns the updated version of the protocol bytecode.\n"
"A given bytecode or protocol implementation can be checked\n"
"to be consolidated or not by analyzing the protocol\n"
"attribute:\n"
"\n"
"    Protocol.consolidated?(Enumerable)\n"
"\n"
"If the first element of the tuple is `true`, it means\n"
"the protocol was consolidated.\n"
"\n"
"This function does not load the protocol at any point\n"
"nor loads the new bytecode for the compiled module.\n"
"However each implementation must be available and\n"
"it will be loaded.\n"
msgstr ""
