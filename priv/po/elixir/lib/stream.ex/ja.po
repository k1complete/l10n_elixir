msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2015-09-17 12:32+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: def Stream.zip(left, right)
#: lib/stream.ex:867
msgid ""
"Zips two collections together, lazily.\n"
"\n"
"The zipping finishes as soon as any enumerable completes.\n"
"\n"
"## Examples\n"
"\n"
"    iex> concat = Stream.concat(1..3, 4..6)\n"
"    iex> cycle  = Stream.cycle([:a, :b, :c])\n"
"    iex> Stream.zip(concat, cycle) |> Enum.to_list\n"
"    [{1, :a}, {2, :b}, {3, :c}, {4, :a}, {5, :b}, {6, :c}]\n"
"\n"
msgstr ""
"二つのコレクションを一緒に、遅延評価しながら、zipします。\n"
"\n"
"Enumerableの何れかが完了するとすぐに、zippingも終了します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> concat = Stream.concat(1..3, 4..6)\n"
"    iex> cycle  = Stream.cycle([:a, :b, :c])\n"
"    iex> Stream.zip(concat, cycle) |> Enum.to_list\n"
"    [{1, :a}, {2, :b}, {3, :c}, {4, :a}, {5, :b}, {6, :c}]\n"
"\n"

#. TRANSLATORS: def Stream.transform(enum, acc, reducer)
#: lib/stream.ex:631
msgid ""
"Transforms an existing stream.\n"
"\n"
"It expects an accumulator and a function that receives each stream item\n"
"and an accumulator, and must return a tuple containing a new stream\n"
"(often a list) with the new accumulator or a tuple with `:halt` as first\n"
"element and the accumulator as second.\n"
"\n"
"Note: this function is similar to `Enum.flat_map_reduce/3` except the\n"
"latter returns both the flat list and accumulator, while this one returns\n"
"only the stream.\n"
"\n"
"## Examples\n"
"\n"
"`Stream.transform/3` is useful as it can be used as the basis to implement\n"
"many of the functions defined in this module. For example, we can implement\n"
"`Stream.take(enum, n)` as follows:\n"
"\n"
"    iex> enum = 1..100\n"
"    iex> n = 3\n"
"    iex> stream = Stream.transform(enum, 0, fn i, acc ->\n"
"    ...>   if acc < n, do: {[i], acc + 1}, else: {:halt, acc}\n"
"    ...> end)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
"既存のストリームを変換します。\n"
"\n"
"アキュムレータとそれぞれのストリームアイテムとアキュムレータを受けとり、\n"
"新しいストリーム(しばしばリスト)と新しいアキュムレータを含むタプルか、\n"
"最初の要素が`:halt`で次の要素がアキュムレータとなるタプルを返す関数を\n"
"期待します。\n"
"\n"
"注: この関数は、`Enum.flat_map_reduce/3`が、フラットリストとアキュムレー\n"
"タを返すこと対して、ストリームだけを返ことを除いては、似ています。\n"
"\n"
"## Examples\n"
"\n"
"このモジュールで定義される関数の多くを実装するための基礎として使うこと\n"
"ができるように、`Stream.transform/3`は便利です。例えば、\n"
"`Stream.take(enum, n)`は以下の様に実装できます:\n"
"\n"
"    iex> enum = 1..100\n"
"    iex> n = 3\n"
"    iex> stream = Stream.transform(enum, 0, fn i, acc ->\n"
"    ...>   if acc < n, do: {[i], acc + 1}, else: {:halt, acc}\n"
"    ...> end)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 3]\n"
"\n"

#. TRANSLATORS: def Stream.transform(enum, start_fun, reducer, after_fun)
#: lib/stream.ex:665
msgid ""
"Transforms an existing stream with function-based start and finish.\n"
"\n"
"The accumulator is only calculated when transformation starts. It also\n"
"allows an after function to be given which is invoked when the stream\n"
"halts or completes.\n"
"\n"
"This function can be seen as a combination of `Stream.resource/3` with\n"
"`Stream.transform/3`.\n"
msgstr ""
"既存のstreamを関数ベースのstartとfinishで変換します。\n"
"\n"
"アキュムレータは変換時にstart関数で計算されます。\n"
"streamが中断か完了したときに呼び出されるafter関数を\n"
"指定することもできます。\n"
"\n"
"この関数は `Stream.resource/3` と `Stream.transform/3` \n"
"の組み合わせとみなすことができます。\n"
"\n"

#. TRANSLATORS: def Stream.chunk(enum, n)
#: lib/stream.ex:125
msgid "Shortcut to `chunk(enum, n, n)`.\n"
msgstr "`chunk(enum, n, n)`へのショートカットです。\n"

#. TRANSLATORS: def Stream.chunk(enum, n, step, pad \\ nil)
#: lib/stream.ex:131
msgid ""
"Streams the enumerable in chunks, containing `n` items each, where\n"
"each new chunk starts `step` elements into the enumerable.\n"
"\n"
"`step` is optional and, if not passed, defaults to `n`, i.e.\n"
"chunks do not overlap. If the final chunk does not have `n`\n"
"elements to fill the chunk, elements are taken as necessary\n"
"from `pad` if it was passed. If `pad` is passed and does not\n"
"have enough elements to fill the chunk, then the chunk is\n"
"returned anyway with less than `n` elements. If `pad` is not\n"
"passed at all or is `nil`, then the partial chunk is discarded\n"
"from the result.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.chunk([1, 2, 3, 4, 5, 6], 2) |> Enum.to_list\n"
"    [[1, 2], [3, 4], [5, 6]]\n"
"\n"
"    iex> Stream.chunk([1, 2, 3, 4, 5, 6], 3, 2) |> Enum.to_list\n"
"    [[1, 2, 3], [3, 4, 5]]\n"
"\n"
"    iex> Stream.chunk([1, 2, 3, 4, 5, 6], 3, 2, [7]) |> Enum.to_list\n"
"    [[1, 2, 3], [3, 4, 5], [5, 6, 7]]\n"
"\n"
"    iex> Stream.chunk([1, 2, 3, 4, 5, 6], 3, 3, []) |> Enum.to_list\n"
"    [[1, 2, 3], [4, 5, 6]]\n"
"\n"
msgstr ""
"それぞれのアイテムは`n`個含んでいて、enumerableの`step`要素毎に\n"
"新しいチャンクが始まる、enumerableをチャンクに流れ出させます。\n"
"\n"
"`step`はオプションで、もし与えられなければ、デフォルトは`n`に\n"
"なります。即ち、チャンクはオーバーラップしません。\n"
"もし最後のチャンクはチャンクを満す`n`個要素を持っていなかったら、\n"
"もし`pad`が与えられていれば、そこから必要に応じて取られます。\n"
"もし`pad`が与えられて、チャンクを満すために十分なエレメントを\n"
"持っていなかったら、チャンクは少なくとも`n`要素より少いもので\n"
"返されます。\n"
"もし`pad`が全く与えられていないか、`nil`なら、結果から\n"
"部分的なチャンクは放棄されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Stream.chunk([1, 2, 3, 4, 5, 6], 2) |> Enum.to_list\n"
"    [[1, 2], [3, 4], [5, 6]]\n"
"\n"
"    iex> Stream.chunk([1, 2, 3, 4, 5, 6], 3, 2) |> Enum.to_list\n"
"    [[1, 2, 3], [3, 4, 5]]\n"
"\n"
"    iex> Stream.chunk([1, 2, 3, 4, 5, 6], 3, 2, [7]) |> Enum.to_list\n"
"    [[1, 2, 3], [3, 4, 5], [5, 6, 7]]\n"
"\n"
"    iex> Stream.chunk([1, 2, 3, 4, 5, 6], 3, 3, []) |> Enum.to_list\n"
"    [[1, 2, 3], [4, 5, 6]]\n"
"\n"

#. TRANSLATORS: def Stream.run(stream)
#: lib/stream.ex:473
msgid ""
"Runs the given stream.\n"
"\n"
"This is useful when a stream needs to be run, for side effects,\n"
"and there is no interest in its return result.\n"
"\n"
"## Examples\n"
"\n"
"Open up a file, replace all `#` by `%` and stream to another file\n"
"without loading the whole file in memory:\n"
"\n"
"    stream = File.stream!(\"code\")\n"
"    |> Stream.map(&String.replace(&1, \"#\", \"%\"))\n"
"    |> Stream.into(File.stream!(\"new\"))\n"
"    |> Stream.run\n"
"\n"
"No computation will be done until we call one of the Enum functions\n"
"or `Stream.run/1`.\n"
msgstr ""
"与えられたストリームを走らせます。\n"
"\n"
"これは返される結果に関心がなく、副作用を期待してストリームを走らせる必\n"
"要があるとき役に立ちます。\n"
"\n"
"## 例\n"
"\n"
"ファイルをオープンして、すべての`#`を`%`に置き換え、メモリにファイル全\n"
"体をロードせずに他のファイルへ流します:\n"
"\n"
"    stream = File.stream!(\"code\")\n"
"    |> Stream.map(&String.replace(&1, \"#\", \"%\"))\n"
"    |> Stream.into(File.stream!(\"new\"))\n"
"    |> Stream.run\n"
"\n"
"Enumモジュールの関数か、`Stream.run/1`のいずれかを呼び出すまでは\n"
"計算はされません。\n"

#. TRANSLATORS: Elixir.Stream Summary
#: lib/stream.ex:2
msgid ""
"Module for creating and composing streams.\n"
"\n"
"Streams are composable, lazy enumerables. Any enumerable that generates\n"
"items one by one during enumeration is called a stream. For example,\n"
"Elixir's `Range` is a stream:\n"
"\n"
"    iex> range = 1..5\n"
"    1..5\n"
"    iex> Enum.map range, &(&1 * 2)\n"
"    [2, 4, 6, 8, 10]\n"
"\n"
"In the example above, as we mapped over the range, the elements being\n"
"enumerated were created one by one, during enumeration. The `Stream`\n"
"module allows us to map the range, without triggering its enumeration:\n"
"\n"
"    iex> range = 1..3\n"
"    iex> stream = Stream.map(range, &(&1 * 2))\n"
"    iex> Enum.map(stream, &(&1 + 1))\n"
"    [3, 5, 7]\n"
"\n"
"Notice we started with a range and then we created a stream that is\n"
"meant to multiply each item in the range by 2. At this point, no\n"
"computation was done yet. Just when `Enum.map/2` is called we\n"
"enumerate over each item in the range, multiplying it by 2 and adding 1.\n"
"We say the functions in `Stream` are *lazy* and the functions in `Enum`\n"
"are *eager*.\n"
"\n"
"Due to their laziness, streams are useful when working with large\n"
"(or even infinite) collections. When chaining many operations with `Enum`,\n"
"intermediate lists are created, while `Stream` creates a recipe of\n"
"computations that are executed at a later moment. Let's see another\n"
"example:\n"
"\n"
"    1..3 |>\n"
"      Enum.map(&IO.inspect(&1)) |>\n"
"      Enum.map(&(&1 * 2)) |>\n"
"      Enum.map(&IO.inspect(&1))\n"
"    1\n"
"    2\n"
"    3\n"
"    2\n"
"    4\n"
"    6\n"
"    #=> [2, 4, 6]\n"
"\n"
"Notice that we first printed each item in the list, then multiplied each\n"
"element by 2 and finally printed each new value. In this example, the list\n"
"was enumerated three times. Let's see an example with streams:\n"
"\n"
"    stream = 1..3 |>\n"
"      Stream.map(&IO.inspect(&1)) |>\n"
"      Stream.map(&(&1 * 2)) |>\n"
"      Stream.map(&IO.inspect(&1))\n"
"    Enum.to_list(stream)\n"
"    1\n"
"    2\n"
"    2\n"
"    4\n"
"    3\n"
"    6\n"
"    #=> [2, 4, 6]\n"
"\n"
"Although the end result is the same, the order in which the items were\n"
"printed changed! With streams, we print the first item and then print\n"
"its double. In this example, the list was enumerated just once!\n"
"\n"
"That's what we meant when we first said that streams are composable,\n"
"lazy enumerables. Notice we could call `Stream.map/2` multiple times,\n"
"effectively composing the streams and they are lazy. The computations\n"
"are performed only when you call a function from the `Enum` module.\n"
"\n"
"## Creating Streams\n"
"\n"
"There are many functions in Elixir's standard library that return\n"
"streams, some examples are:\n"
"\n"
"  * `IO.stream/2`         - streams input lines, one by one\n"
"  * `URI.query_decoder/1` - decodes a query string, pair by pair\n"
"\n"
"This module also provides many convenience functions for creating streams,\n"
"like `Stream.cycle/1`, `Stream.unfold/2`, `Stream.resource/3` and more.\n"
"\n"
"Note the functions in this module are guaranteed to return enumerables.\n"
"Since enumerables can have different shapes (structs, anonymous functions,\n"
"and so on), the functions in this module may return any of those shapes\n"
"and that it may change at any time. For example, a function that today\n"
"returns an anonymous function may return a struct in future releases.\n"
msgstr ""
"ストリームを作り、組み立てるためのモジュールです。\n"
"\n"
"ストリームは組み立て可能な、遅延enumerableです。\n"
"数え上げの間、一つずつアイテムを生成する任意のenumerableが、\n"
"ストリームと呼ばれます。例えば、\n"
"Elixirの`Range`はストリームです:\n"
"\n"
"    iex> range = 1..5\n"
"    1..5\n"
"    iex> Enum.map range, &(&1 * 2)\n"
"    [2, 4, 6, 8, 10]\n"
"\n"
"上の例で、rangeの上にマップしたので、列挙の間、列挙されたアイテムは一つ\n"
"ずつ作成されました。`Stream`モジュールは、列挙操作を起動させることなく、\n"
"rangeをマップすることを許します:\n"
"\n"
"    iex> range = 1..3\n"
"    iex> stream = Stream.map(range, &(&1 * 2))\n"
"    iex> Enum.map(stream, &(&1 + 1))\n"
"    [3, 5, 7]\n"
"\n"
"rangeから開始して、rangeのそれぞれのアイテムを2倍にするストリームを作っ\n"
"たことに注意してください。この点で、まだ計算はされていません。そしてちょ\n"
"うど`Enum.map/2`が呼ばれたとき、rangeのそれぞれのアイテムが列挙され、2\n"
"倍されて、1を加えられます。\n"
"`Stream`の関数は*lazy*で`Enum`の関数は*eager*していると言います。\n"
"\n"
"怠惰であるが故に、ストリームは、巨大な(または更に無限の)コレクションで\n"
"働くとき、役に立ちます。`Enum`で多くの操作を繋ぐとき、\n"
"中間のリストが作成されますが、`Stream`は後で実行される\n"
"計算のレシピを作成します。他の例を見てみましょう:\n"
"\n"
"    1..3 |>\n"
"      Enum.map(&IO.inspect(&1)) |>\n"
"      Enum.map(&(&1 * 2)) |>\n"
"      Enum.map(&IO.inspect(&1))\n"
"    1\n"
"    2\n"
"    3\n"
"    2\n"
"    4\n"
"    6\n"
"    #=> [2, 4, 6]\n"
"\n"
"最初にリストの各要素をプリントし、それから各要素を2倍し、最期に新しい値を\n"
"プリントしています。この例で、リストは3回列挙されています。\n"
"ストリームでの例を見てみましょう:\n"
"\n"
"    stream = 1..3 |>\n"
"      Stream.map(&IO.inspect(&1)) |>\n"
"      Stream.map(&(&1 * 2)) |>\n"
"      Stream.map(&IO.inspect(&1))\n"
"    Enum.to_list(stream)\n"
"    1\n"
"    2\n"
"    2\n"
"    4\n"
"    3\n"
"    6\n"
"    #=> [2, 4, 6]\n"
"\n"
"最後の結果は同じですが、要素のプリントされる順番が異っています!\n"
"ストリームでは、最初の要素をプリントし、それからそれを2倍したものを\n"
"プリントしています。この例ではリストは一度だけ列挙されました!\n"
"\n"
"それが、ストリームが構成可能だと最初に言ったときに、意味したものなので\n"
"す。`Stream.map/2`を複数回呼び出し、ストリームを効果的に構成し、それは\n"
"lazyであることに注意してください。計算の実行は`Enum`モジュールの関数を\n"
"呼び出した時にだけ行われます。\n"
"\n"
"## ストリームの作成\n"
"\n"
"ストリームを返す、Elixirの標準ライブラリの沢山の関数があります。\n"
"幾つかの例は:\n"
"\n"
"  * `IO.stream/2`         - 入力行のストリーム、一つずつ。\n"
"  * `URI.query_decoder/1` - query stringのデコード、二つずつ。\n"
"\n"
"このモジュールも、`Stream.cycle/1`、`Stream.unfold/2`、\n"
"`Stream.resource/3`などのストリームを作成する、多くの便利な関数を提供し\n"
"ます。\n"
"\n"
"このモジュールの関数はenumerableを返すことが保証されていることに\n"
"注意してください。\n"
"enumerableは(構造体、無名関数など)異った形を持つことができるので、\n"
"このモジュールの関数はそれらの任意の形を返すかもしれないし、それが\n"
"何時でも変るかもしれません。例えば、今日無名関数を返す、ある関数が、\n"
"将来のリリースでは構造体を返すかもしれません。\n"

#. TRANSLATORS: def Stream.take(enum, count)
#: lib/stream.ex:532
msgid ""
"Lazily takes the next `count` items from the enumerable and stops\n"
"enumeration.\n"
"\n"
"If a negative `count` is given, the last `count` values will be taken.\n"
"For such, the collection is fully enumerated keeping up to `2 * count`\n"
"elements in memory. Once the end of the collection is reached,\n"
"the last `count` elements will be executed. Therefore, using\n"
"a negative `count` on an infinite collection will never return.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.take(1..100, 5)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 3, 4, 5]\n"
"\n"
"    iex> stream = Stream.take(1..100, -5)\n"
"    iex> Enum.to_list(stream)\n"
"    [96, 97, 98, 99, 100]\n"
"\n"
"    iex> stream = Stream.cycle([1, 2, 3]) |> Stream.take(5)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 3, 1, 2]\n"
"\n"
msgstr ""
"次の`n`アイテムをenumerableから遅延評価して取り出し、列挙を\n"
"停止します。\n"
"\n"
"もし与えられた`n`が負なら、最後の`n`個が取り出されます。それのために、\n"
"コレクションはすべて列挙され、メモリで`2 * n`要素保持されます。コレクショ\n"
"ンの終わりに到達したら、最後の`count`要素が実行されます。従って、無限の\n"
"コレクションに対して、負の`n`を使うと、決して戻りません。\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.take(1..100, 5)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 3, 4, 5]\n"
"\n"
"    iex> stream = Stream.take(1..100, -5)\n"
"    iex> Enum.to_list(stream)\n"
"    [96, 97, 98, 99, 100]\n"
"\n"
"    iex> stream = Stream.cycle([1, 2, 3]) |> Stream.take(5)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 3, 1, 2]\n"
"\n"

#. TRANSLATORS: def Stream.take_while(enum, fun)
#: lib/stream.ex:599
msgid ""
"Lazily takes elements of the enumerable while the given\n"
"function returns `true`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.take_while(1..100, &(&1 <= 5))\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 3, 4, 5]\n"
"\n"
msgstr ""
"与えられた関数を`true`にするenumerableの要素を、\n"
"遅延評価して取り出します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.take_while(1..100, &(&1 <= 5))\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 3, 4, 5]\n"
"\n"

#. TRANSLATORS: def Stream.drop(enum, n)
#: lib/stream.ex:242
msgid ""
"Lazily drops the next `n` items from the enumerable.\n"
"\n"
"If a negative `n` is given, it will drop the last `n` items from\n"
"the collection. Note that the mechanism by which this is implemented\n"
"will delay the emission of any item until `n` additional items have\n"
"been emitted by the enum.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.drop(1..10, 5)\n"
"    iex> Enum.to_list(stream)\n"
"    [6, 7, 8, 9, 10]\n"
"\n"
"    iex> stream = Stream.drop(1..10, -5)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 3, 4, 5]\n"
"\n"
msgstr ""
"enumerableから次の`n`アイテムを遅延評価して削除します。\n"
"\n"
"もし負の`n`が与えられたら、コレクションの最後の`n`アイテムが削除されま\n"
"す。この実装によるメカニズムは、`n`個のさらなるアイテムがenumによって発\n"
"生されるまで、どんなアイテムの放出も遅延されることに、注意してください。\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.drop(1..10, 5)\n"
"    iex> Enum.to_list(stream)\n"
"    [6, 7, 8, 9, 10]\n"
"\n"
"    iex> stream = Stream.drop(1..10, -5)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 3, 4, 5]\n"
"\n"

#. TRANSLATORS: def Stream.drop_while(enum, fun)
#: lib/stream.ex:290
msgid ""
"Lazily drops elements of the enumerable while the given\n"
"function returns `true`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.drop_while(1..10, &(&1 <= 5))\n"
"    iex> Enum.to_list(stream)\n"
"    [6, 7, 8, 9, 10]\n"
"\n"
msgstr ""
"与えられた関数を`true`にするenumerableの要素を遅延評価して削除します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.drop_while(1..10, &(&1 <= 5))\n"
"    iex> Enum.to_list(stream)\n"
"    [6, 7, 8, 9, 10]\n"
"\n"

#. TRANSLATORS: def Stream.into(enum, collectable, transform \\ fn x -> x end)
#: lib/stream.ex:403
msgid ""
"Injects the stream values into the given collectable as a side-effect.\n"
"\n"
"This function is often used with `run/1` since any evaluation\n"
"is delayed until the stream is executed. See `run/1` for an example.\n"
msgstr ""
"副作用として、与えられたcollectableにストリームの値を注入します。\n"
"\n"
"この関数は、ストリームが実行されるまでは、任意の評価が\n"
"遅延されるため、しばしば`run/1`と一緒に使われます。\n"
"例は`run/1`を参照してください。\n"

#. TRANSLATORS: def Stream.each(enum, fun)
#: lib/stream.ex:306
msgid ""
"Executes the given function for each item.\n"
"\n"
"Useful for adding side effects (like printing) to a stream.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.each([1, 2, 3], fn(x) -> send self, x end)\n"
"    iex> Enum.to_list(stream)\n"
"    iex> receive do: (x when is_integer(x) -> x)\n"
"    1\n"
"    iex> receive do: (x when is_integer(x) -> x)\n"
"    2\n"
"    iex> receive do: (x when is_integer(x) -> x)\n"
"    3\n"
"\n"
msgstr ""
"それぞれのアテイムについて、与えられた関数を実行します。\n"
"\n"
"ストリームに(プリントするような)副作用を加えるのに役立ちます。\n"
"\n"
"## 例\n"
"\n"
"    iex> stream = Stream.each([1, 2, 3], fn(x) -> send self, x end)\n"
"    iex> Enum.to_list(stream)\n"
"    iex> receive do: (x when is_integer(x) -> x)\n"
"    1\n"
"    iex> receive do: (x when is_integer(x) -> x)\n"
"    2\n"
"    iex> receive do: (x when is_integer(x) -> x)\n"
"    3\n"
"\n"

#. TRANSLATORS: def Stream.iterate(start_value, next_fun)
#: lib/stream.ex:1000
msgid ""
"Emits a sequence of values, starting with `start_value`. Successive\n"
"values are generated by calling `next_fun` on the previous value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.iterate(0, &(&1+1)) |> Enum.take(5)\n"
"    [0, 1, 2, 3, 4]\n"
"\n"
msgstr ""
"`start_value`で初まる値のシーケンスを放出します。\n"
"連続した値は、前の値で`next_fun`を呼び出すことにより生成されます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.iterate(0, &(&1+1)) |> Enum.take(5)\n"
"    [0, 1, 2, 3, 4]\n"
"\n"

#. TRANSLATORS: def Stream.resource(start_fun, next_fun, after_fun)
#: lib/stream.ex:1047
msgid ""
"Emits a sequence of values for the given resource.\n"
"\n"
"Similar to `transform/2` but the initial accumulated value is\n"
"computed lazily via `start_fun` and executes an `after_fun` at\n"
"the end of enumeration (both in cases of success and failure).\n"
"\n"
"Successive values are generated by calling `next_fun` with the\n"
"previous accumulator (the initial value being the result returned\n"
"by `start_fun`) and it must return a tuple containing a list\n"
"of items to be emitted and the next accumulator. The enumeration\n"
"finishes if it returns `{:halt, acc}`.\n"
"\n"
"As the name says, this function is useful to stream values from\n"
"resources.\n"
"\n"
"## Examples\n"
"\n"
"    Stream.resource(fn -> File.open!(\"sample\") end,\n"
"                    fn file ->\n"
"                      case IO.read(file, :line) do\n"
"                        data when is_binary(data) -> {[data], file}\n"
"                        _ -> {:halt, file}\n"
"                      end\n"
"                    end,\n"
"                    fn file -> File.close(file) end)\n"
"\n"
msgstr ""
"与えられたリソースから値のシーケンスを放出します。\n"
"\n"
"`transform/2`と似ていますが、初期値は`start_fun`により送れて計算され、\n"
"列挙の終わりに`after_run`を実行します(成功も失敗もどちらの場合でも)。\n"
"\n"
"連続した値は、前のアキュムレータ(初期値は`start_fun`により返って来た結\n"
"果になります)とともに、現在の値と次のアキュムレータのタプルを返さなくて\n"
"はならない`next_fun`を呼ぶことにより、生成されます。`nil`を返すと、列挙\n"
"は終わります。\n"
"\n"
"名前が言うように、この関数は、リソースから値をストリームするのに\n"
"便利です。\n"
"\n"
"## 例\n"
"\n"
"    Stream.resource(fn -> File.open!(\"sample\") end,\n"
"                    fn file ->\n"
"                      case IO.read(file, :line) do\n"
"                        data when is_binary(data) -> {data, file}\n"
"                        _ -> nil\n"
"                      end\n"
"                    end,\n"
"                    fn file -> File.close(file) end)\n"
"\n"

#. TRANSLATORS: def Stream.unfold(next_acc, next_fun)
#: lib/stream.ex:1162
msgid ""
"Emits a sequence of values for the given accumulator.\n"
"\n"
"Successive values are generated by calling `next_fun` with the previous\n"
"accumulator and it must return a tuple with the current value and next\n"
"accumulator. The enumeration finishes if it returns `nil`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.unfold(5, fn 0 -> nil; n -> {n, n-1} end) |> Enum.to_list()\n"
"    [5, 4, 3, 2, 1]\n"
"\n"
msgstr ""
"与えられたアキュムレータから値のシーケンスを放出します。\n"
"\n"
"連続した値は、前のアキュムレータとともに、現在の値と次のアキュムレータ\n"
"のタプルを返さなくてはならない`next_fun`を呼ぶことにより、生成されます。\n"
"`nil`を返すと、列挙は終わります。\n"
"\n"
"## 例\n"
"\n"
"    iex> Stream.unfold(5, fn 0 -> nil; n -> {n, n-1} end) |> Enum.to_list()\n"
"    [5, 4, 3, 2, 1]\n"
"\n"

#. TRANSLATORS: def Stream.with_index(enum)
#: lib/stream.ex:813
msgid ""
"Creates a stream where each item in the enumerable will\n"
"be wrapped in a tuple alongside its index.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.with_index([1, 2, 3])\n"
"    iex> Enum.to_list(stream)\n"
"    [{1, 0}, {2, 1}, {3, 2}]\n"
"\n"
msgstr ""
"enumerableのそれぞれのアイテムが、\n"
"そのインデックスと一緒にタプルにラップされた、\n"
"ストリームを作成します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.with_index([1, 2, 3])\n"
"    iex> Enum.to_list(stream)\n"
"    [{1, 0}, {2, 1}, {3, 2}]\n"
"\n"

#. TRANSLATORS: def Stream.reject(enum, fun)
#: lib/stream.ex:457
msgid ""
"Creates a stream that will reject elements according to\n"
"the given function on enumeration.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.reject([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 3]\n"
"\n"
msgstr ""
"与えられた関数に従って、列挙中の要素を拒否する\n"
"ストリームを作成します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.reject([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 3]\n"
"\n"

#. TRANSLATORS: def Stream.flat_map(enum, mapper)
#: lib/stream.ex:333
msgid ""
"Creates a stream that will apply the given function on enumeration and\n"
"flatten the result.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.flat_map([1, 2, 3], fn(x) -> [x, x * 2] end)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 2, 4, 3, 6]\n"
"\n"
msgstr ""
"列挙において、与えられた関数を適用し、結果をフラット化するストリームを\n"
"作成します。\n"
"\n"
"## 例\n"
"\n"
"    iex> stream = Stream.flat_map([1, 2, 3], fn(x) -> [x, x * 2] end)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 2, 4, 3, 6]\n"
"\n"

#. TRANSLATORS: def Stream.map(enum, fun)
#: lib/stream.ex:441
msgid ""
"Creates a stream that will apply the given function on\n"
"enumeration.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.map([1, 2, 3], fn(x) -> x * 2 end)\n"
"    iex> Enum.to_list(stream)\n"
"    [2, 4, 6]\n"
"\n"
msgstr ""
"列挙において、与えられた関数を適用するストリームを\n"
"作成します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.map([1, 2, 3], fn(x) -> x * 2 end)\n"
"    iex> Enum.to_list(stream)\n"
"    [2, 4, 6]\n"
"\n"

#. TRANSLATORS: def Stream.take_every(enum, nth)
#: lib/stream.ex:569
msgid ""
"Creates a stream that takes every `nth` item from the enumerable.\n"
"\n"
"The first item is always included, unless `nth` is 0.\n"
"\n"
"`nth` must be a non-negative integer, or `FunctionClauseError` will be "
"thrown.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.take_every(1..10, 2)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 3, 5, 7, 9]\n"
"\n"
"    iex> stream = Stream.take_every([1, 2, 3, 4, 5], 1)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 3, 4, 5]\n"
"\n"
"    iex> stream = Stream.take_every(1..1000, 0)\n"
"    iex> Enum.to_list(stream)\n"
"    []\n"
"\n"
msgstr ""
"enumerableから`nth`アイテム毎に取り出すストリームを\n"
"作成します。\n"
"\n"
"`nth`は0でないかぎり、最初のアイテムは常に含まれます。\n"
"\n"
"`nth`は非負の整数でなければなりません。さもなくば、\n"
"`FunctionClauseError`を投げます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.take_every(1..10, 2)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 3, 5, 7, 9]\n"
"\n"
"    iex> stream = Stream.take_every([1, 2, 3, 4, 5], 1)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 3, 4, 5]\n"
"\n"
"    iex> stream = Stream.take_every(1..1000, 0)\n"
"    iex> Enum.to_list(stream)\n"
"    []\n"
"\n"

#. TRANSLATORS: def Stream.uniq(enum, fun \\ fn x -> x end)
#: lib/stream.ex:790
msgid ""
"Creates a stream that only emits elements if they are unique.\n"
"\n"
"Keep in mind that, in order to know if an element is unique\n"
"or not, this function needs to store all unique values emitted\n"
"by the stream. Therefore, if the stream is infinite, the number\n"
"of items stored will grow infinitely, never being garbage collected.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.uniq([1, 2, 3, 3, 2, 1]) |> Enum.to_list\n"
"    [1, 2, 3]\n"
"\n"
"    iex> Stream.uniq([{1, :x}, {2, :y}, {2, :z}, {1, :x}], fn {x, _} -> x "
"end) |> Enum.to_list\n"
"    [{1, :x}, {2, :y}]\n"
"\n"
msgstr ""
"ユニークな要素だけを発するストリームを作成します。\n"
"\n"
"要素がユニークかそうでないかを知るために、この関数は、\n"
"ストリームから発せられた全てのユニークな値を保存する必要が\n"
"あることを心にとめておいていください。\n"
"従って、ストリームが無限であるなら、保存された値の数は無現に\n"
"増大し、決してガーベジコレクションされません。\n"
"\n"
"## 例\n"
"\n"
"    iex> Stream.uniq([1, 2, 3, 2, 1]) |> Enum.to_list\n"
"    [1, 2, 3]\n"
"\n"
"    iex> Stream.uniq([{1, :x}, {2, :y}, {1, :z}], fn {x, _} -> x end) |> "
"Enum.to_list\n"
"    [{1, :x}, {2, :y}]\n"
"\n"

#. TRANSLATORS: def Stream.dedup(enum)
#: lib/stream.ex:209
msgid ""
"Creates a stream that only emits elements if they are different from the "
"last emitted element.\n"
"\n"
"This function only ever needs to store the last emitted element.\n"
"\n"
"Elements are compared using `===`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.dedup([1, 2, 3, 3, 2, 1]) |> Enum.to_list\n"
"    [1, 2, 3, 2, 1]\n"
"\n"
msgstr ""
"最後に発出した要素から異る要素だけからなるstreamを作成します。\n"
"\n"
"この関数は最後に発出した要素を保存する必要があります。\n"
"\n"
"要素は `===` で比較されます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.dedup([1, 2, 3, 3, 2, 1]) |> Enum.to_list\n"
"    [1, 2, 3, 2, 1]\n"
"\n"

#. TRANSLATORS: def Stream.dedup_by(enum, fun)
#: lib/stream.ex:227
msgid ""
"Creates a stream that only emits elements if the result of calling `fun` on "
"the element is\n"
"different from the (stored) result of calling `fun` on the last emitted "
"element.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.dedup_by([{1, :x}, {2, :y}, {2, :z}, {1, :x}], fn {x, _} -> "
"x end) |> Enum.to_list\n"
"    [{1, :x}, {2, :y}, {1, :x}]\n"
"\n"
msgstr ""
"(保存された)最後に発出した要素を`fun`に適用した戻値と、\n"
"要素を`fun`に適用した結果が異る要素だけからなる、\n"
"streamを作成します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.dedup_by([{1, :x}, {2, :y}, {2, :z}, {1, :x}], fn {x, _} -> "
"x end) |> Enum.to_list\n"
"    [{1, :x}, {2, :y}, {1, :x}]\n"
"\n"

#. TRANSLATORS: def Stream.filter(enum, fun)
#: lib/stream.ex:349
msgid ""
"Creates a stream that filters elements according to\n"
"the given function on enumeration.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.filter([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    iex> Enum.to_list(stream)\n"
"    [2]\n"
"\n"
msgstr ""
"列挙において、与えられた関数に従って要素をフィルタする\n"
"ストリームを作成します。\n"
"\n"
"## 例\n"
"\n"
"    iex> stream = Stream.filter([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    iex> Enum.to_list(stream)\n"
"    [2]\n"
"\n"

#. TRANSLATORS: def Stream.filter_map(enum, filter, mapper)
#: lib/stream.ex:365
msgid ""
"Creates a stream that filters and then maps elements according\n"
"to given functions.\n"
"\n"
"Exists for symmetry with `Enum.filter_map/3`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.filter_map(1..6, fn(x) -> rem(x, 2) == 0 end, &(&1 "
"* 2))\n"
"    iex> Enum.to_list(stream)\n"
"    [4, 8, 12]\n"
"\n"
msgstr ""
"与えられた関数に従って、要素をフィルタしてマップする\n"
"ストリームを作成します。\n"
"\n"
"`Enum.filter_map/3`との対称性の為に存在します。\n"
"\n"
"## 例\n"
"\n"
"    iex> stream = Stream.filter_map(1..6, fn(x) -> rem(x, 2) == 0 end, &(&1 "
"* 2))\n"
"    iex> Enum.to_list(stream)\n"
"    [4, 8, 12]\n"
"\n"

#. TRANSLATORS: def Stream.concat(first, second)
#: lib/stream.ex:846
msgid ""
"Creates a stream that enumerates the first argument, followed by the "
"second.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.concat(1..3, 4..6)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 3, 4, 5, 6]\n"
"\n"
"    iex> stream1 = Stream.cycle([1, 2, 3])\n"
"    iex> stream2 = Stream.cycle([4, 5, 6])\n"
"    iex> stream = Stream.concat(stream1, stream2)\n"
"    iex> Enum.take(stream, 6)\n"
"    [1, 2, 3, 1, 2, 3]\n"
"\n"
msgstr ""
"最初の引数を列挙し、それから2番目を続ける\n"
"ストリームを作成します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.concat(1..3, 4..6)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 3, 4, 5, 6]\n"
"\n"
"    iex> stream1 = Stream.cycle([1, 2, 3])\n"
"    iex> stream2 = Stream.cycle([4, 5, 6])\n"
"    iex> stream = Stream.concat(stream1, stream2)\n"
"    iex> Enum.take(stream, 6)\n"
"    [1, 2, 3, 1, 2, 3]\n"
"\n"

#. TRANSLATORS: def Stream.concat(enumerables)
#: lib/stream.ex:831
msgid ""
"Creates a stream that enumerates each enumerable in an enumerable.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.concat([1..3, 4..6, 7..9])\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 3, 4, 5, 6, 7, 8, 9]\n"
"\n"
msgstr ""
"enumerableの中のそれぞれのenumerableを列挙する、\n"
"ストリームを作成します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.concat([1..3, 4..6, 7..9])\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 3, 4, 5, 6, 7, 8, 9]\n"
"\n"

#. TRANSLATORS: def Stream.interval(n)
#: lib/stream.ex:383
msgid ""
"Creates a stream that emits a value after the given period `n` in "
"milliseconds.\n"
"\n"
"The values emitted are an increasing counter starting at `0`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.interval(10) |> Enum.take(10)\n"
"    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n"
"\n"
msgstr ""
"`n`ミリセカンド毎に値を発生するストリームを作成します。\n"
"\n"
"発生される値は`0`から開始されます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.interval(10) |> Enum.take(10)\n"
"    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n"
"\n"

#. TRANSLATORS: def Stream.timer(n)
#: lib/stream.ex:615
msgid ""
"Creates a stream that emits a single value after `n` milliseconds.\n"
"\n"
"The value emitted is `0`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.timer(10) |> Enum.to_list\n"
"    [0]\n"
"\n"
msgstr ""
"`n`ミリセカンド後に一つの値を発生するストリームを作成します。\n"
"\n"
"発生する値は`0`です。\n"
"\n"
"## 例\n"
"\n"
"    iex> Stream.timer(10) |> Enum.to_list\n"
"    [0]\n"
"\n"

#. TRANSLATORS: def Stream.cycle(enumerable)
#: lib/stream.ex:942
msgid ""
"Creates a stream that cycles through the given enumerable,\n"
"infinitely.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.cycle([1, 2, 3])\n"
"    iex> Enum.take(stream, 5)\n"
"    [1, 2, 3, 1, 2]\n"
"\n"
msgstr ""
"与えられたenumerableを通して、無現に循環する\n"
"ストリームを作成します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.cycle([1, 2, 3])\n"
"    iex> Enum.take(stream, 5)\n"
"    [1, 2, 3, 1, 2]\n"
"\n"

#. TRANSLATORS: def Stream.scan(enum, acc, fun)
#: lib/stream.ex:515
msgid ""
"Creates a stream that applies the given function to each\n"
"element, emits the result and uses the same result as the accumulator\n"
"for the next computation. Uses the given `acc` as the starting value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.scan(1..5, 0, &(&1 + &2))\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 3, 6, 10, 15]\n"
"\n"
msgstr ""
"与えられた関数をそれぞれの要素とアキュムレータに適用し、\n"
"結果を発行するストリームを作成します。\n"
"その結果は、次の計算のためのアキュムレータとしても使われます。\n"
"\n"
"初期値は与えられた`acc`を使います。\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.scan(1..5, 0, &(&1 + &2))\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 3, 6, 10, 15]\n"
"\n"

#. TRANSLATORS: def Stream.scan(enum, fun)
#: lib/stream.ex:498
msgid ""
"Creates a stream that applies the given function to each\n"
"element, emits the result and uses the same result as the accumulator\n"
"for the next computation.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.scan(1..5, &(&1 + &2))\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 3, 6, 10, 15]\n"
"\n"
msgstr ""
"与えられた関数をそれぞれの要素とアキュムレータに適用し、\n"
"結果を発行するストリームを作成します。\n"
"その結果は、次の計算のためのアキュムレータとしても使われます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.scan(1..5, &(&1 + &2))\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 3, 6, 10, 15]\n"
"\n"

#. TRANSLATORS: def Stream.chunk_by(enum, fun)
#: lib/stream.ex:181
msgid ""
"Chunks the `enum` by buffering elements for which `fun` returns\n"
"the same value and only emit them when `fun` returns a new value\n"
"or the `enum` finishes.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.chunk_by([1, 2, 2, 3, 4, 4, 6, 7, 7], &(rem(&1, 2) "
"== 1))\n"
"    iex> Enum.to_list(stream)\n"
"    [[1], [2, 2], [3], [4, 4, 6], [7, 7]]\n"
"\n"
msgstr ""
"`fun`が同じ値を返す要素をバッファリングにより`enum`をチャンク\n"
"にします。`fun`が新しい値を返すか、`enum`が終了したときのみ\n"
"発行します。\n"
"\n"
"## 例\n"
"\n"
"    iex> stream = Stream.chunk_by([1, 2, 2, 3, 4, 4, 6, 7, 7], &(rem(&1, 2) "
"== 1))\n"
"    iex> Enum.to_list(stream)\n"
"    [[1], [2, 2], [3], [4, 4, 6], [7, 7]]\n"
"\n"

#. TRANSLATORS: def Stream.repeatedly(generator_fun)
#: lib/stream.ex:1021
msgid ""
"Returns a stream generated by calling `generator_fun` repeatedly.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.repeatedly(&:random.uniform/0) |> Enum.take(3)\n"
"    [0.4435846174457203, 0.7230402056221108, 0.94581636451987]\n"
"\n"
msgstr ""
"`generator_fun`を繰り返し呼ぶことで生成されたストリームを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Stream.repeatedly(&:random.uniform/0) |> Enum.take(3)\n"
"    [0.4435846174457203, 0.7230402056221108, 0.94581636451987]\n"
"\n"
