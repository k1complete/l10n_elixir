#. TRANSLATORS: def Stream.cycle(enumerable)
#: lib/stream.ex:947 
msgid ""
"Creates a stream that cycles through the given enumerable,\n"
"infinitely.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.cycle([1, 2, 3])\n"
"    iex> Enum.take(stream, 5)\n"
"    [1, 2, 3, 1, 2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.map(enum, fun)
#: lib/stream.ex:441 
msgid ""
"Creates a stream that will apply the given function on\n"
"enumeration.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.map([1, 2, 3], fn(x) -> x * 2 end)\n"
"    iex> Enum.to_list(stream)\n"
"    [2, 4, 6]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.timer(n)
#: lib/stream.ex:615 
msgid ""
"Creates a stream that emits a single value after `n` milliseconds.\n"
"\n"
"The value emitted is `0`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.timer(10) |> Enum.to_list\n"
"    [0]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.transform(enum, start_fun, reducer, after_fun)
#: lib/stream.ex:665 
msgid ""
"Transforms an existing stream with function-based start and finish.\n"
"\n"
"The accumulator is only calculated when transformation starts. It also\n"
"allows an after function to be given which is invoked when the stream\n"
"halts or completes.\n"
"\n"
"This function can be seen as a combination of `Stream.resource/3` with\n"
"`Stream.transform/3`.\n"
msgstr ""
#. TRANSLATORS: def Stream.concat(enumerables)
#: lib/stream.ex:836 
msgid ""
"Creates a stream that enumerates each enumerable in an enumerable.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.concat([1..3, 4..6, 7..9])\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 3, 4, 5, 6, 7, 8, 9]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.scan(enum, fun)
#: lib/stream.ex:498 
msgid ""
"Creates a stream that applies the given function to each\n"
"element, emits the result and uses the same result as the accumulator\n"
"for the next computation.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.scan(1..5, &(&1 + &2))\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 3, 6, 10, 15]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.unfold(next_acc, next_fun)
#: lib/stream.ex:1169 
msgid ""
"Emits a sequence of values for the given accumulator.\n"
"\n"
"Successive values are generated by calling `next_fun` with the previous\n"
"accumulator and it must return a tuple with the current value and next\n"
"accumulator. The enumeration finishes if it returns `nil`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.unfold(5, fn 0 -> nil; n -> {n, n-1} end) |> Enum.to_list()\n"
"    [5, 4, 3, 2, 1]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.resource(start_fun, next_fun, after_fun)
#: lib/stream.ex:1054 
msgid ""
"Emits a sequence of values for the given resource.\n"
"\n"
"Similar to `transform/3` but the initial accumulated value is\n"
"computed lazily via `start_fun` and executes an `after_fun` at\n"
"the end of enumeration (both in cases of success and failure).\n"
"\n"
"Successive values are generated by calling `next_fun` with the\n"
"previous accumulator (the initial value being the result returned\n"
"by `start_fun`) and it must return a tuple containing a list\n"
"of items to be emitted and the next accumulator. The enumeration\n"
"finishes if it returns `{:halt, acc}`.\n"
"\n"
"As the name says, this function is useful to stream values from\n"
"resources.\n"
"\n"
"## Examples\n"
"\n"
"    Stream.resource(fn -> File.open!(\"sample\") end,\n"
"                    fn file ->\n"
"                      case IO.read(file, :line) do\n"
"                        data when is_binary(data) -> {[data], file}\n"
"                        _ -> {:halt, file}\n"
"                      end\n"
"                    end,\n"
"                    fn file -> File.close(file) end)\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.each(enum, fun)
#: lib/stream.ex:306 
msgid ""
"Executes the given function for each item.\n"
"\n"
"Useful for adding side effects (like printing) to a stream.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.each([1, 2, 3], fn(x) -> send self, x end)\n"
"    iex> Enum.to_list(stream)\n"
"    iex> receive do: (x when is_integer(x) -> x)\n"
"    1\n"
"    iex> receive do: (x when is_integer(x) -> x)\n"
"    2\n"
"    iex> receive do: (x when is_integer(x) -> x)\n"
"    3\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.dedup_by(enum, fun)
#: lib/stream.ex:227 
msgid ""
"Creates a stream that only emits elements if the result of calling `fun` on the element is\n"
"different from the (stored) result of calling `fun` on the last emitted element.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.dedup_by([{1, :x}, {2, :y}, {2, :z}, {1, :x}], fn {x, _} -> x end) |> Enum.to_list\n"
"    [{1, :x}, {2, :y}, {1, :x}]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.chunk_by(enum, fun)
#: lib/stream.ex:181 
msgid ""
"Chunks the `enum` by buffering elements for which `fun` returns\n"
"the same value and only emit them when `fun` returns a new value\n"
"or the `enum` finishes.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.chunk_by([1, 2, 2, 3, 4, 4, 6, 7, 7], &(rem(&1, 2) == 1))\n"
"    iex> Enum.to_list(stream)\n"
"    [[1], [2, 2], [3], [4, 4, 6], [7, 7]]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.filter_map(enum, filter, mapper)
#: lib/stream.ex:365 
msgid ""
"Creates a stream that filters and then maps elements according\n"
"to given functions.\n"
"\n"
"Exists for symmetry with `Enum.filter_map/3`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.filter_map(1..6, fn(x) -> rem(x, 2) == 0 end, &(&1 * 2))\n"
"    iex> Enum.to_list(stream)\n"
"    [4, 8, 12]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.repeatedly(generator_fun)
#: lib/stream.ex:1026 
msgid ""
"Returns a stream generated by calling `generator_fun` repeatedly.\n"
"\n"
"## Examples\n"
"\n"
"    # Although not necessary, let's seed the random algorithm\n"
"    iex> :rand.seed(:exsplus, {1, 2, 3})\n"
"    iex> Stream.repeatedly(&:rand.uniform/0) |> Enum.take(3)\n"
"    [0.40502929729990744, 0.45336720247823126, 0.04094511692041057]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.transform(enum, acc, reducer)
#: lib/stream.ex:631 
msgid ""
"Transforms an existing stream.\n"
"\n"
"It expects an accumulator and a function that receives each stream item\n"
"and an accumulator, and must return a tuple containing a new stream\n"
"(often a list) with the new accumulator or a tuple with `:halt` as first\n"
"element and the accumulator as second.\n"
"\n"
"Note: this function is similar to `Enum.flat_map_reduce/3` except the\n"
"latter returns both the flat list and accumulator, while this one returns\n"
"only the stream.\n"
"\n"
"## Examples\n"
"\n"
"`Stream.transform/3` is useful as it can be used as the basis to implement\n"
"many of the functions defined in this module. For example, we can implement\n"
"`Stream.take(enum, n)` as follows:\n"
"\n"
"    iex> enum = 1..100\n"
"    iex> n = 3\n"
"    iex> stream = Stream.transform(enum, 0, fn i, acc ->\n"
"    ...>   if acc < n, do: {[i], acc + 1}, else: {:halt, acc}\n"
"    ...> end)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.drop(enum, n)
#: lib/stream.ex:242 
msgid ""
"Lazily drops the next `n` items from the enumerable.\n"
"\n"
"If a negative `n` is given, it will drop the last `n` items from\n"
"the collection. Note that the mechanism by which this is implemented\n"
"will delay the emission of any item until `n` additional items have\n"
"been emitted by the enum.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.drop(1..10, 5)\n"
"    iex> Enum.to_list(stream)\n"
"    [6, 7, 8, 9, 10]\n"
"\n"
"    iex> stream = Stream.drop(1..10, -5)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 3, 4, 5]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.take_while(enum, fun)
#: lib/stream.ex:599 
msgid ""
"Lazily takes elements of the enumerable while the given\n"
"function returns `true`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.take_while(1..100, &(&1 <= 5))\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 3, 4, 5]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.reject(enum, fun)
#: lib/stream.ex:457 
msgid ""
"Creates a stream that will reject elements according to\n"
"the given function on enumeration.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.reject([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.concat(first, second)
#: lib/stream.ex:851 
msgid ""
"Creates a stream that enumerates the first argument, followed by the second.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.concat(1..3, 4..6)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 3, 4, 5, 6]\n"
"\n"
"    iex> stream1 = Stream.cycle([1, 2, 3])\n"
"    iex> stream2 = Stream.cycle([4, 5, 6])\n"
"    iex> stream = Stream.concat(stream1, stream2)\n"
"    iex> Enum.take(stream, 6)\n"
"    [1, 2, 3, 1, 2, 3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.iterate(start_value, next_fun)
#: lib/stream.ex:1005 
msgid ""
"Emits a sequence of values, starting with `start_value`. Successive\n"
"values are generated by calling `next_fun` on the previous value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.iterate(0, &(&1+1)) |> Enum.take(5)\n"
"    [0, 1, 2, 3, 4]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.take(enum, count)
#: lib/stream.ex:532 
msgid ""
"Lazily takes the next `count` items from the enumerable and stops\n"
"enumeration.\n"
"\n"
"If a negative `count` is given, the last `count` values will be taken.\n"
"For such, the collection is fully enumerated keeping up to `2 * count`\n"
"elements in memory. Once the end of the collection is reached,\n"
"the last `count` elements will be executed. Therefore, using\n"
"a negative `count` on an infinite collection will never return.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.take(1..100, 5)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 3, 4, 5]\n"
"\n"
"    iex> stream = Stream.take(1..100, -5)\n"
"    iex> Enum.to_list(stream)\n"
"    [96, 97, 98, 99, 100]\n"
"\n"
"    iex> stream = Stream.cycle([1, 2, 3]) |> Stream.take(5)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 3, 1, 2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.chunk(enum, n)
#: lib/stream.ex:125 
msgid ""
"Shortcut to `chunk(enum, n, n)`.\n"
msgstr ""
#. TRANSLATORS: def Stream.uniq(enum, fun \\ fn x -> x end)
#: lib/stream.ex:790 
msgid ""
"Creates a stream that only emits elements if they are unique.\n"
"\n"
"Keep in mind that, in order to know if an element is unique\n"
"or not, this function needs to store all unique values emitted\n"
"by the stream. Therefore, if the stream is infinite, the number\n"
"of items stored will grow infinitely, never being garbage collected.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.uniq([1, 2, 3, 3, 2, 1]) |> Enum.to_list\n"
"    [1, 2, 3]\n"
"\n"
"    iex> Stream.uniq([{1, :x}, {2, :y}, {2, :z}, {1, :x}], fn {x, _} -> x end) |> Enum.to_list\n"
"    [{1, :x}, {2, :y}]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.filter(enum, fun)
#: lib/stream.ex:349 
msgid ""
"Creates a stream that filters elements according to\n"
"the given function on enumeration.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.filter([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    iex> Enum.to_list(stream)\n"
"    [2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.dedup(enum)
#: lib/stream.ex:209 
msgid ""
"Creates a stream that only emits elements if they are different from the last emitted element.\n"
"\n"
"This function only ever needs to store the last emitted element.\n"
"\n"
"Elements are compared using `===`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.dedup([1, 2, 3, 3, 2, 1]) |> Enum.to_list\n"
"    [1, 2, 3, 2, 1]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.take_every(enum, nth)
#: lib/stream.ex:569 
msgid ""
"Creates a stream that takes every `nth` item from the enumerable.\n"
"\n"
"The first item is always included, unless `nth` is 0.\n"
"\n"
"`nth` must be a non-negative integer, or `FunctionClauseError` will be thrown.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.take_every(1..10, 2)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 3, 5, 7, 9]\n"
"\n"
"    iex> stream = Stream.take_every([1, 2, 3, 4, 5], 1)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 3, 4, 5]\n"
"\n"
"    iex> stream = Stream.take_every(1..1000, 0)\n"
"    iex> Enum.to_list(stream)\n"
"    []\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.zip(left, right)
#: lib/stream.ex:872 
msgid ""
"Zips two collections together, lazily.\n"
"\n"
"The zipping finishes as soon as any enumerable completes.\n"
"\n"
"## Examples\n"
"\n"
"    iex> concat = Stream.concat(1..3, 4..6)\n"
"    iex> cycle  = Stream.cycle([:a, :b, :c])\n"
"    iex> Stream.zip(concat, cycle) |> Enum.to_list\n"
"    [{1, :a}, {2, :b}, {3, :c}, {4, :a}, {5, :b}, {6, :c}]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.drop_while(enum, fun)
#: lib/stream.ex:290 
msgid ""
"Lazily drops elements of the enumerable while the given\n"
"function returns `true`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.drop_while(1..10, &(&1 <= 5))\n"
"    iex> Enum.to_list(stream)\n"
"    [6, 7, 8, 9, 10]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.interval(n)
#: lib/stream.ex:383 
msgid ""
"Creates a stream that emits a value after the given period `n` in milliseconds.\n"
"\n"
"The values emitted are an increasing counter starting at `0`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.interval(10) |> Enum.take(10)\n"
"    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.scan(enum, acc, fun)
#: lib/stream.ex:515 
msgid ""
"Creates a stream that applies the given function to each\n"
"element, emits the result and uses the same result as the accumulator\n"
"for the next computation. Uses the given `acc` as the starting value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.scan(1..5, 0, &(&1 + &2))\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 3, 6, 10, 15]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.chunk(enum, n, step, pad \\ nil)
#: lib/stream.ex:131 
msgid ""
"Streams the enumerable in chunks, containing `n` items each, where\n"
"each new chunk starts `step` elements into the enumerable.\n"
"\n"
"`step` is optional and, if not passed, defaults to `n`, i.e.\n"
"chunks do not overlap. If the final chunk does not have `n`\n"
"elements to fill the chunk, elements are taken as necessary\n"
"from `pad` if it was passed. If `pad` is passed and does not\n"
"have enough elements to fill the chunk, then the chunk is\n"
"returned anyway with less than `n` elements. If `pad` is not\n"
"passed at all or is `nil`, then the partial chunk is discarded\n"
"from the result.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.chunk([1, 2, 3, 4, 5, 6], 2) |> Enum.to_list\n"
"    [[1, 2], [3, 4], [5, 6]]\n"
"\n"
"    iex> Stream.chunk([1, 2, 3, 4, 5, 6], 3, 2) |> Enum.to_list\n"
"    [[1, 2, 3], [3, 4, 5]]\n"
"\n"
"    iex> Stream.chunk([1, 2, 3, 4, 5, 6], 3, 2, [7]) |> Enum.to_list\n"
"    [[1, 2, 3], [3, 4, 5], [5, 6, 7]]\n"
"\n"
"    iex> Stream.chunk([1, 2, 3, 4, 5, 6], 3, 3, []) |> Enum.to_list\n"
"    [[1, 2, 3], [4, 5, 6]]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.into(enum, collectable, transform \\ fn x -> x end)
#: lib/stream.ex:403 
msgid ""
"Injects the stream values into the given collectable as a side-effect.\n"
"\n"
"This function is often used with `run/1` since any evaluation\n"
"is delayed until the stream is executed. See `run/1` for an example.\n"
msgstr ""
#. TRANSLATORS: def Stream.run(stream)
#: lib/stream.ex:473 
msgid ""
"Runs the given stream.\n"
"\n"
"This is useful when a stream needs to be run, for side effects,\n"
"and there is no interest in its return result.\n"
"\n"
"## Examples\n"
"\n"
"Open up a file, replace all `#` by `%` and stream to another file\n"
"without loading the whole file in memory:\n"
"\n"
"    stream = File.stream!(\"code\")\n"
"    |> Stream.map(&String.replace(&1, \"#\", \"%\"))\n"
"    |> Stream.into(File.stream!(\"new\"))\n"
"    |> Stream.run\n"
"\n"
"No computation will be done until we call one of the Enum functions\n"
"or `Stream.run/1`.\n"
msgstr ""
#. TRANSLATORS: def Stream.flat_map(enum, mapper)
#: lib/stream.ex:333 
msgid ""
"Creates a stream that will apply the given function on enumeration and\n"
"flatten the result.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.flat_map([1, 2, 3], fn(x) -> [x, x * 2] end)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 2, 4, 3, 6]\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.Stream Summary
#: lib/stream.ex:2 
msgid ""
"Module for creating and composing streams.\n"
"\n"
"Streams are composable, lazy enumerables. Any enumerable that generates\n"
"items one by one during enumeration is called a stream. For example,\n"
"Elixir's `Range` is a stream:\n"
"\n"
"    iex> range = 1..5\n"
"    1..5\n"
"    iex> Enum.map range, &(&1 * 2)\n"
"    [2, 4, 6, 8, 10]\n"
"\n"
"In the example above, as we mapped over the range, the elements being\n"
"enumerated were created one by one, during enumeration. The `Stream`\n"
"module allows us to map the range, without triggering its enumeration:\n"
"\n"
"    iex> range = 1..3\n"
"    iex> stream = Stream.map(range, &(&1 * 2))\n"
"    iex> Enum.map(stream, &(&1 + 1))\n"
"    [3, 5, 7]\n"
"\n"
"Notice we started with a range and then we created a stream that is\n"
"meant to multiply each item in the range by 2. At this point, no\n"
"computation was done. Only when `Enum.map/2` is called we actually\n"
"enumerate over each item in the range, multiplying it by 2 and adding 1.\n"
"We say the functions in `Stream` are *lazy* and the functions in `Enum`\n"
"are *eager*.\n"
"\n"
"Due to their laziness, streams are useful when working with large\n"
"(or even infinite) collections. When chaining many operations with `Enum`,\n"
"intermediate lists are created, while `Stream` creates a recipe of\n"
"computations that are executed at a later moment. Let's see another\n"
"example:\n"
"\n"
"    1..3\n"
"    |> Enum.map(&IO.inspect(&1))\n"
"    |> Enum.map(&(&1 * 2))\n"
"    |> Enum.map(&IO.inspect(&1))\n"
"    1\n"
"    2\n"
"    3\n"
"    2\n"
"    4\n"
"    6\n"
"    #=> [2, 4, 6]\n"
"\n"
"Notice that we first printed each item in the list, then multiplied each\n"
"element by 2 and finally printed each new value. In this example, the list\n"
"was enumerated three times. Let's see an example with streams:\n"
"\n"
"    stream = 1..3\n"
"    |> Stream.map(&IO.inspect(&1))\n"
"    |> Stream.map(&(&1 * 2))\n"
"    |> Stream.map(&IO.inspect(&1))\n"
"    Enum.to_list(stream)\n"
"    1\n"
"    2\n"
"    2\n"
"    4\n"
"    3\n"
"    6\n"
"    #=> [2, 4, 6]\n"
"\n"
"Although the end result is the same, the order in which the items were\n"
"printed changed! With streams, we print the first item and then print\n"
"its double. In this example, the list was enumerated just once!\n"
"\n"
"That's what we meant when we said earlier that streams are composable,\n"
"lazy enumerables. Notice we could call `Stream.map/2` multiple times,\n"
"effectively composing the streams and keeping them lazy. The computations\n"
"are only performed when you call a function from the `Enum` module.\n"
"\n"
"## Creating Streams\n"
"\n"
"There are many functions in Elixir's standard library that return\n"
"streams, some examples are:\n"
"\n"
"  * `IO.stream/2`         - streams input lines, one by one\n"
"  * `URI.query_decoder/1` - decodes a query string, pair by pair\n"
"\n"
"This module also provides many convenience functions for creating streams,\n"
"like `Stream.cycle/1`, `Stream.unfold/2`, `Stream.resource/3` and more.\n"
"\n"
"Note the functions in this module are guaranteed to return enumerables.\n"
"Since enumerables can have different shapes (structs, anonymous functions,\n"
"and so on), the functions in this module may return any of those shapes\n"
"and that this may change at any time. For example, a function that today\n"
"returns an anonymous function may return a struct in future releases.\n"
msgstr ""
#. TRANSLATORS: def Stream.with_index(enum, offset \\ 0)
#: lib/stream.ex:813 
msgid ""
"Creates a stream where each item in the enumerable will\n"
"be wrapped in a tuple alongside its index.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.with_index([1, 2, 3])\n"
"    iex> Enum.to_list(stream)\n"
"    [{1, 0}, {2, 1}, {3, 2}]\n"
"\n"
"    iex> stream = Stream.with_index([1, 2, 3], 3)\n"
"    iex> Enum.to_list(stream)\n"
"    [{1, 3}, {2, 4}, {3, 5}]\n"
"\n"
msgstr ""
