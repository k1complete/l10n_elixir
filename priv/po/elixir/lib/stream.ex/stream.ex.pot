#. TRANSLATORS: def Stream.zip(left, right)
#: lib/stream.ex:819 
msgid ""
"Zips two collections together, lazily.\n"
"\n"
"The zipping finishes as soon as any enumerable completes.\n"
"\n"
"## Examples\n"
"\n"
"    iex> concat = Stream.concat(1..3, 4..6)\n"
"    iex> cycle  = Stream.cycle([:a, :b, :c])\n"
"    iex> Stream.zip(concat, cycle) |> Enum.to_list\n"
"    [{1,:a},{2,:b},{3,:c},{4,:a},{5,:b},{6,:c}]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.transform(enum, acc, reducer)
#: lib/stream.ex:638 
msgid ""
"Transforms an existing stream.\n"
"\n"
"It expects an accumulator and a function that receives each stream item\n"
"and an accumulator, and must return a tuple containing a new stream\n"
"(often a list) with the new accumulator or a tuple with `:halt` as first\n"
"element and the accumulator as second.\n"
"\n"
"Note: this function is similar to `Enum.flat_map_reduce/3` except the\n"
"latter returns both the flat list and accumulator, while this one returns\n"
"only the stream.\n"
"\n"
"## Examples\n"
"\n"
"`Stream.transform/3` is useful as it can be used as the basis to implement\n"
"many of the functions defined in this module. For example, we can implement\n"
"`Stream.take(enum, n)` as follows:\n"
"\n"
"    iex> enum = 1..100\n"
"    iex> n = 3\n"
"    iex> stream = Stream.transform(enum, 0, fn i, acc ->\n"
"    ...>   if acc < n, do: {[i], acc + 1}, else: {:halt, acc}\n"
"    ...> end)\n"
"    iex> Enum.to_list(stream)\n"
"    [1,2,3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.chunk(enum, n)
#: lib/stream.ex:125 
msgid ""
"Shortcut to `chunk(enum, n, n)`.\n"
msgstr ""
#. TRANSLATORS: def Stream.chunk(enum, n, step, pad \\ nil)
#: lib/stream.ex:157 
msgid ""
"Streams the enumerable in chunks, containing `n` items each, where\n"
"each new chunk starts `step` elements into the enumerable.\n"
"\n"
"`step` is optional and, if not passed, defaults to `n`, i.e.\n"
"chunks do not overlap. If the final chunk does not have `n`\n"
"elements to fill the chunk, elements are taken as necessary\n"
"from `pad` if it was passed. If `pad` is passed and does not\n"
"have enough elements to fill the chunk, then the chunk is\n"
"returned anyway with less than `n` elements. If `pad` is not\n"
"passed at all or is `nil`, then the partial chunk is discarded\n"
"from the result.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.chunk([1, 2, 3, 4, 5, 6], 2) |> Enum.to_list\n"
"    [[1, 2], [3, 4], [5, 6]]\n"
"\n"
"    iex> Stream.chunk([1, 2, 3, 4, 5, 6], 3, 2) |> Enum.to_list\n"
"    [[1, 2, 3], [3, 4, 5]]\n"
"\n"
"    iex> Stream.chunk([1, 2, 3, 4, 5, 6], 3, 2, [7]) |> Enum.to_list\n"
"    [[1, 2, 3], [3, 4, 5], [5, 6, 7]]\n"
"\n"
"    iex> Stream.chunk([1, 2, 3, 4, 5, 6], 3, 3, []) |> Enum.to_list\n"
"    [[1, 2, 3], [4, 5, 6]]\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.Stream Summary
#: lib/stream.ex:1 
msgid ""
"Module for creating and composing streams.\n"
"\n"
"Streams are composable, lazy enumerables. Any enumerable that generates\n"
"items one by one during enumeration is called a stream. For example,\n"
"Elixir's `Range` is a stream:\n"
"\n"
"    iex> range = 1..5\n"
"    1..5\n"
"    iex> Enum.map range, &(&1 * 2)\n"
"    [2,4,6,8,10]\n"
"\n"
"In the example above, as we mapped over the range, the elements being\n"
"enumerated were created one by one, during enumeration. The `Stream`\n"
"module allows us to map the range, without triggering its enumeration:\n"
"\n"
"    iex> range = 1..3\n"
"    iex> stream = Stream.map(range, &(&1 * 2))\n"
"    iex> Enum.map(stream, &(&1 + 1))\n"
"    [3,5,7]\n"
"\n"
"Notice we started with a range and then we created a stream that is\n"
"meant to multiply each item in the range by 2. At this point, no\n"
"computation was done yet. Just when `Enum.map/2` is called we\n"
"enumerate over each item in the range, multiplying it by 2 and adding 1.\n"
"We say the functions in `Stream` are *lazy* and the functions in `Enum`\n"
"are *eager*.\n"
"\n"
"Due to their laziness, streams are useful when working with large\n"
"(or even infinite) collections. When chaining many operations with `Enum`,\n"
"intermediate lists are created, while `Stream` creates a recipe of\n"
"computations that are executed at a later moment. Let's see another\n"
"example:\n"
"\n"
"    1..3 |>\n"
"      Enum.map(&IO.inspect(&1)) |>\n"
"      Enum.map(&(&1 * 2)) |>\n"
"      Enum.map(&IO.inspect(&1))\n"
"    1\n"
"    2\n"
"    3\n"
"    2\n"
"    4\n"
"    6\n"
"    #=> [2,4,6]\n"
"\n"
"Notice that we first printed each item in the list, then multiplied each\n"
"element by 2 and finally printed each new value. In this example, the list\n"
"was enumerated three times. Let's see an example with streams:\n"
"\n"
"    stream = 1..3 |>\n"
"      Stream.map(&IO.inspect(&1)) |>\n"
"      Stream.map(&(&1 * 2)) |>\n"
"      Stream.map(&IO.inspect(&1))\n"
"    Enum.to_list(stream)\n"
"    1\n"
"    2\n"
"    2\n"
"    4\n"
"    3\n"
"    6\n"
"    #=> [2,4,6]\n"
"\n"
"Although the end result is the same, the order in which the items were\n"
"printed changed! With streams, we print the first item and then print\n"
"its double. In this example, the list was enumerated just once!\n"
"\n"
"That's what we meant when we first said that streams are composable,\n"
"lazy enumerables. Notice we could call `Stream.map/2` multiple times,\n"
"effectively composing the streams and they are lazy. The computations\n"
"are performed only when you call a function from the `Enum` module.\n"
"\n"
"## Creating Streams\n"
"\n"
"There are many functions in Elixir's standard library that return\n"
"streams, some examples are:\n"
"\n"
"  * `IO.stream/2`         - streams input lines, one by one\n"
"  * `URI.query_decoder/1` - decodes a query string, pair by pair\n"
"\n"
"This module also provides many convenience functions for creating streams,\n"
"like `Stream.cycle/1`, `Stream.unfold/2`, `Stream.resource/3` and more.\n"
"\n"
"Note the functions in this module are guaranteed to return enumerables.\n"
"Since enumerables can have different shapes (structs, anonymous functions,\n"
"and so on), the functions in this module may return any of those shapes\n"
"and that it may change at any time. For example, a function that today\n"
"returns an anonymous function may return a struct in future releases.\n"
msgstr ""
#. TRANSLATORS: def Stream.each(enum, fun)
#: lib/stream.ex:286 
msgid ""
"Executes the given function for each item.\n"
"\n"
"Useful for adding side effects (like printing) to a stream.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.each([1, 2, 3], fn(x) -> send self, x end)\n"
"    iex> Enum.to_list(stream)\n"
"    iex> receive do: (x when is_integer(x) -> x)\n"
"    1\n"
"    iex> receive do: (x when is_integer(x) -> x)\n"
"    2\n"
"    iex> receive do: (x when is_integer(x) -> x)\n"
"    3\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.take(enum, n)
#: lib/stream.ex:519 
msgid ""
"Lazily takes the next `n` items from the enumerable and stops\n"
"enumeration.\n"
"\n"
"If a negative `n` is given, the last `n` values will be taken.\n"
"For such, the collection is fully enumerated keeping up to `2 * n`\n"
"elements in memory. Once the end of the collection is reached,\n"
"the last `count` elements will be executed. Therefore, using\n"
"a negative `n` on an infinite collection will never return.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.take(1..100, 5)\n"
"    iex> Enum.to_list(stream)\n"
"    [1,2,3,4,5]\n"
"\n"
"    iex> stream = Stream.take(1..100, -5)\n"
"    iex> Enum.to_list(stream)\n"
"    [96,97,98,99,100]\n"
"\n"
"    iex> stream = Stream.cycle([1, 2, 3]) |> Stream.take(5)\n"
"    iex> Enum.to_list(stream)\n"
"    [1,2,3,1,2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.take_while(enum, fun)
#: lib/stream.ex:588 
msgid ""
"Lazily takes elements of the enumerable while the given\n"
"function returns `true`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.take_while(1..100, &(&1 <= 5))\n"
"    iex> Enum.to_list(stream)\n"
"    [1,2,3,4,5]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.drop(enum, n)
#: lib/stream.ex:224 
msgid ""
"Lazily drops the next `n` items from the enumerable.\n"
"\n"
"If a negative `n` is given, it will drop the last `n` items from\n"
"the collection. Note that the mechanism by which this is implemented\n"
"will delay the emission of any item until `n` additional items have\n"
"been emitted by the enum.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.drop(1..10, 5)\n"
"    iex> Enum.to_list(stream)\n"
"    [6,7,8,9,10]\n"
"\n"
"    iex> stream = Stream.drop(1..10, -5)\n"
"    iex> Enum.to_list(stream)\n"
"    [1,2,3,4,5]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.drop_while(enum, fun)
#: lib/stream.ex:264 
msgid ""
"Lazily drops elements of the enumerable while the given\n"
"function returns `true`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.drop_while(1..10, &(&1 <= 5))\n"
"    iex> Enum.to_list(stream)\n"
"    [6,7,8,9,10]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.iterate(start_value, next_fun)
#: lib/stream.ex:949 
msgid ""
"Emits a sequence of values, starting with `start_value`. Successive\n"
"values are generated by calling `next_fun` on the previous value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.iterate(0, &(&1+1)) |> Enum.take(5)\n"
"    [0,1,2,3,4]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.resource(start_fun, next_fun, after_fun)
#: lib/stream.ex:1014 
msgid ""
"Emits a sequence of values for the given resource.\n"
"\n"
"Similar to `transform/2` but the initial accumulated value is\n"
"computed lazily via `start_fun` and executes an `after_fun` at\n"
"the end of enumeration (both in cases of success and failure).\n"
"\n"
"Successive values are generated by calling `next_fun` with the\n"
"previous accumulator (the initial value being the result returned\n"
"by `start_fun`) and it must return a tuple containing a list\n"
"of items to be emitted and the next accumulator. The enumeration\n"
"finishes if it returns `{:halt, acc}`.\n"
"\n"
"As the name says, this function is useful to stream values from\n"
"resources.\n"
"\n"
"## Examples\n"
"\n"
"    Stream.resource(fn -> File.open!(\"sample\") end,\n"
"                    fn file ->\n"
"                      case IO.read(file, :line) do\n"
"                        data when is_binary(data) -> {[data], file}\n"
"                        _ -> {:halt, file}\n"
"                      end\n"
"                    end,\n"
"                    fn file -> File.close(file) end)\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.unfold(next_acc, next_fun)
#: lib/stream.ex:1114 
msgid ""
"Emits a sequence of values for the given accumulator.\n"
"\n"
"Successive values are generated by calling `next_fun` with the previous\n"
"accumulator and it must return a tuple with the current value and next\n"
"accumulator. The enumeration finishes if it returns `nil`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.unfold(5, fn 0 -> nil; n -> {n, n-1} end) |> Enum.to_list()\n"
"    [5, 4, 3, 2, 1]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.into(enum, collectable, transform \\ fn x -> x end)
#: lib/stream.ex:371 
msgid ""
"Injects the stream values into the given collectable as a side-effect.\n"
"\n"
"This function is often used with `run/1` since any evaluation\n"
"is delayed until the stream is executed. See `run/1` for an example.\n"
msgstr ""
#. TRANSLATORS: def Stream.with_index(enum)
#: lib/stream.ex:763 
msgid ""
"Creates a stream where each item in the enumerable will\n"
"be wrapped in a tuple alongside its index.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.with_index([1, 2, 3])\n"
"    iex> Enum.to_list(stream)\n"
"    [{1,0},{2,1},{3,2}]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.reject(enum, fun)
#: lib/stream.ex:430 
msgid ""
"Creates a stream that will reject elements according to\n"
"the given function on enumeration.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.reject([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    iex> Enum.to_list(stream)\n"
"    [1,3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.flat_map(enum, mapper)
#: lib/stream.ex:307 
msgid ""
"Creates a stream that will apply the given function on enumeration and\n"
"flatten the result.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.flat_map([1, 2, 3], fn(x) -> [x, x * 2] end)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 2, 4, 3, 6]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.map(enum, fun)
#: lib/stream.ex:414 
msgid ""
"Creates a stream that will apply the given function on\n"
"enumeration.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.map([1, 2, 3], fn(x) -> x * 2 end)\n"
"    iex> Enum.to_list(stream)\n"
"    [2,4,6]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.take_every(enum, n)
#: lib/stream.ex:570 
msgid ""
"Creates a stream that takes every `n` item from the enumerable.\n"
"\n"
"The first item is always included, unless `n` is 0.\n"
"\n"
"`n` must be a non-negative integer, or `FunctionClauseError` will be thrown.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.take_every(1..10, 2)\n"
"    iex> Enum.to_list(stream)\n"
"    [1,3,5,7,9]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.uniq(enum, fun \\ fn x -> x end)
#: lib/stream.ex:747 
msgid ""
"Creates a stream that only emits elements if they are unique.\n"
"\n"
"Keep in mind that, in order to know if an element is unique\n"
"or not, this function needs to store all unique values emitted\n"
"by the stream. Therefore, if the stream is infinite, the number\n"
"of items stored will grow infinitely, never being garbage collected.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.uniq([1, 2, 3, 2, 1]) |> Enum.to_list\n"
"    [1, 2, 3]\n"
"\n"
"    iex> Stream.uniq([{1, :x}, {2, :y}, {1, :z}], fn {x, _} -> x end) |> Enum.to_list\n"
"    [{1,:x}, {2,:y}]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.filter(enum, fun)
#: lib/stream.ex:323 
msgid ""
"Creates a stream that filters elements according to\n"
"the given function on enumeration.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.filter([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    iex> Enum.to_list(stream)\n"
"    [2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.filter_map(enum, filter, mapper)
#: lib/stream.ex:341 
msgid ""
"Creates a stream that filters and then maps elements according\n"
"to given functions.\n"
"\n"
"Exists for symmetry with `Enum.filter_map/3`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.filter_map(1..6, fn(x) -> rem(x, 2) == 0 end, &(&1 * 2))\n"
"    iex> Enum.to_list(stream)\n"
"    [4,8,12]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.concat(first, second)
#: lib/stream.ex:801 
msgid ""
"Creates a stream that enumerates the first argument, followed by the second.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.concat(1..3, 4..6)\n"
"    iex> Enum.to_list(stream)\n"
"    [1,2,3,4,5,6]\n"
"\n"
"    iex> stream1 = Stream.cycle([1, 2, 3])\n"
"    iex> stream2 = Stream.cycle([4, 5, 6])\n"
"    iex> stream = Stream.concat(stream1, stream2)\n"
"    iex> Enum.take(stream, 6)\n"
"    [1,2,3,1,2,3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.concat(enumerables)
#: lib/stream.ex:780 
msgid ""
"Creates a stream that enumerates each enumerable in an enumerable.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.concat([1..3, 4..6, 7..9])\n"
"    iex> Enum.to_list(stream)\n"
"    [1,2,3,4,5,6,7,8,9]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.interval(n)
#: lib/stream.ex:357 
msgid ""
"Creates a stream that emits a value every `n` milliseconds.\n"
"\n"
"The values emitted are an increasing counter starting at `0`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.interval(10) |> Enum.take(10)\n"
"    [0,1,2,3,4,5,6,7,8,9]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.timer(n)
#: lib/stream.ex:604 
msgid ""
"Creates a stream that emits a single value after `n` milliseconds.\n"
"\n"
"The value emitted is `0`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.timer(10) |> Enum.to_list\n"
"    [0]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.cycle(enumerable)
#: lib/stream.ex:892 
msgid ""
"Creates a stream that cycles through the given enumerable,\n"
"infinitely.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.cycle([1,2,3])\n"
"    iex> Enum.take(stream, 5)\n"
"    [1,2,3,1,2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.scan(enum, acc, fun)
#: lib/stream.ex:489 
msgid ""
"Creates a stream that applies the given function to each\n"
"element, emits the result and uses the same result as the accumulator\n"
"for the next computation. Uses the given `acc` as the starting value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.scan(1..5, 0, &(&1 + &2))\n"
"    iex> Enum.to_list(stream)\n"
"    [1,3,6,10,15]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.scan(enum, fun)
#: lib/stream.ex:472 
msgid ""
"Creates a stream that applies the given function to each\n"
"element, emits the result and uses the same result as the accumulator\n"
"for the next computation.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.scan(1..5, &(&1 + &2))\n"
"    iex> Enum.to_list(stream)\n"
"    [1,3,6,10,15]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.chunk_by(enum, fun)
#: lib/stream.ex:190 
msgid ""
"Chunks the `enum` by buffering elements for which `fun` returns\n"
"the same value and only emit them when `fun` returns a new value\n"
"or the `enum` finishes.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.chunk_by([1, 2, 2, 3, 4, 4, 6, 7, 7], &(rem(&1, 2) == 1))\n"
"    iex> Enum.to_list(stream)\n"
"    [[1], [2, 2], [3], [4, 4, 6], [7, 7]]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.run(stream)
#: lib/stream.ex:454 
msgid ""
"Runs the given stream.\n"
"\n"
"This is useful when a stream needs to be run, for side effects,\n"
"and there is no interest in its return result.\n"
"\n"
"## Examples\n"
"\n"
"Open up a file, replace all `#` by `%` and stream to another file\n"
"without loading the whole file in memory:\n"
"\n"
"    stream = File.stream!(\"code\")\n"
"    |> Stream.map(&String.replace(&1, \"#\", \"%\"))\n"
"    |> Stream.into(File.stream!(\"new\"))\n"
"    |> Stream.run\n"
"\n"
"No computation will be done until we call one of the Enum functions\n"
"or `Stream.run/1`.\n"
msgstr ""
#. TRANSLATORS: def Stream.repeatedly(generator_fun)
#: lib/stream.ex:969 
msgid ""
"Returns a stream generated by calling `generator_fun` repeatedly.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.repeatedly(&:random.uniform/0) |> Enum.take(3)\n"
"    [0.4435846174457203, 0.7230402056221108, 0.94581636451987]\n"
"\n"
msgstr ""
