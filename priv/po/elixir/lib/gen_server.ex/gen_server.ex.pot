#. TRANSLATORS: @type debug
#: lib/gen_server.ex:385 
msgid ""
"debug options supported by the `start*` functions"
msgstr ""
#. TRANSLATORS: @type from
#: lib/gen_server.ex:391 
msgid ""
"Tuple describing the client of a call request.\n"
"\n"
"`pid` is the pid of the caller and `tag` is a unique term used to identify the\n"
"call.\n"
msgstr ""
#. TRANSLATORS: @type server
#: lib/gen_server.ex:388 
msgid ""
"The server reference"
msgstr ""
#. TRANSLATORS: @type name
#: lib/gen_server.ex:376 
msgid ""
"The GenServer name"
msgstr ""
#. TRANSLATORS: def GenServer.start(module, args, options \\ [])
#: lib/gen_server.ex:491 
msgid ""
"Starts a `GenServer` process without links (outside of a supervision tree).\n"
"\n"
"See `start_link/3` for more information.\n"
msgstr ""
#. TRANSLATORS: def GenServer.start_link(module, args, options \\ [])
#: lib/gen_server.ex:447 
msgid ""
"Starts a `GenServer` process linked to the current process.\n"
"\n"
"This is often used to start the `GenServer` as part of a supervision tree.\n"
"\n"
"Once the server is started, it calls the `init/1` function in the given `module`\n"
"passing the given `args` to initialize it. To ensure a synchronized start-up\n"
"procedure, this function does not return until `init/1` has returned.\n"
"\n"
"Note that a `GenServer` started with `start_link/3` is linked to the\n"
"parent process and will exit in case of crashes. The GenServer will also\n"
"exit due to the `:normal` reasons in case it is configured to trap exits\n"
"in the `init/1` callback.\n"
"\n"
"## Options\n"
"\n"
"The `:name` option is used for name registration as described in the module\n"
"documentation. If the option `:timeout` option is present, the server is\n"
"allowed to spend the given milliseconds initializing or it will be\n"
"terminated and the start function will return `{:error, :timeout}`.\n"
"\n"
"If the `:debug` option is present, the corresponding function in the\n"
"[`:sys` module](http://www.erlang.org/doc/man/sys.html) will be invoked.\n"
"\n"
"If the `:spawn_opt` option is present, its value will be passed as options\n"
"to the underlying process as in `Process.spawn/4`.\n"
"\n"
"## Return values\n"
"\n"
"If the server is successfully created and initialized, the function returns\n"
"`{:ok, pid}`, where pid is the pid of the server. If a process with the \n"
"specified server name already exists, the function returns\n"
"`{:error, {:already_started, pid}}` with the pid of that process.\n"
"\n"
"If the `init/1` callback fails with `reason`, the function returns\n"
"`{:error, reason}`. Otherwise, if it returns `{:stop, reason}`\n"
"or `:ignore`, the process is terminated and the function returns\n"
"`{:error, reason}` or `:ignore`, respectively.\n"
msgstr ""
#. TRANSLATORS: def GenServer.cast(server, request)
#: lib/gen_server.ex:545 
msgid ""
"Sends an asynchronous request to the `server`.\n"
"\n"
"This function returns `:ok` without waiting for the\n"
"destination `server` to handle the message. Therefore it\n"
"is unknown whether the destination `server` successfully\n"
"handled the message. If the `server` is an atom without\n"
"an associated process an `ArgumentError` is raised. In\n"
"all other cases the function returns `:ok` regardless of\n"
"whether the destination `server` (or node) exists. Note\n"
"that `{name, node()}` can be used when an exception is\n"
"not desired if no process is locally associated with the\n"
"atom `name`.\n"
"\n"
"`handle_cast/2` will be called on the server to handle\n"
"the request. In case the `server` is on a node which is\n"
"not yet connected to the caller one, the call is going to\n"
"block until a connection happens. This is different than\n"
"the behaviour in OTP's `:gen_server` where the message\n"
"is sent by another process in this case, which could cause\n"
"messages to other nodes to arrive out of order.\n"
msgstr ""
#. TRANSLATORS: def GenServer.whereis(pid)
#: lib/gen_server.ex:665 
msgid ""
"Returns the `pid` or `{name, node}` of a GenServer process.\n"
"Returns `nil` if no process is associated with the given name.\n"
"\n"
"For example, to lookup a server process, monitor it and send a cast:\n"
"\n"
"    process = GenServer.whereis(server)\n"
"    monitor = Process.monitor(process)\n"
"    GenServer.cast(process, :hello)\n"
"\n"
msgstr ""
#. TRANSLATORS: def GenServer.reply(client, reply)
#: lib/gen_server.ex:640 
msgid ""
"Replies to a client.\n"
"\n"
"This function can be used by a server to explicitly send a reply to a\n"
"client that called `call/3` or `multi_call/4`. When the reply cannot be\n"
"defined in the return value of `handle_call/3`.\n"
"\n"
"The `client` must be the `from` argument (the second argument) received\n"
"in `handle_call/3` callbacks. Reply is an arbitrary term which will be\n"
"given back to the client as the return value of the call.\n"
"\n"
"This function always returns `:ok`.\n"
msgstr ""
#. TRANSLATORS: @type on_start
#: lib/gen_server.ex:373 
msgid ""
"Return values of `start*` functions"
msgstr ""
#. TRANSLATORS: def GenServer.call(server, request, timeout \\ 5000)
#: lib/gen_server.ex:512 
msgid ""
"Makes a synchronous call to the `server` and waits for its reply.\n"
"\n"
"The client sends the given `request` to the server and waits until a reply\n"
"arrives or a timeout occurs. `handle_call/3` will be called on the server\n"
"to handle the request.\n"
"\n"
"The server can be any of the values described in the `Name Registration`\n"
"section of the module documentation.\n"
"\n"
"## Timeouts\n"
"\n"
"The `timeout` is an integer greater than zero which specifies how many\n"
"milliseconds to wait for a reply, or the atom `:infinity` to wait\n"
"indefinitely. The default value is 5000. If no reply is received within\n"
"the specified time, the function call fails. If the caller catches the\n"
"failure and continues running, and the server is just late with the reply,\n"
"it may arrive at any time later into the caller's message queue. The caller\n"
"must in this case be prepared for this and discard any such garbage messages\n"
"that are two element tuples with a reference as the first element.\n"
msgstr ""
#. TRANSLATORS: @callback handle_call/3
#: lib/gen_server.ex:212 
msgid ""
"Invoked to handle synchronous `call/3` messages. `call/3` will block until a\n"
"reply is received (unless the call times out or nodes are disconnected).\n"
"\n"
"`request` is the request message sent by a `call/3`, `from` is a 2-tuple\n"
"containing the caller's pid and a term that uniquely identifies the call, and\n"
"`state` is the current state of the `GenServer`.\n"
"\n"
"Returning `{:reply, reply, new_state}` sends the response `reply` to the\n"
"caller and continues the loop with new state `new_state`.\n"
"\n"
"Returning `{:reply, reply, new_state, timeout}` is similar to\n"
"`{:reply, reply, new_state}` except `handle_info(:timeout, new_state)` will be\n"
"called after `timeout` milliseconds if no messages are receved.\n"
"\n"
"Returning `{:reply, reply, new_state, :hibernate}` is similar to\n"
"`{:reply, reply, new_state}` except the process is hibernated and will\n"
"continue the loop once a message is its message queue. If a message is already\n"
"in the message queue this will be immediately. Hibernating a `GenServer`\n"
"causes garbage collection and leaves a continuous heap that minimises the\n"
"memory used by the process.\n"
"\n"
"Hibernating should not be used aggressively as too much time could be spent\n"
"garbage collecting. Normally it should only be used when a message is not\n"
"expected soon and minimising the memory of the process is shown to be\n"
"beneficial.\n"
"\n"
"Returning `{:noreply, new_state}` does not send a response to the caller and\n"
"continues the loop with new state `new_state`. The response must be sent with\n"
"`reply/2`.\n"
"\n"
"There are three main use cases for not replying using the return value:\n"
"\n"
"- To reply before returning from the callback because the response is known\n"
"before calling a slow function.\n"
"- To reply after returning from the callback because the response is not yet\n"
"available.\n"
"- To reply from another process, such as a task.\n"
"\n"
"When replying from another process the `GenServer` should exit if the other\n"
"process exits without replying as the caller will be blocking awaiting a\n"
"reply.\n"
"\n"
"Returning `{:noreply, new_state, timeout | :hibernate}` is similar to\n"
"`{:noreply, new_state}` except a timeout or hibernation occurs as with a\n"
"`:reply` tuple.\n"
"\n"
"Returning `{:stop, reason, reply, new_state}` stops the loop and `terminate/2`\n"
"is called with reason `reason` and state `new_state`. Then the `reply` is sent\n"
"as the response to call and the process exits with reason `reason`.\n"
"\n"
"Returning `{:stop, reason, new_state}` is similar to\n"
"`{:stop, reason, reply, new_state}` except a reply is not sent.\n"
msgstr ""
#. TRANSLATORS: @callback handle_cast/2
#: lib/gen_server.ex:274 
msgid ""
"Invoked to handle asynchronous `cast/2` messages.\n"
"\n"
"`request` is the request message sent by a `cast/2` and `state` is the current\n"
"state of the `GenServer`.\n"
"\n"
"Returning `{:noreply, new_state}` continues the loop with new state `new_state`.\n"
"\n"
"Returning `{:noreply, new_state, timeout}` is similar to\n"
"`{:noreply, reply, new_state}` except `handle_info(:timeout, new_state)` will\n"
"be called after `timeout` milliseconds if no messages are received.\n"
"\n"
"Returning `{:noreply, new_state, :hibernate}` is similar to\n"
"`{:noreply, new_state}` except the process is hibernated before continuing the\n"
"loop. See `handle_call/3` for more information.\n"
"\n"
"Returning `{:stop, reason, new_state}` stops the loop and `terminate/2` is\n"
"called with the reason `reason` and state `new_state`. The process exits with\n"
"reason `reason`.\n"
msgstr ""
#. TRANSLATORS: @callback code_change/3
#: lib/gen_server.ex:350 
msgid ""
"Invoked to change the state of the `GenServer` when a different version of a\n"
"module is loaded (hot code swapping) and the state's term structure should be\n"
"changed.\n"
"\n"
"`old_vsn` is the previous version of the module (defined by the `@vsn`\n"
"attribute) when upgrading. When downgrading the previous version is wrapped in\n"
"a 2-tuple with first element `:down`. `state` is the current state of the\n"
"`GenServer` and `extra` is any extra data required to change the state.\n"
"\n"
"Returning `{:ok, new_state}` changes the state to `new_state` and the code\n"
"change is successful.\n"
"\n"
"Returning `{:error, reason}` fails the code change with reason `reason` and\n"
"the state remains as the previous state.\n"
"\n"
"If `code_change/3` raises the code change fails and the loop will continue\n"
"with its previous state. Therefore this callback does not usually contain side effects.\n"
msgstr ""
#. TRANSLATORS: @callback init/1
#: lib/gen_server.ex:171 
msgid ""
"Invoked when the server is started. `start_link/3` (or `start/3`) will\n"
"block until it returns.\n"
"\n"
"`args` is the argument term (second argument) passed to `start_link/3`.\n"
"\n"
"Returning `{:ok, state}` will cause `start_link/3` to return\n"
"`{:ok, pid}` and the process to enter its loop.\n"
"\n"
"Returning `{:ok, state, timeout}` is similar to `{:ok, state}`\n"
"except `handle_info(:timeout, state)` will be called after `timeout`\n"
"milliseconds if no messages are received within the timeout.\n"
"\n"
"Returning `{:ok, state, :hibernate}` is similar to\n"
"`{:ok, state}` except the process is hibernated before entering the loop. See\n"
"`handle_call/3` for more information on hibernation.\n"
"\n"
"Returning `:ignore` will cause `start_link/3` to return `:ignore` and the\n"
"process will exit normally without entering the loop or calling `terminate/2`.\n"
"If used when part of a supervision tree the parent supervisor will not fail\n"
"to start nor immediately try to restart the `GenServer`. The remainder of the\n"
"supervision tree will be (re)started and so the `GenServer` should not be\n"
"required by other processes. It can be started later with\n"
"`Supervisor.restart_child/2` as the child specification is saved in the parent\n"
"supervisor. The main use cases for this are:\n"
"\n"
"- The `GenServer` is disabled by configuration but might be enabled later.\n"
"- An error occured and it will be handled by a different mechanism than the\n"
"`Supervisor`. Likely this approach involves calling `Supervisor.restart_child/2`\n"
"after a delay to attempt a restart.\n"
"\n"
"Returning `{:stop, reason}` will cause `start_link/3` to return\n"
"`{:error, reason}` and the process to exit with reason `reason` without\n"
"entering the loop or calling `terminate/2`.\n"
msgstr ""
#. TRANSLATORS: @callback terminate/2
#: lib/gen_server.ex:312 
msgid ""
"Invoked when the server is about to exit. It should do any cleanup required.\n"
"\n"
"`reason` is exit reason and `state` is the current state of the `GenServer`.\n"
"The return value is ignored.\n"
"\n"
"`terminate/2` is called if a callback (except `init/1`) returns a `:stop`\n"
"tuple, raises, calls `Kernel.exit/1` or returns an invalid value. It may also\n"
"be called if the `GenServer` traps exits using `Process.flag/2` *and* the\n"
"parent process sends an exit signal.\n"
"\n"
"If part of a supervision tree a `GenServer`'s `Supervisor` will send an exit\n"
"signal when shutting it down. The exit signal is based on the shutdown\n"
"strategy in the child's specification. If it is `:brutal_kill` the `GenServer`\n"
"is killed and so `terminate/2` is not called. However if it is a timeout the\n"
"`Supervisor` will send the exit signal `:shutdown` and the `GenServer` will\n"
"have the duration of the timeout to call `terminate/2` - if the process is\n"
"still alive after the timeout it is killed.\n"
"\n"
"If the `GenServer` receives an exit signal (that is not `:normal`) from any\n"
"process when it is not trapping exits it will exit abruptly with the same\n"
"reason and so not call `terminate/2`. Note that a process does *NOT* trap\n"
"exits by default and an exit signal is sent when a linked process exits or its\n"
"node is disconnected.\n"
"\n"
"Therefore it is not guaranteed that `terminate/2` is called when a `GenServer`\n"
"exits. For such reasons, we usually recommend important clean-up rules to\n"
"happen in separated processes either by use of monitoring or by links\n"
"themselves. For example if the `GenServer` controls a `port` (e.g.\n"
"`:gen_tcp.socket`) or `File.io_device`, they will be closed on receiving a\n"
"`GenServer`'s exit signal and do not need to be closed in `terminate/2`.\n"
"\n"
"If `reason` is not `:normal`, `:shutdown` nor `{:shutdown, term}` an error is\n"
"logged.\n"
msgstr ""
#. TRANSLATORS: @callback handle_info/2
#: lib/gen_server.ex:299 
msgid ""
"Invoked to handle all other messages.\n"
"\n"
"`msg` is the message and `state` is the current state of the `GenServer`. When\n"
"a timeout occurs the message is `:timeout`.\n"
"\n"
"Return values are the same as `handle_cast/2`.\n"
msgstr ""
#. TRANSLATORS: def GenServer.abcast(nodes \\ nodes(), name, request)
#: lib/gen_server.ex:594 
msgid ""
"Casts all servers locally registered as `name` at the specified nodes.\n"
"\n"
"The function returns immediately and ignores nodes that do not exist, or where the\n"
"server name does not exist.\n"
"\n"
"See `multi_call/4` for more information.\n"
msgstr ""
#. TRANSLATORS: def GenServer.multi_call(nodes \\ nodes(), name, request, timeout \\ :infinity)
#: lib/gen_server.ex:618 
msgid ""
"Calls all servers locally registered as `name` at the specified `nodes`.\n"
"\n"
"The `request` is first sent to every node and then we wait for the\n"
"replies. This function returns a tuple containing the node and its reply\n"
"as first element and all bad nodes as second element. The bad nodes is a\n"
"list of nodes that either did not exist, or where a server with the given\n"
"`name` did not exist or did not reply.\n"
"\n"
"Nodes is a list of node names to which the request is sent. The default\n"
"value is the list of all known nodes.\n"
"\n"
"To avoid that late answers (after the timeout) pollute the caller's message\n"
"queue, a middleman process is used to do the actual calls. Late answers will\n"
"then be discarded when they arrive to a terminated process.\n"
msgstr ""
#. TRANSLATORS: Elixir.GenServer Summary
#: lib/gen_server.ex:2 
msgid ""
"A behaviour module for implementing the server of a client-server relation.\n"
"\n"
"A GenServer is a process as any other Elixir process and it can be used\n"
"to keep state, execute code asynchronously and so on. The advantage of using\n"
"a generic server process (GenServer) implemented using this module is that it\n"
"will have a standard set of interface functions and include functionality for\n"
"tracing and error reporting. It will also fit into a supervision tree.\n"
"\n"
"## Example\n"
"\n"
"The GenServer behaviour abstracts the common client-server interaction.\n"
"Developers are only required to implement the callbacks and functionality they are\n"
"interested in.\n"
"\n"
"Let's start with a code example and then explore the available callbacks.\n"
"Imagine we want a GenServer that works like a stack, allowing us to push\n"
"and pop items:\n"
"\n"
"  defmodule Stack do\n"
"    use GenServer\n"
"\n"
"    # Callbacks\n"
"\n"
"    def handle_call(:pop, _from, [h|t]) do\n"
"      {:reply, h, t}\n"
"    end\n"
"\n"
"    def handle_cast({:push, item}, state) do\n"
"      {:noreply, [item|state]}\n"
"    end\n"
"  end\n"
"\n"
"  # Start the server\n"
"  {:ok, pid} = GenServer.start_link(Stack, [:hello])\n"
"\n"
"  # This is the client\n"
"  GenServer.call(pid, :pop)\n"
"  #=> :hello\n"
"\n"
"  GenServer.cast(pid, {:push, :world})\n"
"  #=> :ok\n"
"\n"
"  GenServer.call(pid, :pop)\n"
"  #=> :world\n"
"\n"
"We start our `Stack` by calling `start_link/3`, passing the module\n"
"with the server implementation and its initial argument (a list\n"
"representing the stack containing the item `:hello`). We can primarily\n"
"interact with the server by sending two types of messages. **call**\n"
"messages expect a reply from the server (and are therefore synchronous)\n"
"while **cast** messages do not.\n"
"\n"
"Every time you do a `GenServer.call/3`, the client will send a message\n"
"that must be handled by the `handle_call/3` callback in the GenServer.\n"
"A `cast/2` message must be handled by `handle_cast/2`.\n"
"\n"
"## Callbacks\n"
"\n"
"There are 6 callbacks required to be implemented in a `GenServer`. By\n"
"adding `use GenServer` to your module, Elixir will automatically define\n"
"all 6 callbacks for you, leaving it up to you to implement the ones\n"
"you want to customize.\n"
"\n"
"## Name Registration\n"
"\n"
"Both `start_link/3` and `start/3` support the `GenServer` to register\n"
"a name on start via the `:name` option. Registered names are also\n"
"automatically cleaned up on termination. The supported values are:\n"
"\n"
"* an atom - the GenServer is registered locally with the given name\n"
"  using `Process.register/2`.\n"
"\n"
"* `{:global, term}`- the GenServer is registered globally with the given\n"
"  term using the functions in the `:global` module.\n"
"\n"
"* `{:via, module, term}` - the GenServer is registered with the given\n"
"  mechanism and name. The `:via` option expects a module name to control\n"
"  the registration mechanism alongside a name which can be any term.\n"
"\n"
"For example, we could start and register our Stack server locally as follows:\n"
"\n"
"  # Start the server and register it locally with name MyStack\n"
"  {:ok, _} = GenServer.start_link(Stack, [:hello], name: MyStack)\n"
"\n"
"  # Now messages can be sent directly to MyStack\n"
"  GenServer.call(MyStack, :pop) #=> :hello\n"
"\n"
"Once the server is started, the remaining functions in this module (`call/3`,\n"
"`cast/2`, and friends) will also accept an atom, or any `:global` or `:via`\n"
"tuples. In general, the following formats are supported:\n"
"\n"
"* a `pid`\n"
"* an `atom` if the server is locally registered\n"
"* `{atom, node}` if the server is locally registered at another node\n"
"* `{:global, term}` if the server is globally registered\n"
"* `{:via, module, name}` if the server is registered through an alternative\n"
"  registry\n"
"\n"
"## Client / Server APIs\n"
"\n"
"Although in the example above we have used `GenServer.start_link/3` and\n"
"friends to directly start and communicate with the server, most of the\n"
"time we don't call the `GenServer` functions directly. Instead, we wrap\n"
"the calls in new functions representing the public API of the server.\n"
"\n"
"Here is a better implementation of our Stack module:\n"
"\n"
"  defmodule Stack do\n"
"    use GenServer\n"
"\n"
"    # Client\n"
"\n"
"    def start_link(default) do\n"
"      GenServer.start_link(__MODULE__, default)\n"
"    end\n"
"\n"
"    def push(pid, item) do\n"
"      GenServer.cast(pid, {:push, item})\n"
"    end\n"
"\n"
"    def pop(pid) do\n"
"      GenServer.call(pid, :pop)\n"
"    end\n"
"\n"
"    # Server (callbacks)\n"
"\n"
"    def handle_call(:pop, _from, [h|t]) do\n"
"      {:reply, h, t}\n"
"    end\n"
"\n"
"    def handle_call(request, from, state) do\n"
"      # Call the default implementation from GenServer\n"
"      super(request, from, state)\n"
"    end\n"
"\n"
"    def handle_cast({:push, item}, state) do\n"
"      {:noreply, [item|state]}\n"
"    end\n"
"\n"
"    def handle_cast(request, state) do\n"
"      super(request, state)\n"
"    end\n"
"  end\n"
"\n"
"In practice, it is common to have both server and client functions in\n"
"the same module. If the server and/or client implementations are growing\n"
"complex, you may want to have them in different modules.\n"
"\n"
"## Receiving custom messages\n"
"\n"
"The goal of a `GenServer` is to abstract the \"receive\" loop for developers,\n"
"automatically handling system messages, support code change, synchronous\n"
"calls and more. Therefore, you should never call your own \"receive\" inside\n"
"the GenServer callbacks as doing so will cause the GenServer to misbehave.\n"
"If you want to receive custom messages, always receive them in `handle_info/2`.\n"
"\n"
"## Learn more\n"
"\n"
"If you wish to find out more about gen servers, the Elixir Getting Started\n"
"guide provides a tutorial-like introduction. The documentation and links\n"
"in Erlang can also provide extra insight.\n"
"\n"
"* http://elixir-lang.org/getting-started/mix-otp/genserver.html\n"
"* http://www.erlang.org/doc/man/gen_server.html\n"
"* http://www.erlang.org/doc/design_principles/gen_server_concepts.html\n"
"* http://learnyousomeerlang.com/clients-and-servers\n"
msgstr ""
