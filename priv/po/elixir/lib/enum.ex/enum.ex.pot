#. TRANSLATORS: def Enum.find_value(collection, ifnone \\ nil, fun)
#: lib/enum.ex:732 
msgid ""
"Similar to `find/3`, but returns the value of the function\n"
"invocation instead of the element itself.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.find_value([2, 4, 6], fn(x) -> rem(x, 2) == 1 end)\n"
"    nil\n"
"\n"
"    iex> Enum.find_value([2, 3, 4], fn(x) -> rem(x, 2) == 1 end)\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.find_index(collection, fun)
#: lib/enum.ex:759 
msgid ""
"Similar to `find/3`, but returns the index (zero-based)\n"
"of the element instead of the element itself.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.find_index([2, 4, 6], fn(x) -> rem(x, 2) == 1 end)\n"
"    nil\n"
"\n"
"    iex> Enum.find_index([2, 3, 4], fn(x) -> rem(x, 2) == 1 end)\n"
"    1\n"
"\n"
msgstr ""
#. TRANSLATORS: @type result
#: lib/enum.ex:0 
msgid ""
"The result of the reduce operation.\n"
"\n"
"It may be *done* when the enumeration is finished by reaching\n"
"its end, or *halted*/*suspended* when the enumeration was halted\n"
"or suspended by the reducer function.\n"
"\n"
"In case a reducer function returns the `:suspend` accumulator, the\n"
"`:suspended` tuple must be explicitly handled by the caller and\n"
"never leak. In practice, this means regular enumeration functions\n"
"just need to be concerned about `:done` and `:halted` results.\n"
"\n"
"Furthermore, a `:suspend` call must always be followed by another call,\n"
"eventually halting or continuing until the end.\n"
msgstr ""
#. TRANSLATORS: @type reducer
#: lib/enum.ex:0 
msgid ""
"The reducer function.\n"
"\n"
"Should be called with the collection element and the\n"
"accumulator contents. Returns the accumulator for\n"
"the next enumeration step.\n"
msgstr ""
#. TRANSLATORS: @type acc
#: lib/enum.ex:0 
msgid ""
"The accumulator value for each step.\n"
"\n"
"It must be a tagged tuple with one of the following \"tags\":\n"
"\n"
"  * `:cont`    - the enumeration should continue\n"
"  * `:halt`    - the enumeration should halt immediately\n"
"  * `:suspend` - the enumeration should be suspended immediately\n"
"\n"
"Depending on the accumulator value, the result returned by\n"
"`Enumerable.reduce/3` will change. Please check the `result`\n"
"type docs for more information.\n"
"\n"
"In case a reducer function returns a `:suspend` accumulator,\n"
"it must be explicitly handled by the caller and never leak.\n"
msgstr ""
#. TRANSLATORS: def Enum.zip(coll1, coll2)
#: lib/enum.ex:2034 
msgid ""
"Zips corresponding elements from two collections into one list\n"
"of tuples.\n"
"\n"
"The zipping finishes as soon as any enumerable completes.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.zip([1, 2, 3], [:a, :b, :c])\n"
"    [{1,:a},{2,:b},{3,:c}]\n"
"\n"
"    iex> Enum.zip([1,2,3,4,5], [:a, :b, :c])\n"
"    [{1,:a},{2,:b},{3,:c}]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.take_while(collection, fun)
#: lib/enum.ex:1939 
msgid ""
"Takes the items at the beginning of `collection` while `fun` returns `true`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.take_while([1, 2, 3], fn(x) -> x < 3 end)\n"
"    [1, 2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.take(collection, count)
#: lib/enum.ex:1883 
msgid ""
"Takes the first `count` items from the collection.\n"
"\n"
"`count` must be an integer. If a negative `count` is given, the last `count` values will\n"
"be taken. For such, the collection is fully enumerated keeping up\n"
"to `2 * count` elements in memory. Once the end of the collection is\n"
"reached, the last `count` elements are returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.take([1, 2, 3], 2)\n"
"    [1,2]\n"
"\n"
"    iex> Enum.take([1, 2, 3], 10)\n"
"    [1,2,3]\n"
"\n"
"    iex> Enum.take([1, 2, 3], 0)\n"
"    []\n"
"\n"
"    iex> Enum.take([1, 2, 3], -1)\n"
"    [3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.chunk(coll, n)
#: lib/enum.ex:307 
msgid ""
"Shortcut to `chunk(coll, n, n)`.\n"
msgstr ""
#. TRANSLATORS: def Enum.chunk(coll, n, step, pad \\ nil)
#: lib/enum.ex:338 
msgid ""
"Returns a collection of lists containing `n` items each, where\n"
"each new chunk starts `step` elements into the collection.\n"
"\n"
"`step` is optional and, if not passed, defaults to `n`, i.e.\n"
"chunks do not overlap. If the final chunk does not have `n`\n"
"elements to fill the chunk, elements are taken as necessary\n"
"from `pad` if it was passed. If `pad` is passed and does not\n"
"have enough elements to fill the chunk, then the chunk is\n"
"returned anyway with less than `n` elements. If `pad` is not\n"
"passed at all or is `nil`, then the partial chunk is discarded\n"
"from the result.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4, 5, 6], 2)\n"
"    [[1, 2], [3, 4], [5, 6]]\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4, 5, 6], 3, 2)\n"
"    [[1, 2, 3], [3, 4, 5]]\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4, 5, 6], 3, 2, [7])\n"
"    [[1, 2, 3], [3, 4, 5], [5, 6, 7]]\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4, 5, 6], 3, 3, [])\n"
"    [[1, 2, 3], [4, 5, 6]]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.take_every(collection, nth)
#: lib/enum.ex:1920 
msgid ""
"Returns a collection of every `nth` item in the collection,\n"
"starting with the first element.\n"
"\n"
"The second argument specifying every `nth` item must be a non-negative integer.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.take_every(1..10, 2)\n"
"    [1, 3, 5, 7, 9]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.drop(collection, count)
#: lib/enum.ex:485 
msgid ""
"Drops the first `count` items from `collection`.\n"
"\n"
"If a negative value `count` is given, the last `count`\n"
"values will be dropped. The collection is enumerated\n"
"once to retrieve the proper index and the remaining\n"
"calculation is performed from the end.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.drop([1, 2, 3], 2)\n"
"    [3]\n"
"\n"
"    iex> Enum.drop([1, 2, 3], 10)\n"
"    []\n"
"\n"
"    iex> Enum.drop([1, 2, 3], 0)\n"
"    [1,2,3]\n"
"\n"
"    iex> Enum.drop([1, 2, 3], -1)\n"
"    [1,2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.drop_while(collection, fun)
#: lib/enum.ex:513 
msgid ""
"Drops items at the beginning of `collection` while `fun` returns `true`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.drop_while([1, 2, 3, 4, 5], fn(x) -> x < 3 end)\n"
"    [3,4,5]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.shuffle(collection)
#: lib/enum.ex:1581 
msgid ""
"Returns a list of collection elements shuffled.\n"
"\n"
"Notice that you need to explicitly call `:random.seed/1` and\n"
"set a seed value for the random algorithm. Otherwise, the\n"
"default seed will be set which will always return the same\n"
"result. For example, one could do the following to set a seed\n"
"dynamically:\n"
"\n"
"    :random.seed(:os.timestamp)\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.shuffle([1, 2, 3])\n"
"    [3, 2, 1]\n"
"    iex> Enum.shuffle([1, 2, 3])\n"
"    [3, 1, 2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.empty?(collection)
#: lib/enum.ex:562 
msgid ""
"Returns `true` if the collection is empty, otherwise `false`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.empty?([])\n"
"    true\n"
"\n"
"    iex> Enum.empty?([1, 2, 3])\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enumerable.count(collection)
#: lib/enum.ex:140 
msgid ""
"Retrieves the collection's size.\n"
"\n"
"It should return `{:ok, size}`.\n"
"\n"
"If `{:error, __MODULE__}` is returned a default algorithm using `reduce` and\n"
"the match (`===`) operator is used. This algorithm runs in linear time.\n"
"\n"
"Please force use of the default algorithm unless you can implement an\n"
"algorithm that is significantly faster.\n"
msgstr ""
#. TRANSLATORS: def Enumerable.reduce(collection, acc, fun)
#: lib/enum.ex:112 
msgid ""
"Reduces the collection into a value.\n"
"\n"
"Most of the operations in `Enum` are implemented in terms of reduce.\n"
"This function should apply the given `reducer` function to each\n"
"item in the collection and proceed as expected by the returned accumulator.\n"
"\n"
"As an example, here is the implementation of `reduce` for lists:\n"
"\n"
"    def reduce(_,     {:halt, acc}, _fun),   do: {:halted, acc}\n"
"    def reduce(list,  {:suspend, acc}, fun), do: {:suspended, acc, &reduce(list, &1, fun)}\n"
"    def reduce([],    {:cont, acc}, _fun),   do: {:done, acc}\n"
"    def reduce([h|t], {:cont, acc}, fun),    do: reduce(t, fun.(h, acc), fun)\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.Enum Summary
#: lib/enum.ex:143 
msgid ""
"Provides a set of algorithms that enumerate over collections according to the\n"
"`Enumerable` protocol:\n"
"\n"
"    iex> Enum.map([1, 2, 3], fn(x) -> x * 2 end)\n"
"    [2,4,6]\n"
"\n"
"Some particular types, like dictionaries, yield a specific format on\n"
"enumeration. For dicts, the argument is always a `{key, value}` tuple:\n"
"\n"
"    iex> dict = %{a: 1, b: 2}\n"
"    iex> Enum.map(dict, fn {k, v} -> {k, v * 2} end)\n"
"    [a: 2, b: 4]\n"
"\n"
"Note that the functions in the `Enum` module are eager: they always start\n"
"the enumeration of the given collection. The `Stream` module allows\n"
"lazy enumeration of collections and provides infinite streams.\n"
"\n"
"Since the majority of the functions in `Enum` enumerate the whole\n"
"collection and return a list as result, infinite streams need to\n"
"be carefully used with such functions, as they can potentially run\n"
"forever. For example:\n"
"\n"
"    Enum.each Stream.cycle([1,2,3]), &IO.puts(&1)\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.flat_map_reduce(collection, acc, fun)
#: lib/enum.ex:818 
msgid ""
"Maps and reduces a collection, flattening the given results.\n"
"\n"
"It expects an accumulator and a function that receives each stream item\n"
"and an accumulator, and must return a tuple containing a new stream\n"
"(often a list) with the new accumulator or a tuple with `:halt` as first\n"
"element and the accumulator as second.\n"
"\n"
"## Examples\n"
"\n"
"    iex> enum = 1..100\n"
"    iex> n = 3\n"
"    iex> Enum.flat_map_reduce(enum, 0, fn i, acc ->\n"
"    ...>   if acc < n, do: {[i], acc + 1}, else: {:halt, acc}\n"
"    ...> end)\n"
"    {[1,2,3], 3}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.map_join(collection, joiner \\ "", mapper)
#: lib/enum.ex:1001 
msgid ""
"Maps and joins the given `collection` in one pass.\n"
"`joiner` can be either a binary or a list and the\n"
"result will be of the same type as `joiner`. If\n"
"`joiner` is not passed at all, it defaults to an\n"
"empty binary.\n"
"\n"
"All items in the collection must be convertible\n"
"to a binary, otherwise an error is raised.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.map_join([1, 2, 3], &(&1 * 2))\n"
"    \"246\"\n"
"\n"
"    iex> Enum.map_join([1, 2, 3], \" = \", &(&1 * 2))\n"
"    \"2 = 4 = 6\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.concat(enumerables)
#: lib/enum.ex:387 
msgid ""
"Given an enumerable of enumerables, concatenates the enumerables into a single list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.concat([1..3, 4..6, 7..9])\n"
"    [1,2,3,4,5,6,7,8,9]\n"
"\n"
"    iex> Enum.concat([[1, [2], 3], [4], [5, 6]])\n"
"    [1,[2],3,4,5,6]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.fetch(collection, n)
#: lib/enum.ex:596 
msgid ""
"Finds the element at the given index (zero-based).\n"
"\n"
"Returns `{:ok, element}` if found, otherwise `:error`.\n"
"\n"
"A negative index can be passed, which means the collection is\n"
"enumerated once and the index is counted from the end (i.e.\n"
"`-1` fetches the last element).\n"
"\n"
"Note this operation takes linear time. In order to access\n"
"the element at index `n`, it will need to traverse `n`\n"
"previous elements.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.fetch([2, 4, 6], 0)\n"
"    {:ok, 2}\n"
"\n"
"    iex> Enum.fetch([2, 4, 6], 2)\n"
"    {:ok, 6}\n"
"\n"
"    iex> Enum.fetch([2, 4, 6], 4)\n"
"    :error\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.at(collection, n, default \\ nil)
#: lib/enum.ex:296 
msgid ""
"Finds the element at the given index (zero-based).\n"
"\n"
"Returns `default` if index is out of bounds.\n"
"\n"
"Note this operation takes linear time. In order to access\n"
"the element at index `n`, it will need to traverse `n`\n"
"previous elements.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.at([2, 4, 6], 0)\n"
"    2\n"
"\n"
"    iex> Enum.at([2, 4, 6], 2)\n"
"    6\n"
"\n"
"    iex> Enum.at([2, 4, 6], 4)\n"
"    nil\n"
"\n"
"    iex> Enum.at([2, 4, 6], 4, :none)\n"
"    :none\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.join(collection, joiner \\ "")
#: lib/enum.ex:943 
msgid ""
"Joins the given `collection` into a binary using `joiner` as a separator.\n"
"If `joiner` is not passed at all, it defaults to the empty binary.\n"
"\n"
"All items in the collection must be convertible\n"
"to a binary, otherwise an error is raised.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.join([1, 2, 3])\n"
"    \"123\"\n"
"\n"
"    iex> Enum.join([1, 2, 3], \" = \")\n"
"    \"1 = 2 = 3\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.each(collection, fun)
#: lib/enum.ex:536 
msgid ""
"Invokes the given `fun` for each item in the `collection`.\n"
"Returns `:ok`.\n"
"\n"
"## Examples\n"
"\n"
"    Enum.each([\"some\", \"example\"], fn(x) -> IO.puts x end)\n"
"    \"some\"\n"
"    \"example\"\n"
"    #=> :ok\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.any?(collection, fun \\ fn x -> x end)
#: lib/enum.ex:259 
msgid ""
"Invokes the given `fun` for each item in the `collection` and returns `true` if\n"
"at least one invocation returns `true`. Returns `false` otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.any?([2, 4, 6], fn(x) -> rem(x, 2) == 1 end)\n"
"    false\n"
"\n"
"    iex> Enum.any?([2, 3, 4], fn(x) -> rem(x, 2) == 1 end)\n"
"    true\n"
"\n"
"If no function is given, it defaults to checking if\n"
"at least one item in the collection evaluates to `true`.\n"
"\n"
"    iex> Enum.any?([false, false, false])\n"
"    false\n"
"\n"
"    iex> Enum.any?([false, true, false])\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.all?(collection, fun \\ fn x -> x end)
#: lib/enum.ex:222 
msgid ""
"Invokes the given `fun` for each item in the `collection` and returns `false`\n"
"if at least one invocation returns `false`. Otherwise returns `true`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.all?([2, 4, 6], fn(x) -> rem(x, 2) == 0 end)\n"
"    true\n"
"\n"
"    iex> Enum.all?([2, 3, 4], fn(x) -> rem(x, 2) == 0 end)\n"
"    false\n"
"\n"
"If no function is given, it defaults to checking if\n"
"all items in the collection evaluate to `true`.\n"
"\n"
"    iex> Enum.all?([1, 2, 3])\n"
"    true\n"
"\n"
"    iex> Enum.all?([1, nil, 3])\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.map_reduce(collection, acc, fun)
#: lib/enum.ex:1032 
msgid ""
"Invokes the given `fun` for each item in the `collection`\n"
"while also keeping an accumulator. Returns a tuple where\n"
"the first element is the mapped collection and the second\n"
"one is the final accumulator.\n"
"\n"
"For dicts, the first tuple element must be a `{key, value}`\n"
"tuple.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.map_reduce([1, 2, 3], 0, fn(x, acc) -> {x * 2, x + acc} end)\n"
"    {[2, 4, 6], 6}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.reduce(collection, fun)
#: lib/enum.ex:1346 
msgid ""
"Invokes `fun` for each element in the collection passing that element and the\n"
"accumulator `acc` as arguments. `fun`'s return value is stored in `acc`.\n"
"The first element of the collection is used as the initial value of `acc`.\n"
"Returns the accumulator.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reduce([1, 2, 3, 4], fn(x, acc) -> x * acc end)\n"
"    24\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.reduce(collection, acc, fun)
#: lib/enum.ex:1315 
msgid ""
"Invokes `fun` for each element in the collection passing that element and the\n"
"accumulator `acc` as arguments. `fun`'s return value is stored in `acc`.\n"
"Returns the accumulator.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reduce([1, 2, 3], 0, fn(x, acc) -> x + acc end)\n"
"    6\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.intersperse(collection, element)
#: lib/enum.ex:850 
msgid ""
"Intersperses `element` between each element of the enumeration.\n"
"\n"
"Complexity: O(n)\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.intersperse([1, 2, 3], 0)\n"
"    [1, 0, 2, 0, 3]\n"
"\n"
"    iex> Enum.intersperse([1], 0)\n"
"    [1]\n"
"\n"
"    iex> Enum.intersperse([], 0)\n"
"    []\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.sort_by(collection, mapper, sorter \\ :erlang.make_fun(:erlang, :"=<", 2))
#: lib/enum.ex:1775 
msgid ""
"Sorts the mapped results of the `collection` according to the `sorter` function.\n"
"\n"
"This function maps each element of the collection using the `mapper`\n"
"function.  The collection is then sorted by the mapped elements using the\n"
"`sorter` function, which defaults to `<=/2`\n"
"\n"
"`sort_by/3` differs from `sort/2` in that it only calculates the comparison\n"
"value for each element in the collection once instead of once for each\n"
"element in each comparison.  If the same function is being called on both\n"
"element, it's also more compact to use `sort_by/3`.\n"
"\n"
"This technique is also known as a\n"
"[Schwartzian Transform](https://en.wikipedia.org/wiki/Schwartzian_transform),\n"
"or the Lisp decorate-sort-undecorate idiom as the `mapper` is decorating the\n"
"original `collection`, then `sorter` is sorting the decorations, and finally\n"
"the `collection` is being undecorated so only the original elements remain,\n"
"but now in sorted order.\n"
"\n"
"## Examples\n"
"\n"
"Using the default `sorter` of `<=/2`:\n"
"\n"
"    iex> Enum.sort_by [\"some\", \"kind\", \"of\", \"monster\"], &byte_size/1\n"
"    [\"of\", \"some\", \"kind\", \"monster\"]\n"
"\n"
"Using a custom `sorter` to override the order:\n"
"\n"
"    iex> Enum.sort_by [\"some\", \"kind\", \"of\", \"monster\"], &byte_size/1, &>=/2\n"
"    [\"monster\", \"some\", \"kind\", \"of\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.sort(collection, fun)
#: lib/enum.ex:1734 
msgid ""
"Sorts the collection by the given function.\n"
"\n"
"This function uses the merge sort algorithm. The given function\n"
"must return false if the first argument is less than right one.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.sort([1, 2, 3], &(&1 > &2))\n"
"    [3, 2, 1]\n"
"\n"
"The sorting algorithm will be stable as long as the given function\n"
"returns true for values considered equal:\n"
"\n"
"    iex> Enum.sort [\"some\", \"kind\", \"of\", \"monster\"], &(byte_size(&1) <= byte_size(&2))\n"
"    [\"of\", \"some\", \"kind\", \"monster\"]\n"
"\n"
"If the function does not return true, the sorting is not stable and\n"
"the order of equal terms may be shuffled:\n"
"\n"
"    iex> Enum.sort [\"some\", \"kind\", \"of\", \"monster\"], &(byte_size(&1) < byte_size(&2))\n"
"    [\"of\", \"kind\", \"some\", \"monster\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.sort(collection)
#: lib/enum.ex:1701 
msgid ""
"Sorts the collection according to Elixir's term ordering.\n"
"\n"
"Uses the merge sort algorithm.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.sort([3, 2, 1])\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.split(collection, count)
#: lib/enum.ex:1811 
msgid ""
"Splits the enumerable into two collections, leaving `count`\n"
"elements in the first one. If `count` is a negative number,\n"
"it starts counting from the back to the beginning of the\n"
"collection.\n"
"\n"
"Be aware that a negative `count` implies the collection\n"
"will be enumerated twice: once to calculate the position, and\n"
"a second time to do the actual splitting.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.split([1, 2, 3], 2)\n"
"    {[1,2], [3]}\n"
"\n"
"    iex> Enum.split([1, 2, 3], 10)\n"
"    {[1,2,3], []}\n"
"\n"
"    iex> Enum.split([1, 2, 3], 0)\n"
"    {[], [1,2,3]}\n"
"\n"
"    iex> Enum.split([1, 2, 3], -1)\n"
"    {[1,2], [3]}\n"
"\n"
"    iex> Enum.split([1, 2, 3], -5)\n"
"    {[], [1,2,3]}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.group_by(collection, dict \\ %{}, fun)
#: lib/enum.ex:1297 
msgid ""
"Splits `collection` into groups based on `fun`.\n"
"\n"
"The result is a dict (by default a map) where each key is\n"
"a group and each value is a list of elements from `collection`\n"
"for which `fun` returned that group. Ordering is not necessarily\n"
"preserved.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.group_by(~w{ant buffalo cat dingo}, &String.length/1)\n"
"    %{3 => [\"cat\", \"ant\"], 7 => [\"buffalo\"], 5 => [\"dingo\"]}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.split_while(collection, fun)
#: lib/enum.ex:1842 
msgid ""
"Splits `collection` in two while `fun` returns `true`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.split_while([1, 2, 3, 4], fn(x) -> x < 3 end)\n"
"    {[1, 2], [3, 4]}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.chunk_by(coll, fun)
#: lib/enum.ex:362 
msgid ""
"Splits `coll` on every element for which `fun` returns a new value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.chunk_by([1, 2, 2, 3, 4, 4, 6, 7, 7], &(rem(&1, 2) == 1))\n"
"    [[1], [2, 2], [3], [4, 4, 6], [7, 7]]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.sum(collection)
#: lib/enum.ex:1253 
msgid ""
"Returns the sum of all values.\n"
"\n"
"Raises `ArithmeticError` if collection contains a non-numeric value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.sum([1, 2, 3])\n"
"    6\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.into(collection, list)
#: lib/enum.ex:875 
msgid ""
"Inserts the given enumerable into a collectable.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.into([1, 2], [0])\n"
"    [0, 1, 2]\n"
"\n"
"    iex> Enum.into([a: 1, b: 2], %{})\n"
"    %{a: 1, b: 2}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.into(collection, list, transform)
#: lib/enum.ex:902 
msgid ""
"Inserts the given enumerable into a collectable\n"
"according to the transformation function.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.into([2, 3], [3], fn x -> x * 3 end)\n"
"    [3, 6, 9]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.fetch!(collection, n)
#: lib/enum.ex:643 
msgid ""
"Finds the element at the given index (zero-based).\n"
"\n"
"Raises `OutOfBoundsError` if the given position\n"
"is outside the range of the collection.\n"
"\n"
"Note this operation takes linear time. In order to access\n"
"the element at index `n`, it will need to traverse `n`\n"
"previous elements.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.fetch!([2, 4, 6], 0)\n"
"    2\n"
"\n"
"    iex> Enum.fetch!([2, 4, 6], 2)\n"
"    6\n"
"\n"
"    iex> Enum.fetch!([2, 4, 6], 4)\n"
"    ** (Enum.OutOfBoundsError) out of bounds error\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.filter(collection, fun)
#: lib/enum.ex:661 
msgid ""
"Filters the collection, i.e. returns only those elements\n"
"for which `fun` returns `true`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.filter([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    [2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.filter_map(collection, filter, mapper)
#: lib/enum.ex:680 
msgid ""
"Filters the collection and maps its values in one pass.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.filter_map([1, 2, 3], fn(x) -> rem(x, 2) == 0 end, &(&1 * 2))\n"
"    [4]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.partition(collection, fun)
#: lib/enum.ex:1269 
msgid ""
"Partitions `collection` into two collections, where the first one contains elements\n"
"for which `fun` returns a truthy value, and the second one -- for which `fun`\n"
"returns `false` or `nil`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.partition([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    {[2], [1,3]}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.unzip(coll)
#: lib/enum.ex:2010 
msgid ""
"Opposite of `Enum.zip/2`; takes a list of two-element tuples and returns a\n"
"tuple with two lists, each of which is formed by the first and second element\n"
"of each tuple, respectively.\n"
"\n"
"This function fails unless `coll` is or can be converted into a list of\n"
"tuples with *exactly* two elements in each tuple.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.unzip([{:a, 1}, {:b, 2}, {:c, 3}])\n"
"    {[:a, :b, :c], [1, 2, 3]}\n"
"\n"
"    iex> Enum.unzip(%{a: 1, b: 2})\n"
"    {[:a, :b], [1, 2]}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.uniq(collection, fun \\ fn x -> x end)
#: lib/enum.ex:1980 
msgid ""
"Enumerates the collection, removing all duplicated items.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.uniq([1, 2, 3, 2, 1])\n"
"    [1, 2, 3]\n"
"\n"
"    iex> Enum.uniq([{1, :x}, {2, :y}, {1, :z}], fn {x, _} -> x end)\n"
"    [{1,:x}, {2,:y}]\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.Enumerable Summary
#: lib/enum.ex:1 
msgid ""
"Enumerable protocol used by `Enum` and `Stream` modules.\n"
"\n"
"When you invoke a function in the `Enum` module, the first argument\n"
"is usually a collection that must implement this protocol. For example,\n"
"the expression\n"
"\n"
"    Enum.map([1, 2, 3], &(&1 * 2))\n"
"\n"
"invokes underneath `Enumerable.reduce/3` to perform the reducing\n"
"operation that builds a mapped list by calling the mapping function\n"
"`&(&1 * 2)` on every element in the collection and cons'ing the\n"
"element with an accumulated list.\n"
"\n"
"Internally, `Enum.map/2` is implemented as follows:\n"
"\n"
"    def map(enum, fun) do\n"
"      reducer = fn x, acc -> {:cont, [fun.(x)|acc]} end\n"
"      Enumerable.reduce(enum, {:cont, []}, reducer) |> elem(1) |> :lists.reverse()\n"
"    end\n"
"\n"
"Notice the user given function is wrapped into a `reducer` function.\n"
"The `reducer` function must return a tagged tuple after each step,\n"
"as described in the `acc/0` type.\n"
"\n"
"The reason the accumulator requires a tagged tuple is to allow the\n"
"reducer function to communicate to the underlying enumerable the end\n"
"of enumeration, allowing any open resource to be properly closed. It\n"
"also allows suspension of the enumeration, which is useful when\n"
"interleaving between many enumerables is required (as in zip).\n"
"\n"
"Finally, `Enumerable.reduce/3` will return another tagged tuple,\n"
"as represented by the `result/0` type.\n"
msgstr ""
#. TRANSLATORS: def Enum.concat(left, right)
#: lib/enum.ex:406 
msgid ""
"Concatenates the enumerable on the right with the enumerable on the left.\n"
"\n"
"This function produces the same result as the `Kernel.++/2` operator for lists.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.concat(1..3, 4..6)\n"
"    [1,2,3,4,5,6]\n"
"\n"
"    iex> Enum.concat([1, 2, 3], [4, 5, 6])\n"
"    [1,2,3,4,5,6]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enumerable.member?(collection, value)
#: lib/enum.ex:126 
msgid ""
"Checks if a value exists within the collection.\n"
"\n"
"It should return `{:ok, boolean}`.\n"
"\n"
"If `{:error, __MODULE__}` is returned a default algorithm using `reduce` and\n"
"the match (`===`) operator is used. This algorithm runs in linear time.\n"
"\n"
"Please force use of the default algorithm unless you can implement an\n"
"algorithm that is significantly faster.\n"
msgstr ""
#. TRANSLATORS: def Enum.member?(collection, value)
#: lib/enum.ex:1114 
msgid ""
"Checks if `value` exists within the `collection`.\n"
"\n"
"Membership is tested with the match (`===`) operator, although\n"
"enumerables like ranges may include floats inside the given\n"
"range.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.member?(1..10, 5)\n"
"    true\n"
"\n"
"    iex> Enum.member?([:a, :b, :c], :d)\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.reverse(collection)
#: lib/enum.ex:1397 
msgid ""
"Reverses the collection.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reverse([1, 2, 3])\n"
"    [3, 2, 1]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.reverse_slice(coll, start, count)
#: lib/enum.ex:1440 
msgid ""
"Reverses the collection in the range from initial position `first`\n"
"through `count` elements. If `count` is greater than the size of\n"
"the rest of the collection, then this function will reverse the rest\n"
"of the collection.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reverse_slice([1, 2, 3, 4, 5, 6], 2, 4)\n"
"    [1, 2, 6, 5, 4, 3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.reverse(collection, tail)
#: lib/enum.ex:1417 
msgid ""
"Reverses the collection and appends the tail.\n"
"This is an optimization for\n"
"`Enum.concat(Enum.reverse(collection), tail)`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reverse([1, 2, 3], [4, 5, 6])\n"
"    [3, 2, 1, 4, 5, 6]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.min(collection)
#: lib/enum.ex:1141 
msgid ""
"Returns the minimum value.\n"
"Raises `EmptyError` if the collection is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.min([1, 2, 3])\n"
"    1\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.min_by(collection, fun)
#: lib/enum.ex:1156 
msgid ""
"Returns the minimum value as calculated by the given function.\n"
"Raises `EmptyError` if the collection is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.min_by([\"a\", \"aa\", \"aaa\"], fn(x) -> String.length(x) end)\n"
"    \"a\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.max(collection)
#: lib/enum.ex:1055 
msgid ""
"Returns the maximum value.\n"
"Raises `EmptyError` if the collection is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.max([1, 2, 3])\n"
"    3\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.max_by(collection, fun)
#: lib/enum.ex:1070 
msgid ""
"Returns the maximum value as calculated by the given function.\n"
"Raises `EmptyError` if the collection is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.max_by([\"a\", \"aa\", \"aaa\"], fn(x) -> String.length(x) end)\n"
"    \"aaa\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.count(collection, fun)
#: lib/enum.ex:455 
msgid ""
"Returns the count of items in the collection for which\n"
"`fun` returns `true`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.count([1, 2, 3, 4, 5], fn(x) -> rem(x, 2) == 0 end)\n"
"    2\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.count(collection)
#: lib/enum.ex:429 
msgid ""
"Returns the collection's size.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.count([1, 2, 3])\n"
"    3\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.find(collection, ifnone \\ nil, fun)
#: lib/enum.ex:706 
msgid ""
"Returns the first item for which `fun` returns a truthy value. If no such\n"
"item is found, returns `ifnone`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.find([2, 4, 6], fn(x) -> rem(x, 2) == 1 end)\n"
"    nil\n"
"\n"
"    iex> Enum.find([2, 4, 6], 0, fn(x) -> rem(x, 2) == 1 end)\n"
"    0\n"
"\n"
"    iex> Enum.find([2, 3, 4], fn(x) -> rem(x, 2) == 1 end)\n"
"    3\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.minmax(collection)
#: lib/enum.ex:1194 
msgid ""
"Returns a tuple with the minimum and maximum values.\n"
"Raises `EmptyError` if the collection is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.minmax([2, 3, 1])\n"
"    {1, 3}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.minmax_by(collection, fun)
#: lib/enum.ex:1220 
msgid ""
"Returns a tuple with the minimum and maximum values as calculated by the given function.\n"
"Raises `EmptyError` if the collection is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.minmax_by([\"aaa\", \"bb\", \"c\"], fn(x) -> String.length(x) end)\n"
"    {\"c\", \"aaa\"}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.with_index(collection)
#: lib/enum.ex:2053 
msgid ""
"Returns the collection with each element wrapped in a tuple\n"
"alongside its index.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.with_index [1,2,3]\n"
"    [{1,0},{2,1},{3,2}]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.reject(collection, fun)
#: lib/enum.ex:1379 
msgid ""
"Returns elements of collection for which `fun` returns `false`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reject([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    [1, 3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.slice(coll, start, count)
#: lib/enum.ex:1609 
msgid ""
"Returns a subset list of the given collection. Drops elements\n"
"until element position `start`, then takes `count` elements.\n"
"\n"
"If the count is greater than collection length, it returns as\n"
"much as possible. If zero, then it returns `[]`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.slice(1..100, 5, 10)\n"
"    [6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n"
"\n"
"    iex> Enum.slice(1..10, 5, 100)\n"
"    [6, 7, 8, 9, 10]\n"
"\n"
"    iex> Enum.slice(1..10, 5, 0)\n"
"    []\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.slice(coll, arg2)
#: lib/enum.ex:1668 
msgid ""
"Returns a subset list of the given collection. Drops elements\n"
"until element position `range.first`, then takes elements until element\n"
"position `range.last` (inclusive).\n"
"\n"
"Positions are calculated by adding the number of items in the collection to\n"
"negative positions (so position -3 in a collection with count 5 becomes\n"
"position 2).\n"
"\n"
"The first position (after adding count to negative positions) must be smaller\n"
"or equal to the last position.\n"
"\n"
"If the start of the range is not a valid offset for the given\n"
"collection or if the range is in reverse order, returns `[]`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.slice(1..100, 5..10)\n"
"    [6, 7, 8, 9, 10, 11]\n"
"\n"
"    iex> Enum.slice(1..10, 5..20)\n"
"    [6, 7, 8, 9, 10]\n"
"\n"
"    iex> Enum.slice(1..10, 11..20)\n"
"    []\n"
"\n"
"    iex> Enum.slice(1..10, 6..5)\n"
"    []\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.sample(collection, count)
#: lib/enum.ex:1505 
msgid ""
"Returns a random sublist of a collection.\n"
"\n"
"Notice this function will traverse the whole collection to\n"
"get the random sublist of collection. If you want the random\n"
"number between two integers, the best option is to use the\n"
":random module.\n"
"\n"
"See `sample/1` for notes on implementation and random seed.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.sample(1..10, 2)\n"
"    [1, 5]\n"
"    iex> Enum.sample(?a..?z, 5)\n"
"    'tfesm'\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.sample(collection)
#: lib/enum.ex:1479 
msgid ""
"Returns a random element of a collection.\n"
"Raises `EmptyError` if the collection is empty.\n"
"\n"
"Notice that you need to explicitly call `:random.seed/1` and\n"
"set a seed value for the random algorithm. Otherwise, the\n"
"default seed will be set which will always return the same\n"
"result. For example, one could do the following to set a seed\n"
"dynamically:\n"
"\n"
"    :random.seed(:os.timestamp)\n"
"\n"
"The implementation is based on the\n"
"[reservoir sampling](http://en.wikipedia.org/wiki/Reservoir_sampling#Relation_to_Fisher-Yates_shuffle)\n"
"algorithm.\n"
"It assumes that the sample being returned can fit into memory;\n"
"the input collection doesn't have to - it is traversed just once.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.sample([1,2,3])\n"
"    1\n"
"    iex> Enum.sample([1,2,3])\n"
"    2\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.map(collection, fun)
#: lib/enum.ex:973 
msgid ""
"Returns a new collection, where each item is the result\n"
"of invoking `fun` on each corresponding item of `collection`.\n"
"\n"
"For dicts, the function expects a key-value tuple.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.map([1, 2, 3], fn(x) -> x * 2 end)\n"
"    [2, 4, 6]\n"
"\n"
"    iex> Enum.map([a: 1, b: 2], fn({k, v}) -> {k, -v} end)\n"
"    [a: -1, b: -2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.flat_map(collection, fun)
#: lib/enum.ex:791 
msgid ""
"Returns a new collection appending the result of invoking `fun`\n"
"on each corresponding item of `collection`.\n"
"\n"
"The given function should return an enumerable.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.flat_map([:a, :b, :c], fn(x) -> [x, x] end)\n"
"    [:a, :a, :b, :b, :c, :c]\n"
"\n"
"    iex> Enum.flat_map([{1,3}, {4,6}], fn({x,y}) -> x..y end)\n"
"    [1, 2, 3, 4, 5, 6]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.scan(enum, acc, fun)
#: lib/enum.ex:1555 
msgid ""
"Applies the given function to each element in the collection,\n"
"storing the result in a list and passing it as the accumulator\n"
"for the next computation. Uses the given `acc` as the starting value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.scan(1..5, 0, &(&1 + &2))\n"
"    [1,3,6,10,15]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.scan(enum, fun)
#: lib/enum.ex:1537 
msgid ""
"Applies the given function to each element in the collection,\n"
"storing the result in a list and passing it as the accumulator\n"
"for the next computation.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.scan(1..5, &(&1 + &2))\n"
"    [1,3,6,10,15]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.to_list(collection)
#: lib/enum.ex:1958 
msgid ""
"Converts `collection` to a list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.to_list(1 .. 3)\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
#. TRANSLATORS: @type continuation
#: lib/enum.ex:0 
msgid ""
"A partially applied reduce function.\n"
"\n"
"The continuation is the closure returned as a result when\n"
"the enumeration is suspended. When invoked, it expects\n"
"a new accumulator and it returns the result.\n"
"\n"
"A continuation is easily implemented as long as the reduce\n"
"function is defined in a tail recursive fashion. If the function\n"
"is tail recursive, all the state is passed as arguments, so\n"
"the continuation would simply be the reducing function partially\n"
"applied.\n"
msgstr ""
