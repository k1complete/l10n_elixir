#. TRANSLATORS: def Enum.split(enumerable, count)
#: lib/enum.ex:1951 
msgid ""
"Splits the `enumerable` into two enumerables, leaving `count`\n"
"elements in the first one. If `count` is a negative number,\n"
"it starts counting from the back to the beginning of the\n"
"enumerable.\n"
"\n"
"Be aware that a negative `count` implies the `enumerable`\n"
"will be enumerated twice: once to calculate the position, and\n"
"a second time to do the actual splitting.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.split([1, 2, 3], 2)\n"
"    {[1, 2], [3]}\n"
"\n"
"    iex> Enum.split([1, 2, 3], 10)\n"
"    {[1, 2, 3], []}\n"
"\n"
"    iex> Enum.split([1, 2, 3], 0)\n"
"    {[], [1, 2, 3]}\n"
"\n"
"    iex> Enum.split([1, 2, 3], -1)\n"
"    {[1, 2], [3]}\n"
"\n"
"    iex> Enum.split([1, 2, 3], -5)\n"
"    {[], [1, 2, 3]}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.all?(enumerable, fun \\ fn x -> x end)
#: lib/enum.ex:207 
msgid ""
"Invokes the given `fun` for each item in the enumerable.\n"
"It stops the iteration at the first invocation that returns `false` or `nil`.\n"
"It returns `false` if at least one invocation returns `false` or `nil`.\n"
"Otherwise returns `true`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.all?([2, 4, 6], fn(x) -> rem(x, 2) == 0 end)\n"
"    true\n"
"\n"
"    iex> Enum.all?([2, 3, 4], fn(x) -> rem(x, 2) == 0 end)\n"
"    false\n"
"\n"
"If no function is given, it defaults to checking if\n"
"all items in the enumerable are truthy values.\n"
"\n"
"    iex> Enum.all?([1, 2, 3])\n"
"    true\n"
"\n"
"    iex> Enum.all?([1, nil, 3])\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.member?(enumerable, element)
#: lib/enum.ex:1226 
msgid ""
"Checks if `element` exists within the enumerable.\n"
"\n"
"Membership is tested with the match (`===`) operator.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.member?(1..10, 5)\n"
"    true\n"
"    iex> Enum.member?(1..10, 5.0)\n"
"    false\n"
"\n"
"    iex> Enum.member?([1.0, 2.0, 3.0], 2)\n"
"    false\n"
"    iex> Enum.member?([1.0, 2.0, 3.0], 2.000)\n"
"    true\n"
"\n"
"    iex> Enum.member?([:a, :b, :c], :d)\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.intersperse(enumerable, element)
#: lib/enum.ex:917 
msgid ""
"Intersperses `element` between each element of the enumeration.\n"
"\n"
"Complexity: O(n).\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.intersperse([1, 2, 3], 0)\n"
"    [1, 0, 2, 0, 3]\n"
"\n"
"    iex> Enum.intersperse([1], 0)\n"
"    [1]\n"
"\n"
"    iex> Enum.intersperse([], 0)\n"
"    []\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.fetch(enumerable, index)
#: lib/enum.ex:646 
msgid ""
"Finds the element at the given `index` (zero-based).\n"
"\n"
"Returns `{:ok, element}` if found, otherwise `:error`.\n"
"\n"
"A negative `index` can be passed, which means the `enumerable` is\n"
"enumerated once and the `index` is counted from the end (e.g.\n"
"`-1` fetches the last element).\n"
"\n"
"Note this operation takes linear time. In order to access\n"
"the element at index `index`, it will need to traverse `index`\n"
"previous elements.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.fetch([2, 4, 6], 0)\n"
"    {:ok, 2}\n"
"\n"
"    iex> Enum.fetch([2, 4, 6], 2)\n"
"    {:ok, 6}\n"
"\n"
"    iex> Enum.fetch([2, 4, 6], 4)\n"
"    :error\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.any?(enumerable, fun \\ fn x -> x end)
#: lib/enum.ex:246 
msgid ""
"Invokes the given `fun` for each item in the enumerable.\n"
"It stops the iteration at the first invocation that returns a truthy value.\n"
"Returns `true` if at least one invocation returns a truthy value.\n"
"Otherwise returns `false`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.any?([2, 4, 6], fn(x) -> rem(x, 2) == 1 end)\n"
"    false\n"
"\n"
"    iex> Enum.any?([2, 3, 4], fn(x) -> rem(x, 2) == 1 end)\n"
"    true\n"
"\n"
"If no function is given, it defaults to checking if at least one item\n"
"in the enumerable is a truthy value.\n"
"\n"
"    iex> Enum.any?([false, false, false])\n"
"    false\n"
"\n"
"    iex> Enum.any?([false, true, false])\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.find_index(enumerable, fun)
#: lib/enum.ex:825 
msgid ""
"Similar to `find/3`, but returns the index (zero-based)\n"
"of the element instead of the element itself.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.find_index([2, 4, 6], fn(x) -> rem(x, 2) == 1 end)\n"
"    nil\n"
"\n"
"    iex> Enum.find_index([2, 3, 4], fn(x) -> rem(x, 2) == 1 end)\n"
"    1\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.take_while(enumerable, fun)
#: lib/enum.ex:2205 
msgid ""
"Takes the items from the beginning of the enumerable while `fun` returns\n"
"a truthy value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.take_while([1, 2, 3], fn(x) -> x < 3 end)\n"
"    [1, 2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.into(enumerable, collectable, transform)
#: lib/enum.ex:997 
msgid ""
"Inserts the given `enumerable` into a `collectable` according to the\n"
"transformation function.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.into([2, 3], [3], fn x -> x * 3 end)\n"
"    [3, 6, 9]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.max_by(enumerable, fun)
#: lib/enum.ex:1183 
msgid ""
"Returns the biggest of the elements in the enumerable as calculated\n"
"by the given function.\n"
"\n"
"If more than one elements compare equal, the first one that was found\n"
"is returned.\n"
"\n"
"Raises `Enum.EmptyError` if `enumerable` is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.max_by([\"a\", \"aa\", \"aaa\"], fn(x) -> String.length(x) end)\n"
"    \"aaa\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.at(enumerable, index, default \\ nil)
#: lib/enum.ex:285 
msgid ""
"Finds the element at the given `index` (zero-based).\n"
"\n"
"Returns `default` if `index` is out of bounds.\n"
"\n"
"Note this operation takes linear time. In order to access\n"
"the element at index `index`, it will need to traverse `index`\n"
"previous elements.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.at([2, 4, 6], 0)\n"
"    2\n"
"\n"
"    iex> Enum.at([2, 4, 6], 2)\n"
"    6\n"
"\n"
"    iex> Enum.at([2, 4, 6], 4)\n"
"    nil\n"
"\n"
"    iex> Enum.at([2, 4, 6], 4, :none)\n"
"    :none\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.join(enumerable, joiner \\ "")
#: lib/enum.ex:1036 
msgid ""
"Joins the given enumerable into a binary using `joiner` as a\n"
"separator.\n"
"\n"
"If `joiner` is not passed at all, it defaults to the empty binary.\n"
"\n"
"All items in the enumerable must be convertible to a binary,\n"
"otherwise an error is raised.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.join([1, 2, 3])\n"
"    \"123\"\n"
"\n"
"    iex> Enum.join([1, 2, 3], \" = \")\n"
"    \"1 = 2 = 3\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.chunk(enumerable, count)
#: lib/enum.ex:317 
msgid ""
"Shortcut to `chunk(enumerable, count, count)`.\n"
msgstr ""
#. TRANSLATORS: def Enum.take_every(enumerable, nth)
#: lib/enum.ex:2103 
msgid ""
"Returns a list of every `nth` item in the enumerable,\n"
"starting with the first element.\n"
"\n"
"The first item is always included, unless `nth` is 0.\n"
"\n"
"The second argument specifying every `nth` item must be a non-negative\n"
"integer, otherwise `FunctionClauseError` will be raised.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.take_every(1..10, 2)\n"
"    [1, 3, 5, 7, 9]\n"
"\n"
"    iex> Enum.take_every(1..10, 0)\n"
"    []\n"
"\n"
"    iex> Enum.take_every([1, 2, 3], 1)\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.flat_map_reduce(enumerable, acc, fun)
#: lib/enum.ex:877 
msgid ""
"Maps and reduces an enumerable, flattening the given results.\n"
"\n"
"It expects an accumulator and a function that receives each stream\n"
"item, and must return a tuple containing a new stream (often a list)\n"
"with the new accumulator or a tuple with `:halt` as first element and\n"
"the accumulator as second.\n"
"\n"
"## Examples\n"
"\n"
"    iex> enum = 1..100\n"
"    iex> n = 3\n"
"    iex> Enum.flat_map_reduce(enum, 0, fn i, acc ->\n"
"    ...>   if acc < n, do: {[i], acc + 1}, else: {:halt, acc}\n"
"    ...> end)\n"
"    {[1, 2, 3], 3}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.min_by(enumerable, fun)
#: lib/enum.ex:1284 
msgid ""
"Returns the smallest of the elements in the enumerable as calculated\n"
"by the given function.\n"
"\n"
"If more than one elements compare equal, the first one that was found\n"
"is returned.\n"
"\n"
"Raises `Enum.EmptyError` if `enumerable` is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.min_by([\"a\", \"aa\", \"aaa\"], fn(x) -> String.length(x) end)\n"
"    \"a\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.scan(enumerable, acc, fun)
#: lib/enum.ex:1699 
msgid ""
"Applies the given function to each element in the enumerable,\n"
"storing the result in a list and passing it as the accumulator\n"
"for the next computation. Uses the given `acc` as the starting value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.scan(1..5, 0, &(&1 + &2))\n"
"    [1, 3, 6, 10, 15]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.scan(enumerable, fun)
#: lib/enum.ex:1682 
msgid ""
"Applies the given function to each element in the enumerable,\n"
"storing the result in a list and passing it as the accumulator\n"
"for the next computation.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.scan(1..5, &(&1 + &2))\n"
"    [1, 3, 6, 10, 15]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.count(enumerable, fun)
#: lib/enum.ex:467 
msgid ""
"Returns the count of items in the enumerable for which `fun` returns\n"
"a truthy value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.count([1, 2, 3, 4, 5], fn(x) -> rem(x, 2) == 0 end)\n"
"    2\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.shuffle(enumerable)
#: lib/enum.ex:1716 
msgid ""
"Returns a list with the elements of `enumerable` shuffled.\n"
"\n"
"This function uses Erlang's `:rand` module to calculate\n"
"the random value. Check its documentation for setting a\n"
"different random algorithm or a different seed.\n"
"\n"
"## Examples\n"
"\n"
"    # Although not necessary, let's seed the random algorithm\n"
"    iex> :rand.seed(:exsplus, {1, 2, 3})\n"
"    iex> Enum.shuffle([1, 2, 3])\n"
"    [2, 1, 3]\n"
"    iex> Enum.shuffle([1, 2, 3])\n"
"    [2, 3, 1]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.take(enumerable, count)
#: lib/enum.ex:2029 
msgid ""
"Takes the first `count` items from the enumerable.\n"
"\n"
"`count` must be an integer. If a negative `count` is given, the last\n"
"`count` values will be taken.\n"
"For such, the enumerable is fully enumerated keeping up\n"
"to `2 * count` elements in memory. Once the end of the enumerable is\n"
"reached, the last `count` elements are returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.take([1, 2, 3], 2)\n"
"    [1, 2]\n"
"\n"
"    iex> Enum.take([1, 2, 3], 10)\n"
"    [1, 2, 3]\n"
"\n"
"    iex> Enum.take([1, 2, 3], 0)\n"
"    []\n"
"\n"
"    iex> Enum.take([1, 2, 3], -1)\n"
"    [3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.reduce(enumerable, acc, fun)
#: lib/enum.ex:1458 
msgid ""
"Invokes `fun` for each element in the `enumerable`, passing that\n"
"element and the accumulator `acc` as arguments. `fun`'s return value\n"
"is stored in `acc`.\n"
"\n"
"Returns the accumulator.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reduce([1, 2, 3], 0, fn(x, acc) -> x + acc end)\n"
"    6\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.sort_by(enumerable, mapper, sorter \\ &<=/2)
#: lib/enum.ex:1906 
msgid ""
"Sorts the mapped results of the enumerable according to the `sorter`\n"
"function.\n"
"\n"
"This function maps each element of the enumerable using the `mapper`\n"
"function.  The enumerable is then sorted by the mapped elements\n"
"using the `sorter` function, which defaults to `<=/2`\n"
"\n"
"`sort_by/3` differs from `sort/2` in that it only calculates the\n"
"comparison value for each element in the enumerable once instead of\n"
"once for each element in each comparison.\n"
"If the same function is being called on both element, it's also more\n"
"compact to use `sort_by/3`.\n"
"\n"
"This technique is also known as a\n"
"_[Schwartzian Transform](https://en.wikipedia.org/wiki/Schwartzian_transform)_,\n"
"or the _Lisp decorate-sort-undecorate idiom_ as the `mapper`\n"
"is decorating the original `enumerable`; then `sorter` is sorting the\n"
"decorations; and finally the enumerable is being undecorated so only\n"
"the original elements remain, but now in sorted order.\n"
"\n"
"## Examples\n"
"\n"
"Using the default `sorter` of `<=/2`:\n"
"\n"
"    iex> Enum.sort_by [\"some\", \"kind\", \"of\", \"monster\"], &byte_size/1\n"
"    [\"of\", \"some\", \"kind\", \"monster\"]\n"
"\n"
"Using a custom `sorter` to override the order:\n"
"\n"
"    iex> Enum.sort_by [\"some\", \"kind\", \"of\", \"monster\"], &byte_size/1, &>=/2\n"
"    [\"monster\", \"some\", \"kind\", \"of\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: @type continuation
#: lib/enum.ex:84 
msgid ""
"A partially applied reduce function.\n"
"\n"
"The continuation is the closure returned as a result when\n"
"the enumeration is suspended. When invoked, it expects\n"
"a new accumulator and it returns the result.\n"
"\n"
"A continuation is easily implemented as long as the reduce\n"
"function is defined in a tail recursive fashion. If the function\n"
"is tail recursive, all the state is passed as arguments, so\n"
"the continuation would simply be the reducing function partially\n"
"applied.\n"
msgstr ""
#. TRANSLATORS: def Enum.reverse(enumerable, tail)
#: lib/enum.ex:1597 
msgid ""
"Reverses the elements in `enumerable`, appends the tail, and returns\n"
"it as a list.\n"
"\n"
"This is an optimization for\n"
"`Enum.concat(Enum.reverse(enumerable), tail)`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reverse([1, 2, 3], [4, 5, 6])\n"
"    [3, 2, 1, 4, 5, 6]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.reverse(enumerable)
#: lib/enum.ex:1579 
msgid ""
"Returns a list of elements in `enumerable` in reverse order.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reverse([1, 2, 3])\n"
"    [3, 2, 1]\n"
"\n"
msgstr ""
#. TRANSLATORS: @type result
#: lib/enum.ex:65 
msgid ""
"The result of the reduce operation.\n"
"\n"
"It may be *done* when the enumeration is finished by reaching\n"
"its end, or *halted*/*suspended* when the enumeration was halted\n"
"or suspended by the `t:reducer/0` function.\n"
"\n"
"In case a `t:reducer/0` function returns the `:suspend` accumulator, the\n"
"`:suspended` tuple must be explicitly handled by the caller and\n"
"never leak. In practice, this means regular enumeration functions\n"
"just need to be concerned about `:done` and `:halted` results.\n"
"\n"
"Furthermore, a `:suspend` call must always be followed by another call,\n"
"eventually halting or continuing until the end.\n"
msgstr ""
#. TRANSLATORS: def Enum.unzip(enumerable)
#: lib/enum.ex:2298 
msgid ""
"Opposite of `Enum.zip/2`; extracts a two-element tuples from the\n"
"enumerable and groups them together.\n"
"\n"
"It takes an enumerable with items being two-element tuples and returns\n"
"a tuple with two lists, each of which is formed by the first and\n"
"second element of each tuple, respectively.\n"
"\n"
"This function fails unless `enumerable` is or can be converted into a\n"
"list of tuples with *exactly* two elements in each tuple.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.unzip([{:a, 1}, {:b, 2}, {:c, 3}])\n"
"    {[:a, :b, :c], [1, 2, 3]}\n"
"\n"
"    iex> Enum.unzip(%{a: 1, b: 2})\n"
"    {[:a, :b], [1, 2]}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.concat(enumerables)
#: lib/enum.ex:394 
msgid ""
"Given an enumerable of enumerables, concatenates the enumerables into\n"
"a single list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.concat([1..3, 4..6, 7..9])\n"
"    [1, 2, 3, 4, 5, 6, 7, 8, 9]\n"
"\n"
"    iex> Enum.concat([[1, [2], 3], [4], [5, 6]])\n"
"    [1, [2], 3, 4, 5, 6]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enumerable.count(enumerable)
#: lib/enum.ex:133 
msgid ""
"Retrieves the enumerable's size.\n"
"\n"
"It should return `{:ok, size}`.\n"
"\n"
"If `{:error, __MODULE__}` is returned a default algorithm using\n"
"`reduce` and the match (`===`) operator is used. This algorithm runs\n"
"in linear time.\n"
"\n"
"_Please force use of the default algorithm unless you can implement an\n"
"algorithm that is significantly faster._\n"
msgstr ""
#. TRANSLATORS: def Enum.uniq(enumerable)
#: lib/enum.ex:2251 
msgid ""
"Enumerates the `enumerable`, removing all duplicated elements.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.uniq([1, 2, 3, 3, 2, 1])\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.slice(enumerable, start, count)
#: lib/enum.ex:1741 
msgid ""
"Returns a subset list of the given enumerable. Drops elements\n"
"until element position `start`, then takes `count` elements.\n"
"\n"
"If the count is greater than `enumerable` length, it returns as\n"
"many as possible. If zero, then it returns `[]`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.slice(1..100, 5, 10)\n"
"    [6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n"
"\n"
"    iex> Enum.slice(1..10, 5, 100)\n"
"    [6, 7, 8, 9, 10]\n"
"\n"
"    iex> Enum.slice(1..10, 5, 0)\n"
"    []\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.count(enumerable)
#: lib/enum.ex:442 
msgid ""
"Returns the size of the enumerable.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.count([1, 2, 3])\n"
"    3\n"
"\n"
msgstr ""
#. TRANSLATORS: @type acc
#: lib/enum.ex:37 
msgid ""
"The accumulator value for each step.\n"
"\n"
"It must be a tagged tuple with one of the following \"tags\":\n"
"\n"
"  * `:cont`    - the enumeration should continue\n"
"  * `:halt`    - the enumeration should halt immediately\n"
"  * `:suspend` - the enumeration should be suspended immediately\n"
"\n"
"Depending on the accumulator value, the result returned by\n"
"`Enumerable.reduce/3` will change. Please check the `t:result/0`\n"
"type documentation for more information.\n"
"\n"
"In case a `t:reducer/0` function returns a `:suspend` accumulator,\n"
"it must be explicitly handled by the caller and never leak.\n"
msgstr ""
#. TRANSLATORS: def Enum.empty?(enumerable)
#: lib/enum.ex:616 
msgid ""
"Determines if the enumerable is empty.\n"
"\n"
"Returns `true` if `enumerable` is empty, otherwise `false`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.empty?([])\n"
"    true\n"
"\n"
"    iex> Enum.empty?([1, 2, 3])\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.reduce_while(enumerable, acc, fun)
#: lib/enum.ex:1540 
msgid ""
"Reduces the enumerable until `halt` is emitted.\n"
"\n"
"The return value for `fun` is expected to be `{:cont, acc}`, return\n"
"`{:halt, acc}` to end the reduction early.\n"
"\n"
"Returns the accumulator.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reduce_while(1..100, 0, fn i, acc ->\n"
"    ...>   if i < 3, do: {:cont, acc + i}, else: {:halt, acc}\n"
"    ...> end)\n"
"    3\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.reverse_slice(enumerable, start, count)
#: lib/enum.ex:1622 
msgid ""
"Reverses the enumerable in the range from initial position `start`\n"
"through `count` elements.\n"
"\n"
"If `count` is greater than the size of the rest of the enumerable,\n"
"then this function will reverse the rest of the enumerable.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reverse_slice([1, 2, 3, 4, 5, 6], 2, 4)\n"
"    [1, 2, 6, 5, 4, 3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.sort(enumerable)
#: lib/enum.ex:1851 
msgid ""
"Sorts the enumerable according to Erlang's term ordering.\n"
"\n"
"Uses the merge sort algorithm.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.sort([3, 2, 1])\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.sum(enumerable)
#: lib/enum.ex:1395 
msgid ""
"Returns the sum of all elements.\n"
"\n"
"Raises `ArithmeticError` if `enumerable` contains a non-numeric value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.sum([1, 2, 3])\n"
"    6\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.fetch!(enumerable, index)
#: lib/enum.ex:697 
msgid ""
"Finds the element at the given `index` (zero-based).\n"
"\n"
"Raises `OutOfBoundsError` if the given `index` is outside the range of\n"
"the enumerable.\n"
"\n"
"Note this operation takes linear time. In order to access the element\n"
"at index `index`, it will need to traverse `index` previous elements.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.fetch!([2, 4, 6], 0)\n"
"    2\n"
"\n"
"    iex> Enum.fetch!([2, 4, 6], 2)\n"
"    6\n"
"\n"
"    iex> Enum.fetch!([2, 4, 6], 4)\n"
"    ** (Enum.OutOfBoundsError) out of bounds error\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.filter_map(enumerable, filter, mapper)
#: lib/enum.ex:745 
msgid ""
"Filters the enumerable and maps its elements in one pass.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.filter_map([1, 2, 3], fn(x) -> rem(x, 2) == 0 end, &(&1 * 2))\n"
"    [4]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.group_by(enumerable, dict \\ %{}, fun)
#: lib/enum.ex:1436 
msgid ""
"Splits the enumerable into groups based on `fun`.\n"
"\n"
"The result is a dict (by default a map) where each key is\n"
"a group and each value is a list of elements from enumerable\n"
"for which `fun` returned that group. Ordering is not necessarily\n"
"preserved.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.group_by(~w{ant buffalo cat dingo}, &String.length/1)\n"
"    %{3 => [\"cat\", \"ant\"], 7 => [\"buffalo\"], 5 => [\"dingo\"]}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.random(enumerable)
#: lib/enum.ex:1649 
msgid ""
"Returns a random element of an enumerable.\n"
"\n"
"Raises `Enum.EmptyError` if `enumerable` is empty.\n"
"\n"
"This function uses Erlang's `:rand` module to calculate\n"
"the random value. Check its documentation for setting a\n"
"different random algorithm or a different seed.\n"
"\n"
"The implementation is based on the\n"
"[reservoir sampling](https://en.wikipedia.org/wiki/Reservoir_sampling#Relation_to_Fisher-Yates_shuffle)\n"
"algorithm.\n"
"It assumes that the sample being returned can fit into memory;\n"
"the input `enumerable` doesn't have to, as it is traversed just once.\n"
"\n"
"## Examples\n"
"\n"
"    # Although not necessary, let's seed the random algorithm\n"
"    iex> :rand.seed(:exsplus, {1, 2, 3})\n"
"    iex> Enum.random([1, 2, 3])\n"
"    2\n"
"    iex> Enum.random([1, 2, 3])\n"
"    1\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.max(enumerable)
#: lib/enum.ex:1163 
msgid ""
"Returns the biggest of the elements in the enumerable according\n"
"to Erlang's term ordering.\n"
"\n"
"If more than one elements compare equal, the first one that was found\n"
"is returned.\n"
"\n"
"Raises `Enum.EmptyError` if `enumerable` is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.max([1, 2, 3])\n"
"    3\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.chunk(enumerable, count, step, pad \\ nil)
#: lib/enum.ex:323 
msgid ""
"Returns list of lists containing `count` items each, where\n"
"each new chunk starts `step` elements into the enumerable.\n"
"\n"
"`step` is optional and, if not passed, defaults to `count`, i.e.\n"
"chunks do not overlap.\n"
"\n"
"If the final chunk does not have `count` elements to fill the chunk,\n"
"elements are taken as necessary from `pad` if it was passed.\n"
"\n"
"If `pad` is passed and does not have enough elements to fill the\n"
"chunk, then the chunk is returned anyway with less than `count`\n"
"elements.\n"
"If `pad` is not passed at all or is `nil`, then the partial chunk is\n"
"discarded from the result.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4, 5, 6], 2)\n"
"    [[1, 2], [3, 4], [5, 6]]\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4, 5, 6], 3, 2)\n"
"    [[1, 2, 3], [3, 4, 5]]\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4, 5, 6], 3, 2, [7])\n"
"    [[1, 2, 3], [3, 4, 5], [5, 6, 7]]\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4, 5, 6], 3, 3, [])\n"
"    [[1, 2, 3], [4, 5, 6]]\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.Enumerable Summary
#: lib/enum.ex:2 
msgid ""
"Enumerable protocol used by `Enum` and `Stream` modules.\n"
"\n"
"When you invoke a function in the `Enum` module, the first argument\n"
"is usually a collection that must implement this protocol.\n"
"For example, the expression:\n"
"\n"
"    Enum.map([1, 2, 3], &(&1 * 2))\n"
"\n"
"invokes `Enumerable.reduce/3` to perform the reducing\n"
"operation that builds a mapped list by calling the mapping function\n"
"`&(&1 * 2)` on every element in the collection and consuming the\n"
"element with an accumulated list.\n"
"\n"
"Internally, `Enum.map/2` is implemented as follows:\n"
"\n"
"    def map(enum, fun) do\n"
"      reducer = fn x, acc -> {:cont, [fun.(x)|acc]} end\n"
"      Enumerable.reduce(enum, {:cont, []}, reducer) |> elem(1) |> :lists.reverse()\n"
"    end\n"
"\n"
"Notice the user-supplied function is wrapped into a `t:reducer/0` function.\n"
"The `t:reducer/0` function must return a tagged tuple after each step,\n"
"as described in the `t:acc/0` type.\n"
"\n"
"The reason the accumulator requires a tagged tuple is to allow the\n"
"`t:reducer/0` function to communicate the end of enumeration to the underlying\n"
"enumerable, allowing any open resources to be properly closed.\n"
"It also allows suspension of the enumeration, which is useful when\n"
"interleaving between many enumerables is required (as in zip).\n"
"\n"
"Finally, `Enumerable.reduce/3` will return another tagged tuple,\n"
"as represented by the `t:result/0` type.\n"
msgstr ""
#. TRANSLATORS: Elixir.Enum Summary
#: lib/enum.ex:152 
msgid ""
"Provides a set of algorithms that enumerate over enumerables according\n"
"to the `Enumerable` protocol.\n"
"\n"
"    iex> Enum.map([1, 2, 3], fn(x) -> x * 2 end)\n"
"    [2, 4, 6]\n"
"\n"
"Some particular types, like dictionaries, yield a specific format on\n"
"enumeration. For dicts, the argument is always a `{key, value}` tuple:\n"
"\n"
"    iex> dict = %{a: 1, b: 2}\n"
"    iex> Enum.map(dict, fn {k, v} -> {k, v * 2} end)\n"
"    [a: 2, b: 4]\n"
"\n"
"Note that the functions in the `Enum` module are eager: they always\n"
"start the enumeration of the given enumerable. The `Stream` module\n"
"allows lazy enumeration of enumerables and provides infinite streams.\n"
"\n"
"Since the majority of the functions in `Enum` enumerate the whole\n"
"enumerable and return a list as result, infinite streams need to\n"
"be carefully used with such functions, as they can potentially run\n"
"forever. For example:\n"
"\n"
"    Enum.each Stream.cycle([1, 2, 3]), &IO.puts(&1)\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.map_join(enumerable, joiner \\ "", mapper)
#: lib/enum.ex:1095 
msgid ""
"Maps and joins the given enumerable in one pass.\n"
"\n"
"`joiner` can be either a binary or a list and the result will be of\n"
"the same type as `joiner`.\n"
"If `joiner` is not passed at all, it defaults to an empty binary.\n"
"\n"
"All items in the enumerable must be convertible to a binary,\n"
"otherwise an error is raised.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.map_join([1, 2, 3], &(&1 * 2))\n"
"    \"246\"\n"
"\n"
"    iex> Enum.map_join([1, 2, 3], \" = \", &(&1 * 2))\n"
"    \"2 = 4 = 6\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enumerable.reduce(enumerable, acc, fun)
#: lib/enum.ex:99 
msgid ""
"Reduces the enumerable into an element.\n"
"\n"
"Most of the operations in `Enum` are implemented in terms of reduce.\n"
"This function should apply the given `t:reducer/0` function to each\n"
"item in the enumerable and proceed as expected by the returned\n"
"accumulator.\n"
"\n"
"As an example, here is the implementation of `reduce` for lists:\n"
"\n"
"    def reduce(_,     {:halt, acc}, _fun),   do: {:halted, acc}\n"
"    def reduce(list,  {:suspend, acc}, fun), do: {:suspended, acc, &reduce(list, &1, fun)}\n"
"    def reduce([],    {:cont, acc}, _fun),   do: {:done, acc}\n"
"    def reduce([h|t], {:cont, acc}, fun),    do: reduce(t, fun.(h, acc), fun)\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enumerable.member?(enumerable, element)
#: lib/enum.ex:118 
msgid ""
"Checks if an element exists within the enumerable.\n"
"\n"
"It should return `{:ok, boolean}`.\n"
"\n"
"If `{:error, __MODULE__}` is returned a default algorithm using\n"
"`reduce` and the match (`===`) operator is used. This algorithm runs\n"
"in linear time.\n"
"\n"
"_Please force use of the default algorithm unless you can implement an\n"
"algorithm that is significantly faster._\n"
msgstr ""
#. TRANSLATORS: def Enum.into(enumerable, collectable)
#: lib/enum.ex:947 
msgid ""
"Inserts the given `enumerable` into a `collectable`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.into([1, 2], [0])\n"
"    [0, 1, 2]\n"
"\n"
"    iex> Enum.into([a: 1, b: 2], %{})\n"
"    %{a: 1, b: 2}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.sort(enumerable, fun)
#: lib/enum.ex:1871 
msgid ""
"Sorts the enumerable by the given function.\n"
"\n"
"This function uses the merge sort algorithm. The given function\n"
"must return `false` if the first argument is smaller than second one.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.sort([1, 2, 3], &(&1 > &2))\n"
"    [3, 2, 1]\n"
"\n"
"The sorting algorithm will be stable as long as the given function\n"
"returns `true` for values considered equal:\n"
"\n"
"    iex> Enum.sort [\"some\", \"kind\", \"of\", \"monster\"], &(byte_size(&1) <= byte_size(&2))\n"
"    [\"of\", \"some\", \"kind\", \"monster\"]\n"
"\n"
"If the function does not return `true` for equal values, the sorting\n"
"is not stable and the order of equal terms may be shuffled.\n"
"For example:\n"
"\n"
"    iex> Enum.sort [\"some\", \"kind\", \"of\", \"monster\"], &(byte_size(&1) < byte_size(&2))\n"
"    [\"of\", \"kind\", \"some\", \"monster\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.each(enumerable, fun)
#: lib/enum.ex:589 
msgid ""
"Invokes the given `fun` for each item in the enumerable.\n"
"\n"
"Returns `:ok`.\n"
"\n"
"## Examples\n"
"\n"
"    Enum.each([\"some\", \"example\"], fn(x) -> IO.puts x end)\n"
"    \"some\"\n"
"    \"example\"\n"
"    #=> :ok\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.find(enumerable, default \\ nil, fun)
#: lib/enum.ex:766 
msgid ""
"Returns the first item for which `fun` returns a truthy value.\n"
"If no such item is found, returns `default`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.find([2, 4, 6], fn(x) -> rem(x, 2) == 1 end)\n"
"    nil\n"
"\n"
"    iex> Enum.find([2, 4, 6], 0, fn(x) -> rem(x, 2) == 1 end)\n"
"    0\n"
"\n"
"    iex> Enum.find([2, 3, 4], fn(x) -> rem(x, 2) == 1 end)\n"
"    3\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.partition(enumerable, fun)
#: lib/enum.ex:1411 
msgid ""
"Partitions `enumerable` into two enumerables, where the first one\n"
"contains elements for which `fun` returns a truthy value, and the\n"
"second one – for which `fun` returns `false` or `nil`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.partition([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    {[2], [1, 3]}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.split_while(enumerable, fun)
#: lib/enum.ex:2002 
msgid ""
"Splits enumerable in two at the position of the element for which\n"
"`fun` returns `false` for the first time.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.split_while([1, 2, 3, 4], fn(x) -> x < 3 end)\n"
"    {[1, 2], [3, 4]}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.map(enumerable, fun)
#: lib/enum.ex:1069 
msgid ""
"Returns a list where each item is the result of invoking\n"
"`fun` on each corresponding item of `enumerable`.\n"
"\n"
"For dicts, the function expects a key-value tuple.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.map([1, 2, 3], fn(x) -> x * 2 end)\n"
"    [2, 4, 6]\n"
"\n"
"    iex> Enum.map([a: 1, b: 2], fn({k, v}) -> {k, -v} end)\n"
"    [a: -1, b: -2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.zip(enumerable1, enumerable2)
#: lib/enum.ex:2328 
msgid ""
"Zips corresponding elements from two enumerables into one list\n"
"of tuples.\n"
"\n"
"The zipping finishes as soon as any enumerable completes.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.zip([1, 2, 3], [:a, :b, :c])\n"
"    [{1, :a}, {2, :b}, {3, :c}]\n"
"\n"
"    iex> Enum.zip([1, 2, 3, 4, 5], [:a, :b, :c])\n"
"    [{1, :a}, {2, :b}, {3, :c}]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.drop(enumerable, n)
#: lib/enum.ex:527 
msgid ""
"Drops the first `n` items from then enumerable.\n"
"\n"
"If a negative value `n` is given, the last `n` values will be dropped.\n"
"\n"
"The `enumerable` is enumerated once to retrieve the proper index and\n"
"the remaining calculation is performed from the end.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.drop([1, 2, 3], 2)\n"
"    [3]\n"
"\n"
"    iex> Enum.drop([1, 2, 3], 10)\n"
"    []\n"
"\n"
"    iex> Enum.drop([1, 2, 3], 0)\n"
"    [1, 2, 3]\n"
"\n"
"    iex> Enum.drop([1, 2, 3], -1)\n"
"    [1, 2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.chunk_by(enumerable, fun)
#: lib/enum.ex:370 
msgid ""
"Splits enumerable on every element for which `fun` returns a new\n"
"value.\n"
"\n"
"Returns a list of lists.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.chunk_by([1, 2, 2, 3, 4, 4, 6, 7, 7], &(rem(&1, 2) == 1))\n"
"    [[1], [2, 2], [3], [4, 4, 6], [7, 7]]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.min_max(enumerable)
#: lib/enum.ex:1327 
msgid ""
"Returns a tuple with the smallest and the biggest elements in the\n"
"enumerable according to Erlang's term ordering.\n"
"\n"
"If more than one elements compare equal, the first one that was found\n"
"is picked.\n"
"\n"
"Raises `Enum.EmptyError` if `enumerable` is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.min_max([2, 3, 1])\n"
"    {1, 3}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.find_value(enumerable, default \\ nil, fun)
#: lib/enum.ex:795 
msgid ""
"Similar to `find/3`, but returns the value of the function\n"
"invocation instead of the element itself.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.find_value([2, 4, 6], fn(x) -> rem(x, 2) == 1 end)\n"
"    nil\n"
"\n"
"    iex> Enum.find_value([2, 3, 4], fn(x) -> rem(x, 2) == 1 end)\n"
"    true\n"
"\n"
"    iex> Enum.find_value([1, 2, 3], \"no bools!\", &is_boolean/1)\n"
"    \"no bools!\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.drop_while(enumerable, fun)
#: lib/enum.ex:569 
msgid ""
"Drops items at the beginning of the enumerable while `fun` returns a\n"
"truthy value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.drop_while([1, 2, 3, 4, 5], fn(x) -> x < 3 end)\n"
"    [3, 4, 5]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.dedup(enumerable)
#: lib/enum.ex:485 
msgid ""
"Enumerates the `enumerable`, returning a list where all consecutive\n"
"duplicated elements are collapsed to a single element.\n"
"\n"
"Elements are compared using `===`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.dedup([1, 2, 3, 3, 2, 1])\n"
"    [1, 2, 3, 2, 1]\n"
"\n"
"    iex> Enum.dedup([1, 1, 2, 2.0, :three, :\"three\"])\n"
"    [1, 2, 2.0, :three]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.concat(left, right)
#: lib/enum.ex:412 
msgid ""
"Concatenates the enumerable on the right with the enumerable on the\n"
"left.\n"
"\n"
"This function produces the same result as the `Kernel.++/2` operator\n"
"for lists.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.concat(1..3, 4..6)\n"
"    [1, 2, 3, 4, 5, 6]\n"
"\n"
"    iex> Enum.concat([1, 2, 3], [4, 5, 6])\n"
"    [1, 2, 3, 4, 5, 6]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.filter(enumerable, fun)
#: lib/enum.ex:726 
msgid ""
"Filters the enumerable, i.e. returns only those elements\n"
"for which `fun` returns a truthy value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.filter([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    [2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.take_random(enumerable, count)
#: lib/enum.ex:2136 
msgid ""
"Takes random items from the enumerable.\n"
"\n"
"Notice this function will traverse the whole enumerable to\n"
"get the random sublist of `enumerable`. If you want the random\n"
"number between two integers, the best option is to use the\n"
"[`:random`](http://www.erlang.org/doc/man/random.html) module.\n"
"\n"
"See `random/1` for notes on implementation and random seed.\n"
"\n"
"## Examples\n"
"\n"
"    # Although not necessary, let's seed the random algorithm\n"
"    iex> :rand.seed(:exsplus, {1, 2, 3})\n"
"    iex> Enum.take_random(1..10, 2)\n"
"    [5, 8]\n"
"    iex> Enum.take_random(?a..?z, 5)\n"
"    'fhjni'\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.reduce(enumerable, fun)
#: lib/enum.ex:1490 
msgid ""
"Invokes `fun` for each element in the `enumerable`, passing that\n"
"element and the accumulator as arguments. `fun`'s return value\n"
"is stored in the accumulator.\n"
"\n"
"The first element of the enumerable is used as the initial value of\n"
"the accumulator.\n"
"If you wish to use another value for the accumulator, use\n"
"`Enumerable.reduce/3`.\n"
"This function won't call the specified function for enumerables that\n"
"are 1-element long.\n"
"\n"
"Returns the accumulator.\n"
"\n"
"Note that since the first element of the enumerable is used as the\n"
"initial value of the accumulator, `fun` will only be executed `n - 1`\n"
"times where `n` is the length of the enumerable.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reduce([1, 2, 3, 4], fn(x, acc) -> x * acc end)\n"
"    24\n"
"\n"
msgstr ""
#. TRANSLATORS: @type reducer
#: lib/enum.ex:55 
msgid ""
"The reducer function.\n"
"\n"
"Should be called with the enumerable element and the\n"
"accumulator contents.\n"
"\n"
"Returns the accumulator for the next enumeration step.\n"
msgstr ""
#. TRANSLATORS: def Enum.flat_map(enumerable, fun)
#: lib/enum.ex:855 
msgid ""
"Returns a new enumerable appending the result of invoking `fun` on\n"
"each corresponding item of `enumerable`.\n"
"\n"
"The given function must return an enumerable.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.flat_map([:a, :b, :c], fn(x) -> [x, x] end)\n"
"    [:a, :a, :b, :b, :c, :c]\n"
"\n"
"    iex> Enum.flat_map([{1, 3}, {4, 6}], fn({x, y}) -> x..y end)\n"
"    [1, 2, 3, 4, 5, 6]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.min(enumerable)
#: lib/enum.ex:1264 
msgid ""
"Returns the smallest of the elements in the enumerable according\n"
"to Erlang's term ordering.\n"
"\n"
"If more than one elements compare equal, the first one that was found\n"
"is returned.\n"
"\n"
"Raises `Enum.EmptyError` if `enumerable` is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.min([1, 2, 3])\n"
"    1\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.with_index(enumerable, offset \\ 0)
#: lib/enum.ex:2355 
msgid ""
"Returns the enumerable with each element wrapped in a tuple\n"
"alongside its index.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.with_index([:a, :b, :c])\n"
"    [a: 0, b: 1, c: 2]\n"
"\n"
"    iex> Enum.with_index([:a, :b, :c], 3)\n"
"    [a: 3, b: 4, c: 5]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.min_max_by(enumerable, fun)
#: lib/enum.ex:1358 
msgid ""
"Returns a tuple with the smallest and the biggest elements in the\n"
"enumerable as calculated by the given function.\n"
"\n"
"If more than one elements compare equal, the first one that was found\n"
"is picked.\n"
"\n"
"Raises `Enum.EmptyError` if `enumerable` is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.min_max_by([\"aaa\", \"bb\", \"c\"], fn(x) -> String.length(x) end)\n"
"    {\"c\", \"aaa\"}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.dedup_by(enumerable, fun)
#: lib/enum.ex:505 
msgid ""
"Enumerates the `enumerable`, returning a list where all consecutive\n"
"duplicated elements are collapsed to a single element.\n"
"\n"
"The function `fun` maps every element to a term which is used to\n"
"determine if two elements are duplicates.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.dedup_by([{1, :a}, {2, :b}, {2, :c}, {1, :a}], fn {x, _} -> x end)\n"
"    [{1, :a}, {2, :b}, {1, :a}]\n"
"\n"
"    iex> Enum.dedup_by([5, 1, 2, 3, 2, 1], fn x -> x > 2 end)\n"
"    [5, 1, 3, 2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.reject(enumerable, fun)
#: lib/enum.ex:1560 
msgid ""
"Returns elements of `enumerable` for which the function `fun` returns\n"
"`false` or `nil`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reject([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    [1, 3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.uniq_by(enumerable, fun)
#: lib/enum.ex:2272 
msgid ""
"Enumerates the `enumerable`, by removing the elements for which\n"
"function `fun` returned duplicate items.\n"
"\n"
"The function `fun` maps every element to a term which is used to\n"
"determine if two elements are duplicates.\n"
"## Example\n"
"\n"
"    iex> Enum.uniq_by([{1, :x}, {2, :y}, {1, :z}], fn {x, _} -> x end)\n"
"    [{1, :x}, {2, :y}]\n"
"\n"
"    Enum.uniq_by([{a: {tea: 2}}, {b: {tea: 2}}, {c, {coffe: 1}}], fn {x, _} -> x end)\n"
"    [a: [tea: 2], b: [tea: 2]]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.to_list(enumerable)
#: lib/enum.ex:2233 
msgid ""
"Converts `enumerable` to a list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.to_list(1..3)\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.slice(enumerable, range)
#: lib/enum.ex:1795 
msgid ""
"Returns a subset list of the given enumerable. Drops elements\n"
"until element position `range.first`, then takes elements until\n"
"element position `range.last` (inclusive).\n"
"\n"
"Positions are calculated by adding the number of items in the\n"
"enumerable to negative positions (e.g. position -3 in an\n"
"enumerable with count 5 becomes position 2).\n"
"\n"
"The first position (after adding count to negative positions) must be\n"
"smaller or equal to the last position.\n"
"\n"
"If the start of the range is not a valid offset for the given\n"
"enumerable or if the range is in reverse order, returns `[]`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.slice(1..100, 5..10)\n"
"    [6, 7, 8, 9, 10, 11]\n"
"\n"
"    iex> Enum.slice(1..10, 5..20)\n"
"    [6, 7, 8, 9, 10]\n"
"\n"
"    iex> Enum.slice(1..10, 11..20)\n"
"    []\n"
"\n"
"    iex> Enum.slice(1..10, 6..5)\n"
"    []\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.map_reduce(enumerable, acc, fun)
#: lib/enum.ex:1130 
msgid ""
"Invokes the given function to each item in the enumerable to reduce\n"
"it to a single element, while keeping an accumulator.\n"
"\n"
"Returns a tuple where the first element is the mapped enumerable and\n"
"the second one is the final accumulator.\n"
"\n"
"The function, `fun`, receives two arguments: the first one is the\n"
"element, and the second one is the accumulator. `fun` must return a\n"
"a tuple with two elements in the form of `{result, accumulator}`.\n"
"\n"
"For dicts, the first tuple element must be a `{key, value}` tuple.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.map_reduce([1, 2, 3], 0, fn(x, acc) -> {x * 2, x + acc} end)\n"
"    {[2, 4, 6], 6}\n"
"\n"
msgstr ""
