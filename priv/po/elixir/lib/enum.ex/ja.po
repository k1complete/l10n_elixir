msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2016-01-02 21:07+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: def Enum.min_by(enumerable, fun)
#: lib/enum.ex:1288
msgid ""
"Returns the smallest of the elements in the enumerable as calculated\n"
"by the given function.\n"
"\n"
"If more than one elements compare equal, the first one that was found\n"
"is returned.\n"
"\n"
"Raises `Enum.EmptyError` if `enumerable` is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.min_by([\"a\", \"aa\", \"aaa\"], fn(x) -> String.length(x) "
"end)\n"
"    \"a\"\n"
"\n"
msgstr ""
"与えられた関数により計算した値が最小となる要素を返します。\n"
"\n"
"もし最小値が複数なら、最初に見付かった値を返します。\n"
"\n"
"もしenumerableが空なら、`EmptyError`を上げます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.min_by([\"a\", \"aa\", \"aaa\"], fn(x) -> String.length(x) "
"end)\n"
"    \"a\"\n"
"\n"

#. TRANSLATORS: def Enum.split(enumerable, count)
#: lib/enum.ex:1971
msgid ""
"Splits the `enumerable` into two enumerables, leaving `count`\n"
"elements in the first one. If `count` is a negative number,\n"
"it starts counting from the back to the beginning of the\n"
"enumerable.\n"
"\n"
"Be aware that a negative `count` implies the `enumerable`\n"
"will be enumerated twice: once to calculate the position, and\n"
"a second time to do the actual splitting.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.split([1, 2, 3], 2)\n"
"    {[1, 2], [3]}\n"
"\n"
"    iex> Enum.split([1, 2, 3], 10)\n"
"    {[1, 2, 3], []}\n"
"\n"
"    iex> Enum.split([1, 2, 3], 0)\n"
"    {[], [1, 2, 3]}\n"
"\n"
"    iex> Enum.split([1, 2, 3], -1)\n"
"    {[1, 2], [3]}\n"
"\n"
"    iex> Enum.split([1, 2, 3], -5)\n"
"    {[], [1, 2, 3]}\n"
"\n"
msgstr ""
"`enumerable`を、最初の`count`個の要素とそれ以外の、二つのenumerableに分\n"
"割します。もし`count`が負の数なら、enumerableの最後から最初に向って数\n"
"えます。\n"
"\n"
"負の`count`は、`enumerable`で2回数え上げられることを意味する\n"
"ということに、注意してください: 一度は位置を計算するために、\n"
"二回目は、実際の分割をするために。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.split([1, 2, 3], 2)\n"
"    {[1, 2], [3]}\n"
"\n"
"    iex> Enum.split([1, 2, 3], 10)\n"
"    {[1, 2, 3], []}\n"
"\n"
"    iex> Enum.split([1, 2, 3], 0)\n"
"    {[], [1, 2, 3]}\n"
"\n"
"    iex> Enum.split([1, 2, 3], -1)\n"
"    {[1,2 ], [3]}\n"
"\n"
"    iex> Enum.split([1, 2, 3], -5)\n"
"    {[], [1, 2, 3]}\n"
"\n"

#. TRANSLATORS: def Enum.all?(enumerable, fun \\ fn x -> x end)
#: lib/enum.ex:207
msgid ""
"Invokes the given `fun` for each item in the enumerable.\n"
"It stops the iteration at the first invocation that returns `false` or "
"`nil`.\n"
"It returns `false` if at least one invocation returns `false` or `nil`.\n"
"Otherwise returns `true`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.all?([2, 4, 6], fn(x) -> rem(x, 2) == 0 end)\n"
"    true\n"
"\n"
"    iex> Enum.all?([2, 3, 4], fn(x) -> rem(x, 2) == 0 end)\n"
"    false\n"
"\n"
"If no function is given, it defaults to checking if\n"
"all items in the enumerable are truthy values.\n"
"\n"
"    iex> Enum.all?([1, 2, 3])\n"
"    true\n"
"\n"
"    iex> Enum.all?([1, nil, 3])\n"
"    false\n"
"\n"
msgstr ""
"enumerableのそれぞれのアイテムに対して与えられた`fun`を起動します。\n"
"`false`または`nil`を返す最初の発動でイテレーションは停止します。\n"
"その結果、少なくとも一つが`false` または`nil`を返したら、\n"
"`false`を返します。さもなければ、`true`を返します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.all?([2, 4, 6], fn(x) -> rem(x, 2) == 0 end)\n"
"    true\n"
"\n"
"    iex> Enum.all?([2, 3, 4], fn(x) -> rem(x, 2) == 0 end)\n"
"    false\n"
"\n"
"関数が与えられないなら、デフォルトでenumerableの\n"
"全てのアイテムが`true`に評価されるかをチェックします。\n"
"\n"
"    iex> Enum.all?([1, 2, 3])\n"
"    true\n"
"\n"
"    iex> Enum.all?([1, nil, 3])\n"
"    false\n"
"\n"

#. TRANSLATORS: def Enum.take_every(enumerable, nth)
#: lib/enum.ex:2123
msgid ""
"Returns a list of every `nth` item in the enumerable,\n"
"starting with the first element.\n"
"\n"
"The first item is always included, unless `nth` is 0.\n"
"\n"
"The second argument specifying every `nth` item must be a non-negative\n"
"integer, otherwise `FunctionClauseError` will be raised.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.take_every(1..10, 2)\n"
"    [1, 3, 5, 7, 9]\n"
"\n"
"    iex> Enum.take_every(1..10, 0)\n"
"    []\n"
"\n"
"    iex> Enum.take_every([1, 2, 3], 1)\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
"enumerableの`nth`番目ごとの要素のコレクションを返します。\n"
"最初の要素からスタートします。\n"
"\n"
"`nth`が0でない限り、最初のアイテムは常に含まれます。\n"
"\n"
"`nth`番目毎を指定する2番目の引数は、非負の整数でなくてはなりま\n"
"せん。さもなければ`FunctionClauseError`が投げられるでしょう。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.take_every(1..10, 2)\n"
"    [1, 3, 5, 7, 9]\n"
"\n"
"    iex> Enum.take_every(1..10, 0)\n"
"    []\n"
"\n"
"    iex> Enum.take_every([1, 2, 3], 1)\n"
"    [1, 2, 3]\n"
"\n"

#. TRANSLATORS: def Enum.chunk(enumerable, count)
#: lib/enum.ex:321
msgid "Shortcut to `chunk(enumerable, count, count)`.\n"
msgstr "`chunk(enumerable, count, count)`へのショートカットです。\n"

#. TRANSLATORS: def Enum.flat_map_reduce(enumerable, acc, fun)
#: lib/enum.ex:881
msgid ""
"Maps and reduces an enumerable, flattening the given results.\n"
"\n"
"It expects an accumulator and a function that receives each stream\n"
"item, and must return a tuple containing a new stream (often a list)\n"
"with the new accumulator or a tuple with `:halt` as first element and\n"
"the accumulator as second.\n"
"\n"
"## Examples\n"
"\n"
"    iex> enum = 1..100\n"
"    iex> n = 3\n"
"    iex> Enum.flat_map_reduce(enum, 0, fn i, acc ->\n"
"    ...>   if acc < n, do: {[i], acc + 1}, else: {:halt, acc}\n"
"    ...> end)\n"
"    {[1, 2, 3], 3}\n"
"\n"
msgstr ""
"enumerableをmapしてreduceし、結果をflattenします。\n"
"\n"
"アキュムレータと関数を期待します。関数は、それぞれのストリームのアイテ\n"
"ムとアキュムレータを受信して、新しいストリーム(しばしばリストです)と新\n"
"しいアキュムレータを含むタプルか、最初の要素が`:halt`で二つめの要素がア\n"
"キュムレータであるタプルを、返さなくてはなりません。\n"
"\n"
"## Examples\n"
"\n"
"    iex> enum = 1..100\n"
"    iex> n = 3\n"
"    iex> Enum.flat_map_reduce(enum, 0, fn i, acc ->\n"
"    ...>   if acc < n, do: {[i], acc + 1}, else: {:halt, acc}\n"
"    ...> end)\n"
"    {[1, 2, 3], 3}\n"
"\n"

#. TRANSLATORS: def Enum.group_by(enumerable, map \\ %{}, fun)
#: lib/enum.ex:1440
#, fuzzy
msgid ""
"Splits the enumerable into groups based on `fun`.\n"
"\n"
"The result is a map where each key is a group and each value is\n"
"a list of elements from enumerable for which `fun` returned that\n"
"group. Ordering is preserved.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.group_by(~w{ant buffalo cat dingo}, &String.length/1)\n"
"    %{3 => [\"ant\", \"cat\"], 7 => [\"buffalo\"], 5 => [\"dingo\"]}\n"
"\n"
msgstr ""
"enumerableを分割して`fun`に基いてグループ化します。\n"
"\n"
"結果は、キーがグループで、値が`fun`が返したグループによる、\n"
"enumerableからの要素のリストとなるdict(デフォルトではマップ)です。\n"
"順序は保存されません。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.group_by(~w{ant buffalo cat dingo}, &String.length/1)\n"
"    %{3 => [\"cat\", \"ant\"], 7 => [\"buffalo\"], 5 => [\"dingo\"]}\n"
"\n"

#. TRANSLATORS: def Enum.any?(enumerable, fun \\ fn x -> x end)
#: lib/enum.ex:246
msgid ""
"Invokes the given `fun` for each item in the enumerable.\n"
"It stops the iteration at the first invocation that returns a truthy value.\n"
"Returns `true` if at least one invocation returns a truthy value.\n"
"Otherwise returns `false`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.any?([2, 4, 6], fn(x) -> rem(x, 2) == 1 end)\n"
"    false\n"
"\n"
"    iex> Enum.any?([2, 3, 4], fn(x) -> rem(x, 2) == 1 end)\n"
"    true\n"
"\n"
"If no function is given, it defaults to checking if at least one item\n"
"in the enumerable is a truthy value.\n"
"\n"
"    iex> Enum.any?([false, false, false])\n"
"    false\n"
"\n"
"    iex> Enum.any?([false, true, false])\n"
"    true\n"
"\n"
msgstr ""
"enumerableのそれぞれのアイテムに対して、与えられた`fun`を起動します。\n"
"最初に真の値を返した時点でイテレーションは停止します。\n"
"少なくとも一つが`true`を返すなら、`true`を返します。さもなければ、`false`を\n"
"返します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.any?([2, 4, 6], fn(x) -> rem(x, 2) == 1 end)\n"
"    false\n"
"\n"
"    iex> Enum.any?([2, 3, 4], fn(x) -> rem(x, 2) == 1 end)\n"
"    true\n"
"\n"
"関数が与えられないと、デフォルトで少なくともひとつのコレク\n"
"ションのアイテムが真に評価されるかをチェックします。\n"
"\n"
"    iex> Enum.any?([false, false, false])\n"
"    false\n"
"\n"
"    iex> Enum.any?([false, true, false])\n"
"    true\n"
"\n"

#. TRANSLATORS: def Enum.member?(enumerable, element)
#: lib/enum.ex:1230
msgid ""
"Checks if `element` exists within the enumerable.\n"
"\n"
"Membership is tested with the match (`===`) operator.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.member?(1..10, 5)\n"
"    true\n"
"    iex> Enum.member?(1..10, 5.0)\n"
"    false\n"
"\n"
"    iex> Enum.member?([1.0, 2.0, 3.0], 2)\n"
"    false\n"
"    iex> Enum.member?([1.0, 2.0, 3.0], 2.000)\n"
"    true\n"
"\n"
"    iex> Enum.member?([:a, :b, :c], :d)\n"
"    false\n"
"\n"
msgstr ""
"`element`がenumerableの中に存在するかチェックします。\n"
"\n"
"メンバーシップはマッチオペレータ(`===`)でテストされます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.member?(1..10, 5)\n"
"    true\n"
"    iex> Enum.member?(1..10, 5.0)\n"
"    false\n"
"\n"
"    iex> Enum.member?([1.0, 2.0, 3.0], 2)\n"
"    false\n"
"    iex> Enum.member?([1.0, 2.0, 3.0], 2.000)\n"
"    true\n"
"\n"
"    iex> Enum.member?([:a, :b, :c], :d)\n"
"    false\n"
"\n"

#. TRANSLATORS: def Enum.find_index(enumerable, fun)
#: lib/enum.ex:829
msgid ""
"Similar to `find/3`, but returns the index (zero-based)\n"
"of the element instead of the element itself.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.find_index([2, 4, 6], fn(x) -> rem(x, 2) == 1 end)\n"
"    nil\n"
"\n"
"    iex> Enum.find_index([2, 3, 4], fn(x) -> rem(x, 2) == 1 end)\n"
"    1\n"
"\n"
msgstr ""
"`find/3`と似ていますが、要素自身の替わりに要素のインデックス(ゼロ始ま\n"
"り)を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.find_index([2, 4, 6], fn(x) -> rem(x, 2) == 1 end)\n"
"    nil\n"
"\n"
"    iex> Enum.find_index([2, 3, 4], fn(x) -> rem(x, 2) == 1 end)\n"
"    1\n"
"\n"

#. TRANSLATORS: def Enum.scan(enumerable, acc, fun)
#: lib/enum.ex:1719
msgid ""
"Applies the given function to each element in the enumerable,\n"
"storing the result in a list and passing it as the accumulator\n"
"for the next computation. Uses the given `acc` as the starting value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.scan(1..5, 0, &(&1 + &2))\n"
"    [1, 3, 6, 10, 15]\n"
"\n"
msgstr ""
"与えられた関数を、enumerableのそれぞれの要素に適用し、\n"
"リストに結果を保存し、次の計算のためのアキュムレータとして\n"
"渡します。与えられた`acc`は、初期値として使います。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.scan(1..5, 0, &(&1 + &2))\n"
"    [1, 3, 6, 10, 15]\n"
"\n"

#. TRANSLATORS: def Enum.scan(enumerable, fun)
#: lib/enum.ex:1702
msgid ""
"Applies the given function to each element in the enumerable,\n"
"storing the result in a list and passing it as the accumulator\n"
"for the next computation.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.scan(1..5, &(&1 + &2))\n"
"    [1, 3, 6, 10, 15]\n"
"\n"
msgstr ""
"与えられた関数を、enumerableのそれぞれの要素に適用し、\n"
"リストに結果を保存し、次の計算のためのアキュムレータとして\n"
"渡します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.scan(1..5, &(&1 + &2))\n"
"    [1, 3, 6, 10, 15]\n"
"\n"

#. TRANSLATORS: def Enum.count(enumerable, fun)
#: lib/enum.ex:471
msgid ""
"Returns the count of items in the enumerable for which `fun` returns\n"
"a truthy value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.count([1, 2, 3, 4, 5], fn(x) -> rem(x, 2) == 0 end)\n"
"    2\n"
"\n"
msgstr ""
"enumerableの中で`fun`が真な値を返す要素の数を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.count([1, 2, 3, 4, 5], fn(x) -> rem(x, 2) == 0 end)\n"
"    2\n"
"\n"

#. TRANSLATORS: def Enum.shuffle(enumerable)
#: lib/enum.ex:1736
msgid ""
"Returns a list with the elements of `enumerable` shuffled.\n"
"\n"
"This function uses Erlang's `:rand` module to calculate\n"
"the random value. Check its documentation for setting a\n"
"different random algorithm or a different seed.\n"
"\n"
"## Examples\n"
"\n"
"    # Although not necessary, let's seed the random algorithm\n"
"    iex> :rand.seed(:exsplus, {1, 2, 3})\n"
"    iex> Enum.shuffle([1, 2, 3])\n"
"    [2, 1, 3]\n"
"    iex> Enum.shuffle([1, 2, 3])\n"
"    [2, 3, 1]\n"
"\n"
msgstr ""
"`enumerable`の要素をシャッフルしたリストを返します。\n"
"\n"
"この関数はErlangの乱数の計算に `:rand`モジュールを使います。\n"
"異る乱数アルゴリズムあるいは異るseedについては\n"
"そのドキュメントを参照してください。\n"
"\n"
"## Examples\n"
"\n"
"    # Although not necessary, let's seed the random algorithm\n"
"    iex> :rand.seed(:exsplus, {1, 2, 3})\n"
"    iex> Enum.shuffle([1, 2, 3])\n"
"    [2, 1, 3]\n"
"    iex> Enum.shuffle([1, 2, 3])\n"
"    [2, 3, 1]\n"
"\n"

#. TRANSLATORS: def Enum.join(enumerable, joiner \\ "")
#: lib/enum.ex:1040
msgid ""
"Joins the given enumerable into a binary using `joiner` as a\n"
"separator.\n"
"\n"
"If `joiner` is not passed at all, it defaults to the empty binary.\n"
"\n"
"All items in the enumerable must be convertible to a binary,\n"
"otherwise an error is raised.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.join([1, 2, 3])\n"
"    \"123\"\n"
"\n"
"    iex> Enum.join([1, 2, 3], \" = \")\n"
"    \"1 = 2 = 3\"\n"
"\n"
msgstr ""
"enumerableをバイナリ`joiner`をセパレータとしてjoinします。\n"
"\n"
"もし`joiner`が全くパスされない場合、デフォルトは空のバイナリに\n"
"なります。\n"
"\n"
"コレクションの全てのアイテムはバイナリへ変換できなければ\n"
"なりません。さもないとエラーが上ります。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.join([1, 2, 3])\n"
"    \"123\"\n"
"\n"
"    iex> Enum.join([1, 2, 3], \" = \")\n"
"    \"1 = 2 = 3\"\n"
"\n"

#. TRANSLATORS: def Enum.fetch(enumerable, index)
#: lib/enum.ex:650
msgid ""
"Finds the element at the given `index` (zero-based).\n"
"\n"
"Returns `{:ok, element}` if found, otherwise `:error`.\n"
"\n"
"A negative `index` can be passed, which means the `enumerable` is\n"
"enumerated once and the `index` is counted from the end (e.g.\n"
"`-1` fetches the last element).\n"
"\n"
"Note this operation takes linear time. In order to access\n"
"the element at index `index`, it will need to traverse `index`\n"
"previous elements.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.fetch([2, 4, 6], 0)\n"
"    {:ok, 2}\n"
"\n"
"    iex> Enum.fetch([2, 4, 6], 2)\n"
"    {:ok, 6}\n"
"\n"
"    iex> Enum.fetch([2, 4, 6], 4)\n"
"    :error\n"
"\n"
msgstr ""
"与えられた(0始まりの) `index`の要素を見付けます。\n"
"\n"
"見付かれば、`{:ok, element}`を返し、さもなければ`:error`を返します。\n"
"\n"
"負の`index`が渡されると、`enumerable`は一度列挙され、\n"
"`index`は終わりから数えられる(即ち、`-1`は最後の要素を\n"
"取ってきます)ことを意味します。\n"
"\n"
"この操作は線形時間がかかることに気を付けてください。\n"
"インデックス `index`の要素へアクセスするために、`index`個の以前の\n"
"要素を渡り歩く必要があります。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.fetch([2, 4, 6], 0)\n"
"    {:ok, 2}\n"
"\n"
"    iex> Enum.fetch([2, 4, 6], 2)\n"
"    {:ok, 6}\n"
"\n"
"    iex> Enum.fetch([2, 4, 6], 4)\n"
"    :error\n"
"\n"

#. TRANSLATORS: def Enum.take(enumerable, count)
#: lib/enum.ex:2049
msgid ""
"Takes the first `count` items from the enumerable.\n"
"\n"
"`count` must be an integer. If a negative `count` is given, the last\n"
"`count` values will be taken.\n"
"For such, the enumerable is fully enumerated keeping up\n"
"to `2 * count` elements in memory. Once the end of the enumerable is\n"
"reached, the last `count` elements are returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.take([1, 2, 3], 2)\n"
"    [1, 2]\n"
"\n"
"    iex> Enum.take([1, 2, 3], 10)\n"
"    [1, 2, 3]\n"
"\n"
"    iex> Enum.take([1, 2, 3], 0)\n"
"    []\n"
"\n"
"    iex> Enum.take([1, 2, 3], -1)\n"
"    [3]\n"
"\n"
msgstr ""
"最初の`count`個のアイテムをenumerableから取り出します。\n"
"\n"
"`count`は整数でなくてはなりません。`count`に負が与えられると、\n"
"最後の`count`個が取り出されます。そのため、コレクションは完全な\n"
"列挙にはメモリ内に`2 * count`要素が続きます。コレクションの終わ\n"
"りに到達したら、最後の`count`個の要素が返されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.take([1, 2, 3], 2)\n"
"    [1,2]\n"
"\n"
"    iex> Enum.take([1, 2, 3], 10)\n"
"    [1,2,3]\n"
"\n"
"    iex> Enum.take([1, 2, 3], 0)\n"
"    []\n"
"\n"
"    iex> Enum.take([1, 2, 3], -1)\n"
"    [3]\n"
"\n"

#. TRANSLATORS: def Enum.reduce(enumerable, acc, fun)
#: lib/enum.ex:1478
msgid ""
"Invokes `fun` for each element in the `enumerable`, passing that\n"
"element and the accumulator `acc` as arguments. `fun`'s return value\n"
"is stored in `acc`.\n"
"\n"
"Returns the accumulator.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reduce([1, 2, 3], 0, fn(x, acc) -> x + acc end)\n"
"    6\n"
"\n"
msgstr ""
"`enumerable`のそれぞれの要素について、その要素とアキュムレータを引数とし\n"
"て、`fun`を起動します。`fun`の戻り値は、`acc`に保存されます。\n"
"\n"
"アキュムレータを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.reduce([1, 2, 3], 0, fn(x, acc) -> x + acc end)\n"
"    6\n"
"\n"

#. TRANSLATORS: def Enum.intersperse(enumerable, element)
#: lib/enum.ex:921
msgid ""
"Intersperses `element` between each element of the enumeration.\n"
"\n"
"Complexity: O(n).\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.intersperse([1, 2, 3], 0)\n"
"    [1, 0, 2, 0, 3]\n"
"\n"
"    iex> Enum.intersperse([1], 0)\n"
"    [1]\n"
"\n"
"    iex> Enum.intersperse([], 0)\n"
"    []\n"
"\n"
msgstr ""
"enumerableのそれぞれの要素の間で、`element`を散在さ\n"
"せます。\n"
"\n"
"複雑さ: O(n)\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.intersperse([1, 2, 3], 0)\n"
"    [1, 0, 2, 0, 3]\n"
"\n"
"    iex> Enum.intersperse([1], 0)\n"
"    [1]\n"
"\n"
"    iex> Enum.intersperse([], 0)\n"
"    []\n"
"\n"

#. TRANSLATORS: @type continuation
#: lib/enum.ex:84
msgid ""
"A partially applied reduce function.\n"
"\n"
"The continuation is the closure returned as a result when\n"
"the enumeration is suspended. When invoked, it expects\n"
"a new accumulator and it returns the result.\n"
"\n"
"A continuation is easily implemented as long as the reduce\n"
"function is defined in a tail recursive fashion. If the function\n"
"is tail recursive, all the state is passed as arguments, so\n"
"the continuation would simply be the reducing function partially\n"
"applied.\n"
msgstr ""
"reduce関数の部分適用です。\n"
"\n"
"continuation(継続)は数え上げ(enumeration)が中断(suspended)\n"
"された時に結果として返されるクロージャです。起動されるとき、\n"
"新しいアキュムレータを期待して、結果を返します。\n"
"\n"
"継続はreduce関数が末尾再帰様式で定義されているかぎり、簡単\n"
"に実装されます。もし関数が末尾再帰なら、全てのステートは引\n"
"数としてパスされ、継続は単に部分的に適用されるreduce関数に\n"
"なるでしょう。\n"

#. TRANSLATORS: @type result
#: lib/enum.ex:65
msgid ""
"The result of the reduce operation.\n"
"\n"
"It may be *done* when the enumeration is finished by reaching\n"
"its end, or *halted*/*suspended* when the enumeration was halted\n"
"or suspended by the `t:reducer/0` function.\n"
"\n"
"In case a `t:reducer/0` function returns the `:suspend` accumulator, the\n"
"`:suspended` tuple must be explicitly handled by the caller and\n"
"never leak. In practice, this means regular enumeration functions\n"
"just need to be concerned about `:done` and `:halted` results.\n"
"\n"
"Furthermore, a `:suspend` call must always be followed by another call,\n"
"eventually halting or continuing until the end.\n"
msgstr ""
"reduceオペレーションの結果です。\n"
"\n"
"終りに到達することで数え上げ(enumeration)が終了したときに\n"
"*done* になり、`t:reducer/0`関数により数え上げ(enumeration)が中止\n"
"(halted)や中断(suspend)された時に *halted*/*suspended* になり\n"
"ます。\n"
"\n"
"`t:reducer/0`関数が`:suspend`アキュムレータを返した場合、呼出し側に\n"
"より、`:suspended`タプルは漏れ無く明示的にハンドルされなけれ\n"
"ばなりません。実際には、これは標準の数え上げ(enumeration)関数\n"
"は`:done`と`:halted`についてだけ心配する必要があることを意味\n"
"します。\n"
"\n"
"さらに、`:suspend`呼出しは、常にもう一つの呼出しがつづき、結\n"
"局中止(halting)するか、終りまで続け(continuing)ます。\n"

#. TRANSLATORS: def Enum.reverse(enumerable, tail)
#: lib/enum.ex:1617
msgid ""
"Reverses the elements in `enumerable`, appends the tail, and returns\n"
"it as a list.\n"
"\n"
"This is an optimization for\n"
"`Enum.concat(Enum.reverse(enumerable), tail)`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reverse([1, 2, 3], [4, 5, 6])\n"
"    [3, 2, 1, 4, 5, 6]\n"
"\n"
msgstr ""
"`enumerable`を逆順にしてtailを追加したものをリストとして返します。\n"
"\n"
"これは`Enum.concat(Enum.reverse(collection), tail)`の最適化です。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.reverse([1, 2, 3], [4, 5, 6])\n"
"    [3, 2, 1, 4, 5, 6]\n"
"\n"

#. TRANSLATORS: def Enum.reverse(enumerable)
#: lib/enum.ex:1599
msgid ""
"Returns a list of elements in `enumerable` in reverse order.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reverse([1, 2, 3])\n"
"    [3, 2, 1]\n"
"\n"
msgstr ""
"`enumerable`を逆順にしたリストを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.reverse([1, 2, 3])\n"
"    [3, 2, 1]\n"
"\n"

#. TRANSLATORS: def Enum.unzip(enumerable)
#: lib/enum.ex:2318
msgid ""
"Opposite of `Enum.zip/2`; extracts a two-element tuples from the\n"
"enumerable and groups them together.\n"
"\n"
"It takes an enumerable with items being two-element tuples and returns\n"
"a tuple with two lists, each of which is formed by the first and\n"
"second element of each tuple, respectively.\n"
"\n"
"This function fails unless `enumerable` is or can be converted into a\n"
"list of tuples with *exactly* two elements in each tuple.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.unzip([{:a, 1}, {:b, 2}, {:c, 3}])\n"
"    {[:a, :b, :c], [1, 2, 3]}\n"
"\n"
"    iex> Enum.unzip(%{a: 1, b: 2})\n"
"    {[:a, :b], [1, 2]}\n"
"\n"
msgstr ""
"`Enum.zip/2`の正反対; 二要素のタプルのenumerableから\n"
"それらのグループに展開します。\n"
"\n"
"二つの要素のタプルからなるenumerableをとり、\n"
"二つのリストからなるタプルを返します。それぞれのリストは\n"
"対応する最初の要素だけから、２番目の要素だけから作られます。\n"
"\n"
"`enumerable`が各のタプルで *正確に* 二要素のタプルのリストであるか、\n"
"それにコンバート出来ない限り、この関数は失敗します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.unzip([{:a, 1}, {:b, 2}, {:c, 3}])\n"
"    {[:a, :b, :c], [1, 2, 3]}\n"
"\n"
"    iex> Enum.unzip(%{a: 1, b: 2})\n"
"    {[:a, :b], [1, 2]}\n"
"\n"

#. TRANSLATORS: def Enum.concat(enumerables)
#: lib/enum.ex:398
msgid ""
"Given an enumerable of enumerables, concatenates the enumerables into\n"
"a single list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.concat([1..3, 4..6, 7..9])\n"
"    [1, 2, 3, 4, 5, 6, 7, 8, 9]\n"
"\n"
"    iex> Enum.concat([[1, [2], 3], [4], [5, 6]])\n"
"    [1, [2], 3, 4, 5, 6]\n"
"\n"
msgstr ""
"与えられたenumerableのenumerableを一つのリストに連結します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.concat([1..3, 4..6, 7..9])\n"
"    [1, 2, 3, 4, 5, 6, 7, 8, 9]\n"
"\n"
"    iex> Enum.concat([[1, [2], 3], [4], [5, 6]])\n"
"    [1, [2], 3, 4, 5, 6]\n"
"\n"

#. TRANSLATORS: def Enum.take_while(enumerable, fun)
#: lib/enum.ex:2225
msgid ""
"Takes the items from the beginning of the enumerable while `fun` returns\n"
"a truthy value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.take_while([1, 2, 3], fn(x) -> x < 3 end)\n"
"    [1, 2]\n"
"\n"
msgstr ""
"enumerableの先頭から`fun`が真な値を返す間のアイテムを取り出します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.take_while([1, 2, 3], fn(x) -> x < 3 end)\n"
"    [1, 2]\n"
"\n"

#. TRANSLATORS: def Enumerable.count(enumerable)
#: lib/enum.ex:133
msgid ""
"Retrieves the enumerable's size.\n"
"\n"
"It should return `{:ok, size}`.\n"
"\n"
"If `{:error, __MODULE__}` is returned a default algorithm using\n"
"`reduce` and the match (`===`) operator is used. This algorithm runs\n"
"in linear time.\n"
"\n"
"_Please force use of the default algorithm unless you can implement an\n"
"algorithm that is significantly faster._\n"
msgstr ""
"enumerableのサイズを取り出します。\n"
"\n"
"通常は`{:ok, size}`を返すべきです。\n"
"\n"
"もし`{:error, __MODULE__}`を返したら、デフォルトアルゴリズムの\n"
"`reduce`とマッチ(`===`)オペレータが使われます。このアルゴリズムは実行に\n"
"線形時間がかかります。\n"
"\n"
"_あなたがより速いアルゴリズムを実装することができない限り、デフォルトの\n"
"アルゴリズムの使用を強制してください。_\n"

#. TRANSLATORS: def Enumerable.member?(enumerable, element)
#: lib/enum.ex:118
msgid ""
"Checks if an element exists within the enumerable.\n"
"\n"
"It should return `{:ok, boolean}`.\n"
"\n"
"If `{:error, __MODULE__}` is returned a default algorithm using\n"
"`reduce` and the match (`===`) operator is used. This algorithm runs\n"
"in linear time.\n"
"\n"
"_Please force use of the default algorithm unless you can implement an\n"
"algorithm that is significantly faster._\n"
msgstr ""
"要素がenumerableの中に存在するかチェックします。\n"
"\n"
"`{:ok, boolean}`を返すべきです。\n"
"\n"
"`{:error, __MODULE__}`を返したら、`reduce`とマッチオペレータ(`===`)を使う\n"
"デフォルトアルゴリズムが使われます。このアルゴリズムは線形に時間がかかりま"
"す。\n"
"\n"
"_より速いアルゴリズムのを実装することができない限り、デフォルトアルゴリ\n"
"ズムの使用を強制してください。_\n"

#. TRANSLATORS: def Enum.max(enumerable)
#: lib/enum.ex:1167
msgid ""
"Returns the biggest of the elements in the enumerable according\n"
"to Erlang's term ordering.\n"
"\n"
"If more than one elements compare equal, the first one that was found\n"
"is returned.\n"
"\n"
"Raises `Enum.EmptyError` if `enumerable` is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.max([1, 2, 3])\n"
"    3\n"
"\n"
msgstr ""
"Erlangのtermの順序にしたがってenumerableの最大の要素を返します。\n"
"\n"
"同じ大きさの要素が複数ある場合、最初のものが返されます。\n"
"\n"
"`enumerable`が空の時、`Enum.EmptyError`が上ります。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.max([1, 2, 3])\n"
"    3\n"
"\n"

#. TRANSLATORS: def Enum.into(enumerable, collectable, transform)
#: lib/enum.ex:1001
msgid ""
"Inserts the given `enumerable` into a `collectable` according to the\n"
"transformation function.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.into([2, 3], [3], fn x -> x * 3 end)\n"
"    [3, 6, 9]\n"
"\n"
msgstr ""
"変換関数に従って、与えられた`enumerable`を`collectable`に挿入します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.into([2, 3], [3], fn x -> x * 3 end)\n"
"    [3, 6, 9]\n"
"\n"

#. TRANSLATORS: def Enum.max_by(enumerable, fun)
#: lib/enum.ex:1187
msgid ""
"Returns the biggest of the elements in the enumerable as calculated\n"
"by the given function.\n"
"\n"
"If more than one elements compare equal, the first one that was found\n"
"is returned.\n"
"\n"
"Raises `Enum.EmptyError` if `enumerable` is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.max_by([\"a\", \"aa\", \"aaa\"], fn(x) -> String.length(x) "
"end)\n"
"    \"aaa\"\n"
"\n"
msgstr ""
"与えられた関数により計算した値が最大となる要素を返します。\n"
"\n"
"もし複数の要素が最大となるなら、最初のに見付かった値を\n"
"返します。\n"
"\n"
"もしコレクションが空なら、`EmptyError`を上げます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.max_by([\"a\", \"aa\", \"aaa\"], fn(x) -> String.length(x) "
"end)\n"
"    \"aaa\"\n"
"\n"

#. TRANSLATORS: def Enum.count(enumerable)
#: lib/enum.ex:446
msgid ""
"Returns the size of the enumerable.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.count([1, 2, 3])\n"
"    3\n"
"\n"
msgstr ""
"enumerableのサイズを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.count([1, 2, 3])\n"
"    3\n"
"\n"

#. TRANSLATORS: def Enum.random(enumerable)
#: lib/enum.ex:1669
msgid ""
"Returns a random element of an enumerable.\n"
"\n"
"Raises `Enum.EmptyError` if `enumerable` is empty.\n"
"\n"
"This function uses Erlang's `:rand` module to calculate\n"
"the random value. Check its documentation for setting a\n"
"different random algorithm or a different seed.\n"
"\n"
"The implementation is based on the\n"
"[reservoir sampling](https://en.wikipedia.org/wiki/"
"Reservoir_sampling#Relation_to_Fisher-Yates_shuffle)\n"
"algorithm.\n"
"It assumes that the sample being returned can fit into memory;\n"
"the input `enumerable` doesn't have to, as it is traversed just once.\n"
"\n"
"## Examples\n"
"\n"
"    # Although not necessary, let's seed the random algorithm\n"
"    iex> :rand.seed(:exsplus, {1, 2, 3})\n"
"    iex> Enum.random([1, 2, 3])\n"
"    2\n"
"    iex> Enum.random([1, 2, 3])\n"
"    1\n"
"\n"
msgstr ""
"enumerableの要素をランダム化して返します。\n"
"\n"
"もし`enumerable`が空なら、`EmptyError`が上ります。\n"
"\n"
"この関数は乱数の計算にErlangの `:rand` モジュールを\n"
"使っています。異る乱数アルゴリズムのセッティングや\n"
"seedについてはそのドキュメントを参照してください。\n"
"\n"
"実装は、\n"
"[reservoir sampling](http://en.wikipedia.org/wiki/\n"
"Reservoir_sampling#Relation_to_Fisher-Yates_shuffle)\n"
"アルゴリズムに基いています。\n"
"それは返されるサンプルがメモリに収まると仮定します; 入力の\n"
"コレクションはその必要はありません。それは丁度一度だけトラバース\n"
"されます。\n"
"\n"
"## 例\n"
"\n"
"    # Although not necessary, let's seed the random algorithm\n"
"    iex> :rand.seed(:exsplus, {1, 2, 3})\n"
"    iex> Enum.random([1, 2, 3])\n"
"    1\n"
"    iex> Enum.random([1, 2, 3])\n"
"    2\n"
"\n"

#. TRANSLATORS: def Enum.sort(enumerable)
#: lib/enum.ex:1871
msgid ""
"Sorts the enumerable according to Erlang's term ordering.\n"
"\n"
"Uses the merge sort algorithm.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.sort([3, 2, 1])\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
"Erlangのtermの順序でenumerableをソートします。\n"
"\n"
"マージソートアルゴリズムを使います。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.sort([3, 2, 1])\n"
"    [1, 2, 3]\n"
"\n"

#. TRANSLATORS: def Enum.sum(enumerable)
#: lib/enum.ex:1399
msgid ""
"Returns the sum of all elements.\n"
"\n"
"Raises `ArithmeticError` if `enumerable` contains a non-numeric value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.sum([1, 2, 3])\n"
"    6\n"
"\n"
msgstr ""
"全ての要素の和を返します。\n"
"\n"
"もし`enumerable`が非数値を含んでないなら`ArithmeticError`を上げます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.sum([1, 2, 3])\n"
"    6\n"
"\n"

#. TRANSLATORS: def Enum.reduce_while(enumerable, acc, fun)
#: lib/enum.ex:1560
msgid ""
"Reduces the enumerable until `halt` is emitted.\n"
"\n"
"The return value for `fun` is expected to be `{:cont, acc}`, return\n"
"`{:halt, acc}` to end the reduction early.\n"
"\n"
"Returns the accumulator.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reduce_while(1..100, 0, fn i, acc ->\n"
"    ...>   if i < 3, do: {:cont, acc + i}, else: {:halt, acc}\n"
"    ...> end)\n"
"    3\n"
"\n"
msgstr ""
"`halt`となるまでenumerableをreduce(簡約)します。\n"
"\n"
"`fun`の戻値は、`{:cont, acc}`、あるいは、\n"
"reduce(簡約)を途中で終了するために`{:halt, acc}`が\n"
"期待されています。\n"
"\n"
"アキュムレータを返します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reduce_while(1..100, 0, fn i, acc ->\n"
"    ...>   if i < 3, do: {:cont, acc + i}, else: {:halt, acc}\n"
"    ...> end)\n"
"    3\n"
"\n"

#. TRANSLATORS: def Enum.reverse_slice(enumerable, start, count)
#: lib/enum.ex:1642
msgid ""
"Reverses the enumerable in the range from initial position `start`\n"
"through `count` elements.\n"
"\n"
"If `count` is greater than the size of the rest of the enumerable,\n"
"then this function will reverse the rest of the enumerable.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reverse_slice([1, 2, 3, 4, 5, 6], 2, 4)\n"
"    [1, 2, 6, 5, 4, 3]\n"
"\n"
msgstr ""
"初期位置が`first`からの`count`要素の範囲(range)のenumerableを\n"
"逆転させます。\n"
"\n"
"もし`count`がenumerableの残りの大きさより大きい場合、\n"
"この関数はenumerableの残り全部を逆転させます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.reverse_slice([1, 2, 3, 4, 5, 6], 2, 4)\n"
"    [1, 2, 6, 5, 4, 3]\n"
"\n"

#. TRANSLATORS: @type acc
#: lib/enum.ex:37
msgid ""
"The accumulator value for each step.\n"
"\n"
"It must be a tagged tuple with one of the following \"tags\":\n"
"\n"
"  * `:cont`    - the enumeration should continue\n"
"  * `:halt`    - the enumeration should halt immediately\n"
"  * `:suspend` - the enumeration should be suspended immediately\n"
"\n"
"Depending on the accumulator value, the result returned by\n"
"`Enumerable.reduce/3` will change. Please check the `t:result/0`\n"
"type documentation for more information.\n"
"\n"
"In case a `t:reducer/0` function returns a `:suspend` accumulator,\n"
"it must be explicitly handled by the caller and never leak.\n"
msgstr ""
"それぞれのステップのアキュムレータの値。\n"
"\n"
"以下の\"タグ\"の何れかにタグ付けられたタプルでなければなりません:\n"
"\n"
"  * `:cont`    - 数え上げ(enumeration)を続けなければならない\n"
"  * `:halt`    - 数え上げ(enumeration)は直ちに中止されなければならない\n"
"  * `:suspend` - 数え上げ(enumeration)は直ちに中断されなければならない\n"
"\n"
"アキュムレータ値に依存して`Enumerable.reduce/3`の戻値は変わり\n"
"ます。詳細は `t:result/0` type ドキュメントをチェックしてください。\n"
"\n"
"`t:reducer/0`関数が`:suspend`アキュムレータを返す場合、呼出し側で明\n"
"示的にハンドルされなければならず、決して漏れてはなりません。\n"

#. TRANSLATORS: def Enum.filter_map(enumerable, filter, mapper)
#: lib/enum.ex:749
msgid ""
"Filters the enumerable and maps its elements in one pass.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.filter_map([1, 2, 3], fn(x) -> rem(x, 2) == 0 end, &(&1 * 2))\n"
"    [4]\n"
"\n"
msgstr ""
"一度のパスでenumerableをフィルタしてマップします。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.filter_map([1, 2, 3], fn(x) -> rem(x, 2) == 0 end, &(&1 * 2))\n"
"    [4]\n"
"\n"

#. TRANSLATORS: def Enum.empty?(enumerable)
#: lib/enum.ex:620
msgid ""
"Determines if the enumerable is empty.\n"
"\n"
"Returns `true` if `enumerable` is empty, otherwise `false`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.empty?([])\n"
"    true\n"
"\n"
"    iex> Enum.empty?([1, 2, 3])\n"
"    false\n"
"\n"
msgstr ""
"enumerableが空かどうかを決定します。\n"
"\n"
"もし、`enumerable`が空なら、`true`を、さもなくば`false`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.empty?([])\n"
"    true\n"
"\n"
"    iex> Enum.empty?([1, 2, 3])\n"
"    false\n"
"\n"

#. TRANSLATORS: def Enum.map(enumerable, fun)
#: lib/enum.ex:1073
#, fuzzy
msgid ""
"Returns a list where each item is the result of invoking\n"
"`fun` on each corresponding item of `enumerable`.\n"
"\n"
"For maps, the function expects a key-value tuple.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.map([1, 2, 3], fn(x) -> x * 2 end)\n"
"    [2, 4, 6]\n"
"\n"
"    iex> Enum.map([a: 1, b: 2], fn({k, v}) -> {k, -v} end)\n"
"    [a: -1, b: -2]\n"
"\n"
msgstr ""
"`enumerable`のそれぞれのアイテムについて、`fun`を実行した結果を\n"
"要素とする、新しいリストを返します。\n"
"\n"
"dictの場合、関数はKey-valueタプルを期待します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.map([1, 2, 3], fn(x) -> x * 2 end)\n"
"    [2, 4, 6]\n"
"\n"
"    iex> Enum.map([a: 1, b: 2], fn({k, v}) -> {k, -v} end)\n"
"    [a: -1, b: -2]\n"
"\n"

#. TRANSLATORS: def Enum.chunk(enumerable, count, step, pad \\ nil)
#: lib/enum.ex:327
msgid ""
"Returns list of lists containing `count` items each, where\n"
"each new chunk starts `step` elements into the enumerable.\n"
"\n"
"`step` is optional and, if not passed, defaults to `count`, i.e.\n"
"chunks do not overlap.\n"
"\n"
"If the final chunk does not have `count` elements to fill the chunk,\n"
"elements are taken as necessary from `pad` if it was passed.\n"
"\n"
"If `pad` is passed and does not have enough elements to fill the\n"
"chunk, then the chunk is returned anyway with less than `count`\n"
"elements.\n"
"If `pad` is not passed at all or is `nil`, then the partial chunk is\n"
"discarded from the result.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4, 5, 6], 2)\n"
"    [[1, 2], [3, 4], [5, 6]]\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4, 5, 6], 3, 2)\n"
"    [[1, 2, 3], [3, 4, 5]]\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4, 5, 6], 3, 2, [7])\n"
"    [[1, 2, 3], [3, 4, 5], [5, 6, 7]]\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4, 5, 6], 3, 3, [])\n"
"    [[1, 2, 3], [4, 5, 6]]\n"
"\n"
msgstr ""
"enumerableから`step`要素毎に`count`個のアイテムを含んだリストのリストを\n"
"返します。\n"
"\n"
"`step`はオプションで、もし与えられなければ、デフォルトは`count`になります。\n"
"即ち、チャンクはオーバーラップしません。\n"
"\n"
"もし最後のチャンクはチャンクを満す`count`個の要素を持っていなかったら、\n"
"要素は`pad`から必要に応じて取られます。\n"
"\n"
"もし`pad`が与えられていて、チャンクを満すのに十分でなかったら、チャンク\n"
"は`count`要素より少くなるでしょう。\n"
"もし`pad`が全く与えられていないか、`nil`なら、結果から部分的なチャンクは\n"
"放棄されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4, 5, 6], 2)\n"
"    [[1, 2], [3, 4], [5, 6]]\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4, 5, 6], 3, 2)\n"
"    [[1, 2, 3], [3, 4, 5]]\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4, 5, 6], 3, 2, [7])\n"
"    [[1, 2, 3], [3, 4, 5], [5, 6, 7]]\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4, 5, 6], 3, 3, [])\n"
"    [[1, 2, 3], [4, 5, 6]]\n"
"\n"

#. TRANSLATORS: def Enum.uniq(enumerable)
#: lib/enum.ex:2271
msgid ""
"Enumerates the `enumerable`, removing all duplicated elements.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.uniq([1, 2, 3, 3, 2, 1])\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
"重複するアイテムを削除しながら、`enumerable`を列挙します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.uniq([1, 2, 3, 2, 1])\n"
"    [1, 2, 3]\n"
"\n"

#. TRANSLATORS: def Enum.slice(enumerable, start, count)
#: lib/enum.ex:1761
msgid ""
"Returns a subset list of the given enumerable. Drops elements\n"
"until element position `start`, then takes `count` elements.\n"
"\n"
"If the count is greater than `enumerable` length, it returns as\n"
"many as possible. If zero, then it returns `[]`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.slice(1..100, 5, 10)\n"
"    [6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n"
"\n"
"    iex> Enum.slice(1..10, 5, 100)\n"
"    [6, 7, 8, 9, 10]\n"
"\n"
"    iex> Enum.slice(1..10, 5, 0)\n"
"    []\n"
"\n"
msgstr ""
"与えられたenumerableのサブセットのリストを返します。`start`番目の要素\n"
"まで削除され、そこから`count`個の要素のリストになります。\n"
"\n"
"もし`enumerable`の長さよりcountが大きいなら、可能な最大値が\n"
"帰って来ます。もし0なら、`[]`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.slice(1..100, 5, 10)\n"
"    [6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n"
"\n"
"    iex> Enum.slice(1..10, 5, 100)\n"
"    [6, 7, 8, 9, 10]\n"
"\n"
"    iex> Enum.slice(1..10, 5, 0)\n"
"    []\n"
"\n"

#. TRANSLATORS: def Enum.fetch!(enumerable, index)
#: lib/enum.ex:701
msgid ""
"Finds the element at the given `index` (zero-based).\n"
"\n"
"Raises `OutOfBoundsError` if the given `index` is outside the range of\n"
"the enumerable.\n"
"\n"
"Note this operation takes linear time. In order to access the element\n"
"at index `index`, it will need to traverse `index` previous elements.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.fetch!([2, 4, 6], 0)\n"
"    2\n"
"\n"
"    iex> Enum.fetch!([2, 4, 6], 2)\n"
"    6\n"
"\n"
"    iex> Enum.fetch!([2, 4, 6], 4)\n"
"    ** (Enum.OutOfBoundsError) out of bounds error\n"
"\n"
msgstr ""
"与えられた(0始まりの)`index`の要素を見付けます。\n"
"\n"
"与えられた`index`がenumerableの範囲外なら、`OutOfBoundsError`を上げます。\n"
"\n"
"この操作は線形時間がかかることに気を付けてください。\n"
"インデックス`index`の要素へアクセスするために、`index`個の以前の\n"
"要素を渡り歩く必要があります。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.fetch!([2, 4, 6], 0)\n"
"    2\n"
"\n"
"    iex> Enum.fetch!([2, 4, 6], 2)\n"
"    6\n"
"\n"
"    iex> Enum.fetch!([2, 4, 6], 4)\n"
"    ** (Enum.OutOfBoundsError) out of bounds error\n"
"\n"

#. TRANSLATORS: Elixir.Enumerable Summary
#: lib/enum.ex:2
msgid ""
"Enumerable protocol used by `Enum` and `Stream` modules.\n"
"\n"
"When you invoke a function in the `Enum` module, the first argument\n"
"is usually a collection that must implement this protocol.\n"
"For example, the expression:\n"
"\n"
"    Enum.map([1, 2, 3], &(&1 * 2))\n"
"\n"
"invokes `Enumerable.reduce/3` to perform the reducing\n"
"operation that builds a mapped list by calling the mapping function\n"
"`&(&1 * 2)` on every element in the collection and consuming the\n"
"element with an accumulated list.\n"
"\n"
"Internally, `Enum.map/2` is implemented as follows:\n"
"\n"
"    def map(enum, fun) do\n"
"      reducer = fn x, acc -> {:cont, [fun.(x)|acc]} end\n"
"      Enumerable.reduce(enum, {:cont, []}, reducer) |> elem(1) |> :lists."
"reverse()\n"
"    end\n"
"\n"
"Notice the user-supplied function is wrapped into a `t:reducer/0` function.\n"
"The `t:reducer/0` function must return a tagged tuple after each step,\n"
"as described in the `t:acc/0` type.\n"
"\n"
"The reason the accumulator requires a tagged tuple is to allow the\n"
"`t:reducer/0` function to communicate the end of enumeration to the "
"underlying\n"
"enumerable, allowing any open resources to be properly closed.\n"
"It also allows suspension of the enumeration, which is useful when\n"
"interleaving between many enumerables is required (as in zip).\n"
"\n"
"Finally, `Enumerable.reduce/3` will return another tagged tuple,\n"
"as represented by the `t:result/0` type.\n"
msgstr ""
"`Enum`と`Stream`モジュールで使われる、Enumerableプロトコルです。\n"
"\n"
"`Enum`モジュールの関数を起動したとき、最初の引数は通常はコレクションで、\n"
"このプロトコルを実装していなければなりません。\n"
"例えば、式\n"
"\n"
"    Enum.map([1, 2, 3], &(&1 * 2))\n"
"\n"
"は、コレクションのそれぞれのアイテムに関数`&(&1 * 2)`を呼び出し、その結\n"
"果を累積リストにコンシングすることにより、マップされたリストを構築する、\n"
"reduceオペレーションを実行するために、下層にある`Enumerable.reduce/3`を\n"
"起動します。\n"
"\n"
"内部的に、`Enum.map/2`は、以下のように実装されています:\n"
"\n"
"    def map(enum, fun) do\n"
"      reducer = fn x, acc -> {:cont, [fun.(x)|acc]} end\n"
"      Enumerable.reduce(enum, {:cont, []}, reducer) |> elem(1) |> :lists."
"reverse()\n"
"    end\n"
"\n"
"ユーザに与えられた関数は、`t:reducer/0`関数にラップされていることに、注意し\n"
"てください。`t:reducer/0`関数は、それぞれのステップの後で、`t:acc/0`タイプ"
"で\n"
"記述されるタグづけされたタプルを返さなければなりません。\n"
"\n"
"アキュムレータがタグづけされたタプルを要求する理由は、\n"
"`t:reducer/0`関数に、下層のenumerableと列挙の終わりを知らせ、\n"
"オープンした任意のリソースをクローズさせるることを許すためです。\n"
"列挙の中断も許します。それは、\n"
"多くのenumerable間のインターリーブが必要とされる時(zipの時のような)に\n"
"便利です。\n"
"\n"
"最後に、`Enumerable.reduce/3`は、`t:result/0`タイプにより表現される、\n"
"もう一つのタグづけされたタプルを返します。\n"

#. TRANSLATORS: def Enum.map_join(enumerable, joiner \\ "", mapper)
#: lib/enum.ex:1099
msgid ""
"Maps and joins the given enumerable in one pass.\n"
"\n"
"`joiner` can be either a binary or a list and the result will be of\n"
"the same type as `joiner`.\n"
"If `joiner` is not passed at all, it defaults to an empty binary.\n"
"\n"
"All items in the enumerable must be convertible to a binary,\n"
"otherwise an error is raised.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.map_join([1, 2, 3], &(&1 * 2))\n"
"    \"246\"\n"
"\n"
"    iex> Enum.map_join([1, 2, 3], \" = \", &(&1 * 2))\n"
"    \"2 = 4 = 6\"\n"
"\n"
msgstr ""
"一度のパスで、与えられたenumerableをmapしてjoinします。\n"
"`joiner`はバイナリでもリストでもよく、結果は\n"
"`joiner`と同じタイプになります。もし`joiner`が全く\n"
"パスされない場合、デフォルトは空のバイナリになります。\n"
"\n"
"enumerableの全てのアイテムはバイナリへ変換できなければ\n"
"なりません。さもないとエラーが上ります。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.map_join([1, 2, 3], &(&1 * 2))\n"
"    \"246\"\n"
"\n"
"    iex> Enum.map_join([1, 2, 3], \" = \", &(&1 * 2))\n"
"    \"2 = 4 = 6\"\n"
"\n"

#. TRANSLATORS: def Enumerable.reduce(enumerable, acc, fun)
#: lib/enum.ex:99
msgid ""
"Reduces the enumerable into an element.\n"
"\n"
"Most of the operations in `Enum` are implemented in terms of reduce.\n"
"This function should apply the given `t:reducer/0` function to each\n"
"item in the enumerable and proceed as expected by the returned\n"
"accumulator.\n"
"\n"
"As an example, here is the implementation of `reduce` for lists:\n"
"\n"
"    def reduce(_,     {:halt, acc}, _fun),   do: {:halted, acc}\n"
"    def reduce(list,  {:suspend, acc}, fun), do: {:suspended, acc, "
"&reduce(list, &1, fun)}\n"
"    def reduce([],    {:cont, acc}, _fun),   do: {:done, acc}\n"
"    def reduce([h|t], {:cont, acc}, fun),    do: reduce(t, fun.(h, acc), "
"fun)\n"
"\n"
msgstr ""
"enumerableを一つの値に簡約(reduce)します。\n"
"\n"
"`Enum`のほとんどのオペレーションはreduceで実装されています。この関数は\n"
"与えられた`t:reducer/0`関数をenumerableのそれぞれのアイテムに適用して、返\n"
"されたアキュムレータにより、繰返し累積しなくてはなりません。\n"
"\n"
"例として、リストの`reduce`の実装です:\n"
"\n"
"    def reduce(_,     {:halt, acc}, _fun),   do: {:halted, acc}\n"
"    def reduce(list,  {:suspend, acc}, fun), do: {:suspended, acc, "
"&reduce(list, &1, fun)}\n"
"    def reduce([],    {:cont, acc}, _fun),   do: {:done, acc}\n"
"    def reduce([h|t], {:cont, acc}, fun),    do: reduce(t, fun.(h, acc), "
"fun)\n"
"\n"

#. TRANSLATORS: def Enum.into(enumerable, collectable)
#: lib/enum.ex:951
msgid ""
"Inserts the given `enumerable` into a `collectable`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.into([1, 2], [0])\n"
"    [0, 1, 2]\n"
"\n"
"    iex> Enum.into([a: 1, b: 2], %{})\n"
"    %{a: 1, b: 2}\n"
"\n"
msgstr ""
"`collectable`に与えられた`enumerable`を挿入します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.into([1, 2], [0])\n"
"    [0, 1, 2]\n"
"\n"
"    iex> Enum.into([a: 1, b: 2], %{})\n"
"    %{a: 1, b: 2}\n"
"\n"

#. TRANSLATORS: def Enum.sort(enumerable, fun)
#: lib/enum.ex:1891
msgid ""
"Sorts the enumerable by the given function.\n"
"\n"
"This function uses the merge sort algorithm. The given function\n"
"must return `false` if the first argument is smaller than second one.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.sort([1, 2, 3], &(&1 > &2))\n"
"    [3, 2, 1]\n"
"\n"
"The sorting algorithm will be stable as long as the given function\n"
"returns `true` for values considered equal:\n"
"\n"
"    iex> Enum.sort [\"some\", \"kind\", \"of\", \"monster\"], "
"&(byte_size(&1) <= byte_size(&2))\n"
"    [\"of\", \"some\", \"kind\", \"monster\"]\n"
"\n"
"If the function does not return `true` for equal values, the sorting\n"
"is not stable and the order of equal terms may be shuffled.\n"
"For example:\n"
"\n"
"    iex> Enum.sort [\"some\", \"kind\", \"of\", \"monster\"], "
"&(byte_size(&1) < byte_size(&2))\n"
"    [\"of\", \"kind\", \"some\", \"monster\"]\n"
"\n"
msgstr ""
"与えられた関数によってenumerableをソートします。\n"
"\n"
"この関数はマージソートアルゴリズムを使います。与えられた関数はもし最初\n"
"の引数が右の物よりも小さいならば`false`を返さなければなりません。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.sort([1, 2, 3], &(&1 > &2))\n"
"    [3, 2, 1]\n"
"\n"
"\n"
"ソートアルゴリズムは値が等しいときに`true`を返す関数を与えた場合に限り\n"
"安定です:\n"
"\n"
"    iex> Enum.sort [\"some\", \"kind\", \"of\", \"monster\"], "
"&(byte_size(&1) <= byte_size(&2))\n"
"    [\"of\", \"some\", \"kind\", \"monster\"]\n"
"\n"
"もし関数が`true`を返さない場合、ソートは不安定となり、等しい要素の順番は\n"
"シャッフルされるでしょう:\n"
"\n"
"    iex> Enum.sort [\"some\", \"kind\", \"of\", \"monster\"], "
"&(byte_size(&1) < byte_size(&2))\n"
"    [\"of\", \"kind\", \"some\", \"monster\"]\n"
"\n"

#. TRANSLATORS: def Enum.each(enumerable, fun)
#: lib/enum.ex:593
msgid ""
"Invokes the given `fun` for each item in the enumerable.\n"
"\n"
"Returns `:ok`.\n"
"\n"
"## Examples\n"
"\n"
"    Enum.each([\"some\", \"example\"], fn(x) -> IO.puts x end)\n"
"    \"some\"\n"
"    \"example\"\n"
"    #=> :ok\n"
"\n"
msgstr ""
"enumerableのそれぞれのアイテムに対して、与えられた`fun`を起動します。\n"
"\n"
"`:ok`を返します。\n"
"\n"
"## 例\n"
"\n"
"    Enum.each([\"some\", \"example\"], fn(x) -> IO.puts x end)\n"
"    \"some\"\n"
"    \"example\"\n"
"    #=> :ok\n"
"\n"

#. TRANSLATORS: def Enum.partition(enumerable, fun)
#: lib/enum.ex:1415
msgid ""
"Partitions `enumerable` into two enumerables, where the first one\n"
"contains elements for which `fun` returns a truthy value, and the\n"
"second one – for which `fun` returns `false` or `nil`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.partition([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    {[2], [1, 3]}\n"
"\n"
msgstr ""
"`enumerable`を二つのenumerableに分割します。最初のものは、`fun`が真を\n"
"返す要素を含み、二つめは`fun`が`false`または`nil`を返すものです。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.partition([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    {[2], [1, 3]}\n"
"\n"

#. TRANSLATORS: def Enum.split_while(enumerable, fun)
#: lib/enum.ex:2022
msgid ""
"Splits enumerable in two at the position of the element for which\n"
"`fun` returns `false` for the first time.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.split_while([1, 2, 3, 4], fn(x) -> x < 3 end)\n"
"    {[1, 2], [3, 4]}\n"
"\n"
msgstr ""
"enumerableを`fun`が最初に`false`を返す位置で要素を二つに分割します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.split_while([1, 2, 3, 4], fn(x) -> x < 3 end)\n"
"    {[1, 2], [3, 4]}\n"
"\n"

#. TRANSLATORS: def Enum.drop(enumerable, n)
#: lib/enum.ex:531
msgid ""
"Drops the first `n` items from then enumerable.\n"
"\n"
"If a negative value `n` is given, the last `n` values will be dropped.\n"
"\n"
"The `enumerable` is enumerated once to retrieve the proper index and\n"
"the remaining calculation is performed from the end.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.drop([1, 2, 3], 2)\n"
"    [3]\n"
"\n"
"    iex> Enum.drop([1, 2, 3], 10)\n"
"    []\n"
"\n"
"    iex> Enum.drop([1, 2, 3], 0)\n"
"    [1, 2, 3]\n"
"\n"
"    iex> Enum.drop([1, 2, 3], -1)\n"
"    [1, 2]\n"
"\n"
msgstr ""
"最初の`n`個のアイテムを`enumerable`から削除します。\n"
"\n"
"もし負の`n`が与えられたら、最後の`n`個が削除されます。\n"
"`enumerable`は適切なインデックスを取り出すために\n"
"一度列挙され、残りの計算は終わりから実行されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.drop([1, 2, 3], 2)\n"
"    [3]\n"
"\n"
"    iex> Enum.drop([1, 2, 3], 10)\n"
"    []\n"
"\n"
"    iex> Enum.drop([1, 2, 3], 0)\n"
"    [1, 2, 3]\n"
"\n"
"    iex> Enum.drop([1, 2, 3], -1)\n"
"    [1, 2]\n"
"\n"

#. TRANSLATORS: def Enum.chunk_by(enumerable, fun)
#: lib/enum.ex:374
msgid ""
"Splits enumerable on every element for which `fun` returns a new\n"
"value.\n"
"\n"
"Returns a list of lists.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.chunk_by([1, 2, 2, 3, 4, 4, 6, 7, 7], &(rem(&1, 2) == 1))\n"
"    [[1], [2, 2], [3], [4, 4, 6], [7, 7]]\n"
"\n"
msgstr ""
"enumerableの各要素を`fun`が新しい値を返すごとに分割します。\n"
"\n"
"リストのリストを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.chunk_by([1, 2, 2, 3, 4, 4, 6, 7, 7], &(rem(&1, 2) == 1))\n"
"    [[1], [2, 2], [3], [4, 4, 6], [7, 7]]\n"
"\n"

#. TRANSLATORS: def Enum.min_max(enumerable)
#: lib/enum.ex:1331
msgid ""
"Returns a tuple with the smallest and the biggest elements in the\n"
"enumerable according to Erlang's term ordering.\n"
"\n"
"If more than one elements compare equal, the first one that was found\n"
"is picked.\n"
"\n"
"Raises `Enum.EmptyError` if `enumerable` is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.min_max([2, 3, 1])\n"
"    {1, 3}\n"
"\n"
msgstr ""
"Erlangのtermの順序に従って、最小と最大の値のタプルを返します。\n"
"\n"
"もし同じ要素が複数あったら、最初に見付かったものを採用します。\n"
"\n"
"もし`enumerable`が空なら、`EmptyError`を上げます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.minmax([2, 3, 1])\n"
"    {1, 3}\n"
"\n"

#. TRANSLATORS: def Enum.find(enumerable, default \\ nil, fun)
#: lib/enum.ex:770
msgid ""
"Returns the first item for which `fun` returns a truthy value.\n"
"If no such item is found, returns `default`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.find([2, 4, 6], fn(x) -> rem(x, 2) == 1 end)\n"
"    nil\n"
"\n"
"    iex> Enum.find([2, 4, 6], 0, fn(x) -> rem(x, 2) == 1 end)\n"
"    0\n"
"\n"
"    iex> Enum.find([2, 3, 4], fn(x) -> rem(x, 2) == 1 end)\n"
"    3\n"
"\n"
msgstr ""
"`fun`を実行して真を返す最初のアイテムを返します。もしアイテムが見つか\n"
"らないなら、`default`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.find([2, 4, 6], fn(x) -> rem(x, 2) == 1 end)\n"
"    nil\n"
"\n"
"    iex> Enum.find([2, 4, 6], 0, fn(x) -> rem(x, 2) == 1 end)\n"
"    0\n"
"\n"
"    iex> Enum.find([2, 3, 4], fn(x) -> rem(x, 2) == 1 end)\n"
"    3\n"
"\n"

#. TRANSLATORS: def Enum.zip(enumerable1, enumerable2)
#: lib/enum.ex:2348
msgid ""
"Zips corresponding elements from two enumerables into one list\n"
"of tuples.\n"
"\n"
"The zipping finishes as soon as any enumerable completes.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.zip([1, 2, 3], [:a, :b, :c])\n"
"    [{1, :a}, {2, :b}, {3, :c}]\n"
"\n"
"    iex> Enum.zip([1, 2, 3, 4, 5], [:a, :b, :c])\n"
"    [{1, :a}, {2, :b}, {3, :c}]\n"
"\n"
msgstr ""
"二つのenumerableから対応する要素を一つのタプルのリストにzipします。\n"
"\n"
"何れかの数え上げが完了するとzippingも終了します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.zip([1, 2, 3], [:a, :b, :c])\n"
"    [{1, :a}, {2, :b}, {3, :c}]\n"
"\n"
"    iex> Enum.zip([1, 2, 3, 4, 5], [:a, :b, :c])\n"
"    [{1, :a}, {2, :b}, {3, :c}]\n"
"\n"

#. TRANSLATORS: def Enum.find_value(enumerable, default \\ nil, fun)
#: lib/enum.ex:799
msgid ""
"Similar to `find/3`, but returns the value of the function\n"
"invocation instead of the element itself.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.find_value([2, 4, 6], fn(x) -> rem(x, 2) == 1 end)\n"
"    nil\n"
"\n"
"    iex> Enum.find_value([2, 3, 4], fn(x) -> rem(x, 2) == 1 end)\n"
"    true\n"
"\n"
"    iex> Enum.find_value([1, 2, 3], \"no bools!\", &is_boolean/1)\n"
"    \"no bools!\"\n"
"\n"
msgstr ""
"`find/3`と似ていますが、要素それ自身の替わりに、呼び出した関数の値を返\n"
"します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.find_value([2, 4, 6], fn(x) -> rem(x, 2) == 1 end)\n"
"    nil\n"
"\n"
"    iex> Enum.find_value([2, 3, 4], fn(x) -> rem(x, 2) == 1 end)\n"
"    true\n"
"\n"
"    iex> Enum.find_value([1, 2, 3], \"no bools!\", &is_boolean/1)\n"
"    \"no bools!\"\n"
"\n"

#. TRANSLATORS: def Enum.drop_while(enumerable, fun)
#: lib/enum.ex:573
msgid ""
"Drops items at the beginning of the enumerable while `fun` returns a\n"
"truthy value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.drop_while([1, 2, 3, 4, 5], fn(x) -> x < 3 end)\n"
"    [3, 4, 5]\n"
"\n"
msgstr ""
"enumerableの先頭から、`fun`が真の値を返すアイテムを削除します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.drop_while([1, 2, 3, 4, 5], fn(x) -> x < 3 end)\n"
"    [3, 4, 5]\n"
"\n"

#. TRANSLATORS: def Enum.concat(left, right)
#: lib/enum.ex:416
msgid ""
"Concatenates the enumerable on the right with the enumerable on the\n"
"left.\n"
"\n"
"This function produces the same result as the `Kernel.++/2` operator\n"
"for lists.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.concat(1..3, 4..6)\n"
"    [1, 2, 3, 4, 5, 6]\n"
"\n"
"    iex> Enum.concat([1, 2, 3], [4, 5, 6])\n"
"    [1, 2, 3, 4, 5, 6]\n"
"\n"
msgstr ""
"左辺のenumerableと右辺のenumerableを連結します。\n"
"\n"
"この関数はリストのための`Kernel.++/2`演算子と同じ結果を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.concat(1..3, 4..6)\n"
"    [1, 2, 3, 4, 5, 6]\n"
"\n"
"    iex> Enum.concat([1, 2, 3], [4, 5, 6])\n"
"    [1, 2, 3, 4, 5, 6]\n"
"\n"

#. TRANSLATORS: @type reducer
#: lib/enum.ex:55
msgid ""
"The reducer function.\n"
"\n"
"Should be called with the enumerable element and the\n"
"accumulator contents.\n"
"\n"
"Returns the accumulator for the next enumeration step.\n"
msgstr ""
"reducer関数\n"
"\n"
"enumerableの要素とアキュムレータコンテンツを伴って呼び出さ\n"
"れなければなりません。\n"
"\n"
"次の数え上げ(enumeration)ステップのためのアキュムレータを返します。\n"

#. TRANSLATORS: def Enum.take_random(enumerable, count)
#: lib/enum.ex:2156
msgid ""
"Takes random items from the enumerable.\n"
"\n"
"Notice this function will traverse the whole enumerable to\n"
"get the random sublist of `enumerable`. If you want the random\n"
"number between two integers, the best option is to use the\n"
"[`:random`](http://www.erlang.org/doc/man/random.html) module.\n"
"\n"
"See `random/1` for notes on implementation and random seed.\n"
"\n"
"## Examples\n"
"\n"
"    # Although not necessary, let's seed the random algorithm\n"
"    iex> :rand.seed(:exsplus, {1, 2, 3})\n"
"    iex> Enum.take_random(1..10, 2)\n"
"    [5, 8]\n"
"    iex> Enum.take_random(?a..?z, 5)\n"
"    'fhjni'\n"
"\n"
msgstr ""
"enumerableのランダムな要素を返します。\n"
"\n"
"`enumerable`のランダムなサブリストを取得するために、この関数は\n"
"enumerable全体をトラバースすることに気を付けてください。\n"
"もし二つの整数の間のランダムな数を望むなら、\n"
"[`:random`](http://www.erlang.org/doc/man/random.html) \n"
"モジュールを使うことがベストな選択です。\n"
"\n"
"実装とランダムシードについてのメモについては`random/1`を\n"
"参照してください。\n"
"\n"
"## 例\n"
"\n"
"    # Although not necessary, let's seed the random algorithm\n"
"    iex> :rand.seed(:exsplus, {1, 2, 3})\n"
"    iex> Enum.take_random(1..10, 2)\n"
"    [5, 8]\n"
"    iex> Enum.take_random(?a..?z, 5)\n"
"    'fhjni'\n"
"\n"

#. TRANSLATORS: def Enum.at(enumerable, index, default \\ nil)
#: lib/enum.ex:285
#, fuzzy
msgid ""
"Finds the element at the given `index` (zero-based).\n"
"\n"
"Returns `default` if `index` is out of bounds.\n"
"\n"
"A negative `index` can be passed, which means the `enumerable` is\n"
"enumerated once and the `index` is counted from the end (e.g.\n"
"`-1` finds the last element).\n"
"\n"
"Note this operation takes linear time. In order to access\n"
"the element at index `index`, it will need to traverse `index`\n"
"previous elements.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.at([2, 4, 6], 0)\n"
"    2\n"
"\n"
"    iex> Enum.at([2, 4, 6], 2)\n"
"    6\n"
"\n"
"    iex> Enum.at([2, 4, 6], 4)\n"
"    nil\n"
"\n"
"    iex> Enum.at([2, 4, 6], 4, :none)\n"
"    :none\n"
"\n"
msgstr ""
"与えられた(0始まりの) `index`の要素を見付けます。\n"
"\n"
"見付かれば、`{:ok, element}`を返し、さもなければ`:error`を返します。\n"
"\n"
"負の`index`が渡されると、`enumerable`は一度列挙され、\n"
"`index`は終わりから数えられる(即ち、`-1`は最後の要素を\n"
"取ってきます)ことを意味します。\n"
"\n"
"この操作は線形時間がかかることに気を付けてください。\n"
"インデックス `index`の要素へアクセスするために、`index`個の以前の\n"
"要素を渡り歩く必要があります。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.fetch([2, 4, 6], 0)\n"
"    {:ok, 2}\n"
"\n"
"    iex> Enum.fetch([2, 4, 6], 2)\n"
"    {:ok, 6}\n"
"\n"
"    iex> Enum.fetch([2, 4, 6], 4)\n"
"    :error\n"
"\n"

#. TRANSLATORS: def Enum.min(enumerable)
#: lib/enum.ex:1268
msgid ""
"Returns the smallest of the elements in the enumerable according\n"
"to Erlang's term ordering.\n"
"\n"
"If more than one elements compare equal, the first one that was found\n"
"is returned.\n"
"\n"
"Raises `Enum.EmptyError` if `enumerable` is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.min([1, 2, 3])\n"
"    1\n"
"\n"
msgstr ""
"与えられた関数により計算した値が最小となる要素を返します。\n"
"\n"
"もし複数の要素が最小となるなら、最初のに見付かった値を\n"
"返します。\n"
"\n"
"もしコレクションが空なら、`EmptyError`を上げます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.min([1, 2, 3])\n"
"    1\n"
"\n"

#. TRANSLATORS: Elixir.Enum Summary
#: lib/enum.ex:152
#, fuzzy
msgid ""
"Provides a set of algorithms that enumerate over enumerables according\n"
"to the `Enumerable` protocol.\n"
"\n"
"    iex> Enum.map([1, 2, 3], fn(x) -> x * 2 end)\n"
"    [2, 4, 6]\n"
"\n"
"Some particular types, like maps, yield a specific format on enumeration.\n"
"For example, the argument is always a `{key, value}` tuple for maps:\n"
"\n"
"    iex> map = %{a: 1, b: 2}\n"
"    iex> Enum.map(map, fn {k, v} -> {k, v * 2} end)\n"
"    [a: 2, b: 4]\n"
"\n"
"Note that the functions in the `Enum` module are eager: they always\n"
"start the enumeration of the given enumerable. The `Stream` module\n"
"allows lazy enumeration of enumerables and provides infinite streams.\n"
"\n"
"Since the majority of the functions in `Enum` enumerate the whole\n"
"enumerable and return a list as result, infinite streams need to\n"
"be carefully used with such functions, as they can potentially run\n"
"forever. For example:\n"
"\n"
"    Enum.each Stream.cycle([1, 2, 3]), &IO.puts(&1)\n"
"\n"
msgstr ""
"`Enumerable`プロトコルに従った、enumerableを列挙するアルゴリズムのセッ\n"
"トを提供します:\n"
"\n"
"    iex> Enum.map([1, 2, 3], fn(x) -> x * 2 end)\n"
"    [2, 4, 6]\n"
"\n"
"辞書のような、若干の特定のタイプはenumerableに特定のフォーマットを与えま"
"す。\n"
"dictでは、引数は常に`{key, value}`タプルです:\n"
"\n"
"    iex> dict = %{a: 1, b: 2}\n"
"    iex> Enum.map(dict, fn {k, v} -> {k, v * 2} end)\n"
"    [a: 2, b: 4]\n"
"\n"
"`Enum`モジュールはeagerであることに注意してください。\n"
"それらは与えられたコレクションの列挙を常に始めます。\n"
"`Stream`モジュールはコレクションの遅延列挙と無限のストリームを提供します。\n"
"\n"
"`Enum`の大部分の関数が、全部のコレクションを列挙して、\n"
"結果としてリストを返すため、無限のストリームは\n"
"それらの関数で潜在的に永遠に動きつづける可能性があり、\n"
"慎重に使われる必要があります。例えば:\n"
"\n"
"    Enum.each Stream.cycle([1, 2, 3]), &IO.puts(&1)\n"
"\n"

#. TRANSLATORS: def Enum.dedup(enumerable)
#: lib/enum.ex:489
msgid ""
"Enumerates the `enumerable`, returning a list where all consecutive\n"
"duplicated elements are collapsed to a single element.\n"
"\n"
"Elements are compared using `===`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.dedup([1, 2, 3, 3, 2, 1])\n"
"    [1, 2, 3, 2, 1]\n"
"\n"
"    iex> Enum.dedup([1, 1, 2, 2.0, :three, :\"three\"])\n"
"    [1, 2, 2.0, :three]\n"
"\n"
msgstr ""
"`enumerable`を数え上げ、連続して重複する要素を一つの要素に\n"
"したリストを返します。\n"
"\n"
"要素は`===`を使って比較されます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.dedup([1, 2, 3, 3, 2, 1])\n"
"    [1, 2, 3, 2, 1]\n"
"\n"

#. TRANSLATORS: def Enum.sort_by(enumerable, mapper, sorter \\ &<=/2)
#: lib/enum.ex:1926
msgid ""
"Sorts the mapped results of the enumerable according to the `sorter`\n"
"function.\n"
"\n"
"This function maps each element of the enumerable using the `mapper`\n"
"function.  The enumerable is then sorted by the mapped elements\n"
"using the `sorter` function, which defaults to `Kernel.<=/2`\n"
"\n"
"`sort_by/3` differs from `sort/2` in that it only calculates the\n"
"comparison value for each element in the enumerable once instead of\n"
"once for each element in each comparison.\n"
"If the same function is being called on both element, it's also more\n"
"compact to use `sort_by/3`.\n"
"\n"
"This technique is also known as a\n"
"_[Schwartzian Transform](https://en.wikipedia.org/wiki/"
"Schwartzian_transform)_,\n"
"or the _Lisp decorate-sort-undecorate idiom_ as the `mapper`\n"
"is decorating the original `enumerable`; then `sorter` is sorting the\n"
"decorations; and finally the enumerable is being undecorated so only\n"
"the original elements remain, but now in sorted order.\n"
"\n"
"## Examples\n"
"\n"
"Using the default `sorter` of `<=/2`:\n"
"\n"
"    iex> Enum.sort_by [\"some\", \"kind\", \"of\", \"monster\"], "
"&byte_size/1\n"
"    [\"of\", \"some\", \"kind\", \"monster\"]\n"
"\n"
"Using a custom `sorter` to override the order:\n"
"\n"
"    iex> Enum.sort_by [\"some\", \"kind\", \"of\", \"monster\"], "
"&byte_size/1, &>=/2\n"
"    [\"monster\", \"some\", \"kind\", \"of\"]\n"
"\n"
msgstr ""
"`sorter` 関数によって enumerable をmapperで処理された結果でソートします。\n"
"\n"
"この関数は、`mapper`関数を使ってenumerableのそれぞれの要素をマップし\n"
"ます。それからenumerableは、デフォルトが`<=/2`である`sorter`関数を使っ\n"
"て、マップされた要素でソートされます。\n"
"\n"
"各々の比較において要素ごとに一度だけ比較計算をするという点で\n"
"`sort_by/3`は`sort/2`と違います。もし同じ関数が両方の要素で呼ばれている\n"
"ならば`sort_by/3`を使うことでよりコンパクトになります。\n"
"\n"
"この技術は [Schwartzian\n"
"Transform](https://en.wikipedia.org/wiki/Schwartzian_transform)\n"
"として知られています。あるいは、Lispの\n"
"_decorate-sort-undecorate idiom_ として知られています。\n"
"`mapper`がオリジナルの`enumerable`のデコレーション、それから\n"
"`sorter`はソートのデコレレーションとして、そして最後にソート\n"
"された順番以外は `enumerable` はデコレーションされずにオリジ\n"
"ナルの要素のままです。\n"
"\n"
"## 例\n"
"\n"
"デフォルトの `sorter` である `<=/2` を使います: \n"
"\n"
"    iex> Enum.sort_by [\"some\", \"kind\", \"of\", \"monster\"], "
"&byte_size/1\n"
"    [\"of\", \"some\", \"kind\", \"monster\"]\n"
"\n"
"カスタム`sorter`として上書きます: \n"
"\n"
"    iex> Enum.sort_by [\"some\", \"kind\", \"of\", \"monster\"], "
"&byte_size/1, &>=/2\n"
"    [\"monster\", \"some\", \"kind\", \"of\"]\n"
"\n"

#. TRANSLATORS: def Enum.flat_map(enumerable, fun)
#: lib/enum.ex:859
msgid ""
"Returns a new enumerable appending the result of invoking `fun` on\n"
"each corresponding item of `enumerable`.\n"
"\n"
"The given function must return an enumerable.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.flat_map([:a, :b, :c], fn(x) -> [x, x] end)\n"
"    [:a, :a, :b, :b, :c, :c]\n"
"\n"
"    iex> Enum.flat_map([{1, 3}, {4, 6}], fn({x, y}) -> x..y end)\n"
"    [1, 2, 3, 4, 5, 6]\n"
"\n"
msgstr ""
"`enumerable`のそれぞれのアイテムに、`fun`を実行した結果を\n"
"追加した、新しいenumerableを返します。\n"
"\n"
"与えられた関数はenumerableを返さなければなりません。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.flat_map([:a, :b, :c], fn(x) -> [x, x] end)\n"
"    [:a, :a, :b, :b, :c, :c]\n"
"\n"
"    iex> Enum.flat_map([{1, 3}, {4, 6}], fn({x, y}) -> x..y end)\n"
"    [1, 2, 3, 4, 5, 6]\n"
"\n"

#. TRANSLATORS: def Enum.with_index(enumerable, offset \\ 0)
#: lib/enum.ex:2375
msgid ""
"Returns the enumerable with each element wrapped in a tuple\n"
"alongside its index.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.with_index([:a, :b, :c])\n"
"    [a: 0, b: 1, c: 2]\n"
"\n"
"    iex> Enum.with_index([:a, :b, :c], 3)\n"
"    [a: 3, b: 4, c: 5]\n"
"\n"
msgstr ""
"それぞれの要素をそのインデックスと一緒にタプルで包んだ\n"
"enumerableを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.with_index [1, 2, 3]\n"
"    [{1, 0},{2, 1},{3, 2}]\n"
"\n"

#. TRANSLATORS: def Enum.min_max_by(enumerable, fun)
#: lib/enum.ex:1362
msgid ""
"Returns a tuple with the smallest and the biggest elements in the\n"
"enumerable as calculated by the given function.\n"
"\n"
"If more than one elements compare equal, the first one that was found\n"
"is picked.\n"
"\n"
"Raises `Enum.EmptyError` if `enumerable` is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.min_max_by([\"aaa\", \"bb\", \"c\"], fn(x) -> String.length(x) "
"end)\n"
"    {\"c\", \"aaa\"}\n"
"\n"
msgstr ""
"enumerableについて、与えられた関数により計算した値が\n"
"最小と最大となる要素のタプルを返します。\n"
"\n"
"同じ値が複数の場合、最初に見付かったものが使われます。\n"
"\n"
"もし`enumerable`が空なら、`EmptyError`を上げます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.min_max_by([\"aaa\", \"bb\", \"c\"], fn(x) -> String.length(x) "
"end)\n"
"    {\"c\", \"aaa\"}\n"
"\n"

#. TRANSLATORS: def Enum.dedup_by(enumerable, fun)
#: lib/enum.ex:509
msgid ""
"Enumerates the `enumerable`, returning a list where all consecutive\n"
"duplicated elements are collapsed to a single element.\n"
"\n"
"The function `fun` maps every element to a term which is used to\n"
"determine if two elements are duplicates.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.dedup_by([{1, :a}, {2, :b}, {2, :c}, {1, :a}], fn {x, _} -> x "
"end)\n"
"    [{1, :a}, {2, :b}, {1, :a}]\n"
"\n"
"    iex> Enum.dedup_by([5, 1, 2, 3, 2, 1], fn x -> x > 2 end)\n"
"    [5, 1, 3, 2]\n"
"\n"
msgstr ""
"`enumerable`を数え上げ、連続して重複する要素を一つの要素に\n"
"したリストを返します。\n"
"\n"
"関数`fun`はそれぞれの要素を二つの要素が重複しているか\n"
"どうかを決定するために使われます\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.dedup_by([{1, :x}, {2, :y}, {2, :z}, {1, :x}], fn {x, _} -> x "
"end)\n"
"    [{1, :x}, {2, :y}, {1, :x}]\n"
"\n"
"    iex> Enum.dedup_by([5, 1, 2, 3, 2, 1], fn x -> x > 2 end)\n"
"    [5, 1, 3, 2]\n"
"\n"

#. TRANSLATORS: def Enum.reduce(enumerable, fun)
#: lib/enum.ex:1510
msgid ""
"Invokes `fun` for each element in the `enumerable`, passing that\n"
"element and the accumulator as arguments. `fun`'s return value\n"
"is stored in the accumulator.\n"
"\n"
"The first element of the enumerable is used as the initial value of\n"
"the accumulator.\n"
"If you wish to use another value for the accumulator, use\n"
"`Enumerable.reduce/3`.\n"
"This function won't call the specified function for enumerables that\n"
"are 1-element long.\n"
"\n"
"Returns the accumulator.\n"
"\n"
"Note that since the first element of the enumerable is used as the\n"
"initial value of the accumulator, `fun` will only be executed `n - 1`\n"
"times where `n` is the length of the enumerable.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reduce([1, 2, 3, 4], fn(x, acc) -> x * acc end)\n"
"    24\n"
"\n"
msgstr ""
"`enumerable`のそれぞれの要素について、その要素とアキュムレータを引数とし\n"
"て、`fun`を起動します。`fun`の戻り値は、`acc`に保存されます。\n"
"\n"
"`enumerable`の最初の要素は、`acc`の初期値として使われます。\n"
"もし`acc`の初期値として他の値を使いたい場合、`Enumerable.reduce/3`を\n"
"使ってください。この関数は数え上げのために指定された関数を要素数-1回数\n"
"呼出します\n"
"。\n"
"アキュムレータを返します。\n"
"\n"
"最初の要素がアキュムレータの初期値として使われるので、\n"
"enumerableの要素数が`n`なら`fun`は`n - 1`回だけ呼び出されることに\n"
"注意してください。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reduce([1, 2, 3, 4], fn(x, acc) -> x * acc end)\n"
"    24\n"
"\n"

#. TRANSLATORS: def Enum.filter(enumerable, fun)
#: lib/enum.ex:730
msgid ""
"Filters the enumerable, i.e. returns only those elements\n"
"for which `fun` returns a truthy value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.filter([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    [2]\n"
"\n"
msgstr ""
"enumerableをフィルタします。即ち、`fun`が真の値を返す\n"
"要素のみを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.filter([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    [2]\n"
"\n"

#. TRANSLATORS: def Enum.reject(enumerable, fun)
#: lib/enum.ex:1580
msgid ""
"Returns elements of `enumerable` for which the function `fun` returns\n"
"`false` or `nil`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reject([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    [1, 3]\n"
"\n"
msgstr ""
"`fun`が`false`または`nil`となる`enumerable`の要素を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.reject([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    [1, 3]\n"
"\n"

#. TRANSLATORS: def Enum.uniq_by(enumerable, fun)
#: lib/enum.ex:2292
msgid ""
"Enumerates the `enumerable`, by removing the elements for which\n"
"function `fun` returned duplicate items.\n"
"\n"
"The function `fun` maps every element to a term which is used to\n"
"determine if two elements are duplicates.\n"
"## Example\n"
"\n"
"    iex> Enum.uniq_by([{1, :x}, {2, :y}, {1, :z}], fn {x, _} -> x end)\n"
"    [{1, :x}, {2, :y}]\n"
"\n"
"    Enum.uniq_by([{a: {tea: 2}}, {b: {tea: 2}}, {c, {coffe: 1}}], fn {x, _} -"
"> x end)\n"
"    [a: [tea: 2], b: [tea: 2]]\n"
"\n"
msgstr ""
"`enumerable`を数え上げ、連続して重複する要素を一つの要素に\n"
"したリストを返します。\n"
"\n"
"関数`fun`はそれぞれの要素を二つの要素が重複しているか\n"
"どうかを決定するために使われます\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.dedup_by([{1, :x}, {2, :y}, {2, :z}, {1, :x}], fn {x, _} -> x "
"end)\n"
"    [{1, :x}, {2, :y}, {1, :x}]\n"
"\n"
"    iex> Enum.dedup_by([5, 1, 2, 3, 2, 1], fn x -> x > 2 end)\n"
"    [5, 1, 3, 2]\n"
"\n"

#. TRANSLATORS: def Enum.to_list(enumerable)
#: lib/enum.ex:2253
msgid ""
"Converts `enumerable` to a list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.to_list(1..3)\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
"`enumerable`をリストに変換します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.to_list(1 .. 3)\n"
"    [1, 2, 3]\n"
"\n"

#. TRANSLATORS: def Enum.slice(enumerable, range)
#: lib/enum.ex:1815
msgid ""
"Returns a subset list of the given enumerable. Drops elements\n"
"until element position `range.first`, then takes elements until\n"
"element position `range.last` (inclusive).\n"
"\n"
"Positions are calculated by adding the number of items in the\n"
"enumerable to negative positions (e.g. position -3 in an\n"
"enumerable with count 5 becomes position 2).\n"
"\n"
"The first position (after adding count to negative positions) must be\n"
"smaller or equal to the last position.\n"
"\n"
"If the start of the range is not a valid offset for the given\n"
"enumerable or if the range is in reverse order, returns `[]`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.slice(1..100, 5..10)\n"
"    [6, 7, 8, 9, 10, 11]\n"
"\n"
"    iex> Enum.slice(1..10, 5..20)\n"
"    [6, 7, 8, 9, 10]\n"
"\n"
"    iex> Enum.slice(1..10, 11..20)\n"
"    []\n"
"\n"
"    iex> Enum.slice(1..10, 6..5)\n"
"    []\n"
"\n"
msgstr ""
"与えられたenumerableのサブセットのリストを返します。`range.first`番目\n"
"の要素まで削除され、そこから`range.last`番目の要素(要素自身を含みます)\n"
"のリストになります。\n"
"\n"
"負の位置については、位置はコレクション中のアイテムの数を加えることによっ\n"
"て計算されます(だから、カウント5によるenumerableの位置-3は位置2になり\n"
"ます)。\n"
"\n"
"最初の位置(カウントに負の位置を加えた後)は最後の位置と同じか小くなけれ\n"
"ばなりません。\n"
"\n"
"もし範囲の始まりが与えられたenumerableの正しいオフセットで\n"
"ない、あるいは、範囲が逆順であるなら、`[]`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.slice(1..100, 5..10)\n"
"    [6, 7, 8, 9, 10, 11]\n"
"\n"
"    iex> Enum.slice(1..10, 5..20)\n"
"    [6, 7, 8, 9, 10]\n"
"\n"
"    iex> Enum.slice(1..10, 11..20)\n"
"    []\n"
"\n"
"    iex> Enum.slice(1..10, 6..5)\n"
"    []\n"
"\n"

#. TRANSLATORS: def Enum.map_reduce(enumerable, acc, fun)
#: lib/enum.ex:1134
#, fuzzy
msgid ""
"Invokes the given function to each item in the enumerable to reduce\n"
"it to a single element, while keeping an accumulator.\n"
"\n"
"Returns a tuple where the first element is the mapped enumerable and\n"
"the second one is the final accumulator.\n"
"\n"
"The function, `fun`, receives two arguments: the first one is the\n"
"element, and the second one is the accumulator. `fun` must return a\n"
"a tuple with two elements in the form of `{result, accumulator}`.\n"
"\n"
"For maps, the first tuple element must be a `{key, value}` tuple.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.map_reduce([1, 2, 3], 0, fn(x, acc) -> {x * 2, x + acc} end)\n"
"    {[2, 4, 6], 6}\n"
"\n"
msgstr ""
"アキュムレータを保持しながら、enumerableのそれぞれのアイテムで与えら\n"
"れた`fun`を起動します。\n"
"\n"
"最初の要素がmapされたenumerableで二つめは最終的なアキュムレータである\n"
"タプルを返します。\n"
"\n"
"`fun`関数は二つの引数を取ります: 最初のは要素で、二つめはアキュムレータ\n"
"です。`fun`は`{result, accumulator}`の形の2要素のタプルを返さなけ\n"
"ればなりません。\n"
"\n"
"dictでは、最初のタプルの要素は`{key, value}`タプルでなくては\n"
"なりません。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.map_reduce([1, 2, 3], 0, fn(x, acc) -> {x * 2, x + acc} end)\n"
"    {[2, 4, 6], 6}\n"
"\n"

#~ msgid ""
#~ "Finds the element at the given `index` (zero-based).\n"
#~ "\n"
#~ "Returns `default` if `index` is out of bounds.\n"
#~ "\n"
#~ "Note this operation takes linear time. In order to access\n"
#~ "the element at index `index`, it will need to traverse `index`\n"
#~ "previous elements.\n"
#~ "\n"
#~ "## Examples\n"
#~ "\n"
#~ "    iex> Enum.at([2, 4, 6], 0)\n"
#~ "    2\n"
#~ "\n"
#~ "    iex> Enum.at([2, 4, 6], 2)\n"
#~ "    6\n"
#~ "\n"
#~ "    iex> Enum.at([2, 4, 6], 4)\n"
#~ "    nil\n"
#~ "\n"
#~ "    iex> Enum.at([2, 4, 6], 4, :none)\n"
#~ "    :none\n"
#~ "\n"
#~ msgstr ""
#~ "与えられた(0始まりの) `index`の要素を見付けます。\n"
#~ "\n"
#~ "`index`が範囲外なら、`default`を返します。\n"
#~ "\n"
#~ "この操作は線形時間がかかることに気を付けてください。\n"
#~ "インデックス `index` の要素へアクセスするために、`index`個の以前の\n"
#~ "要素を渡り歩く必要があります。\n"
#~ "\n"
#~ "## 例\n"
#~ "\n"
#~ "    iex> Enum.at([2, 4, 6], 0)\n"
#~ "    2\n"
#~ "\n"
#~ "    iex> Enum.at([2, 4, 6], 2)\n"
#~ "    6\n"
#~ "\n"
#~ "    iex> Enum.at([2, 4, 6], 4)\n"
#~ "    nil\n"
#~ "\n"
#~ "    iex> Enum.at([2, 4, 6], 4, :none)\n"
#~ "    :none\n"
#~ "\n"

#~ msgid ""
#~ "Returns the minimum value.\n"
#~ "Raises `EmptyError` if the collection is empty.\n"
#~ "\n"
#~ "## Examples\n"
#~ "\n"
#~ "    iex> Enum.min([1, 2, 3])\n"
#~ "    1\n"
#~ "\n"
#~ msgstr ""
#~ "最小の値を返します。\n"
#~ "もしコレクションが空なら、`EmptyError`を上げます。\n"
#~ "\n"
#~ "## 例\n"
#~ "\n"
#~ "    iex> Enum.min([1, 2, 3])\n"
#~ "    1\n"
#~ "\n"

#~ msgid ""
#~ "Returns the maximum value.\n"
#~ "Raises `EmptyError` if the collection is empty.\n"
#~ "\n"
#~ "## Examples\n"
#~ "\n"
#~ "    iex> Enum.max([1, 2, 3])\n"
#~ "    3\n"
#~ "\n"
#~ msgstr ""
#~ "最大の値を返します。\n"
#~ "もしコレクションが空なら、`EmptyError`を上げます。\n"
#~ "\n"
#~ "## 例\n"
#~ "\n"
#~ "    iex> Enum.max([1, 2, 3])\n"
#~ "    3\n"
#~ "\n"

#~ msgid ""
#~ "Returns a list of collection elements shuffled.\n"
#~ "\n"
#~ "Notice that you need to explicitly call `:random.seed/1` and\n"
#~ "set a seed value for the random algorithm. Otherwise, the\n"
#~ "default seed will be set which will always return the same\n"
#~ "result. For example, one could do the following to set a seed\n"
#~ "dynamically:\n"
#~ "\n"
#~ "    :random.seed(:os.timestamp)\n"
#~ "\n"
#~ "## Examples\n"
#~ "\n"
#~ "    iex> Enum.shuffle([1, 2, 3])\n"
#~ "    [3, 2, 1]\n"
#~ "    iex> Enum.shuffle([1, 2, 3])\n"
#~ "    [3, 1, 2]\n"
#~ "\n"
#~ msgstr ""
#~ "コレクションの要素をシャッフルしたリストを返します。\n"
#~ "\n"
#~ "明示的に`:random.seed/1`を呼び出して、乱数アルゴリズムのシード値を設定\n"
#~ "する必要があることに注意してください。さもないと、常に同じデフォルトシー\n"
#~ "ドが設定され、同じ結果が帰って来ます。例えば、以下の様にして一度呼び出\n"
#~ "すと、シードを動的に設定することができます:\n"
#~ "\n"
#~ "    :random.seed(:os.timestamp)\n"
#~ "\n"
#~ "## 例\n"
#~ "\n"
#~ "    iex> Enum.shuffle([1, 2, 3])\n"
#~ "    [3, 2, 1]\n"
#~ "    iex> Enum.shuffle([1, 2, 3])\n"
#~ "    [3, 1, 2]\n"
#~ "\n"

#~ msgid ""
#~ "Enumerates the collection, removing all duplicated elements.\n"
#~ "\n"
#~ "## Example\n"
#~ "\n"
#~ "    iex> Enum.uniq_by([{1, :x}, {2, :y}, {1, :z}], fn {x, _} -> x end)\n"
#~ "    [{1, :x}, {2, :y}]\n"
#~ "\n"
#~ msgstr ""
#~ "重複するアイテムを削除しながら、コレクションを列挙します。\n"
#~ "\n"
#~ "## Example\n"
#~ "\n"
#~ "    iex> Enum.uniq_by([{1, :x}, {2, :y}, {1, :z}], fn {x, _} -> x end)\n"
#~ "    [{1, :x}, {2, :y}]\n"
#~ "\n"
