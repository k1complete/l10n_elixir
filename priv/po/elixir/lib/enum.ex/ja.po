msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2015-09-12 17:04+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: def Enum.chunk_by(collection, fun)
#: lib/enum.ex:356
msgid ""
"Splits `collection` on every element for which `fun` returns a new value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.chunk_by([1, 2, 2, 3, 4, 4, 6, 7, 7], &(rem(&1, 2) == 1))\n"
"    [[1], [2, 2], [3], [4, 4, 6], [7, 7]]\n"
"\n"
msgstr ""
"`collection`の各要素を`fun`が新しい値を返すごとに分割します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.chunk_by([1, 2, 2, 3, 4, 4, 6, 7, 7], &(rem(&1, 2) == 1))\n"
"    [[1], [2, 2], [3], [4, 4, 6], [7, 7]]\n"
"\n"

#. TRANSLATORS: def Enum.find_value(collection, ifnone \\ nil, fun)
#: lib/enum.ex:758
msgid ""
"Similar to `find/3`, but returns the value of the function\n"
"invocation instead of the element itself.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.find_value([2, 4, 6], fn(x) -> rem(x, 2) == 1 end)\n"
"    nil\n"
"\n"
"    iex> Enum.find_value([2, 3, 4], fn(x) -> rem(x, 2) == 1 end)\n"
"    true\n"
"\n"
"    iex> Enum.find_value([1, 2, 3], \"no bools!\", &is_boolean/1)\n"
"    \"no bools!\"\n"
"\n"
msgstr ""
"`find/3`と似ていますが、要素それ自身の替わりに、呼び出した関数の値を返\n"
"します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.find_value([2, 4, 6], fn(x) -> rem(x, 2) == 1 end)\n"
"    nil\n"
"\n"
"    iex> Enum.find_value([2, 3, 4], fn(x) -> rem(x, 2) == 1 end)\n"
"    true\n"
"\n"
"    iex> Enum.find_value([1, 2, 3], \"no bools!\", &is_boolean/1)\n"
"    \"no bools!\"\n"
"\n"

#. TRANSLATORS: def Enum.find_index(collection, fun)
#: lib/enum.ex:788
msgid ""
"Similar to `find/3`, but returns the index (zero-based)\n"
"of the element instead of the element itself.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.find_index([2, 4, 6], fn(x) -> rem(x, 2) == 1 end)\n"
"    nil\n"
"\n"
"    iex> Enum.find_index([2, 3, 4], fn(x) -> rem(x, 2) == 1 end)\n"
"    1\n"
"\n"
msgstr ""
"`find/3`と似ていますが、要素自身の替わりに要素のインデックス(ゼロ始ま\n"
"り)を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.find_index([2, 4, 6], fn(x) -> rem(x, 2) == 1 end)\n"
"    nil\n"
"\n"
"    iex> Enum.find_index([2, 3, 4], fn(x) -> rem(x, 2) == 1 end)\n"
"    1\n"
"\n"

#. TRANSLATORS: @type result
#: lib/enum.ex:0
msgid ""
"The result of the reduce operation.\n"
"\n"
"It may be *done* when the enumeration is finished by reaching\n"
"its end, or *halted*/*suspended* when the enumeration was halted\n"
"or suspended by the reducer function.\n"
"\n"
"In case a reducer function returns the `:suspend` accumulator, the\n"
"`:suspended` tuple must be explicitly handled by the caller and\n"
"never leak. In practice, this means regular enumeration functions\n"
"just need to be concerned about `:done` and `:halted` results.\n"
"\n"
"Furthermore, a `:suspend` call must always be followed by another call,\n"
"eventually halting or continuing until the end.\n"
msgstr ""
"reduceオペレーションの結果です。\n"
"\n"
"終りに到達することで数え上げ(enumeration)が終了したときに\n"
"*done* になり、reducer関数により数え上げ(enumeration)が中止\n"
"(halted)や中断(suspend)された時に *halted*/*suspended* になり\n"
"ます。\n"
"\n"
"reducer関数が`:suspend`アキュムレータを返した場合、呼出し側に\n"
"より、`:suspended`タプルは漏れ無く明示的にハンドルされなけれ\n"
"ばなりません。実際には、これは標準の数え上げ(enumeration)関数\n"
"は`:done`と`:halted`についてだけ心配する必要があることを意味\n"
"します。\n"
"\n"
"さらに、`:suspend`呼出しは、常にもう一つの呼出しがつづき、結\n"
"局中止(halting)するか、終りまで続け(continuing)ます。\n"

#. TRANSLATORS: @type reducer
#: lib/enum.ex:0
msgid ""
"The reducer function.\n"
"\n"
"Should be called with the collection element and the\n"
"accumulator contents. Returns the accumulator for\n"
"the next enumeration step.\n"
msgstr ""
"reducer関数\n"
"\n"
"コレクションの要素とアキュムレータコンテンツを伴って呼び出さ\n"
"れなければなりません。次の数え上げ(enumeration)ステップのための\n"
"アキュムレータを返します。\n"

#. TRANSLATORS: @type acc
#: lib/enum.ex:0
msgid ""
"The accumulator value for each step.\n"
"\n"
"It must be a tagged tuple with one of the following \"tags\":\n"
"\n"
"  * `:cont`    - the enumeration should continue\n"
"  * `:halt`    - the enumeration should halt immediately\n"
"  * `:suspend` - the enumeration should be suspended immediately\n"
"\n"
"Depending on the accumulator value, the result returned by\n"
"`Enumerable.reduce/3` will change. Please check the `result`\n"
"type docs for more information.\n"
"\n"
"In case a reducer function returns a `:suspend` accumulator,\n"
"it must be explicitly handled by the caller and never leak.\n"
msgstr ""
"それぞれのステップのアキュムレータの値。\n"
"\n"
"以下の\"タグ\"の何れかにタグ付けられたタプルでなければなりません:\n"
"\n"
"  * `:cont`    - 数え上げ(enumeration)を続けなければならない\n"
"  * `:halt`    - 数え上げ(enumeration)は直ちに中止されなければならない\n"
"  * `:suspend` - 数え上げ(enumeration)は直ちに中断されなければならない\n"
"\n"
"アキュムレータ値に依存して`Enumerable.reduce/3`の戻値は変わり\n"
"ます。詳細は `result` type docをチェックしてください。\n"
"\n"
"reducer関数が`:suspend`アキュムレータを返す場合、呼出し側で明\n"
"示的にハンドルされなければならず、決して漏れてはなりません。\n"

#. TRANSLATORS: def Enum.zip(collection1, collection2)
#: lib/enum.ex:2198
msgid ""
"Zips corresponding elements from two collections into one list\n"
"of tuples.\n"
"\n"
"The zipping finishes as soon as any enumerable completes.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.zip([1, 2, 3], [:a, :b, :c])\n"
"    [{1, :a}, {2, :b}, {3, :c}]\n"
"\n"
"    iex> Enum.zip([1, 2, 3, 4, 5], [:a, :b, :c])\n"
"    [{1, :a}, {2, :b}, {3, :c}]\n"
"\n"
msgstr ""
"二つのコレクションから対応する要素を一つのタプルのリストにzipします。\n"
"\n"
"何れかの数え上げが完了するとzippingも終了します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.zip([1, 2, 3], [:a, :b, :c])\n"
"    [{1, :a}, {2, :b}, {3, :c}]\n"
"\n"
"    iex> Enum.zip([1, 2, 3, 4, 5], [:a, :b, :c])\n"
"    [{1, :a}, {2, :b}, {3, :c}]\n"
"\n"

#. TRANSLATORS: def Enum.chunk(collection, n)
#: lib/enum.ex:307
msgid "Shortcut to `chunk(collection, n, n)`.\n"
msgstr "`chunk(collection, n, n)`へのショートカットです。\n"

#. TRANSLATORS: def Enum.group_by(collection, dict \\ %{}, fun)
#: lib/enum.ex:1351
msgid ""
"Splits `collection` into groups based on `fun`.\n"
"\n"
"The result is a dict (by default a map) where each key is\n"
"a group and each value is a list of elements from `collection`\n"
"for which `fun` returned that group. Ordering is not necessarily\n"
"preserved.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.group_by(~w{ant buffalo cat dingo}, &String.length/1)\n"
"    %{3 => [\"cat\", \"ant\"], 7 => [\"buffalo\"], 5 => [\"dingo\"]}\n"
"\n"
msgstr ""
"`collection`を分割して`fun`に基いてグループ化します。\n"
"\n"
"結果は、キーがグループで、値が`fun`が返したグループによる、\n"
"`collection`からの要素のリストとなるdict(デフォルトではマップ)です。\n"
"順序は保存されません。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.group_by(~w{ant buffalo cat dingo}, &String.length/1)\n"
"    %{3 => [\"cat\", \"ant\"], 7 => [\"buffalo\"], 5 => [\"dingo\"]}\n"
"\n"

#. TRANSLATORS: def Enum.split_while(collection, fun)
#: lib/enum.ex:1887
msgid ""
"Splits `collection` in two at the position of the element for which `fun` "
"returns `false` for the\n"
"first time.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.split_while([1, 2, 3, 4], fn(x) -> x < 3 end)\n"
"    {[1, 2], [3, 4]}\n"
"\n"
msgstr ""
"`collection`を`fun`が最初に`false`を返す位置で要素を二つに分割します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.split_while([1, 2, 3, 4], fn(x) -> x < 3 end)\n"
"    {[1, 2], [3, 4]}\n"
"\n"

#. TRANSLATORS: def Enum.sort_by(collection, mapper, sorter \\ &<=/2)
#: lib/enum.ex:1797
msgid ""
"Sorts the mapped results of the `collection` according to the `sorter` "
"function.\n"
"\n"
"This function maps each element of the collection using the `mapper`\n"
"function.  The collection is then sorted by the mapped elements using the\n"
"`sorter` function, which defaults to `<=/2`\n"
"\n"
"`sort_by/3` differs from `sort/2` in that it only calculates the comparison\n"
"value for each element in the collection once instead of once for each\n"
"element in each comparison.  If the same function is being called on both\n"
"element, it's also more compact to use `sort_by/3`.\n"
"\n"
"This technique is also known as a\n"
"[Schwartzian Transform](https://en.wikipedia.org/wiki/"
"Schwartzian_transform),\n"
"or the Lisp decorate-sort-undecorate idiom as the `mapper` is decorating "
"the\n"
"original `collection`, then `sorter` is sorting the decorations, and "
"finally\n"
"the `collection` is being undecorated so only the original elements remain,\n"
"but now in sorted order.\n"
"\n"
"## Examples\n"
"\n"
"Using the default `sorter` of `<=/2`:\n"
"\n"
"    iex> Enum.sort_by [\"some\", \"kind\", \"of\", \"monster\"], "
"&byte_size/1\n"
"    [\"of\", \"some\", \"kind\", \"monster\"]\n"
"\n"
"Using a custom `sorter` to override the order:\n"
"\n"
"    iex> Enum.sort_by [\"some\", \"kind\", \"of\", \"monster\"], "
"&byte_size/1, &>=/2\n"
"    [\"monster\", \"some\", \"kind\", \"of\"]\n"
"\n"
msgstr ""
"`sorter` 関数によって `collection` をmapperで処理された結果でソートします。\n"
"\n"
"この関数は、`mapper`関数を使ってコレクションのそれぞれの要素をマップし\n"
"ます。コレクションはそれからデフォルトは`<=/2`である`sorter`関数を使っ\n"
"てマップされた要素でソートされます。\n"
"\n"
"それが各の比較において要素ごとに一度だけ比較計算をするという点で\n"
"`sort_by/3`は`sort/2`と違います。もし同じ関数が両方の要素で呼ばれている\n"
"ならば`sort_by/3`を使うことでよりコンパクトになります。\n"
"\n"
"この技術は [Schwartzian\n"
"Transform](https://en.wikipedia.org/wiki/Schwartzian_transform) として\n"
"知られています。あるいは、Lispのdecorate-sort-undecorate イディオムとし\n"
"て知られています。`mapper`がオリジナルの`collection`のデコレーション、\n"
"それから`sorter`はソートのデコレレーションとして、そして最後にソートさ\n"
"れた順番以外は `collection` はデコレーションされずにオリジナルの要素のま\n"
"まです。\n"
"\n"
"## 例\n"
"\n"
"デフォルトの `sorter` である `<=/2` を使います: \n"
"\n"
"    iex> Enum.sort_by [\"some\", \"kind\", \"of\", \"monster\"], "
"&byte_size/1\n"
"    [\"of\", \"some\", \"kind\", \"monster\"]\n"
"\n"
"カスタム`sorter`として上書きます: \n"
"\n"
"    iex> Enum.sort_by [\"some\", \"kind\", \"of\", \"monster\"], "
"&byte_size/1, &>=/2\n"
"    [\"monster\", \"some\", \"kind\", \"of\"]\n"
"\n"

#. TRANSLATORS: def Enum.sort(collection, fun)
#: lib/enum.ex:1764
msgid ""
"Sorts the collection by the given function.\n"
"\n"
"This function uses the merge sort algorithm. The given function\n"
"must return `false` if the first argument is less than right one.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.sort([1, 2, 3], &(&1 > &2))\n"
"    [3, 2, 1]\n"
"\n"
"The sorting algorithm will be stable as long as the given function\n"
"returns `true` for values considered equal:\n"
"\n"
"    iex> Enum.sort [\"some\", \"kind\", \"of\", \"monster\"], "
"&(byte_size(&1) <= byte_size(&2))\n"
"    [\"of\", \"some\", \"kind\", \"monster\"]\n"
"\n"
"If the function does not return `true` for equal values, the sorting is not "
"stable and\n"
"the order of equal terms may be shuffled:\n"
"\n"
"    iex> Enum.sort [\"some\", \"kind\", \"of\", \"monster\"], "
"&(byte_size(&1) < byte_size(&2))\n"
"    [\"of\", \"kind\", \"some\", \"monster\"]\n"
"\n"
msgstr ""
"与えられた関数によってコレクションをソートします。\n"
"\n"
"この関数はマージソートアルゴリズムを使います。与えられた関数はもし最初\n"
"の引数が右の物よりも小さいならば`false`を返さなければなりません。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.sort([1, 2, 3], &(&1 > &2))\n"
"    [3, 2, 1]\n"
"\n"
"\n"
"ソートアルゴリズムは値が等しいときに`true`を返す関数を与えた場合に限り\n"
"安定です:\n"
"\n"
"    iex> Enum.sort [\"some\", \"kind\", \"of\", \"monster\"], &(byte_size(&1) <= byte_size(&2))\n"
"    [\"of\", \"some\", \"kind\", \"monster\"]\n"
"\n"
"もし関数が`true`を返さない場合、ソートは不安定となり、等しい要素の順番は\n"
"シャッフルされるでしょう:\n"
"\n"
"    iex> Enum.sort [\"some\", \"kind\", \"of\", \"monster\"], &(byte_size(&1) < byte_size(&2))\n"
"    [\"of\", \"kind\", \"some\", \"monster\"]\n"
"\n"

#. TRANSLATORS: def Enum.sort(collection)
#: lib/enum.ex:1744
msgid ""
"Sorts the collection according to Elixir's term ordering.\n"
"\n"
"Uses the merge sort algorithm.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.sort([3, 2, 1])\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
"Elixirのタームの順序でコレクションをソートします。\n"
"\n"
"マージソートアルゴリズムを使います。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.sort([3, 2, 1])\n"
"    [1, 2, 3]\n"
"\n"

#. TRANSLATORS: def Enum.reverse(collection)
#: lib/enum.ex:1481
msgid ""
"Reverses the collection.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reverse([1, 2, 3])\n"
"    [3, 2, 1]\n"
"\n"
msgstr ""
"コレクションを逆順にします。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.reverse([1, 2, 3])\n"
"    [3, 2, 1]\n"
"\n"

#. TRANSLATORS: def Enum.reverse_slice(collection, start, count)
#: lib/enum.ex:1521
msgid ""
"Reverses the collection in the range from initial position `first`\n"
"through `count` elements. If `count` is greater than the size of\n"
"the rest of the collection, then this function will reverse the rest\n"
"of the collection.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reverse_slice([1, 2, 3, 4, 5, 6], 2, 4)\n"
"    [1, 2, 6, 5, 4, 3]\n"
"\n"
msgstr ""
"初期位置が`first`からの`count`要素の範囲(range)のコレクションを\n"
"逆転させます。\n"
"もし`count`がコレクションの残りの大きさより大きい場合、\n"
"この関数はコレクションの残り全部を逆転させます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.reverse_slice([1, 2, 3, 4, 5, 6], 2, 4)\n"
"    [1, 2, 6, 5, 4, 3]\n"
"\n"

#. TRANSLATORS: def Enum.reverse(collection, tail)
#: lib/enum.ex:1499
msgid ""
"Reverses the collection and appends the tail.\n"
"This is an optimization for\n"
"`Enum.concat(Enum.reverse(collection), tail)`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reverse([1, 2, 3], [4, 5, 6])\n"
"    [3, 2, 1, 4, 5, 6]\n"
"\n"
msgstr ""
"コレクションを逆順にしてtailを追加します。これは\n"
"`Enum.concat(Enum.reverse(collection), tail)`の最適化です。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.reverse([1, 2, 3], [4, 5, 6])\n"
"    [3, 2, 1, 4, 5, 6]\n"
"\n"

#. TRANSLATORS: def Enum.find(collection, ifnone \\ nil, fun)
#: lib/enum.ex:729
msgid ""
"Returns the first item for which `fun` returns a truthy value. If no such\n"
"item is found, returns `ifnone`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.find([2, 4, 6], fn(x) -> rem(x, 2) == 1 end)\n"
"    nil\n"
"\n"
"    iex> Enum.find([2, 4, 6], 0, fn(x) -> rem(x, 2) == 1 end)\n"
"    0\n"
"\n"
"    iex> Enum.find([2, 3, 4], fn(x) -> rem(x, 2) == 1 end)\n"
"    3\n"
"\n"
msgstr ""
"`fun`を実行してtrueを返す最初のアイテムを返します。もしアイテムが見つか\n"
"らないなら、`ifnone`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.find([2, 4, 6], fn(x) -> rem(x, 2) == 1 end)\n"
"    nil\n"
"\n"
"    iex> Enum.find([2, 4, 6], 0, fn(x) -> rem(x, 2) == 1 end)\n"
"    0\n"
"\n"
"    iex> Enum.find([2, 3, 4], fn(x) -> rem(x, 2) == 1 end)\n"
"    3\n"
"\n"

#. TRANSLATORS: def Enum.sum(collection)
#: lib/enum.ex:1310
msgid ""
"Returns the sum of all values.\n"
"\n"
"Raises `ArithmeticError` if collection contains a non-numeric value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.sum([1, 2, 3])\n"
"    6\n"
"\n"
msgstr ""
"全ての値の和を返します。\n"
"\n"
"もしコレクションが非数値を含んでないなら`ArithmeticError`を上げます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.sum([1, 2, 3])\n"
"    6\n"
"\n"

#. TRANSLATORS: def Enum.min(collection)
#: lib/enum.ex:1199
msgid ""
"Returns the minimum value.\n"
"Raises `EmptyError` if the collection is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.min([1, 2, 3])\n"
"    1\n"
"\n"
msgstr ""
"最小の値を返します。\n"
"もしコレクションが空なら、`EmptyError`を上げます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.min([1, 2, 3])\n"
"    1\n"
"\n"

#. TRANSLATORS: def Enum.min_by(collection, fun)
#: lib/enum.ex:1214
msgid ""
"Returns the minimum value as calculated by the given function.\n"
"Raises `EmptyError` if the collection is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.min_by([\"a\", \"aa\", \"aaa\"], fn(x) -> String.length(x) "
"end)\n"
"    \"a\"\n"
"\n"
msgstr ""
"与えられた関数により計算した値が最小となる要素を返します。\n"
"もしコレクションが空なら、`EmptyError`を上げます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.min_by([\"a\", \"aa\", \"aaa\"], fn(x) -> String.length(x) "
"end)\n"
"    \"a\"\n"
"\n"

#. TRANSLATORS: def Enum.max(collection)
#: lib/enum.ex:1113
msgid ""
"Returns the maximum value.\n"
"Raises `EmptyError` if the collection is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.max([1, 2, 3])\n"
"    3\n"
"\n"
msgstr ""
"最大の値を返します。\n"
"もしコレクションが空なら、`EmptyError`を上げます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.max([1, 2, 3])\n"
"    3\n"
"\n"

#. TRANSLATORS: def Enum.max_by(collection, fun)
#: lib/enum.ex:1128
msgid ""
"Returns the maximum value as calculated by the given function.\n"
"Raises `EmptyError` if the collection is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.max_by([\"a\", \"aa\", \"aaa\"], fn(x) -> String.length(x) "
"end)\n"
"    \"aaa\"\n"
"\n"
msgstr ""
"与えられた関数により計算した値が最大となる要素を返します。\n"
"もしコレクションが空なら、`EmptyError`を上げます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.max_by([\"a\", \"aa\", \"aaa\"], fn(x) -> String.length(x) "
"end)\n"
"    \"aaa\"\n"
"\n"

#. TRANSLATORS: def Enum.count(collection, fun)
#: lib/enum.ex:447
msgid ""
"Returns the count of items in the collection for which\n"
"`fun` returns a truthy value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.count([1, 2, 3, 4, 5], fn(x) -> rem(x, 2) == 0 end)\n"
"    2\n"
"\n"
msgstr ""
"コレクションの中で`fun`が真な値を返す要素の数を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.count([1, 2, 3, 4, 5], fn(x) -> rem(x, 2) == 0 end)\n"
"    2\n"
"\n"

#. TRANSLATORS: def Enum.count(collection)
#: lib/enum.ex:422
msgid ""
"Returns the collection's size.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.count([1, 2, 3])\n"
"    3\n"
"\n"
msgstr ""
"コレクションのサイズを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.count([1, 2, 3])\n"
"    3\n"
"\n"

#. TRANSLATORS: def Enum.take_while(collection, fun)
#: lib/enum.ex:2086
msgid ""
"Takes the items from the beginning of `collection` while `fun` returns a "
"truthy value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.take_while([1, 2, 3], fn(x) -> x < 3 end)\n"
"    [1, 2]\n"
"\n"
msgstr ""
"`collection`の先頭から`fun`が真な値を返す間のアイテムを取り出します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.take_while([1, 2, 3], fn(x) -> x < 3 end)\n"
"    [1, 2]\n"
"\n"

#. TRANSLATORS: def Enum.take(collection, count)
#: lib/enum.ex:1914
msgid ""
"Takes the first `count` items from the collection.\n"
"\n"
"`count` must be an integer. If a negative `count` is given, the last `count` "
"values will\n"
"be taken. For such, the collection is fully enumerated keeping up\n"
"to `2 * count` elements in memory. Once the end of the collection is\n"
"reached, the last `count` elements are returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.take([1, 2, 3], 2)\n"
"    [1, 2]\n"
"\n"
"    iex> Enum.take([1, 2, 3], 10)\n"
"    [1, 2, 3]\n"
"\n"
"    iex> Enum.take([1, 2, 3], 0)\n"
"    []\n"
"\n"
"    iex> Enum.take([1, 2, 3], -1)\n"
"    [3]\n"
"\n"
msgstr ""
"最初の`count`個のアイテムを`collection`から取り出します。\n"
"\n"
"`count`は整数でなくてはなりません。`count`に負が与えられると、\n"
"最後の`count`個が取り出されます。そのため、コレクションは完全な\n"
"列挙にはメモリ内に`2 * count`要素が続きます。コレクションの終わ\n"
"りに到達したら、最後の`count`個の要素が返されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.take([1, 2, 3], 2)\n"
"    [1,2]\n"
"\n"
"    iex> Enum.take([1, 2, 3], 10)\n"
"    [1,2,3]\n"
"\n"
"    iex> Enum.take([1, 2, 3], 0)\n"
"    []\n"
"\n"
"    iex> Enum.take([1, 2, 3], -1)\n"
"    [3]\n"
"\n"

#. TRANSLATORS: def Enum.take_random(collection, count)
#: lib/enum.ex:2015
msgid ""
"Takes random items from a collection.\n"
"\n"
"Notice this function will traverse the whole collection to\n"
"get the random sublist of collection. If you want the random\n"
"number between two integers, the best option is to use the\n"
"`:random` module.\n"
"\n"
"See `random/1` for notes on implementation and random seed.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.take_random(1..10, 2)\n"
"    [1, 5]\n"
"    iex> Enum.take_random(?a..?z, 5)\n"
"    'tfesm'\n"
"\n"
msgstr ""
"コレクションのランダムなサブリストを返します。\n"
"\n"
"コレクションのランダムなサブリストを取得するために、この関数は\n"
"コレクション全体をトラバースすることに気を付けてください。\n"
"もし二つの整数の間のランダムな数を望むなら、`:random`モジュールを\n"
"使うことがベストな選択です。\n"
"\n"
"実装とランダムシードについてのメモについては`random/1`を\n"
"参照してください。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.sample(1..10, 2)\n"
"    [1, 5]\n"
"    iex> Enum.sample(?a..?z, 5)\n"
"    'tfesm'\n"
"\n"

#. TRANSLATORS: def Enum.split(collection, count)
#: lib/enum.ex:1837
msgid ""
"Splits the enumerable into two collections, leaving `count`\n"
"elements in the first one. If `count` is a negative number,\n"
"it starts counting from the back to the beginning of the\n"
"collection.\n"
"\n"
"Be aware that a negative `count` implies the collection\n"
"will be enumerated twice: once to calculate the position, and\n"
"a second time to do the actual splitting.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.split([1, 2, 3], 2)\n"
"    {[1, 2], [3]}\n"
"\n"
"    iex> Enum.split([1, 2, 3], 10)\n"
"    {[1, 2, 3], []}\n"
"\n"
"    iex> Enum.split([1, 2, 3], 0)\n"
"    {[], [1, 2, 3]}\n"
"\n"
"    iex> Enum.split([1, 2, 3], -1)\n"
"    {[1, 2], [3]}\n"
"\n"
"    iex> Enum.split([1, 2, 3], -5)\n"
"    {[], [1, 2, 3]}\n"
"\n"
msgstr ""
"enumerableを、最初の`count`個の要素とそれ以外の、二つのコレクションに分\n"
"割します。もし`count`が負の数なら、コレクションの最後から最初に向って数\n"
"えます。\n"
"\n"
"負の`count`は、コレクションで2回数え上げられることを意味する\n"
"ということに、注意してください: 一度は位置を計算するために、\n"
"二回目は、実際の分割をするために。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.split([1, 2, 3], 2)\n"
"    {[1, 2], [3]}\n"
"\n"
"    iex> Enum.split([1, 2, 3], 10)\n"
"    {[1, 2, 3], []}\n"
"\n"
"    iex> Enum.split([1, 2, 3], 0)\n"
"    {[], [1, 2, 3]}\n"
"\n"
"    iex> Enum.split([1, 2, 3], -1)\n"
"    {[1,2 ], [3]}\n"
"\n"
"    iex> Enum.split([1, 2, 3], -5)\n"
"    {[], [1, 2, 3]}\n"
"\n"

#. TRANSLATORS: def Enum.with_index(collection)
#: lib/enum.ex:2222
msgid ""
"Returns the collection with each element wrapped in a tuple\n"
"alongside its index.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.with_index [1, 2, 3]\n"
"    [{1, 0}, {2, 1}, {3, 2}]\n"
"\n"
msgstr ""
"それぞれの要素をそのインデックスと一緒にタプルで包んだ\n"
"コレクションを、返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.with_index [1, 2, 3]\n"
"    [{1, 0},{2, 1},{3, 2}]\n"
"\n"

#. TRANSLATORS: def Enum.reject(collection, fun)
#: lib/enum.ex:1463
msgid ""
"Returns elements of collection for which `fun` returns `false` or `nil`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reject([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    [1, 3]\n"
"\n"
msgstr ""
"`fun`が`false`または`nil`となるコレクションの要素を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.reject([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    [1, 3]\n"
"\n"

#. TRANSLATORS: def Enum.min_max(collection)
#: lib/enum.ex:1252
msgid ""
"Returns a tuple with the minimum and maximum values.\n"
"Raises `EmptyError` if the collection is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.min_max([2, 3, 1])\n"
"    {1, 3}\n"
"\n"
msgstr ""
"最小と最大の値のタプルを返します。\n"
"もしコレクションが空なら、`EmptyError`を上げます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.minmax([2, 3, 1])\n"
"    {1, 3}\n"
"\n"

#. TRANSLATORS: def Enum.min_max_by(collection, fun)
#: lib/enum.ex:1278
msgid ""
"Returns a tuple with the minimum and maximum values as calculated by the "
"given function.\n"
"Raises `EmptyError` if the collection is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.min_max_by([\"aaa\", \"bb\", \"c\"], fn(x) -> String.length(x) "
"end)\n"
"    {\"c\", \"aaa\"}\n"
"\n"
msgstr ""
"与えられた関数により計算した値が最小と最大となる要素のタプルを\n"
"返します。\n"
"もしコレクションが空なら、`EmptyError`を上げます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.min_max_by([\"aaa\", \"bb\", \"c\"], fn(x) -> String.length(x) end)\n"
"    {\"c\", \"aaa\"}\n"
"\n"

#. TRANSLATORS: def Enum.random(collection)
#: lib/enum.ex:1546
msgid ""
"Returns a random element of a collection.\n"
"Raises `EmptyError` if the collection is empty.\n"
"\n"
"Notice that you need to explicitly call `:random.seed/1` and\n"
"set a seed value for the random algorithm. Otherwise, the\n"
"default seed will be set which will always return the same\n"
"result. For example, one could do the following to set a seed\n"
"dynamically:\n"
"\n"
"    :random.seed(:os.timestamp)\n"
"\n"
"The implementation is based on the\n"
"[reservoir sampling](https://en.wikipedia.org/wiki/"
"Reservoir_sampling#Relation_to_Fisher-Yates_shuffle)\n"
"algorithm.\n"
"It assumes that the sample being returned can fit into memory;\n"
"the input collection doesn't have to - it is traversed just once.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.random([1, 2, 3])\n"
"    1\n"
"    iex> Enum.random([1, 2, 3])\n"
"    2\n"
"\n"
msgstr ""
"コレクションの要素をランダム化して返します。\n"
"もしコレクションが空なら、`EmptyError`が上ります。\n"
"\n"
"明示的に`:random.seed/1`を呼び出して、乱数アルゴリズムのシード値を設定\n"
"する必要があることに注意してください。さもないと、常に同じデフォルトシー\n"
"ドが設定され、同じ結果が帰って来ます。例えば、以下の様にして一度呼び出\n"
"すと、シードを動的に設定することができます:\n"
"\n"
"    :random.seed(:os.timestamp)\n"
"\n"
"実装は、\n"
"[reservoir sampling](http://en.wikipedia.org/wiki/\n"
"Reservoir_sampling#Relation_to_Fisher-Yates_shuffle)\n"
"アルゴリズムに基いています。\n"
"それは返されるサンプルがメモリに収まると仮定します; 入力の\n"
"コレクションはその必要はありません。それは丁度一度だけトラバース\n"
"されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.random([1, 2, 3])\n"
"    1\n"
"    iex> Enum.random([1, 2, 3])\n"
"    2\n"
"\n"

#. TRANSLATORS: def Enum.slice(collection, start, count)
#: lib/enum.ex:1641
msgid ""
"Returns a subset list of the given collection. Drops elements\n"
"until element position `start`, then takes `count` elements.\n"
"\n"
"If the count is greater than collection length, it returns as\n"
"much as possible. If zero, then it returns `[]`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.slice(1..100, 5, 10)\n"
"    [6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n"
"\n"
"    iex> Enum.slice(1..10, 5, 100)\n"
"    [6, 7, 8, 9, 10]\n"
"\n"
"    iex> Enum.slice(1..10, 5, 0)\n"
"    []\n"
"\n"
msgstr ""
"与えられたコレクションのサブセットのリストを返します。`start`番目の要素\n"
"まで削除され、そこから`count`個の要素のリストになります。\n"
"\n"
"もしコレクションの長さよりcountが大きいなら、可能な最大値が\n"
"帰って来ます。もし0なら、`[]`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.slice(1..100, 5, 10)\n"
"    [6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n"
"\n"
"    iex> Enum.slice(1..10, 5, 100)\n"
"    [6, 7, 8, 9, 10]\n"
"\n"
"    iex> Enum.slice(1..10, 5, 0)\n"
"    []\n"
"\n"

#. TRANSLATORS: def Enum.slice(collection, range)
#: lib/enum.ex:1690
msgid ""
"Returns a subset list of the given collection. Drops elements\n"
"until element position `range.first`, then takes elements until element\n"
"position `range.last` (inclusive).\n"
"\n"
"Positions are calculated by adding the number of items in the collection to\n"
"negative positions (so position -3 in a collection with count 5 becomes\n"
"position 2).\n"
"\n"
"The first position (after adding count to negative positions) must be "
"smaller\n"
"or equal to the last position.\n"
"\n"
"If the start of the range is not a valid offset for the given\n"
"collection or if the range is in reverse order, returns `[]`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.slice(1..100, 5..10)\n"
"    [6, 7, 8, 9, 10, 11]\n"
"\n"
"    iex> Enum.slice(1..10, 5..20)\n"
"    [6, 7, 8, 9, 10]\n"
"\n"
"    iex> Enum.slice(1..10, 11..20)\n"
"    []\n"
"\n"
"    iex> Enum.slice(1..10, 6..5)\n"
"    []\n"
"\n"
msgstr ""
"与えられたコレクションのサブセットのリストを返します。\n"
"\n"
"与えられたコレクションのサブセットのリストを返します。`range.first`番目\n"
"の要素まで削除され、そこから`range.last`番目の要素(要素自身を含みます)\n"
"のリストになります。\n"
"\n"
"負の位置については、位置はコレクション中のアイテムの数を加えることによっ\n"
"て計算されます(だから、カウント5によるコレクションの位置-3は位置2になり\n"
"ます)。\n"
"\n"
"最初の位置(カウントに負の位置を加えた後)は最後の位置と同じか小くなけれ\n"
"ばなりません。\n"
"\n"
"もし範囲の始まりが与えられたコレクションの正しいオフセットで\n"
"ない、あるいは、範囲が逆順であるなら、`[]`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.slice(1..100, 5..10)\n"
"    [6, 7, 8, 9, 10, 11]\n"
"\n"
"    iex> Enum.slice(1..10, 5..20)\n"
"    [6, 7, 8, 9, 10]\n"
"\n"
"    iex> Enum.slice(1..10, 11..20)\n"
"    []\n"
"\n"
"    iex> Enum.slice(1..10, 6..5)\n"
"    []\n"
"\n"

#. TRANSLATORS: def Enum.map(collection, fun)
#: lib/enum.ex:1026
msgid ""
"Returns a new collection, where each item is the result\n"
"of invoking `fun` on each corresponding item of `collection`.\n"
"\n"
"For dicts, the function expects a key-value tuple.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.map([1, 2, 3], fn(x) -> x * 2 end)\n"
"    [2, 4, 6]\n"
"\n"
"    iex> Enum.map([a: 1, b: 2], fn({k, v}) -> {k, -v} end)\n"
"    [a: -1, b: -2]\n"
"\n"
msgstr ""
"`collection`のそれぞれのアイテムについて、`fun`を実行した結果を\n"
"要素とする、新しいコレクションを返します。\n"
"\n"
"dictの場合、関数はKey-valueタプルを期待します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.map([1, 2, 3], fn(x) -> x * 2 end)\n"
"    [2, 4, 6]\n"
"\n"
"    iex> Enum.map([a: 1, b: 2], fn({k, v}) -> {k, -v} end)\n"
"    [a: -1, b: -2]\n"
"\n"

#. TRANSLATORS: def Enum.flat_map(collection, fun)
#: lib/enum.ex:818
msgid ""
"Returns a new collection appending the result of invoking `fun`\n"
"on each corresponding item of `collection`.\n"
"\n"
"The given function should return an enumerable.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.flat_map([:a, :b, :c], fn(x) -> [x, x] end)\n"
"    [:a, :a, :b, :b, :c, :c]\n"
"\n"
"    iex> Enum.flat_map([{1, 3}, {4, 6}], fn({x, y}) -> x..y end)\n"
"    [1, 2, 3, 4, 5, 6]\n"
"\n"
msgstr ""
"`collection`のそれぞれのアイテムに、`fun`を実行した結果を\n"
"追加した、新しいコレクションを返します。\n"
"\n"
"与えられた関数はenumerableを返さなければなりません。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.flat_map([:a, :b, :c], fn(x) -> [x, x] end)\n"
"    [:a, :a, :b, :b, :c, :c]\n"
"\n"
"    iex> Enum.flat_map([{1, 3}, {4, 6}], fn({x, y}) -> x..y end)\n"
"    [1, 2, 3, 4, 5, 6]\n"
"\n"

#. TRANSLATORS: def Enum.chunk(collection, n, step, pad \\ nil)
#: lib/enum.ex:313
msgid ""
"Returns a collection of lists containing `n` items each, where\n"
"each new chunk starts `step` elements into the collection.\n"
"\n"
"`step` is optional and, if not passed, defaults to `n`, i.e.\n"
"chunks do not overlap. If the final chunk does not have `n`\n"
"elements to fill the chunk, elements are taken as necessary\n"
"from `pad` if it was passed. If `pad` is passed and does not\n"
"have enough elements to fill the chunk, then the chunk is\n"
"returned anyway with less than `n` elements. If `pad` is not\n"
"passed at all or is `nil`, then the partial chunk is discarded\n"
"from the result.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4, 5, 6], 2)\n"
"    [[1, 2], [3, 4], [5, 6]]\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4, 5, 6], 3, 2)\n"
"    [[1, 2, 3], [3, 4, 5]]\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4, 5, 6], 3, 2, [7])\n"
"    [[1, 2, 3], [3, 4, 5], [5, 6, 7]]\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4, 5, 6], 3, 3, [])\n"
"    [[1, 2, 3], [4, 5, 6]]\n"
"\n"
msgstr ""
"コレクションから`step`要素毎に`n`アイテムを含んだリストのコレクションを\n"
"返します。\n"
"\n"
"`step`はオプションで、もし与えられなければ、デフォルトは`n`になります。\n"
"即ち、チャンクはオーバーラップしません。もし最後のチャンクはチャンクを\n"
"満す`n`個要素を持っていなかったら、要素は`pad`から必要に応じて取られま\n"
"す。もし`pad`が与えられていて、チャンクを満すのに十分でなかったら、チャ\n"
"ンクは`n`要素より少くなるでしょう。もし`pad`が全く与えられていないか、\n"
"`nil`なら、結果から部分的なチャンクは放棄されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4, 5, 6], 2)\n"
"    [[1, 2], [3, 4], [5, 6]]\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4, 5, 6], 3, 2)\n"
"    [[1, 2, 3], [3, 4, 5]]\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4, 5, 6], 3, 2, [7])\n"
"    [[1, 2, 3], [3, 4, 5], [5, 6, 7]]\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4, 5, 6], 3, 3, [])\n"
"    [[1, 2, 3], [4, 5, 6]]\n"
"\n"

#. TRANSLATORS: def Enum.take_every(collection, nth)
#: lib/enum.ex:1984
msgid ""
"Returns a collection of every `nth` item in the collection,\n"
"starting with the first element.\n"
"\n"
"The first item is always included, unless `nth` is 0.\n"
"\n"
"The second argument specifying every `nth` item must be a non-negative "
"integer,\n"
"otherwise `FunctionClauseError` will be thrown.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.take_every(1..10, 2)\n"
"    [1, 3, 5, 7, 9]\n"
"\n"
"    iex> Enum.take_every(1..10, 0)\n"
"    []\n"
"\n"
"    iex> Enum.take_every([1, 2, 3], 1)\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
"コレクションの`nth`番目ごとの要素のコレクションを返します。\n"
"最初の要素からスタートします。\n"
"\n"
"`nth`が0でない限り、最初のアイテムは常に含まれます。\n"
"\n"
"`nth`番目毎を指定する2番目の引数は、非負の整数でなくてはなりま\n"
"せん。さもなければ`FunctionClauseError`が投げられるでしょう。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.take_every(1..10, 2)\n"
"    [1, 3, 5, 7, 9]\n"
"\n"
"    iex> Enum.take_every(1..10, 0)\n"
"    []\n"
"\n"
"    iex> Enum.take_every([1, 2, 3], 1)\n"
"    [1, 2, 3]\n"
"\n"

#. TRANSLATORS: def Enum.shuffle(collection)
#: lib/enum.ex:1614
msgid ""
"Returns a list of collection elements shuffled.\n"
"\n"
"Notice that you need to explicitly call `:random.seed/1` and\n"
"set a seed value for the random algorithm. Otherwise, the\n"
"default seed will be set which will always return the same\n"
"result. For example, one could do the following to set a seed\n"
"dynamically:\n"
"\n"
"    :random.seed(:os.timestamp)\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.shuffle([1, 2, 3])\n"
"    [3, 2, 1]\n"
"    iex> Enum.shuffle([1, 2, 3])\n"
"    [3, 1, 2]\n"
"\n"
msgstr ""
"コレクションの要素をシャッフルしたリストを返します。\n"
"\n"
"明示的に`:random.seed/1`を呼び出して、乱数アルゴリズムのシード値を設定\n"
"する必要があることに注意してください。さもないと、常に同じデフォルトシー\n"
"ドが設定され、同じ結果が帰って来ます。例えば、以下の様にして一度呼び出\n"
"すと、シードを動的に設定することができます:\n"
"\n"
"    :random.seed(:os.timestamp)\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.shuffle([1, 2, 3])\n"
"    [3, 2, 1]\n"
"    iex> Enum.shuffle([1, 2, 3])\n"
"    [3, 1, 2]\n"
"\n"

#. TRANSLATORS: def Enumerable.count(collection)
#: lib/enum.ex:128
msgid ""
"Retrieves the collection's size.\n"
"\n"
"It should return `{:ok, size}`.\n"
"\n"
"If `{:error, __MODULE__}` is returned a default algorithm using `reduce` "
"and\n"
"the match (`===`) operator is used. This algorithm runs in linear time.\n"
"\n"
"Please force use of the default algorithm unless you can implement an\n"
"algorithm that is significantly faster.\n"
msgstr ""
"コレクションのサイズを取り出します。\n"
"\n"
"通常は`{:ok, size}`を返すべきです。\n"
"\n"
"もし`{:error, __MODULE__}`を返したら、デフォルトアルゴリズムの\n"
"`reduce`とマッチ(`===`)オペレータが使われます。このアルゴリズムは実行に\n"
"線形時間がかかります。\n"
"\n"
"あなたがより速いアルゴリズムを実装することができない限り、デフォルトの\n"
"アルゴリズムの使用を強制してください。\n"

#. TRANSLATORS: def Enum.dedup_by(collection, fun)
#: lib/enum.ex:482
msgid ""
"Enumerates the collection, returning a list where all consecutive\n"
"duplicated elements are collapsed to a single element.\n"
"\n"
"The function `fun` maps every element to a term which is used to\n"
"determine if two elements are duplicates.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.dedup_by([{1, :x}, {2, :y}, {2, :z}, {1, :x}], fn {x, _} -> x "
"end)\n"
"    [{1, :x}, {2, :y}, {1, :x}]\n"
"\n"
"    iex> Enum.dedup_by([5, 1, 2, 3, 2, 1], fn x -> x > 2 end)\n"
"    [5, 1, 3, 2]\n"
"\n"
msgstr ""
"コレクションを数え上げ、連続して重複する要素を一つの要素に\n"
"したリストを返します。\n"
"\n"
"関数`fun`はそれぞれの要素を二つの要素が重複しているか\n"
"どうかを決定するために使われます\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.dedup_by([{1, :x}, {2, :y}, {2, :z}, {1, :x}], fn {x, _} -> x end)\n"
"    [{1, :x}, {2, :y}, {1, :x}]\n"
"\n"
"    iex> Enum.dedup_by([5, 1, 2, 3, 2, 1], fn x -> x > 2 end)\n"
"    [5, 1, 3, 2]\n"
"\n"

#. TRANSLATORS: def Enum.dedup(collection)
#: lib/enum.ex:465
msgid ""
"Enumerates the collection, returning a list where all consecutive\n"
"duplicated elements are collapsed to a single element.\n"
"\n"
"Elements are compared using `===`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.dedup([1, 2, 3, 3, 2, 1])\n"
"    [1, 2, 3, 2, 1]\n"
"\n"
msgstr ""
"コレクションを数え上げ、連続して重複する要素を一つの要素に\n"
"したリストを返します。\n"
"\n"
"要素は`===`を使って比較されます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.dedup([1, 2, 3, 3, 2, 1])\n"
"    [1, 2, 3, 2, 1]\n"
"\n"

#. TRANSLATORS: def Enum.empty?(collection)
#: lib/enum.ex:591
msgid ""
"Returns `true` if the collection is empty, otherwise `false`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.empty?([])\n"
"    true\n"
"\n"
"    iex> Enum.empty?([1, 2, 3])\n"
"    false\n"
"\n"
msgstr ""
"もし、コレクションが空なら、`true`を、さもなくば`false`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.empty?([])\n"
"    true\n"
"\n"
"    iex> Enum.empty?([1, 2, 3])\n"
"    false\n"
"\n"

#. TRANSLATORS: def Enum.uniq(collection)
#: lib/enum.ex:2131
msgid ""
"Enumerates the collection, removing all duplicated elements.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.uniq([1, 2, 3, 3, 2, 1])\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
"重複するアイテムを削除しながら、コレクションを列挙します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.uniq([1, 2, 3, 2, 1])\n"
"    [1, 2, 3]\n"
"\n"

#. TRANSLATORS: def Enum.uniq_by(collection, fun)
#: lib/enum.ex:2152
msgid ""
"Enumerates the collection, removing all duplicated elements.\n"
"\n"
"## Example\n"
"\n"
"    iex> Enum.uniq_by([{1, :x}, {2, :y}, {1, :z}], fn {x, _} -> x end)\n"
"    [{1, :x}, {2, :y}]\n"
"\n"
msgstr ""
"重複するアイテムを削除しながら、コレクションを列挙します。\n"
"\n"
"## Example\n"
"\n"
"    iex> Enum.uniq_by([{1, :x}, {2, :y}, {1, :z}], fn {x, _} -> x end)\n"
"    [{1, :x}, {2, :y}]\n"
"\n"

#. TRANSLATORS: def Enum.reduce_while(collection, acc, fun)
#: lib/enum.ex:1444
msgid ""
"Reduces the collection until halt is emitted.\n"
"\n"
"The return value for `fun` is expected to be\n"
"`{:cont, acc}`, return `{:halt, acc}` to end the reduction early.\n"
"Returns the accumulator.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reduce_while(1..100, 0, fn i, acc ->\n"
"    ...>   if i < 3, do: {:cont, acc + i}, else: {:halt, acc}\n"
"    ...> end)\n"
"    3\n"
"\n"
msgstr ""
"haltとなるまでコレクションをreduce(簡約)します。\n"
"\n"
"`fun`の戻値は、`{:cont, acc}`、あるいは、\n"
"reduce(簡約)を途中で終了するために`{:halt, acc}`が\n"
"期待されています。\n"
"アキュムレータを返します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reduce_while(1..100, 0, fn i, acc ->\n"
"    ...>   if i < 3, do: {:cont, acc + i}, else: {:halt, acc}\n"
"    ...> end)\n"
"    3\n"
"\n"

#. TRANSLATORS: def Enumerable.reduce(collection, acc, fun)
#: lib/enum.ex:96
msgid ""
"Reduces the collection into a value.\n"
"\n"
"Most of the operations in `Enum` are implemented in terms of reduce.\n"
"This function should apply the given `reducer` function to each\n"
"item in the collection and proceed as expected by the returned accumulator.\n"
"\n"
"As an example, here is the implementation of `reduce` for lists:\n"
"\n"
"    def reduce(_,     {:halt, acc}, _fun),   do: {:halted, acc}\n"
"    def reduce(list,  {:suspend, acc}, fun), do: {:suspended, acc, "
"&reduce(list, &1, fun)}\n"
"    def reduce([],    {:cont, acc}, _fun),   do: {:done, acc}\n"
"    def reduce([h|t], {:cont, acc}, fun),    do: reduce(t, fun.(h, acc), "
"fun)\n"
"\n"
msgstr ""
"コレクションを一つの値に簡約(reduce)します。\n"
"\n"
"`Enum`のほとんどのオペレーションはreduceで実装されています。この関数は\n"
"与えられた`reducer`関数をコレクションのそれぞれのアイテムに適用して、返\n"
"されたアキュムレータにより、繰返し累積しなくてはなりません。\n"
"\n"
"例として、リストの`reduce`の実装です:\n"
"\n"
"    def reduce(_,     {:halt, acc}, _fun),   do: {:halted, acc}\n"
"    def reduce(list,  {:suspend, acc}, fun), do: {:suspended, acc, "
"&reduce(list, &1, fun)}\n"
"    def reduce([],    {:cont, acc}, _fun),   do: {:done, acc}\n"
"    def reduce([h|t], {:cont, acc}, fun),    do: reduce(t, fun.(h, acc), "
"fun)\n"
"\n"

#. TRANSLATORS: Elixir.Enum Summary
#: lib/enum.ex:146
msgid ""
"Provides a set of algorithms that enumerate over collections according to "
"the\n"
"`Enumerable` protocol:\n"
"\n"
"    iex> Enum.map([1, 2, 3], fn(x) -> x * 2 end)\n"
"    [2, 4, 6]\n"
"\n"
"Some particular types, like dictionaries, yield a specific format on\n"
"enumeration. For dicts, the argument is always a `{key, value}` tuple:\n"
"\n"
"    iex> dict = %{a: 1, b: 2}\n"
"    iex> Enum.map(dict, fn {k, v} -> {k, v * 2} end)\n"
"    [a: 2, b: 4]\n"
"\n"
"Note that the functions in the `Enum` module are eager: they always start\n"
"the enumeration of the given collection. The `Stream` module allows\n"
"lazy enumeration of collections and provides infinite streams.\n"
"\n"
"Since the majority of the functions in `Enum` enumerate the whole\n"
"collection and return a list as result, infinite streams need to\n"
"be carefully used with such functions, as they can potentially run\n"
"forever. For example:\n"
"\n"
"    Enum.each Stream.cycle([1, 2, 3]), &IO.puts(&1)\n"
"\n"
msgstr ""
"`Enumerable`プロトコルに従った、コレクションを列挙するアルゴリズムのセッ\n"
"トを提供します:\n"
"\n"
"    iex> Enum.map([1, 2, 3], fn(x) -> x * 2 end)\n"
"    [2, 4, 6]\n"
"\n"
"辞書のような、若干の特定のタイプは列挙に特定のフォーマットを与えます。\n"
"dictでは、引数は常に`{key, value}`タプルです:\n"
"\n"
"    iex> dict = %{a: 1, b: 2}\n"
"    iex> Enum.map(dict, fn {k, v} -> {k, v * 2} end)\n"
"    [a: 2, b: 4]\n"
"\n"
"`Enum`モジュールはeagerであることに注意してください。\n"
"それらは与えられたコレクションの列挙を常に始めます。\n"
"`Stream`モジュールはコレクションの遅延列挙と無限のストリームを提供します。\n"
"\n"
"`Enum`の大部分の関数が、全部のコレクションを列挙して、\n"
"結果としてリストを返すため、無限のストリームは\n"
"それらの関数で潜在的に永遠に動きつづける可能性があり、\n"
"慎重に使われる必要があります。例えば:\n"
"\n"
"    Enum.each Stream.cycle([1, 2, 3]), &IO.puts(&1)\n"
"\n"

#. TRANSLATORS: def Enum.flat_map_reduce(collection, acc, fun)
#: lib/enum.ex:840
msgid ""
"Maps and reduces a collection, flattening the given results.\n"
"\n"
"It expects an accumulator and a function that receives each stream item\n"
"and an accumulator, and must return a tuple containing a new stream\n"
"(often a list) with the new accumulator or a tuple with `:halt` as first\n"
"element and the accumulator as second.\n"
"\n"
"## Examples\n"
"\n"
"    iex> enum = 1..100\n"
"    iex> n = 3\n"
"    iex> Enum.flat_map_reduce(enum, 0, fn i, acc ->\n"
"    ...>   if acc < n, do: {[i], acc + 1}, else: {:halt, acc}\n"
"    ...> end)\n"
"    {[1, 2, 3], 3}\n"
"\n"
msgstr ""
"コレクションをmapしてreduceし、結果をflattenします。\n"
"\n"
"アキュムレータと関数を期待します。関数は、それぞれのストリームのアイテ\n"
"ムとアキュムレータを受信して、新しいストリーム(しばしばリストです)と新\n"
"しいアキュムレータを含むタプルか、最初の要素が`:halt`で二つめの要素がア\n"
"キュムレータであるタプルを、返さなくてはなりません。\n"
"\n"
"## Examples\n"
"\n"
"    iex> enum = 1..100\n"
"    iex> n = 3\n"
"    iex> Enum.flat_map_reduce(enum, 0, fn i, acc ->\n"
"    ...>   if acc < n, do: {[i], acc + 1}, else: {:halt, acc}\n"
"    ...> end)\n"
"    {[1, 2, 3], 3}\n"
"\n"

#. TRANSLATORS: def Enum.map_join(collection, joiner \\ "", mapper)
#: lib/enum.ex:1050
msgid ""
"Maps and joins the given `collection` in one pass.\n"
"`joiner` can be either a binary or a list and the\n"
"result will be of the same type as `joiner`. If\n"
"`joiner` is not passed at all, it defaults to an\n"
"empty binary.\n"
"\n"
"All items in the collection must be convertible\n"
"to a binary, otherwise an error is raised.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.map_join([1, 2, 3], &(&1 * 2))\n"
"    \"246\"\n"
"\n"
"    iex> Enum.map_join([1, 2, 3], \" = \", &(&1 * 2))\n"
"    \"2 = 4 = 6\"\n"
"\n"
msgstr ""
"一度のパスで、与えられた`collection`をmapしてjoinします。\n"
"`joiner`はバイナリでもリストでもよく、結果は\n"
"`joiner`と同じタイプになります。もし`joiner`が全く\n"
"パスされない場合、デフォルトは空のバイナリになります。\n"
"\n"
"コレクションの全てのアイテムはバイナリへ変換できなければ\n"
"なりません。さもないとエラーが上ります。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.map_join([1, 2, 3], &(&1 * 2))\n"
"    \"246\"\n"
"\n"
"    iex> Enum.map_join([1, 2, 3], \" = \", &(&1 * 2))\n"
"    \"2 = 4 = 6\"\n"
"\n"

#. TRANSLATORS: def Enum.fetch(collection, n)
#: lib/enum.ex:612
msgid ""
"Finds the element at the given index (zero-based).\n"
"\n"
"Returns `{:ok, element}` if found, otherwise `:error`.\n"
"\n"
"A negative index can be passed, which means the collection is\n"
"enumerated once and the index is counted from the end (i.e.\n"
"`-1` fetches the last element).\n"
"\n"
"Note this operation takes linear time. In order to access\n"
"the element at index `n`, it will need to traverse `n`\n"
"previous elements.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.fetch([2, 4, 6], 0)\n"
"    {:ok, 2}\n"
"\n"
"    iex> Enum.fetch([2, 4, 6], 2)\n"
"    {:ok, 6}\n"
"\n"
"    iex> Enum.fetch([2, 4, 6], 4)\n"
"    :error\n"
"\n"
msgstr ""
"与えられた(0始まりの)インデックスの要素を見付けます。\n"
"\n"
"見付かれば、`{:ok, 要素}`を返し、さもなければ`:error`を返します。\n"
"\n"
"負のインデックスが渡されると、コレクションは一度列挙され、\n"
"インデックスは終わりから数えられる(即ち、`-1`は最後の要素を\n"
"取ってきます)ことを意味します。\n"
"\n"
"この操作は線形時間がかかることに気を付けてください。\n"
"インデックス`n`の要素へアクセスするために、`n`個の以前の\n"
"要素を渡り歩く必要があります。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.fetch([2, 4, 6], 0)\n"
"    {:ok, 2}\n"
"\n"
"    iex> Enum.fetch([2, 4, 6], 2)\n"
"    {:ok, 6}\n"
"\n"
"    iex> Enum.fetch([2, 4, 6], 4)\n"
"    :error\n"
"\n"

#. TRANSLATORS: def Enum.at(collection, n, default \\ nil)
#: lib/enum.ex:275
msgid ""
"Finds the element at the given index (zero-based).\n"
"\n"
"Returns `default` if index is out of bounds.\n"
"\n"
"Note this operation takes linear time. In order to access\n"
"the element at index `n`, it will need to traverse `n`\n"
"previous elements.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.at([2, 4, 6], 0)\n"
"    2\n"
"\n"
"    iex> Enum.at([2, 4, 6], 2)\n"
"    6\n"
"\n"
"    iex> Enum.at([2, 4, 6], 4)\n"
"    nil\n"
"\n"
"    iex> Enum.at([2, 4, 6], 4, :none)\n"
"    :none\n"
"\n"
msgstr ""
"与えられた(0始まりの)インデックスの要素を見付けます。\n"
"\n"
"インデックスが範囲外なら、`default`を返します。\n"
"\n"
"この操作は線形時間がかかることに気を付けてください。\n"
"インデックス`n`の要素へアクセスするために、`n`個の以前の\n"
"要素を渡り歩く必要があります。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.at([2, 4, 6], 0)\n"
"    2\n"
"\n"
"    iex> Enum.at([2, 4, 6], 2)\n"
"    6\n"
"\n"
"    iex> Enum.at([2, 4, 6], 4)\n"
"    nil\n"
"\n"
"    iex> Enum.at([2, 4, 6], 4, :none)\n"
"    :none\n"
"\n"

#. TRANSLATORS: def Enum.join(collection, joiner \\ "")
#: lib/enum.ex:995
msgid ""
"Joins the given `collection` into a binary using `joiner` as a separator.\n"
"If `joiner` is not passed at all, it defaults to the empty binary.\n"
"\n"
"All items in the collection must be convertible\n"
"to a binary, otherwise an error is raised.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.join([1, 2, 3])\n"
"    \"123\"\n"
"\n"
"    iex> Enum.join([1, 2, 3], \" = \")\n"
"    \"1 = 2 = 3\"\n"
"\n"
msgstr ""
"`collection`をバイナリ`joiner`をセパレータとしてjoinします。\n"
"もし`joiner`が全くパスされない場合、デフォルトは空のバイナリに\n"
"なります。\n"
"\n"
"コレクションの全てのアイテムはバイナリへ変換できなければ\n"
"なりません。さもないとエラーが上ります。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.join([1, 2, 3])\n"
"    \"123\"\n"
"\n"
"    iex> Enum.join([1, 2, 3], \" = \")\n"
"    \"1 = 2 = 3\"\n"
"\n"

#. TRANSLATORS: def Enum.each(collection, fun)
#: lib/enum.ex:565
msgid ""
"Invokes the given `fun` for each item in the `collection`.\n"
"Returns `:ok`.\n"
"\n"
"## Examples\n"
"\n"
"    Enum.each([\"some\", \"example\"], fn(x) -> IO.puts x end)\n"
"    \"some\"\n"
"    \"example\"\n"
"    #=> :ok\n"
"\n"
msgstr ""
"`collection`のそれぞれのアイテムに対して、与えられた`fun`を起動します。\n"
"`:ok`を返します。\n"
"\n"
"## 例\n"
"\n"
"    Enum.each([\"some\", \"example\"], fn(x) -> IO.puts x end)\n"
"    \"some\"\n"
"    \"example\"\n"
"    #=> :ok\n"
"\n"

#. TRANSLATORS: def Enum.any?(collection, fun \\ fn x -> x end)
#: lib/enum.ex:238
msgid ""
"Invokes the given `fun` for each item in the `collection` and returns `true` "
"if\n"
"at least one invocation returns a truthy value. Returns `false` otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.any?([2, 4, 6], fn(x) -> rem(x, 2) == 1 end)\n"
"    false\n"
"\n"
"    iex> Enum.any?([2, 3, 4], fn(x) -> rem(x, 2) == 1 end)\n"
"    true\n"
"\n"
"If no function is given, it defaults to checking if\n"
"at least one item in the collection is a truthy value.\n"
"\n"
"    iex> Enum.any?([false, false, false])\n"
"    false\n"
"\n"
"    iex> Enum.any?([false, true, false])\n"
"    true\n"
"\n"
msgstr ""
"`collection`のそれぞれのアイテムに対して、与えられた`fun`を起動し、少な\n"
"くとも一つが`true`を返すなら、`true`を返します。さもなければ、`false`を\n"
"返します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.any?([2, 4, 6], fn(x) -> rem(x, 2) == 1 end)\n"
"    false\n"
"\n"
"    iex> Enum.any?([2, 3, 4], fn(x) -> rem(x, 2) == 1 end)\n"
"    true\n"
"\n"
"関数が与えられないと、デフォルトで少なくともひとつのコレク\n"
"ションのアイテムが`true`に評価されるかをチェックします。\n"
"\n"
"    iex> Enum.any?([false, false, false])\n"
"    false\n"
"\n"
"    iex> Enum.any?([false, true, false])\n"
"    true\n"
"\n"

#. TRANSLATORS: def Enum.all?(collection, fun \\ fn x -> x end)
#: lib/enum.ex:201
msgid ""
"Invokes the given `fun` for each item in the `collection` and returns "
"`false`\n"
"if at least one invocation returns `false` or `nil`. Otherwise returns "
"`true`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.all?([2, 4, 6], fn(x) -> rem(x, 2) == 0 end)\n"
"    true\n"
"\n"
"    iex> Enum.all?([2, 3, 4], fn(x) -> rem(x, 2) == 0 end)\n"
"    false\n"
"\n"
"If no function is given, it defaults to checking if\n"
"all items in the collection are truthy values.\n"
"\n"
"    iex> Enum.all?([1, 2, 3])\n"
"    true\n"
"\n"
"    iex> Enum.all?([1, nil, 3])\n"
"    false\n"
"\n"
msgstr ""
"`collection`のそれぞれのアイテムに対して与えられた`fun`を起動し、\n"
"その結果、少なくとも一つが`false` または`nil`を返したら、\n"
"`false`を返します。さもなければ、`true`を返します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.all?([2, 4, 6], fn(x) -> rem(x, 2) == 0 end)\n"
"    true\n"
"\n"
"    iex> Enum.all?([2, 3, 4], fn(x) -> rem(x, 2) == 0 end)\n"
"    false\n"
"\n"
"関数が与えられないなら、デフォルトでコレクションの\n"
"全てのアイテムが`true`に評価されるかをチェックします。\n"
"\n"
"    iex> Enum.all?([1, 2, 3])\n"
"    true\n"
"\n"
"    iex> Enum.all?([1, nil, 3])\n"
"    false\n"
"\n"

#. TRANSLATORS: def Enum.map_reduce(collection, acc, fun)
#: lib/enum.ex:1085
msgid ""
"Invokes the given `fun` for each item in the `collection`\n"
"while also keeping an accumulator. Returns a tuple where\n"
"the first element is the mapped collection and the second\n"
"one is the final accumulator.\n"
"\n"
"For dicts, the first tuple element must be a `{key, value}`\n"
"tuple.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.map_reduce([1, 2, 3], 0, fn(x, acc) -> {x * 2, x + acc} end)\n"
"    {[2, 4, 6], 6}\n"
"\n"
msgstr ""
"アキュムレータを保持しながら、`collection`のそれぞれのアイテムで与えら\n"
"れた`fun`を起動します。最初の要素がmapされたコレクションで\n"
"二つめは最終的なアキュムレータであるタプルを返します。\n"
"\n"
"dictでは、最初のタプルの要素は`{key, value}`タプルでなくては\n"
"なりません。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.map_reduce([1, 2, 3], 0, fn(x, acc) -> {x * 2, x + acc} end)\n"
"    {[2, 4, 6], 6}\n"
"\n"

#. TRANSLATORS: def Enum.reduce(collection, fun)
#: lib/enum.ex:1402
msgid ""
"Invokes `fun` for each element in the collection passing that element and "
"the\n"
"accumulator `acc` as arguments. `fun`'s return value is stored in `acc`.\n"
"The first element of the collection is used as the initial value of `acc`.\n"
"If you wish to use another value for `acc`, use `Enumerable.reduce/3`.\n"
"This function won't call the specified function for enumerables that are 1-"
"element long.\n"
"Returns the accumulator.\n"
"\n"
"Note that since the first element of the enumerable is used as the initial\n"
"value of the accumulator, `fun` will only be executed `n - 1` times where "
"`n`\n"
"is the length of the enumerable.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reduce([1, 2, 3, 4], fn(x, acc) -> x * acc end)\n"
"    24\n"
"\n"
msgstr ""
"collectionのそれぞれの要素について、その要素とアキュムレータを引数とし\n"
"て、`fun`を起動します。`fun`の戻り値は、`acc`に保存されます。\n"
"collectionの最初の要素は、`acc`の初期値として使われます。\n"
"もし`acc`の初期値として他の値を使いたい場合、`Enumerable.reduce/3`を\n"
"使ってください。この関数は数え上げのために指定された関数を要素数-1回数\n"
"呼出します。\n"
"アキュムレータを返します。\n"
"\n"
"最初の要素がアキュムレータの初期値として使われるので、\n"
"コレクションの要素数が`n`なら`fun`は`n - 1`回だけ呼び出されることに\n"
"注意してください。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reduce([1, 2, 3, 4], fn(x, acc) -> x * acc end)\n"
"    24\n"
"\n"

#. TRANSLATORS: def Enum.reduce(collection, acc, fun)
#: lib/enum.ex:1372
msgid ""
"Invokes `fun` for each element in the collection passing that element and "
"the\n"
"accumulator `acc` as arguments. `fun`'s return value is stored in `acc`.\n"
"Returns the accumulator.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reduce([1, 2, 3], 0, fn(x, acc) -> x + acc end)\n"
"    6\n"
"\n"
msgstr ""
"collectionのそれぞれの要素について、その要素とアキュムレータを引数とし\n"
"て、`fun`を起動します。`fun`の戻り値は、`acc`に保存されます。アキュムレー\n"
"タを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.reduce([1, 2, 3], 0, fn(x, acc) -> x + acc end)\n"
"    6\n"
"\n"

#. TRANSLATORS: def Enum.intersperse(collection, element)
#: lib/enum.ex:879
msgid ""
"Intersperses `element` between each element of the enumeration.\n"
"\n"
"Complexity: O(n)\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.intersperse([1, 2, 3], 0)\n"
"    [1, 0, 2, 0, 3]\n"
"\n"
"    iex> Enum.intersperse([1], 0)\n"
"    [1]\n"
"\n"
"    iex> Enum.intersperse([], 0)\n"
"    []\n"
"\n"
msgstr ""
"列挙(collection)のそれぞれの要素の間で、`element`を散在さ\n"
"せます。\n"
"\n"
"複雑さ: O(n)\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.intersperse([1, 2, 3], 0)\n"
"    [1, 0, 2, 0, 3]\n"
"\n"
"    iex> Enum.intersperse([1], 0)\n"
"    [1]\n"
"\n"
"    iex> Enum.intersperse([], 0)\n"
"    []\n"
"\n"

#. TRANSLATORS: def Enum.into(collection, list)
#: lib/enum.ex:909
msgid ""
"Inserts the given enumerable into a collectable.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.into([1, 2], [0])\n"
"    [0, 1, 2]\n"
"\n"
"    iex> Enum.into([a: 1, b: 2], %{})\n"
"    %{a: 1, b: 2}\n"
"\n"
msgstr ""
"collectableに与えられたenumerableを挿入します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.into([1, 2], [0])\n"
"    [0, 1, 2]\n"
"\n"
"    iex> Enum.into([a: 1, b: 2], %{})\n"
"    %{a: 1, b: 2}\n"
"\n"

#. TRANSLATORS: def Enum.into(collection, list, transform)
#: lib/enum.ex:959
msgid ""
"Inserts the given enumerable into a collectable\n"
"according to the transformation function.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.into([2, 3], [3], fn x -> x * 3 end)\n"
"    [3, 6, 9]\n"
"\n"
msgstr ""
"変換関数に従って、collectableに与えられたenumerableを挿入します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.into([2, 3], [3], fn x -> x * 3 end)\n"
"    [3, 6, 9]\n"
"\n"

#. TRANSLATORS: def Enum.fetch!(collection, n)
#: lib/enum.ex:662
msgid ""
"Finds the element at the given index (zero-based).\n"
"\n"
"Raises `OutOfBoundsError` if the given position\n"
"is outside the range of the collection.\n"
"\n"
"Note this operation takes linear time. In order to access\n"
"the element at index `n`, it will need to traverse `n`\n"
"previous elements.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.fetch!([2, 4, 6], 0)\n"
"    2\n"
"\n"
"    iex> Enum.fetch!([2, 4, 6], 2)\n"
"    6\n"
"\n"
"    iex> Enum.fetch!([2, 4, 6], 4)\n"
"    ** (Enum.OutOfBoundsError) out of bounds error\n"
"\n"
msgstr ""
"与えられた(0始まりの)インデックスの要素を見付けます。\n"
"\n"
"与えられた位置がコレクションの範囲外なら、`OutOfBoundsError`を上げます。\n"
"\n"
"この操作は線形時間がかかることに気を付けてください。\n"
"インデックス`n`の要素へアクセスするために、`n`個の以前の\n"
"要素を渡り歩く必要があります。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.fetch!([2, 4, 6], 0)\n"
"    2\n"
"\n"
"    iex> Enum.fetch!([2, 4, 6], 2)\n"
"    6\n"
"\n"
"    iex> Enum.fetch!([2, 4, 6], 4)\n"
"    ** (Enum.OutOfBoundsError) out of bounds error\n"
"\n"

#. TRANSLATORS: def Enum.filter(collection, fun)
#: lib/enum.ex:692
msgid ""
"Filters the collection, i.e. returns only those elements\n"
"for which `fun` returns a truthy value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.filter([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    [2]\n"
"\n"
msgstr ""
"コレクションをフィルタします。即ち、`fun`が真の値を返す\n"
"要素のみを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.filter([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    [2]\n"
"\n"

#. TRANSLATORS: def Enum.filter_map(collection, filter, mapper)
#: lib/enum.ex:711
msgid ""
"Filters the collection and maps its values in one pass.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.filter_map([1, 2, 3], fn(x) -> rem(x, 2) == 0 end, &(&1 * 2))\n"
"    [4]\n"
"\n"
msgstr ""
"一度のパスでコレクションをフィルタしてマップします。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.filter_map([1, 2, 3], fn(x) -> rem(x, 2) == 0 end, &(&1 * 2))\n"
"    [4]\n"
"\n"

#. TRANSLATORS: def Enum.concat(enumerables)
#: lib/enum.ex:377
msgid ""
"Given an enumerable of enumerables, concatenates the enumerables into a "
"single list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.concat([1..3, 4..6, 7..9])\n"
"    [1, 2, 3, 4, 5, 6, 7, 8, 9]\n"
"\n"
"    iex> Enum.concat([[1, [2], 3], [4], [5, 6]])\n"
"    [1, [2], 3, 4, 5, 6]\n"
"\n"
msgstr ""
"与えられたenumerableのenumerableを一つのリストに連結します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.concat([1..3, 4..6, 7..9])\n"
"    [1, 2, 3, 4, 5, 6, 7, 8, 9]\n"
"\n"
"    iex> Enum.concat([[1, [2], 3], [4], [5, 6]])\n"
"    [1, [2], 3, 4, 5, 6]\n"
"\n"

#. TRANSLATORS: def Enum.partition(collection, fun)
#: lib/enum.ex:1326
msgid ""
"Partitions `collection` into two collections, where the first one contains "
"elements\n"
"for which `fun` returns a truthy value, and the second one -- for which "
"`fun`\n"
"returns `false` or `nil`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.partition([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    {[2], [1, 3]}\n"
"\n"
msgstr ""
"`collection`を二つのコレクションに分割します。最初のものは、`fun`が真を\n"
"返す要素を含み、二つめは`fun`が`false`または`nil`を返すものです。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.partition([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    {[2], [1, 3]}\n"
"\n"

#. TRANSLATORS: def Enum.unzip(collection)
#: lib/enum.ex:2172
msgid ""
"Opposite of `Enum.zip/2`; takes a list of two-element tuples and returns a\n"
"tuple with two lists, each of which is formed by the first and second "
"element\n"
"of each tuple, respectively.\n"
"\n"
"This function fails unless `collection` is or can be converted into a list "
"of\n"
"tuples with *exactly* two elements in each tuple.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.unzip([{:a, 1}, {:b, 2}, {:c, 3}])\n"
"    {[:a, :b, :c], [1, 2, 3]}\n"
"\n"
"    iex> Enum.unzip(%{a: 1, b: 2})\n"
"    {[:a, :b], [1, 2]}\n"
"\n"
msgstr ""
"`Enum.zip/2`の正反対; 二要素のタプルのリストをとり、二つのリ\n"
"ストをもつタプルを返します(それぞれのリストは各々のタプルの第\n"
"一および第二の要素で作れられます)。\n"
"\n"
"`coll`が各のタプルで *正確に* 二要素のタプルのリストであるか、\n"
"それにコンバート出来ない限り、この関数は失敗します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.unzip([{:a, 1}, {:b, 2}, {:c, 3}])\n"
"    {[:a, :b, :c], [1, 2, 3]}\n"
"\n"
"    iex> Enum.unzip(%{a: 1, b: 2})\n"
"    {[:a, :b], [1, 2]}\n"
"\n"

#. TRANSLATORS: Elixir.Enumerable Summary
#: lib/enum.ex:2
msgid ""
"Enumerable protocol used by `Enum` and `Stream` modules.\n"
"\n"
"When you invoke a function in the `Enum` module, the first argument\n"
"is usually a collection that must implement this protocol. For example,\n"
"the expression\n"
"\n"
"    Enum.map([1, 2, 3], &(&1 * 2))\n"
"\n"
"invokes underneath `Enumerable.reduce/3` to perform the reducing\n"
"operation that builds a mapped list by calling the mapping function\n"
"`&(&1 * 2)` on every element in the collection and cons'ing the\n"
"element with an accumulated list.\n"
"\n"
"Internally, `Enum.map/2` is implemented as follows:\n"
"\n"
"    def map(enum, fun) do\n"
"      reducer = fn x, acc -> {:cont, [fun.(x)|acc]} end\n"
"      Enumerable.reduce(enum, {:cont, []}, reducer) |> elem(1) |> :lists."
"reverse()\n"
"    end\n"
"\n"
"Notice the user given function is wrapped into a `reducer` function.\n"
"The `reducer` function must return a tagged tuple after each step,\n"
"as described in the `acc/0` type.\n"
"\n"
"The reason the accumulator requires a tagged tuple is to allow the\n"
"reducer function to communicate to the underlying enumerable the end\n"
"of enumeration, allowing any open resource to be properly closed. It\n"
"also allows suspension of the enumeration, which is useful when\n"
"interleaving between many enumerables is required (as in zip).\n"
"\n"
"Finally, `Enumerable.reduce/3` will return another tagged tuple,\n"
"as represented by the `result/0` type.\n"
msgstr ""
"`Enum`と`Stream`モジュールで使われる、Enumerableプロトコルです。\n"
"\n"
"`Enum`モジュールの関数を起動したとき、最初の引数は通常はコレクションで、\n"
"このプロトコルを実装していなければなりません。\n"
"例えば、式\n"
"\n"
"    Enum.map([1, 2, 3], &(&1 * 2))\n"
"\n"
"は、コレクションのそれぞれのアイテムに関数`&(&1 * 2)`を呼び出し、その結\n"
"果を累積リストにコンシングすることにより、マップされたリストを構築する、\n"
"reduceオペレーションを実行するために、下層にある`Enumerable.reduce/3`を\n"
"起動します。\n"
"\n"
"内部的に、`Enum.map/2`は、以下のように実装されています:\n"
"\n"
"    def map(enum, fun) do\n"
"      reducer = fn x, acc -> {:cont, [fun.(x)|acc]} end\n"
"      Enumerable.reduce(enum, {:cont, []}, reducer) |> elem(1) |> :lists."
"reverse()\n"
"    end\n"
"\n"
"ユーザに与えられた関数は、`reducer`関数にラップされていることに、注意し\n"
"てください。`reducer`関数は、それぞれのステップの後で、`acc/0`タイプで\n"
"記述されるタグづけされたタプルを返さなければなりません。\n"
"\n"
"アキュムレータがタグづけされたタプルを要求する理由は、\n"
"reducer関数に、下層のenumerableと列挙の終わりを知らせ、\n"
"オープンした任意のリソースをクローズさせるることを許すためです。\n"
"列挙の中断も許します。それは、\n"
"多くのenumerable間のインターリーブが必要とされる時(zipの時のような)に\n"
"便利です。\n"
"\n"
"最後に、`Enumerable.reduce/3`は、`result/0`タイプにより表現される、\n"
"もう一つのタグづけされたタプルを返します。\n"

#. TRANSLATORS: def Enum.drop(collection, count)
#: lib/enum.ex:504
msgid ""
"Drops the first `count` items from `collection`.\n"
"\n"
"If a negative value `count` is given, the last `count`\n"
"values will be dropped. The collection is enumerated\n"
"once to retrieve the proper index and the remaining\n"
"calculation is performed from the end.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.drop([1, 2, 3], 2)\n"
"    [3]\n"
"\n"
"    iex> Enum.drop([1, 2, 3], 10)\n"
"    []\n"
"\n"
"    iex> Enum.drop([1, 2, 3], 0)\n"
"    [1, 2, 3]\n"
"\n"
"    iex> Enum.drop([1, 2, 3], -1)\n"
"    [1, 2]\n"
"\n"
msgstr ""
"最初の`count`個のアイテムを`collection`から削除します。\n"
"\n"
"もし負の`count`が与えられたら、最後の`count`個が削除されます。\n"
"コレクションは適切なインデックスを取り出すために\n"
"一度列挙され、残りの計算は終わりから実行されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.drop([1, 2, 3], 2)\n"
"    [3]\n"
"\n"
"    iex> Enum.drop([1, 2, 3], 10)\n"
"    []\n"
"\n"
"    iex> Enum.drop([1, 2, 3], 0)\n"
"    [1, 2, 3]\n"
"\n"
"    iex> Enum.drop([1, 2, 3], -1)\n"
"    [1, 2]\n"
"\n"

#. TRANSLATORS: def Enum.drop_while(collection, fun)
#: lib/enum.ex:546
msgid ""
"Drops items at the beginning of `collection` while `fun` returns a truthy "
"value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.drop_while([1, 2, 3, 4, 5], fn(x) -> x < 3 end)\n"
"    [3, 4, 5]\n"
"\n"
msgstr ""
"`collection`の先頭から、`fun`が真の値を返すアイテムを削除します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.drop_while([1, 2, 3, 4, 5], fn(x) -> x < 3 end)\n"
"    [3, 4, 5]\n"
"\n"

#. TRANSLATORS: def Enum.concat(left, right)
#: lib/enum.ex:394
msgid ""
"Concatenates the enumerable on the right with the enumerable on the left.\n"
"\n"
"This function produces the same result as the `Kernel.++/2` operator for "
"lists.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.concat(1..3, 4..6)\n"
"    [1, 2, 3, 4, 5, 6]\n"
"\n"
"    iex> Enum.concat([1, 2, 3], [4, 5, 6])\n"
"    [1, 2, 3, 4, 5, 6]\n"
"\n"
msgstr ""
"左辺のenumerableと右辺のenumerableを連結します。\n"
"\n"
"この関数はリストのための`Kernel.++/2`演算子と同じ結果を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.concat(1..3, 4..6)\n"
"    [1, 2, 3, 4, 5, 6]\n"
"\n"
"    iex> Enum.concat([1, 2, 3], [4, 5, 6])\n"
"    [1, 2, 3, 4, 5, 6]\n"
"\n"

#. TRANSLATORS: def Enum.to_list(collection)
#: lib/enum.ex:2113
msgid ""
"Converts `collection` to a list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.to_list(1 .. 3)\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
"`collection`をリストに変換します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.to_list(1 .. 3)\n"
"    [1, 2, 3]\n"
"\n"

#. TRANSLATORS: def Enumerable.member?(collection, value)
#: lib/enum.ex:114
msgid ""
"Checks if a value exists within the collection.\n"
"\n"
"It should return `{:ok, boolean}`.\n"
"\n"
"If `{:error, __MODULE__}` is returned a default algorithm using `reduce` "
"and\n"
"the match (`===`) operator is used. This algorithm runs in linear time.\n"
"\n"
"Please force use of the default algorithm unless you can implement an\n"
"algorithm that is significantly faster.\n"
msgstr ""
"値がコレクションの中に存在するかチェックします。\n"
"\n"
"`{:ok, boolean}`を返すべきです。\n"
"\n"
"`{:error, __MODULE__}`を返したら、`reduce`とマッチオペレータ(`===`)を使う\n"
"デフォルトアルゴリズムが使われます。このアルゴリズムは線形に時間がかかりま"
"す。\n"
"\n"
"より速いアルゴリズムのを実装することができない限り、デフォルトアルゴリ\n"
"ズムの使用を強制してください。\n"

#. TRANSLATORS: def Enum.member?(collection, value)
#: lib/enum.ex:1166
msgid ""
"Checks if `value` exists within the `collection`.\n"
"\n"
"Membership is tested with the match (`===`) operator, although\n"
"enumerables like ranges may include floats inside the given\n"
"range.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.member?(1..10, 5)\n"
"    true\n"
"\n"
"    iex> Enum.member?([:a, :b, :c], :d)\n"
"    false\n"
"\n"
msgstr ""
"値がコレクションの中に存在するかチェックします。\n"
"\n"
"`{:ok, boolean}`を返すべきです。\n"
"\n"
"`{:error, __MODULE__}`を返したら、`reduce`とマッチオペレータ(`===`)を使う\n"
"デフォルトアルゴリズムが使われます。このアルゴリズムは線形に時間がかかりま"
"す。\n"
"\n"
"より速いアルゴリズムのを実装することができない限り、デフォルトアルゴリ\n"
"ズムの使用を強制してください。\n"
"\n"
"メンバーシップはマッチオペレータ(`===`)でテストされます。\n"
"しかし、範囲(range)のようなenumerableは浮動少数点数を所定の範囲(range)に\n"
"含むかもしれません。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.member?(1..10, 5)\n"
"    true\n"
"\n"
"    iex> Enum.member?([:a, :b, :c], :d)\n"
"    false\n"
"\n"

#. TRANSLATORS: def Enum.scan(enum, acc, fun)
#: lib/enum.ex:1597
msgid ""
"Applies the given function to each element in the collection,\n"
"storing the result in a list and passing it as the accumulator\n"
"for the next computation. Uses the given `acc` as the starting value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.scan(1..5, 0, &(&1 + &2))\n"
"    [1, 3, 6, 10, 15]\n"
"\n"
msgstr ""
"与えられた関数を、コレクションのそれぞれの要素に適用し、\n"
"リストに結果を保存し、次の計算のためのアキュムレータとして\n"
"渡します。与えられた`acc`は、初期値として使います。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.scan(1..5, 0, &(&1 + &2))\n"
"    [1, 3, 6, 10, 15]\n"
"\n"

#. TRANSLATORS: def Enum.scan(enum, fun)
#: lib/enum.ex:1580
msgid ""
"Applies the given function to each element in the collection,\n"
"storing the result in a list and passing it as the accumulator\n"
"for the next computation.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.scan(1..5, &(&1 + &2))\n"
"    [1, 3, 6, 10, 15]\n"
"\n"
msgstr ""
"与えられた関数を、コレクションのそれぞれの要素に適用し、\n"
"リストに結果を保存し、次の計算のためのアキュムレータとして\n"
"渡します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.scan(1..5, &(&1 + &2))\n"
"    [1, 3, 6, 10, 15]\n"
"\n"

#. TRANSLATORS: @type continuation
#: lib/enum.ex:0
msgid ""
"A partially applied reduce function.\n"
"\n"
"The continuation is the closure returned as a result when\n"
"the enumeration is suspended. When invoked, it expects\n"
"a new accumulator and it returns the result.\n"
"\n"
"A continuation is easily implemented as long as the reduce\n"
"function is defined in a tail recursive fashion. If the function\n"
"is tail recursive, all the state is passed as arguments, so\n"
"the continuation would simply be the reducing function partially\n"
"applied.\n"
msgstr ""
"reduce関数の部分適用です。\n"
"\n"
"continuation(継続)は数え上げ(enumeration)が中断(suspended)\n"
"された時に結果として返されるクロージャです。起動されるとき、\n"
"新しいアキュムレータを期待して、結果を返します。\n"
"\n"
"継続はreduce関数が末尾再帰様式で定義されているかぎり、簡単\n"
"に実装されます。もし関数が末尾再帰なら、全てのステートは引\n"
"数としてパスされ、継続は単に部分的に適用されるreduce関数に\n"
"なるでしょう。\n"
