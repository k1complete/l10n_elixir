#. TRANSLATORS: def File.open(path, modes \\ [])
#: lib/file.ex:922 
msgid ""
"Opens the given `path` according to the given list of modes.\n"
"\n"
"In order to write and read files, one must use the functions\n"
"in the `IO` module. By default, a file is opened in binary mode,\n"
"which requires the functions `IO.binread/2` and `IO.binwrite/2`\n"
"to interact with the file. A developer may pass `:utf8` as an\n"
"option when opening the file and then all other functions from\n"
"`IO` are available, since they work directly with Unicode data.\n"
"\n"
"The allowed modes:\n"
"\n"
"  * `:read` - the file, which must exist, is opened for reading.\n"
"\n"
"  * `:write` - the file is opened for writing. It is created if it does not\n"
"    exist.\n"
"\n"
"    If the file does exists, and if write is not combined with read, the file\n"
"    will be truncated.\n"
"\n"
"  * `:append` - the file will be opened for writing, and it will be created\n"
"    if it does not exist. Every write operation to a file opened with append\n"
"    will take place at the end of the file.\n"
"\n"
"  * `:exclusive` - the file, when opened for writing, is created if it does\n"
"    not exist. If the file exists, open will return `{:error, :eexist}`.\n"
"\n"
"  * `:char_list` - when this term is given, read operations on the file will\n"
"    return char lists rather than binaries.\n"
"\n"
"  * `:compressed` - makes it possible to read or write gzip compressed files.\n"
"\n"
"    The compressed option must be combined with either read or write, but not\n"
"    both. Note that the file size obtained with `stat/1` will most probably\n"
"    not match the number of bytes that can be read from a compressed file.\n"
"\n"
"  * `:utf8` - this option denotes how data is actually stored in the disk\n"
"    file and makes the file perform automatic translation of characters to\n"
"    and from UTF-8.\n"
"\n"
"    If data is sent to a file in a format that cannot be converted to the\n"
"    UTF-8 or if data is read by a function that returns data in a format that\n"
"    cannot cope with the character range of the data, an error occurs and the\n"
"    file will be closed.\n"
"\n"
"For more information about other options like `:read_ahead` and `:delayed_write`,\n"
"see [`:file.open/2`](http://www.erlang.org/doc/man/file.html#open-2).\n"
"\n"
"This function returns:\n"
"\n"
"  * `{:ok, io_device}` - the file has been opened in the requested mode.\n"
"\n"
"    `io_device` is actually the pid of the process which handles the file.\n"
"    This process is linked to the process which originally opened the file.\n"
"    If any process to which the `io_device` is linked terminates, the file\n"
"    will be closed and the process itself will be terminated.\n"
"\n"
"    An `io_device` returned from this call can be used as an argument to the\n"
"    `IO` module functions.\n"
"\n"
"  * `{:error, reason}` - the file could not be opened.\n"
"\n"
"## Examples\n"
"\n"
"    {:ok, file} = File.open(\"foo.tar.gz\", [:read, :compressed])\n"
"    IO.read(file, :line)\n"
"    File.close(file)\n"
"\n"
msgstr ""
#. TRANSLATORS: def File.mkdir_p(path)
#: lib/file.ex:160 
msgid ""
"Tries to create the directory `path`. Missing parent directories are created.\n"
"Returns `:ok` if successful, or `{:error, reason}` if an error occurs.\n"
"\n"
"Typical error reasons are:\n"
"\n"
"  * `:eacces`  - missing search or write permissions for the parent\n"
"    directories of `path`\n"
"  * `:enospc`  - there is a no space left on the device\n"
"  * `:enotdir` - a component of `path` is not a directory\n"
msgstr ""
#. TRANSLATORS: def File.touch(path, time \\ :calendar.universal_time())
#: lib/file.ex:363 
msgid ""
"Updates modification time (mtime) and access time (atime) of\n"
"the given file.\n"
"\n"
"The file is created if it doesnâ€™t exist. Requires datetime in UTC.\n"
msgstr ""
#. TRANSLATORS: def File.touch!(path, time \\ :calendar.universal_time())
#: lib/file.ex:385 
msgid ""
"Same as `touch/2` but raises an exception if it fails.\n"
"\n"
"Returns `:ok` otherwise. Requires datetime in UTC.\n"
msgstr ""
#. TRANSLATORS: def File.chmod(path, mode)
#: lib/file.ex:1229 
msgid ""
"Changes the `mode` for a given `file`.\n"
"\n"
"Returns `:ok` on success, or `{:error, reason}` on failure.\n"
"\n"
"## Permissions\n"
"\n"
"  * 0o400 - read permission: owner\n"
"  * 0o200 - write permission: owner\n"
"  * 0o100 - execute permission: owner\n"
"\n"
"  * 0o040 - read permission: group\n"
"  * 0o020 - write permission: group\n"
"  * 0o010 - execute permission: group\n"
"\n"
"  * 0o004 - read permission: other\n"
"  * 0o002 - write permission: other\n"
"  * 0o001 - execute permission: other\n"
"\n"
"For example, setting the mode 0o755 gives it\n"
"write, read and execute permission to the owner\n"
"and both read and execute permission to group\n"
"and others.\n"
msgstr ""
#. TRANSLATORS: def File.mkdir!(path)
#: lib/file.ex:147 
msgid ""
"Same as `mkdir/1`, but raises an exception in case of failure. Otherwise `:ok`.\n"
msgstr ""
#. TRANSLATORS: def File.rm!(path)
#: lib/file.ex:775 
msgid ""
"Same as `rm/1`, but raises an exception in case of failure. Otherwise `:ok`.\n"
msgstr ""
#. TRANSLATORS: def File.close(io_device)
#: lib/file.ex:1173 
msgid ""
"Closes the file referenced by `io_device`. It mostly returns `:ok`, except\n"
"for some severe errors such as out of memory.\n"
"\n"
"Note that if the option `:delayed_write` was used when opening the file,\n"
"`close/1` might return an old write error and not even try to close the file.\n"
"See `open/2`.\n"
msgstr ""
#. TRANSLATORS: def File.ls!(path \\ ".")
#: lib/file.ex:1159 
msgid ""
"The same as `ls/1` but raises `File.Error`\n"
"in case of an error.\n"
msgstr ""
#. TRANSLATORS: Elixir.File Summary
#: lib/file.ex:2 
msgid ""
"This module contains functions to manipulate files.\n"
"\n"
"Some of those functions are low-level, allowing the user\n"
"to interact with files or IO devices, like `open/2`,\n"
"`copy/3` and others. This module also provides higher\n"
"level functions that work with filenames and have their naming\n"
"based on UNIX variants. For example, one can copy a file\n"
"via `cp/3` and remove files and directories recursively\n"
"via `rm_rf/1`.\n"
"\n"
"## Encoding\n"
"\n"
"In order to write and read files, one must use the functions\n"
"in the `IO` module. By default, a file is opened in binary mode,\n"
"which requires the functions `IO.binread/2` and `IO.binwrite/2`\n"
"to interact with the file. A developer may pass `:utf8` as an\n"
"option when opening the file, then the slower `IO.read/2` and\n"
"`IO.write/2` functions must be used as they are responsible for\n"
"doing the proper conversions and providing the proper data guarantees.\n"
"\n"
"Note that filenames when given as char lists in Elixir are\n"
"always treated as UTF-8. In particular, we expect that the\n"
"shell and the operating system are configured to use UTF-8\n"
"encoding. Binary filenames are considered raw and passed\n"
"to the OS as is.\n"
"\n"
"## API\n"
"\n"
"Most of the functions in this module return `:ok` or\n"
"`{:ok, result}` in case of success, `{:error, reason}`\n"
"otherwise. Those functions also have a variant\n"
"that ends with `!` which returns the result (instead of the\n"
"`{:ok, result}` tuple) in case of success or raises an\n"
"exception in case it fails. For example:\n"
"\n"
"    File.read(\"hello.txt\")\n"
"    #=> {:ok, \"World\"}\n"
"\n"
"    File.read(\"invalid.txt\")\n"
"    #=> {:error, :enoent}\n"
"\n"
"    File.read!(\"hello.txt\")\n"
"    #=> \"World\"\n"
"\n"
"    File.read!(\"invalid.txt\")\n"
"    #=> raises File.Error\n"
"\n"
"In general, a developer should use the former in case they want\n"
"to react if the file does not exist. The latter should be used\n"
"when the developer expects their software to fail in case the\n"
"file cannot be read (i.e. it is literally an exception).\n"
"\n"
"## Processes and raw files\n"
"\n"
"Every time a file is opened, Elixir spawns a new process. Writing\n"
"to a file is equivalent to sending messages to the process that\n"
"writes to the file descriptor.\n"
"\n"
"This means files can be passed between nodes and message passing\n"
"guarantees they can write to the same file in a network.\n"
"\n"
"However, you may not always want to pay the price for this abstraction.\n"
"In such cases, a file can be opened in `:raw` mode. The options `:read_ahead`\n"
"and `:delayed_write` are also useful when operating on large files or\n"
"working with files in tight loops.\n"
"\n"
"Check [`:file.open/2`](http://www.erlang.org/doc/man/file.html#open-2) for more information\n"
"about such options and other performance considerations.\n"
msgstr ""
#. TRANSLATORS: def File.cd!(path)
#: lib/file.ex:1113 
msgid ""
"The same as `cd/1`, but raises an exception if it fails.\n"
msgstr ""
#. TRANSLATORS: def File.lstat(path, opts \\ [])
#: lib/file.ex:294 
msgid ""
"Returns information about the `path`. If the file is a symlink, sets\n"
"the `type` to `:symlink` and returns a `File.Stat` struct for the link. For any\n"
"other file, returns exactly the same values as `stat/2`.\n"
"\n"
"For more details, see [`:file.read_link_info/2`](http://www.erlang.org/doc/man/file.html#read_link_info-2).\n"
"\n"
"## Options\n"
"\n"
"The accepted options are:\n"
"\n"
"  * `:time` - configures how the file timestamps are returned\n"
"\n"
"The values for `:time` can be:\n"
"\n"
"  * `:universal` - returns a `{date, time}` tuple in UTC (default)\n"
"  * `:local` - returns a `{date, time}` tuple using the machine time\n"
"  * `:posix` - returns the time as integer seconds since epoch\n"
"\n"
msgstr ""
#. TRANSLATORS: def File.write(path, content, modes \\ [])
#: lib/file.ex:676 
msgid ""
"Writes `content` to the file `path`.\n"
"\n"
"The file is created if it does not exist. If it exists, the previous\n"
"contents are overwritten. Returns `:ok` if successful, or `{:error, reason}`\n"
"if an error occurs.\n"
"\n"
"**Warning:** Every time this function is invoked, a file descriptor is opened\n"
"and a new process is spawned to write to the file. For this reason, if you are\n"
"doing multiple writes in a loop, opening the file via `File.open/2` and using\n"
"the functions in `IO` to write to the file will yield much better performance\n"
"than calling this function multiple times.\n"
"\n"
"Typical error reasons are:\n"
"\n"
"  * `:enoent`  - a component of the file name does not exist\n"
"  * `:enotdir` - a component of the file name is not a directory;\n"
"    on some platforms, `:enoent` is returned instead\n"
"  * `:enospc`  - there is a no space left on the device\n"
"  * `:eacces`  - missing permission for writing the file or searching one of\n"
"    the parent directories\n"
"  * `:eisdir`  - the named file is a directory\n"
"\n"
"Check `File.open/2` for other available options.\n"
msgstr ""
#. TRANSLATORS: def File.chgrp(path, gid)
#: lib/file.ex:1271 
msgid ""
"Changes the group given by the group id `gid`\n"
"for a given `file`. Returns `:ok` on success, or\n"
"`{:error, reason}` on failure.\n"
msgstr ""
#. TRANSLATORS: def File.copy!(source, destination, bytes_count \\ :infinity)
#: lib/file.ex:438 
msgid ""
"The same as `copy/3` but raises an `File.CopyError` if it fails.\n"
"Returns the `bytes_copied` otherwise.\n"
msgstr ""
#. TRANSLATORS: def File.cd!(path, function)
#: lib/file.ex:1126 
msgid ""
"Changes the current directory to the given `path`,\n"
"executes the given function and then reverts back\n"
"to the previous path regardless of whether there is an exception.\n"
"\n"
"Raises an error if retrieving or changing the current\n"
"directory fails.\n"
msgstr ""
#. TRANSLATORS: def File.stat!(path, opts \\ [])
#: lib/file.ex:280 
msgid ""
"Same as `stat/2` but returns the `File.Stat` directly and\n"
"throws `File.Error` if an error is returned.\n"
msgstr ""
#. TRANSLATORS: def File.stream!(path, modes \\ [], line_or_bytes \\ :line)
#: lib/file.ex:1186 
msgid ""
"Returns a `File.Stream` for the given `path` with the given `modes`.\n"
"\n"
"The stream implements both `Enumerable` and `Collectable` protocols,\n"
"which means it can be used both for read and write.\n"
"\n"
"The `line_or_byte` argument configures how the file is read when\n"
"streaming, by `:line` (default) or by a given number of bytes.\n"
"\n"
"Operating the stream can fail on open for the same reasons as\n"
"`File.open!/2`. Note that the file is automatically opened each time streaming\n"
"begins. There is no need to pass `:read` and `:write` modes, as those are\n"
"automatically set by Elixir.\n"
"\n"
"## Raw files\n"
"\n"
"Since Elixir controls when the streamed file is opened, the underlying\n"
"device cannot be shared and as such it is convenient to open the file\n"
"in raw mode for performance reasons. Therefore, Elixir **will** open\n"
"streams in `:raw` mode with the `:read_ahead` option unless an encoding\n"
"is specified. This means any data streamed into the file must be\n"
"converted to `iodata` type. If you pass `[:utf8]` in the modes parameter,\n"
"the underlying stream will use `IO.write/2` and the `String.Chars` protocol\n"
"to convert the data. See `IO.binwrite/2` and `IO.write/2` .\n"
"\n"
"One may also consider passing the `:delayed_write` option if the stream\n"
"is meant to be written to under a tight loop.\n"
"\n"
"## Examples\n"
"\n"
"    # Read in 2048 byte chunks rather than lines\n"
"    File.stream!(\"./test/test.data\", [], 2048)\n"
"    #=>  %File.Stream{line_or_bytes: 2048, modes: [:raw, :read_ahead, :binary],\n"
"    #=> path: \"./test/test.data\", raw: true}\n"
"\n"
"See `Stream.run/1` for an example of streaming into a file.\n"
"\n"
msgstr ""
#. TRANSLATORS: def File.cp(source, destination, callback \\ fn _, _ -> true end)
#: lib/file.ex:478 
msgid ""
"Copies the contents in `source` to `destination` preserving its mode.\n"
"\n"
"If a file already exists in the destination, it invokes a\n"
"callback which should return `true` if the existing file\n"
"should be overwritten, `false` otherwise. The callback defaults to return `true`.\n"
"\n"
"The function returns `:ok` in case of success, returns\n"
"`{:error, reason}` otherwise.\n"
"\n"
"If you want to copy contents from an io device to another device\n"
"or do a straight copy from a source to a destination without\n"
"preserving modes, check `copy/3` instead.\n"
"\n"
"Note: The command `cp` in Unix systems behaves differently depending\n"
"if `destination` is an existing directory or not. We have chosen to\n"
"explicitly disallow this behaviour. If destination is a directory, an\n"
"error will be returned.\n"
msgstr ""
#. TRANSLATORS: def File.read(path)
#: lib/file.ex:213 
msgid ""
"Returns `{:ok, binary}`, where `binary` is a binary data object that contains the contents\n"
"of `path`, or `{:error, reason}` if an error occurs.\n"
"\n"
"Typical error reasons:\n"
"\n"
"  * `:enoent`  - the file does not exist\n"
"  * `:eacces`  - missing permission for reading the file,\n"
"    or for searching one of the parent directories\n"
"  * `:eisdir`  - the named file is a directory\n"
"  * `:enotdir` - a component of the file name is not a directory;\n"
"    on some platforms, `:enoent` is returned instead\n"
"  * `:enomem`  - there is not enough memory for the contents of the file\n"
"\n"
"You can use `:file.format_error/1` to get a descriptive string of the error.\n"
msgstr ""
#. TRANSLATORS: def File.write_stat(path, stat, opts \\ [])
#: lib/file.ex:339 
msgid ""
"Writes the given `File.Stat` back to the filesystem at the given\n"
"path. Returns `:ok` or `{:error, reason}`.\n"
msgstr ""
#. TRANSLATORS: def File.rmdir(path)
#: lib/file.ex:788 
msgid ""
"Tries to delete the dir at `path`.\n"
"Returns `:ok` if successful, or `{:error, reason}` if an error occurs.\n"
"\n"
"## Examples\n"
"\n"
"    File.rmdir('tmp_dir')\n"
"    #=> :ok\n"
"\n"
"    File.rmdir('file.txt')\n"
"    #=> {:error, :enotdir}\n"
"\n"
msgstr ""
#. TRANSLATORS: def File.open!(path, modes \\ [])
#: lib/file.ex:1038 
msgid ""
"Same as `open/2` but raises an error if file could not be opened.\n"
"\n"
"Returns the `io_device` otherwise.\n"
msgstr ""
#. TRANSLATORS: def File.chgrp!(path, gid)
#: lib/file.ex:1281 
msgid ""
"Same as `chgrp/2`, but raises an exception in case of failure. Otherwise `:ok`.\n"
msgstr ""
#. TRANSLATORS: def File.open(path, modes, function)
#: lib/file.ex:1003 
msgid ""
"Similar to `open/2` but expects a function as its last argument.\n"
"\n"
"The file is opened, given to the function as an argument and\n"
"automatically closed after the function returns, regardless\n"
"if there was an error when executing the function.\n"
"\n"
"It returns `{:ok, function_result}` in case of success,\n"
"`{:error, reason}` otherwise.\n"
"\n"
"This function expects the file to be closed with success,\n"
"which is usually the case unless the `:delayed_write` option\n"
"is given. For this reason, we do not recommend passing\n"
"`:delayed_write` to this function.\n"
"\n"
"## Examples\n"
"\n"
"    File.open(\"file.txt\", [:read, :write], fn(file) ->\n"
"      IO.read(file, :line)\n"
"    end)\n"
"\n"
msgstr ""
#. TRANSLATORS: def File.chown!(path, uid)
#: lib/file.ex:1304 
msgid ""
"Same as `chown/2`, but raises an exception in case of failure. Otherwise `:ok`.\n"
msgstr ""
#. TRANSLATORS: def File.write!(path, content, modes \\ [])
#: lib/file.ex:706 
msgid ""
"Same as `write/3` but raises an exception if it fails, returns `:ok` otherwise.\n"
msgstr ""
#. TRANSLATORS: def File.read!(path)
#: lib/file.ex:234 
msgid ""
"Returns a binary with the contents of the given filename or raises\n"
"`File.Error` if an error occurs.\n"
msgstr ""
#. TRANSLATORS: def File.ls(path \\ ".")
#: lib/file.ex:1145 
msgid ""
"Returns the list of files in the given directory.\n"
"\n"
"It returns `{:ok, [files]}` in case of success,\n"
"`{:error, reason}` otherwise.\n"
msgstr ""
#. TRANSLATORS: def File.regular?(path)
#: lib/file.ex:85 
msgid ""
"Returns `true` if the path is a regular file.\n"
"\n"
"## Examples\n"
"\n"
"    File.regular? __ENV__.file #=> true\n"
"\n"
msgstr ""
#. TRANSLATORS: def File.rm_rf(path)
#: lib/file.ex:819 
msgid ""
"Removes files and directories recursively at the given `path`.\n"
"Symlinks are not followed but simply removed, non-existing\n"
"files are simply ignored (i.e. doesn't make this function fail).\n"
"\n"
"Returns `{:ok, files_and_directories}` with all files and\n"
"directories removed in no specific order, `{:error, reason, file}`\n"
"otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    File.rm_rf \"samples\"\n"
"    #=> {:ok, [\"samples\", \"samples/1.txt\"]}\n"
"\n"
"    File.rm_rf \"unknown\"\n"
"    #=> {:ok, []}\n"
"\n"
msgstr ""
#. TRANSLATORS: def File.lstat!(path, opts \\ [])
#: lib/file.ex:325 
msgid ""
"Same as `lstat/2` but returns the `File.Stat` struct directly and\n"
"throws `File.Error` if an error is returned.\n"
msgstr ""
#. TRANSLATORS: def File.cwd!()
#: lib/file.ex:1091 
msgid ""
"The same as `cwd/0`, but raises an exception if it fails.\n"
msgstr ""
#. TRANSLATORS: def File.mkdir(path)
#: lib/file.ex:128 
msgid ""
"Tries to create the directory `path`. Missing parent directories are not created.\n"
"Returns `:ok` if successful, or `{:error, reason}` if an error occurs.\n"
"\n"
"Typical error reasons are:\n"
"\n"
"  * `:eacces`  - missing search or write permissions for the parent\n"
"    directories of `path`\n"
"  * `:eexist`  - there is already a file or directory named `path`\n"
"  * `:enoent`  - a component of `path` does not exist\n"
"  * `:enospc`  - there is a no space left on the device\n"
"  * `:enotdir` - a component of `path` is not a directory;\n"
"    on some platforms, `:enoent` is returned instead\n"
msgstr ""
#. TRANSLATORS: def File.rm_rf!(path)
#: lib/file.ex:908 
msgid ""
"Same as `rm_rf/1` but raises `File.Error` in case of failures,\n"
"otherwise the list of files or directories removed.\n"
msgstr ""
#. TRANSLATORS: def File.chown(path, uid)
#: lib/file.ex:1294 
msgid ""
"Changes the owner given by the user id `uid`\n"
"for a given `file`. Returns `:ok` on success,\n"
"or `{:error, reason}` on failure.\n"
msgstr ""
#. TRANSLATORS: def File.write_stat!(path, stat, opts \\ [])
#: lib/file.ex:349 
msgid ""
"Same as `write_stat/3` but raises an exception if it fails.\n"
"Returns `:ok` otherwise.\n"
msgstr ""
#. TRANSLATORS: def File.mkdir_p!(path)
#: lib/file.ex:200 
msgid ""
"Same as `mkdir_p/1`, but raises an exception in case of failure. Otherwise `:ok`.\n"
msgstr ""
#. TRANSLATORS: def File.rmdir!(path)
#: lib/file.ex:806 
msgid ""
"Same as `rmdir/1`, but raises an exception in case of failure. Otherwise `:ok`.\n"
msgstr ""
#. TRANSLATORS: def File.cp_r(source, destination, callback \\ fn _, _ -> true end)
#: lib/file.ex:529 
msgid ""
"Copies the contents in source to destination.\n"
"\n"
"If the source is a file, it copies `source` to\n"
"`destination`. If the source is a directory, it copies\n"
"the contents inside source into the destination.\n"
"\n"
"If a file already exists in the destination,\n"
"it invokes a callback which should return\n"
"`true` if the existing file should be overwritten,\n"
"`false` otherwise. The callback defaults to return `true`.\n"
"\n"
"If a directory already exists in the destination\n"
"where a file is meant to be (or vice versa), this\n"
"function will fail.\n"
"\n"
"This function may fail while copying files,\n"
"in such cases, it will leave the destination\n"
"directory in a dirty state, where file which have already been copied\n"
"won't be removed.\n"
"\n"
"The function returns `{:ok, files_and_directories}` in case of\n"
"success, `files_and_directories` lists all files and directories copied in no\n"
"specific order. It returns `{:error, reason, file}` otherwise.\n"
"\n"
"Note: The command `cp` in Unix systems behaves differently\n"
"depending if `destination` is an existing directory or not.\n"
"We have chosen to explicitly disallow this behaviour.\n"
"\n"
"## Examples\n"
"\n"
"    # Copies file \"a.txt\" to \"b.txt\"\n"
"    File.cp_r \"a.txt\", \"b.txt\"\n"
"\n"
"    # Copies all files in \"samples\" to \"tmp\"\n"
"    File.cp_r \"samples\", \"tmp\"\n"
"\n"
"    # Same as before, but asks the user how to proceed in case of conflicts\n"
"    File.cp_r \"samples\", \"tmp\", fn(source, destination) ->\n"
"      IO.gets(\"Overwriting #{destination} by #{source}. Type y to confirm. \") == \"y\\n\"\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def File.copy(source, destination, bytes_count \\ :infinity)
#: lib/file.ex:411 
msgid ""
"Copies the contents of `source` to `destination`.\n"
"\n"
"Both parameters can be a filename or an io device opened\n"
"with `open/2`. `bytes_count` specifies the number of\n"
"bytes to copy, the default being `:infinity`.\n"
"\n"
"If file `destination` already exists, it is overwritten\n"
"by the contents in `source`.\n"
"\n"
"Returns `{:ok, bytes_copied}` if successful,\n"
"`{:error, reason}` otherwise.\n"
"\n"
"Compared to the `cp/3`, this function is more low-level,\n"
"allowing a copy from device to device limited by a number of\n"
"bytes. On the other hand, `cp/3` performs more extensive\n"
"checks on both source and destination and it also preserves\n"
"the file mode after copy.\n"
"\n"
"Typical error reasons are the same as in `open/2`,\n"
"`read/1` and `write/3`.\n"
msgstr ""
#. TRANSLATORS: def File.cp_r!(source, destination, callback \\ fn _, _ -> true end)
#: lib/file.ex:583 
msgid ""
"The same as `cp_r/3`, but raises `File.CopyError` if it fails.\n"
"Returns the list of copied files otherwise.\n"
msgstr ""
#. TRANSLATORS: def File.chmod!(path, mode)
#: lib/file.ex:1258 
msgid ""
"Same as `chmod/2`, but raises an exception in case of failure. Otherwise `:ok`.\n"
msgstr ""
#. TRANSLATORS: def File.stat(path, opts \\ [])
#: lib/file.ex:249 
msgid ""
"Returns information about the `path`. If it exists, it\n"
"returns a `{:ok, info}` tuple, where info is a\n"
"`File.Stat` struct. Returns `{:error, reason}` with\n"
"the same reasons as `read/1` if a failure occurs.\n"
"\n"
"## Options\n"
"\n"
"The accepted options are:\n"
"\n"
"  * `:time` - configures how the file timestamps are returned\n"
"\n"
"The values for `:time` can be:\n"
"\n"
"  * `:universal` - returns a `{date, time}` tuple in UTC (default)\n"
"  * `:local` - returns a `{date, time}` tuple using the same time zone as the\n"
"    machine\n"
"  * `:posix` - returns the time as integer seconds since epoch\n"
"\n"
msgstr ""
#. TRANSLATORS: def File.rename(source, destination)
#: lib/file.ex:453 
msgid ""
"Renames the `source` file to `destination` file.  It can be used to move files\n"
"(and directories) between directories.  If moving a file, you must fully\n"
"specify the `destination` filename, it is not sufficient to simply specify\n"
"its directory.\n"
"\n"
"It returns `:ok` in case of success, returns `{:error, reason}` otherwise.\n"
"\n"
"Note: The command `mv` in Unix systems behaves differently depending\n"
"if `source` is a file and the `destination` is an existing directory.\n"
"We have chosen to explicitly disallow this behaviour.\n"
"\n"
"## Examples\n"
"\n"
"    # Rename file \"a.txt\" to \"b.txt\"\n"
"    File.rename \"a.txt\", \"b.txt\"\n"
"\n"
"    # Rename directory \"samples\" to \"tmp\"\n"
"    File.rename \"samples\", \"tmp\"\n"
msgstr ""
#. TRANSLATORS: def File.open!(path, modes, function)
#: lib/file.ex:1052 
msgid ""
"Same as `open/3` but raises an error if file could not be opened.\n"
"\n"
"Returns the function result otherwise.\n"
msgstr ""
#. TRANSLATORS: def File.rm(path)
#: lib/file.ex:719 
msgid ""
"Tries to delete the file `path`.\n"
"\n"
"Returns `:ok` if successful, or `{:error, reason}` if an error occurs.\n"
"\n"
"Note the file is deleted even if in read-only mode.\n"
"\n"
"Typical error reasons are:\n"
"\n"
"  * `:enoent`  - the file does not exist\n"
"  * `:eacces`  - missing permission for the file or one of its parents\n"
"  * `:eperm`   - the file is a directory and user is not super-user\n"
"  * `:enotdir` - a component of the file name is not a directory;\n"
"    on some platforms, `:enoent` is returned instead\n"
"  * `:einval`  - filename had an improper type, such as tuple\n"
"\n"
"## Examples\n"
"\n"
"    File.rm(\"file.txt\")\n"
"    #=> :ok\n"
"\n"
"    File.rm(\"tmp_dir/\")\n"
"    #=> {:error, :eperm}\n"
"\n"
msgstr ""
#. TRANSLATORS: def File.dir?(path)
#: lib/file.ex:98 
msgid ""
"Returns `true` if the path is a directory.\n"
msgstr ""
#. TRANSLATORS: def File.ln_s(existing, new)
#: lib/file.ex:400 
msgid ""
"Creates a symbolic link `new` to the file or directory `existing`.\n"
"\n"
"Returns `:ok` if successful, `{:error, reason}` otherwise.\n"
"If the operating system does not support symlinks, returns\n"
"`{:error, :enotsup}`.\n"
msgstr ""
#. TRANSLATORS: def File.cwd()
#: lib/file.ex:1066 
msgid ""
"Gets the current working directory.\n"
"\n"
"In rare circumstances, this function can fail on Unix. It may happen\n"
"if read permissions do not exist for the parent directories of the\n"
"current directory. For this reason, returns `{:ok, cwd}` in case\n"
"of success, `{:error, reason}` otherwise.\n"
msgstr ""
#. TRANSLATORS: def File.cp!(source, destination, callback \\ fn _, _ -> true end)
#: lib/file.ex:515 
msgid ""
"The same as `cp/3`, but raises `File.CopyError` if it fails.\n"
"Returns `:ok` otherwise.\n"
msgstr ""
#. TRANSLATORS: def File.cd(path)
#: lib/file.ex:1103 
msgid ""
"Sets the current working directory.\n"
"\n"
"Returns `:ok` if successful, `{:error, reason}` otherwise.\n"
msgstr ""
#. TRANSLATORS: def File.exists?(path)
#: lib/file.ex:106 
msgid ""
"Returns `true` if the given path exists.\n"
"It can be regular file, directory, socket,\n"
"symbolic link, named pipe or device file.\n"
"\n"
"## Examples\n"
"\n"
"    File.exists?(\"test/\")\n"
"    #=> true\n"
"\n"
"    File.exists?(\"missing.txt\")\n"
"    #=> false\n"
"\n"
"    File.exists?(\"/dev/null\")\n"
"    #=> true\n"
"\n"
msgstr ""
