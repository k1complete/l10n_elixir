msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2015-05-20 21:53+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: def File.ls!(path \\ ".")
#: lib/file.ex:1135
msgid ""
"The same as `ls/1` but raises `File.Error`\n"
"in case of an error.\n"
msgstr "`ls/1`と同じですが、エラーのとき`File.Error`例外を上げます。\n"

#. TRANSLATORS: def File.cwd!()
#: lib/file.ex:1066
msgid "The same as `cwd/0`, but raises an exception if it fails.\n"
msgstr "`cwd/0`と同じですが、失敗すると例外を上げます。\n"

#. TRANSLATORS: def File.cp_r!(source, destination, callback \\ fn _, _ -> true end)
#: lib/file.ex:552
msgid ""
"The same as `cp_r/3`, but raises `File.CopyError` if it fails.\n"
"Returns the list of copied files otherwise.\n"
msgstr ""
"`cp_r/3`と同じですが、失敗すると`File.CopyError`を上げます。\n"
"さもなければコピーされたファイルのリストを返します。\n"

#. TRANSLATORS: def File.cp!(source, destination, callback \\ fn _, _ -> true end)
#: lib/file.ex:481
msgid ""
"The same as `cp/3`, but raises `File.CopyError` if it fails.\n"
"Returns the list of copied files otherwise.\n"
msgstr ""
"`cp/3`と同じですが、失敗すると`File.CopyError`を上げます。\n"
"さもなければコピーされたファイルのリストを返します。\n"

#. TRANSLATORS: def File.copy!(source, destination, bytes_count \\ :infinity)
#: lib/file.ex:435
msgid ""
"The same as `copy/3` but raises an `File.CopyError` if it fails.\n"
"Returns the `bytes_copied` otherwise.\n"
msgstr ""
"`copy/3`と同じですが、失敗すると`File.CopyError`を上げます。\n"
"さもなければ、`bytes_copied`(コピーされたバイト数)を返します。\n"

#. TRANSLATORS: def File.cd!(path)
#: lib/file.ex:1088
msgid "The same as `cd/1`, but raises an exception if it fails.\n"
msgstr "`cd/1`と同じですが、失敗すると例外を上げます。\n"

#. TRANSLATORS: def File.write_stat(path, stat, opts \\ [])
#: lib/file.ex:340
msgid ""
"Writes the given `File.Stat` back to the filesystem at the given\n"
"path. Returns `:ok` or `{:error, reason}`.\n"
msgstr ""
"与えられた`File.Stat`を与えられたパスのファイルシステムに書き出します。\n"
"`:ok`または`{:error, reason}`を返します。\n"

#. TRANSLATORS: def File.write(path, content, modes \\ [])
#: lib/file.ex:671
msgid ""
"Writes `content` to the file `path`.\n"
"\n"
"The file is created if it does not exist. If it exists, the previous\n"
"contents are overwritten. Returns `:ok` if successful, or `{:error, reason}"
"`\n"
"if an error occurs.\n"
"\n"
"**Warning:** Every time this function is invoked, a file descriptor is "
"opened\n"
"and a new process is spawned to write to the file. For this reason, if you "
"are\n"
"doing multiple writes in a loop, opening the file via `File.open/2` and "
"using\n"
"the functions in `IO` to write to the file will yield much better "
"performance\n"
"then calling this function multiple times.\n"
"\n"
"Typical error reasons are:\n"
"\n"
"  * `:enoent`  - a component of the file name does not exist\n"
"  * `:enotdir` - a component of the file name is not a directory;\n"
"                 on some platforms, enoent is returned instead\n"
"  * `:enospc`  - there is a no space left on the device\n"
"  * `:eacces`  - missing permission for writing the file or searching one "
"of\n"
"                 the parent directories\n"
"  * `:eisdir`  - the named file is a directory\n"
"\n"
"Check `File.open/2` for other available options.\n"
msgstr ""
"`content`を`path`に書き出します。\n"
"\n"
"ファイルはもし存在しなかったら作成されます。もし存在したら、以前の内容\n"
"は上書きされます。成功したら`:ok`を、エラーが起きたら`{:error,\n"
"reason}` を返します。\n"
"\n"
"**警告:** この関数が呼び出されたら毎回、ファイルディスクプリタはオープン\n"
"され、ファイルへ書き出すための新しいプロセスが生成されます。\n"
"この理由から、ループの中で複数回書き出しをするなら、`File.open/2`でファイル"
"を\n"
"オープンして、ファイルへ書き出すために`IO`モジュールの関数を使うことが\n"
"この関数を複数回呼び出すよりも非常によいパフォーマンスを与えます。\n"
"\n"
"典型的なエラー理由は以下の通りです:\n"
"\n"
"  * `:enoent`  - ファイル名の構成要素が存在しません\n"
"  * `:enotdir` - ファイル名の構成要素がディレクトリではありません;\n"
"                 いくつかのプラットフォームでは、enoentが替わりに返されます\n"
"  * `:enospc`  - デバイスに残りスペースがありません。\n"
"  * `:eacces`  - ファイルを書くための、あるいは、親ディレクトリでサーチする\n"
"                 ためのパーミッションがありません。\n"
"  * `:eisdir`  - ファイル名がディレクトリです。\n"
"\n"
"そのほか有効なオプションについて`File.open/2`をチェックしてください\n"

#. TRANSLATORS: def File.rm(path)
#: lib/file.ex:713
msgid ""
"Tries to delete the file `path`.\n"
"\n"
"Returns `:ok` if successful, or `{:error, reason}` if an error occurs.\n"
"Note the file is deleted even if in read-only mode.\n"
"\n"
"Typical error reasons are:\n"
"\n"
"  * `:enoent`  - the file does not exist\n"
"  * `:eacces`  - missing permission for the file or one of its parents\n"
"  * `:eperm`   - the file is a directory and user is not super-user\n"
"  * `:enotdir` - a component of the file name is not a directory;\n"
"                 on some platforms, enoent is returned instead\n"
"  * `:einval`  - filename had an improper type, such as tuple\n"
"\n"
"## Examples\n"
"\n"
"    File.rm('file.txt')\n"
"    #=> :ok\n"
"\n"
"    File.rm('tmp_dir/')\n"
"    #=> {:error, :eperm}\n"
"\n"
msgstr ""
"`path`ファイルの削除を試みます。\n"
"\n"
"成功したら`:ok`を、エラーが発生したら`{:error, reason}`を返します。\n"
"たとえ読み出し専用モードであってもファイルが削除される点に注意してくださ"
"い。\n"
"\n"
"典型的なエラー原因は以下の通りです:\n"
"\n"
"  * `:enoent`  - ファイルが存在しない\n"
"  * `:eacces`  - ファイルまたはその親のいずれかのパーミッションがない\n"
"  * `:eperm`   - ファイルがディレクトリで、ユーザがスーパーユーザでない\n"
"  * `:enotdir` - ファイル名の一部がディレクトリでない;\n"
"                 いくつかのプラットフォームでは、かわりにenoentが返される\n"
"  * `:einval`  - ファイル名にタプルのような不適当なタイプがあった\n"
"\n"
"## 例\n"
"\n"
"    File.rm('file.txt')\n"
"    #=> :ok\n"
"\n"
"    File.rm('tmp_dir/')\n"
"    #=> {:error, :eperm}\n"
"\n"

#. TRANSLATORS: def File.rmdir(path)
#: lib/file.ex:770
msgid ""
"Tries to delete the dir at `path`.\n"
"Returns `:ok` if successful, or `{:error, reason}` if an error occurs.\n"
"\n"
"## Examples\n"
"\n"
"    File.rmdir('tmp_dir')\n"
"    #=> :ok\n"
"\n"
"    File.rmdir('file.txt')\n"
"    #=> {:error, :enotdir}\n"
"\n"
msgstr ""
"`path`のディレクトリの削除を試みます。\n"
"成功したら`{:ok}`を、エラーが発生したら`{:error, reason}`を返します。\n"
"\n"
"## 例\n"
"\n"
"    File.rmdir('tmp_dir')\n"
"    #=> :ok\n"
"\n"
"    File.rmdir('file.txt')\n"
"    #=> {:error, :enotdir}\n"
"\n"

#. TRANSLATORS: def File.mkdir(path)
#: lib/file.ex:143
msgid ""
"Tries to create the directory `path`. Missing parent directories are not "
"created.\n"
"Returns `:ok` if successful, or `{:error, reason}` if an error occurs.\n"
"\n"
"Typical error reasons are:\n"
"\n"
"  * `:eacces`  - missing search or write permissions for the parent\n"
"     directories of `path`\n"
"  * `:eexist`  - there is already a file or directory named `path`\n"
"  * `:enoent`  - a component of `path` does not exist\n"
"  * `:enospc`  - there is a no space left on the device\n"
"  * `:enotdir` - a component of `path` is not a directory;\n"
"     on some platforms, `:enoent` is returned instead\n"
msgstr ""
"`path`ディレクトリの作成を試みます。親ディレクトリが存在しない場合、作\n"
"成されません。\n"
"成功したら`{:ok}`を、エラーが発生したら`{:error, reason}`を返します。\n"
"\n"
"典型的なエラーは以下のとおりです:\n"
"\n"
"  * `:eacces`  - `path`の親ディレクトリへの検索または書込みパーミッションがな"
"い\n"
"  * `:eexist`  - `path`という名前のファイル又はディレクトリが既に存在する\n"
"  * `:enoent`  - `path`の一部が存在しない\n"
"  * `:enospc`  - デバイスの残り容量がない\n"
"  * `:enotdir` - `path`の一部がディレクトリでない;\n"
"     幾つかのプラットフォームではかわりに`:enoent`が返される。\n"

#. TRANSLATORS: def File.mkdir_p(path)
#: lib/file.ex:172
msgid ""
"Tries to create the directory `path`. Missing parent directories are "
"created.\n"
"Returns `:ok` if successful, or `{:error, reason}` if an error occurs.\n"
"\n"
"Typical error reasons are:\n"
"\n"
"  * `:eacces`  - missing search or write permissions for the parent\n"
"                 directories of `path`\n"
"  * `:enospc`  - there is a no space left on the device\n"
"  * `:enotdir` - a component of `path` is not a directory\n"
msgstr ""
"`path`ディレクトリの作成を試みます。親ディレクトリが存在しない場合、作\n"
"成されます。\n"
"\n"
"典型的なエラーは以下のとおりです:\n"
"\n"
"  * `:eacces`  - `path`の親ディレクトリへの検索または書込みパーミッションがな"
"い\n"
"  * `:enospc`  - デバイスの残り容量がない\n"
"  * `:enotdir` - `path`の一部がディレクトリでない;\n"

#. TRANSLATORS: def File.touch(path, time \\ :calendar.local_time())
#: lib/file.ex:363
msgid ""
"Updates modification time (mtime) and access time (atime) of\n"
"the given file. File is created if it doesn’t exist.\n"
msgstr ""
"与えられたファイルの変更時刻(mtime)とアクセス時刻(atime)を更新します。\n"
"存在しない場合、ファイルは作成されます。\n"

#. TRANSLATORS: Elixir.File Summary
#: lib/file.ex:1
msgid ""
"This module contains functions to manipulate files.\n"
"\n"
"Some of those functions are low-level, allowing the user\n"
"to interact with the file or IO devices, like `open/2`,\n"
"`copy/3` and others. This module also provides higher\n"
"level functions that work with filenames and have their naming\n"
"based on UNIX variants. For example, one can copy a file\n"
"via `cp/3` and remove files and directories recursively\n"
"via `rm_rf/1`\n"
"\n"
"## Encoding\n"
"\n"
"In order to write and read files, one must use the functions\n"
"in the `IO` module. By default, a file is opened in binary mode\n"
"which requires the functions `IO.binread/2` and `IO.binwrite/2`\n"
"to interact with the file. A developer may pass `:utf8` as an\n"
"option when opening the file, then the slower `IO.read/2` and\n"
"`IO.write/2` functions must be used as they are responsible for\n"
"doing the proper conversions and data guarantees.\n"
"\n"
"Note that filenames when given as char lists in Elixir are\n"
"always treated as UTF-8. In particular, we expect that the\n"
"shell and the operating system are configured to use UTF8\n"
"encoding. Binary filenames are considering raw and passed\n"
"to the OS as is.\n"
"\n"
"## API\n"
"\n"
"Most of the functions in this module return `:ok` or\n"
"`{:ok, result}` in case of success, `{:error, reason}`\n"
"otherwise. Those function are also followed by a variant\n"
"that ends with `!` which returns the result (without the\n"
"`{:ok, result}` tuple) in case of success or raises an\n"
"exception in case it fails. For example:\n"
"\n"
"    File.read(\"hello.txt\")\n"
"    #=> {:ok, \"World\"}\n"
"\n"
"    File.read(\"invalid.txt\")\n"
"    #=> {:error, :enoent}\n"
"\n"
"    File.read!(\"hello.txt\")\n"
"    #=> \"World\"\n"
"\n"
"    File.read!(\"invalid.txt\")\n"
"    #=> raises File.Error\n"
"\n"
"In general, a developer should use the former in case they want\n"
"to react if the file does not exist. The latter should be used\n"
"when the developer expects their software to fail in case the\n"
"file cannot be read (i.e. it is literally an exception).\n"
"\n"
"## Processes and raw files\n"
"\n"
"Every time a file is opened, Elixir spawns a new process. Writing\n"
"to a file is equivalent to sending messages to that process that\n"
"writes to the file descriptor.\n"
"\n"
"This means files can be passed between nodes and message passing\n"
"guarantees they can write to the same file in a network.\n"
"\n"
"However, you may not always want to pay the price for this abstraction.\n"
"In such cases, a file can be opened in `:raw` mode. The options `:"
"read_ahead`\n"
"and `:delayed_write` are also useful when operating large files or\n"
"working with files in tight loops.\n"
"\n"
"Check http://www.erlang.org/doc/man/file.html#open-2 for more information\n"
"about such options and other performance considerations.\n"
msgstr ""
"このモジュールはファイルを操作するための関数を含みます。\n"
"\n"
"それらの関数の幾つかは`open/2`, `copy/3`やその他のように、低レベルでファ\n"
"イルあるいはIOデバイスと相互作用することを許します。このモジュールはファ\n"
"イル名とともに動作し、UNIX族に基いた命名の高レベルの関数も提供します。\n"
"例えば、`cp/3`によりファイルのコピーができ、`rm_rf/1`により再帰的に\n"
"ファイルとディレクトリを削除できます。\n"
"\n"
"## エンコーディング\n"
"\n"
"ファイルを読み書きするために、`IO`モジュールの関数を使わなければなりま\n"
"せん。デフォルトではファイルは相互作用するために`IO.binread/2`と\n"
"`IO.binwrite/2`を必要とするバイナリモードでオープンされます。開発者はファ\n"
"イルをオープンするときに、適当な変換とデータの保証の役割をより遅い\n"
"`IO.read/2`と`IO.write/2`に負わせるために、オプションとして`:utf8`を付\n"
"けるかもしれません。\n"
"\n"
"Elixirで文字のリストとして与えられたファイル名は、常にUTF-8として\n"
"扱われることに注意してください。特に、シェルとオペレーティングシステムが\n"
"UTF8エンコーディングを使用するように構成されていると仮定しています。\n"
"バイナリのファイル名はrawであるとみなしてOSへそのままパスされます。\n"
"\n"
"## API\n"
"\n"
"このモジュールのほとんどの関数は成功時に`:ok`あるいは、`{:ok,\n"
"result}`を返し、さもなくば`{:error, reason}`を返します。それらの関数の\n"
"後ろに`!`が付くバージョンもあり、それらは、成功時(`{:ok, result}`タプル\n"
"なしで)resultを返し、失敗時に例外を上げます。\n"
"例えば:\n"
"\n"
"    File.read(\"hello.txt\")\n"
"    #=> {:ok, \"World\"}\n"
"\n"
"    File.read(\"invalid.txt\")\n"
"    #=> {:error, :enoent}\n"
"\n"
"    File.read!(\"hello.txt\")\n"
"    #=> \"World\"\n"
"\n"
"    File.read!(\"invalid.txt\")\n"
"    #=> raises File.Error\n"
"\n"
"一般に、開発者はファイルが存在しないケースに反応したい場合には\n"
"前者を使うべきです。ファイルが読むことが出来ないケースに\n"
"ソフトウエアが失敗すると考えている場合(すなわち、\n"
"それは文字通り例外です)には、後者を使うべきです。\n"
"\n"
"## プロセスとrawファイル\n"
"\n"
"ファイルがオープンされる度に、Elixirは新しいプロセスを生みます。ファイ\n"
"ルへ書くことは、そのファイル記述子に書き込むプロセスへメッセージを送信\n"
"することと等しいです。\n"
"\n"
"これはファイルはノード間で受け渡すことが出来ること、メッセージ\n"
"パッシングはネットワークで同じファイルに書き込むことが出来ることを\n"
"保証していることを意味します。\n"
"\n"
"しかしながら、必ずしもこの抽象概念の対価を支払わなくてもよいです。その\n"
"様な場合、`:raw`モードでオープンすることができます。`:read_ahead`オプショ\n"
"ンと`:delayed_write`オプションも巨大なファイルの操作やタイトなループに\n"
"おいての作業に役に立ちます。\n"
"\n"
"それらのオプションとその他パフォーマンスの考慮点についての詳細は、\n"
"http://www.erlang.org/doc/man/file.html#open-2 をチェックしてください。\n"

#. TRANSLATORS: def File.cd(path)
#: lib/file.ex:1080
msgid ""
"Sets the current working directory.\n"
"\n"
"Returns `:ok` if successful, `{:error, reason}` otherwise.\n"
msgstr ""
"カレントワーキングディレクトリをセットします。\n"
"\n"
"成功したら`:ok`を、さもなければ`{:error, reason}`を返します。\n"

#. TRANSLATORS: def File.stream!(path, modes \\ [], line_or_bytes \\ :line)
#: lib/file.ex:1182
msgid ""
"Returns a `File.Stream` for the given `path` with the given `modes`.\n"
"\n"
"The stream implements both `Enumerable` and `Collectable` protocols,\n"
"which means it can be used both for read and write.\n"
"\n"
"The `line_or_byte` argument configures how the file is read when\n"
"streaming, by `:line` (default) or by a given number of bytes.\n"
"\n"
"Operating the stream can fail on open for the same reasons as\n"
"`File.open!/2`. Note that the file is automatically opened only and\n"
"every time streaming begins. There is no need to pass `:read` and\n"
"`:write` modes, as those are automatically set by Elixir.\n"
"\n"
"## Raw files\n"
"\n"
"Since Elixir controls when the streamed file is opened, the underlying\n"
"device cannot be shared and as such it is convenient to open the file\n"
"in raw mode for performance reasons. Therefore, Elixir **will** open\n"
"streams in `:raw` mode with the `:read_ahead` option unless an encoding\n"
"is specified.\n"
"\n"
"One may also consider passing the `:delayed_write` option if the stream\n"
"is meant to be written to under a tight loop.\n"
msgstr ""
"与えられた`path`について、与えられた`modes`での`File.Stream`を返します。\n"
"\n"
"ストリームは`Enumerable`と`Collectable`プロトコルの両方を実装していて、\n"
"これは読み書きの両方が出来ることを意味します。\n"
"\n"
"`line_or_byte`引数は、ファイルがストリーミングされるときの方法を、\n"
"`:line`(デフォルト)か、与えられたバイト数毎か、を構成します。\n"
"\n"
"オペレーティングシステムは`File.open!/2`と同じreasonでオープンに失敗す\n"
"ることがあります。ストリーミングは開始される毎に、ファイルは自動的にオー\n"
"プンされるだけであることに、注意してください。`:read`や`:write`モードは\n"
"Elixirにより自動的にセットされるので指定する必要はありません。\n"
"\n"
"## Rawファイル\n"
"\n"
"ストリームファイルが何時オープンされるかを、Elixirが制御するので、下層\n"
"のデバイスは共有されることはありません。ですので、パフォーマンス上の理\n"
"由からrawモードでファイルをオープンすることは便利です。従って、エンコー\n"
"ディングが指定されない限り、Elixirは、`:read_ahead`オプション付の\n"
"`:raw`モードでストリームをオープン ** します ** 。\n"
"\n"
"人は、もしストリームが堅いループ中で書き込みされるはずなら、\n"
"`:delayed_write`オプションをパスすることを考慮するかもしれません。\n"

#. TRANSLATORS: def File.read(path)
#: lib/file.ex:230
msgid ""
"Returns `{:ok, binary}`, where `binary` is a binary data object that "
"contains the contents\n"
"of `path`, or `{:error, reason}` if an error occurs.\n"
"\n"
"Typical error reasons:\n"
"\n"
"  * `:enoent`  - the file does not exist\n"
"  * `:eacces`  - missing permission for reading the file,\n"
"                 or for searching one of the parent directories\n"
"  * `:eisdir`  - the named file is a directory\n"
"  * `:enotdir` - a component of the file name is not a directory;\n"
"                 on some platforms, `:enoent` is returned instead\n"
"  * `:enomem`  - there is not enough memory for the contents of the file\n"
"\n"
"You can use `:file.format_error/1` to get a descriptive string of the "
"error.\n"
msgstr ""
"`binary`を`path`の内容を含むバイナリデータオブジェクトとして、\n"
"`{:ok, binary}`を返します。または、エラーが起きると`{:error, reason}`を\n"
"返します。\n"
"\n"
"典型的なエラー reason は以下の通りです:\n"
"\n"
"  * `:enoent`  - ファイルが存在しない\n"
"  * `:eacces`  - ファイルを読むため、または、親ディレクトリのサーチ\n"
"                 するためのパーミッションが無い\n"
"  * `:eisdir`  - その名前のファイルはディレクトリです\n"
"  * `:enotdir` - ファイル名を構成する一部がディレクトリでない;\n"
"                 幾つかのプラットフォームではかわりに`:enoent`が返される。\n"
"  * `:enomem`  - ファイルの内容のための十分なメモりがない\n"
"\n"
"エラーの記述文字列を得るために`:file.format_error/1`を使うことができます。\n"

#. TRANSLATORS: def File.regular?(path)
#: lib/file.ex:94
msgid ""
"Returns `true` if the path is a regular file.\n"
"\n"
"## Examples\n"
"\n"
"    File.regular? __ENV__.file #=> true\n"
"\n"
msgstr ""
"もし、pathが通常ファイルなら、`true`を返します。\n"
"\n"
"## 例\n"
"\n"
"    File.regular? __ENV__.file #=> true\n"
"\n"

#. TRANSLATORS: def File.dir?(path)
#: lib/file.ex:102
msgid "Returns `true` if the path is a directory.\n"
msgstr "もし、pathがディレクトリなら、`true`を返します。\n"

#. TRANSLATORS: def File.exists?(path)
#: lib/file.ex:124
msgid ""
"Returns `true` if the given path exists.\n"
"It can be regular file, directory, socket,\n"
"symbolic link, named pipe or device file.\n"
"\n"
"## Examples\n"
"\n"
"    File.exists?(\"test/\")\n"
"    #=> true\n"
"\n"
"    File.exists?(\"missing.txt\")\n"
"    #=> false\n"
"\n"
"    File.exists?(\"/dev/null\")\n"
"    #=> true\n"
"\n"
msgstr ""
"与えられたパスが存在するなら、`true`を返します。\n"
"標準ファイル、ディレクトリ、ソケット、シンボリックリンク、\n"
"名前付きパイプあるいはデバイスファイルが有り得ます。\n"
"\n"
"## 例\n"
"\n"
"    File.exists?(\"test/\")\n"
"    #=> true\n"
"\n"
"    File.exists?(\"missing.txt\")\n"
"    #=> false\n"
"\n"
"    File.exists?(\"/dev/null\")\n"
"    #=> true\n"
"\n"

#. TRANSLATORS: def File.rm_rf(path)
#: lib/file.ex:806
msgid ""
"Removes files and directories recursively at the given `path`.\n"
"Symlinks are not followed but simply removed, non-existing\n"
"files are simply ignored (i.e. doesn't make this function fail).\n"
"\n"
"Returns `{:ok, files_and_directories}` with all files and\n"
"directories removed in no specific order, `{:error, reason, file}`\n"
"otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    File.rm_rf \"samples\"\n"
"    #=> {:ok, [\"samples\", \"samples/1.txt\"]}\n"
"\n"
"    File.rm_rf \"unknown\"\n"
"    #=> {:ok, []}\n"
"\n"
msgstr ""
"与えられた`path`を再帰的にファイルとディレクトリを削除します。\n"
"シンボリックリンクは辿らずに単に削除します。\n"
"存在しないファイルは単に無視されます(即ち、この関数は失敗しません)。\n"
"\n"
"削除した全てのファイルとディレクトリの順不同のリストを\n"
"file_and_directoriesとして、`{:ok, file_and_directories}`を返します。\n"
"さもなくば、`{:error, reason, file}`を返します。\n"
"\n"
"## 例\n"
"\n"
"    File.rm_rf \"samples\"\n"
"    #=> {:ok, [\"samples\", \"samples/1.txt\"]}\n"
"\n"
"    File.rm_rf \"unknown\"\n"
"    #=> {:ok, []}\n"
"\n"

#. TRANSLATORS: def File.open(path, modes, function)
#: lib/file.ex:995
msgid ""
"Similar to `open/2` but expects a function as last argument.\n"
"\n"
"The file is opened, given to the function as argument and\n"
"automatically closed after the function returns, regardless\n"
"if there was an error when executing the function.\n"
"\n"
"It returns `{:ok, function_result}` in case of success,\n"
"`{:error, reason}` otherwise.\n"
"\n"
"This function expects the file to be closed with success,\n"
"which is usually the case unless the `:delayed_write` option\n"
"is given. For this reason, we do not recommend passing\n"
"`:delayed_write` to this function.\n"
"\n"
"## Examples\n"
"\n"
"    File.open(\"file.txt\", [:read, :write], fn(file) ->\n"
"      IO.read(file, :line)\n"
"    end)\n"
"\n"
msgstr ""
"`open/2`と似ていますが、最後の引数として関数を期待しています。\n"
"\n"
"ファイルは、オープンされ、関数の引数として与えられ、\n"
"関数が戻った後に自動的にクローズされ、\n"
"関数が実行しているときにエラーがあっても気にしません。\n"
"\n"
"成功すると`{:ok, function_result}`を返し、さもなければ\n"
"`{:error, reason}`を返します。\n"
"\n"
"この関数は、成功で閉じられることを期待します。そしてそれは\n"
"`:delayed_write`オプションが与えられない限り正しいです。この理由からこ\n"
"の関数に`deleyed_write`を指定することを薦めません。\n"
"\n"
"## 例\n"
"\n"
"    File.open(\"file.txt\", [:read, :write], fn(file) ->\n"
"      IO.read(file, :line)\n"
"    end)\n"
"\n"

#. TRANSLATORS: def File.write_stat!(path, stat, opts \\ [])
#: lib/file.ex:349
msgid ""
"Same as `write_stat/3` but raises an exception if it fails.\n"
"Returns `:ok` otherwise.\n"
msgstr ""
"`write_state/3`と同じですが、失敗すると例外を上げます。\n"
"さもなくば`:ok`を返します。\n"

#. TRANSLATORS: def File.write!(path, content, modes \\ [])
#: lib/file.ex:679
msgid ""
"Same as `write/3` but raises an exception if it fails, returns `:ok` "
"otherwise.\n"
msgstr ""
"`write/3`と同じですが、失敗すると例外を上げます。さもなくば`:ok`を\n"
"返します。\n"

#. TRANSLATORS: def File.touch!(path, time \\ :calendar.local_time())
#: lib/file.ex:383
msgid ""
"Same as `touch/2` but raises an exception if it fails.\n"
"Returns `:ok` otherwise.\n"
msgstr ""
"`touch/2`と同じですが、失敗すると例外を上げます。さもなくば\n"
"`:ok`を返します。\n"

#. TRANSLATORS: def File.stat!(path, opts \\ [])
#: lib/file.ex:283
msgid ""
"Same as `stat/2` but returns the `File.Stat` directly and\n"
"throws `File.Error` if an error is returned.\n"
msgstr ""
"`stat/2`と同じですが、もしエラーが帰って来たら`File.Stat`を直接返さず、\n"
"`File.Errorを投げます。\n"

#. TRANSLATORS: def File.cwd()
#: lib/file.ex:1046
msgid ""
"Gets the current working directory.\n"
"\n"
"In rare circumstances, this function can fail on Unix. It may happen\n"
"if read permission does not exist for the parent directories of the\n"
"current directory. For this reason, returns `{:ok, cwd}` in case\n"
"of success, `{:error, reason}` otherwise.\n"
msgstr ""
"カレントワーキングディレクトリを返します。\n"
"\n"
"稀な状況では、この関数はUnixで失敗することがあります。カレントディレク\n"
"トリの親ディレクトリの読み込み許可がない場合、それは起きるかもしれませ\n"
"ん。この理由で、成功したら`{:ok, cwd}`(さもなければ`{:error, reason}`)\n"
"が返ります。\n"

#. TRANSLATORS: def File.open(path, modes \\ [])
#: lib/file.ex:962
msgid ""
"Opens the given `path` according to the given list of modes.\n"
"\n"
"In order to write and read files, one must use the functions\n"
"in the `IO` module. By default, a file is opened in binary mode\n"
"which requires the functions `IO.binread/2` and `IO.binwrite/2`\n"
"to interact with the file. A developer may pass `:utf8` as an\n"
"option when opening the file and then all other functions from\n"
"`IO` are available, since they work directly with Unicode data.\n"
"\n"
"The allowed modes:\n"
"\n"
"  * `:read` - the file, which must exist, is opened for reading.\n"
"\n"
"  * `:write` - the file is opened for writing. It is created if it does not\n"
"    exist.\n"
"\n"
"    If the file does exists, and if write is not combined with read, the "
"file\n"
"    will be truncated.\n"
"\n"
"  * `:append` - the file will be opened for writing, and it will be created\n"
"    if it does not exist. Every write operation to a file opened with "
"append\n"
"    will take place at the end of the file.\n"
"\n"
"  * `:exclusive` - the file, when opened for writing, is created if it does\n"
"    not exist. If the file exists, open will return `{:error, :eexist}`.\n"
"\n"
"  * `:char_list` - when this term is given, read operations on the file "
"will\n"
"    return char lists rather than binaries.\n"
"\n"
"  * `:compressed` - makes it possible to read or write gzip compressed "
"files.\n"
"\n"
"    The compressed option must be combined with either read or write, but "
"not\n"
"    both. Note that the file size obtained with `stat/1` will most probably\n"
"    not match the number of bytes that can be read from a compressed file.\n"
"\n"
"  * `:utf8` - this option denotes how data is actually stored in the disk\n"
"    file and makes the file perform automatic translation of characters to\n"
"    and from utf-8.\n"
"\n"
"    If data is sent to a file in a format that cannot be converted to the\n"
"    utf-8 or if data is read by a function that returns data in a format "
"that\n"
"    cannot cope with the character range of the data, an error occurs and "
"the\n"
"    file will be closed.\n"
"\n"
"Check http://www.erlang.org/doc/man/file.html#open-2 for more information "
"about\n"
"other options like `:read_ahead` and `:delayed_write`.\n"
"\n"
"This function returns:\n"
"\n"
"  * `{:ok, io_device}` - the file has been opened in the requested mode.\n"
"\n"
"    `io_device` is actually the pid of the process which handles the file.\n"
"    This process is linked to the process which originally opened the file.\n"
"    If any process to which the `io_device` is linked terminates, the file\n"
"    will be closed and the process itself will be terminated.\n"
"\n"
"    An `io_device` returned from this call can be used as an argument to "
"the\n"
"    `IO` module functions.\n"
"\n"
"  * `{:error, reason}` - the file could not be opened.\n"
"\n"
"## Examples\n"
"\n"
"    {:ok, file} = File.open(\"foo.tar.gz\", [:read, :compressed])\n"
"    IO.read(file, :line)\n"
"    File.close(file)\n"
"\n"
msgstr ""
"与えられたモードのリストに従って、与えられた`path`をオープンします。\n"
"\n"
"ファイルを読み書きするために、`IO`モジュールの関数を使わなくてはなりま\n"
"せん。デフォルトではファイルは、`IO.binread/2`と`IO.binwrite/2`で相互作\n"
"用することを要求する、バイナリモードでオープンされます。\n"
"開発者はファイルを開くときに、`:utf8`オプションを渡すこともでき、そうすると\n"
"、ユニコードデータで直接動くので、`IO`からの他の全ての関数が有効にな\n"
"ります。\n"
"\n"
"許されたモードは以下のとおりです:\n"
"\n"
"  * `:read` - ファイルは存在していなくてはならず、読み込みのためにオープンさ"
"れます\n"
"\n"
"  * `:write` - ファイルは書き込みの為にオープンされます。もしなければ、\n"
"              作られます。\n"
"\n"
"    もしファイルが存在して、そして、もしwriteがreadと一緒に指定されないな"
"ら、\n"
"    ファイルはトランケートされます。\n"
"\n"
"  * `:append` - ファイルは書き込みの為にオープンされ、もし存在しないなら、\n"
"    作成されます。appendでオープンされたファイルへの、それぞれの書込み\n"
"    オペレーションは、ファイルの終わりの場所に行われます。\n"
"\n"
"  * `:exclusive` - 書き込みの為にオープンされたファイルは、存在しないなら\n"
"    作成されます。もしファイルが存在したらopenは`{:error, :eexist}`を返しま"
"す。\n"
"\n"
"  * `:char_list` - これが指定されたら、ファイルの読み込み\n"
"    オペレーションはバイナリではなく文字のリストを返します。\n"
"\n"
"  * `:compressed` - gzipで圧縮されたファイルを読み書きすることを可能にしま"
"す。\n"
"\n"
"    compressedオプションはreadかwriteの両方ではなく、どちらか一方と一緒に\n"
"    指定されなければなりません。\n"
"    `stat/1`で得られるファイルサイズは、圧縮ファイルから読み込むことができ"
"る\n"
"     バイト数と、多分マッチしないことに注意してください。\n"
"\n"
"  * `:utf8` - このオプションは、ディスクファイルに実際に保存される方法\n"
"    を意味して、ファイルに対して、自動的にutf8からまたは、utf8への文字\n"
"    の変換を実行させます。\n"
"\n"
"    もし、データがutf8へ変換出来ないフォーマットでファイルに送信されたら、\n"
"    または、データの文字範囲に対処できないフォーマットでデータを返す関数に\n"
"    よってデータが読み込まれたら、エラーが発生し、ファイルはクローズされま"
"す。\n"
"\n"
"`:read_ahead`や`:delayed_write`といった、他のオプションについての詳細は、\n"
"http://www.erlang.org/doc/man/file.html#open-2をチェックしてください。\n"
"\n"
"この関数は以下を返します:\n"
"\n"
"  * `{:ok, io_device}` - 要求されたモードで、ファイルはオープンされました。\n"
"\n"
"    `io_device`は通常、ファイルを扱うプロセスのpidです。\n"
"    このプロセスはファイルをオープンしたオリジナルのプロセスにリンクしていま"
"す。\n"
"    もし`io_device`がリンクされている任意のプロセスが終了したら、\n"
"    ファイルはクローズされ、そのプロセス自身も終了します。\n"
"\n"
"    この関数から返された`io_device`は、`IO`モジュールの関数に引数として渡\n"
"    されることがあります。\n"
"\n"
"  * `{:error, reason}` - ファイルはオープン出来ませんでした。\n"
"\n"
"## 例\n"
"\n"
"    {:ok, file} = File.open(\"foo.tar.gz\", [:read, :compressed])\n"
"    IO.read(file, :line)\n"
"    File.close(file)\n"
"\n"

#. TRANSLATORS: def File.ln_s(existing, new)
#: lib/file.ex:399
msgid ""
"Creates a symbolic link `new` to the file or directory `existing`.\n"
"\n"
"Returns `:ok` if successful, `{:error, reason}` otherwise.\n"
"If the operating system does not support symlinks, returns\n"
"`{:error, :enotsup}`.\n"
msgstr ""
"シンボリックリンク`new`をファイルかディレクトリ`existing`に対して\n"
"作成します。\n"
"\n"
"成功すると`:ok`を返し、さもなければ`{:error, reason}`を返します。\n"
"もしオペレーティングシステムがシンボリックリンクをサポートしていないなら、\n"
"`{:error, :enotsup}`を返します。\n"

#. TRANSLATORS: def File.copy(source, destination, bytes_count \\ :infinity)
#: lib/file.ex:426
msgid ""
"Copies the contents of `source` to `destination`.\n"
"\n"
"Both parameters can be a filename or an io device opened\n"
"with `open/2`. `bytes_count` specifies the number of\n"
"bytes to copy, the default being `:infinity`.\n"
"\n"
"If file `destination` already exists, it is overwritten\n"
"by the contents in `source`.\n"
"\n"
"Returns `{:ok, bytes_copied}` if successful,\n"
"`{:error, reason}` otherwise.\n"
"\n"
"Compared to the `cp/3`, this function is more low-level,\n"
"allowing a copy from device to device limited by a number of\n"
"bytes. On the other hand, `cp/3` performs more extensive\n"
"checks on both source and destination and it also preserves\n"
"the file mode after copy.\n"
"\n"
"Typical error reasons are the same as in `open/2`,\n"
"`read/1` and `write/3`.\n"
msgstr ""
"`source`の内容を`destination`にコピーします。\n"
"\n"
"両方のパラメタは、ファイル名か、`open/2`でオープンされたIOデバイスです。\n"
"`bytes_count`はコピーするバイト数を指定します。デフォルトは\n"
"`:infinity`です。\n"
"\n"
"もしファイル`destination`が既に存在していたら、`source`の\n"
"内容によって上書きされます。\n"
"\n"
"成功すれば、`{:ok, bytes_copied}`を返し、さもなくば、\n"
"`{:error, reason}`を返します。\n"
"\n"
"`cp/3`と比較して、この関数はより低レベルで、デバイスからデバイスへの\n"
"コピーについて、バイト数で制限することを許します。\n"
"一方で、`cp/3`は、\n"
"ソースとデスティネーションの両方でより広範位なチェックを実行し、\n"
"コピーの後で、ファイルモードを維持します。\n"
"\n"
"典型的なエラーreasonは`open/2`、`read/2`、`write/3`と同じです。\n"

#. TRANSLATORS: def File.cp_r(source, destination, callback \\ fn _, _ -> true end)
#: lib/file.ex:537
msgid ""
"Copies the contents in source to destination.\n"
"\n"
"If the source is a file, it copies `source` to\n"
"`destination`. If the source is a directory, it copies\n"
"the contents inside source into the destination.\n"
"\n"
"If a file already exists in the destination,\n"
"it invokes a callback which should return\n"
"`true` if the existing file should be overwritten,\n"
"`false` otherwise. It defaults to return `true`.\n"
"\n"
"If a directory already exists in the destination\n"
"where a file is meant to be (or otherwise), this\n"
"function will fail.\n"
"\n"
"This function may fail while copying files,\n"
"in such cases, it will leave the destination\n"
"directory in a dirty state, where already\n"
"copied files won't be removed.\n"
"\n"
"It returns `{:ok, files_and_directories}` in case of\n"
"success with all files and directories copied in no\n"
"specific order, `{:error, reason, file}` otherwise.\n"
"\n"
"Note: The command `cp` in Unix systems behaves differently\n"
"depending if `destination` is an existing directory or not.\n"
"We have chosen to explicitly disallow this behaviour.\n"
"\n"
"## Examples\n"
"\n"
"    # Copies \"a.txt\" to \"tmp\"\n"
"    File.cp_r \"a.txt\", \"tmp.txt\"\n"
"\n"
"    # Copies all files in \"samples\" to \"tmp\"\n"
"    File.cp_r \"samples\", \"tmp\"\n"
"\n"
"    # Same as before, but asks the user how to proceed in case of conflicts\n"
"    File.cp_r \"samples\", \"tmp\", fn(source, destination) ->\n"
"      IO.gets(\"Overwriting #{destination} by #{source}. Type y to confirm."
"\") == \"y\"\n"
"    end\n"
"\n"
msgstr ""
"sourceの内容をdestinationへコピーします。\n"
"\n"
"Copies the contents in source to destination.\n"
"\n"
"もしsourceがファイルなら、`source`を`destination`へコピーします。\n"
"もしsourceがディレクトリなら、sourceの中のコンテンツを\n"
"destinationにコピーします。\n"
"\n"
"もしデスティネーションにファイルが存在したら、\n"
"callbackが起動され、そのファイルは上書きされる\n"
"べきなら、`true`を返し、さもなくば、\n"
"`false`を返すようにします。デフォルトのコールバック\n"
"は`true`を返します。\n"
"\n"
"ファイルがあるはずであるデスティネーションに\n"
"ディレクトリが既に存在するか、ファイルがないなら、\n"
"この関数は失敗します。\n"
"\n"
"この関数はファイルのコピー中に失敗するかもしれません。そのような場合、\n"
"デスティネーションディレクトリをダーティステートのままです。つまり、既\n"
"にコピーしたファイルは削除されません。\n"
"\n"
"成功すると、順不同でコピーされたファイルとディレクトリすべてを`{:ok,\n"
"files_and_directories}`で返します。\n"
"さもなければ、`{:error, reason, file}`を返します。\n"
"\n"
"注意: Unixシステムの`cp`コマンドは、`destination`が既存の\n"
"ディレクトリか否かで異った振る舞いをします。我々は、この振る舞いを\n"
"明確に認めないほうを選びました。\n"
"\n"
"## 例\n"
"\n"
"    # Copies \"a.txt\" to \"tmp\"\n"
"    File.cp_r \"a.txt\", \"tmp.txt\"\n"
"\n"
"    # Copies all files in \"samples\" to \"tmp\"\n"
"    File.cp_r \"samples\", \"tmp\"\n"
"\n"
"    # Same as before, but asks the user how to proceed in case of conflicts\n"
"    File.cp_r \"samples\", \"tmp\", fn(source, destination) ->\n"
"      IO.gets(\"Overwriting #{destination} by #{source}. Type y to confirm."
"\") == \"y\"\n"
"    end\n"
"\n"

#. TRANSLATORS: def File.cp(source, destination, callback \\ fn _, _ -> true end)
#: lib/file.ex:466
msgid ""
"Copies the contents in `source` to `destination` preserving its mode.\n"
"\n"
"If a file already exists in the destination, it invokes a\n"
"callback which should return `true` if the existing file\n"
"should be overwritten, `false` otherwise. It defaults to return `true`.\n"
"\n"
"It returns `:ok` in case of success, returns\n"
"`{:error, reason}` otherwise.\n"
"\n"
"If you want to copy contents from an io device to another device\n"
"or do a straight copy from a source to a destination without\n"
"preserving modes, check `copy/3` instead.\n"
"\n"
"Note: The command `cp` in Unix systems behaves differently depending\n"
"if `destination` is an existing directory or not. We have chosen to\n"
"explicitly disallow this behaviour. If destination is a directory, an\n"
"error will be returned.\n"
msgstr ""
"sourceの内容をdestinationへ、モードを維持してコピーします。\n"
"\n"
"もしデスティネーションにファイルが存在したら、\n"
"callbackが起動され、そのファイルは上書きされる\n"
"べきなら、`true`を返し、さもなくば、\n"
"`false`を返すようにします。デフォルトのコールバック\n"
"は`true`を返します。\n"
"\n"
"成功すると、`{:ok}を返し、さもなければ、`{:error, reason}`を返します。\n"
"\n"
"もしIOデバイスから他のデバイスへコピーしたいとか、直接\n"
"sourceからdestinationへモードの維持なしでコピーしたいなら、代りに\n"
"`copy/3`をチェックしてください。\n"
"\n"
"注意: Unixシステムの`cp`コマンドは、`destination`が既存の\n"
"ディレクトリか否かで異った振る舞いをします。我々は、この振る舞いを\n"
"明確に認めないほうを選びました。もしdestinationがディレクトリなら、\n"
"エラーを返します。\n"

#. TRANSLATORS: def File.close(io_device)
#: lib/file.ex:1153
msgid ""
"Closes the file referenced by `io_device`. It mostly returns `:ok`, except\n"
"for some severe errors such as out of memory.\n"
"\n"
"Note that if the option `:delayed_write` was used when opening the file,\n"
"`close/1` might return an old write error and not even try to close the "
"file.\n"
"See `open/2`.\n"
msgstr ""
"`io_device`により参照されるファイルをクローズします。\n"
"out of memoryのようないくつかの深刻なエラーを除いて、\n"
"殆ど`:ok`を返します。\n"
"\n"
"ファイルをオープンするときに、`:delayed_write`オプションが使われていたら、\n"
"`close/1`は古い書き込みエラーを返し、ファイルを閉じようとしないかもしれない\n"
"ことに、注意してください。`open/2`を参照してください。\n"

#. TRANSLATORS: def File.chgrp(path, gid)
#: lib/file.ex:1216
msgid ""
"Changes the user group given by the group id `gid`\n"
"for a given `file`. Returns `:ok` on success, or\n"
"`{:error, reason}` on failure.\n"
msgstr ""
"与えられた`file`について、ユーザグループを\n"
"与えられたグループID`gid`に、変更します。\n"
"成功したら`:ok`を返し、失敗したら`{:error, reason}`を\n"
"返します。\n"

#. TRANSLATORS: def File.chmod(path, mode)
#: lib/file.ex:1193
msgid ""
"Changes the unix file `mode` for a given `file`.\n"
"Returns `:ok` on success, or `{:error, reason}`\n"
"on failure.\n"
msgstr ""
"与えられた`file`について、unixファイル`mode`に変更します。\n"
"成功したら`:ok`を返し、失敗したら`{:error, reason}`を\n"
"返します。\n"

#. TRANSLATORS: def File.chown(path, uid)
#: lib/file.ex:1239
msgid ""
"Changes the owner given by the user id `uid`\n"
"for a given `file`. Returns `:ok` on success,\n"
"or `{:error, reason}` on failure.\n"
msgstr ""
"与えられた`file`について、オーナを、ユーザID`uid`に変更します。成功した\n"
"ら`:ok`を返し、失敗したら`{:error, reason}`を返します。\n"

#. TRANSLATORS: def File.cd!(path, function)
#: lib/file.ex:1106
msgid ""
"Changes the current directory to the given `path`,\n"
"executes the given function and then revert back\n"
"to the previous path regardless if there is an exception.\n"
"\n"
"Raises an error if retrieving or changing the current\n"
"directory fails.\n"
msgstr ""
"与えられた`path`に、カレントディレクトリを変更し、\n"
"与えられた関数を実行します。そして、例外が\n"
"あったら、とにかく以前のパスに戻ります。\n"
"\n"
"もしカレントディレクトリを取得するか変更するかに失敗したら、\n"
"エラーが上ります。\n"

#. TRANSLATORS: def File.rmdir!(path)
#: lib/file.ex:778
msgid ""
"Same as `rmdir/1`, but raises an exception in case of failure. Otherwise `:"
"ok`.\n"
msgstr ""
"`rmdir/1`と同じですが、失敗すると例外を上げます。さもなくば`:ok`を\n"
"返します。\n"

#. TRANSLATORS: def File.rm_rf!(path)
#: lib/file.ex:881
msgid ""
"Same as `rm_rf/1` but raises `File.Error` in case of failures,\n"
"otherwise the list of files or directories removed.\n"
msgstr ""
"`rm_rf/1`と同じですが、失敗すると`File.Error`を上げます。\n"
"さもなくば削除されたファイルやディレクトリのリストを返します。\n"

#. TRANSLATORS: def File.rm!(path)
#: lib/file.ex:747
msgid ""
"Same as `rm/1`, but raises an exception in case of failure. Otherwise `:"
"ok`.\n"
msgstr ""
"`rm/1`と同じですが、失敗すると例外を上げます。さもなくば`:ok`を返し\n"
"ます。\n"

#. TRANSLATORS: def File.open!(path, modes, function)
#: lib/file.ex:1028
msgid ""
"Same as `open/3` but raises an error if file could not be opened.\n"
"\n"
"Returns the function result otherwise.\n"
msgstr ""
"`open/3`と同じですが、オープンできないとエラーを上げます。\n"
"\n"
"さもないと関数の実行結果を返します。\n"

#. TRANSLATORS: def File.open!(path, modes \\ [])
#: lib/file.ex:1013
msgid ""
"Same as `open/2` but raises an error if file could not be opened.\n"
"\n"
"Returns the `io_device` otherwise.\n"
msgstr ""
"`open/2`と同じですが、オープンできないとエラーを上げます。\n"
"\n"
"さもなければ`io_device`を返します。\n"

#. TRANSLATORS: def File.mkdir_p!(path)
#: lib/file.ex:204
msgid ""
"Same as `mkdir_p/1`, but raises an exception in case of failure. Otherwise `:"
"ok`.\n"
msgstr ""
"`mkdir_p/1`と同じですが、失敗すると例外を上げます。さもなくば\n"
"`:ok`を返します。\n"

#. TRANSLATORS: def File.mkdir!(path)
#: lib/file.ex:151
msgid ""
"Same as `mkdir/1`, but raises an exception in case of failure. Otherwise `:"
"ok`.\n"
msgstr ""
"`mkdir/1`と同じですが、失敗すると例外を上げます。さもなくば\n"
"`:ok`を返します。\n"

#. TRANSLATORS: def File.lstat!(path, opts \\ [])
#: lib/file.ex:326
msgid ""
"Same as `lstat/2` but returns the `File.Stat` directly and\n"
"throws `File.Error` if an error is returned.\n"
msgstr ""
"`stat/2`と同じですが、もしエラーが帰って来たら`File.Stat`を\n"
"直接返さず、`File.Errorを投げます。\n"

#. TRANSLATORS: def File.chown!(path, uid)
#: lib/file.ex:1247
msgid ""
"Same as `chown/2`, but raises an exception in case of failure. Otherwise `:"
"ok`.\n"
msgstr ""
"`chown/2`と同じですが、失敗すると例外を上げます。さもなくば\n"
"`:ok`を返します。\n"

#. TRANSLATORS: def File.chmod!(path, mode)
#: lib/file.ex:1201
msgid ""
"Same as `chmod/2`, but raises an exception in case of failure. Otherwise `:"
"ok`.\n"
msgstr ""
"`chmod/2`と同じですが、失敗すると例外を上げます。さもなくば\n"
"`:ok`を返します。\n"

#. TRANSLATORS: def File.chgrp!(path, gid)
#: lib/file.ex:1224
msgid ""
"Same as `chgrp/2`, but raises an exception in case of failure. Otherwise `:"
"ok`.\n"
msgstr ""
"`chgrp/2`と同じですが、失敗すると例外を上げます。さもなくば\n"
"`:ok`を返します。\n"

#. TRANSLATORS: def File.ls(path \\ ".")
#: lib/file.ex:1123
msgid ""
"Returns list of files in the given directory.\n"
"\n"
"It returns `{:ok, [files]}` in case of success,\n"
"`{:error, reason}` otherwise.\n"
msgstr ""
"与えられたディレクトリの中のファイルのリストを返します。\n"
"\n"
"成功すると、`{:ok, [files]}`を、さもなくば、\n"
"`{:error, reason}`を返します。\n"

#. TRANSLATORS: def File.lstat(path, opts \\ [])
#: lib/file.ex:312
msgid ""
"Returns information about the `path`. If the file is a symlink sets \n"
"the `type` to `:symlink` and returns `File.Stat` for the link. For any\n"
"other file, returns exactly the same values as `stat/2`. For more details\n"
"see http://www.erlang.org/doc/man/file.html#read_link_info-2 \n"
"\n"
"## Options\n"
"\n"
"The accepted options are:\n"
"\n"
"  * `:time` - configures how the file timestamps are returned\n"
"\n"
"The values for `:time` can be:\n"
"\n"
"  * `:local` - returns a `{date, time}` tuple using the machine time\n"
"  * `:universal` - returns a `{date, time}` tuple in UTC\n"
"  * `:posix` - returns the time as integer seconds since epoch\n"
"\n"
msgstr ""
"`path`についての、情報を返します。もしファイルがシンボリックリング\n"
"なら、`type`を`:symlink`にセットして、リンクについての`File.Stat`を\n"
"返します。その他のファイルの場合、`stat/2`と全く同じ値を返します。\n"
"詳細は、 http://www.erlang.org/doc/man/file.html#read_link_info-2 を\n"
"参照してください。\n"
"\n"
"## オプション\n"
"\n"
"以下のオプションを受け付けます:\n"
"\n"
"  * `:time` - ファイルのタイムタンプを\n"
"             どのように返すかを構成します\n"
"\n"
"`:time`の値は以下のものが可能です:\n"
"\n"
"  * `:local` - マシンタイムを使い、`{date, time}`タプルを返します。\n"
"  * `:universal` - UTCの`{date, time}`タプルを返します。\n"
"  * `:posix` - epochからの整数の秒数として時刻を返します。\n"
"\n"

#. TRANSLATORS: def File.stat(path, opts \\ [])
#: lib/file.ex:269
msgid ""
"Returns information about the `path`. If it exists, it\n"
"returns a `{:ok, info}` tuple, where info is a\n"
"`File.Stat` struct. Returns `{:error, reason}` with\n"
"the same reasons as `read/1` if a failure occurs.\n"
"\n"
"## Options\n"
"\n"
"The accepted options are:\n"
"\n"
"  * `:time` - configures how the file timestamps are returned\n"
"\n"
"The values for `:time` can be:\n"
"\n"
"  * `:local` - returns a `{date, time}` tuple using the machine time\n"
"  * `:universal` - returns a `{date, time}` tuple in UTC\n"
"  * `:posix` - returns the time as integer seconds since epoch\n"
"\n"
msgstr ""
"`path`についての、情報を返します。もしあれば、infoが`File.Stat`構造体と\n"
"して、`{:ok, info}`タプルを返します。失敗が発生したら、`read/1`と同じ\n"
"reasonで、`{:error, reason}`を返します。\n"
"\n"
"## オプション\n"
"\n"
"以下のオプションを受け付けます:\n"
"\n"
"  * `:time` - ファイルのタイムタンプを\n"
"             どのように返すかを構成します\n"
"\n"
"`:time`の値は以下のものが可能です:\n"
"\n"
"  * `:local` - マシンタイムを使い、`{date, time}`タプルを返します。\n"
"  * `:universal` - UTCの`{date, time}`タプルを返します。\n"
"  * `:posix` - epochからの整数の秒数として時刻を返します。\n"
"\n"

#. TRANSLATORS: def File.read!(path)
#: lib/file.ex:239
msgid ""
"Returns binary with the contents of the given filename or raises\n"
"`File.Error` if an error occurs.\n"
msgstr ""
"与えられたファイル名の内容をバイナリで返します。\n"
"あるいは、エラーが起きたら`File.Error`を上げます。\n"
