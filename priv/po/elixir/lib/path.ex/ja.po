msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2016-02-27 21:33+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: def Path.split(path)
#: lib/path.ex:488
msgid ""
"Splits the path into a list at the path separator.\n"
"\n"
"If an empty string is given, returns an empty list.\n"
"\n"
"On Windows, path is split on both \"\\\" and \"/\" separators\n"
"and the driver letter, if there is one, is always returned\n"
"in lowercase.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.split(\"\")\n"
"    []\n"
"\n"
"    iex> Path.split(\"foo\")\n"
"    [\"foo\"]\n"
"\n"
"    iex> Path.split(\"/foo/bar\")\n"
"    [\"/\", \"foo\", \"bar\"]\n"
"\n"
msgstr ""
"パスをパスセパレータでリストに分割します。\n"
"\n"
"もし空文字列を与えられたら、空リストを返します。\n"
"\n"
"Windowsでは、パスは\"\\\"と\"/\"の両方と、もしあれば、ドライブレターで\n"
"分割されます。そして通常、小文字で返されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Path.split(\"\")\n"
"    []\n"
"\n"
"    iex> Path.split(\"foo\")\n"
"    [\"foo\"]\n"
"\n"
"    iex> Path.split(\"/foo/bar\")\n"
"    [\"/\", \"foo\", \"bar\"]\n"
"\n"

#. TRANSLATORS: def Path.wildcard(glob, opts \\ [])
#: lib/path.ex:549
msgid ""
"Traverses paths according to the given `glob` expression, and returns a\n"
"list of matches.\n"
"\n"
"The wildcard looks like an ordinary path, except that certain\n"
"\"wildcard characters\" are interpreted in a special way. The\n"
"following characters are special:\n"
"\n"
"  * `?` - matches one character\n"
"\n"
"  * `*` - matches any number of characters up to the end of the filename, "
"the\n"
"    next dot, or the next slash\n"
"\n"
"  * `**` - two adjacent `*`'s used as a single pattern will match all\n"
"    files and zero or more directories and subdirectories\n"
"\n"
"  * `[char1, char2, ...]` - matches any of the characters listed; two\n"
"    characters separated by a hyphen will match a range of characters\n"
"\n"
"  * `{item1, item2, ...}` - matches one of the alternatives\n"
"\n"
"Other characters represent themselves. Only paths that have\n"
"exactly the same character in the same position will match. Note\n"
"that matching is case-sensitive; i.e. \"a\" will not match \"A\".\n"
"\n"
"By default, the patterns `*` and `?` do not match files starting\n"
"with a dot `.` unless `match_dot: true` is given in `opts`.\n"
"\n"
"## Examples\n"
"\n"
"Imagine you have a directory called `projects` with three Elixir projects\n"
"inside of it: `elixir`, `ex_doc` and `dynamo`. You can find all `.beam` "
"files\n"
"inside the `ebin` directory of each project as follows:\n"
"\n"
"    Path.wildcard(\"projects/*/ebin/**/*.beam\")\n"
"\n"
"If you want to search for both `.beam` and `.app` files, you could do:\n"
"\n"
"    Path.wildcard(\"projects/*/ebin/**/*.{beam,app}\")\n"
"\n"
msgstr ""
"与えられた`glob`表現でパスをトラバースし、マッチしたもののリストを\n"
"返します。\n"
"\n"
"ワイルドカードは普通のパスに見えますが、特定の\"ワイルドカード文字\"は\n"
"特別な方法で解釈されます。以下の文字が特別です:\n"
"\n"
"  * `?` - 一文字にマッチします\n"
"\n"
"  * `*` - ファイル名の終わり、次のドットあるいは、次のスラッシュまでの\n"
"    任意の文字列にマッチします\n"
"\n"
"  * `**` - 一つのパターンとして使われた二つ隣接した`*`は\n"
"    ファイルと0以上のディレクトリとサブディレクトリ全てにマッチします\n"
"\n"
"  * `[char1, char2,...]` - リストされた文字の何れか一つにマッチします; \n"
"     ハイフンで区切られた二つの文字は文字の範囲にマッチします\n"
"\n"
"  * `{item1, item2,...}` - 文字列の何れかひとつにマッチします。\n"
"\n"
"他の文字はそれ自身を表します。正確に同じ場所で同じ文字の場合にだけ\n"
"パスはマッチします。例えば、\"a\"は\"A\"にマッチしません。\n"
"\n"
"`opt`に`matuch_dot: true`オプションを与えない限り、\n"
"デフォルトでは`*`と`?`はファイル名先頭の`.`にはマッチしません。\n"
"\n"
"## 例\n"
"\n"
"`elixir`, `ex_doc`, `dynamo`という三つのElixirプロジェクトを含む\n"
"`projects`と呼ばれるディレクトリをもっているとします。以下のようにして、\n"
"それぞれのプロジェクトの`ebin`ディレクトリの中の`.beam`ファイルを見付け\n"
"ることができます。\n"
"\n"
"    Path.wildcard(\"projects/*/ebin/**/*.beam\")\n"
"\n"
"このようにして`.beam`と`.app`ファイル両方を探すこともできます:\n"
"\n"
"    Path.wildcard(\"projects/*/ebin/**/*.{beam,app}\")\n"
"\n"

#. TRANSLATORS: def Path.relative(name)
#: lib/path.ex:193
msgid ""
"Forces the path to be a relative path.\n"
"\n"
"## Unix examples\n"
"\n"
"    Path.relative(\"/usr/local/bin\")   #=> \"usr/local/bin\"\n"
"    Path.relative(\"usr/local/bin\")    #=> \"usr/local/bin\"\n"
"    Path.relative(\"../usr/local/bin\") #=> \"../usr/local/bin\"\n"
"\n"
"## Windows examples\n"
"\n"
"    Path.relative(\"D:/usr/local/bin\") #=> \"usr/local/bin\"\n"
"    Path.relative(\"usr/local/bin\")    #=> \"usr/local/bin\"\n"
"    Path.relative(\"D:bar.ex\")         #=> \"bar.ex\"\n"
"    Path.relative(\"/bar/foo.ex\")      #=> \"bar/foo.ex\"\n"
"\n"
msgstr ""
"パスを相対パスに強制します。\n"
"\n"
"## Unixの例\n"
"\n"
"    Path.relative(\"/usr/local/bin\")   #=> \"usr/local/bin\"\n"
"    Path.relative(\"usr/local/bin\")    #=> \"usr/local/bin\"\n"
"    Path.relative(\"../usr/local/bin\") #=> \"../usr/local/bin\"\n"
"\n"
"## Windowsの例\n"
"\n"
"    Path.relative(\"D:/usr/local/bin\") #=> \"usr/local/bin\"\n"
"    Path.relative(\"usr/local/bin\")    #=> \"usr/local/bin\"\n"
"    Path.relative(\"D:bar.ex\")         #=> \"bar.ex\"\n"
"    Path.relative(\"/bar/foo.ex\")      #=> \"bar/foo.ex\"\n"
"\n"

#. TRANSLATORS: def Path.join(left, right)
#: lib/path.ex:454
msgid ""
"Joins two paths.\n"
"\n"
"The right path will always be expanded to its relative format\n"
"and any trailing slash is removed on join.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.join(\"foo\", \"bar\")\n"
"    \"foo/bar\"\n"
"\n"
msgstr ""
"二つのパスを結合します。\n"
"\n"
"右のパスは常に、相対フォーマットで展開され、結合において\n"
"末尾にスラッシュがなかったら、追加されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Path.join(\"foo\", \"bar\")\n"
"    \"foo/bar\"\n"
"\n"

#. TRANSLATORS: def Path.join(list)
#: lib/path.ex:430
msgid ""
"Joins a list of strings.\n"
"\n"
"This function should be used to convert a list of strings to a path.\n"
"Note that any trailing slash is removed on join.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.join([\"~\", \"foo\"])\n"
"    \"~/foo\"\n"
"\n"
"    iex> Path.join([\"foo\"])\n"
"    \"foo\"\n"
"\n"
"    iex> Path.join([\"/\", \"foo\", \"bar/\"])\n"
"    \"/foo/bar\"\n"
"\n"
msgstr ""
"文字列のリストを結合します。\n"
"\n"
"この関数は文字列のリストをパスに変関するために使われるべきです。結合の\n"
"際、末尾のスラッシュはすべて削除されることに注意してください。\n"
"\n"
"## 例\n"
"\n"
"    iex> Path.join([\"~\", \"foo\"])\n"
"    \"~/foo\"\n"
"\n"
"    iex> Path.join([\"foo\"])\n"
"    \"foo\"\n"
"\n"
"    iex> Path.join([\"/\", \"foo\", \"bar/\"])\n"
"    \"/foo/bar\"\n"
"\n"

#. TRANSLATORS: def Path.absname(path)
#: lib/path.ex:18
msgid ""
"Converts the given path to an absolute one. Unlike\n"
"`expand/1`, no attempt is made to resolve `..`, `.` or `~`.\n"
"\n"
"## Unix examples\n"
"\n"
"    Path.absname(\"foo\")\n"
"    #=> \"/usr/local/foo\"\n"
"\n"
"    Path.absname(\"../x\")\n"
"    #=> \"/usr/local/../x\"\n"
"\n"
"## Windows\n"
"\n"
"    Path.absname(\"foo\").\n"
"    \"D:/usr/local/foo\"\n"
"    Path.absname(\"../x\").\n"
"    \"D:/usr/local/../x\"\n"
"\n"
msgstr ""
"与えられたpathを絶対パスにに変換します。\n"
"`expand/1`と違って、`..`、`.`、`~`を解決しません。\n"
"\n"
"## Unixの例\n"
"\n"
"    Path.absname(\"foo\")\n"
"    #=> \"/usr/local/foo\"\n"
"\n"
"    Path.absname(\"../x\")\n"
"    #=> \"/usr/local/../x\"\n"
"\n"
"## Windows\n"
"\n"
"    Path.absname(\"foo\").\n"
"    \"D:/usr/local/foo\"\n"
"    Path.absname(\"../x\").\n"
"    \"D:/usr/local/../x\"\n"
"\n"

#. TRANSLATORS: def Path.rootname(path)
#: lib/path.ex:395
msgid ""
"Returns the `path` with the `extension` stripped.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.rootname(\"/foo/bar\")\n"
"    \"/foo/bar\"\n"
"\n"
"    iex> Path.rootname(\"/foo/bar.ex\")\n"
"    \"/foo/bar\"\n"
"\n"
msgstr ""
"`拡張子`を取り去った`path`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Path.rootname(\"/foo/bar\")\n"
"    \"/foo/bar\"\n"
"\n"
"    iex> Path.rootname(\"/foo/bar.ex\")\n"
"    \"/foo/bar\"\n"
"\n"

#. TRANSLATORS: def Path.dirname(path)
#: lib/path.ex:361
msgid ""
"Returns the directory component of `path`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.dirname(\"/foo/bar.ex\")\n"
"    \"/foo\"\n"
"\n"
"    iex> Path.dirname(\"/foo/bar/baz.ex\")\n"
"    \"/foo/bar\"\n"
"\n"
msgstr ""
"`path`のディレクトリ部分を返します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.dirname(\"/foo/bar.ex\")\n"
"    \"/foo\"\n"
"\n"
"    iex> Path.dirname(\"/foo/bar/baz.ex\")\n"
"    \"/foo/bar\"\n"
"\n"

#. TRANSLATORS: def Path.extname(path)
#: lib/path.ex:378
msgid ""
"Returns the extension of the last component of `path`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.extname(\"foo.erl\")\n"
"    \".erl\"\n"
"\n"
"    iex> Path.extname(\"~/foo/bar\")\n"
"    \"\"\n"
"\n"
msgstr ""
"`path`の最後の構成要素の拡張子を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Path.extname(\"foo.erl\")\n"
"    \".erl\"\n"
"\n"
"    iex> Path.extname(\"~/foo/bar\")\n"
"    \"\"\n"
"\n"

#. TRANSLATORS: def Path.expand(path, relative_to)
#: lib/path.ex:142
msgid ""
"Expands the path relative to the path given as the second argument\n"
"expanding any `.` and `..` characters. If the path is already an\n"
"absolute path, `relative_to` is ignored.\n"
"\n"
"Note, that this function treats `path` with a leading `~` as\n"
"an absolute one.\n"
"\n"
"The second argument is first expanded to an absolute path.\n"
"\n"
"## Examples\n"
"\n"
"    # Assuming that the absolute path to baz is /quux/baz\n"
"    Path.expand(\"foo/bar/../bar\", \"baz\")\n"
"    #=> \"/quux/baz/foo/bar\"\n"
"\n"
"    Path.expand(\"foo/bar/../bar\", \"/baz\")\n"
"    \"/baz/foo/bar\"\n"
"    Path.expand(\"/foo/bar/../bar\", \"/baz\")\n"
"    \"/foo/bar\"\n"
"\n"
msgstr ""
"二つめの引数として与えられたパスに相対的なパスを展開します。\n"
"すべての`.`と`..`文字は展開されます。\n"
"もしパスが既に絶対パスなら、`relative_to`は無視されます。\n"
"\n"
"この関数は、`path`先頭の`~`を絶対パスとして扱うことに、\n"
"注意してください。\n"
"\n"
"二つめの引数は最初に絶対パスに展開されます。\n"
"\n"
"## 例\n"
"\n"
"    # この例では、bazの絶対パスは /quux/bazと見做されています。\n"
"    Path.expand(\"foo/bar/../bar\", \"baz\")\n"
"    #=> \"/quux/baz/foo/bar\"\n"
"\n"
"    Path.expand(\"foo/bar/../bar\", \"/baz\")\n"
"    \"/baz/foo/bar\"\n"
"    Path.expand(\"/foo/bar/../bar\", \"/baz\")\n"
"    \"/foo/bar\"\n"
"\n"

#. TRANSLATORS: def Path.expand(path)
#: lib/path.ex:127
msgid ""
"Converts the path to an absolute one and expands\n"
"any `.` and `..` characters and a leading `~`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.expand(\"/foo/bar/../bar\")\n"
"    \"/foo/bar\"\n"
"\n"
msgstr ""
"pathを`.`と`..`、先頭の`~`を展開し、絶対パスに変換します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.expand(\"/foo/bar/../bar\")\n"
"    \"/foo/bar\"\n"
"\n"

#. TRANSLATORS: def Path.relative_to_cwd(path)
#: lib/path.ex:305
msgid ""
"Convenience to get the path relative to the current working\n"
"directory. If, for some reason, the current working directory\n"
"cannot be retrieved, returns the full path.\n"
msgstr ""
"カレントワーキングディレクトリからの相対パスを取得するのに\n"
"便利なものです。\n"
"いくつかの理由で、カレントワーキングディレクトリが取得できなかったら、\n"
"絶対パスを返します。\n"

#. TRANSLATORS: def Path.absname(path, relative_to)
#: lib/path.ex:43
msgid ""
"Builds a path from `relative_to` to `path`. If `path` is already\n"
"an absolute path, `relative_to` is ignored. See also `relative_to/2`.\n"
"\n"
"Unlike `expand/2`, no attempt is made to\n"
"resolve `..`, `.` or `~`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.absname(\"foo\", \"bar\")\n"
"    \"bar/foo\"\n"
"\n"
"    iex> Path.absname(\"../x\", \"bar\")\n"
"    \"bar/../x\"\n"
"\n"
msgstr ""
"`relative_to`から`path`へパスを組み立てます。\n"
"もし`path`が既に絶対パスなら、`relative_to`は無視されます。\n"
"`relative_to/2`も参照してください。\n"
"\n"
"`expand/2`と違い、`..`、`.`、`~`の解決を試みません。\n"
"\n"
"## 例\n"
"\n"
"    iex> Path.absname(\"foo\", \"bar\")\n"
"    \"bar/foo\"\n"
"\n"
"    iex> Path.absname(\"../x\", \"bar\")\n"
"    \"bar/../x\"\n"
"\n"

#. TRANSLATORS: def Path.basename(path, extension)
#: lib/path.ex:339
msgid ""
"Returns the last component of `path` with the `extension`\n"
"stripped. This function should be used to remove a specific\n"
"extension which may, or may not, be there.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.basename(\"~/foo/bar.ex\", \".ex\")\n"
"    \"bar\"\n"
"\n"
"    iex> Path.basename(\"~/foo/bar.exs\", \".ex\")\n"
"    \"bar.exs\"\n"
"\n"
"    iex> Path.basename(\"~/foo/bar.old.ex\", \".ex\")\n"
"    \"bar.old\"\n"
"\n"
msgstr ""
"`extension`を取り除いた`path`の最後の構成要素を返します。この関数は、あ\n"
"るかないかわからない特定の拡張子を取り除くために使うべきです。\n"
"\n"
"## 例\n"
"\n"
"    iex> Path.basename(\"~/foo/bar.ex\", \".ex\")\n"
"    \"bar\"\n"
"\n"
"    iex> Path.basename(\"~/foo/bar.exs\", \".ex\")\n"
"    \"bar.exs\"\n"
"\n"
"    iex> Path.basename(\"~/foo/bar.old.ex\", \".ex\")\n"
"    \"bar.old\"\n"
"\n"

#. TRANSLATORS: Elixir.Path Summary
#: lib/path.ex:2
msgid ""
"This module provides conveniences for manipulating or\n"
"retrieving file system paths.\n"
"\n"
"The functions in this module may receive a char data as\n"
"argument (i.e. a string or a list of characters / string)\n"
"and will always return a string (encoded in UTF-8).\n"
"\n"
"The majority of the functions in this module do not\n"
"interact with the file system, except for a few functions\n"
"that require it (like `wildcard/2` and `expand/1`).\n"
msgstr ""
"このモジュールはファイルシステムパスを操作したり、\n"
"パスから要素を取り出したりするための便利な関数を提供します。\n"
"\n"
"このモジュールの関数は引数として文字データ(つまり、文字列あるいは文字/\n"
"文字列のリストです)を受け取ります。そして、常に(UTF-8でエンコードされ\n"
"た)文字列を返します。\n"
"\n"
"このモジュールの大部分の関数は、(`wildcard/2`と`expand/1`のような)どう\n"
"しても必要な少数の関数を除いては、ファイルシステムと相互作用しません。\n"

#. TRANSLATORS: def Path.type(name)
#: lib/path.ex:169
msgid ""
"Returns the path type.\n"
"\n"
"## Unix examples\n"
"\n"
"    Path.type(\"/\")                #=> :absolute\n"
"    Path.type(\"/usr/local/bin\")   #=> :absolute\n"
"    Path.type(\"usr/local/bin\")    #=> :relative\n"
"    Path.type(\"../usr/local/bin\") #=> :relative\n"
"    Path.type(\"~/file\")           #=> :relative\n"
"\n"
"## Windows examples\n"
"\n"
"    Path.type(\"D:/usr/local/bin\") #=> :absolute\n"
"    Path.type(\"usr/local/bin\")    #=> :relative\n"
"    Path.type(\"D:bar.ex\")         #=> :volumerelative\n"
"    Path.type(\"/bar/foo.ex\")      #=> :volumerelative\n"
"\n"
msgstr ""
"パスのタイプを返します。\n"
"\n"
"## Unixの例\n"
"\n"
"    Path.type(\"/\")                #=> :absolute\n"
"    Path.type(\"/usr/local/bin\")   #=> :absolute\n"
"    Path.type(\"usr/local/bin\")    #=> :relative\n"
"    Path.type(\"../usr/local/bin\") #=> :relative\n"
"    Path.type(\"~/file\")           #=> :relative\n"
"\n"
"## Windowsの例\n"
"\n"
"    Path.type(\"D:/usr/local/bin\") #=> :absolute\n"
"    Path.type(\"usr/local/bin\")    #=> :relative\n"
"    Path.type(\"D:bar.ex\")         #=> :volumerelative\n"
"    Path.type(\"/bar/foo.ex\")      #=> :volumerelative\n"
"\n"

#. TRANSLATORS: def Path.relative_to(path, from)
#: lib/path.ex:265
msgid ""
"Returns the given `path` relative to the given `from` path.\n"
"In other words, it tries to strip the `from` prefix from `path`.\n"
"\n"
"This function does not query the file system, so it assumes\n"
"no symlinks between the paths.\n"
"\n"
"In case a direct relative path cannot be found, it returns\n"
"the original path.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.relative_to(\"/usr/local/foo\", \"/usr/local\")\n"
"    \"foo\"\n"
"\n"
"    iex> Path.relative_to(\"/usr/local/foo\", \"/\")\n"
"    \"usr/local/foo\"\n"
"\n"
"    iex> Path.relative_to(\"/usr/local/foo\", \"/etc\")\n"
"    \"/usr/local/foo\"\n"
"\n"
msgstr ""
"与えられた`path`の与えられた`from`パスからの相対パスを返します。\n"
"言い替えると、`from`プレフィックスを`path`から取り除こうとします。\n"
"\n"
"この関数はファイルシステムへの問合せはしませんので、\n"
"パスの間のシンボリックリンクを考慮しません。\n"
"\n"
"直接的な相対パスが見付からないと、オリジナルパスを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Path.relative_to(\"/usr/local/foo\", \"/usr/local\")\n"
"    \"foo\"\n"
"\n"
"    iex> Path.relative_to(\"/usr/local/foo\", \"/\")\n"
"    \"usr/local/foo\"\n"
"\n"
"    iex> Path.relative_to(\"/usr/local/foo\", \"/etc\")\n"
"    \"/usr/local/foo\"\n"
"\n"

#. TRANSLATORS: def Path.basename(path)
#: lib/path.ex:318
msgid ""
"Returns the last component of the path or the path\n"
"itself if it does not contain any directory separators.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.basename(\"foo\")\n"
"    \"foo\"\n"
"\n"
"    iex> Path.basename(\"foo/bar\")\n"
"    \"bar\"\n"
"\n"
"    iex> Path.basename(\"/\")\n"
"    \"\"\n"
"\n"
msgstr ""
"パスの最後の構成要素、またはディレクトリセパレータを含んでいないならパ\n"
"スそのものを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Path.basename(\"foo\")\n"
"    \"foo\"\n"
"\n"
"    iex> Path.basename(\"foo/bar\")\n"
"    \"bar\"\n"
"\n"
"    iex> Path.basename(\"/\")\n"
"    \"\"\n"
"\n"

#. TRANSLATORS: def Path.rootname(path, extension)
#: lib/path.ex:412
msgid ""
"Returns the `path` with the `extension` stripped. This function should be "
"used to\n"
"remove a specific extension which might, or might not, be there.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.rootname(\"/foo/bar.erl\", \".erl\")\n"
"    \"/foo/bar\"\n"
"\n"
"    iex> Path.rootname(\"/foo/bar.erl\", \".ex\")\n"
"    \"/foo/bar.erl\"\n"
"\n"
msgstr ""
"`extension`を取り去った`path`を返します。\n"
"この関数は、そこにあるかもしれないか、ないかもしれない特定の拡張子を、\n"
"取り除くために使われるべきです。\n"
"\n"
"## 例\n"
"\n"
"    iex> Path.rootname(\"/foo/bar.erl\", \".erl\")\n"
"    \"/foo/bar\"\n"
"\n"
"    iex> Path.rootname(\"/foo/bar.erl\", \".ex\")\n"
"    \"/foo/bar.erl\"\n"
"\n"
