#. TRANSLATORS: def Path.wildcard(glob, opts \\ [])
#: lib/path.ex:588 
msgid ""
"Traverses paths according to the given `glob` expression.\n"
"\n"
"The wildcard looks like an ordinary path, except that certain\n"
"\"wildcard characters\" are interpreted in a special way. The\n"
"following characters are special:\n"
"\n"
"  * `?` - matches one character\n"
"\n"
"  * `*` - matches any number of characters up to the end of the filename, the\n"
"    next dot, or the next slash\n"
"\n"
"  * `**` - two adjacent `*`'s used as a single pattern will match all\n"
"    files and zero or more directories and subdirectories\n"
"\n"
"  * `[char1,char2,...]` - matches any of the characters listed; two\n"
"    characters separated by a hyphen will match a range of characters\n"
"\n"
"  * `{item1,item2,...}` - matches one of the alternatives\n"
"\n"
"Other characters represent themselves. Only paths that have\n"
"exactly the same character in the same position will match. Note\n"
"that matching is case-sensitive; i.e. \"a\" will not match \"A\".\n"
"\n"
"By default, the patterns `*` and `?` do not match files starting\n"
"with a dot `.` unless `match_dot: true` is given.\n"
"\n"
"## Examples\n"
"\n"
"Imagine you have a directory called `projects` with three Elixir projects\n"
"inside of it: `elixir`, `ex_doc` and `dynamo`. You can find all `.beam` files\n"
"inside the `ebin` directory of each project as follows:\n"
"\n"
"    Path.wildcard(\"projects/*/ebin/**/*.beam\")\n"
"\n"
"If you want to search for both `.beam` and `.app` files, you could do:\n"
"\n"
"    Path.wildcard(\"projects/*/ebin/**/*.{beam,app}\")\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.Path Summary
#: lib/path.ex:1 
msgid ""
"This module provides conveniences for manipulating or\n"
"retrieving file system paths.\n"
"\n"
"The functions in this module may receive a char data as\n"
"argument (i.e. a string or a list of characters / string)\n"
"and will always return a string (encoded in UTF-8).\n"
"\n"
"The majority of the functions in this module do not\n"
"interact with the file system, except for a few functions\n"
"that require it (like `wildcard/1` and `expand/1`).\n"
msgstr ""
#. TRANSLATORS: def Path.join(left, right)
#: lib/path.ex:466 
msgid ""
"Joins two paths.\n"
"\n"
"The right path will always be expanded to its relative format\n"
"and any trailing slash is removed on join.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.join(\"foo\", \"bar\")\n"
"    \"foo/bar\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Path.split(path)
#: lib/path.ex:510 
msgid ""
"Splits the path into a list at the path separator.\n"
"\n"
"If an empty string is given, returns an empty list.\n"
"\n"
"On Windows, path is split on both \"\\\" and \"/\" separators\n"
"and the driver letter, if there is one, is always returned\n"
"in lowercase.\n"
"\n"
"## Examples\n"
"\n"
"     iex> Path.split(\"\")\n"
"     []\n"
"\n"
"     iex> Path.split(\"foo\")\n"
"     [\"foo\"]\n"
"\n"
"     iex> Path.split(\"/foo/bar\")\n"
"     [\"/\", \"foo\", \"bar\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Path.expand(path, relative_to)
#: lib/path.ex:165 
msgid ""
"Expands the path relative to the path given as the second argument\n"
"expanding any `.` and `..` characters. If the path is already an\n"
"absolute path, `relative_to` is ignored.\n"
"\n"
"Note, that this function treats `path` with a leading `~` as\n"
"an absolute one.\n"
"\n"
"The second argument is first expanded to an absolute path.\n"
"\n"
"## Examples\n"
"\n"
"    # Assuming that the absolute path to baz is /quux/baz\n"
"    Path.expand(\"foo/bar/../bar\", \"baz\")\n"
"    #=> \"/quux/baz/foo/bar\"\n"
"\n"
"    Path.expand(\"foo/bar/../bar\", \"/baz\")\n"
"    \"/baz/foo/bar\"\n"
"    Path.expand(\"/foo/bar/../bar\", \"/baz\")\n"
"    \"/foo/bar\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Path.type(name)
#: lib/path.ex:189 
msgid ""
"Returns the path type.\n"
"\n"
"## Unix examples\n"
"\n"
"    Path.type(\"/\")                #=> :absolute\n"
"    Path.type(\"/usr/local/bin\")   #=> :absolute\n"
"    Path.type(\"usr/local/bin\")    #=> :relative\n"
"    Path.type(\"../usr/local/bin\") #=> :relative\n"
"    Path.type(\"~/file\")           #=> :relative\n"
"\n"
"## Windows examples\n"
"\n"
"    Path.type(\"D:/usr/local/bin\") #=> :absolute\n"
"    Path.type(\"usr/local/bin\")    #=> :relative\n"
"    Path.type(\"D:bar.ex\")         #=> :volumerelative\n"
"    Path.type(\"/bar/foo.ex\")      #=> :volumerelative\n"
"\n"
msgstr ""
#. TRANSLATORS: def Path.join(list1)
#: lib/path.ex:448 
msgid ""
"Joins a list of strings.\n"
"\n"
"This function should be used to convert a list of strings to a path.\n"
"Note that any trailing slash is removed on join.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.join([\"~\", \"foo\"])\n"
"    \"~/foo\"\n"
"\n"
"    iex> Path.join([\"foo\"])\n"
"    \"foo\"\n"
"\n"
"    iex> Path.join([\"/\", \"foo\", \"bar/\"])\n"
"    \"/foo/bar\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Path.relative(name)
#: lib/path.ex:211 
msgid ""
"Forces the path to be a relative path.\n"
"\n"
"## Unix examples\n"
"\n"
"    Path.relative(\"/usr/local/bin\")   #=> \"usr/local/bin\"\n"
"    Path.relative(\"usr/local/bin\")    #=> \"usr/local/bin\"\n"
"    Path.relative(\"../usr/local/bin\") #=> \"../usr/local/bin\"\n"
"\n"
"## Windows examples\n"
"\n"
"    Path.relative(\"D:/usr/local/bin\") #=> \"usr/local/bin\"\n"
"    Path.relative(\"usr/local/bin\")    #=> \"usr/local/bin\"\n"
"    Path.relative(\"D:bar.ex\")         #=> \"bar.ex\"\n"
"    Path.relative(\"/bar/foo.ex\")      #=> \"bar/foo.ex\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Path.expand(path)
#: lib/path.ex:138 
msgid ""
"Converts the path to an absolute one and expands\n"
"any `.` and `..` characters and a leading `~`.\n"
"\n"
"## Examples\n"
"\n"
"    Path.expand(\"/foo/bar/../bar\")\n"
"    \"/foo/bar\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Path.absname(path)
#: lib/path.ex:39 
msgid ""
"Converts the given path to an absolute one. Unlike\n"
"`expand/1`, no attempt is made to resolve `..`, `.` or `~`.\n"
"\n"
"## Unix examples\n"
"\n"
"    Path.absname(\"foo\")\n"
"    #=> \"/usr/local/foo\"\n"
"\n"
"    Path.absname(\"../x\")\n"
"    #=> \"/usr/local/../x\"\n"
"\n"
"## Windows\n"
"\n"
"    Path.absname(\"foo\").\n"
"    \"D:/usr/local/foo\"\n"
"    Path.absname(\"../x\").\n"
"    \"D:/usr/local/../x\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Path.absname(path, relative_to)
#: lib/path.ex:60 
msgid ""
"Builds a path from `relative_to` to `path`. If `path` is already\n"
"an absolute path, `relative_to` is ignored. See also `relative_to/2`.\n"
"\n"
"Unlike `expand/2`, no attempt is made to\n"
"resolve `..`, `.` or `~`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.absname(\"foo\", \"bar\")\n"
"    \"bar/foo\"\n"
"\n"
"    iex> Path.absname(\"../x\", \"bar\")\n"
"    \"bar/../x\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Path.basename(path)
#: lib/path.ex:335 
msgid ""
"Returns the last component of the path or the path\n"
"itself if it does not contain any directory separators.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.basename(\"foo\")\n"
"    \"foo\"\n"
"\n"
"    iex> Path.basename(\"foo/bar\")\n"
"    \"bar\"\n"
"\n"
"    iex> Path.basename(\"/\")\n"
"    \"\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Path.basename(path, extension)
#: lib/path.ex:357 
msgid ""
"Returns the last component of `path` with the `extension`\n"
"stripped. This function should be used to remove a specific\n"
"extension which may, or may not, be there.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.basename(\"~/foo/bar.ex\", \".ex\")\n"
"    \"bar\"\n"
"\n"
"    iex> Path.basename(\"~/foo/bar.exs\", \".ex\")\n"
"    \"bar.exs\"\n"
"\n"
"    iex> Path.basename(\"~/foo/bar.old.ex\", \".ex\")\n"
"    \"bar.old\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Path.relative_to(path, from)
#: lib/path.ex:288 
msgid ""
"Returns the given `path` relative to the given `from` path.\n"
"In other words, it tries to strip the `from` prefix from `path`.\n"
"\n"
"This function does not query the file system, so it assumes\n"
"no symlinks in between the paths.\n"
"\n"
"In case a direct relative path cannot be found, it returns\n"
"the original path.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.relative_to(\"/usr/local/foo\", \"/usr/local\")\n"
"    \"foo\"\n"
"\n"
"    iex> Path.relative_to(\"/usr/local/foo\", \"/\")\n"
"    \"usr/local/foo\"\n"
"\n"
"    iex> Path.relative_to(\"/usr/local/foo\", \"/etc\")\n"
"    \"/usr/local/foo\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Path.extname(path)
#: lib/path.ex:390 
msgid ""
"Returns the extension of the last component of `path`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.extname(\"foo.erl\")\n"
"    \".erl\"\n"
"\n"
"    iex> Path.extname(\"~/foo/bar\")\n"
"    \"\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Path.dirname(path)
#: lib/path.ex:373 
msgid ""
"Returns the directory component of `path`.\n"
"\n"
"## Examples\n"
"\n"
"    Path.dirname(\"/foo/bar.ex\")\n"
"    #=> \"/foo\"\n"
"    Path.dirname(\"/foo/bar/baz.ex\")\n"
"    #=> \"/foo/bar\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Path.rootname(path, extension)
#: lib/path.ex:425 
msgid ""
"Returns the `path` with the `extension` stripped. This function should be used to\n"
"remove a specific extension which might, or might not, be there.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.rootname(\"/foo/bar.erl\", \".erl\")\n"
"    \"/foo/bar\"\n"
"\n"
"    iex> Path.rootname(\"/foo/bar.erl\", \".ex\")\n"
"    \"/foo/bar.erl\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Path.rootname(path)
#: lib/path.ex:407 
msgid ""
"Returns the `path` with the `extension` stripped.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.rootname(\"/foo/bar\")\n"
"    \"/foo/bar\"\n"
"\n"
"    iex> Path.rootname(\"/foo/bar.ex\")\n"
"    \"/foo/bar\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Path.relative_to_cwd(path)
#: lib/path.ex:311 
msgid ""
"Convenience to get the path relative to the current working\n"
"directory. If, for some reason, the current working directory\n"
"cannot be retrieved, returns the full path.\n"
msgstr ""
