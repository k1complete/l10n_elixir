#. TRANSLATORS: Elixir.StringIO Summary
#: lib/string_io.ex:2 
msgid ""
"This module provides an IO device that wraps a string.\n"
"\n"
"## Examples\n"
"\n"
"    iex> {:ok, pid} = StringIO.open(\"foo\")\n"
"    iex> IO.read(pid, 2)\n"
"    \"fo\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def StringIO.close(pid)
#: lib/string_io.ex:76 
msgid ""
"Stops the IO device and returns remaining buffers.\n"
"\n"
"## Examples\n"
"\n"
"    iex> {:ok, pid} = StringIO.open(\"in\")\n"
"    iex> IO.write(pid, \"out\")\n"
"    iex> StringIO.close(pid)\n"
"    {:ok, {\"in\", \"out\"}}\n"
"\n"
msgstr ""
#. TRANSLATORS: def StringIO.contents(pid)
#: lib/string_io.ex:42 
msgid ""
"Returns current buffers.\n"
"\n"
"## Examples\n"
"\n"
"    iex> {:ok, pid} = StringIO.open(\"in\")\n"
"    iex> IO.write(pid, \"out\")\n"
"    iex> StringIO.contents(pid)\n"
"    {\"in\", \"out\"}\n"
"\n"
msgstr ""
#. TRANSLATORS: def StringIO.flush(pid)
#: lib/string_io.ex:58 
msgid ""
"Flushes output buffer.\n"
"\n"
"## Examples\n"
"\n"
"    iex> {:ok, pid} = StringIO.open(\"in\")\n"
"    iex> IO.write(pid, \"out\")\n"
"    iex> StringIO.flush(pid)\n"
"    \"out\"\n"
"    iex> StringIO.contents(pid)\n"
"    {\"in\", \"\"}\n"
"\n"
msgstr ""
#. TRANSLATORS: def StringIO.open(string, options \\ [])
#: lib/string_io.ex:15 
msgid ""
"Creates an IO device.\n"
"\n"
"If the `:capture_prompt` option is set to `true`,\n"
"prompts (specified as arguments to `IO.get*` functions)\n"
"are captured.\n"
"\n"
"## Examples\n"
"\n"
"    iex> {:ok, pid} = StringIO.open(\"foo\")\n"
"    iex> IO.gets(pid, \">\")\n"
"    \"foo\"\n"
"    iex> StringIO.contents(pid)\n"
"    {\"\", \"\"}\n"
"\n"
"    iex> {:ok, pid} = StringIO.open(\"foo\", capture_prompt: true)\n"
"    iex> IO.gets(pid, \">\")\n"
"    \"foo\"\n"
"    iex> StringIO.contents(pid)\n"
"    {\"\", \">\"}\n"
"\n"
msgstr ""
