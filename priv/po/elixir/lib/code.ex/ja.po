msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2015-09-11 23:34+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: def Code.get_docs(module, kind)
#: lib/code.ex:568
msgid ""
"Returns the docs for the given module.\n"
"\n"
"When given a module name, it finds its BEAM code and reads the docs from "
"it.\n"
"\n"
"When given a path to a .beam file, it will load the docs directly from that\n"
"file.\n"
"\n"
"The return value depends on the `kind` value:\n"
"\n"
"  * `:docs` - list of all docstrings attached to functions and macros\n"
"    using the `@doc` attribute\n"
"\n"
"  * `:moduledoc` - tuple `{<line>, <doc>}` where `line` is the line on\n"
"    which module definition starts and `doc` is the string\n"
"    attached to the module using the `@moduledoc` attribute\n"
"\n"
"  * `:callback_docs` - list of all docstrings attached to\n"
"    `@callbacks` using the `@doc` attribute\n"
"\n"
"  * `:type_docs` - list of all docstrings attached to\n"
"    `@type` callbacks using the `@typedoc` attribute\n"
"\n"
"  * `:all` - a keyword list with both `:docs` and `:moduledoc`\n"
"\n"
"## Examples\n"
"\n"
"    # Get the documentation for the first function listed\n"
"    iex> [fun|_] = Code.get_docs(Atom, :docs) |> Enum.sort()\n"
"    iex> {{_function, _arity}, _line, _kind, _signature, text} = fun\n"
"    iex> String.split(text, \"\\n\") |> Enum.at(0)\n"
"    \"Converts an atom to a char list.\"\n"
"\n"
msgstr ""
"与えられたモジュールのドキュメントを返します。\n"
"\n"
"モジュール名が与えられたとき、そこからbeamコードを見付け、ドキュメントを\n"
"読み出します。\n"
"\n"
".beamファイルへのパスが与えられたとき、そのファイルからダイレクトに\n"
"ドキュメントをロードします。\n"
"\n"
"`kind`の値に依存して返される値は以下のようになります:\n"
"\n"
"  * `:docs` - `@doc`アトリビュートを使って関数とマクロにアタッチ\n"
"              されたドキュメント文字列の全てのリストです。\n"
"\n"
"  * `:moduledoc` - タプル `{<line>, <doc>}`、ただし、\n"
"                `line`はモジュールの定義が開始される行で、`doc`は\n"
"               `@moduledoc`アトリビュートを使ってモジュールにアタッチされた\n"
"               文字列です。\n"
"\n"
"  * `:callback_docs` - `@doc`アトリビュートを使って、\n"
"             `@callbacks`にアタッチされたドキュメント文字列\n"
"             全てのリストです。\n"
"\n"
"  * `:type_docs` - `@typedoc`アトリビュートを使って、\n"
"             `@type`コールバックにアタッチされたドキュメント文字列\n"
"             全てのリストです。\n"
"\n"
"  * `:all` - 上記全てのキーワードリストです。\n"
"\n"
"## Examples\n"
"\n"
"    # Get the documentation for the first function listed\n"
"    iex> [fun|_] = Code.get_docs(Atom, :docs) |> Enum.sort()\n"
"    iex> {{_function, _arity}, _line, _kind, _signature, text} = fun\n"
"    iex> String.split(text, \"\\n\") |> Enum.at(0)\n"
"    \"Converts an atom to a char list.\"\n"
"\n"

#. TRANSLATORS: Elixir.Code Summary
#: lib/code.ex:2
msgid ""
"Utilities for managing code compilation, code evaluation and code loading.\n"
"\n"
"This module complements [Erlang's code module](http://www.erlang.org/doc/man/"
"code.html)\n"
"to add behaviour which is specific to Elixir. Almost all of the functions in "
"this module\n"
"have global side effects on the behaviour of Elixir.\n"
msgstr ""
"コードコンパイル、コード評価、コードローディングの管理のためのユーティ\n"
"リティです。\n"
"\n"
"このモジュールは [Erlangのcodeモジュール]\n"
"(http://www.erlang.org/doc/man/code.html) にElixir固有の振舞いを追加\n"
"して補足しました。\n"
"このモジュールのほとんどの関数はElixirの振舞いで大域的な\n"
"副作用があります。\n"

#. TRANSLATORS: def Code.compiler_options(opts)
#: lib/code.ex:399
msgid ""
"Sets compilation options.\n"
"\n"
"These options are global since they are stored by Elixir's Code Server.\n"
"\n"
"Available options are:\n"
"\n"
"  * `:docs` - when `true`, retain documentation in the compiled module,\n"
"    `true` by default\n"
"\n"
"  * `:debug_info` - when `true`, retain debug information in the compiled\n"
"    module; this allows a developer to reconstruct the original source\n"
"    code, `false` by default\n"
"\n"
"  * `:ignore_module_conflict` - when `true`, override modules that were\n"
"    already defined without raising errors, `false` by default\n"
"\n"
"  * `:warnings_as_errors` - cause compilation to fail when warnings are\n"
"    generated\n"
"\n"
"It returns the new list of compiler options.\n"
"\n"
"## Examples\n"
"\n"
"    Code.compiler_options(debug_info: true)\n"
"    #=> [debug_info: true, docs: true, warnings_as_errors: false]\n"
"\n"
msgstr ""
"コンパイラオプションをセットします。\n"
"\n"
"これらのオプションはElixirコードサーバに保存されるときからグローバルに\n"
"有効になります。\n"
"\n"
"指定できるオプションは以下のとおりです:\n"
"\n"
"  * `:docs` - `true`にすると、コンパイルされたモジュールでドキュメントを\n"
"    保持します。デフォルトは`true`です。\n"
"\n"
"  * `:debug_info` - `true`にすると、コンパイルされたモジュールで\n"
"    デバッグ情報を保持します。これは開発者にオリジナルのソースコードを\n"
"    再構築することを許します。デフォルトは`false`です。\n"
"\n"
"  * `:ignore_module_conflict` - `true`にすると、定義済のモジュールを\n"
"     エラーを引き起すことなしに上書きします。デフォルトは`false`です。\n"
"\n"
"  * `:warnings_as_errors` - 警告が発生したときに、それを原因にコンパイラを\n"
"     失敗させます。\n"
"\n"
"コンパイラオプションの新しいリストを返します。\n"
"\n"
"## Examples\n"
"\n"
"    Code.compiler_options(debug_info: true)\n"
"    #=> [debug_info: true, docs: true, warnings_as_errors: false]\n"
"\n"

#. TRANSLATORS: def Code.available_compiler_options()
#: lib/code.ex:384
msgid ""
"Returns a list with the available compiler options.\n"
"\n"
"See `Code.compiler_options/1` for more info.\n"
"\n"
"## Examples\n"
"\n"
"    Code.available_compiler_options\n"
"    #=> [:docs, :debug_info, :ignore_module_conflict, :warnings_as_errors]\n"
"\n"
msgstr ""
"有効なコンパイラオプションのリストを返します。\n"
"\n"
"更なる情報は `Code.compiler_options/1` を参照してください。\n"
"\n"
"## Examples\n"
"\n"
"    Code.available_compiler_options\n"
"    #=> [:docs, :debug_info, :ignore_module_conflict, :warnings_as_errors]\n"
"\n"

#. TRANSLATORS: def Code.require_file(file, relative_to \\ nil)
#: lib/code.ex:326
msgid ""
"Requires the given `file`.\n"
"\n"
"Accepts `relative_to` as an argument to tell where the file is located.\n"
"The return value is the same as that of `load_file/2`. If the file was "
"already\n"
"required/loaded, doesn't do anything and returns `nil`.\n"
"\n"
"Notice that if `require_file` is invoked by different processes "
"concurrently,\n"
"the first process to invoke `require_file` acquires a lock and the "
"remaining\n"
"ones will block until the file is available. I.e. if `require_file` is "
"called\n"
"N times with a given file, it will be loaded only once. The first process "
"to\n"
"call `require_file` will get the list of loaded modules, others will get "
"`nil`.\n"
"\n"
"Check `load_file/2` if you want a file to be loaded multiple times. See "
"also\n"
"`unload_files/1`\n"
"\n"
"## Examples\n"
"\n"
"If the code is already loaded, it returns `nil`:\n"
"\n"
"    Code.require_file(\"eex_test.exs\",\"../eex/test\") #=> nil\n"
"\n"
"If the code is not loaded yet, it returns the same as `load_file/2`:\n"
"\n"
"    Code.require_file(\"eex_test.exs\",\"../eex/test\") |> List.first\n"
"    #=> {EExTest.Compiled, <<70, 79, 82, 49, ...>>}\n"
"\n"
msgstr ""
"与えられた`file`をrequireします。\n"
"\n"
"ファイルの場所を尋ねるための引数として、`relative_to`を受け付けます。戻\n"
"値は、`load_file/2`と同じです。もしファイルが既にrequireやloadされてい\n"
"たら、何もせず、`nil`を返します。\n"
"\n"
"もし、`require_file`が並行する異るプロセスにより実行されたら、最初のプ\n"
"ロセスは`require_file`を実行するためにロックを要求します。そして残った\n"
"プロセスはファイルが有効になりまでブロックするでしょう。すなわち、もし\n"
"`require_file`がN回呼ばれたら、一度だけロードされるでしょう。\n"
"`require_file`を呼び出す最初のプロセスはロードされたモジュールのリスト\n"
"を得て、他のプロセスは`nil`を得るでしょう。\n"
"\n"
"もし一つのファイルを複数回ロードしたいならば、`load_file/2`を\n"
"チェックしてください。`unload_files/1`も参照してください。\n"
"\n"
"## Examples\n"
"\n"
"If the code is already loaded, it returns `nil`:\n"
"\n"
"    Code.require_file(\"eex_test.exs\",\"../eex/test\") #=> nil\n"
"\n"
"If the code is not loaded yet, it returns the same as `load_file/2`:\n"
"\n"
"    Code.require_file(\"eex_test.exs\",\"../eex/test\") |> List.first\n"
"    #=> {EExTest.Compiled, <<70, 79, 82, 49, ...>>}\n"
"\n"

#. TRANSLATORS: def Code.unload_files(files)
#: lib/code.ex:23
msgid ""
"Removes files from the loaded files list.\n"
"\n"
"The modules defined in the file are not removed;\n"
"calling this function only removes them from the list,\n"
"allowing them to be required again.\n"
"\n"
"## Examples\n"
"\n"
"    # Load EEx test code, unload file, check for functions still available\n"
"    Code.load_file(\"../eex/test/eex_test.exs\")\n"
"    Code.unload_files(Code.loaded_files)\n"
"    function_exported?(EExTest.Compiled, :before_compile, 0) #=> true\n"
"\n"
msgstr ""
"ロードされたファイルリストからファイルを削除します。\n"
"\n"
"ファイル中の定義されたモジュールは削除されません;\n"
"この関数はリストからそれらだけを削除するので、\n"
"再びrequireが出来るようになります。\n"
"\n"
"## Examples\n"
"\n"
"    # Load EEx test code, unload file, check for functions still available\n"
"    Code.load_file(\"../eex/test/eex_test.exs\")\n"
"    Code.unload_files(Code.loaded_files)\n"
"    function_exported?(EExTest.Compiled, :before_compile, 0) #=> true\n"
"\n"

#. TRANSLATORS: def Code.compiler_options()
#: lib/code.ex:369
msgid ""
"Gets the compilation options from the code server.\n"
"\n"
"Check `compiler_options/1` for more information.\n"
"\n"
"## Examples\n"
"\n"
"    Code.compiler_options\n"
"    #=> [debug_info: true, docs: true, warnings_as_errors: false]\n"
"\n"
msgstr ""
"コンパイラオプションをコードサーバから取得します。\n"
"\n"
"詳細は、`compiler_options/1`をチェックしてください。\n"
"\n"
"## Examples\n"
"\n"
"    Code.compiler_options\n"
"    #=> [debug_info: true, docs: true, warnings_as_errors: false]\n"
"\n"

#. TRANSLATORS: def Code.load_file(file, relative_to \\ nil)
#: lib/code.ex:299
msgid ""
"Loads the given file.\n"
"\n"
"Accepts `relative_to` as an argument to tell where the file is located.\n"
"If the file was already required/loaded, loads it again.\n"
"\n"
"It returns a list of tuples `{ModuleName, <<byte_code>>}`, one tuple for\n"
"each module defined in the file.\n"
"\n"
"Notice that if `load_file` is invoked by different processes concurrently,\n"
"the target file will be loaded concurrently many times. Check "
"`require_file/2`\n"
"if you don't want a file to be loaded concurrently.\n"
"\n"
"## Examples\n"
"\n"
"    Code.load_file(\"eex_test.exs\",\"../eex/test\") |> List.first\n"
"    #=> {EExTest.Compiled, <<70, 79, 82, 49, ...>>}\n"
"\n"
msgstr ""
"与えられたファイルをロードします。\n"
"\n"
"ファイルの場所を尋ねるための引数として与えられた`relative_to`を受け付け\n"
"ます。もし既にrequire/loadされていたら、再びロードされます。\n"
"\n"
"そのファイルに定義されたそれぞれのモジュール毎に1タプルとして、タプル\n"
"`{ModuleName, <<byte_code>>}`のリストを返します。\n"
"\n"
"もし、並行して異なるプロセスにより`load_file`が起動されるなら、ターゲッ\n"
"トファイルは並行して何回もロードされることに、注意してください。一つの\n"
"ファイルを並行してロードしたくないなら、`require_file/2`をチェックして\n"
"ください。\n"
"\n"
"## Examples\n"
"\n"
"    Code.load_file(\"eex_test.exs\",\"../eex/test\") |> List.first\n"
"    #=> {EExTest.Compiled, <<70, 79, 82, 49, ...>>}\n"
"\n"

#. TRANSLATORS: def Code.loaded_files()
#: lib/code.ex:10
msgid ""
"Lists all loaded files.\n"
"\n"
"## Examples\n"
"\n"
"    Code.require_file(\"../eex/test/eex_test.exs\")\n"
"    List.first(Code.loaded_files) =~ \"eex_test.exs\" #=> true\n"
"\n"
msgstr ""
"ロードされた全てのファイルのリストです。\n"
"\n"
"## Examples\n"
"\n"
"    Code.require_file(\"../eex/test/eex_test.exs\")\n"
"    List.first(Code.loaded_files) =~ \"eex_test.exs\" #=> true\n"
"\n"

#. TRANSLATORS: def Code.ensure_loaded?(module)
#: lib/code.ex:510
msgid ""
"Ensures the given module is loaded.\n"
"\n"
"Similar to `ensure_loaded/1`, but returns `true` if the module\n"
"is already loaded or was successfully loaded. Returns `false`\n"
"otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Code.ensure_loaded?(Atom)\n"
"    true\n"
"\n"
msgstr ""
"与えられたモジュールがロードされたことを確実にします。\n"
"\n"
"`ensure_loaded/1`と似ていますが、モジュールが既に\n"
"ロードされたか、ロードに成功したら、`true`を返します。\n"
"さもなければ`false`を返します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Code.ensure_loaded?(Atom)\n"
"    true\n"
"\n"

#. TRANSLATORS: def Code.ensure_loaded(module)
#: lib/code.ex:459
msgid ""
"Ensures the given module is loaded.\n"
"\n"
"If the module is already loaded, this works as no-op. If the module\n"
"was not yet loaded, it tries to load it.\n"
"\n"
"If it succeeds loading the module, it returns `{:module, module}`.\n"
"If not, returns `{:error, reason}` with the error reason.\n"
"\n"
"## Code loading on the Erlang VM\n"
"\n"
"Erlang has two modes to load code: interactive and embedded.\n"
"\n"
"By default, the Erlang VM runs in interactive mode, where modules\n"
"are loaded as needed. In embedded mode the opposite happens, as all\n"
"modules need to be loaded upfront or explicitly.\n"
"\n"
"Therefore, this function is used to check if a module is loaded\n"
"before using it and allows one to react accordingly. For example, the `URI`\n"
"module uses this function to check if a specific parser exists for a given\n"
"URI scheme.\n"
"\n"
"## Code.ensure_compiled/1\n"
"\n"
"Elixir also contains an `ensure_compiled/1` function that is a\n"
"superset of `ensure_loaded/1`.\n"
"\n"
"Since Elixir's compilation happens in parallel, in some situations\n"
"you may need to use a module that was not yet compiled, therefore\n"
"it can't even be loaded.\n"
"\n"
"`ensure_compiled/1` halts the current process until the\n"
"module we are depending on is available.\n"
"\n"
"In most cases, `ensure_loaded/1` is enough. `ensure_compiled/1`\n"
"must be used in rare cases, usually involving macros that need to\n"
"invoke a module for callback information.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Code.ensure_loaded(Atom)\n"
"    {:module, Atom}\n"
"\n"
"    iex> Code.ensure_loaded(DoesNotExist)\n"
"    {:error, :nofile}\n"
"\n"
msgstr ""
"与えられたモジュールがロードされたことを確実にします。\n"
"\n"
"もしモジュールが既にロードされていたら、no-op(なにもしない)です。\n"
"もしモジュールが未だロードされてないなら、ロードを試みます。\n"
"\n"
"モジュールのロードに成功したら、`{:module, module}`を返します。\n"
"そうでなかったら、エラーreasonとともに`{:error, reason}`を返します。\n"
"\n"
"## Erlang VMでのコードローディング\n"
"\n"
"Erlangは二つのモードを持ってます: インタラクティブとエンベデッ\n"
"ドです。\n"
"\n"
"デフォルトでは、Erlang VMはインタラクティブモードで動き、モ\n"
"ジュールは必要に応じてロードされます。エンベデッドモードでは、\n"
"反対に、全てのモジュールが事前に、あるいは明示的にロードされて\n"
"いる必要があります。\n"
"\n"
"従って、この関数は、使う前にモジュールがロードされているかと、\n"
"それに応じて対応出来るかの、チェックに使われます。例えば、\n"
"`URI`モジュールはこの関数を、与えられたURIスキームに対応した特\n"
"定のパーサが存在するかの、チェックに使っています。\n"
"\n"
"## Code.ensure_compiled/1\n"
"\n"
"Elixirは、`ensure_loaded/1`のスーパーセットである、\n"
"`ensure_compiled/1`関数も含みます。\n"
"\n"
"Elixirのコンパイルは並列に起きるので、使いたいモジュールがまだ\n"
"コンパイルされていない、いくつかのシチュエーションでは、決して\n"
"それはロードされません。\n"
"\n"
"`ensure_compile/1`は、依存しているモジュールが有効になるまで現\n"
"在のプロセスを停止させます。\n"
"\n"
"殆どの場合、`ensure_loaded/1`で十分です。`ensure_compiled/1`は、\n"
"コールバック情報の為にモジュールを起動する必要があるマクロを実\n"
"行するような、レアなケースで使用されなければなりません。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Code.ensure_loaded(Atom)\n"
"    {:module, Atom}\n"
"\n"
"    iex> Code.ensure_loaded(DoesNotExist)\n"
"    {:error, :nofile}\n"
"\n"

#. TRANSLATORS: def Code.ensure_compiled?(module)
#: lib/code.ex:557
msgid ""
"Ensures the given module is compiled and loaded.\n"
"\n"
"Similar to `ensure_compiled/1`, but returns `true` if the module\n"
"is already loaded or was successfully loaded and compiled.\n"
"Returns `false` otherwise.\n"
msgstr ""
"与えられたモジュールがコンパイルされ、ロードされたことを確実にします。\n"
"\n"
"`ensure_compiled/1`と似ていますが、モジュールが既にロード\n"
"されていたか、コンパイルとロードに成功したら、`true`を返します。\n"
"さもなければ、`false`を返します。\n"

#. TRANSLATORS: def Code.ensure_compiled(module)
#: lib/code.ex:527
msgid ""
"Ensures the given module is compiled and loaded.\n"
"\n"
"If the module is already loaded, it works as no-op. If the module was\n"
"not loaded yet, it checks if it needs to be compiled first and then\n"
"tries to load it.\n"
"\n"
"If it succeeds loading the module, it returns `{:module, module}`.\n"
"If not, returns `{:error, reason}` with the error reason.\n"
"\n"
"Check `ensure_loaded/1` for more information on module loading\n"
"and when to use `ensure_loaded/1` or `ensure_compiled/1`.\n"
msgstr ""
"与えられたモジュールがコンパイルされ、ロードされたことを確実にします。\n"
"\n"
"もしモジュールが既にロードされていたら、no-op(なにもしない)です。\n"
"もしモジュールが未だロードされてないなら、まずコンパイルし、それから\n"
"ロードを試みます。\n"
"\n"
"モジュールのロードに成功したら、`{:module, module}`を返します。\n"
"そうでなかったら、エラーreasonとともに`{:error, reason}`を返します。\n"
"\n"
"モジュールローディングの詳細情報と、\n"
"何時`ensure_loaded/1`と`ensure_compile/1`を利用するか\n"
"については、\n"
"`ensure_loaded/1`をチェックしてください。\n"

#. TRANSLATORS: def Code.eval_quoted(quoted, binding \\ [], opts \\ [])
#: lib/code.ex:172
msgid ""
"Evaluates the quoted contents.\n"
"\n"
"See `eval_string/3` for a description of arguments and return values.\n"
"\n"
"## Examples\n"
"\n"
"    iex> contents = quote(do: var!(a) + var!(b))\n"
"    iex> Code.eval_quoted(contents, [a: 1, b: 2], file: __ENV__.file, line: "
"__ENV__.line)\n"
"    {3, [a: 1, b: 2]}\n"
"\n"
"For convenience, you can pass `__ENV__` as the `opts` argument and\n"
"all options will be automatically extracted from the current environment:\n"
"\n"
"    iex> contents = quote(do: var!(a) + var!(b))\n"
"    iex> Code.eval_quoted(contents, [a: 1, b: 2], __ENV__)\n"
"    {3, [a: 1, b: 2]}\n"
"\n"
msgstr ""
"クォートされたコンテンツを評価します。\n"
"\n"
"引数と戻り値の説明は、`eval_string/3`を参照してください。\n"
"\n"
"## 例\n"
"\n"
"    iex> contents = quote(do: var!(a) + var!(b))\n"
"    iex> Code.eval_quoted(contents, [a: 1, b: 2], file: __ENV__.file, line: "
"__ENV__.line)\n"
"    {3, [a: 1, b: 2]}\n"
"\n"
"For convenience, you can pass `__ENV__` as the `opts` argument and\n"
"all options will be automatically extracted from the current environment:\n"
"\n"
"    iex> contents = quote(do: var!(a) + var!(b))\n"
"    iex> Code.eval_quoted(contents, [a: 1, b: 2], __ENV__)\n"
"    {3, [a: 1, b: 2]}\n"
"\n"

#. TRANSLATORS: def Code.eval_string(string, binding \\ [], opts \\ [])
#: lib/code.ex:101
msgid ""
"Evaluates the contents given by `string`.\n"
"\n"
"The `binding` argument is a keyword list of variable bindings.\n"
"The `opts` argument is a keyword list of environment options.\n"
"\n"
"Those options can be:\n"
"\n"
"  * `:file` - the file to be considered in the evaluation\n"
"  * `:line` - the line on which the script starts\n"
"\n"
"Additionally, the following scope values can be configured:\n"
"\n"
"  * `:aliases` - a list of tuples with the alias and its target\n"
"\n"
"  * `:requires` - a list of modules required\n"
"\n"
"  * `:functions` - a list of tuples where the first element is a module\n"
"    and the second a list of imported function names and arity; the list\n"
"    of function names and arity must be sorted\n"
"\n"
"  * `:macros` - a list of tuples where the first element is a module\n"
"    and the second a list of imported macro names and arity; the list\n"
"    of function names and arity must be sorted\n"
"\n"
"Notice that setting any of the values above overrides Elixir's default\n"
"values. For example, setting `:requires` to `[]`, will no longer\n"
"automatically require the `Kernel` module; in the same way setting\n"
"`:macros` will no longer auto-import `Kernel` macros like `if`, `case`,\n"
"etc.\n"
"\n"
"Returns a tuple of the form `{value, binding}`,\n"
"where `value` is the value returned from evaluating `string`.\n"
"If an error occurs while evaluating `string` an exception will be raised.\n"
"\n"
"`binding` is a keyword list with the value of all variable bindings\n"
"after evaluating `string`. The binding key is usually an atom, but it\n"
"may be a tuple for variables defined in a different context.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Code.eval_string(\"a + b\", [a: 1, b: 2], file: __ENV__.file, line: "
"__ENV__.line)\n"
"    {3, [a: 1, b: 2]}\n"
"\n"
"    iex> Code.eval_string(\"c = a + b\", [a: 1, b: 2], __ENV__)\n"
"    {3, [a: 1, b: 2, c: 3]}\n"
"\n"
"    iex> Code.eval_string(\"a = a + b\", [a: 1, b: 2])\n"
"    {3, [a: 3, b: 2]}\n"
"\n"
"For convenience, you can pass `__ENV__` as the `opts` argument and\n"
"all imports, requires and aliases defined in the current environment\n"
"will be automatically carried over:\n"
"\n"
"    iex> Code.eval_string(\"a + b\", [a: 1, b: 2], __ENV__)\n"
"    {3, [a: 1, b: 2]}\n"
"\n"
msgstr ""
"`string`によって与えられたコンテンツを評価します。\n"
"\n"
"`binding`引数は変数の束縛のキーワードリストです。\n"
"`opts`引数は環境オプションのキーワードリストです。\n"
"\n"
"オプションは次のとおりです:\n"
"\n"
"  * `:file`               - 評価の間、想定するファイル名を指定します\n"
"  * `:line`               - スクリプトが開始する行番号を指定します\n"
"\n"
"加えて、以下のスコープ値も設定できます:\n"
"\n"
"  * `:aliases` - エリアスとそのターゲットのタプルリストです\n"
"\n"
"  * `:requires` - requireするモジュールのリストです\n"
"\n"
"  * `:functions` - 最初の要素がモジュールで、二番目の要素が\n"
"      importされた関数名とアリティのリストとなるタプルのリストです;\n"
"      関数名とアリティのリストはソートされてなければなりません\n"
"\n"
"  * `:macros` - 最初の要素がモジュールで、二番目の要素が\n"
"      importされたマクロ名とアリティのリストとなるタプルのリストです;\n"
"      マクロ名とアリティのリストはソートされてなければなりません\n"
"\n"
"上記の値の設定により、Elixirのデフォルト値を上書きすることに、注意して\n"
"ください。例えば、`:requires`を`[]`に設定すると、もはや`Kernel`モジュー\n"
"ルを自動的にはrequireしません; 同じように、`:macros`を設定すると、もは\n"
"や`if`、`case`等といった`Kernel`マクロは自動importされません。\n"
"\n"
"`{value, binding}`形式のタプルを返します。\n"
"`value`は`string`を評価した戻り値です。もし`string`を評価\n"
"している間にエラーが起きたら、例外が上ります。\n"
"\n"
"`binding`は、`string`を評価した後の全ての変数束縛の値の、\n"
"キーワードリストです。束縛キーは通常アトムですが、\n"
"異るコンテキストで定義された変数を示すタプルであるかもしれません。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Code.eval_string(\"a + b\", [a: 1, b: 2], file: __ENV__.file, line: "
"__ENV__.line)\n"
"    {3, [a: 1, b: 2]}\n"
"\n"
"    iex> Code.eval_string(\"c = a + b\", [a: 1, b: 2], __ENV__)\n"
"    {3, [a: 1, b: 2, c: 3]}\n"
"\n"
"    iex> Code.eval_string(\"a = a + b\", [a: 1, b: 2])\n"
"    {3, [a: 3, b: 2]}\n"
"\n"
"便宜上、`opts`引数として`__ENV__`を使うことができます。それは、\n"
"現在の環境で定義された全てのimport、require、aliasを自動的に\n"
"引き継ぎます:\n"
"\n"
"    iex> Code.eval_string(\"a + b\", [a: 1, b: 2], __ENV__)\n"
"    {3, [a: 1, b: 2]}\n"
"\n"

#. TRANSLATORS: def Code.eval_file(file, relative_to \\ nil)
#: lib/code.ex:285
msgid ""
"Evals the given file.\n"
"\n"
"Accepts `relative_to` as an argument to tell where the file is located.\n"
"\n"
"While `load_file` loads a file and returns the loaded modules and their\n"
"byte code, `eval_file` simply evaluates the file contents and returns the\n"
"evaluation result and its bindings.\n"
msgstr ""
"与えられたファイルを評価します。\n"
"\n"
"ファイルが置かれた位置を知らせるための引数として、\n"
"`relative_to`を受け付けます。\n"
"\n"
"`load_file`が、ファイルをロードし、ロードされたモジュールとその\n"
"バイトコードを返す一方、`eval_file`は単にファイルのコンテンツを評価し、\n"
"その評価結果とバインディングを返します。\n"

#. TRANSLATORS: def Code.delete_path(path)
#: lib/code.ex:82
msgid ""
"Deletes a path from the Erlang VM code path list. This is the list of\n"
"directories the Erlang VM uses for finding module code.\n"
"\n"
"The path is expanded with `Path.expand/1` before being deleted. If the\n"
"path does not exist it returns `false`.\n"
"\n"
"## Examples\n"
"\n"
"    Code.prepend_path(\".\")\n"
"    Code.delete_path(\".\") #=> true\n"
"\n"
"    Code.delete_path(\"/does_not_exist\") #=> false\n"
"\n"
msgstr ""
"Erlang VM codeパスリストからpathを削除します。これは\n"
"Erlang VMがモジュールコードを見付けるために使うディレクトリリストです。\n"
"\n"
"\n"
"pathは削除される前に`Path.expand/1`で展開されます。\n"
"もしこのpathが存在しないなら、`false`が返されます。\n"
"\n"
"## Examples\n"
"\n"
"    Code.prepend_path(\".\")\n"
"    Code.delete_path(\".\") #=> true\n"
"\n"
"    Code.delete_path(\"/does_not_exist\") #=> false\n"
"\n"

#. TRANSLATORS: def Code.prepend_path(path)
#: lib/code.ex:62
msgid ""
"Prepends a path to the begining of the Erlang VM code path list.\n"
"\n"
"This is the list of directories the Erlang VM uses for finding\n"
"module code.\n"
"\n"
"The path is expanded with `Path.expand/1` before being prepended.\n"
"If this path does not exist, an error is returned.\n"
"\n"
"## Examples\n"
"\n"
"    Code.prepend_path(\".\") #=> true\n"
"\n"
"    Code.prepend_path(\"/does_not_exist\") #=> {:error, :bad_directory}\n"
"\n"
msgstr ""
"Erlang VM codeパスリストの先頭にpathを追加します。\n"
"\n"
"これはErlang VMがモジュールコードを見付けるために使うディレクトリ\n"
"リストです。\n"
"\n"
"pathは追加される前に`Path.expand/1`で展開されます。\n"
"もしこのpathが存在しないなら、errorが返されます。\n"
"\n"
"## Examples\n"
"\n"
"    Code.prepend_path(\".\") #=> true\n"
"\n"
"    Code.prepend_path(\"/does_not_exist\") #=> {:error, :bad_directory}\n"
"\n"

#. TRANSLATORS: def Code.string_to_quoted(string, opts \\ [])
#: lib/code.ex:241
msgid ""
"Converts the given string to its quoted form.\n"
"\n"
"Returns `{:ok, quoted_form}`\n"
"if it succeeds, `{:error, {line, error, token}}` otherwise.\n"
"\n"
"## Options\n"
"\n"
"  * `:file` - the filename to be used in stacktraces\n"
"    and the file reported in the `__ENV__` variable\n"
"\n"
"  * `:line` - the line reported in the `__ENV__` variable\n"
"\n"
"  * `:existing_atoms_only` - when `true`, raises an error\n"
"    when non-existing atoms are found by the tokenizer\n"
"\n"
"## Macro.to_string/2\n"
"\n"
"The opposite of converting a string to its quoted form is\n"
"`Macro.to_string/2`, which converts a quoted form to a string/binary\n"
"representation.\n"
msgstr ""
"与えられた文字列をquoteされたフォームに変換します。\n"
"\n"
"成功すれば、`{:ok, quoted_form}`を返し、さもなければ、`{:error, {line,\n"
"error, token}}`を返します。\n"
"\n"
"## オプション\n"
"\n"
"  * `:file` - スタックトレースと、`__ENV__`変数に格納されるファイル名を\n"
"    指定します\n"
"\n"
"  * `:line` - `__ENV__`変数に格納される行番号を指定します\n"
"\n"
"  * `:existing_atoms_only` - `true`の時、トークナイザーにより、存在しな\n"
"    いatomが見付かったとき、エラーを上げます\n"
"\n"
"## Macro.to_string/2\n"
"\n"
"文字列をquoteされたフォームに変換することの反対は`Macro.to_string/2`で\n"
"す。それはquoteされたフォームを文字列/バイナリの表現に変換します。\n"

#. TRANSLATORS: def Code.string_to_quoted!(string, opts \\ [])
#: lib/code.ex:269
msgid ""
"Converts the given string to its quoted form.\n"
"\n"
"It returns the ast if it succeeds,\n"
"raises an exception otherwise. The exception is a `TokenMissingError`\n"
"in case a token is missing (usually because the expression is incomplete),\n"
"`SyntaxError` otherwise.\n"
"\n"
"Check `string_to_quoted/2` for options information.\n"
msgstr ""
"与えられた文字列をquoteされたフォームに変換します。\n"
"\n"
"成功すれば、`{:ok, quoted_form}`を返し、さもなければ、\n"
"例外を上げます。例外は、トークンが足りない場合に(通常は式が\n"
"不完全の時です)、`TokenMissingError`で、さもなくば`SyntaxError`です。\n"
"\n"
"オプション情報は `string_to_quoted/2` を参照してください。\n"

#. TRANSLATORS: def Code.compile_quoted(quoted, file \\ "nofile")
#: lib/code.ex:449
msgid ""
"Compiles the quoted expression.\n"
"\n"
"Returns a list of tuples where the first element is the module name and\n"
"the second one is its byte code (as a binary).\n"
msgstr ""
"quoteされた式をコンパイルします。\n"
"\n"
"最初の要素はモジュール名で、2番目の要素はその(バイナリとしての)バイトコード\n"
"となる、タプルのリストを返します。\n"

#. TRANSLATORS: def Code.compile_string(string, file \\ "nofile")
#: lib/code.ex:437
msgid ""
"Compiles the given string.\n"
"\n"
"Returns a list of tuples where the first element is the module name\n"
"and the second one is its byte code (as a binary).\n"
"\n"
"For compiling many files at once, check `Kernel.ParallelCompiler.files/2`.\n"
msgstr ""
"与えられた文字列をコンパイルします。\n"
"\n"
"最初の要素はモジュール名で、2番目の要素はその(バイナリとしての)バイトコード\n"
"となる、タプルのリストを返します。\n"
"\n"
"一度に多くのファイルをコンパイルするためには、\n"
"`Kernel.ParallelCompiler.files/2`をチェックしてください。\n"

#. TRANSLATORS: def Code.append_path(path)
#: lib/code.ex:42
msgid ""
"Appends a path to the end of the Erlang VM code path list.\n"
"\n"
"This is the list of directories the Erlang VM uses for\n"
"finding module code.\n"
"\n"
"The path is expanded with `Path.expand/1` before being appended.\n"
"If this path does not exist, an error is returned.\n"
"\n"
"## Examples\n"
"\n"
"    Code.append_path(\".\") #=> true\n"
"\n"
"    Code.append_path(\"/does_not_exist\") #=> {:error, :bad_directory}\n"
"\n"
msgstr ""
"Erlang VM codeパスリストの最後にpathを追加します。\n"
"\n"
"これはErlang VMがモジュールコードを見付けるために使うディレクトリ\n"
"リストです。\n"
"\n"
"pathは追加される前に`Path.expand/1`で展開されます。\n"
"もしこのpathが存在しないなら、errorが返されます。\n"
"\n"
"## Examples\n"
"\n"
"    Code.append_path(\".\") #=> true\n"
"\n"
"    Code.append_path(\"/does_not_exist\") #=> {:error, :bad_directory}\n"
"\n"

#~ msgid ""
#~ "Removes files from the loaded files list.\n"
#~ "\n"
#~ "The modules defined in the file are not removed;\n"
#~ "calling this function only removes them from the list,\n"
#~ "allowing them to be required again.\n"
#~ msgstr ""
#~ "ロードされたファイルリストからファイルを取り除きます。\n"
#~ "\n"
#~ "ファイルに定義されているモジュールは取り除かれません;この関数を呼ぶこと\n"
#~ "はリストから取り除くだけで、それらは再び要求されることを許します。\n"

#~ msgid ""
#~ "Re-add paths given to the command line to keep their position\n"
#~ "on the overall code path.\n"
#~ "\n"
#~ "Some tools may change the code path by prepending new items but\n"
#~ "still want the paths given by the user to have higher priority.\n"
#~ "Calling this function guarantees the paths are re-added on\n"
#~ "top of the user given ones.\n"
#~ msgstr ""
#~ "全体的なコードパスのコマンドラインの位置を保つために、\n"
#~ "与えられたパスを再追加します。\n"
#~ "\n"
#~ "幾つかのツールは、新しいアイテムを前に加えることによって、コードパスを\n"
#~ "変更するかもしれませんが、まだ、より高いプライオリティを持つことをユー\n"
#~ "ザが望むかもしれません。この関数を呼ぶことは、ユーザが与えたパスがトッ\n"
#~ "プに再追加されることを保証します。\n"

#~ msgid ""
#~ "Prepends a path to the Erlang VM code path.\n"
#~ "\n"
#~ "The path is expanded with `Path.expand/1` before being prepended.\n"
#~ msgstr ""
#~ "Erlang VMのコードパスにpathを前に付加します。\n"
#~ "\n"
#~ "pathは付加される前に、`Path.expand/1`で展開されます。\n"

#~ msgid "Lists all loaded files.\n"
#~ msgstr "全てのロードされたファイルのリストです。\n"

#~ msgid ""
#~ "Deletes a path from the Erlang VM code path.\n"
#~ "\n"
#~ "The path is expanded with `Path.expand/1` before being deleted.\n"
#~ msgstr ""
#~ "Erlang VMコードパスからpathを削除します。\n"
#~ "\n"
#~ "pathは削除される前に、`Path.expand/1`で展開されます。\n"

#~ msgid ""
#~ "Appends a path to the Erlang VM code path.\n"
#~ "\n"
#~ "The path is expanded with `Path.expand/1` before being appended.\n"
#~ msgstr ""
#~ "Erlang VMコードパスにpathを後ろに追加します。\n"
#~ "\n"
#~ "pathは付加される前に、`Path.expand/1`で展開されます。\n"
