#. TRANSLATORS: Elixir.Code Summary
#: lib/code.ex:1 
msgid ""
"Utilities for managing code compilation, code evaluation and code loading.\n"
"\n"
"This module complements [Erlang's code module](http://www.erlang.org/doc/man/code.html)\n"
"to add behaviour which is specific to Elixir.\n"
msgstr ""
#. TRANSLATORS: def Code.ensure_loaded?(module)
#: lib/code.ex:441 
msgid ""
"Ensures the given module is loaded.\n"
"\n"
"Similar to `ensure_loaded/1`, but returns `true` if the module\n"
"is already loaded or was successfully loaded. Returns `false`\n"
"otherwise.\n"
msgstr ""
#. TRANSLATORS: def Code.ensure_loaded(module)
#: lib/code.ex:430 
msgid ""
"Ensures the given module is loaded.\n"
"\n"
"If the module is already loaded, this works as no-op. If the module\n"
"was not yet loaded, it tries to load it.\n"
"\n"
"If it succeeds loading the module, it returns `{:module, module}`.\n"
"If not, returns `{:error, reason}` with the error reason.\n"
"\n"
"## Code loading on the Erlang VM\n"
"\n"
"Erlang has two modes to load code: interactive and embedded.\n"
"\n"
"By default, the Erlang VM runs in interactive mode, where modules\n"
"are loaded as needed. In embedded mode the opposite happens, as all\n"
"modules need to be loaded upfront or explicitly.\n"
"\n"
"Therefore, this function is used to check if a module is loaded\n"
"before using it and allows one to react accordingly. For example, the `URI`\n"
"module uses this function to check if a specific parser exists for a given\n"
"URI scheme.\n"
"\n"
"## `Code.ensure_compiled/1`\n"
"\n"
"Elixir also contains an `ensure_compiled/1` function that is a\n"
"superset of `ensure_loaded/1`.\n"
"\n"
"Since Elixir's compilation happens in parallel, in some situations\n"
"you may need to use a module that was not yet compiled, therefore\n"
"it can't even be loaded.\n"
"\n"
"`ensure_compiled/1` halts the current process until the\n"
"module we are depending on is available.\n"
"\n"
"In most cases, `ensure_loaded/1` is enough. `ensure_compiled/1`\n"
"must be used in rare cases, usually involving macros that need to\n"
"invoke a module for callback information.\n"
msgstr ""
#. TRANSLATORS: def Code.ensure_compiled?(module)
#: lib/code.ex:482 
msgid ""
"Ensures the given module is compiled and loaded.\n"
"\n"
"Similar to `ensure_compiled/1`, but returns `true` if the module\n"
"is already loaded or was successfully loaded and compiled.\n"
"Returns `false` otherwise.\n"
msgstr ""
#. TRANSLATORS: def Code.ensure_compiled(module)
#: lib/code.ex:458 
msgid ""
"Ensures the given module is compiled and loaded.\n"
"\n"
"If the module is already loaded, it works as no-op. If the module was\n"
"not loaded yet, it checks if it needs to be compiled first and then\n"
"tries to load it.\n"
"\n"
"If it succeeds loading the module, it returns `{:module, module}`.\n"
"If not, returns `{:error, reason}` with the error reason.\n"
"\n"
"Check `ensure_loaded/1` for more information on module loading\n"
"and when to use `ensure_loaded/1` or `ensure_compiled/1`.\n"
msgstr ""
#. TRANSLATORS: def Code.require_file(file, relative_to \\ nil)
#: lib/code.ex:307 
msgid ""
"Requires the given `file`.\n"
"\n"
"Accepts `relative_to` as an argument to tell where the file is located.\n"
"The return value is the same as that of `load_file/2`. If the file was already\n"
"required/loaded, doesn't do anything and returns `nil`.\n"
"\n"
"Notice that if `require_file` is invoked by different processes concurrently,\n"
"the first process to invoke `require_file` acquires a lock and the remaining\n"
"ones will block until the file is available. I.e. if `require_file` is called\n"
"N times with a given file, it will be loaded only once. The first process to\n"
"call `require_file` will get the list of loaded modules, others will get `nil`.\n"
"\n"
"Check `load_file/2` if you want a file to be loaded multiple times.\n"
msgstr ""
#. TRANSLATORS: def Code.unload_files(files)
#: lib/code.ex:23 
msgid ""
"Removes files from the loaded files list.\n"
"\n"
"The modules defined in the file are not removed;\n"
"calling this function only removes them from the list,\n"
"allowing them to be required again.\n"
msgstr ""
#. TRANSLATORS: def Code.readd_paths()
#: lib/code.ex:64 
msgid ""
"Re-add paths given to the command line to keep their position\n"
"on the overall code path.\n"
"\n"
"Some tools may change the code path by prepending new items but\n"
"still want the paths given by the user to have higher priority.\n"
"Calling this function guarantees the paths are re-added on\n"
"top of the user given ones.\n"
msgstr ""
#. TRANSLATORS: def Code.prepend_path(path)
#: lib/code.ex:41 
msgid ""
"Prepends a path to the Erlang VM code path.\n"
"\n"
"The path is expanded with `Path.expand/1` before being prepended.\n"
msgstr ""
#. TRANSLATORS: def Code.compiler_options(opts)
#: lib/code.ex:361 
msgid ""
"Sets compilation options.\n"
"\n"
"These options are global since they are stored by Elixir's Code Server.\n"
"\n"
"Available options are:\n"
"\n"
"  * `:docs` - when `true`, retain documentation in the compiled module,\n"
"    `true` by default\n"
"\n"
"  * `:debug_info` - when `true`, retain debug information in the compiled\n"
"    module; this allows a developer to reconstruct the original source\n"
"    code, `false` by default\n"
"\n"
"  * `:ignore_module_conflict` - when `true`, override modules that were\n"
"    already defined without raising errors, `false` by default\n"
"\n"
"  * `:warnings_as_errors` - cause compilation to fail when warnings are\n"
"    generated\n"
"\n"
msgstr ""
#. TRANSLATORS: def Code.load_file(file, relative_to \\ nil)
#: lib/code.ex:284 
msgid ""
"Loads the given file.\n"
"\n"
"Accepts `relative_to` as an argument to tell where the file is located.\n"
"If the file was already required/loaded, loads it again.\n"
"\n"
"It returns a list of tuples `{ModuleName, <<byte_code>>}`, one tuple for\n"
"each module defined in the file.\n"
"\n"
"Notice that if `load_file` is invoked by different processes concurrently,\n"
"the target file will be loaded concurrently many times. Check `require_file/2`\n"
"if you don't want a file to be loaded concurrently.\n"
msgstr ""
#. TRANSLATORS: def Code.compiler_options()
#: lib/code.ex:327 
msgid ""
"Gets the compilation options from the code server.\n"
"\n"
"Check `compiler_options/1` for more information.\n"
msgstr ""
#. TRANSLATORS: def Code.eval_quoted(quoted, binding \\ [], opts \\ [])
#: lib/code.ex:163 
msgid ""
"Evaluates the quoted contents.\n"
"\n"
"See `eval_string/3` for a description of arguments and return values.\n"
"\n"
"## Examples\n"
"\n"
"    iex> contents = quote(do: var!(a) + var!(b))\n"
"    iex> Code.eval_quoted(contents, [a: 1, b: 2], file: __ENV__.file, line: __ENV__.line)\n"
"    {3, [a: 1, b: 2]}\n"
"\n"
"For convenience, you can pass `__ENV__` as the `opts` argument and\n"
"all options will be automatically extracted from the current environment:\n"
"\n"
"    iex> contents = quote(do: var!(a) + var!(b))\n"
"    iex> Code.eval_quoted(contents, [a: 1, b: 2], __ENV__)\n"
"    {3, [a: 1, b: 2]}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Code.loaded_files()
#: lib/code.ex:12 
msgid ""
"Lists all loaded files.\n"
msgstr ""
#. TRANSLATORS: def Code.eval_string(string, binding \\ [], opts \\ [])
#: lib/code.ex:131 
msgid ""
"Evaluates the contents given by `string`.\n"
"\n"
"The `binding` argument is a keyword list of variable bindings.\n"
"The `opts` argument is a keyword list of environment options.\n"
"\n"
"Those options can be:\n"
"\n"
"  * `:file`               - the file to be considered in the evaluation\n"
"  * `:line`               - the line on which the script starts\n"
"  * `:delegate_locals_to` - delegate local calls to the given module,\n"
"                            the default is to not delegate\n"
"\n"
"Additionally, the following scope values can be configured:\n"
"\n"
"  * `:aliases` - a list of tuples with the alias and its target\n"
"\n"
"  * `:requires` - a list of modules required\n"
"\n"
"  * `:functions` - a list of tuples where the first element is a module\n"
"    and the second a list of imported function names and arity; the list\n"
"    of function names and arity must be sorted\n"
"\n"
"  * `:macros` - a list of tuples where the first element is a module\n"
"    and the second a list of imported macro names and arity; the list\n"
"    of function names and arity must be sorted\n"
"\n"
"Notice that setting any of the values above overrides Elixir's default\n"
"values. For example, setting `:requires` to `[]`, will no longer\n"
"automatically require the `Kernel` module; in the same way setting\n"
"`:macros` will no longer auto-import `Kernel` macros like `if`, `case`,\n"
"etc.\n"
"\n"
"Returns a tuple of the form `{value, binding}`,\n"
"where `value` is the value returned from evaluating `string`.\n"
"If an error occurs while evaluating `string` an exception will be raised.\n"
"\n"
"`binding` is a keyword list with the value of all variable bindings\n"
"after evaluating `string`. The binding key is usually an atom, but it\n"
"may be a tuple for variables defined in a different context.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Code.eval_string(\"a + b\", [a: 1, b: 2], file: __ENV__.file, line: __ENV__.line)\n"
"    {3, [a: 1, b: 2]}\n"
"\n"
"    iex> Code.eval_string(\"c = a + b\", [a: 1, b: 2], __ENV__)\n"
"    {3, [a: 1, b: 2, c: 3]}\n"
"\n"
"    iex> Code.eval_string(\"a = a + b\", [a: 1, b: 2])\n"
"    {3, [a: 3, b: 2]}\n"
"\n"
"For convenience, you can pass `__ENV__` as the `opts` argument and\n"
"all imports, requires and aliases defined in the current environment\n"
"will be automatically carried over:\n"
"\n"
"    iex> Code.eval_string(\"a + b\", [a: 1, b: 2], __ENV__)\n"
"    {3, [a: 1, b: 2]}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Code.eval_file(file, relative_to \\ nil)
#: lib/code.ex:266 
msgid ""
"Evals the given file.\n"
"\n"
"Accepts `relative_to` as an argument to tell where the file is located.\n"
"\n"
"While `load_file` loads a file and returns the loaded modules and their\n"
"byte code, `eval_file` simply evaluates the file contents and returns the\n"
"evaluation result and its bindings.\n"
msgstr ""
#. TRANSLATORS: def Code.delete_path(path)
#: lib/code.ex:50 
msgid ""
"Deletes a path from the Erlang VM code path.\n"
"\n"
"The path is expanded with `Path.expand/1` before being deleted.\n"
msgstr ""
#. TRANSLATORS: def Code.string_to_quoted(string, opts \\ [])
#: lib/code.ex:235 
msgid ""
"Converts the given string to its quoted form.\n"
"\n"
"Returns `{:ok, quoted_form}`\n"
"if it succeeds, `{:error, {line, error, token}}` otherwise.\n"
"\n"
"## Options\n"
"\n"
"  * `:file` - the filename to be used in stacktraces\n"
"    and the file reported in the `__ENV__` variable\n"
"\n"
"  * `:line` - the line reported in the `__ENV__` variable\n"
"\n"
"  * `:existing_atoms_only` - when `true`, raises an error\n"
"    when non-existing atoms are found by the tokenizer\n"
"\n"
"## Macro.to_string/2\n"
"\n"
"The opposite of converting a string to its quoted form is\n"
"`Macro.to_string/2`, which converts a quoted form to a string/binary\n"
"representation.\n"
msgstr ""
#. TRANSLATORS: def Code.string_to_quoted!(string, opts \\ [])
#: lib/code.ex:251 
msgid ""
"Converts the given string to its quoted form.\n"
"\n"
"It returns the ast if it succeeds,\n"
"raises an exception otherwise. The exception is a `TokenMissingError`\n"
"in case a token is missing (usually because the expression is incomplete),\n"
"`SyntaxError` otherwise.\n"
"\n"
"Check `string_to_quoted/2` for options information.\n"
msgstr ""
#. TRANSLATORS: def Code.compile_quoted(quoted, file \\ "nofile")
#: lib/code.ex:388 
msgid ""
"Compiles the quoted expression.\n"
"\n"
"Returns a list of tuples where the first element is the module name and\n"
"the second one is its byte code (as a binary).\n"
msgstr ""
#. TRANSLATORS: def Code.compile_string(string, file \\ "nofile")
#: lib/code.ex:378 
msgid ""
"Compiles the given string.\n"
"\n"
"Returns a list of tuples where the first element is the module name\n"
"and the second one is its byte code (as a binary).\n"
"\n"
"For compiling many files at once, check `Kernel.ParallelCompiler.files/2`.\n"
msgstr ""
#. TRANSLATORS: def Code.available_compiler_options()
#: lib/code.ex:336 
msgid ""
"Returns a list with the available compiler options.\n"
"\n"
"See `Code.compiler_options/1` for more info.\n"
msgstr ""
#. TRANSLATORS: def Code.get_docs(module, kind)
#: lib/code.ex:506 
msgid ""
"Returns the docs for the given module.\n"
"\n"
"When given a module name, it finds its BEAM code and reads the docs from it.\n"
"\n"
"When given a path to a .beam file, it will load the docs directly from that\n"
"file.\n"
"\n"
"The return value depends on the `kind` value:\n"
"\n"
"  * `:docs` - list of all docstrings attached to functions and macros\n"
"    using the `@doc` attribute\n"
"\n"
"  * `:moduledoc` - tuple `{<line>, <doc>}` where `line` is the line on\n"
"    which module definition starts and `doc` is the string\n"
"    attached to the module using the `@moduledoc` attribute\n"
"\n"
"  * `:all` - a keyword list with both `:docs` and `:moduledoc`\n"
"\n"
msgstr ""
#. TRANSLATORS: def Code.append_path(path)
#: lib/code.ex:32 
msgid ""
"Appends a path to the Erlang VM code path.\n"
"\n"
"The path is expanded with `Path.expand/1` before being appended.\n"
msgstr ""
