#. TRANSLATORS: def Code.string_to_quoted(string, opts \\ [])
#: lib/code.ex:241 
msgid ""
"Converts the given string to its quoted form.\n"
"\n"
"Returns `{:ok, quoted_form}`\n"
"if it succeeds, `{:error, {line, error, token}}` otherwise.\n"
"\n"
"## Options\n"
"\n"
"  * `:file` - the filename to be used in stacktraces\n"
"    and the file reported in the `__ENV__` variable\n"
"\n"
"  * `:line` - the line reported in the `__ENV__` variable\n"
"\n"
"  * `:existing_atoms_only` - when `true`, raises an error\n"
"    when non-existing atoms are found by the tokenizer\n"
"\n"
"## Macro.to_string/2\n"
"\n"
"The opposite of converting a string to its quoted form is\n"
"`Macro.to_string/2`, which converts a quoted form to a string/binary\n"
"representation.\n"
msgstr ""
#. TRANSLATORS: def Code.compiler_options()
#: lib/code.ex:369 
msgid ""
"Gets the compilation options from the code server.\n"
"\n"
"Check `compiler_options/1` for more information.\n"
"\n"
"## Examples\n"
"\n"
"    Code.compiler_options\n"
"    #=> %{debug_info: true, docs: true,\n"
"          warnings_as_errors: false, ignore_module_conflict: false}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Code.eval_string(string, binding \\ [], opts \\ [])
#: lib/code.ex:101 
msgid ""
"Evaluates the contents given by `string`.\n"
"\n"
"The `binding` argument is a keyword list of variable bindings.\n"
"The `opts` argument is a keyword list of environment options.\n"
"\n"
"Those options can be:\n"
"\n"
"  * `:file` - the file to be considered in the evaluation\n"
"  * `:line` - the line on which the script starts\n"
"\n"
"Additionally, the following scope values can be configured:\n"
"\n"
"  * `:aliases` - a list of tuples with the alias and its target\n"
"\n"
"  * `:requires` - a list of modules required\n"
"\n"
"  * `:functions` - a list of tuples where the first element is a module\n"
"    and the second a list of imported function names and arity; the list\n"
"    of function names and arity must be sorted\n"
"\n"
"  * `:macros` - a list of tuples where the first element is a module\n"
"    and the second a list of imported macro names and arity; the list\n"
"    of function names and arity must be sorted\n"
"\n"
"Notice that setting any of the values above overrides Elixir's default\n"
"values. For example, setting `:requires` to `[]`, will no longer\n"
"automatically require the `Kernel` module; in the same way setting\n"
"`:macros` will no longer auto-import `Kernel` macros like `if`, `case`,\n"
"etc.\n"
"\n"
"Returns a tuple of the form `{value, binding}`,\n"
"where `value` is the value returned from evaluating `string`.\n"
"If an error occurs while evaluating `string` an exception will be raised.\n"
"\n"
"`binding` is a keyword list with the value of all variable bindings\n"
"after evaluating `string`. The binding key is usually an atom, but it\n"
"may be a tuple for variables defined in a different context.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Code.eval_string(\"a + b\", [a: 1, b: 2], file: __ENV__.file, line: __ENV__.line)\n"
"    {3, [a: 1, b: 2]}\n"
"\n"
"    iex> Code.eval_string(\"c = a + b\", [a: 1, b: 2], __ENV__)\n"
"    {3, [a: 1, b: 2, c: 3]}\n"
"\n"
"    iex> Code.eval_string(\"a = a + b\", [a: 1, b: 2])\n"
"    {3, [a: 3, b: 2]}\n"
"\n"
"For convenience, you can pass `__ENV__` as the `opts` argument and\n"
"all imports, requires and aliases defined in the current environment\n"
"will be automatically carried over:\n"
"\n"
"    iex> Code.eval_string(\"a + b\", [a: 1, b: 2], __ENV__)\n"
"    {3, [a: 1, b: 2]}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Code.compiler_options(opts)
#: lib/code.ex:400 
msgid ""
"Sets compilation options.\n"
"\n"
"These options are global since they are stored by Elixir's Code Server.\n"
"\n"
"Available options are:\n"
"\n"
"  * `:docs` - when `true`, retain documentation in the compiled module,\n"
"    `true` by default\n"
"\n"
"  * `:debug_info` - when `true`, retain debug information in the compiled\n"
"    module; this allows a developer to reconstruct the original source\n"
"    code, `false` by default\n"
"\n"
"  * `:ignore_module_conflict` - when `true`, override modules that were\n"
"    already defined without raising errors, `false` by default\n"
"\n"
"  * `:warnings_as_errors` - cause compilation to fail when warnings are\n"
"    generated\n"
"\n"
"It returns the new list of compiler options.\n"
"\n"
"## Examples\n"
"\n"
"    Code.compiler_options(debug_info: true)\n"
"    #=> %{debug_info: true, docs: true,\n"
"          warnings_as_errors: false, ignore_module_conflict: false}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Code.available_compiler_options()
#: lib/code.ex:385 
msgid ""
"Returns a list with the available compiler options.\n"
"\n"
"See `Code.compiler_options/1` for more info.\n"
"\n"
"## Examples\n"
"\n"
"    Code.available_compiler_options\n"
"    #=> [:docs, :debug_info, :ignore_module_conflict, :warnings_as_errors]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Code.prepend_path(path)
#: lib/code.ex:62 
msgid ""
"Prepends a path to the begining of the Erlang VM code path list.\n"
"\n"
"This is the list of directories the Erlang VM uses for finding\n"
"module code.\n"
"\n"
"The path is expanded with `Path.expand/1` before being prepended.\n"
"If this path does not exist, an error is returned.\n"
"\n"
"## Examples\n"
"\n"
"    Code.prepend_path(\".\") #=> true\n"
"\n"
"    Code.prepend_path(\"/does_not_exist\") #=> {:error, :bad_directory}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Code.ensure_compiled(module)
#: lib/code.ex:529 
msgid ""
"Ensures the given module is compiled and loaded.\n"
"\n"
"If the module is already loaded, it works as no-op. If the module was\n"
"not loaded yet, it checks if it needs to be compiled first and then\n"
"tries to load it.\n"
"\n"
"If it succeeds loading the module, it returns `{:module, module}`.\n"
"If not, returns `{:error, reason}` with the error reason.\n"
"\n"
"Check `ensure_loaded/1` for more information on module loading\n"
"and when to use `ensure_loaded/1` or `ensure_compiled/1`.\n"
msgstr ""
#. TRANSLATORS: def Code.compile_quoted(quoted, file \\ "nofile")
#: lib/code.ex:451 
msgid ""
"Compiles the quoted expression.\n"
"\n"
"Returns a list of tuples where the first element is the module name and\n"
"the second one is its byte code (as a binary).\n"
msgstr ""
#. TRANSLATORS: def Code.eval_quoted(quoted, binding \\ [], opts \\ [])
#: lib/code.ex:172 
msgid ""
"Evaluates the quoted contents.\n"
"\n"
"See `eval_string/3` for a description of arguments and return values.\n"
"\n"
"## Examples\n"
"\n"
"    iex> contents = quote(do: var!(a) + var!(b))\n"
"    iex> Code.eval_quoted(contents, [a: 1, b: 2], file: __ENV__.file, line: __ENV__.line)\n"
"    {3, [a: 1, b: 2]}\n"
"\n"
"For convenience, you can pass `__ENV__` as the `opts` argument and\n"
"all options will be automatically extracted from the current environment:\n"
"\n"
"    iex> contents = quote(do: var!(a) + var!(b))\n"
"    iex> Code.eval_quoted(contents, [a: 1, b: 2], __ENV__)\n"
"    {3, [a: 1, b: 2]}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Code.unload_files(files)
#: lib/code.ex:23 
msgid ""
"Removes files from the loaded files list.\n"
"\n"
"The modules defined in the file are not removed;\n"
"calling this function only removes them from the list,\n"
"allowing them to be required again.\n"
"\n"
"## Examples\n"
"\n"
"    # Load EEx test code, unload file, check for functions still available\n"
"    Code.load_file(\"../eex/test/eex_test.exs\")\n"
"    Code.unload_files(Code.loaded_files)\n"
"    function_exported?(EExTest.Compiled, :before_compile, 0) #=> true\n"
"\n"
msgstr ""
#. TRANSLATORS: def Code.loaded_files()
#: lib/code.ex:10 
msgid ""
"Lists all loaded files.\n"
"\n"
"## Examples\n"
"\n"
"    Code.require_file(\"../eex/test/eex_test.exs\")\n"
"    List.first(Code.loaded_files) =~ \"eex_test.exs\" #=> true\n"
"\n"
msgstr ""
#. TRANSLATORS: def Code.ensure_loaded(module)
#: lib/code.ex:461 
msgid ""
"Ensures the given module is loaded.\n"
"\n"
"If the module is already loaded, this works as no-op. If the module\n"
"was not yet loaded, it tries to load it.\n"
"\n"
"If it succeeds loading the module, it returns `{:module, module}`.\n"
"If not, returns `{:error, reason}` with the error reason.\n"
"\n"
"## Code loading on the Erlang VM\n"
"\n"
"Erlang has two modes to load code: interactive and embedded.\n"
"\n"
"By default, the Erlang VM runs in interactive mode, where modules\n"
"are loaded as needed. In embedded mode the opposite happens, as all\n"
"modules need to be loaded upfront or explicitly.\n"
"\n"
"Therefore, this function is used to check if a module is loaded\n"
"before using it and allows one to react accordingly. For example, the `URI`\n"
"module uses this function to check if a specific parser exists for a given\n"
"URI scheme.\n"
"\n"
"## Code.ensure_compiled/1\n"
"\n"
"Elixir also contains an `ensure_compiled/1` function that is a\n"
"superset of `ensure_loaded/1`.\n"
"\n"
"Since Elixir's compilation happens in parallel, in some situations\n"
"you may need to use a module that was not yet compiled, therefore\n"
"it can't even be loaded.\n"
"\n"
"`ensure_compiled/1` halts the current process until the\n"
"module we are depending on is available.\n"
"\n"
"In most cases, `ensure_loaded/1` is enough. `ensure_compiled/1`\n"
"must be used in rare cases, usually involving macros that need to\n"
"invoke a module for callback information.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Code.ensure_loaded(Atom)\n"
"    {:module, Atom}\n"
"\n"
"    iex> Code.ensure_loaded(DoesNotExist)\n"
"    {:error, :nofile}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Code.string_to_quoted!(string, opts \\ [])
#: lib/code.ex:269 
msgid ""
"Converts the given string to its quoted form.\n"
"\n"
"It returns the ast if it succeeds,\n"
"raises an exception otherwise. The exception is a `TokenMissingError`\n"
"in case a token is missing (usually because the expression is incomplete),\n"
"`SyntaxError` otherwise.\n"
"\n"
"Check `string_to_quoted/2` for options information.\n"
msgstr ""
#. TRANSLATORS: def Code.delete_path(path)
#: lib/code.ex:82 
msgid ""
"Deletes a path from the Erlang VM code path list. This is the list of\n"
"directories the Erlang VM uses for finding module code.\n"
"\n"
"The path is expanded with `Path.expand/1` before being deleted. If the\n"
"path does not exist it returns `false`.\n"
"\n"
"## Examples\n"
"\n"
"    Code.prepend_path(\".\")\n"
"    Code.delete_path(\".\") #=> true\n"
"\n"
"    Code.delete_path(\"/does_not_exist\") #=> false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Code.load_file(file, relative_to \\ nil)
#: lib/code.ex:299 
msgid ""
"Loads the given file.\n"
"\n"
"Accepts `relative_to` as an argument to tell where the file is located.\n"
"If the file was already required/loaded, loads it again.\n"
"\n"
"It returns a list of tuples `{ModuleName, <<byte_code>>}`, one tuple for\n"
"each module defined in the file.\n"
"\n"
"Notice that if `load_file` is invoked by different processes concurrently,\n"
"the target file will be loaded concurrently many times. Check `require_file/2`\n"
"if you don't want a file to be loaded concurrently.\n"
"\n"
"## Examples\n"
"\n"
"    Code.load_file(\"eex_test.exs\",\"../eex/test\") |> List.first\n"
"    #=> {EExTest.Compiled, <<70, 79, 82, 49, ...>>}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Code.append_path(path)
#: lib/code.ex:42 
msgid ""
"Appends a path to the end of the Erlang VM code path list.\n"
"\n"
"This is the list of directories the Erlang VM uses for\n"
"finding module code.\n"
"\n"
"The path is expanded with `Path.expand/1` before being appended.\n"
"If this path does not exist, an error is returned.\n"
"\n"
"## Examples\n"
"\n"
"    Code.append_path(\".\") #=> true\n"
"\n"
"    Code.append_path(\"/does_not_exist\") #=> {:error, :bad_directory}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Code.ensure_loaded?(module)
#: lib/code.ex:512 
msgid ""
"Ensures the given module is loaded.\n"
"\n"
"Similar to `ensure_loaded/1`, but returns `true` if the module\n"
"is already loaded or was successfully loaded. Returns `false`\n"
"otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Code.ensure_loaded?(Atom)\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: def Code.require_file(file, relative_to \\ nil)
#: lib/code.ex:326 
msgid ""
"Requires the given `file`.\n"
"\n"
"Accepts `relative_to` as an argument to tell where the file is located.\n"
"The return value is the same as that of `load_file/2`. If the file was already\n"
"required/loaded, doesn't do anything and returns `nil`.\n"
"\n"
"Notice that if `require_file` is invoked by different processes concurrently,\n"
"the first process to invoke `require_file` acquires a lock and the remaining\n"
"ones will block until the file is available. I.e. if `require_file` is called\n"
"N times with a given file, it will be loaded only once. The first process to\n"
"call `require_file` will get the list of loaded modules, others will get `nil`.\n"
"\n"
"Check `load_file/2` if you want a file to be loaded multiple times. See also\n"
"`unload_files/1`\n"
"\n"
"## Examples\n"
"\n"
"If the code is already loaded, it returns `nil`:\n"
"\n"
"    Code.require_file(\"eex_test.exs\",\"../eex/test\") #=> nil\n"
"\n"
"If the code is not loaded yet, it returns the same as `load_file/2`:\n"
"\n"
"    Code.require_file(\"eex_test.exs\",\"../eex/test\") |> List.first\n"
"    #=> {EExTest.Compiled, <<70, 79, 82, 49, ...>>}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Code.get_docs(module, kind)
#: lib/code.ex:570 
msgid ""
"Returns the docs for the given module.\n"
"\n"
"When given a module name, it finds its BEAM code and reads the docs from it.\n"
"\n"
"When given a path to a .beam file, it will load the docs directly from that\n"
"file.\n"
"\n"
"The return value depends on the `kind` value:\n"
"\n"
"  * `:docs` - list of all docstrings attached to functions and macros\n"
"    using the `@doc` attribute\n"
"\n"
"  * `:moduledoc` - tuple `{<line>, <doc>}` where `line` is the line on\n"
"    which module definition starts and `doc` is the string\n"
"    attached to the module using the `@moduledoc` attribute\n"
"\n"
"  * `:callback_docs` - list of all docstrings attached to\n"
"    `@callbacks` using the `@doc` attribute\n"
"\n"
"  * `:type_docs` - list of all docstrings attached to\n"
"    `@type` callbacks using the `@typedoc` attribute\n"
"\n"
"  * `:all` - a keyword list with `:docs` and `:moduledoc`, `:callback_docs`,\n"
"    and `:type_docs`.\n"
"\n"
"If the module cannot be found, it returns `nil`.\n"
"\n"
"## Examples\n"
"\n"
"    # Get the documentation for the first function listed\n"
"    iex> [fun|_] = Code.get_docs(Atom, :docs) |> Enum.sort()\n"
"    iex> {{_function, _arity}, _line, _kind, _signature, text} = fun\n"
"    iex> String.split(text, \"\\n\") |> Enum.at(0)\n"
"    \"Converts an atom to a char list.\"\n"
"\n"
"    # Module doesn't exist\n"
"    iex> Code.get_docs(ModuleNotGood, :all)\n"
"    nil\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.Code Summary
#: lib/code.ex:2 
msgid ""
"Utilities for managing code compilation, code evaluation and code loading.\n"
"\n"
"This module complements Erlang's [`:code` module](http://www.erlang.org/doc/man/code.html)\n"
"to add behaviour which is specific to Elixir. Almost all of the functions in this module\n"
"have global side effects on the behaviour of Elixir.\n"
msgstr ""
#. TRANSLATORS: def Code.eval_file(file, relative_to \\ nil)
#: lib/code.ex:285 
msgid ""
"Evals the given file.\n"
"\n"
"Accepts `relative_to` as an argument to tell where the file is located.\n"
"\n"
"While `load_file` loads a file and returns the loaded modules and their\n"
"byte code, `eval_file` simply evaluates the file contents and returns the\n"
"evaluation result and its bindings.\n"
msgstr ""
#. TRANSLATORS: def Code.compile_string(string, file \\ "nofile")
#: lib/code.ex:439 
msgid ""
"Compiles the given string.\n"
"\n"
"Returns a list of tuples where the first element is the module name\n"
"and the second one is its byte code (as a binary).\n"
"\n"
"For compiling many files at once, check `Kernel.ParallelCompiler.files/2`.\n"
msgstr ""
#. TRANSLATORS: def Code.ensure_compiled?(module)
#: lib/code.ex:559 
msgid ""
"Ensures the given module is compiled and loaded.\n"
"\n"
"Similar to `ensure_compiled/1`, but returns `true` if the module\n"
"is already loaded or was successfully loaded and compiled.\n"
"Returns `false` otherwise.\n"
msgstr ""
