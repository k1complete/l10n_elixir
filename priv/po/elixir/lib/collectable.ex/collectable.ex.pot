#. TRANSLATORS: def Collectable.into(collectable)
#: lib/collectable.ex:31 
msgid ""
"Returns a function that collects values alongside\n"
"the initial accumulation value.\n"
"\n"
"The returned function receives a collectable and injects a given\n"
"value into it for every `{:cont, term}` instruction.\n"
"\n"
"`:done` is passed when no further values will be injected, useful\n"
"for closing resources and normalizing values. A collectable must\n"
"be returned on `:done`.\n"
"\n"
"If injection is suddenly interrupted, `:halt` is passed and it can\n"
"return any value, as it won't be used.\n"
msgstr ""
#. TRANSLATORS: Elixir.Collectable Summary
#: lib/collectable.ex:2 
msgid ""
"A protocol to traverse data structures.\n"
"\n"
"The `Enum.into/2` function uses this protocol to insert an\n"
"enumerable into a collection:\n"
"\n"
"    iex> Enum.into([a: 1, b: 2], %{})\n"
"    %{a: 1, b: 2}\n"
"\n"
"## Why Collectable?\n"
"\n"
"The `Enumerable` protocol is useful to take values out of a collection.\n"
"In order to support a wide range of values, the functions provided by\n"
"the `Enumerable` protocol do not keep shape. For example, passing a\n"
"map to `Enum.map/2` always returns a list.\n"
"\n"
"This design is intentional. `Enumerable` was designed to support infinite\n"
"collections, resources and other structures with fixed shape. For example,\n"
"it doesn't make sense to insert values into a range, as it has a fixed\n"
"shape where just the range limits are stored.\n"
"\n"
"The `Collectable` module was designed to fill the gap left by the\n"
"`Enumerable` protocol. `into/1` can be seen as the opposite of\n"
"`Enumerable.reduce/3`. If `Enumerable` is about taking values out,\n"
"`Collectable.into/1` is about collecting those values into a structure.\n"
msgstr ""
