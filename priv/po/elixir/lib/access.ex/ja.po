msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2016-02-27 10:34+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: def Access.fetch(container, key)
#: lib/access.ex:128
msgid "Fetches the container's value for the given key.\n"
msgstr "与えられたキーに対するコンテナの値を取得します。\n"

#. TRANSLATORS: def Access.get_and_update(container, key, fun)
#: lib/access.ex:172
msgid ""
"Gets and updates the container's value for the given key, in a single pass.\n"
"\n"
"The argument function `fun` must receive the value for the given `key` (or\n"
"`nil` if the key doesn't exist in `container`). It must return a tuple\n"
"containing the `get` value and the new value to be stored in the "
"`container`.\n"
"\n"
"This function returns a two-element tuple.\n"
"The first element is the `get` value, as returned by `fun`.\n"
"The second element is the container, updated with the value returned by "
"`fun`.\n"
msgstr ""
"一度のパスで、与えられた`key`の値を取得し、コンテナを更新します。\n"
"\n"
"引数の関数`fun`は、与えられた`key`の値(または、もし`container`にキーが\n"
"存在しないなら、`nil`)を受け取らなければならず、関数は`get`した値と、\n"
"`container`に保存された新しい値を含むタプルを返さなくてはなりません。\n"
"\n"
"この関数は2要素のタプルを返します。\n"
"最初の要素は、`fun`から返された`get`した値です。\n"
"二つめの要素は、`fun`から返された値で更新されたコンテナです。\n"

#. TRANSLATORS: def Access.get(container, key, default \\ nil)
#: lib/access.ex:161
msgid "Gets the container's value for the given key.\n"
msgstr "与えられたキーに対するコンテナの値を取得します。\n"

#. TRANSLATORS: Elixir.Access Summary
#: lib/access.ex:2
msgid ""
"Key-based access to data structures via the `foo[bar]` bracket syntax.\n"
"\n"
"Elixir provides two syntaxes for accessing values. `user[:name]`\n"
"is used by dynamic structures, like maps and keywords, while\n"
"`user.name` is used by structs. The main difference is that\n"
"`user[:name]` won't raise if the key `:name` is missing but\n"
"`user.name` will raise if there is no `:name` key.\n"
"\n"
"Besides the cases above, this module provides convenience\n"
"functions for accessing other structures, like `at/1` for\n"
"lists and `elem/1` for tuples. Those functions can be used\n"
"by the nested update functions in `Kernel`, such as\n"
"`Kernel.get_in/2`, `Kernel.put_in/3`, `Kernel.update_in/3`,\n"
"`Kernel.get_and_update_in/3` and friends.\n"
"\n"
"## Key-based lookups\n"
"\n"
"Out of the box, Access works with `Keyword` and `Map`:\n"
"\n"
"    iex> keywords = [a: 1, b: 2]\n"
"    iex> keywords[:a]\n"
"    1\n"
"\n"
"    iex> map = %{a: 1, b: 2}\n"
"    iex> map[:a]\n"
"    1\n"
"\n"
"    iex> star_ratings = %{1.0 => \"★\", 1.5 => \"★☆\", 2.0 => \"★★\"}\n"
"    iex> star_ratings[1.5]\n"
"    \"★☆\"\n"
"\n"
"Access can be combined with `Kernel.put_in/3` to put a value\n"
"in a given key:\n"
"\n"
"    iex> map = %{a: 1, b: 2}\n"
"    iex> put_in map[:a], 3\n"
"    %{a: 3, b: 2}\n"
"\n"
"This syntax is very convenient as it can be nested arbitrarily:\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> put_in users[\"john\"][:age], 28\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"Furthermore, Access transparently ignores `nil` values:\n"
"\n"
"    iex> keywords = [a: 1, b: 2]\n"
"    iex> keywords[:c][:unknown]\n"
"    nil\n"
"\n"
"Since Access is a behaviour, it can be implemented to key-value\n"
"data structures. Access requires the key comparison to be\n"
"implemented using the `===` operator.\n"
"\n"
"## Field-based lookups\n"
"\n"
"The Access syntax (`foo[bar]`) cannot be used to access fields in\n"
"structs. That's by design, as Access is meant to be used for\n"
"dynamic key-value structures, like maps and keywords, and not\n"
"by static ones like structs.\n"
"\n"
"Therefore Elixir provides a field-based lookup for structs.\n"
"Imagine a struct named `User` with name and age fields. The\n"
"following would raise:\n"
"\n"
"    user = %User{name: \"john\"}\n"
"    user[:name]\n"
"    ** (UndefinedFunctionError) undefined function User.fetch/2\n"
"       (User does not implement the Access behaviour)\n"
"\n"
"Structs instead use the `user.name` syntax:\n"
"\n"
"    user.name\n"
"    #=> \"john\"\n"
"\n"
"The same `user.name` syntax can also be used by `Kernel.put_in/2`\n"
"to for updating structs fields:\n"
"\n"
"    put_in user.name, \"mary\"\n"
"    %User{name: \"mary\"}\n"
"\n"
"Differently from `user[:name]`, `user.name` is not extensible and\n"
"is restricted to only maps and structs.\n"
"\n"
"Summing up:\n"
"\n"
"  * `user[:name]` is used by dynamic structures, is extensible and\n"
"    does not raise on missing keys\n"
"  * `user.name` is used by static structures, it is not extensible\n"
"    and it will raise on missing keys\n"
"\n"
"## Accessors\n"
"\n"
"While Elixir provides built-in syntax only for traversing dynamic\n"
"and static key-value structures, this module provides convenience\n"
"functions for traversing other structures, like tuples and lists,\n"
"to be used alongside `Kernel.put_in/2` in others.\n"
"\n"
"**TODO: implement `field/1`, `key/1`, `at/1`, `elem/1`.**\n"
"\n"
msgstr ""
"`foo[bar]`シンタックスを介した辞書ライクなデータ構造へのアクセス\n"
"\n"
"Elixirは値へのアクセスの為に二つのシンタックスを提供します。\n"
"`user[:name]`はmapやkeywordのような動的な構造により使われ、\n"
"`user.name`はstructにより使われます。主な違いは`user[:name]`はキー\n"
"`:name`が無くても例外を上げないのに対して、`user.name`は`:name`キーが無\n"
"いと例外をあげる点です。\n"
"\n"
"上記のケースの他に、このモジュールは、listのための`at/1`やtupleのための\n"
"`elem/1`のような、他の構造へアクセスするための便利な関数を提供します。\n"
"それらの関数は`Kernel.get_in/2`, `Kernel.put_in/3`,\n"
"`Kernel.update_in/3`, `Kernel.get_and_update_in/3`その他`Kernel`のネス\n"
"トされた更新関数によっても使われます。\n"
"\n"
"## Key-based lookups\n"
"\n"
"Accessは`Keyword`と`Map`ではすぐに使えます:\n"
"\n"
"    iex> keywords = [a: 1, b: 2]\n"
"    iex> keywords[:a]\n"
"    1\n"
"\n"
"    iex> map = %{a: 1, b: 2}\n"
"    iex> map[:a]\n"
"    1\n"
"\n"
"    iex> star_ratings = %{1.0 => \"★\", 1.5 => \"★☆\", 2.0 => \"★★\"}\n"
"    iex> star_ratings[1.5]\n"
"    \"★☆\"\n"
"\n"
"Accessは与えられたキーの値をputするために`Kernel.put_in/3`と結合するこ\n"
"ともできます:\n"
"\n"
"    iex> map = %{a: 1, b: 2}\n"
"    iex> put_in map[:a], 3\n"
"    %{a: 3, b: 2}\n"
"\n"
"このシンタックスは任意にネスト出来るので非常に便利です:\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> put_in users[\"john\"][:age], 28\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"さらにまた、Accessは`nil`値を透過的に無視します:\n"
"\n"
"    iex> keywords = [a: 1, b: 2]\n"
"    iex> keywords[:c][:unknown]\n"
"    nil\n"
"\n"
"Accessはbehaviourなので、key-valueデータ構造のために実装することが\n"
"できます。Accessはキーの比較を`===`オペレータを使って実装されることを\n"
"要求します。\n"
"\n"
"## Field-based lookups\n"
"\n"
"Accessシンタックス(`foo[bar]`)はstructのフィールドのアクセスには使うこ\n"
"とができません。Accessはmapやkeywordのような、動的なkey-value構造のため\n"
"に使われることを意味し、structのような静的な構造のためではないという、\n"
"設計によるものです。\n"
"\n"
"しかしながら、Elixirは既にstructのためのフィールドベース参照を\n"
"提供しています。nameとageフィールドを持つ`User`というstructを\n"
"想像してください。以下のようにすると例外が上ります:\n"
"\n"
"    user = %User{name: \"john\"}\n"
"    user[:name]\n"
"    ** (UndefinedFunctionError) undefined function User.fetch/2\n"
"       (User does not implement the Access behaviour)\n"
"\n"
"structは`user.name`シンタックスを代りに使います:\n"
"\n"
"    user.name\n"
"    #=> \"john\"\n"
"\n"
"`user.name`シンタックスはstructのフィールドを更新するために、\n"
"`Kernel.put_in/2`により使われることも同じです:\n"
"\n"
"    put_in user.name, \"mary\"\n"
"    %User{name: \"mary\"}\n"
"\n"
"`user[:name]`に対する、`user.name`の相違点は、デベロッパによる拡張がで\n"
"きない点と、常にmapとstructだけに制限される点です。\n"
"\n"
"要約すると:\n"
"\n"
"  * `user[:name]` は動的構造に使い、拡張可能で、キーがなくても例外を上\n"
"    げません\n"
"  * `user.name` は静的構造に使い、拡張不可能で、キーがないと\n"
"    例外を上げます\n"
"\n"
"## Accessors\n"
"\n"
"Elixirが動的、静的なkey-value構造をトラバースするためだけにビルトインシ\n"
"ンタックスを提供する一方、このモジュールは`Kernel.put_in/2`その他と一緒\n"
"に使われる、tupleやlistといった他の構造のトラバースする便利な関数も提供し\n"
"ます。\n"
"\n"
"**TODO: implement `field/1`, `key/1`, `at/1`, `elem/1`.**\n"
"\n"
