#. TRANSLATORS: def Access.fetch(container, key)
#: lib/access.ex:42 
msgid ""
"Fetches the container's value for the given key.\n"
msgstr ""
#. TRANSLATORS: def Access.get_and_update(container, key, fun)
#: lib/access.ex:78 
msgid ""
"Gets and updates the container's value for the given key, in a single pass.\n"
"\n"
"The argument function `fun` must receive the value for the given `key` (or\n"
"`nil` if the key doesn't exist in `container`). It must return a tuple\n"
"containing the `get` value and the new value to be stored in the `container`.\n"
"\n"
"This function returns a two-element tuple.\n"
"The first element is the `get` value, as returned by `fun`.\n"
"The second element is the container, updated with the value returned by `fun`.\n"
msgstr ""
#. TRANSLATORS: def Access.get(container, key, default \\ nil)
#: lib/access.ex:67 
msgid ""
"Gets the container's value for the given key.\n"
msgstr ""
#. TRANSLATORS: Elixir.Access Summary
#: lib/access.ex:2 
msgid ""
"Dictionary-like access to data structures via the `foo[bar]` syntax.\n"
"\n"
"This module also empowers `Kernel`s nested update functions\n"
"`Kernel.get_in/2`, `Kernel.put_in/3`, `Kernel.update_in/3` and\n"
"`Kernel.get_and_update_in/3`.\n"
"\n"
"## Examples\n"
"\n"
"Out of the box, Access works with built-in dictionaries: `Keyword`\n"
"and `Map`:\n"
"\n"
"    iex> keywords = [a: 1, b: 2]\n"
"    iex> keywords[:a]\n"
"    1\n"
"\n"
"    iex> map = %{a: 1, b: 2}\n"
"    iex> map[:a]\n"
"    1\n"
"\n"
"    iex> star_ratings = %{1.0 => \"★\", 1.5 => \"★☆\", 2.0 => \"★★\"}\n"
"    iex> star_ratings[1.5]\n"
"    \"★☆\"\n"
"\n"
"Furthermore, Access transparently ignores `nil` values:\n"
"\n"
"    iex> keywords = [a: 1, b: 2]\n"
"    iex> keywords[:c][:unknown]\n"
"    nil\n"
"\n"
"The key comparison must be implemented using the `===` operator.\n"
msgstr ""
