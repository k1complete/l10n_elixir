#. TRANSLATORS: def Macro.decompose_call(ast)
#: lib/macro.ex:250 
msgid ""
"Decomposes a local or remote call into its remote part (when provided),\n"
"function name and argument list.\n"
"\n"
"Returns `:error` when an invalid call syntax is provided.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Macro.decompose_call(quote do: foo)\n"
"    {:foo, []}\n"
"\n"
"    iex> Macro.decompose_call(quote do: foo())\n"
"    {:foo, []}\n"
"\n"
"    iex> Macro.decompose_call(quote do: foo(1, 2, 3))\n"
"    {:foo, [1, 2, 3]}\n"
"\n"
"    iex> Macro.decompose_call(quote do: Elixir.M.foo(1, 2, 3))\n"
"    {{:__aliases__, [], [:Elixir, :M]}, :foo, [1, 2, 3]}\n"
"\n"
"    iex> Macro.decompose_call(quote do: 42)\n"
"    :error\n"
"\n"
msgstr ""
#. TRANSLATORS: def Macro.expand(tree, env)
#: lib/macro.ex:1034 
msgid ""
"Receives an AST node and expands it until it can no longer\n"
"be expanded.\n"
"\n"
"This function uses `expand_once/2` under the hood. Check\n"
"it out for more information and examples.\n"
msgstr ""
#. TRANSLATORS: def Macro.postwalk(ast, acc, fun)
#: lib/macro.ex:241 
msgid ""
"Performs a depth-first, post-order traversal of quoted expressions\n"
"using an accumulator.\n"
msgstr ""
#. TRANSLATORS: def Macro.prewalk(ast, acc, fun)
#: lib/macro.ex:224 
msgid ""
"Performs a depth-first, pre-order traversal of quoted expressions\n"
"using an accumulator.\n"
msgstr ""
#. TRANSLATORS: @type t
#: lib/macro.ex:21 
msgid ""
"Abstract Syntax Tree (AST)"
msgstr ""
#. TRANSLATORS: def Macro.traverse(ast, acc, pre, post)
#: lib/macro.ex:170 
msgid ""
"Performs a depth-first traversal of quoted expressions\n"
"using an accumulator.\n"
msgstr ""
#. TRANSLATORS: def Macro.underscore(atom)
#: lib/macro.ex:1053 
msgid ""
"Converts the given atom or binary to underscore format.\n"
"\n"
"If an atom is given, it is assumed to be an Elixir module,\n"
"so it is converted to a binary and then processed.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Macro.underscore \"FooBar\"\n"
"    \"foo_bar\"\n"
"\n"
"    iex> Macro.underscore \"Foo.Bar\"\n"
"    \"foo/bar\"\n"
"\n"
"    iex> Macro.underscore Foo.Bar\n"
"    \"foo/bar\"\n"
"\n"
"In general, `underscore` can be thought of as the reverse of\n"
"`camelize`, however, in some cases formatting may be lost:\n"
"\n"
"    iex> Macro.underscore \"SAPExample\"\n"
"    \"sap_example\"\n"
"\n"
"    iex> Macro.camelize \"sap_example\"\n"
"    \"SapExample\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Macro.to_string(tree, fun \\ fn _ast, string -> string end)
#: lib/macro.ex:450 
msgid ""
"Converts the given expression to a binary.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Macro.to_string(quote do: foo.bar(1, 2, 3))\n"
"    \"foo.bar(1, 2, 3)\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Macro.prewalk(ast, fun)
#: lib/macro.ex:216 
msgid ""
"Performs a depth-first, pre-order traversal of quoted expressions.\n"
msgstr ""
#. TRANSLATORS: Elixir.Macro Summary
#: lib/macro.ex:4 
msgid ""
"Conveniences for working with macros.\n"
"\n"
"## Custom Sigils\n"
"\n"
"To create a custom sigil, define a function with the name\n"
"`sigil_{identifier}` that takes two arguments. The first argument will be\n"
"the interpolated string, the second will be a char list containing any\n"
"modifiers.\n"
"\n"
"Valid modifiers include only lower and upper case letters. Other characters\n"
"will cause a syntax error.\n"
"\n"
"The module containing the custom sigil must be imported before the sigil\n"
"syntax can be used.\n"
msgstr ""
#. TRANSLATORS: def Macro.postwalk(ast, fun)
#: lib/macro.ex:233 
msgid ""
"Performs a depth-first, post-order traversal of quoted expressions.\n"
msgstr ""
#. TRANSLATORS: def Macro.expand_once(ast, env)
#: lib/macro.ex:847 
msgid ""
"Receives an AST node and expands it once.\n"
"\n"
"The following contents are expanded:\n"
"\n"
"  * Macros (local or remote)\n"
"  * Aliases are expanded (if possible) and return atoms\n"
"  * Pseudo-variables (`__ENV__`, `__MODULE__` and `__DIR__`)\n"
"  * Module attributes reader (`@foo`)\n"
"\n"
"If the expression cannot be expanded, it returns the expression\n"
"itself. Notice that `expand_once/2` performs the expansion just\n"
"once and it is not recursive. Check `expand/2` for expansion\n"
"until the node can no longer be expanded.\n"
"\n"
"## Examples\n"
"\n"
"In the example below, we have a macro that generates a module\n"
"with a function named `name_length` that returns the length\n"
"of the module name. The value of this function will be calculated\n"
"at compilation time and not at runtime.\n"
"\n"
"Consider the implementation below:\n"
"\n"
"    defmacro defmodule_with_length(name, do: block) do\n"
"      length = length(Atom.to_char_list(name))\n"
"\n"
"      quote do\n"
"        defmodule unquote(name) do\n"
"          def name_length, do: unquote(length)\n"
"          unquote(block)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"When invoked like this:\n"
"\n"
"    defmodule_with_length My.Module do\n"
"      def other_function, do: ...\n"
"    end\n"
"\n"
"The compilation will fail because `My.Module` when quoted\n"
"is not an atom, but a syntax tree as follow:\n"
"\n"
"    {:__aliases__, [], [:My, :Module]}\n"
"\n"
"That said, we need to expand the aliases node above to an\n"
"atom, so we can retrieve its length. Expanding the node is\n"
"not straight-forward because we also need to expand the\n"
"caller aliases. For example:\n"
"\n"
"    alias MyHelpers, as: My\n"
"\n"
"    defmodule_with_length My.Module do\n"
"      def other_function, do: ...\n"
"    end\n"
"\n"
"The final module name will be `MyHelpers.Module` and not\n"
"`My.Module`. With `Macro.expand/2`, such aliases are taken\n"
"into consideration. Local and remote macros are also\n"
"expanded. We could rewrite our macro above to use this\n"
"function as:\n"
"\n"
"    defmacro defmodule_with_length(name, do: block) do\n"
"      expanded = Macro.expand(name, __CALLER__)\n"
"      length   = length(Atom.to_char_list(expanded))\n"
"\n"
"      quote do\n"
"        defmodule unquote(name) do\n"
"          def name_length, do: unquote(length)\n"
"          unquote(block)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def Macro.unescape_string(chars, map)
#: lib/macro.ex:378 
msgid ""
"Unescapes the given chars according to the map given.\n"
"\n"
"Check `unescape_string/1` if you want to use the same map\n"
"as Elixir single- and double-quoted strings.\n"
"\n"
"## Map\n"
"\n"
"The map must be a function. The function receives an integer\n"
"representing the codepoint of the character it wants to unescape.\n"
"Here is the default mapping function implemented by Elixir:\n"
"\n"
"    def unescape_map(?0), do: ?0\n"
"    def unescape_map(?a), do: ?\\a\n"
"    def unescape_map(?b), do: ?\\b\n"
"    def unescape_map(?d), do: ?\\d\n"
"    def unescape_map(?e), do: ?\\e\n"
"    def unescape_map(?f), do: ?\\f\n"
"    def unescape_map(?n), do: ?\\n\n"
"    def unescape_map(?r), do: ?\\r\n"
"    def unescape_map(?s), do: ?\\s\n"
"    def unescape_map(?t), do: ?\\t\n"
"    def unescape_map(?v), do: ?\\v\n"
"    def unescape_map(?x), do: true\n"
"    def unescape_map(?u), do: true\n"
"    def unescape_map(e),  do: e\n"
"\n"
"If the `unescape_map` function returns `false`. The char is\n"
"not escaped and `\\` is kept in the char list.\n"
"\n"
"Hexadecimals and Unicode codepoints will be escaped if the map\n"
"function returns `true` for `?x`. Unicode codepoints if the map\n"
"function returns `true` for `?u`.\n"
"\n"
"## Examples\n"
"\n"
"Using the `unescape_map` function defined above is easy:\n"
"\n"
"    Macro.unescape_string \"example\\\\n\", &unescape_map(&1)\n"
"\n"
msgstr ""
#. TRANSLATORS: def Macro.camelize(string)
#: lib/macro.ex:1113 
msgid ""
"Converts the given string to CamelCase format.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Macro.camelize \"foo_bar\"\n"
"    \"FooBar\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Macro.unescape_tokens(tokens)
#: lib/macro.ex:424 
msgid ""
"Unescapes the given tokens according to the default map.\n"
"\n"
"Check `unescape_string/1` and `unescape_string/2` for more\n"
"information about unescaping.\n"
"\n"
"Only tokens that are binaries are unescaped, all others are\n"
"ignored. This function is useful when implementing your own\n"
"sigils. Check the implementation of `Kernel.sigil_s/2`\n"
"for examples.\n"
msgstr ""
#. TRANSLATORS: def Macro.pipe(expr, call_args, position)
#: lib/macro.ex:82 
msgid ""
"Pipes `expr` into the `call_args` at the given `position`.\n"
msgstr ""
#. TRANSLATORS: def Macro.unescape_tokens(tokens, map)
#: lib/macro.ex:440 
msgid ""
"Unescapes the given tokens according to the given map.\n"
"\n"
"Check `unescape_tokens/1` and `unescape_string/2` for more information.\n"
msgstr ""
#. TRANSLATORS: def Macro.var(var, context)
#: lib/macro.ex:145 
msgid ""
"Generates an AST node representing the variable given\n"
"by the atoms `var` and `context`.\n"
"\n"
"## Examples\n"
"\n"
"In order to build a variable, a context is expected.\n"
"Most of the times, in order to preserve hygiene, the\n"
"context must be `__MODULE__`:\n"
"\n"
"    iex> Macro.var(:foo, __MODULE__)\n"
"    {:foo, [], __MODULE__}\n"
"\n"
"However, if there is a need to access the user variable,\n"
"nil can be given:\n"
"\n"
"    iex> Macro.var(:foo, nil)\n"
"    {:foo, [], nil}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Macro.unescape_string(chars)
#: lib/macro.ex:349 
msgid ""
"Unescapes the given chars.\n"
"\n"
"This is the unescaping behaviour used by default in Elixir\n"
"single- and double-quoted strings. Check `unescape_string/2`\n"
"for information on how to customize the escaping map.\n"
"\n"
"In this setup, Elixir will escape the following: `\\0`, `\\a`, `\\b`,\n"
"`\\d`, `\\e`, `\\f`, `\\n`, `\\r`, `\\s`, `\\t` and `\\v`. Bytes can be\n"
"given as hexadecimals via `\\xNN` and Unicode Codepoints as\n"
"`\\uNNNN` escapes.\n"
"\n"
"This function is commonly used on sigil implementations\n"
"(like `~r`, `~s` and others) which receive a raw, unescaped\n"
"string.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Macro.unescape_string(\"example\\\\n\")\n"
"    \"example\\n\"\n"
"\n"
"In the example above, we pass a string with `\\n` escaped\n"
"and return a version with it unescaped.\n"
msgstr ""
#. TRANSLATORS: def Macro.update_meta(quoted, fun)
#: lib/macro.ex:119 
msgid ""
"Applies the given function to the node metadata if it contains one.\n"
"\n"
"This is often useful when used with `Macro.prewalk/2` to remove\n"
"information like lines and hygienic counters from the expression\n"
"for either storage or comparison.\n"
"\n"
"## Examples\n"
"\n"
"    iex> quoted = quote line: 10, do: sample()\n"
"    {:sample, [line: 10], []}\n"
"    iex> Macro.update_meta(quoted, &Keyword.delete(&1, :line))\n"
"    {:sample, [], []}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Macro.escape(expr, opts \\ [])
#: lib/macro.ex:289 
msgid ""
"Recursively escapes a value so it can be inserted\n"
"into a syntax tree.\n"
"\n"
"One may pass `unquote: true` to `escape/2`\n"
"which leaves `unquote` statements unescaped, effectively\n"
"unquoting the contents on escape.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Macro.escape(:foo)\n"
"    :foo\n"
"\n"
"    iex> Macro.escape({:a, :b, :c})\n"
"    {:{}, [], [:a, :b, :c]}\n"
"\n"
"    iex> Macro.escape({:unquote, [], [1]}, unquote: true)\n"
"    1\n"
"\n"
msgstr ""
#. TRANSLATORS: def Macro.unpipe(expr)
#: lib/macro.ex:64 
msgid ""
"Breaks a pipeline expression into a list.\n"
"\n"
"Raises if the pipeline is ill-formed.\n"
msgstr ""
#. TRANSLATORS: def Macro.validate(expr)
#: lib/macro.ex:315 
msgid ""
"Validates the given expressions are valid quoted expressions.\n"
"\n"
"Check the `type:Macro.t` for the specification of a valid\n"
"quoted expression.\n"
msgstr ""
