msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2015-12-17 23:24+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: def Macro.decompose_call(ast)
#: lib/macro.ex:250
msgid ""
"Decomposes a local or remote call into its remote part (when provided),\n"
"function name and argument list.\n"
"\n"
"Returns `:error` when an invalid call syntax is provided.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Macro.decompose_call(quote do: foo)\n"
"    {:foo, []}\n"
"\n"
"    iex> Macro.decompose_call(quote do: foo())\n"
"    {:foo, []}\n"
"\n"
"    iex> Macro.decompose_call(quote do: foo(1, 2, 3))\n"
"    {:foo, [1, 2, 3]}\n"
"\n"
"    iex> Macro.decompose_call(quote do: Elixir.M.foo(1, 2, 3))\n"
"    {{:__aliases__, [], [:Elixir, :M]}, :foo, [1, 2, 3]}\n"
"\n"
"    iex> Macro.decompose_call(quote do: 42)\n"
"    :error\n"
"\n"
msgstr ""
"ローカルかリモート呼び出しを、リモートパート(あれば)と関数名と\n"
"引数リストに分解します。\n"
"\n"
"無効な呼び出し構文の場合、`:error`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Macro.decompose_call(quote do: foo)\n"
"    {:foo, []}\n"
"\n"
"    iex> Macro.decompose_call(quote do: foo())\n"
"    {:foo, []}\n"
"\n"
"    iex> Macro.decompose_call(quote do: foo(1, 2, 3))\n"
"    {:foo, [1, 2, 3]}\n"
"\n"
"    iex> Macro.decompose_call(quote do: Elixir.M.foo(1, 2, 3))\n"
"    {{:__aliases__, [], [:Elixir, :M]}, :foo, [1, 2, 3]}\n"
"\n"
"    iex> Macro.decompose_call(quote do: 42)\n"
"    :error\n"
"\n"

#. TRANSLATORS: def Macro.expand(tree, env)
#: lib/macro.ex:1027
msgid ""
"Receives an AST node and expands it until it can no longer\n"
"be expanded.\n"
"\n"
"This function uses `expand_once/2` under the hood. Check\n"
"it out for more information and examples.\n"
msgstr ""
"ASTノードを受け取り、それをもはや展開できなくなるまで展開します。\n"
"\n"
"この関数は`expand_once/2`をフードの下で使います。\n"
"詳細と、例については、`expand_once/2`をチェックしてください。\n"

#. TRANSLATORS: def Macro.postwalk(ast, acc, fun)
#: lib/macro.ex:241
msgid ""
"Performs a depth-first, post-order traversal of quoted expressions\n"
"using an accumulator.\n"
msgstr ""
"quoteされた式をアキュムレータ付きで、深さ優先\n"
"帰り掛け順(DFS,post-order)探索を実行します。\n"

#. TRANSLATORS: def Macro.prewalk(ast, acc, fun)
#: lib/macro.ex:224
msgid ""
"Performs a depth-first, pre-order traversal of quoted expressions\n"
"using an accumulator.\n"
msgstr ""
"quoteされた式をアキュムレータ付きで、深さ優先\n"
"行き掛け順(DFS,pre-order)探索を実行します。\n"

#. TRANSLATORS: def Macro.to_string(tree, fun \\ fn _ast, string -> string end)
#: lib/macro.ex:447
msgid ""
"Converts the given expression to a binary.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Macro.to_string(quote do: foo.bar(1, 2, 3))\n"
"    \"foo.bar(1, 2, 3)\"\n"
"\n"
msgstr ""
"与えられた式をバイナリに変換します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Macro.to_string(quote do: foo.bar(1, 2, 3))\n"
"    \"foo.bar(1, 2, 3)\"\n"
"\n"

#. TRANSLATORS: def Macro.postwalk(ast, fun)
#: lib/macro.ex:233
msgid "Performs a depth-first, post-order traversal of quoted expressions.\n"
msgstr ""
"quoteされた式の、深さ優先帰り掛け順(DFS,post-order)探索を実行します。\n"

#. TRANSLATORS: @type t
#: lib/macro.ex:21
msgid "Abstract Syntax Tree (AST)"
msgstr "抽象構文木(AST)"

#. TRANSLATORS: def Macro.underscore(atom)
#: lib/macro.ex:1046
msgid ""
"Converts the given atom or binary to underscore format.\n"
"\n"
"If an atom is given, it is assumed to be an Elixir module,\n"
"so it is converted to a binary and then processed.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Macro.underscore \"FooBar\"\n"
"    \"foo_bar\"\n"
"\n"
"    iex> Macro.underscore \"Foo.Bar\"\n"
"    \"foo/bar\"\n"
"\n"
"    iex> Macro.underscore Foo.Bar\n"
"    \"foo/bar\"\n"
"\n"
"In general, `underscore` can be thought of as the reverse of\n"
"`camelize`, however, in some cases formatting may be lost:\n"
"\n"
"    iex> Macro.underscore \"SAPExample\"\n"
"    \"sap_example\"\n"
"\n"
"    iex> Macro.camelize \"sap_example\"\n"
"    \"SapExample\"\n"
"\n"
msgstr ""
"与えられたアトムあるいはバイナリをunderscoreフォーマットに\n"
"変換します。\n"
"\n"
"もしアトムが与えられたら、それはElixirモジュールと仮定され、\n"
"バイナリに変換され、それから処理されます。\n"
"If an atom is given, it is assumed to be an Elixir module,\n"
"so it is converted to a binary and then processed.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Macro.underscore \"FooBar\"\n"
"    \"foo_bar\"\n"
"\n"
"    iex> Macro.underscore \"Foo.Bar\"\n"
"    \"foo/bar\"\n"
"\n"
"    iex> Macro.underscore Foo.Bar\n"
"    \"foo/bar\"\n"
"\n"
"一般に、`undersocre`は`camelize`の逆のように考えることが\n"
"出来ますが、いくつかのケースではフォーマットが失われる\n"
"ことがあります:\n"
"\n"
"    iex> Macro.underscore \"SAPExample\"\n"
"    \"sap_example\"\n"
"\n"
"    iex> Macro.camelize \"sap_example\"\n"
"    \"SapExample\"\n"
"\n"

#. TRANSLATORS: def Macro.expand_once(ast, env)
#: lib/macro.ex:840
msgid ""
"Receives an AST node and expands it once.\n"
"\n"
"The following contents are expanded:\n"
"\n"
"  * Macros (local or remote)\n"
"  * Aliases are expanded (if possible) and return atoms\n"
"  * Pseudo-variables (`__ENV__`, `__MODULE__` and `__DIR__`)\n"
"  * Module attributes reader (`@foo`)\n"
"\n"
"If the expression cannot be expanded, it returns the expression\n"
"itself. Notice that `expand_once/2` performs the expansion just\n"
"once and it is not recursive. Check `expand/2` for expansion\n"
"until the node can no longer be expanded.\n"
"\n"
"## Examples\n"
"\n"
"In the example below, we have a macro that generates a module\n"
"with a function named `name_length` that returns the length\n"
"of the module name. The value of this function will be calculated\n"
"at compilation time and not at runtime.\n"
"\n"
"Consider the implementation below:\n"
"\n"
"    defmacro defmodule_with_length(name, do: block) do\n"
"      length = length(Atom.to_char_list(name))\n"
"\n"
"      quote do\n"
"        defmodule unquote(name) do\n"
"          def name_length, do: unquote(length)\n"
"          unquote(block)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"When invoked like this:\n"
"\n"
"    defmodule_with_length My.Module do\n"
"      def other_function, do: ...\n"
"    end\n"
"\n"
"The compilation will fail because `My.Module` when quoted\n"
"is not an atom, but a syntax tree as follow:\n"
"\n"
"    {:__aliases__, [], [:My, :Module]}\n"
"\n"
"That said, we need to expand the aliases node above to an\n"
"atom, so we can retrieve its length. Expanding the node is\n"
"not straight-forward because we also need to expand the\n"
"caller aliases. For example:\n"
"\n"
"    alias MyHelpers, as: My\n"
"\n"
"    defmodule_with_length My.Module do\n"
"      def other_function, do: ...\n"
"    end\n"
"\n"
"The final module name will be `MyHelpers.Module` and not\n"
"`My.Module`. With `Macro.expand/2`, such aliases are taken\n"
"into consideration. Local and remote macros are also\n"
"expanded. We could rewrite our macro above to use this\n"
"function as:\n"
"\n"
"    defmacro defmodule_with_length(name, do: block) do\n"
"      expanded = Macro.expand(name, __CALLER__)\n"
"      length   = length(Atom.to_char_list(expanded))\n"
"\n"
"      quote do\n"
"        defmodule unquote(name) do\n"
"          def name_length, do: unquote(length)\n"
"          unquote(block)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
msgstr ""
"ASTノードを受け取り、それを一度だけ展開します。\n"
"\n"
"以下のコンテンツが展開されます:\n"
"\n"
"  * マクロ (ローカルまたはリモート)\n"
"  * エリアスは展開され(可能なら)、アトムを返します。\n"
"  * 仮想変数(`__ENV__`, `__MODULE__` and `__DIR__`)\n"
"  * モジュールアトリビュート(`@foo`)\n"
"\n"
"もし式が展開できないなら、その式自身を返します。`expand_once/2`はちょう\n"
"ど一回だけ展開を実行し、再帰的ではないいことに注意してください。もはや\n"
"展開できなくなるまで展開するためには、`expand/2`をチェックしてください。\n"
"\n"
"## 例\n"
"\n"
"下の例で、モジュール名の長さを返す`name_length`という名前の関数とモジュー\n"
"ルを生成するマクロがあります。この関数の値はコンパイル時に計算され、実\n"
"行時ではありません。\n"
"\n"
"以下の実装を考えてみます:\n"
"\n"
"    defmacro defmodule_with_length(name, do: block) do\n"
"      length = length(Atom.to_char_list(name))\n"
"\n"
"      quote do\n"
"        defmodule unquote(name) do\n"
"          def name_length, do: unquote(length)\n"
"          unquote(block)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"実行するときは、このようにします:\n"
"\n"
"    defmodule_with_length My.Module do\n"
"      def other_function, do: ...\n"
"    end\n"
"\n"
"引用されたときの`My.Module`はアトムではないので、構文ツリーは\n"
"以下のようになり、コンパイルは失敗するでしょう:\n"
"\n"
"    {:__aliases__, [], [:My, :Module]}\n"
"\n"
"それは、別名ノードをアトムに展開する必要があるということです。そのあと\n"
"で、その長さを取り出すことができます。呼び出しの別名の展開が必要なので、\n"
"ノードの展開は簡単ではありません。例えば:\n"
"\n"
"    alias MyHelpers, as: My\n"
"\n"
"    defmodule_with_length My.Module do\n"
"      def other_function, do: ...\n"
"    end\n"
"\n"
"最後のモジュールは`MyHelpers.Module`と名付け、`My.Module`では\n"
"ありません。`Macro.expand/2`で、それらの別名は考慮されて\n"
"扱われます。ローカルとリモートのマクロもまた展開されます。\n"
"我々は、上記のマクロをこれらの機能を使って書き直すことができます:\n"
"\n"
"    defmacro defmodule_with_length(name, do: block) do\n"
"      expanded = Macro.expand(name, __CALLER__)\n"
"      length   = length(Atom.to_char_list(expanded))\n"
"\n"
"      quote do\n"
"        defmodule unquote(name) do\n"
"          def name_length, do: unquote(length)\n"
"          unquote(block)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"

#. TRANSLATORS: def Macro.prewalk(ast, fun)
#: lib/macro.ex:216
msgid "Performs a depth-first, pre-order traversal of quoted expressions.\n"
msgstr "quoteされた式の、深さ優先行き掛け順(DFS,pre-order)探索を実行します。\n"

#. TRANSLATORS: Elixir.Macro Summary
#: lib/macro.ex:4
msgid ""
"Conveniences for working with macros.\n"
"\n"
"## Custom Sigils\n"
"\n"
"To create a custom sigil, define a function with the name\n"
"`sigil_{identifier}` that takes two arguments. The first argument will be\n"
"the interpolated string, the second will be a char list containing any\n"
"modifiers.\n"
"\n"
"Valid modifiers include only lower and upper case letters. Other characters\n"
"will cause a syntax error.\n"
"\n"
"The module containing the custom sigil must be imported before the sigil\n"
"syntax can be used.\n"
msgstr ""
"マクロで働くための便利なものです。\n"
"\n"
"## Custom Sigils\n"
"\n"
"カスタムsigilを作るために、`sigil_{identifier}`という\n"
"名前の2引数の関数を定義してください。\n"
"最初の引数は展開される文字列で、二つめは文字の\n"
"リストで構成される任意のmodifier(修飾子)です。\n"
"\n"
"有効なmodifierは小文字と大文字だけです。他の文字は\n"
"シンタックスエラーとなります。\n"
"\n"
"カスタムsigilを含むモジュールは、そのsigilシンタックスが\n"
"使われる前にimportされなければなりません。\n"

#. TRANSLATORS: def Macro.unescape_string(chars, map)
#: lib/macro.ex:377
msgid ""
"Unescapes the given chars according to the map given.\n"
"\n"
"Check `unescape_string/1` if you want to use the same map\n"
"as Elixir single- and double-quoted strings.\n"
"\n"
"## Map\n"
"\n"
"The map must be a function. The function receives an integer\n"
"representing the codepoint of the character it wants to unescape.\n"
"Here is the default mapping function implemented by Elixir:\n"
"\n"
"    def unescape_map(?0), do: ?0\n"
"    def unescape_map(?a), do: ?\\a\n"
"    def unescape_map(?b), do: ?\\b\n"
"    def unescape_map(?d), do: ?\\d\n"
"    def unescape_map(?e), do: ?\\e\n"
"    def unescape_map(?f), do: ?\\f\n"
"    def unescape_map(?n), do: ?\\n\n"
"    def unescape_map(?r), do: ?\\r\n"
"    def unescape_map(?s), do: ?\\s\n"
"    def unescape_map(?t), do: ?\\t\n"
"    def unescape_map(?v), do: ?\\v\n"
"    def unescape_map(?x), do: true\n"
"    def unescape_map(e),  do: e\n"
"\n"
"If the `unescape_map` function returns `false`. The char is\n"
"not escaped and `\\` is kept in the char list.\n"
"\n"
"Hexadecimals will be escaped if the map function returns `true`\n"
"for `?x`.\n"
"\n"
"## Examples\n"
"\n"
"Using the `unescape_map` function defined above is easy:\n"
"\n"
"    Macro.unescape_string \"example\\\\n\", &unescape_map(&1)\n"
"\n"
msgstr ""
"与えられたトークンを与えられたマップに従ってアンエスケープします。\n"
"\n"
"Elixirの単一引用符と二重引用符の文字列として同じマップを\n"
"使いたい場合、`unescape_string/1`をチェックしてください。\n"
"\n"
"## マップ\n"
"\n"
"マップは関数でなければなりません。関数はアンエスケープしたい\n"
"文字のコードポイント表現した整数を受け取ります。\n"
"Elixirで実装されたデフォルトマッピング関数は以下のとおりです:\n"
"\n"
"    def unescape_map(?0), do: ?0\n"
"    def unescape_map(?a), do: ?\\a\n"
"    def unescape_map(?b), do: ?\\b\n"
"    def unescape_map(?d), do: ?\\d\n"
"    def unescape_map(?e), do: ?\\e\n"
"    def unescape_map(?f), do: ?\\f\n"
"    def unescape_map(?n), do: ?\\n\n"
"    def unescape_map(?r), do: ?\\r\n"
"    def unescape_map(?s), do: ?\\s\n"
"    def unescape_map(?t), do: ?\\t\n"
"    def unescape_map(?v), do: ?\\v\n"
"    def unescape_map(?x), do: true\n"
"    def unescape_map(e),  do: e\n"
"\n"
"もし`unescape_map`関数が`false`を返したら、その文字はエスケープされず、\n"
"`\\`は文字リストに保持されます。\n"
"\n"
"16進数はマップ関数が`?x`に対して`true`を返したらエスケープされるでしょ\n"
"う。\n"
"\n"
"## 例\n"
"\n"
"上で定義された`unescape_map`関数を使用することは簡単です:\n"
"\n"
"    Macro.unescape_string \"example\\\\n\", &unescape_map(&1)\n"
"\n"

#. TRANSLATORS: def Macro.camelize(string)
#: lib/macro.ex:1106
msgid ""
"Converts the given string to CamelCase format.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Macro.camelize \"foo_bar\"\n"
"    \"FooBar\"\n"
"\n"
msgstr ""
"与えられた文字列をCamelCaseフォーマットに変換します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Macro.camelize \"foo_bar\"\n"
"    \"FooBar\"\n"
"\n"

#. TRANSLATORS: def Macro.traverse(ast, acc, pre, post)
#: lib/macro.ex:170
msgid ""
"Performs a depth-first, traversal of quoted expressions\n"
"using an accumulator.\n"
msgstr ""
"quoteされた式をアキュムレータ付きで、深さ優先\n"
"(DFS)探索を実行します。\n"

#. TRANSLATORS: def Macro.unescape_tokens(tokens)
#: lib/macro.ex:421
msgid ""
"Unescapes the given tokens according to the default map.\n"
"\n"
"Check `unescape_string/1` and `unescape_string/2` for more\n"
"information about unescaping.\n"
"\n"
"Only tokens that are binaries are unescaped, all others are\n"
"ignored. This function is useful when implementing your own\n"
"sigils. Check the implementation of `Kernel.sigil_s/2`\n"
"for examples.\n"
msgstr ""
"与えられたトークンをデフォルトマップに従ってアンエスケープします。\n"
"\n"
"アンエスケープについての更なる情報は、`unescape_tokens/1`と\n"
"`unescape_string/2`をチェックしてください。\n"
"\n"
"バイナリのトークンだけがアンエスケープされます、他の全ては\n"
"無視されます。この関数は自分でsigilを実装するときに便利です。\n"
"例については`Kernel.sigil_s/2`の実装をチェックしてください。\n"

#. TRANSLATORS: def Macro.unescape_string(chars)
#: lib/macro.ex:349
msgid ""
"Unescapes the given chars.\n"
"\n"
"This is the unescaping behaviour used by default in Elixir\n"
"single- and double-quoted strings. Check `unescape_string/2`\n"
"for information on how to customize the escaping map.\n"
"\n"
"In this setup, Elixir will escape the following: `\\0`, `\\a`, `\\b`,\n"
"`\\d`, `\\e`, `\\f`, `\\n`, `\\r`, `\\s`, `\\t` and `\\v`. Unicode "
"codepoints\n"
"can be given as hexadecimals via `\\xNN` and `\\x{NN...}` escapes.\n"
"\n"
"This function is commonly used on sigil implementations\n"
"(like `~r`, `~s` and others) which receive a raw, unescaped\n"
"string.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Macro.unescape_string(\"example\\\\n\")\n"
"    \"example\\n\"\n"
"\n"
"In the example above, we pass a string with `\\n` escaped\n"
"and return a version with it unescaped.\n"
msgstr ""
"与えられた文字をアンエスケープします。\n"
"\n"
"このアンエスケープは、Elixirの単一引用符と二重引用符の文字列で使われる\n"
"デフォルトの振舞いです。エスケープマップをカスタマイズする方法について\n"
"の情報は`unescape_string/2`をチェックしてください。\n"
"\n"
"このセットアップでは、Elixirは以下のとおりエスケープします: `\\0`,\n"
"`\\a`, `\\b`, `\\d`, `\\e`, `\\f`, `\\n`, `\\r`, `\\s`, `\\t` そして `"
"\\v`。\n"
"`\\xNN`や`\\x{NN...}`といった16進数構文もサポートされます。\n"
"\n"
"この関数は生の文字列を受信する(`~r`, `~s`やその他のような)sigilの実装で\n"
"共通的に使われ、文字列をアンエスケープします。\n"
"\n"
"## 例\n"
"\n"
"    iex> Macro.unescape_string(\"example\\n\")\n"
"    \"example\\n\"\n"
"\n"
"上の例では、エスケープされた`\\n`付きの文字列をパスして\n"
"アンエスケープされたバージョンを返しています。\n"

#. TRANSLATORS: def Macro.escape(expr, opts \\ [])
#: lib/macro.ex:289
msgid ""
"Recursively escapes a value so it can be inserted\n"
"into a syntax tree.\n"
"\n"
"One may pass `unquote: true` to `escape/2`\n"
"which leaves `unquote` statements unescaped, effectively\n"
"unquoting the contents on escape.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Macro.escape(:foo)\n"
"    :foo\n"
"\n"
"    iex> Macro.escape({:a, :b, :c})\n"
"    {:{}, [], [:a, :b, :c]}\n"
"\n"
"    iex> Macro.escape({:unquote, [], [1]}, unquote: true)\n"
"    1\n"
"\n"
msgstr ""
"再帰的に、それが構文ツリーに挿入されることが出来るように値をエスケープしま"
"す。\n"
"\n"
"アンエスケープされた文を`unquote`で残し、エスケープの中で、効果的にコン\n"
"テンツをアンクォートするために、`unquote: true`を`escape/2`に送るかもし\n"
"れません。\n"
"\n"
"## 例\n"
"\n"
"    iex> Macro.escape(:foo)\n"
"    :foo\n"
"\n"
"    iex> Macro.escape({:a, :b, :c})\n"
"    {:{}, [], [:a, :b, :c]}\n"
"\n"
"    iex> Macro.escape({:unquote, [], [1]}, unquote: true)\n"
"    1\n"
"\n"

#. TRANSLATORS: def Macro.unescape_tokens(tokens, map)
#: lib/macro.ex:437
msgid ""
"Unescapes the given tokens according to the given map.\n"
"\n"
"Check `unescape_tokens/1` and `unescape_string/2` for more information.\n"
msgstr ""
"与えられたトークンを与えられたマップに従ってアンエスケープします。\n"
"\n"
"更なる情報は、`unescape_tokens/1`と`unescape_string/2`をチェックしてく\n"
"ださい。\n"

#. TRANSLATORS: def Macro.pipe(expr, call_args, position)
#: lib/macro.ex:82
msgid "Pipes `expr` into the `call_args` at the given `position`.\n"
msgstr "与えられた`position`の`call_args`へ`expr`をパイプします。\n"

#. TRANSLATORS: def Macro.var(var, context)
#: lib/macro.ex:145
msgid ""
"Generates an AST node representing the variable given\n"
"by the atoms `var` and `context`.\n"
"\n"
"## Examples\n"
"\n"
"In order to build a variable, a context is expected.\n"
"Most of the times, in order to preserve hygiene, the\n"
"context must be `__MODULE__`:\n"
"\n"
"    iex> Macro.var(:foo, __MODULE__)\n"
"    {:foo, [], __MODULE__}\n"
"\n"
"However, if there is a need to access the user variable,\n"
"nil can be given:\n"
"\n"
"    iex> Macro.var(:foo, nil)\n"
"    {:foo, [], nil}\n"
"\n"
msgstr ""
"アトム`var`と`context`によって与えられた、変数のASTノード表現を\n"
"生成します。\n"
"\n"
"## 例\n"
"\n"
"変数を作るために、contextを使います。\n"
"ほとんどの場合、健全性を保存するために、\n"
"contextは、`__MODULE__`でなくてはなりません:\n"
"\n"
"    iex> Macro.var(:foo, __MODULE__)\n"
"    {:foo, [], __MODULE__}\n"
"\n"
"しかしながら、ユーザ変数にアクセスする必要があるならば、\n"
"nilを与えることができます:\n"
"\n"
"    iex> Macro.var(:foo, nil)\n"
"    {:foo, [], nil}\n"
"\n"

#. TRANSLATORS: def Macro.update_meta(quoted, fun)
#: lib/macro.ex:119
msgid ""
"Applies the given function to the node metadata if it contains one.\n"
"\n"
"This is often useful when used with `Macro.prewalk/2` to remove\n"
"information like lines and hygienic counters from the expression\n"
"for either storage or comparison.\n"
"\n"
"## Examples\n"
"\n"
"    iex> quoted = quote line: 10, do: sample()\n"
"    {:sample, [line: 10], []}\n"
"    iex> Macro.update_meta(quoted, &Keyword.delete(&1, :line))\n"
"    {:sample, [], []}\n"
"\n"
msgstr ""
"メタデータを含んでいたら、ノードに与えられた関数を\n"
"適用します。\n"
"\n"
"これは、保管または比較の目的で、式から行番号と健全性\n"
"カウンタの様な情報を削除するために、\n"
"`Macro.prewalk/2`を使うときに便利です。\n"
"\n"
"## 例\n"
"\n"
"    iex> quoted = quote line: 10, do: sample()\n"
"    {:sample, [line: 10], []}\n"
"    iex> Macro.update_meta(quoted, &Keyword.delete(&1, :line))\n"
"    {:sample, [], []}\n"
"\n"

#. TRANSLATORS: def Macro.unpipe(expr)
#: lib/macro.ex:64
msgid ""
"Breaks a pipeline expression into a list.\n"
"\n"
"Raises if the pipeline is ill-formed.\n"
msgstr ""
"パイプライン式をリストにします。\n"
"\n"
"パイプラインが不適格なら、エラーを上げます。\n"

#. TRANSLATORS: def Macro.validate(expr)
#: lib/macro.ex:315
msgid ""
"Validates the given expressions are valid quoted expressions.\n"
"\n"
"Check the `type:Macro.t` for the specification of a valid\n"
"quoted expression.\n"
msgstr ""
"与えられた式がquoteされた式として正しいか検証します。\n"
"\n"
"正しいquoteされた式の仕様については`type:Macro.t`をチェック\n"
"してください。\n"

#~ msgid "Expr node (remaining ones are literals)"
#~ msgstr "Exprノード(残りの物はリテラルです)"

#~ msgid "Conveniences for working with macros.\n"
#~ msgstr "マクロで働くための便利なものです。\n"
