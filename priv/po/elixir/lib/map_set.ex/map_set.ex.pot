#. TRANSLATORS: def MapSet.put(set, value)
#: lib/map_set.ex:178 
msgid ""
"Inserts `value` into `set` if `set` doesn't already contain it.\n"
"\n"
"## Examples\n"
"\n"
"    iex> MapSet.put(MapSet.new([1, 2, 3]), 3)\n"
"    #MapSet<[1, 2, 3]>\n"
"    iex> MapSet.put(MapSet.new([1, 2, 3]), 4)\n"
"    #MapSet<[1, 2, 3, 4]>\n"
"\n"
msgstr ""
#. TRANSLATORS: def MapSet.equal?(map_set1, map_set2)
#: lib/map_set.ex:119 
msgid ""
"Checks if two sets are equal.\n"
"\n"
"The comparison between elements must be done using `===`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> MapSet.equal?(MapSet.new([1, 2]), MapSet.new([2, 1, 1]))\n"
"    true\n"
"    iex> MapSet.equal?(MapSet.new([1, 2]), MapSet.new([3, 4]))\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def MapSet.member?(map_set, value)
#: lib/map_set.ex:162 
msgid ""
"Checks if `set` contains `value`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> MapSet.member?(MapSet.new([1, 2, 3]), 2)\n"
"    true\n"
"    iex> MapSet.member?(MapSet.new([1, 2, 3]), 4)\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def MapSet.new(enumerable)
#: lib/map_set.ex:28 
msgid ""
"Creates a set from an enumerable.\n"
"\n"
"## Examples\n"
"\n"
"    iex> MapSet.new([:b, :a, 3])\n"
"    #MapSet<[3, :a, :b]>\n"
"    iex> MapSet.new([3, 3, 3, 2, 2, 1])\n"
"    #MapSet<[1, 2, 3]>\n"
"\n"
msgstr ""
#. TRANSLATORS: def MapSet.intersection(map_set1, map_set2)
#: lib/map_set.ex:137 
msgid ""
"Returns a set containing only members that `set1` and `set2` have in common.\n"
"\n"
"## Examples\n"
"\n"
"    iex> MapSet.intersection(MapSet.new([1, 2]), MapSet.new([2, 3, 4]))\n"
"    #MapSet<[2]>\n"
"\n"
"    iex> MapSet.intersection(MapSet.new([1, 2]), MapSet.new([3, 4]))\n"
"    #MapSet<[]>\n"
"\n"
msgstr ""
#. TRANSLATORS: def MapSet.disjoint?(map_set1, map_set2)
#: lib/map_set.ex:94 
msgid ""
"Checks if `set1` and `set2` have no members in common.\n"
"\n"
"## Examples\n"
"\n"
"    iex> MapSet.disjoint?(MapSet.new([1, 2]), MapSet.new([3, 4]))\n"
"    true\n"
"    iex> MapSet.disjoint?(MapSet.new([1, 2]), MapSet.new([2, 3]))\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def MapSet.subset?(map_set1, map_set2)
#: lib/map_set.ex:208 
msgid ""
"Checks if `set1`'s members are all contained in `set2`.\n"
"\n"
"This function checks if `set1` is a subset of `set2`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> MapSet.subset?(MapSet.new([1, 2]), MapSet.new([1, 2, 3]))\n"
"    true\n"
"    iex> MapSet.subset?(MapSet.new([1, 2, 3]), MapSet.new([1, 2]))\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def MapSet.size(map_set)
#: lib/map_set.ex:194 
msgid ""
"Returns the number of elements in `set`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> MapSet.size(MapSet.new([1, 2, 3]))\n"
"    3\n"
"\n"
msgstr ""
#. TRANSLATORS: def MapSet.union(map_set1, map_set2)
#: lib/map_set.ex:252 
msgid ""
"Returns a set containing all members of `set1` and `set2`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> MapSet.union(MapSet.new([1, 2]), MapSet.new([2, 3, 4]))\n"
"    #MapSet<[1, 2, 3, 4]>\n"
"\n"
msgstr ""
#. TRANSLATORS: def MapSet.difference(map_set1, map_set2)
#: lib/map_set.ex:77 
msgid ""
"Returns a set that is `set1` without the members of `set2`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> MapSet.difference(MapSet.new([1, 2]), MapSet.new([2, 3, 4]))\n"
"    #MapSet<[1]>\n"
"\n"
msgstr ""
#. TRANSLATORS: def MapSet.new(enumerable, transform)
#: lib/map_set.ex:44 
msgid ""
"Creates a mapset from an enumerable via the transformation function.\n"
"\n"
"## Examples\n"
"\n"
"    iex> MapSet.new([1, 2, 1], fn x -> 2 * x end)\n"
"    #MapSet<[2, 4]>\n"
"\n"
msgstr ""
#. TRANSLATORS: def MapSet.delete(set, term)
#: lib/map_set.ex:58 
msgid ""
"Deletes `value` from `set`.\n"
"\n"
"Returns a new set which is a copy of `set` but without `value`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> set = MapSet.new([1, 2, 3])\n"
"    iex> MapSet.delete(set, 4)\n"
"    #MapSet<[1, 2, 3]>\n"
"    iex> MapSet.delete(set, 2)\n"
"    #MapSet<[1, 3]>\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.MapSet Summary
#: lib/map_set.ex:2 
msgid ""
"A set of functions for working with sets.\n"
"\n"
"The `MapSet` is represented internally as a struct,\n"
"therefore `%MapSet{}` can be used whenever there is a\n"
"need to match on any `MapSet`. Note though the struct\n"
"fields are private and must not be accessed directly.\n"
"Instead, use the functions in this module.\n"
msgstr ""
#. TRANSLATORS: def MapSet.to_list(map_set)
#: lib/map_set.ex:238 
msgid ""
"Converts `set` to a list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> MapSet.to_list(MapSet.new([1, 2, 3]))\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def MapSet.new()
#: lib/map_set.ex:16 
msgid ""
"Returns a new set.\n"
"\n"
"## Examples\n"
"\n"
"    iex> MapSet.new\n"
"    #MapSet<[]>\n"
"\n"
msgstr ""
