msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2016-02-21 08:41+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: def Regex.replace(regex, string, replacement, options \\ [])
#: lib/regex.ex:453
msgid ""
"Receives a regex, a binary and a replacement, returns a new\n"
"binary where all matches are replaced by the replacement.\n"
"\n"
"The replacement can be either a string or a function. The string\n"
"is used as a replacement for every match and it allows specific\n"
"captures to be accessed via `\\\\N` or `\\g{N}`, where `N` is the\n"
"capture. In case `\\\\0` is used, the whole match is inserted.\n"
"\n"
"When the replacement is a function, the function may have arity\n"
"N where each argument maps to a capture, with the first argument\n"
"being the whole match. If the function expects more arguments\n"
"than captures found, the remaining arguments will receive `\"\"`.\n"
"\n"
"## Options\n"
"\n"
"  * `:global` - when `false`, replaces only the first occurrence\n"
"    (defaults to `true`)\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.replace(~r/d/, \"abc\", \"d\")\n"
"    \"abc\"\n"
"\n"
"    iex> Regex.replace(~r/b/, \"abc\", \"d\")\n"
"    \"adc\"\n"
"\n"
"    iex> Regex.replace(~r/b/, \"abc\", \"[\\\\0]\")\n"
"    \"a[b]c\"\n"
"\n"
"    iex> Regex.replace(~r/a(b|d)c/, \"abcadc\", \"[\\\\1]\")\n"
"    \"[b][d]\"\n"
"\n"
"    iex> Regex.replace(~r/\\.(\\d)$/, \"500.5\", \".\\\\g{1}0\")\n"
"    \"500.50\"\n"
"\n"
"    iex> Regex.replace(~r/a(b|d)c/, \"abcadc\", fn _, x -> \"[#{x}]\" end)\n"
"    \"[b][d]\"\n"
"\n"
"    iex> Regex.replace(~r/a/, \"abcadc\", \"A\", global: false)\n"
"    \"Abcadc\"\n"
"\n"
msgstr ""
"正規表現、バイナリとreplacementを受け取り、全てのマッチがreplacementで\n"
"置き換えられた、新しいバイナリを返します。\n"
"\n"
"replacementは、文字列でも関数でも可能です。あらゆるマッチの為の\n"
"replacementとして文字列を使われます。そして、それは`N`はキャプチャした\n"
"文字列とすると、`\\N`または`\\g{N}`によってアクセスできる特定のキャプチャを\n"
"許します。`\\0`が使われた場合、マッチ全体が挿入されます。\n"
"\n"
"replacementが関数のとき、関数は、最初の引数はマッチ全体である、それぞれ\n"
"の引数がキャプチャにマップされるアリティNを持つかもしれません。もし関数\n"
"がキャプチャされるより多くの引数を予想していたら、残りの引数は`\"\"`とな\n"
"ります。\n"
"\n"
"## オプション\n"
"\n"
"  * `:global` - `false`の時、最初のだけ置き換えます\n"
"    (デフォルトは`true`です)\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.replace(~r/d/, \"abc\", \"d\")\n"
"    \"abc\"\n"
"\n"
"    iex> Regex.replace(~r/b/, \"abc\", \"d\")\n"
"    \"adc\"\n"
"\n"
"    iex> Regex.replace(~r/b/, \"abc\", \"[\\\\0]\")\n"
"    \"a[b]c\"\n"
"\n"
"    iex> Regex.replace(~r/a(b|d)c/, \"abcadc\", \"[\\\\1]\")\n"
"    \"[b][d]\"\n"
"\n"
"    iex> Regex.replace(~r/\\.(\\d)$/, \"500.5\", \".\\\\g{1}0\")\n"
"    \"500.50\"\n"
"\n"
"    iex> Regex.replace(~r/a(b|d)c/, \"abcadc\", fn _, x -> \"[#{x}]\" end)\n"
"    \"[b][d]\"\n"
"\n"
"    iex> Regex.replace(~r/a/, \"abcadc\", \"A\", global: false)\n"
"    \"Abcadc\"\n"
"\n"

#. TRANSLATORS: Elixir.Regex Summary
#: lib/regex.ex:2
msgid ""
"Provides regular expressions for Elixir. Built on top of Erlang's `:re`\n"
"module.\n"
"\n"
"As the `:re` module, Regex is based on PCRE\n"
"(Perl Compatible Regular Expressions). More information can be\n"
"found in the [`:re` module documentation](http://www.erlang.org/doc/man/re."
"html).\n"
"\n"
"Regular expressions in Elixir can be created using `Regex.compile!/2`\n"
"or using the special form with [`~r`](Kernel.html#sigil_r/2) or [`~R`]"
"(Kernel.html#sigil_R/2):\n"
"\n"
"    # A simple regular expressions that matches foo anywhere in the string\n"
"    ~r/foo/\n"
"\n"
"    # A regular expression with case insensitive and unicode options\n"
"    ~r/foo/iu\n"
"\n"
"A Regex is represented internally as the `Regex` struct. Therefore,\n"
"`%Regex{}` can be used whenever there is a need to match on them.\n"
"\n"
"## Modifiers\n"
"\n"
"The modifiers available when creating a Regex are:\n"
"\n"
"  * `unicode` (u) - enables unicode specific patterns like `\\p` and change\n"
"    modifiers like `\\w`, `\\W`, `\\s` and friends to also match on "
"unicode.\n"
"    It expects valid unicode strings to be given on match\n"
"\n"
"  * `caseless` (i) - add case insensitivity\n"
"\n"
"  * `dotall` (s) - causes dot to match newlines and also set newline to\n"
"    anycrlf; the new line setting can be overridden by setting `(*CR)` or\n"
"    `(*LF)` or `(*CRLF)` or `(*ANY)` according to re documentation\n"
"\n"
"  * `multiline` (m) - causes `^` and `$` to mark the beginning and end of\n"
"    each line; use `\\A` and `\\z` to match the end or beginning of the "
"string\n"
"\n"
"  * `extended` (x) - whitespace characters are ignored except when escaped\n"
"    and allow `#` to delimit comments\n"
"\n"
"  * `firstline` (f) - forces the unanchored pattern to match before or at "
"the\n"
"    first newline, though the matched text may continue over the newline\n"
"\n"
"  * `ungreedy` (U) - inverts the \"greediness\" of the regexp\n"
"    (the previous `r` option is deprecated in favor of `U`)\n"
"\n"
"The options not available are:\n"
"\n"
"  * `anchored` - not available, use `^` or `\\A` instead\n"
"  * `dollar_endonly` - not available, use `\\z` instead\n"
"  * `no_auto_capture` - not available, use `?:` instead\n"
"  * `newline` - not available, use `(*CR)` or `(*LF)` or `(*CRLF)` or\n"
"    `(*ANYCRLF)` or `(*ANY)` at the beginning of the regexp according to "
"the\n"
"    re documentation\n"
"\n"
"## Captures\n"
"\n"
"Many functions in this module handle what to capture in a regex\n"
"match via the `:capture` option. The supported values are:\n"
"\n"
"  * `:all` - all captured subpatterns including the complete matching "
"string\n"
"    (this is the default)\n"
"\n"
"  * `:first` - only the first captured subpattern, which is always the\n"
"    complete matching part of the string; all explicitly captured "
"subpatterns\n"
"    are discarded\n"
"\n"
"  * `:all_but_first`- all but the first matching subpattern, i.e. all\n"
"    explicitly captured subpatterns, but not the complete matching part of\n"
"    the string\n"
"\n"
"  * `:none` - do not return matching subpatterns at all\n"
"\n"
"  * `:all_names` - captures all names in the Regex\n"
"\n"
"  * `list(binary)` - a list of named captures to capture\n"
"\n"
msgstr ""
"Erlangの`:re`モジュールの上に作られたElixirの正規表現です。\n"
"\n"
"`re`モジュールとして、RegexはPCRE(Perl Compatible Regular Expressions)\n"
"に基いています。詳細は、[`:re` documentation](http://www.erlang.org/doc/man/"
"re.html)に見付かります。\n"
"\n"
"Elixirの正規表現は`Regex.compile!/2`またはスペシャルフォーム\n"
"[`~r`](Kernel.html#sigil_r/2) または、\n"
"[`~R`](Kernel.html#sigil_R/2) を使って作成することができます:\n"
"\n"
"    # 文字列中のどこでもfooにマッチするシンプルな正規表現\n"
"    ~r/foo/\n"
"\n"
"    # 大文字小文字を無視、unicodeの二つのオプションのついた正規表現\n"
"    ~r/foo/iu\n"
"\n"
"Regexは`Regex`構造体として内部では表現されます。従って、\n"
"それらにマッチする必要があるときは何時でも`%Regex{}`は使われます。\n"
"\n"
"## モディファイア\n"
"\n"
"Regexを作るときに有効なモディファイアは以下の通りです:\n"
"\n"
"  * `unicode` (u) - `\\p`のようなunicode特有のパターンを有効にし、\n"
"    `\\w`、`\\W`、`\\s`などの様なモディファイアをunicodeにも\n"
"     マッチするように変更します。与えられたマッチは有効なunicode\n"
"     文字列を予想します\n"
"\n"
"  * `caseless` (i) - 大文字小文字を無視します\n"
"\n"
"  * `dotall` (s) - ドット(.)を改行にマッチさせ、改行を(*ANYCRLF)に\n"
"    にセットします; 改行設定は`(*CR)`、`(*LF)`、`(*CRLF)`、`(*ANY)`を\n"
"    設定することで上書きできます。それらに関しては re のドキュメントを\n"
"    参照してください\n"
"\n"
"  * `multiline` (m) - `^`と`$`それぞれの行の先頭と末尾にマークします;\n"
"    文字列の先頭と末尾にマッチするためには`\\A`と`\\Z`を使ってください\n"
"\n"
"  * `extended` (x) - エスケープされたものを除き、空白文字は無視されます。\n"
"    そして、`#`でコメントを区切るのを許します。\n"
"\n"
"  * `firstline` (f) - マッチしたテキストが改行を越えて続くかも\n"
"    しれないが、先頭固定ではないパターンでも、最初の改行あるいは\n"
"    その前でマッチすることを強制します。\n"
"\n"
"  * `ungreedy` (U) - 正規表現の\"欲張り\"を反転します。\n"
"    (以前の`r`オプションはdeprecatedで、`U`を使ってください)\n"
"\n"
"有効ではないオプションは以下の通りです:\n"
"\n"
"  * `anchored` - 無効です。 かわりに'^'か`\\A`を使います\n"
"  * `dollar_endonly` - 無効です。かわりに`\\z`を使います。\n"
"  * `no_auto_capture` - 無効です。かわりに`?:`を使います。\n"
"  * `newline` - 無効です。かわりに`(*CR)`、 `(*LF)` 、`(*CRLF)` 、\n"
"    `(*ANYCRLF)` 、`(*ANY)` を正規表現の前に設定します。\n"
"    詳しくは re のドキュメントを参照してください\n"
"\n"
"## キャプチャ(捕捉)\n"
"\n"
"このモジュールの多くの関数は、正規表現マッチで`:capture`オプションにより\n"
"キャプチャすることを許します。サポートされている値は以下の通りです:\n"
"\n"
"  * `:all` - 完全にマッチした文字列を含むサブパターンを全てキャプチャします\n"
"    (これはデフォルトです)\n"
"\n"
"  * `:first` - 常に文字列の部分が完全にマッチした最初のサブパターンだけ\n"
"    キャプチャします; 全ての明確にキャプチャされたサブパターンは\n"
"    放棄されます\n"
"\n"
"  * `:all_but_first`- 最初のサブパターン以外、すなわち全ての明確に\n"
"    キャプチャされたサブパターンで、文字列の完全なマッチしている部分\n"
"    ではないものです\n"
"\n"
"  * `:none` - 全てのサブパターン返しません\n"
"\n"
"  * `:all_names` - Regexの全ての名前をキャプチャします\n"
"\n"
"  * `list(binary)` - キャプチャに名前付されたキャプチャリストを使います\n"
"\n"

#. TRANSLATORS: def Regex.escape(string)
#: lib/regex.ex:630
msgid ""
"Escapes a string to be literally matched in a regex.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.escape(\".\")\n"
"    \"\\\\.\"\n"
"\n"
"    iex> Regex.escape(\"\\\\what if\")\n"
"    \"\\\\\\\\what\\\\ if\"\n"
"\n"
msgstr ""
"正規表現に文字通りにマッチした文字列をエスケープします。\n"
"\n"
"## 例\n"
"\n"
"    iex> Regex.escape(\".\")\n"
"    \"\\\\.\"\n"
"\n"
"    iex> Regex.escape(\"\\\\what if\")\n"
"    \"\\\\\\\\what\\\\ if\"\n"
"\n"

#. TRANSLATORS: def Regex.split(regex, string, options \\ [])
#: lib/regex.ex:333
msgid ""
"Splits the given target based on the given pattern and in the given number "
"of\n"
"parts.\n"
"\n"
"## Options\n"
"\n"
"  * `:parts` - when specified, splits the string into the given number of\n"
"    parts. If not specified, `:parts` defaults to `:infinity`, which will\n"
"    split the string into the maximum number of parts possible based on the\n"
"    given pattern.\n"
"\n"
"  * `:trim` - when `true`, removes empty strings (`\"\"`) from the result.\n"
"\n"
"  * `:on` - specifies which captures to split the string on, and in what\n"
"    order. Defaults to `:first` which means captures inside the regex do "
"not\n"
"    affect the splitting process.\n"
"\n"
"  * `:include_captures` - when `true`, includes in the result the matches "
"of\n"
"    the regular expression. Defaults to `false`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.split(~r/-/, \"a-b-c\")\n"
"    [\"a\", \"b\", \"c\"]\n"
"\n"
"    iex> Regex.split(~r/-/, \"a-b-c\", [parts: 2])\n"
"    [\"a\", \"b-c\"]\n"
"\n"
"    iex> Regex.split(~r/-/, \"abc\")\n"
"    [\"abc\"]\n"
"\n"
"    iex> Regex.split(~r//, \"abc\")\n"
"    [\"a\", \"b\", \"c\", \"\"]\n"
"\n"
"    iex> Regex.split(~r/a(?<second>b)c/, \"abc\")\n"
"    [\"\", \"\"]\n"
"\n"
"    iex> Regex.split(~r/a(?<second>b)c/, \"abc\", on: [:second])\n"
"    [\"a\", \"c\"]\n"
"\n"
"    iex> Regex.split(~r/(x)/, \"Elixir\", include_captures: true)\n"
"    [\"Eli\", \"x\", \"ir\"]\n"
"\n"
"    iex> Regex.split(~r/a(?<second>b)c/, \"abc\", on: [:second], "
"include_captures: true)\n"
"    [\"a\", \"b\", \"c\"]\n"
"\n"
msgstr ""
"与えられたターゲットを指定された数の部分に分割します。\n"
"\n"
"## オプション\n"
"\n"
"  * `:parts` - 指定されたとき、文字列を与えられた数のパーツに分割します。\n"
"    もし指定されてないと、`:parts`のデフォルト値は`:infinity`、つまり、\n"
"    与えられたパターンに基いて、可能な限りの最大の数のパーツに分割されま"
"す。\n"
"\n"
"  * `:trim` - `true`の時、結果から空文字列(\"\")を取り除きます。\n"
"\n"
"  * `:on` - 分割した文字列を捕捉することと、その順番を指定します。デフォ\n"
"     ルトは`:first`で、それは、Regexの内部で捕捉することを意味し、分割\n"
"     の結果に影響しません。\n"
"\n"
"  * `:include_captures` - `true`の時、その正規表現にマッチした結果を\n"
"    含みます。デフォルトは`false`です。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.split(~r/-/, \"a-b-c\")\n"
"    [\"a\", \"b\", \"c\"]\n"
"\n"
"    iex> Regex.split(~r/-/, \"a-b-c\", [parts: 2])\n"
"    [\"a\", \"b-c\"]\n"
"\n"
"    iex> Regex.split(~r/-/, \"abc\")\n"
"    [\"abc\"]\n"
"\n"
"    iex> Regex.split(~r//, \"abc\")\n"
"    [\"a\", \"b\", \"c\", \"\"]\n"
"\n"
"    iex> Regex.split(~r/a(?<second>b)c/, \"abc\")\n"
"    [\"\", \"\"]\n"
"\n"
"    iex> Regex.split(~r/a(?<second>b)c/, \"abc\", on: [:second])\n"
"    [\"a\", \"c\"]\n"
"\n"

#. TRANSLATORS: def Regex.named_captures(regex, string, options \\ [])
#: lib/regex.ex:217
msgid ""
"Returns the given captures as a map or `nil` if no captures are\n"
"found. The option `:return` can be set to `:index` to get indexes\n"
"back.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.named_captures(~r/c(?<foo>d)/, \"abcd\")\n"
"    %{\"foo\" => \"d\"}\n"
"\n"
"    iex> Regex.named_captures(~r/a(?<foo>b)c(?<bar>d)/, \"abcd\")\n"
"    %{\"bar\" => \"d\", \"foo\" => \"b\"}\n"
"\n"
"    iex> Regex.named_captures(~r/a(?<foo>b)c(?<bar>d)/, \"efgh\")\n"
"    nil\n"
"\n"
msgstr ""
"与えられたキャプチャをマップとして返します。キャプチャが見付からないな\n"
"ら、`nil`を返します。インデックスを戻すために`:return`オプションを\n"
"`:index`にセットすることができます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Regex.named_captures(~r/c(?<foo>d)/, \"abcd\")\n"
"    %{\"foo\" => \"d\"}\n"
"\n"
"    iex> Regex.named_captures(~r/a(?<foo>b)c(?<bar>d)/, \"abcd\")\n"
"    %{\"bar\" => \"d\", \"foo\" => \"b\"}\n"
"\n"
"    iex> Regex.named_captures(~r/a(?<foo>b)c(?<bar>d)/, \"efgh\")\n"
"    nil\n"
"\n"

#. TRANSLATORS: def Regex.scan(regex, string, options \\ [])
#: lib/regex.ex:293
msgid ""
"Same as `run/3`, but scans the target several times collecting all\n"
"matches of the regular expression.\n"
"\n"
"A list of lists is returned, where each entry in the primary list represents "
"a\n"
"match and each entry in the secondary list represents the captured "
"contents.\n"
"\n"
"## Options\n"
"\n"
"  * `:return`  - set to `:index` to return indexes. Defaults to `:binary`.\n"
"  * `:capture` - what to capture in the result. Check the moduledoc for "
"`Regex`\n"
"    to see the possible capture values.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.scan(~r/c(d|e)/, \"abcd abce\")\n"
"    [[\"cd\", \"d\"], [\"ce\", \"e\"]]\n"
"\n"
"    iex> Regex.scan(~r/c(?:d|e)/, \"abcd abce\")\n"
"    [[\"cd\"], [\"ce\"]]\n"
"\n"
"    iex> Regex.scan(~r/e/, \"abcd\")\n"
"    []\n"
"\n"
msgstr ""
"`run/3`と同じですが、正規表現にマッチしたもの全てを集めるため何回かスキャ\n"
"ンします。\n"
"\n"
"それぞれのリストの最初の要素はマッチを表現し、それぞれのリストの次の要\n"
"素はキャプチャされたコンテンツを表現する、リストのリストを返します。\n"
"\n"
"\n"
"## オプション\n"
"\n"
"  * `:return`  - `:index`をセットするとindexを返します。デフォルト\n"
"                 は`:binary`です。\n"
"  * `:capture` - 結果にキャプチャを含めます。可能なキャプチャの値\n"
"                 を見るために`Regex`のドキュメントをチェックしてください。\n"
"\n"
"## 例\n"
"\n"
"    iex> Regex.scan(~r/c(d|e)/, \"abcd abce\")\n"
"    [[\"cd\", \"d\"], [\"ce\", \"e\"]]\n"
"\n"
"    iex> Regex.scan(~r/c(?:d|e)/, \"abcd abce\")\n"
"    [[\"cd\"], [\"ce\"]]\n"
"\n"
"    iex> Regex.scan(~r/e/, \"abcd\")\n"
"    []\n"
"\n"

#. TRANSLATORS: def Regex.compile(source, options \\ "")
#: lib/regex.ex:89
msgid ""
"Compiles the regular expression.\n"
"\n"
"The given options can either be a binary with the characters\n"
"representing the same regex options given to the `~r` sigil,\n"
"or a list of options, as expected by the Erlang's [`:re` module](http://www."
"erlang.org/doc/man/re.html).\n"
"\n"
"It returns `{:ok, regex}` in case of success,\n"
"`{:error, reason}` otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.compile(\"foo\")\n"
"    {:ok, ~r\"foo\"}\n"
"\n"
"    iex> Regex.compile(\"*foo\")\n"
"    {:error, {'nothing to repeat', 0}}\n"
"\n"
msgstr ""
"正規表現をコンパイルします。\n"
"\n"
"与えられたオプションは、`~r` sigilのための正規表現オプションである、\n"
"文字列表現でも、Erlangの \n"
"[`:re` モジュール](http://www.erlang.org/doc/man/re.html)\n"
"によって想定されるオプションのリストでも有り得ます。\n"
"\n"
"成功したら、`{:ok, regex}`を返し、さもなければ`{:error, reason}`を返し\n"
"ます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Regex.compile(\"foo\")\n"
"    {:ok, ~r\"foo\"}\n"
"\n"
"    iex> Regex.compile(\"*foo\")\n"
"    {:error, {'nothing to repeat', 0}}\n"
"\n"

#. TRANSLATORS: def Regex.opts(regex)
#: lib/regex.ex:264
msgid ""
"Returns the regex options as a string.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.opts(~r(foo)m)\n"
"    \"m\"\n"
"\n"
msgstr ""
"正規表現オプションを文字列として返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Regex.opts(~r(foo)m)\n"
"    \"m\"\n"
"\n"

#. TRANSLATORS: def Regex.re_pattern(regex)
#: lib/regex.ex:242
msgid "Returns the underlying `re_pattern` in the regular expression.\n"
msgstr "正規表現で根底にある`re_pattern`を返します。\n"

#. TRANSLATORS: def Regex.regex?(term)
#: lib/regex.ex:163
msgid ""
"Returns `true` if the given `term` is a regex.\n"
"Otherwise returns `false`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.regex?(~r/foo/)\n"
"    true\n"
"\n"
"    iex> Regex.regex?(0)\n"
"    false\n"
"\n"
msgstr ""
"与えられた`term`が正規表現なら`true`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Regex.regex?(~r/foo/)\n"
"    true\n"
"\n"
"    iex> Regex.regex?(0)\n"
"    false\n"
"\n"

#. TRANSLATORS: def Regex.names(regex)
#: lib/regex.ex:278
msgid ""
"Returns a list of names in the regex.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.names(~r/(?<foo>bar)/)\n"
"    [\"foo\"]\n"
"\n"
msgstr ""
"regex中の名前のリストを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Regex.names(~r/(?<foo>bar)/)\n"
"    [\"foo\"]\n"
"\n"

#. TRANSLATORS: def Regex.run(regex, string, options \\ [])
#: lib/regex.ex:181
msgid ""
"Runs the regular expression against the given string until the first match.\n"
"It returns a list with all captures or `nil` if no match occurred.\n"
"\n"
"## Options\n"
"\n"
"  * `:return`  - set to `:index` to return indexes. Defaults to `:binary`.\n"
"  * `:capture` - what to capture in the result. Check the moduledoc for "
"`Regex`\n"
"    to see the possible capture values.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.run(~r/c(d)/, \"abcd\")\n"
"    [\"cd\", \"d\"]\n"
"\n"
"    iex> Regex.run(~r/e/, \"abcd\")\n"
"    nil\n"
"\n"
"    iex> Regex.run(~r/c(d)/, \"abcd\", return: :index)\n"
"    [{2, 2}, {3, 1}]\n"
"\n"
msgstr ""
"最初にマッチするまで、与えられた文字列に対して正規表現を走らせます。全\n"
"てのキャプチャされたリストまたは、マッチがなかった場合は`nil`を返します。\n"
"\n"
"## オプション\n"
"\n"
"  * `:return`  - `:index`をセットするとindexを返します。デフォルト\n"
"                 は`:binary`です。\n"
"  * `:capture` - 結果にキャプチャを含めます。可能なキャプチャの値\n"
"                 を見るために`Regex`のドキュメントをチェックしてください。\n"
"\n"
"## 例\n"
"\n"
"    iex> Regex.run(~r/c(d)/, \"abcd\")\n"
"    [\"cd\", \"d\"]\n"
"\n"
"    iex> Regex.run(~r/e/, \"abcd\")\n"
"    nil\n"
"\n"
"    iex> Regex.run(~r/c(d)/, \"abcd\", return: :index)\n"
"    [{2,2},{3,1}]\n"
"\n"

#. TRANSLATORS: def Regex.match?(regex, string)
#: lib/regex.ex:146
msgid ""
"Returns a boolean indicating whether there was a match or not.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.match?(~r/foo/, \"foo\")\n"
"    true\n"
"\n"
"    iex> Regex.match?(~r/foo/, \"bar\")\n"
"    false\n"
"\n"
msgstr ""
"マッチするか否かをブーリアンで返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Regex.match?(~r/foo/, \"foo\")\n"
"    true\n"
"\n"
"    iex> Regex.match?(~r/foo/, \"bar\")\n"
"    false\n"
"\n"

#. TRANSLATORS: def Regex.compile!(source, options \\ "")
#: lib/regex.ex:134
msgid ""
"Compiles the regular expression according to the given options.\n"
"Fails with `Regex.CompileError` if the regex cannot be compiled.\n"
msgstr ""
"正規表現を与えられたオプションに従って、コンパイルします。\n"
"regexがコンパイル出来なかったら、`Regex.CompileError`で失敗します。\n"

#. TRANSLATORS: def Regex.source(regex)
#: lib/regex.ex:250
msgid ""
"Returns the regex source as a binary.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.source(~r(foo))\n"
"    \"foo\"\n"
"\n"
msgstr ""
"正規表現のソースをバイナリとして返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Regex.source(~r(foo))\n"
"    \"foo\"\n"
"\n"
