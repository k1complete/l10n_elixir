#. TRANSLATORS: Elixir.Regex Summary
#: lib/regex.ex:2 
msgid ""
"Provides regular expressions for Elixir. Built on top of Erlang's `:re`\n"
"module.\n"
"\n"
"As the `:re` module, Regex is based on PCRE\n"
"(Perl Compatible Regular Expressions). More information can be\n"
"found in the [`:re` module documentation](http://www.erlang.org/doc/man/re.html).\n"
"\n"
"Regular expressions in Elixir can be created using `Regex.compile!/2`\n"
"or using the special form with [`~r`](Kernel.html#sigil_r/2) or [`~R`](Kernel.html#sigil_R/2):\n"
"\n"
"    # A simple regular expressions that matches foo anywhere in the string\n"
"    ~r/foo/\n"
"\n"
"    # A regular expression with case insensitive and unicode options\n"
"    ~r/foo/iu\n"
"\n"
"A Regex is represented internally as the `Regex` struct. Therefore,\n"
"`%Regex{}` can be used whenever there is a need to match on them.\n"
"\n"
"## Modifiers\n"
"\n"
"The modifiers available when creating a Regex are:\n"
"\n"
"  * `unicode` (u) - enables unicode specific patterns like `\\p` and change\n"
"    modifiers like `\\w`, `\\W`, `\\s` and friends to also match on unicode.\n"
"    It expects valid unicode strings to be given on match\n"
"\n"
"  * `caseless` (i) - add case insensitivity\n"
"\n"
"  * `dotall` (s) - causes dot to match newlines and also set newline to\n"
"    anycrlf; the new line setting can be overridden by setting `(*CR)` or\n"
"    `(*LF)` or `(*CRLF)` or `(*ANY)` according to re documentation\n"
"\n"
"  * `multiline` (m) - causes `^` and `$` to mark the beginning and end of\n"
"    each line; use `\\A` and `\\z` to match the end or beginning of the string\n"
"\n"
"  * `extended` (x) - whitespace characters are ignored except when escaped\n"
"    and allow `#` to delimit comments\n"
"\n"
"  * `firstline` (f) - forces the unanchored pattern to match before or at the\n"
"    first newline, though the matched text may continue over the newline\n"
"\n"
"  * `ungreedy` (U) - inverts the \"greediness\" of the regexp\n"
"    (the previous `r` option is deprecated in favor of `U`)\n"
"\n"
"The options not available are:\n"
"\n"
"  * `anchored` - not available, use `^` or `\\A` instead\n"
"  * `dollar_endonly` - not available, use `\\z` instead\n"
"  * `no_auto_capture` - not available, use `?:` instead\n"
"  * `newline` - not available, use `(*CR)` or `(*LF)` or `(*CRLF)` or\n"
"    `(*ANYCRLF)` or `(*ANY)` at the beginning of the regexp according to the\n"
"    re documentation\n"
"\n"
"## Captures\n"
"\n"
"Many functions in this module handle what to capture in a regex\n"
"match via the `:capture` option. The supported values are:\n"
"\n"
"  * `:all` - all captured subpatterns including the complete matching string\n"
"    (this is the default)\n"
"\n"
"  * `:first` - only the first captured subpattern, which is always the\n"
"    complete matching part of the string; all explicitly captured subpatterns\n"
"    are discarded\n"
"\n"
"  * `:all_but_first`- all but the first matching subpattern, i.e. all\n"
"    explicitly captured subpatterns, but not the complete matching part of\n"
"    the string\n"
"\n"
"  * `:none` - do not return matching subpatterns at all\n"
"\n"
"  * `:all_names` - captures all names in the Regex\n"
"\n"
"  * `list(binary)` - a list of named captures to capture\n"
"\n"
msgstr ""
#. TRANSLATORS: def Regex.replace(regex, string, replacement, options \\ [])
#: lib/regex.ex:454 
msgid ""
"Receives a regex, a binary and a replacement, returns a new\n"
"binary where all matches are replaced by the replacement.\n"
"\n"
"The replacement can be either a string or a function. The string\n"
"is used as a replacement for every match and it allows specific\n"
"captures to be accessed via `\\\\N` or `\\g{N}`, where `N` is the\n"
"capture. In case `\\\\0` is used, the whole match is inserted.\n"
"\n"
"When the replacement is a function, the function may have arity\n"
"N where each argument maps to a capture, with the first argument\n"
"being the whole match. If the function expects more arguments\n"
"than captures found, the remaining arguments will receive `\"\"`.\n"
"\n"
"## Options\n"
"\n"
"  * `:global` - when `false`, replaces only the first occurrence\n"
"    (defaults to `true`)\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.replace(~r/d/, \"abc\", \"d\")\n"
"    \"abc\"\n"
"\n"
"    iex> Regex.replace(~r/b/, \"abc\", \"d\")\n"
"    \"adc\"\n"
"\n"
"    iex> Regex.replace(~r/b/, \"abc\", \"[\\\\0]\")\n"
"    \"a[b]c\"\n"
"\n"
"    iex> Regex.replace(~r/a(b|d)c/, \"abcadc\", \"[\\\\1]\")\n"
"    \"[b][d]\"\n"
"\n"
"    iex> Regex.replace(~r/\\.(\\d)$/, \"500.5\", \".\\\\g{1}0\")\n"
"    \"500.50\"\n"
"\n"
"    iex> Regex.replace(~r/a(b|d)c/, \"abcadc\", fn _, x -> \"[#{x}]\" end)\n"
"    \"[b][d]\"\n"
"\n"
"    iex> Regex.replace(~r/a/, \"abcadc\", \"A\", global: false)\n"
"    \"Abcadc\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Regex.escape(string)
#: lib/regex.ex:631 
msgid ""
"Escapes a string to be literally matched in a regex.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.escape(\".\")\n"
"    \"\\\\.\"\n"
"\n"
"    iex> Regex.escape(\"\\\\what if\")\n"
"    \"\\\\\\\\what\\\\ if\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Regex.split(regex, string, options \\ [])
#: lib/regex.ex:334 
msgid ""
"Splits the given target based on the given pattern and in the given number of\n"
"parts.\n"
"\n"
"## Options\n"
"\n"
"  * `:parts` - when specified, splits the string into the given number of\n"
"    parts. If not specified, `:parts` defaults to `:infinity`, which will\n"
"    split the string into the maximum number of parts possible based on the\n"
"    given pattern.\n"
"\n"
"  * `:trim` - when `true`, removes empty strings (`\"\"`) from the result.\n"
"\n"
"  * `:on` - specifies which captures to split the string on, and in what\n"
"    order. Defaults to `:first` which means captures inside the regex do not\n"
"    affect the splitting process.\n"
"\n"
"  * `:include_captures` - when `true`, includes in the result the matches of\n"
"    the regular expression. Defaults to `false`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.split(~r/-/, \"a-b-c\")\n"
"    [\"a\", \"b\", \"c\"]\n"
"\n"
"    iex> Regex.split(~r/-/, \"a-b-c\", [parts: 2])\n"
"    [\"a\", \"b-c\"]\n"
"\n"
"    iex> Regex.split(~r/-/, \"abc\")\n"
"    [\"abc\"]\n"
"\n"
"    iex> Regex.split(~r//, \"abc\")\n"
"    [\"a\", \"b\", \"c\", \"\"]\n"
"\n"
"    iex> Regex.split(~r/a(?<second>b)c/, \"abc\")\n"
"    [\"\", \"\"]\n"
"\n"
"    iex> Regex.split(~r/a(?<second>b)c/, \"abc\", on: [:second])\n"
"    [\"a\", \"c\"]\n"
"\n"
"    iex> Regex.split(~r/(x)/, \"Elixir\", include_captures: true)\n"
"    [\"Eli\", \"x\", \"ir\"]\n"
"\n"
"    iex> Regex.split(~r/a(?<second>b)c/, \"abc\", on: [:second], include_captures: true)\n"
"    [\"a\", \"b\", \"c\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Regex.named_captures(regex, string, options \\ [])
#: lib/regex.ex:218 
msgid ""
"Returns the given captures as a map or `nil` if no captures are\n"
"found. The option `:return` can be set to `:index` to get indexes\n"
"back.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.named_captures(~r/c(?<foo>d)/, \"abcd\")\n"
"    %{\"foo\" => \"d\"}\n"
"\n"
"    iex> Regex.named_captures(~r/a(?<foo>b)c(?<bar>d)/, \"abcd\")\n"
"    %{\"bar\" => \"d\", \"foo\" => \"b\"}\n"
"\n"
"    iex> Regex.named_captures(~r/a(?<foo>b)c(?<bar>d)/, \"efgh\")\n"
"    nil\n"
"\n"
msgstr ""
#. TRANSLATORS: def Regex.scan(regex, string, options \\ [])
#: lib/regex.ex:294 
msgid ""
"Same as `run/3`, but scans the target several times collecting all\n"
"matches of the regular expression.\n"
"\n"
"A list of lists is returned, where each entry in the primary list represents a\n"
"match and each entry in the secondary list represents the captured contents.\n"
"\n"
"## Options\n"
"\n"
"  * `:return`  - set to `:index` to return indexes. Defaults to `:binary`.\n"
"  * `:capture` - what to capture in the result. Check the moduledoc for `Regex`\n"
"    to see the possible capture values.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.scan(~r/c(d|e)/, \"abcd abce\")\n"
"    [[\"cd\", \"d\"], [\"ce\", \"e\"]]\n"
"\n"
"    iex> Regex.scan(~r/c(?:d|e)/, \"abcd abce\")\n"
"    [[\"cd\"], [\"ce\"]]\n"
"\n"
"    iex> Regex.scan(~r/e/, \"abcd\")\n"
"    []\n"
"\n"
msgstr ""
#. TRANSLATORS: def Regex.compile(source, options \\ "")
#: lib/regex.ex:89 
msgid ""
"Compiles the regular expression.\n"
"\n"
"The given options can either be a binary with the characters\n"
"representing the same regex options given to the `~r` sigil,\n"
"or a list of options, as expected by the Erlang's [`:re` module](http://www.erlang.org/doc/man/re.html).\n"
"\n"
"It returns `{:ok, regex}` in case of success,\n"
"`{:error, reason}` otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.compile(\"foo\")\n"
"    {:ok, ~r\"foo\"}\n"
"\n"
"    iex> Regex.compile(\"*foo\")\n"
"    {:error, {'nothing to repeat', 0}}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Regex.opts(regex)
#: lib/regex.ex:265 
msgid ""
"Returns the regex options as a string.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.opts(~r(foo)m)\n"
"    \"m\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Regex.run(regex, string, options \\ [])
#: lib/regex.ex:182 
msgid ""
"Runs the regular expression against the given string until the first match.\n"
"It returns a list with all captures or `nil` if no match occurred.\n"
"\n"
"## Options\n"
"\n"
"  * `:return`  - set to `:index` to return indexes. Defaults to `:binary`.\n"
"  * `:capture` - what to capture in the result. Check the moduledoc for `Regex`\n"
"    to see the possible capture values.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.run(~r/c(d)/, \"abcd\")\n"
"    [\"cd\", \"d\"]\n"
"\n"
"    iex> Regex.run(~r/e/, \"abcd\")\n"
"    nil\n"
"\n"
"    iex> Regex.run(~r/c(d)/, \"abcd\", return: :index)\n"
"    [{2, 2}, {3, 1}]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Regex.regex?(term)
#: lib/regex.ex:163 
msgid ""
"Returns `true` if the given `term` is a regex.\n"
"Otherwise returns `false`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.regex?(~r/foo/)\n"
"    true\n"
"\n"
"    iex> Regex.regex?(0)\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Regex.names(regex)
#: lib/regex.ex:279 
msgid ""
"Returns a list of names in the regex.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.names(~r/(?<foo>bar)/)\n"
"    [\"foo\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Regex.match?(regex, string)
#: lib/regex.ex:146 
msgid ""
"Returns a boolean indicating whether there was a match or not.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.match?(~r/foo/, \"foo\")\n"
"    true\n"
"\n"
"    iex> Regex.match?(~r/foo/, \"bar\")\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Regex.re_pattern(regex)
#: lib/regex.ex:243 
msgid ""
"Returns the underlying `re_pattern` in the regular expression.\n"
msgstr ""
#. TRANSLATORS: def Regex.compile!(source, options \\ "")
#: lib/regex.ex:134 
msgid ""
"Compiles the regular expression according to the given options.\n"
"Fails with `Regex.CompileError` if the regex cannot be compiled.\n"
msgstr ""
#. TRANSLATORS: def Regex.source(regex)
#: lib/regex.ex:251 
msgid ""
"Returns the regex source as a binary.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.source(~r(foo))\n"
"    \"foo\"\n"
"\n"
msgstr ""
