msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2015-12-14 22:12+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: def Keyword.update!(keywords, key, fun)
#: lib/keyword.ex:614
msgid ""
"Updates the `key` with the given function.\n"
"\n"
"If the `key` does not exist, raises `KeyError`.\n"
"\n"
"If there are duplicated keys, they are all removed and only the first one\n"
"is updated.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.update!([a: 1], :a, &(&1 * 2))\n"
"    [a: 2]\n"
"    iex> Keyword.update!([a: 1, a: 2], :a, &(&1 * 2))\n"
"    [a: 2]\n"
"\n"
"    iex> Keyword.update!([a: 1], :b, &(&1 * 2))\n"
"    ** (KeyError) key :b not found in: [a: 1]\n"
"\n"
msgstr ""
"与えられた関数で`key`を更新します。\n"
"\n"
"もし`key`が存在しないなら、`KeyError`を上げます。\n"
"\n"
"もしキーが重複していたら、全て削除され、最初の値だけが\n"
"更新されます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.update!([a: 1], :a, &(&1 * 2))\n"
"    [a: 2]\n"
"    iex> Keyword.update!([a: 1, a: 2], :a, &(&1 * 2))\n"
"    [a: 2]\n"
"\n"
"    iex> Keyword.update!([a: 1], :b, &(&1 * 2))\n"
"    ** (KeyError) key :b not found in: [a: 1]\n"
"\n"

#. TRANSLATORS: def Keyword.delete(keywords, key, value)
#: lib/keyword.ex:374
msgid ""
"Deletes the entries in the keyword list for a `key` with `value`.\n"
"\n"
"If no `key` with `value` exists, returns the keyword list unchanged.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.delete([a: 1, b: 2], :a, 1)\n"
"    [b: 2]\n"
"    iex> Keyword.delete([a: 1, b: 2, a: 3], :a, 3)\n"
"    [a: 1, b: 2]\n"
"    iex> Keyword.delete([a: 1], :a, 5)\n"
"    [a: 1]\n"
"    iex> Keyword.delete([a: 1], :b, 5)\n"
"    [a: 1]\n"
"\n"
msgstr ""
"キーワードリスト中の`value`を持つ`key`のエントリ全てを削除します。\n"
"\n"
"もし`value`を持つ`key`が存在しないなら、\n"
"変更せずにキーワードリストを返します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.delete([a: 1, b: 2], :a, 1)\n"
"    [b: 2]\n"
"    iex> Keyword.delete([a: 1, b: 2, a: 3], :a, 3)\n"
"    [a: 1, b: 2]\n"
"    iex> Keyword.delete([a: 1], :a, 5)\n"
"    [a: 1]\n"
"    iex> Keyword.delete([a: 1], :b, 5)\n"
"    [a: 1]\n"
"\n"

#. TRANSLATORS: def Keyword.pop(keywords, key, default \\ nil)
#: lib/keyword.ex:749
msgid ""
"Returns and removes all values associated with `key` in the keyword list.\n"
"\n"
"All duplicated keys are removed. See `pop_first/3` for\n"
"removing only the first entry.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.pop([a: 1], :a)\n"
"    {1, []}\n"
"    iex> Keyword.pop([a: 1], :b)\n"
"    {nil, [a: 1]}\n"
"    iex> Keyword.pop([a: 1], :b, 3)\n"
"    {3, [a: 1]}\n"
"    iex> Keyword.pop([a: 1, a: 2], :a)\n"
"    {1, []}\n"
"\n"
msgstr ""
"キーワードリストの中の`key`に関連付けられた最初の値\n"
"と、その`key`を取り除いたキーワードリストを返します。\n"
"\n"
"全ての重複したキーは削除されます。最初のエントリだけを\n"
"削除するためには `pop_first/3`を参照してください。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.pop [a: 1], :a\n"
"    {1, []}\n"
"    iex> Keyword.pop [a: 1], :b\n"
"    {nil, [a: 1]}\n"
"    iex> Keyword.pop [a: 1], :b, 3\n"
"    {3, [a: 1]}\n"
"    iex> Keyword.pop [a: 1], :b, 3\n"
"    {3, [a: 1]}\n"
"    iex> Keyword.pop [a: 1, a: 2], :a\n"
"    {1, []}\n"
"\n"

#. TRANSLATORS: def Keyword.get_and_update(keywords, key, fun)
#: lib/keyword.ex:190
msgid ""
"Gets the value from `key` and updates it, all in one pass.\n"
"\n"
"This `fun` argument receives the value of `key` (or `nil` if `key`\n"
"is not present) and must return a two-elements tuple: the \"get\" value "
"(the\n"
"retrieved value, which can be operated on before being returned) and the "
"new\n"
"value to be stored under `key`.\n"
"\n"
"The returned value is a tuple with the \"get\" value returned by `fun` and a "
"new\n"
"keyword list with the updated value under `key`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.get_and_update([a: 1], :a, fn current_value ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    {1, [a: \"new value!\"]}\n"
"\n"
"    iex> Keyword.get_and_update([a: 1], :b, fn current_value ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    {nil, [b: \"new value!\", a: 1]}\n"
"\n"
msgstr ""
"`key`から値を取得し、更新します。それら全てを一度のパスで行います。\n"
"\n"
"`fun`引数は`key`の値(`key`がない時は`nil`)をとり、\n"
"2要素のタプルを返さなければなりません: \"get\"した値(\n"
"取り出された値で、戻す前に操作することが出来ます)と、\n"
"`key`にストアされる新しい値のタプルです。\n"
"\n"
"`fun`により戻された\"get\"された値と、`key`の下で更新された\n"
"新しいキーワードのタプルを返します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.get_and_update([a: 1], :a, fn current_value ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    {1, [a: \"new value!\"]}\n"
"\n"
"    iex> Keyword.get_and_update([a: 1], :b, fn current_value ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    {nil, [b: \"new value!\", a: 1]}\n"
"\n"

#. TRANSLATORS: def Keyword.merge(keywords1, keywords2)
#: lib/keyword.ex:527
msgid ""
"Merges two keyword lists into one.\n"
"\n"
"All keys, including duplicated keys, given in `keywords2` will be added\n"
"to `keywords1`, overriding any existing one.\n"
"\n"
"There are no guarantees about the order of keys in the returned keyword.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4])\n"
"    [b: 2, a: 3, d: 4]\n"
"\n"
"    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4, a: 5])\n"
"    [b: 2, a: 3, d: 4, a: 5]\n"
"\n"
msgstr ""
"二つのキーワードリストを一つにマージします。\n"
"\n"
"与えられた`keyword2`の重複したキーを含む全てのキーは\n"
"`keyword1`に追加され、既存のものは上書きされます。\n"
"\n"
"返されるキーワードリストのキーの順序は保証されません。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4])\n"
"    [b: 2, a: 3, d: 4]\n"
"\n"
"    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4, a: 5])\n"
"    [b: 2, a: 3, d: 4, a: 5]\n"
"\n"

#. TRANSLATORS: def Keyword.new(pairs)
#: lib/keyword.ex:77
msgid ""
"Creates a keyword from an enumerable.\n"
"\n"
"Duplicated entries are removed, the latest one prevails.\n"
"Unlike `Enum.into(enumerable, [])`, `Keyword.new(enumerable)`\n"
"guarantees the keys are unique.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.new([{:b, 1}, {:a, 2}])\n"
"    [b: 1, a: 2]\n"
"\n"
"    iex> Keyword.new([{:a, 1}, {:a, 2}, {:a, 3}])\n"
"    [a: 3]\n"
"\n"
msgstr ""
"enumerableからキーワードリストを作成します。\n"
"\n"
"重複したエントリは削除され、最後のものが勝ちます。\n"
"`Enum.into(enumerable, [])`と異なり、`Keyword.new(enumerable)`は\n"
"キーのユニーク性を保証します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.new([{:b, 1}, {:a, 2}])\n"
"    [b: 1, a: 2]\n"
"\n"
"    iex> Keyword.new([{:a, 1}, {:a, 2}, {:a, 3}])\n"
"    [a: 3]\n"
"\n"

#. TRANSLATORS: Elixir.Keyword Summary
#: lib/keyword.ex:2
msgid ""
"A set of functions for working with keywords.\n"
"\n"
"A keyword is a list of 2-element tuples where the first\n"
"element of the tuple is an atom and the second element\n"
"can be any value.\n"
"\n"
"A keyword may have duplicated keys so it is not strictly\n"
"a dictionary. However most of the functions in this module\n"
"behave exactly as a dictionary so they work similarly to\n"
"the functions you would find in the `Map` module.\n"
"\n"
"For example, `Keyword.get/3` will get the first entry matching\n"
"the given key, regardless if duplicated entries exist.\n"
"Similarly, `Keyword.put/3` and `Keyword.delete/3` ensure all\n"
"duplicated entries for a given key are removed when invoked.\n"
"\n"
"A handful of functions exist to handle duplicated keys, in\n"
"particular, `Enum.into/2` allows creating new keywords without\n"
"removing duplicated keys, `get_values/2` returns all values for\n"
"a given key and `delete_first/2` deletes just one of the existing\n"
"entries.\n"
"\n"
"The functions in Keyword do not guarantee any property when\n"
"it comes to ordering. However, since a keyword list is simply a\n"
"list, all the operations defined in `Enum` and `List` can be\n"
"applied too, specially when ordering is required.\n"
msgstr ""
"キーワードで動く一組の関数です。\n"
"\n"
"キーワードは、最初の要素がアトムで2番目の要素が任意の\n"
"値を取れる、タプルのリストです。\n"
"\n"
"キワードは、それが厳しい辞書でないように、キーの重複を持つかもしれませ\n"
"ん。しかしながら、このモジュールのほとんどの関数は、辞書として\n"
"正確に振る舞って、`Dict`ビヘイビアにより定義されるAPIを模倣します。\n"
"\n"
"例えば、`Keyword.get/3`は、与えられたキーにマッチする最初のエントリを取\n"
"得し、重複したエントリの存在を気にしません。\n"
"同様に、`Keyword.put/3`と`Keyword.delete/3`は、実行されたとき、\n"
"与えられたキーの重複した全てのエントリが削除されることを、確実にします。\n"
"\n"
"小数の関数が、重複したキーを取り扱うために存在します。特に、\n"
"`Enum.into/2`は重複したキーを削除することなく新しいキーワードの作成を許\n"
"し、`get_values/2`は与えられたキーの全ての値を返し、`delete_first/2`は\n"
"存在するエントリの一つだけを削除します。\n"
"\n"
"キーワードリストの関数はプロパティの順序は保証されません。\n"
"しかしながら、キーワドリストは単なるリストなので、\n"
"特別な順序が要求されたときは、`Enum`と`List`で定義された全ての\n"
"操作が適用できます。\n"

#. TRANSLATORS: def Keyword.pop_lazy(keywords, key, fun)
#: lib/keyword.ex:777
msgid ""
"Lazily returns and removes all values associated with `key` in the keyword "
"list.\n"
"\n"
"This is useful if the default value is very expensive to calculate or\n"
"generally difficult to setup and teardown again.\n"
"\n"
"All duplicated keys are removed. See `pop_first/3` for\n"
"removing only the first entry.\n"
"\n"
"## Examples\n"
"\n"
"    iex> keyword = [a: 1]\n"
"    iex> fun = fn ->\n"
"    ...>   # some expensive operation here\n"
"    ...>   13\n"
"    ...> end\n"
"    iex> Keyword.pop_lazy(keyword, :a, fun)\n"
"    {1, []}\n"
"    iex> Keyword.pop_lazy(keyword, :b, fun)\n"
"    {13, [a: 1]}\n"
"\n"
msgstr ""
"キーワードリストの中の`key`に関連付けられた全ての値\n"
"を削除するか、それが無い場合はfunを評価した結果と、\n"
"`key`を削除したキーワードリストを返します。\n"
"\n"
"これはデフォルト値の計算にコストが非常にかかったり、\n"
"一般にset-upやtear-downが困難なときに便利です。\n"
"\n"
"全ての重複したキーは削除されます。最初のエントリだけを\n"
"削除するためには `pop_first/3`を参照してください。\n"
"\n"
"## Examples\n"
"\n"
"    iex> keyword = [a: 1]\n"
"    iex> fun = fn ->\n"
"    ...>   # some expensive operation here\n"
"    ...>   13\n"
"    ...> end\n"
"    iex> Keyword.pop_lazy(keyword, :a, fun)\n"
"    {1, []}\n"
"    iex> Keyword.pop_lazy(keyword, :b, fun)\n"
"    {13, [a: 1]}\n"
"\n"

#. TRANSLATORS: def Keyword.get(keywords, key, default \\ nil)
#: lib/keyword.ex:120
msgid ""
"Gets the value for a specific `key`.\n"
"\n"
"If `key` does not exist, return the default value\n"
"(`nil` if no default value).\n"
"\n"
"If duplicated entries exist, the first one is returned.\n"
"Use `get_values/2` to retrieve all entries.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.get([], :a)\n"
"    nil\n"
"    iex> Keyword.get([a: 1], :a)\n"
"    1\n"
"    iex> Keyword.get([a: 1], :b)\n"
"    nil\n"
"    iex> Keyword.get([a: 1], :b, 3)\n"
"    3\n"
"\n"
"With duplicated keys:\n"
"\n"
"    iex> Keyword.get([a: 1, a: 2], :a, 3)\n"
"    1\n"
"    iex> Keyword.get([a: 1, a: 2], :b, 3)\n"
"    3\n"
"\n"
msgstr ""
"指定された`key`の値を取得します。\n"
"\n"
"`key`が存在しないなら、デフォルト値(デフォルト値が\n"
"ないなら、`nil`)を返します。\n"
"\n"
"もし重複したエントリが存在したら、最初のものが返ります。\n"
"全てのエントリを取り出すには`get_values/2`を使用してください。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.get([], :a)\n"
"    nil\n"
"    iex> Keyword.get([a: 1], :a)\n"
"    1\n"
"    iex> Keyword.get([a: 1], :b)\n"
"    nil\n"
"    iex> Keyword.get([a: 1], :b, 3)\n"
"    3\n"
"\n"
"重複するキーでは:\n"
"\n"
"    iex> Keyword.get([a: 1, a: 2], :a, 3)\n"
"    1\n"
"    iex> Keyword.get([a: 1, a: 2], :b, 3)\n"
"    3\n"
"\n"

#. TRANSLATORS: def Keyword.to_list(keyword)
#: lib/keyword.ex:835
msgid ""
"Returns the keyword list itself.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.to_list([a: 1])\n"
"    [a: 1]\n"
"\n"
msgstr ""
"キーワードリスト自身を返します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.to_list([a: 1])\n"
"    [a: 1]\n"
"\n"

#. TRANSLATORS: def Keyword.put(keywords, key, value)
#: lib/keyword.ex:436
msgid ""
"Puts the given `value` under `key`.\n"
"\n"
"If a previous value is already stored, all entries are\n"
"removed and the value is overridden.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.put([a: 1], :b, 2)\n"
"    [b: 2, a: 1]\n"
"    iex> Keyword.put([a: 1, b: 2], :a, 3)\n"
"    [a: 3, b: 2]\n"
"    iex> Keyword.put([a: 1, b: 2, a: 4], :a, 3)\n"
"    [a: 3, b: 2]\n"
"\n"
msgstr ""
"与えられた`value`を`key`の下でプットします。\n"
"\n"
"もし値が既に保存されていたら、全てのエントリは\n"
"削除されて、値が上書きされます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.put([a: 1], :b, 2)\n"
"    [b: 2, a: 1]\n"
"    iex> Keyword.put([a: 1, b: 2], :a, 3)\n"
"    [a: 3, b: 2]\n"
"    iex> Keyword.put([a: 1, b: 2, a: 4], :a, 3)\n"
"    [a: 3, b: 2]\n"
"\n"

#. TRANSLATORS: def Keyword.put_new(keywords, key, value)
#: lib/keyword.ex:486
msgid ""
"Puts the given `value` under `key` unless the entry `key`\n"
"already exists.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.put_new([a: 1], :b, 2)\n"
"    [b: 2, a: 1]\n"
"    iex> Keyword.put_new([a: 1, b: 2], :a, 3)\n"
"    [a: 1, b: 2]\n"
"\n"
msgstr ""
"既に`key`のエントリが存在しないかぎり、与えられた`value`を\n"
"`key`の下でプットします。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.put_new([a: 1], :b, 2)\n"
"    [b: 2, a: 1]\n"
"    iex> Keyword.put_new([a: 1, b: 2], :a, 3)\n"
"    [a: 1, b: 2]\n"
"\n"

#. TRANSLATORS: def Keyword.put_new_lazy(keywords, key, fun)
#: lib/keyword.ex:457
msgid ""
"Evaluates `fun` and puts the result under `key`\n"
"in keyword list unless `key` is already present.\n"
"\n"
"This is useful if the value is very expensive to calculate or\n"
"generally difficult to setup and teardown again.\n"
"\n"
"## Examples\n"
"\n"
"    iex> keyword = [a: 1]\n"
"    iex> fun = fn ->\n"
"    ...>   # some expensive operation here\n"
"    ...>   3\n"
"    ...> end\n"
"    iex> Keyword.put_new_lazy(keyword, :a, fun)\n"
"    [a: 1]\n"
"    iex> Keyword.put_new_lazy(keyword, :b, fun)\n"
"    [b: 3, a: 1]\n"
"\n"
msgstr ""
"キーワードリストに`key`が既に存在しない限り、\n"
"`fun`を評価し、`key`に結果をputします。\n"
"\n"
"これは値の計算にコストが非常にかかったり、\n"
"一般にset-upやtear-downが困難なときに便利です。\n"
"\n"
"## Examples\n"
"\n"
"    iex> keyword = [a: 1]\n"
"    iex> fun = fn ->\n"
"    ...>   # some expensive operation here\n"
"    ...>   3\n"
"    ...> end\n"
"    iex> Keyword.put_new_lazy(keyword, :a, fun)\n"
"    [a: 1]\n"
"    iex> Keyword.put_new_lazy(keyword, :b, fun)\n"
"    [b: 3, a: 1]\n"
"\n"

#. TRANSLATORS: def Keyword.pop_first(keywords, key, default \\ nil)
#: lib/keyword.ex:810
msgid ""
"Returns and removes the first value associated with `key` in the keyword "
"list.\n"
"\n"
"Duplicated keys are not removed.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.pop_first [a: 1], :a\n"
"    {1, []}\n"
"    iex> Keyword.pop_first [a: 1], :b\n"
"    {nil, [a: 1]}\n"
"    iex> Keyword.pop_first [a: 1], :b, 3\n"
"    {3, [a: 1]}\n"
"    iex> Keyword.pop_first [a: 1, a: 2], :a\n"
"    {1, [a: 2]}\n"
"\n"
msgstr ""
"キーワードリストの中の`key`に関連付けられた最初の値\n"
"と、その`key`を取り除いたキーワードリストを返します。\n"
"\n"
"重複したキーは削除されません。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.pop_first [a: 1], :a\n"
"    {1, []}\n"
"    iex> Keyword.pop_first [a: 1], :b\n"
"    {nil, [a: 1]}\n"
"    iex> Keyword.pop_first [a: 1], :b, 3\n"
"    {3, [a: 1]}\n"
"    iex> Keyword.pop_first [a: 1], :b, 3\n"
"    {3, [a: 1]}\n"
"    iex> Keyword.pop_first [a: 1, a: 2], :a\n"
"    {1, [a: 2]}\n"
"\n"

#. TRANSLATORS: def Keyword.keys(keywords)
#: lib/keyword.ex:338
msgid ""
"Returns all keys from the keyword list.\n"
"\n"
"Duplicated keys appear duplicated in the final list of keys.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.keys([a: 1, b: 2])\n"
"    [:a, :b]\n"
"    iex> Keyword.keys([a: 1, b: 2, a: 3])\n"
"    [:a, :b, :a]\n"
"\n"
msgstr ""
"キーワードリストから全てのキーを返します。\n"
"\n"
"重複したキーは最終的なキーのリストに重複して現れます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.keys([a: 1, b: 2])\n"
"    [:a, :b]\n"
"    iex> Keyword.keys([a: 1, b: 2, a: 3])\n"
"    [:a, :b, :a]\n"
"\n"

#. TRANSLATORS: def Keyword.get_and_update!(keywords, key, fun)
#: lib/keyword.ex:232
msgid ""
"Gets the value from `key` and updates it. Raises if there is no `key`.\n"
"\n"
"This `fun` argument receives the value of `key` and must return a\n"
"two-elements tuple: the \"get\" value (the retrieved value, which can be\n"
"operated on before being returned) and the new value to be stored under\n"
"`key`.\n"
"\n"
"The returned value is a tuple with the \"get\" value returned by `fun` and a "
"new\n"
"keyword list with the updated value under `key`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.get_and_update!([a: 1], :a, fn(current_value) ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    {1, [a: \"new value!\"]}\n"
"\n"
"    iex> Keyword.get_and_update!([a: 1], :b, fn current_value ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    ** (KeyError) key :b not found in: [a: 1]\n"
"\n"
msgstr ""
"`key`から値を取得し、更新します。それら全てを一度のパスで行います。\n"
"\n"
"`fun`引数は`key`の値(`key`がない時は`nil`)をとり、\n"
"2要素のタプルを返さなければなりません: \"get\"した値(\n"
"取り出された値で、戻す前に操作することが出来ます)と、\n"
"`key`にストアされる新しい値のタプルです。\n"
"\n"
"`fun`により戻された\"get\"された値と、`key`の下で更新された\n"
"新しいキーワードのタプルを返します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.get_and_update!([a: 1], :a, fn(current_value) ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    {1, [a: \"new value!\"]}\n"
"\n"
"    iex> Keyword.get_and_update!([a: 1], :b, fn current_value ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    ** (KeyError) key :b not found in: [a: 1]\n"
"\n"

#. TRANSLATORS: def Keyword.update(keywords, key, initial, fun)
#: lib/keyword.ex:650
msgid ""
"Updates the `key` in `keywords` with the given function.\n"
"\n"
"If the `key` does not exist, inserts the given `initial` value.\n"
"\n"
"If there are duplicated keys, they are all removed and only the first one\n"
"is updated.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.update([a: 1], :a, 13, &(&1 * 2))\n"
"    [a: 2]\n"
"    iex> Keyword.update([a: 1, a: 2], :a, 13, &(&1 * 2))\n"
"    [a: 2]\n"
"    iex> Keyword.update([a: 1], :b, 11, &(&1 * 2))\n"
"    [a: 1, b: 11]\n"
"\n"
msgstr ""
"与えられた関数で`key`を更新します。\n"
"\n"
"もし`key`が存在しないなら、与えられた`initial`値を挿入します。\n"
"\n"
"もしキーが重複していたら、全て削除され、最初の値だけが\n"
"更新されます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.update([a: 1], :a, 13, &(&1 * 2))\n"
"    [a: 2]\n"
"    iex> Keyword.update([a: 1, a: 2], :a, 13, &(&1 * 2))\n"
"    [a: 2]\n"
"    iex> Keyword.update([a: 1], :b, 11, &(&1 * 2))\n"
"    [a: 1, b: 11]\n"
"\n"

#. TRANSLATORS: def Keyword.new()
#: lib/keyword.ex:65
msgid ""
"Returns an empty keyword list, i.e. an empty list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.new()\n"
"    []\n"
"\n"
msgstr ""
"空のキーワードリストを返します。即ち、空のリストです。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.new()\n"
"    []\n"
"\n"

#. TRANSLATORS: def Keyword.keyword?(term)
#: lib/keyword.ex:39
msgid ""
"Returns `true` if `term` is a keyword list; otherwise returns `false`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.keyword?([])\n"
"    true\n"
"    iex> Keyword.keyword?([a: 1])\n"
"    true\n"
"    iex> Keyword.keyword?([{Foo, 1}])\n"
"    true\n"
"    iex> Keyword.keyword?([{}])\n"
"    false\n"
"    iex> Keyword.keyword?([:key])\n"
"    false\n"
"    iex> Keyword.keyword?(%{})\n"
"    false\n"
"\n"
msgstr ""
"`term`がキーワードリストなら`true`を返し、さもなくば`false`を返します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.keyword?([])\n"
"    true\n"
"    iex> Keyword.keyword?([a: 1])\n"
"    true\n"
"    iex> Keyword.keyword?([{Foo, 1}])\n"
"    true\n"
"    iex> Keyword.keyword?([{}])\n"
"    false\n"
"    iex> Keyword.keyword?([:key])\n"
"    false\n"
"    iex> Keyword.keyword?(%{})\n"
"    false\n"
"\n"

#. TRANSLATORS: def Keyword.new(pairs, transform)
#: lib/keyword.ex:98
msgid ""
"Creates a keyword from an enumerable via the transformation function.\n"
"\n"
"Duplicated entries are removed, the latest one prevails.\n"
"Unlike `Enum.into(enumerable, [], fun)`,\n"
"`Keyword.new(enumerable, fun)` guarantees the keys are unique.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.new([:a, :b], fn (x) -> {x, x} end)\n"
"    [a: :a, b: :b]\n"
"\n"
msgstr ""
"enumerableから変形関数によって、キーワードリストを作成します。\n"
"\n"
"重複したエントリは削除され、最後のものが勝ちます。\n"
"`Enum.into(enumerable, [])`と異なり、`Keyword.new(enumerable)`は\n"
"キーのユニーク性を保証します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.new([:a, :b], fn (x) -> {x, x} end)\n"
"    [a: :a, b: :b]\n"
"\n"

#. TRANSLATORS: def Keyword.get_lazy(keywords, key, fun)
#: lib/keyword.ex:157
msgid ""
"Gets the value for a specific `key`.\n"
"\n"
"If `key` does not exist, lazily evaluates `fun` and returns its result.\n"
"\n"
"This is useful if the default value is very expensive to calculate or\n"
"generally difficult to setup and teardown again.\n"
"\n"
"If duplicated entries exist, the first one is returned.\n"
"Use `get_values/2` to retrieve all entries.\n"
"\n"
"## Examples\n"
"\n"
"    iex> keyword = [a: 1]\n"
"    iex> fun = fn ->\n"
"    ...>   # some expensive operation here\n"
"    ...>   13\n"
"    ...> end\n"
"    iex> Keyword.get_lazy(keyword, :a, fun)\n"
"    1\n"
"    iex> Keyword.get_lazy(keyword, :b, fun)\n"
"    13\n"
"\n"
msgstr ""
"指定された`key`の値を取得します。\n"
"\n"
"`key`が存在しないなら、`fun`が遅延評価され\n"
"それを返します。\n"
"\n"
"これはデフォルト値の計算にコストが非常にかかったり、\n"
"一般にset-upやtear-downが困難なときに便利です。\n"
"\n"
"もし重複したエントリが存在したら、最初のものが返ります。\n"
"全てのエントリを取り出すには`get_values/2`を使用してください。\n"
"\n"
"## Examples\n"
"\n"
"    iex> keyword = [a: 1]\n"
"    iex> fun = fn ->\n"
"    ...>   # some expensive operation here\n"
"    ...>   13\n"
"    ...> end\n"
"    iex> Keyword.get_lazy(keyword, :a, fun)\n"
"    1\n"
"    iex> Keyword.get_lazy(keyword, :b, fun)\n"
"    13\n"
"\n"

#. TRANSLATORS: def Keyword.fetch(keywords, key)
#: lib/keyword.ex:274
msgid ""
"Fetches the value for a specific `key` and returns it in a tuple.\n"
"\n"
"If the `key` does not exist, returns `:error`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.fetch([a: 1], :a)\n"
"    {:ok, 1}\n"
"    iex> Keyword.fetch([a: 1], :b)\n"
"    :error\n"
"\n"
msgstr ""
"指定した`key`の値を取り出し、タプルに入れて返します。\n"
"\n"
"もし`key`が存在しないなら、`:error`を返します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.fetch([a: 1], :a)\n"
"    {:ok, 1}\n"
"    iex> Keyword.fetch([a: 1], :b)\n"
"    :error\n"
"\n"

#. TRANSLATORS: def Keyword.values(keywords)
#: lib/keyword.ex:356
msgid ""
"Returns all values from the keyword list.\n"
"\n"
"Values from duplicated keys will be kept in the final list of values.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.values([a: 1, b: 2])\n"
"    [1, 2]\n"
"    iex> Keyword.values([a: 1, b: 2, a: 3])\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
"キーワードリストから全てのキーを返します。\n"
"\n"
"重複したキーは最終的なキーのリストに重複して現れます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.values([a: 1, b: 2])\n"
"    [1, 2]\n"
"    iex> Keyword.values([a: 1, b: 2, a: 3])\n"
"    [1, 2, 3]\n"
"\n"

#. TRANSLATORS: def Keyword.merge(keywords1, keywords2, fun)
#: lib/keyword.ex:550
msgid ""
"Merges two keyword lists into one.\n"
"\n"
"All keys, including duplicated keys, given in `keywords2` will be added\n"
"to `keywords1`. The given function will be invoked to solve conflicts.\n"
"\n"
"If `keywords2` has duplicate keys, the given function will be invoked\n"
"for each matching pair in `keywords1`.\n"
"\n"
"There are no guarantees about the order of keys in the returned keyword.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4], fn _k, v1, v2 ->\n"
"    ...>   v1 + v2\n"
"    ...> end)\n"
"    [b: 2, a: 4, d: 4]\n"
"\n"
"    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4, a: 5], fn :a, v1, v2 ->\n"
"    ...>  v1 + v2\n"
"    ...> end)\n"
"    [b: 2, a: 4, d: 4, a: 5]\n"
"\n"
"    iex> Keyword.merge([a: 1, b: 2, a: 3], [a: 3, d: 4, a: 5], fn :a, v1, v2 "
"->\n"
"    ...>  v1 + v2\n"
"    ...> end)\n"
"    [b: 2, a: 4, d: 4, a: 8]\n"
"\n"
msgstr ""
"二つのキーワードリストを一つにマージします。\n"
"\n"
"与えられた`keyword2`の重複したキーを含めた全てのキーは、\n"
"`keyword1`へ追加されます。それから、与えられた\n"
"関数が起動され、衝突が解決されます。\n"
"\n"
"もし`keyword2`が重複したキーを持っていたら、与えられた関数が\n"
"`keyword1`のマッチングするそれぞれのペアに対して起動されます。\n"
"\n"
"返されるキーワドのキーの順序は保証されません。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4], fn _k, v1, v2 ->\n"
"    ...>   v1 + v2\n"
"    ...> end)\n"
"    [b: 2, a: 4, d: 4]\n"
"\n"
"    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4, a: 5], fn :a, v1, v2 ->\n"
"    ...>  v1 + v2\n"
"    ...> end)\n"
"    [b: 2, a: 4, d: 4, a: 5]\n"
"\n"
"    iex> Keyword.merge([a: 1, b: 2, a: 3], [a: 3, d: 4, a: 5], fn :a, v1, v2 "
"->\n"
"    ...>  v1 + v2\n"
"    ...> end)\n"
"    [b: 2, a: 4, d: 4, a: 8]\n"
"\n"

#. TRANSLATORS: def Keyword.get_values(keywords, key)
#: lib/keyword.ex:316
msgid ""
"Gets all values for a specific `key`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.get_values([], :a)\n"
"    []\n"
"    iex> Keyword.get_values([a: 1], :a)\n"
"    [1]\n"
"    iex> Keyword.get_values([a: 1, a: 2], :a)\n"
"    [1, 2]\n"
"\n"
msgstr ""
"特定の`key`の全ての値を取得します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.get_values([], :a)\n"
"    []\n"
"    iex> Keyword.get_values([a: 1], :a)\n"
"    [1]\n"
"    iex> Keyword.get_values([a: 1, a: 2], :a)\n"
"    [1, 2]\n"
"\n"

#. TRANSLATORS: def Keyword.equal?(left, right)
#: lib/keyword.ex:506
msgid ""
"Checks if two keywords are equal.\n"
"\n"
"Two keywords are considered to be equal if they contain\n"
"the same keys and those keys contain the same values.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.equal?([a: 1, b: 2], [b: 2, a: 1])\n"
"    true\n"
"    iex> Keyword.equal?([a: 1, b: 2], [b: 1, a: 2])\n"
"    false\n"
"    iex> Keyword.equal?([a: 1, b: 2, a: 3], [b: 2, a: 3, a: 1])\n"
"    true\n"
"\n"
msgstr ""
"二つのキーワードリストが等しいかチェックします。\n"
"\n"
"二つのキーワードリストは、\n"
"同じキーを含んでいること、それらのキーに同じ値を含んでいる\n"
"かどうかで等しいかを考慮します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.equal?([a: 1, b: 2], [b: 2, a: 1])\n"
"    true\n"
"    iex> Keyword.equal?([a: 1, b: 2], [b: 1, a: 2])\n"
"    false\n"
"    iex> Keyword.equal?([a: 1, b: 2, a: 3], [b: 2, a: 3, a: 1])\n"
"    true\n"
"\n"

#. TRANSLATORS: def Keyword.split(keywords, keys)
#: lib/keyword.ex:683
msgid ""
"Takes all entries corresponding to the given keys and extracts them into a\n"
"separate keyword list.\n"
"\n"
"Returns a tuple with the new list and the old list with removed keys.\n"
"\n"
"Keys for which there are no entires in the keyword list are ignored.\n"
"\n"
"Entries with duplicated keys end up in the same keyword list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.split([a: 1, b: 2, c: 3], [:a, :c, :e])\n"
"    {[a: 1, c: 3], [b: 2]}\n"
"    iex> Keyword.split([a: 1, b: 2, c: 3, a: 4], [:a, :c, :e])\n"
"    {[a: 1, c: 3, a: 4], [b: 2]}\n"
"\n"
msgstr ""
"与えられたキーと一致する全てのエントリを取出して、\n"
"キーワードリストを分割します。\n"
"\n"
"新しいリストと古いリストからキーを削除したもののタプルを返します。\n"
"\n"
"キーワードリストにエントリがないキーは無視されます。\n"
"\n"
"重複したキーのエントリは同じキーワードリストになります。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.split([a: 1, b: 2, c: 3], [:a, :c, :e])\n"
"    {[a: 1, c: 3], [b: 2]}\n"
"    iex> Keyword.split([a: 1, b: 2, c: 3, a: 4], [:a, :c, :e])\n"
"    {[a: 1, c: 3, a: 4], [b: 2]}\n"
"\n"

#. TRANSLATORS: def Keyword.delete(keywords, key)
#: lib/keyword.ex:396
msgid ""
"Deletes the entries in the keyword list for a specific `key`.\n"
"\n"
"If the `key` does not exist, returns the keyword list unchanged.\n"
"Use `delete_first/2` to delete just the first entry in case of\n"
"duplicated keys.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.delete([a: 1, b: 2], :a)\n"
"    [b: 2]\n"
"    iex> Keyword.delete([a: 1, b: 2, a: 3], :a)\n"
"    [b: 2]\n"
"    iex> Keyword.delete([b: 2], :a)\n"
"    [b: 2]\n"
"\n"
msgstr ""
"キーワードリスト中の指定された`key`のエントリ全てを削除します。\n"
"\n"
"もし`key`が存在しないなら、変更せずにキーワードリストを返します。\n"
"重複したキーの最初のエントリだけを削除するためには、\n"
"`delete_first/2`を使ってください。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.delete([a: 1, b: 2], :a)\n"
"    [b: 2]\n"
"    iex> Keyword.delete([a: 1, b: 2, a: 3], :a)\n"
"    [b: 2]\n"
"    iex> Keyword.delete([b: 2], :a)\n"
"    [b: 2]\n"
"\n"

#. TRANSLATORS: def Keyword.take(keywords, keys)
#: lib/keyword.ex:714
msgid ""
"Takes all entries corresponding to the given keys and returns them in a new\n"
"keyword list.\n"
"\n"
"Duplicated keys are preserved in the new keyword list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.take([a: 1, b: 2, c: 3], [:a, :c, :e])\n"
"    [a: 1, c: 3]\n"
"    iex> Keyword.take([a: 1, b: 2, c: 3, a: 5], [:a, :c, :e])\n"
"    [a: 1, c: 3, a: 5]\n"
"\n"
msgstr ""
"与えられたキーと一致している全てのエントリを取出して、それらで\n"
"新しいキーワードリストを作成して返します。\n"
"\n"
"重複したキーは新しいキーワードリストに保存されます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.take([a: 1, b: 2, c: 3], [:a, :c, :e])\n"
"    [a: 1, c: 3]\n"
"    iex> Keyword.take([a: 1, b: 2, c: 3, a: 5], [:a, :c, :e])\n"
"    [a: 1, c: 3, a: 5]\n"
"\n"

#. TRANSLATORS: def Keyword.has_key?(keywords, key)
#: lib/keyword.ex:598
msgid ""
"Returns whether a given `key` exists in the given `keywords`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.has_key?([a: 1], :a)\n"
"    true\n"
"    iex> Keyword.has_key?([a: 1], :b)\n"
"    false\n"
"\n"
msgstr ""
"与えられた`keywords`中に与えられた`key`があるかどうかを返します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.has_key?([a: 1], :a)\n"
"    true\n"
"    iex> Keyword.has_key?([a: 1], :b)\n"
"    false\n"
"\n"

#. TRANSLATORS: def Keyword.fetch!(keywords, key)
#: lib/keyword.ex:295
msgid ""
"Fetches the value for specific `key`.\n"
"\n"
"If `key` does not exist, a `KeyError` is raised.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.fetch!([a: 1], :a)\n"
"    1\n"
"    iex> Keyword.fetch!([a: 1], :b)\n"
"    ** (KeyError) key :b not found in: [a: 1]\n"
"\n"
msgstr ""
"指定した`key`の値を取り出します。\n"
"\n"
"もし`key`が存在しないなら、`KeyError`を上げます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.fetch!([a: 1], :a)\n"
"    1\n"
"    iex> Keyword.fetch!([a: 1], :b)\n"
"    ** (KeyError) key :b not found in: [a: 1]\n"
"\n"

#. TRANSLATORS: def Keyword.drop(keywords, keys)
#: lib/keyword.ex:732
msgid ""
"Drops the given keys from the keyword list.\n"
"\n"
"Duplicated keys are preserved in the new keyword list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.drop([a: 1, b: 2, c: 3], [:b, :d])\n"
"    [a: 1, c: 3]\n"
"    iex> Keyword.drop([a: 1, b: 2, b: 3, c: 3, a: 5], [:b, :d])\n"
"    [a: 1, c: 3, a: 5]\n"
"\n"
msgstr ""
"キーワードリストから与えられたキーリストのエントリを削除します。\n"
"\n"
"重複したキーは新しいキーワードリストに保存されます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.drop([a: 1, b: 2, c: 3], [:b, :d])\n"
"    [a: 1, c: 3]\n"
"    iex> Keyword.drop([a: 1, b: 2, b: 3, c: 3, a: 5], [:b, :d])\n"
"    [a: 1, c: 3, a: 5]\n"
"\n"

#. TRANSLATORS: def Keyword.delete_first(keywords, key)
#: lib/keyword.ex:418
msgid ""
"Deletes the first entry in the keyword list for a specific `key`.\n"
"\n"
"If the `key` does not exist, returns the keyword list unchanged.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.delete_first([a: 1, b: 2, a: 3], :a)\n"
"    [b: 2, a: 3]\n"
"    iex> Keyword.delete_first([b: 2], :a)\n"
"    [b: 2]\n"
"\n"
msgstr ""
"キーワードリスト中の指定された`key`の最初のエントリを削除します。\n"
"\n"
"もし`key`が存在しないなら、変更せずにキーワードリストを返します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.delete_first([a: 1, b: 2, a: 3], :a)\n"
"    [b: 2, a: 3]\n"
"    iex> Keyword.delete_first([b: 2], :a)\n"
"    [b: 2]\n"
"\n"

#~ msgid "Returns an empty keyword list, i.e. an empty list.\n"
#~ msgstr "空のキーワードリスト、すなわち空のリストを返します。\n"

#~ msgid ""
#~ "Returns `true` if `term` is a keyword list; otherwise returns `false`.\n"
#~ msgstr ""
#~ "`term`がキーワードリストなら`true`を返します。\n"
#~ "さもなくば`false`を返します。\n"

#~ msgid ""
#~ "Merges two keyword lists into one.\n"
#~ "\n"
#~ "If they have duplicated keys, the one given in the second argument wins.\n"
#~ "\n"
#~ "## Examples\n"
#~ "\n"
#~ "    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4])\n"
#~ "    [a: 3, d: 4, b: 2]\n"
#~ "\n"
#~ msgstr ""
#~ "二つのキーワードリストを一つにマージします。\n"
#~ "\n"
#~ "もし重複したキーがあれば、二つめの引数が勝ちます。\n"
#~ "\n"
#~ "## 例\n"
#~ "\n"
#~ "    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4])\n"
#~ "    [a: 3, d: 4, b: 2]\n"
#~ "\n"

#~ msgid ""
#~ "Merges two keyword lists into one.\n"
#~ "\n"
#~ "If they have duplicated keys, the given function is invoked to solve "
#~ "conflicts.\n"
#~ "\n"
#~ "## Examples\n"
#~ "\n"
#~ "    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4], fn (_k, v1, v2) ->\n"
#~ "    ...>  v1 + v2\n"
#~ "    ...> end)\n"
#~ "    [a: 4, b: 2, d: 4]\n"
#~ "\n"
#~ msgstr ""
#~ "二つのキーワードリストを一つにマージます。\n"
#~ "\n"
#~ "もし重複したキーがあれば、衝突を解決するため、与えられた関数が\n"
#~ "起動されます。\n"
#~ "\n"
#~ "## 例\n"
#~ "\n"
#~ "    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4], fn (_k, v1, v2) ->\n"
#~ "    ...>  v1 + v2\n"
#~ "    ...> end)\n"
#~ "    [a: 4, b: 2, d: 4]\n"
#~ "\n"

#~ msgid "Checks if the given argument is a keyword list or not.\n"
#~ msgstr ""
#~ "与えられた引数がキーワードリストか否かを、\n"
#~ "チェックします。\n"
