#. TRANSLATORS: def Keyword.pop(keywords, key, default \\ nil)
#: lib/keyword.ex:761 
msgid ""
"Returns and removes all values associated with `key` in the keyword list.\n"
"\n"
"All duplicated keys are removed. See `pop_first/3` for\n"
"removing only the first entry.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.pop([a: 1], :a)\n"
"    {1, []}\n"
"    iex> Keyword.pop([a: 1], :b)\n"
"    {nil, [a: 1]}\n"
"    iex> Keyword.pop([a: 1], :b, 3)\n"
"    {3, [a: 1]}\n"
"    iex> Keyword.pop([a: 1, a: 2], :a)\n"
"    {1, []}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.get(keywords, key, default \\ nil)
#: lib/keyword.ex:120 
msgid ""
"Gets the value for a specific `key`.\n"
"\n"
"If `key` does not exist, return the default value\n"
"(`nil` if no default value).\n"
"\n"
"If duplicated entries exist, the first one is returned.\n"
"Use `get_values/2` to retrieve all entries.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.get([], :a)\n"
"    nil\n"
"    iex> Keyword.get([a: 1], :a)\n"
"    1\n"
"    iex> Keyword.get([a: 1], :b)\n"
"    nil\n"
"    iex> Keyword.get([a: 1], :b, 3)\n"
"    3\n"
"\n"
"With duplicated keys:\n"
"\n"
"    iex> Keyword.get([a: 1, a: 2], :a, 3)\n"
"    1\n"
"    iex> Keyword.get([a: 1, a: 2], :b, 3)\n"
"    3\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.merge(keywords1, keywords2)
#: lib/keyword.ex:539 
msgid ""
"Merges two keyword lists into one.\n"
"\n"
"All keys, including duplicated keys, given in `keywords2` will be added\n"
"to `keywords1`, overriding any existing one.\n"
"\n"
"There are no guarantees about the order of keys in the returned keyword.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4])\n"
"    [b: 2, a: 3, d: 4]\n"
"\n"
"    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4, a: 5])\n"
"    [b: 2, a: 3, d: 4, a: 5]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.update!(keywords, key, fun)
#: lib/keyword.ex:626 
msgid ""
"Updates the `key` with the given function.\n"
"\n"
"If the `key` does not exist, raises `KeyError`.\n"
"\n"
"If there are duplicated keys, they are all removed and only the first one\n"
"is updated.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.update!([a: 1], :a, &(&1 * 2))\n"
"    [a: 2]\n"
"    iex> Keyword.update!([a: 1, a: 2], :a, &(&1 * 2))\n"
"    [a: 2]\n"
"\n"
"    iex> Keyword.update!([a: 1], :b, &(&1 * 2))\n"
"    ** (KeyError) key :b not found in: [a: 1]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.get_and_update!(keywords, key, fun)
#: lib/keyword.ex:244 
msgid ""
"Gets the value from `key` and updates it. Raises if there is no `key`.\n"
"\n"
"This `fun` argument receives the value of `key` and must return a\n"
"two-element tuple: the \"get\" value (the retrieved value, which can be\n"
"operated on before being returned) and the new value to be stored under\n"
"`key`.\n"
"\n"
"The returned value is a tuple with the \"get\" value returned by `fun` and a new\n"
"keyword list with the updated value under `key`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.get_and_update!([a: 1], :a, fn(current_value) ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    {1, [a: \"new value!\"]}\n"
"\n"
"    iex> Keyword.get_and_update!([a: 1], :b, fn current_value ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    ** (KeyError) key :b not found in: [a: 1]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.get_and_update(keywords, key, fun)
#: lib/keyword.ex:190 
msgid ""
"Gets the value from `key` and updates it, all in one pass.\n"
"\n"
"This `fun` argument receives the value of `key` (or `nil` if `key`\n"
"is not present) and must return a two-element tuple: the \"get\" value\n"
"(the retrieved value, which can be operated on before being returned)\n"
"and the new value to be stored under `key`. The `fun` may also\n"
"return `:pop`, implying the current value shall be removed from the\n"
"keyword list and returned.\n"
"\n"
"The returned value is a tuple with the \"get\" value returned by\n"
"`fun` and a new keyword list with the updated value under `key`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.get_and_update([a: 1], :a, fn current_value ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    {1, [a: \"new value!\"]}\n"
"\n"
"    iex> Keyword.get_and_update([a: 1], :b, fn current_value ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    {nil, [b: \"new value!\", a: 1]}\n"
"\n"
"    iex> Keyword.get_and_update([a: 1], :a, fn _ -> :pop end)\n"
"    {1, []}\n"
"\n"
"    iex> Keyword.get_and_update([a: 1], :b, fn _ -> :pop end)\n"
"    {nil, [a: 1]}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.new(pairs)
#: lib/keyword.ex:77 
msgid ""
"Creates a keyword from an enumerable.\n"
"\n"
"Duplicated entries are removed, the latest one prevails.\n"
"Unlike `Enum.into(enumerable, [])`, `Keyword.new(enumerable)`\n"
"guarantees the keys are unique.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.new([{:b, 1}, {:a, 2}])\n"
"    [b: 1, a: 2]\n"
"\n"
"    iex> Keyword.new([{:a, 1}, {:a, 2}, {:a, 3}])\n"
"    [a: 3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.delete(keywords, key, value)
#: lib/keyword.ex:386 
msgid ""
"Deletes the entries in the keyword list for a `key` with `value`.\n"
"\n"
"If no `key` with `value` exists, returns the keyword list unchanged.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.delete([a: 1, b: 2], :a, 1)\n"
"    [b: 2]\n"
"    iex> Keyword.delete([a: 1, b: 2, a: 3], :a, 3)\n"
"    [a: 1, b: 2]\n"
"    iex> Keyword.delete([a: 1], :a, 5)\n"
"    [a: 1]\n"
"    iex> Keyword.delete([a: 1], :b, 5)\n"
"    [a: 1]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.pop_lazy(keywords, key, fun)
#: lib/keyword.ex:789 
msgid ""
"Lazily returns and removes all values associated with `key` in the keyword list.\n"
"\n"
"This is useful if the default value is very expensive to calculate or\n"
"generally difficult to setup and teardown again.\n"
"\n"
"All duplicated keys are removed. See `pop_first/3` for\n"
"removing only the first entry.\n"
"\n"
"## Examples\n"
"\n"
"    iex> keyword = [a: 1]\n"
"    iex> fun = fn ->\n"
"    ...>   # some expensive operation here\n"
"    ...>   13\n"
"    ...> end\n"
"    iex> Keyword.pop_lazy(keyword, :a, fun)\n"
"    {1, []}\n"
"    iex> Keyword.pop_lazy(keyword, :b, fun)\n"
"    {13, [a: 1]}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.to_list(keyword)
#: lib/keyword.ex:847 
msgid ""
"Returns the keyword list itself.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.to_list([a: 1])\n"
"    [a: 1]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.put(keywords, key, value)
#: lib/keyword.ex:448 
msgid ""
"Puts the given `value` under `key`.\n"
"\n"
"If a previous value is already stored, all entries are\n"
"removed and the value is overridden.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.put([a: 1], :b, 2)\n"
"    [b: 2, a: 1]\n"
"    iex> Keyword.put([a: 1, b: 2], :a, 3)\n"
"    [a: 3, b: 2]\n"
"    iex> Keyword.put([a: 1, b: 2, a: 4], :a, 3)\n"
"    [a: 3, b: 2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.put_new(keywords, key, value)
#: lib/keyword.ex:498 
msgid ""
"Puts the given `value` under `key` unless the entry `key`\n"
"already exists.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.put_new([a: 1], :b, 2)\n"
"    [b: 2, a: 1]\n"
"    iex> Keyword.put_new([a: 1, b: 2], :a, 3)\n"
"    [a: 1, b: 2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.put_new_lazy(keywords, key, fun)
#: lib/keyword.ex:469 
msgid ""
"Evaluates `fun` and puts the result under `key`\n"
"in keyword list unless `key` is already present.\n"
"\n"
"This is useful if the value is very expensive to calculate or\n"
"generally difficult to setup and teardown again.\n"
"\n"
"## Examples\n"
"\n"
"    iex> keyword = [a: 1]\n"
"    iex> fun = fn ->\n"
"    ...>   # some expensive operation here\n"
"    ...>   3\n"
"    ...> end\n"
"    iex> Keyword.put_new_lazy(keyword, :a, fun)\n"
"    [a: 1]\n"
"    iex> Keyword.put_new_lazy(keyword, :b, fun)\n"
"    [b: 3, a: 1]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.pop_first(keywords, key, default \\ nil)
#: lib/keyword.ex:822 
msgid ""
"Returns and removes the first value associated with `key` in the keyword list.\n"
"\n"
"Duplicated keys are not removed.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.pop_first [a: 1], :a\n"
"    {1, []}\n"
"    iex> Keyword.pop_first [a: 1], :b\n"
"    {nil, [a: 1]}\n"
"    iex> Keyword.pop_first [a: 1], :b, 3\n"
"    {3, [a: 1]}\n"
"    iex> Keyword.pop_first [a: 1, a: 2], :a\n"
"    {1, [a: 2]}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.keys(keywords)
#: lib/keyword.ex:350 
msgid ""
"Returns all keys from the keyword list.\n"
"\n"
"Duplicated keys appear duplicated in the final list of keys.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.keys([a: 1, b: 2])\n"
"    [:a, :b]\n"
"    iex> Keyword.keys([a: 1, b: 2, a: 3])\n"
"    [:a, :b, :a]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.update(keywords, key, initial, fun)
#: lib/keyword.ex:662 
msgid ""
"Updates the `key` in `keywords` with the given function.\n"
"\n"
"If the `key` does not exist, inserts the given `initial` value.\n"
"\n"
"If there are duplicated keys, they are all removed and only the first one\n"
"is updated.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.update([a: 1], :a, 13, &(&1 * 2))\n"
"    [a: 2]\n"
"    iex> Keyword.update([a: 1, a: 2], :a, 13, &(&1 * 2))\n"
"    [a: 2]\n"
"    iex> Keyword.update([a: 1], :b, 11, &(&1 * 2))\n"
"    [a: 1, b: 11]\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.Keyword Summary
#: lib/keyword.ex:2 
msgid ""
"A set of functions for working with keywords.\n"
"\n"
"A keyword is a list of two-element tuples where the first\n"
"element of the tuple is an atom and the second element\n"
"can be any value.\n"
"\n"
"A keyword may have duplicated keys so it is not strictly\n"
"a key-value store. However most of the functions in this module\n"
"behave exactly as a dictionary so they work similarly to\n"
"the functions you would find in the `Map` module.\n"
"\n"
"For example, `Keyword.get/3` will get the first entry matching\n"
"the given key, regardless if duplicated entries exist.\n"
"Similarly, `Keyword.put/3` and `Keyword.delete/3` ensure all\n"
"duplicated entries for a given key are removed when invoked.\n"
"\n"
"A handful of functions exist to handle duplicated keys, in\n"
"particular, `Enum.into/2` allows creating new keywords without\n"
"removing duplicated keys, `get_values/2` returns all values for\n"
"a given key and `delete_first/2` deletes just one of the existing\n"
"entries.\n"
"\n"
"The functions in Keyword do not guarantee any property when\n"
"it comes to ordering. However, since a keyword list is simply a\n"
"list, all the operations defined in `Enum` and `List` can be\n"
"applied too, specially when ordering is required.\n"
msgstr ""
#. TRANSLATORS: def Keyword.keyword?(term)
#: lib/keyword.ex:39 
msgid ""
"Returns `true` if `term` is a keyword list; otherwise returns `false`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.keyword?([])\n"
"    true\n"
"    iex> Keyword.keyword?([a: 1])\n"
"    true\n"
"    iex> Keyword.keyword?([{Foo, 1}])\n"
"    true\n"
"    iex> Keyword.keyword?([{}])\n"
"    false\n"
"    iex> Keyword.keyword?([:key])\n"
"    false\n"
"    iex> Keyword.keyword?(%{})\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.new()
#: lib/keyword.ex:65 
msgid ""
"Returns an empty keyword list, i.e. an empty list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.new()\n"
"    []\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.merge(keywords1, keywords2, fun)
#: lib/keyword.ex:562 
msgid ""
"Merges two keyword lists into one.\n"
"\n"
"All keys, including duplicated keys, given in `keywords2` will be added\n"
"to `keywords1`. The given function will be invoked to solve conflicts.\n"
"\n"
"If `keywords2` has duplicate keys, the given function will be invoked\n"
"for each matching pair in `keywords1`.\n"
"\n"
"There are no guarantees about the order of keys in the returned keyword.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4], fn _k, v1, v2 ->\n"
"    ...>   v1 + v2\n"
"    ...> end)\n"
"    [b: 2, a: 4, d: 4]\n"
"\n"
"    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4, a: 5], fn :a, v1, v2 ->\n"
"    ...>  v1 + v2\n"
"    ...> end)\n"
"    [b: 2, a: 4, d: 4, a: 5]\n"
"\n"
"    iex> Keyword.merge([a: 1, b: 2, a: 3], [a: 3, d: 4, a: 5], fn :a, v1, v2 ->\n"
"    ...>  v1 + v2\n"
"    ...> end)\n"
"    [b: 2, a: 4, d: 4, a: 8]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.fetch(keywords, key)
#: lib/keyword.ex:286 
msgid ""
"Fetches the value for a specific `key` and returns it in a tuple.\n"
"\n"
"If the `key` does not exist, returns `:error`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.fetch([a: 1], :a)\n"
"    {:ok, 1}\n"
"    iex> Keyword.fetch([a: 1], :b)\n"
"    :error\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.split(keywords, keys)
#: lib/keyword.ex:695 
msgid ""
"Takes all entries corresponding to the given keys and extracts them into a\n"
"separate keyword list.\n"
"\n"
"Returns a tuple with the new list and the old list with removed keys.\n"
"\n"
"Keys for which there are no entires in the keyword list are ignored.\n"
"\n"
"Entries with duplicated keys end up in the same keyword list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.split([a: 1, b: 2, c: 3], [:a, :c, :e])\n"
"    {[a: 1, c: 3], [b: 2]}\n"
"    iex> Keyword.split([a: 1, b: 2, c: 3, a: 4], [:a, :c, :e])\n"
"    {[a: 1, c: 3, a: 4], [b: 2]}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.fetch!(keywords, key)
#: lib/keyword.ex:307 
msgid ""
"Fetches the value for specific `key`.\n"
"\n"
"If `key` does not exist, a `KeyError` is raised.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.fetch!([a: 1], :a)\n"
"    1\n"
"    iex> Keyword.fetch!([a: 1], :b)\n"
"    ** (KeyError) key :b not found in: [a: 1]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.new(pairs, transform)
#: lib/keyword.ex:98 
msgid ""
"Creates a keyword from an enumerable via the transformation function.\n"
"\n"
"Duplicated entries are removed, the latest one prevails.\n"
"Unlike `Enum.into(enumerable, [], fun)`,\n"
"`Keyword.new(enumerable, fun)` guarantees the keys are unique.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.new([:a, :b], fn (x) -> {x, x} end)\n"
"    [a: :a, b: :b]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.equal?(left, right)
#: lib/keyword.ex:518 
msgid ""
"Checks if two keywords are equal.\n"
"\n"
"Two keywords are considered to be equal if they contain\n"
"the same keys and those keys contain the same values.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.equal?([a: 1, b: 2], [b: 2, a: 1])\n"
"    true\n"
"    iex> Keyword.equal?([a: 1, b: 2], [b: 1, a: 2])\n"
"    false\n"
"    iex> Keyword.equal?([a: 1, b: 2, a: 3], [b: 2, a: 3, a: 1])\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.get_lazy(keywords, key, fun)
#: lib/keyword.ex:157 
msgid ""
"Gets the value for a specific `key`.\n"
"\n"
"If `key` does not exist, lazily evaluates `fun` and returns its result.\n"
"\n"
"This is useful if the default value is very expensive to calculate or\n"
"generally difficult to setup and teardown again.\n"
"\n"
"If duplicated entries exist, the first one is returned.\n"
"Use `get_values/2` to retrieve all entries.\n"
"\n"
"## Examples\n"
"\n"
"    iex> keyword = [a: 1]\n"
"    iex> fun = fn ->\n"
"    ...>   # some expensive operation here\n"
"    ...>   13\n"
"    ...> end\n"
"    iex> Keyword.get_lazy(keyword, :a, fun)\n"
"    1\n"
"    iex> Keyword.get_lazy(keyword, :b, fun)\n"
"    13\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.values(keywords)
#: lib/keyword.ex:368 
msgid ""
"Returns all values from the keyword list.\n"
"\n"
"Values from duplicated keys will be kept in the final list of values.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.values([a: 1, b: 2])\n"
"    [1, 2]\n"
"    iex> Keyword.values([a: 1, b: 2, a: 3])\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.get_values(keywords, key)
#: lib/keyword.ex:328 
msgid ""
"Gets all values for a specific `key`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.get_values([], :a)\n"
"    []\n"
"    iex> Keyword.get_values([a: 1], :a)\n"
"    [1]\n"
"    iex> Keyword.get_values([a: 1, a: 2], :a)\n"
"    [1, 2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.delete(keywords, key)
#: lib/keyword.ex:408 
msgid ""
"Deletes the entries in the keyword list for a specific `key`.\n"
"\n"
"If the `key` does not exist, returns the keyword list unchanged.\n"
"Use `delete_first/2` to delete just the first entry in case of\n"
"duplicated keys.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.delete([a: 1, b: 2], :a)\n"
"    [b: 2]\n"
"    iex> Keyword.delete([a: 1, b: 2, a: 3], :a)\n"
"    [b: 2]\n"
"    iex> Keyword.delete([b: 2], :a)\n"
"    [b: 2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.take(keywords, keys)
#: lib/keyword.ex:726 
msgid ""
"Takes all entries corresponding to the given keys and returns them in a new\n"
"keyword list.\n"
"\n"
"Duplicated keys are preserved in the new keyword list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.take([a: 1, b: 2, c: 3], [:a, :c, :e])\n"
"    [a: 1, c: 3]\n"
"    iex> Keyword.take([a: 1, b: 2, c: 3, a: 5], [:a, :c, :e])\n"
"    [a: 1, c: 3, a: 5]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.has_key?(keywords, key)
#: lib/keyword.ex:610 
msgid ""
"Returns whether a given `key` exists in the given `keywords`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.has_key?([a: 1], :a)\n"
"    true\n"
"    iex> Keyword.has_key?([a: 1], :b)\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.drop(keywords, keys)
#: lib/keyword.ex:744 
msgid ""
"Drops the given keys from the keyword list.\n"
"\n"
"Duplicated keys are preserved in the new keyword list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.drop([a: 1, b: 2, c: 3], [:b, :d])\n"
"    [a: 1, c: 3]\n"
"    iex> Keyword.drop([a: 1, b: 2, b: 3, c: 3, a: 5], [:b, :d])\n"
"    [a: 1, c: 3, a: 5]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.delete_first(keywords, key)
#: lib/keyword.ex:430 
msgid ""
"Deletes the first entry in the keyword list for a specific `key`.\n"
"\n"
"If the `key` does not exist, returns the keyword list unchanged.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.delete_first([a: 1, b: 2, a: 3], :a)\n"
"    [b: 2, a: 3]\n"
"    iex> Keyword.delete_first([b: 2], :a)\n"
"    [b: 2]\n"
"\n"
msgstr ""
