#. TRANSLATORS: def Keyword.update!(keywords, key, fun)
#: lib/keyword.ex:422 
msgid ""
"Updates the `key` with the given function. \n"
"\n"
"If the `key` does not exist, raises `KeyError`.\n"
"\n"
"If there are duplicated keys, they are all removed and only the first one\n"
"is updated.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.update!([a: 1], :a, &(&1 * 2))\n"
"    [a: 2]\n"
"\n"
"    iex> Keyword.update!([a: 1], :b, &(&1 * 2))\n"
"    ** (KeyError) key :b not found in: [a: 1]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.update(list1, key, initial, fun)
#: lib/keyword.ex:456 
msgid ""
"Updates the `key` with the given function. \n"
"\n"
"If the `key` does not exist, inserts the given `initial` value.\n"
"\n"
"If there are duplicated keys, they are all removed and only the first one\n"
"is updated.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.update([a: 1], :a, 13, &(&1 * 2))\n"
"    [a: 2]\n"
"\n"
"    iex> Keyword.update([a: 1], :b, 11, &(&1 * 2))\n"
"    [a: 1, b: 11]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.take(keywords, keys)
#: lib/keyword.ex:519 
msgid ""
"Takes all entries corresponding to the given keys and returns them in a new\n"
"keyword list.\n"
"\n"
"Duplicated keys are preserved in the new keyword list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> d = [a: 1, b: 2, c: 3, d: 4]\n"
"    iex> Keyword.take(d, [:a, :c, :e])\n"
"    [a: 1, c: 3]\n"
"\n"
"    iex> d = [a: 1, b: 2, c: 3, d: 4, a: 5]\n"
"    iex> Keyword.take(d, [:a, :c, :e])\n"
"    [a: 1, c: 3, a: 5]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.split(keywords, keys)
#: lib/keyword.ex:489 
msgid ""
"Takes all entries corresponding to the given keys and extracts them into a\n"
"separate keyword list. \n"
"\n"
"Returns a tuple with the new list and the old list with removed keys.\n"
"\n"
"Keys for which there are no entires in the keyword list are ignored.\n"
"\n"
"Entries with duplicated keys end up in the same keyword list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> d = [a: 1, b: 2, c: 3, d: 4]\n"
"    iex> Keyword.split(d, [:a, :c, :e])\n"
"    {[a: 1, c: 3], [b: 2, d: 4]}\n"
"\n"
"    iex> d = [a: 1, b: 2, c: 3, d: 4, a: 5]\n"
"    iex> Keyword.split(d, [:a, :c, :e])\n"
"    {[a: 1, c: 3, a: 5], [b: 2, d: 4]}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.drop(keywords, keys)
#: lib/keyword.ex:539 
msgid ""
"Drops the given keys from the keyword list.\n"
"\n"
"Duplicated keys are preserved in the new keyword list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> d = [a: 1, b: 2, c: 3, d: 4]\n"
"    iex> Keyword.drop(d, [:b, :d])\n"
"    [a: 1, c: 3]\n"
"\n"
"    iex> d = [a: 1, b: 2, b: 3, c: 3, d: 4, a: 5]\n"
"    iex> Keyword.drop(d, [:b, :d])\n"
"    [a: 1, c: 3, a: 5]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.put(keywords, key, value)
#: lib/keyword.ex:302 
msgid ""
"Puts the given `value` under `key`.\n"
"\n"
"If a previous value is already stored, all entries are\n"
"removed and the value is overridden.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.put([a: 1, b: 2], :a, 3)\n"
"    [a: 3, b: 2]\n"
"\n"
"    iex> Keyword.put([a: 1, b: 2, a: 4], :a, 3)\n"
"    [a: 3, b: 2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.put_new(keywords, key, value)
#: lib/keyword.ex:320 
msgid ""
"Puts the given `value` under `key` unless the entry `key`\n"
"already exists.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.put_new([a: 1], :b, 2)\n"
"    [b: 2, a: 1]\n"
"\n"
"    iex> Keyword.put_new([a: 1, b: 2], :a, 3)\n"
"    [a: 1, b: 2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.merge(d1, d2)
#: lib/keyword.ex:356 
msgid ""
"Merges two keyword lists into one. \n"
"\n"
"If they have duplicated keys, the one given in the second argument wins.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4]) |> Enum.sort\n"
"    [a: 3, b: 2, d: 4]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.merge(d1, d2, fun)
#: lib/keyword.ex:375 
msgid ""
"Merges two keyword lists into one. \n"
"\n"
"If they have duplicated keys, the given function is invoked to solve conflicts.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4], fn (_k, v1, v2) ->\n"
"    ...>  v1 + v2\n"
"    ...> end)\n"
"    [a: 4, b: 2, d: 4]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.new()
#: lib/keyword.ex:51 
msgid ""
"Returns an empty keyword list, i.e. an empty list.\n"
msgstr ""
#. TRANSLATORS: def Keyword.values(keywords)
#: lib/keyword.ex:217 
msgid ""
"Returns all values from the keyword list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.values([a: 1, b: 2])\n"
"    [1,2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.keys(keywords)
#: lib/keyword.ex:203 
msgid ""
"Returns all keys from the keyword list. \n"
"\n"
"Duplicated keys appear duplicated in the final list of keys.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.keys([a: 1, b: 2])\n"
"    [:a,:b]\n"
"\n"
"    iex> Keyword.keys([a: 1, b: 2, a: 3])\n"
"    [:a,:b,:a]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.get_values(keywords, key)
#: lib/keyword.ex:179 
msgid ""
"Gets all values for a specific `key`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.get_values([a: 1, a: 2], :a)\n"
"    [1,2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.fetch!(keywords, key)
#: lib/keyword.ex:162 
msgid ""
"Fetches the value for specific `key`. \n"
"\n"
"If `key` does not exist, a `KeyError` is raised.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.fetch!([a: 1], :a)\n"
"    1\n"
"\n"
"    iex> Keyword.fetch!([a: 1], :b)\n"
"    ** (KeyError) key :b not found in: [a: 1]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.fetch(keywords, key)
#: lib/keyword.ex:140 
msgid ""
"Fetches the value for a specific `key` and returns it in a tuple.\n"
"\n"
"If the `key` does not exist, returns `:error`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.fetch([a: 1], :a)\n"
"    {:ok, 1}\n"
"\n"
"    iex> Keyword.fetch([a: 1], :b)\n"
"    :error\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.delete_first(keywords, key)
#: lib/keyword.ex:282 
msgid ""
"Deletes the first entry in the keyword list for a specific `key`.\n"
"\n"
"If the `key` does not exist, returns the keyword list unchanged.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.delete_first([a: 1, b: 2, a: 3], :a)\n"
"    [b: 2, a: 3]\n"
"\n"
"    iex> Keyword.delete_first([b: 2], :a)\n"
"    [b: 2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.delete(keywords, key)
#: lib/keyword.ex:263 
msgid ""
"Deletes the entries in the keyword list for a specific `key`.\n"
"\n"
"If the `key` does not exist, returns the keyword list unchanged.\n"
"Use `delete_first/2` to delete just the first entry in case of\n"
"duplicated keys.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.delete([a: 1, b: 2], :a)\n"
"    [b: 2]\n"
"\n"
"    iex> Keyword.delete([a: 1, b: 2, a: 3], :a)\n"
"    [b: 2]\n"
"\n"
"    iex> Keyword.delete([b: 2], :a)\n"
"    [b: 2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.delete(keywords, key, value)
#: lib/keyword.ex:239 
msgid ""
"Deletes the entries in the keyword list for a `key` with `value`.\n"
"\n"
"If no `key` with `value` exists, returns the keyword list unchanged.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.delete([a: 1, b: 2], :a, 1)\n"
"    [b: 2]\n"
"\n"
"    iex> Keyword.delete([a: 1, b: 2, a: 3], :a, 3)\n"
"    [a: 1, b: 2]\n"
"\n"
"    iex> Keyword.delete([b: 2], :a, 5)\n"
"    [b: 2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.get(keywords, key, default \\ nil)
#: lib/keyword.ex:118 
msgid ""
"Gets the value for a specific `key`.\n"
"\n"
"If `key` does not exist, return the default value (`nil` if no default value).\n"
"\n"
"If duplicated entries exist, the first one is returned.\n"
"Use `get_values/2` to retrieve all entries.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.get([a: 1], :a)\n"
"    1\n"
"\n"
"    iex> Keyword.get([a: 1], :b)\n"
"    nil\n"
"\n"
"    iex> Keyword.get([a: 1], :b, 3)\n"
"    3\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.new(pairs)
#: lib/keyword.ex:69 
msgid ""
"Creates a keyword from an enumerable.\n"
"\n"
"Duplicated entries are removed, the latest one prevails.\n"
"Unlike `Enum.into(enumerable, [])`,\n"
"`Keyword.new(enumerable)` guarantees the keys are unique.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.new([{:b, 1}, {:a, 2}])\n"
"    [a: 2, b: 1]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.new(pairs, transform)
#: lib/keyword.ex:89 
msgid ""
"Creates a keyword from an enumerable via the transformation function.\n"
"\n"
"Duplicated entries are removed, the latest one prevails.\n"
"Unlike `Enum.into(enumerable, [], fun)`,\n"
"`Keyword.new(enumerable, fun)` guarantees the keys are unique.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.new([:a, :b], fn (x) -> {x, x} end) |> Enum.sort\n"
"    [a: :a, b: :b]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.equal?(left, right)
#: lib/keyword.ex:340 
msgid ""
"Checks if two keywords are equal. \n"
"\n"
"Two keywords are considered to be equal if they contain\n"
"the same keys and those keys contain the same values.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.equal?([a: 1, b: 2], [b: 2, a: 1])\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.keyword?(arg1)
#: lib/keyword.ex:40 
msgid ""
"Checks if the given argument is a keyword list or not.\n"
msgstr ""
#. TRANSLATORS: def Keyword.has_key?(keywords, key)
#: lib/keyword.ex:400 
msgid ""
"Returns whether a given `key` exists in the given `keywords`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.has_key?([a: 1], :a)\n"
"    true\n"
"\n"
"    iex> Keyword.has_key?([a: 1], :b)\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.pop_first(keywords, key, default \\ nil)
#: lib/keyword.ex:597 
msgid ""
"Returns the first value associated with `key` in the keyword\n"
"list as well as the keyword list without that particular occurrence\n"
"of `key`.\n"
"\n"
"Duplicated keys are not removed.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.pop_first [a: 1], :a\n"
"    {1,[]}\n"
"\n"
"    iex> Keyword.pop_first [a: 1], :b\n"
"    {nil,[a: 1]}\n"
"\n"
"    iex> Keyword.pop_first [a: 1], :b, 3\n"
"    {3,[a: 1]}\n"
"\n"
"    iex> Keyword.pop_first [a: 1], :b, 3\n"
"    {3,[a: 1]}\n"
"\n"
"    iex> Keyword.pop_first [a: 1, a: 2], :a\n"
"    {1,[a: 2]}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.pop(keywords, key, default \\ nil)
#: lib/keyword.ex:568 
msgid ""
"Returns the first value associated with `key` in the keyword\n"
"list as well as the keyword list without `key`.\n"
"\n"
"All duplicated keys are removed. See `pop_first/3` for\n"
"removing only the first entry.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.pop [a: 1], :a\n"
"    {1,[]}\n"
"\n"
"    iex> Keyword.pop [a: 1], :b\n"
"    {nil,[a: 1]}\n"
"\n"
"    iex> Keyword.pop [a: 1], :b, 3\n"
"    {3,[a: 1]}\n"
"\n"
"    iex> Keyword.pop [a: 1], :b, 3\n"
"    {3,[a: 1]}\n"
"\n"
"    iex> Keyword.pop [a: 1, a: 2], :a\n"
"    {1,[]}\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.Keyword Summary
#: lib/keyword.ex:1 
msgid ""
"A keyword is a list of tuples where the first element\n"
"of the tuple is an atom and the second element can be\n"
"any value.\n"
"\n"
"A keyword may have duplicated keys so it is not strictly\n"
"a dictionary. However most of the functions in this module\n"
"behave exactly as a dictionary and mimic the API defined\n"
"by the `Dict` behaviour.\n"
"\n"
"For example, `Keyword.get/3` will get the first entry matching\n"
"the given key, regardless if duplicated entries exist.\n"
"Similarly, `Keyword.put/3` and `Keyword.delete/3` ensure all\n"
"duplicated entries for a given key are removed when invoked.\n"
"\n"
"A handful of functions exist to handle duplicated keys, in\n"
"particular, `Enum.into/2` allows creating new keywords without\n"
"removing duplicated keys, `get_values/2` returns all values for\n"
"a given key and `delete_first/2` deletes just one of the existing\n"
"entries.\n"
"\n"
"Since a keyword list is simply a list, all the operations defined\n"
"in `Enum` and `List` can be applied.\n"
msgstr ""
