#. TRANSLATORS: def Keyword.has_key?(keywords, key)
#: lib/keyword.ex:486 
msgid ""
"Returns whether a given `key` exists in the given `keywords`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.has_key?([a: 1], :a)\n"
"    true\n"
"\n"
"    iex> Keyword.has_key?([a: 1], :b)\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.pop_first(keywords, key, default \\ nil)
#: lib/keyword.ex:710 
msgid ""
"Returns the first value associated with `key` in the keyword\n"
"list as well as the keyword list without that particular occurrence\n"
"of `key`.\n"
"\n"
"Duplicated keys are not removed.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.pop_first [a: 1], :a\n"
"    {1, []}\n"
"\n"
"    iex> Keyword.pop_first [a: 1], :b\n"
"    {nil, [a: 1]}\n"
"\n"
"    iex> Keyword.pop_first [a: 1], :b, 3\n"
"    {3, [a: 1]}\n"
"\n"
"    iex> Keyword.pop_first [a: 1, a: 2], :a\n"
"    {1, [a: 2]}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.pop_lazy(keywords, key, fun)
#: lib/keyword.ex:676 
msgid ""
"Returns the first value associated with `key` in the keyword\n"
"list as well as the keyword list without `key`.\n"
"\n"
"This is useful if the default value is very expensive to calculate or\n"
"generally difficult to set-up and tear-down again.\n"
"\n"
"All duplicated keys are removed. See `pop_first/3` for\n"
"removing only the first entry.\n"
"\n"
"## Examples\n"
"\n"
"    iex> keyword = [a: 1]\n"
"    iex> fun = fn ->\n"
"    ...>   # some expensive operation here\n"
"    ...>   :result\n"
"    ...> end\n"
"    iex> Keyword.pop_lazy(keyword, :a, fun)\n"
"    {1, []}\n"
"    iex> Keyword.pop_lazy(keyword, :b, fun)\n"
"    {:result, [a: 1]}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.pop(keywords, key, default \\ nil)
#: lib/keyword.ex:644 
msgid ""
"Returns the first value associated with `key` in the keyword\n"
"list as well as the keyword list without `key`.\n"
"\n"
"All duplicated keys are removed. See `pop_first/3` for\n"
"removing only the first entry.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.pop [a: 1], :a\n"
"    {1, []}\n"
"\n"
"    iex> Keyword.pop [a: 1], :b\n"
"    {nil, [a: 1]}\n"
"\n"
"    iex> Keyword.pop [a: 1], :b, 3\n"
"    {3, [a: 1]}\n"
"\n"
"    iex> Keyword.pop [a: 1, a: 2], :a\n"
"    {1, []}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.update!(keywords, key, fun)
#: lib/keyword.ex:503 
msgid ""
"Updates the `key` with the given function.\n"
"\n"
"If the `key` does not exist, raises `KeyError`.\n"
"\n"
"If there are duplicated keys, they are all removed and only the first one\n"
"is updated.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.update!([a: 1], :a, &(&1 * 2))\n"
"    [a: 2]\n"
"\n"
"    iex> Keyword.update!([a: 1], :b, &(&1 * 2))\n"
"    ** (KeyError) key :b not found in: [a: 1]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.update(keywords, key, initial, fun)
#: lib/keyword.ex:537 
msgid ""
"Updates the `key` in `keywords` with the given function.\n"
"\n"
"If the `key` does not exist, inserts the given `initial` value.\n"
"\n"
"If there are duplicated keys, they are all removed and only the first one\n"
"is updated.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.update([a: 1], :a, 13, &(&1 * 2))\n"
"    [a: 2]\n"
"\n"
"    iex> Keyword.update([a: 1], :b, 11, &(&1 * 2))\n"
"    [a: 1, b: 11]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.take(keywords, keys)
#: lib/keyword.ex:603 
msgid ""
"Takes all entries corresponding to the given keys and returns them in a new\n"
"keyword list.\n"
"\n"
"Duplicated keys are preserved in the new keyword list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> d = [a: 1, b: 2, c: 3, d: 4]\n"
"    iex> Keyword.take(d, [:a, :c, :e])\n"
"    [a: 1, c: 3]\n"
"\n"
"    iex> d = [a: 1, b: 2, c: 3, d: 4, a: 5]\n"
"    iex> Keyword.take(d, [:a, :c, :e])\n"
"    [a: 1, c: 3, a: 5]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.split(keywords, keys)
#: lib/keyword.ex:569 
msgid ""
"Takes all entries corresponding to the given keys and extracts them into a\n"
"separate keyword list.\n"
"\n"
"Returns a tuple with the new list and the old list with removed keys.\n"
"\n"
"Keys for which there are no entires in the keyword list are ignored.\n"
"\n"
"Entries with duplicated keys end up in the same keyword list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> d = [a: 1, b: 2, c: 3, d: 4]\n"
"    iex> Keyword.split(d, [:a, :c, :e])\n"
"    {[a: 1, c: 3], [b: 2, d: 4]}\n"
"\n"
"    iex> d = [a: 1, b: 2, c: 3, d: 4, a: 5]\n"
"    iex> Keyword.split(d, [:a, :c, :e])\n"
"    {[a: 1, c: 3, a: 5], [b: 2, d: 4]}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.new()
#: lib/keyword.ex:50 
msgid ""
"Returns an empty keyword list, i.e. an empty list.\n"
msgstr ""
#. TRANSLATORS: def Keyword.values(keywords)
#: lib/keyword.ex:277 
msgid ""
"Returns all values from the keyword list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.values([a: 1, b: 2])\n"
"    [1, 2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.keys(keywords)
#: lib/keyword.ex:258 
msgid ""
"Returns all keys from the keyword list.\n"
"\n"
"Duplicated keys appear duplicated in the final list of keys.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.keys([a: 1, b: 2])\n"
"    [:a, :b]\n"
"\n"
"    iex> Keyword.keys([a: 1, b: 2, a: 3])\n"
"    [:a, :b, :a]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.keyword?(term)
#: lib/keyword.ex:38 
msgid ""
"Returns `true` if `term` is a keyword list; otherwise returns `false`.\n"
msgstr ""
#. TRANSLATORS: def Keyword.put(keywords, key, value)
#: lib/keyword.ex:356 
msgid ""
"Puts the given `value` under `key`.\n"
"\n"
"If a previous value is already stored, all entries are\n"
"removed and the value is overridden.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.put([a: 1, b: 2], :a, 3)\n"
"    [a: 3, b: 2]\n"
"\n"
"    iex> Keyword.put([a: 1, b: 2, a: 4], :a, 3)\n"
"    [a: 3, b: 2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.put_new(keywords, key, value)
#: lib/keyword.ex:405 
msgid ""
"Puts the given `value` under `key` unless the entry `key`\n"
"already exists.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.put_new([a: 1], :b, 2)\n"
"    [b: 2, a: 1]\n"
"\n"
"    iex> Keyword.put_new([a: 1, b: 2], :a, 3)\n"
"    [a: 1, b: 2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.merge(keywords1, keywords2)
#: lib/keyword.ex:443 
msgid ""
"Merges two keyword lists into one.\n"
"\n"
"If they have duplicated keys, the one given in the second argument wins.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4])\n"
"    [a: 3, d: 4, b: 2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.merge(keywords1, keywords2, fun)
#: lib/keyword.ex:460 
msgid ""
"Merges two keyword lists into one.\n"
"\n"
"If they have duplicated keys, the given function is invoked to solve conflicts.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4], fn (_k, v1, v2) ->\n"
"    ...>  v1 + v2\n"
"    ...> end)\n"
"    [a: 4, b: 2, d: 4]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.get_and_update(keywords, key, fun)
#: lib/keyword.ex:158 
msgid ""
"Gets the value from `key` and updates it, all in one pass.\n"
"\n"
"This `fun` argument receives the value of `key` (or `nil` if `key`\n"
"is not present) and must return a two-elements tuple: the \"get\" value (the\n"
"retrieved value, which can be operated on before being returned) and the new\n"
"value to be stored under `key`.\n"
"\n"
"The returned value is a tuple with the \"get\" value returned by `fun` and a new\n"
"keyword list with the updated value under `key`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.get_and_update [a: 1], :a, fn(current_value) ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end\n"
"    {1, [a: \"new value!\"]}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.get(keywords, key, default \\ nil)
#: lib/keyword.ex:96 
msgid ""
"Gets the value for a specific `key`.\n"
"\n"
"If `key` does not exist, return the default value (`nil` if no default value).\n"
"\n"
"If duplicated entries exist, the first one is returned.\n"
"Use `get_values/2` to retrieve all entries.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.get([a: 1], :a)\n"
"    1\n"
"\n"
"    iex> Keyword.get([a: 1], :b)\n"
"    nil\n"
"\n"
"    iex> Keyword.get([a: 1], :b, 3)\n"
"    3\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.get_lazy(keywords, key, fun)
#: lib/keyword.ex:125 
msgid ""
"Gets the value for a specific `key`.\n"
"\n"
"If `key` does not exist, lazily evaluates `fun` and returns its result.\n"
"\n"
"This is useful if the default value is very expensive to calculate or\n"
"generally difficult to set-up and tear-down again.\n"
"\n"
"If duplicated entries exist, the first one is returned.\n"
"Use `get_values/2` to retrieve all entries.\n"
"\n"
"## Examples\n"
"\n"
"    iex> keyword = [a: 1]\n"
"    iex> fun = fn ->\n"
"    ...>   # some expensive operation here\n"
"    ...>   :result\n"
"    ...> end\n"
"    iex> Keyword.get_lazy(keyword, :a, fun)\n"
"    1\n"
"    iex> Keyword.get_lazy(keyword, :b, fun)\n"
"    :result\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.get_values(keywords, key)
#: lib/keyword.ex:239 
msgid ""
"Gets all values for a specific `key`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.get_values([a: 1, a: 2], :a)\n"
"    [1, 2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.fetch!(keywords, key)
#: lib/keyword.ex:217 
msgid ""
"Fetches the value for specific `key`.\n"
"\n"
"If `key` does not exist, a `KeyError` is raised.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.fetch!([a: 1], :a)\n"
"    1\n"
"\n"
"    iex> Keyword.fetch!([a: 1], :b)\n"
"    ** (KeyError) key :b not found in: [a: 1]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.fetch(keywords, key)
#: lib/keyword.ex:195 
msgid ""
"Fetches the value for a specific `key` and returns it in a tuple.\n"
"\n"
"If the `key` does not exist, returns `:error`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.fetch([a: 1], :a)\n"
"    {:ok, 1}\n"
"\n"
"    iex> Keyword.fetch([a: 1], :b)\n"
"    :error\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.put_new_lazy(keywords, key, fun)
#: lib/keyword.ex:376 
msgid ""
"Evaluates `fun` and puts the result under `key`\n"
"in keyword list unless `key` is already present.\n"
"\n"
"This is useful if the value is very expensive to calculate or generally\n"
"difficult to set-up and tear-down again.\n"
"\n"
"## Examples\n"
"\n"
"    iex> keyword = [a: 1]\n"
"    iex> fun = fn ->\n"
"    ...>   # some expensive operation here\n"
"    ...>   3\n"
"    ...> end\n"
"    iex> Keyword.put_new_lazy(keyword, :a, fun)\n"
"    [a: 1]\n"
"    iex> Keyword.put_new_lazy(keyword, :b, fun)\n"
"    [b: 3, a: 1]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.drop(keywords, keys)
#: lib/keyword.ex:624 
msgid ""
"Drops the given keys from the keyword list.\n"
"\n"
"Duplicated keys are preserved in the new keyword list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> d = [a: 1, b: 2, c: 3, d: 4]\n"
"    iex> Keyword.drop(d, [:b, :d])\n"
"    [a: 1, c: 3]\n"
"\n"
"    iex> d = [a: 1, b: 2, b: 3, c: 3, d: 4, a: 5]\n"
"    iex> Keyword.drop(d, [:b, :d])\n"
"    [a: 1, c: 3, a: 5]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.delete_first(keywords, key)
#: lib/keyword.ex:337 
msgid ""
"Deletes the first entry in the keyword list for a specific `key`.\n"
"\n"
"If the `key` does not exist, returns the keyword list unchanged.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.delete_first([a: 1, b: 2, a: 3], :a)\n"
"    [b: 2, a: 3]\n"
"\n"
"    iex> Keyword.delete_first([b: 2], :a)\n"
"    [b: 2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.delete(keywords, key)
#: lib/keyword.ex:313 
msgid ""
"Deletes the entries in the keyword list for a specific `key`.\n"
"\n"
"If the `key` does not exist, returns the keyword list unchanged.\n"
"Use `delete_first/2` to delete just the first entry in case of\n"
"duplicated keys.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.delete([a: 1, b: 2], :a)\n"
"    [b: 2]\n"
"\n"
"    iex> Keyword.delete([a: 1, b: 2, a: 3], :a)\n"
"    [b: 2]\n"
"\n"
"    iex> Keyword.delete([b: 2], :a)\n"
"    [b: 2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.delete(keywords, key, value)
#: lib/keyword.ex:291 
msgid ""
"Deletes the entries in the keyword list for a `key` with `value`.\n"
"\n"
"If no `key` with `value` exists, returns the keyword list unchanged.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.delete([a: 1, b: 2], :a, 1)\n"
"    [b: 2]\n"
"\n"
"    iex> Keyword.delete([a: 1, b: 2, a: 3], :a, 3)\n"
"    [a: 1, b: 2]\n"
"\n"
"    iex> Keyword.delete([b: 2], :a, 5)\n"
"    [b: 2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.new(pairs)
#: lib/keyword.ex:56 
msgid ""
"Creates a keyword from an enumerable.\n"
"\n"
"Duplicated entries are removed, the latest one prevails.\n"
"Unlike `Enum.into(enumerable, [])`,\n"
"`Keyword.new(enumerable)` guarantees the keys are unique.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.new([{:b, 1}, {:a, 2}])\n"
"    [a: 2, b: 1]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.new(pairs, transform)
#: lib/keyword.ex:74 
msgid ""
"Creates a keyword from an enumerable via the transformation function.\n"
"\n"
"Duplicated entries are removed, the latest one prevails.\n"
"Unlike `Enum.into(enumerable, [], fun)`,\n"
"`Keyword.new(enumerable, fun)` guarantees the keys are unique.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.new([:a, :b], fn (x) -> {x, x} end)\n"
"    [b: :b, a: :a]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.equal?(left, right)
#: lib/keyword.ex:426 
msgid ""
"Checks if two keywords are equal.\n"
"\n"
"Two keywords are considered to be equal if they contain\n"
"the same keys and those keys contain the same values.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.equal?([a: 1, b: 2], [b: 2, a: 1])\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.Keyword Summary
#: lib/keyword.ex:2 
msgid ""
"A keyword is a list of tuples where the first element\n"
"of the tuple is an atom and the second element can be\n"
"any value.\n"
"\n"
"A keyword may have duplicated keys so it is not strictly\n"
"a dictionary. However most of the functions in this module\n"
"behave exactly as a dictionary and mimic the API defined\n"
"by the `Dict` behaviour.\n"
"\n"
"For example, `Keyword.get/3` will get the first entry matching\n"
"the given key, regardless if duplicated entries exist.\n"
"Similarly, `Keyword.put/3` and `Keyword.delete/3` ensure all\n"
"duplicated entries for a given key are removed when invoked.\n"
"\n"
"A handful of functions exist to handle duplicated keys, in\n"
"particular, `Enum.into/2` allows creating new keywords without\n"
"removing duplicated keys, `get_values/2` returns all values for\n"
"a given key and `delete_first/2` deletes just one of the existing\n"
"entries.\n"
"\n"
"The functions in Keyword do not guarantee any property when\n"
"it comes to ordering. However, since a keyword list is simply a\n"
"list, all the operations defined in `Enum` and `List` can be\n"
"applied too, specially when ordering is required.\n"
msgstr ""
