msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2016-02-28 16:15+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: def Module.defines?(module, tuple, kind)
#: lib/module.ex:748
msgid ""
"Checks if the module defines a function or macro of the\n"
"given `kind`.\n"
"\n"
"`kind` can be any of `:def`, `:defp`, `:defmacro` or `:defmacrop`.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Example do\n"
"      Module.defines? __MODULE__, {:version, 0}, :defp #=> false\n"
"      def version, do: 1\n"
"      Module.defines? __MODULE__, {:version, 0}, :defp #=> false\n"
"    end\n"
"\n"
msgstr ""
"与えられた`kind`の関数かマクロがmoduleで定義されているかチェックします。\n"
"\n"
"`kind`は`:def`、`:defp`、`:defmacro`、`:defmacrop`の何れかです。\n"
"\n"
"## 例\n"
"\n"
"    defmodule Example do\n"
"      Module.defines? __MODULE__, {:version, 0}, :defp #=> false\n"
"      def version, do: 1\n"
"      Module.defines? __MODULE__, {:version, 0}, :defp #=> false\n"
"    end\n"
"\n"

#. TRANSLATORS: def Module.put_attribute(module, key, value)
#: lib/module.ex:850
msgid ""
"Puts an Erlang attribute to the given module with the given\n"
"key and value.\n"
"\n"
"The semantics of putting the attribute depends\n"
"if the attribute was registered or not via `register_attribute/3`.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule MyModule do\n"
"      Module.put_attribute __MODULE__, :custom_threshold_for_lib, 10\n"
"    end\n"
"\n"
msgstr ""
"Erlangアトリビュートを与えられたモジュールに与えられたキーと値でプット\n"
"します。\n"
"\n"
"アトリビュートをプットするセマンティクスは、\n"
"`register_attribute/3`によってアトリビュートが登録されていたか否かに、\n"
"依存します。\n"
"\n"
"## 例\n"
"\n"
"    defmodule MyModule do\n"
"      Module.put_attribute __MODULE__, :custom_threshold_for_lib, 10\n"
"    end\n"
"\n"

#. TRANSLATORS: def Module.definitions_in(module, kind)
#: lib/module.ex:789
msgid ""
"Returns all functions defined in `module`, according\n"
"to its kind.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Example do\n"
"      def version, do: 1\n"
"      Module.definitions_in __MODULE__, :def  #=> [{:version, 0}]\n"
"      Module.definitions_in __MODULE__, :defp #=> []\n"
"    end\n"
"\n"
msgstr ""
"その種別(kind)によって、`module`で定義されている全ての関数を返します。\n"
"\n"
"## 例\n"
"\n"
"    defmodule Example do\n"
"      def version, do: 1\n"
"      Module.definitions_in __MODULE__, :def  #=> [{:version,0}]\n"
"      Module.definitions_in __MODULE__, :defp #=> []\n"
"    end\n"
"\n"

#. TRANSLATORS: def Module.eval_quoted(module, quoted, binding \\ [], opts \\ [])
#: lib/module.ex:404
msgid ""
"Evaluates the quoted contents in the given module's context.\n"
"\n"
"A list of environment options can also be given as argument.\n"
"See `Code.eval_string/3` for more information.\n"
"\n"
"Raises an error if the module was already compiled.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Foo do\n"
"      contents = quote do: (def sum(a, b), do: a + b)\n"
"      Module.eval_quoted __MODULE__, contents\n"
"    end\n"
"\n"
"    Foo.sum(1, 2) #=> 3\n"
"\n"
"For convenience, you can pass `__ENV__` as an argument and\n"
"all options will be automatically extracted from the environment:\n"
"\n"
"    defmodule Foo do\n"
"      contents = quote do: (def sum(a, b), do: a + b)\n"
"      Module.eval_quoted __MODULE__, contents, [], __ENV__\n"
"    end\n"
"\n"
"    Foo.sum(1, 2) #=> 3\n"
"\n"
msgstr ""
"与えられたモジュールのコンテキストで、quoteされたコンテンツを、評価します。\n"
"\n"
"環境のリストのオプションも引数として与えることができます。\n"
"詳細は、`Code.eval_string/3`を\n"
"参照してください。\n"
"\n"
"もしモジュールがすでにコンパイルされていたら、エラーを上げます。\n"
"\n"
"## 例\n"
"\n"
"    defmodule Foo do\n"
"      contents = quote do: (def sum(a, b), do: a + b)\n"
"      Module.eval_quoted __MODULE__, contents\n"
"    end\n"
"\n"
"    Foo.sum(1, 2) #=> 3\n"
"\n"
"便宜上、引数として`__ENV__`を渡すことができ、その環境から全てのオプショ\n"
"ンが自動的に抽出されます:\n"
"\n"
"    defmodule Foo do\n"
"      contents = quote do: (def sum(a, b), do: a + b)\n"
"      Module.eval_quoted __MODULE__, contents, [], __ENV__\n"
"    end\n"
"\n"
"    Foo.sum(1, 2) #=> 3\n"
"\n"

#. TRANSLATORS: def Module.safe_concat(left, right)
#: lib/module.ex:553
msgid ""
"Concatenates two aliases and returns a new alias only if the alias was\n"
"already referenced.\n"
"\n"
"If the alias was not referenced yet, fails with `ArgumentError`.\n"
"It handles char lists, binaries and atoms.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Module.safe_concat(Module, Unknown)\n"
"    ** (ArgumentError) argument error\n"
"\n"
"    iex> Module.safe_concat(List, Chars)\n"
"    List.Chars\n"
"\n"
msgstr ""
"二つのエイリアスを連結し、それが既に参照されているなら、新し\n"
"いエイリアスを返します。\n"
"\n"
"もしエイリアスがまだ参照されていなかったら、`ArgumentError`で\n"
"失敗します。文字のリスト、バイナリ、アトムを取り扱います。\n"
"\n"
"## 例\n"
"\n"
"    iex> Module.safe_concat(Unknown, Module)\n"
"    ** (ArgumentError) argument error\n"
"\n"
"    iex> Module.safe_concat(List, Chars)\n"
"    List.Chars\n"
"\n"

#. TRANSLATORS: Elixir.Module Summary
#: lib/module.ex:2
msgid ""
"Provides functions to deal with modules during compilation time.\n"
"\n"
"It allows a developer to dynamically add, delete and register\n"
"attributes, attach documentation and so forth.\n"
"\n"
"After a module is compiled, using many of the functions in\n"
"this module will raise errors, since it is out of their scope\n"
"to inspect runtime data. Most of the runtime data can be inspected\n"
"via the `__info__(attr)` function attached to each compiled module.\n"
"\n"
"## Module attributes\n"
"\n"
"Each module can be decorated with one or more attributes. The following "
"ones\n"
"are currently defined by Elixir:\n"
"\n"
"  * `@after_compile`\n"
"\n"
"    A hook that will be invoked right after the current module is compiled.\n"
"    Accepts a module or a tuple `{<module>, <function atom>}`.\n"
"    See the \"Compile callbacks\" section below.\n"
"\n"
"  * `@before_compile`\n"
"\n"
"    A hook that will be invoked before the module is compiled.\n"
"    Accepts a module or a tuple `{<module>, <function/macro atom>}`.\n"
"    See the \"Compile callbacks\" section below.\n"
"\n"
"  * `@behaviour` (notice the British spelling)\n"
"\n"
"    Behaviours can be referenced by modules to ensure they implement\n"
"    required specific function signatures defined by `@callback`.\n"
"\n"
"    For example, you can specify the URI.Parser behaviour as follows:\n"
"\n"
"        defmodule URI.Parser do\n"
"          @doc \"Parses the given URL\"\n"
"          @callback parse(uri_info :: URI.t) :: URI.t\n"
"\n"
"          @doc \"Defines a default port\"\n"
"          @callback default_port() :: integer\n"
"        end\n"
"\n"
"        And then a module may use it as:\n"
"\n"
"        defmodule URI.HTTP do\n"
"          @behaviour URI.Parser\n"
"          def default_port(), do: 80\n"
"          def parse(info), do: info\n"
"        end\n"
"\n"
"    If the behaviour changes or URI.HTTP does not implement one of the\n"
"    callbacks, a warning will be raised.\n"
"\n"
"    Specifies an OTP or user-defined behaviour.\n"
"\n"
"    ### Example\n"
"\n"
"        defmodule M do\n"
"          @behaviour gen_event\n"
"\n"
"          # ...\n"
"        end\n"
"\n"
"  * `@compile`\n"
"\n"
"    Defines options for module compilation. This is used to configure\n"
"    both Elixir and Erlang compilers, as any other compilation pass\n"
"    added by external tools.\n"
"\n"
"    Multiple uses of `@compile` will accumulate instead of overriding\n"
"    previous ones. See the \"Compile options\" section below.\n"
"\n"
"    ### Example\n"
"\n"
"        defmodule M do\n"
"          @compile {:inline, myfun: 1}\n"
"\n"
"          def myfun(arg) do\n"
"            to_string(arg)\n"
"          end\n"
"        end\n"
"\n"
"  * `@doc`\n"
"\n"
"    Provides documentation for the function or macro that follows the\n"
"    attribute.\n"
"\n"
"    Accepts a string (often a heredoc) or `false` where `@doc false` will\n"
"    make the function/macro invisible to the documentation extraction tools\n"
"    like ExDoc.\n"
"\n"
"    Can be invoked more than once.\n"
"\n"
"    ### Example\n"
"\n"
"        defmodule M do\n"
"          @doc \"Hello world\"\n"
"          def hello do\n"
"            \"world\"\n"
"          end\n"
"\n"
"          @doc \"\"\"\n"
"          Sums `a` to `b`.\n"
"          \"\"\"\n"
"          def sum(a, b) do\n"
"            a + b\n"
"          end\n"
"        end\n"
"\n"
"  * `@dialyzer`\n"
"\n"
"    Defines warnings to request or suppress when using a version of\n"
"    `:dialyzer` that supports module attributes.\n"
"\n"
"    Accepts an atom, a tuple, or a list of atoms and tuples.\n"
"\n"
"    For the list of supported warnings, see\n"
"    [`:dialyzer` module](http://www.erlang.org/doc/man/dialyzer.html).\n"
"\n"
"    Multiple uses of `@dialyzer` will accumulate instead of overriding\n"
"    previous ones.\n"
"\n"
"    ### Example\n"
"\n"
"        defmodule M do\n"
"          @dialyzer {:nowarn_function, myfun: 1}\n"
"\n"
"          def myfun(arg) do\n"
"            M.not_a_function(arg)\n"
"          end\n"
"        end\n"
"\n"
"  * `@external_resource`\n"
"\n"
"    Specifies an external resource to the current module.\n"
"\n"
"    Many times a module embeds information from an external file. This\n"
"    attribute allows the module to annotate which external resources\n"
"    have been used.\n"
"\n"
"    Tools like Mix may use this information to ensure the module is\n"
"    recompiled in case any of the external resources change.\n"
"\n"
"  * `@file`\n"
"\n"
"    Changes the filename used in stacktraces for the function or macro that\n"
"    follows the attribute.\n"
"\n"
"    Accepts a string. Can be used more than once.\n"
"\n"
"    ### Example\n"
"\n"
"        defmodule M do\n"
"          @doc \"Hello world\"\n"
"          @file \"hello.ex\"\n"
"          def hello do\n"
"            \"world\"\n"
"          end\n"
"        end\n"
"\n"
"  * `@moduledoc`\n"
"\n"
"    Provides documentation for the current module.\n"
"\n"
"    Accepts a string (which is often a heredoc) or `false` where\n"
"    `@moduledoc false` will make the module invisible to the\n"
"    documentation extraction tools like ExDoc.\n"
"\n"
"    ### Example\n"
"\n"
"        defmodule M do\n"
"          @moduledoc \"\"\"\n"
"          A very useful module\n"
"          \"\"\"\n"
"        end\n"
"\n"
"  * `@on_definition`\n"
"\n"
"    A hook that will be invoked when each function or macro in the current\n"
"    module is defined. Useful when annotating functions.\n"
"\n"
"    Accepts a module or a tuple `{<module>, <function atom>}`. See the\n"
"    \"Compile callbacks\" section below.\n"
"\n"
"  * `@on_load`\n"
"\n"
"    A hook that will be invoked whenever the module is loaded.\n"
"\n"
"    Accepts a function atom of a function in the current module. The "
"function\n"
"    must have arity 0 (no arguments) and has to return `:ok`, otherwise the\n"
"    loading of the module will be aborted.\n"
"\n"
"    ### Example\n"
"\n"
"        defmodule M do\n"
"          @on_load :load_check\n"
"\n"
"          def load_check do\n"
"            if some_condition() do\n"
"              :ok\n"
"            else\n"
"              nil\n"
"            end\n"
"          end\n"
"\n"
"          def some_condition do\n"
"            false\n"
"          end\n"
"        end\n"
"\n"
"  * `@vsn`\n"
"\n"
"    Specify the module version. Accepts any valid Elixir value.\n"
"\n"
"    ### Example\n"
"\n"
"        defmodule M do\n"
"          @vsn \"1.0\"\n"
"        end\n"
"\n"
"The following attributes are part of typespecs and are also reserved by\n"
"Elixir:\n"
"\n"
"  * `@type`          - defines a type to be used in `@spec`\n"
"  * `@typep`         - defines a private type to be used in `@spec`\n"
"  * `@opaque`        - defines an opaque type to be used in `@spec`\n"
"  * `@spec`          - provides a specification for a function\n"
"  * `@callback`      - provides a specification for a behaviour callback\n"
"  * `@macrocallback` - provides a specification for a macro behaviour "
"callback\n"
"\n"
"In addition to the built-in attributes outlined above, custom attributes "
"may\n"
"also be added. A custom attribute is any valid identifier prefixed with an\n"
"`@` and followed by a valid Elixir value:\n"
"\n"
"    defmodule M do\n"
"      @custom_attr [some: \"stuff\"]\n"
"    end\n"
"\n"
"For more advanced options available when defining custom attributes, see\n"
"`register_attribute/3`.\n"
"\n"
"## Compile callbacks\n"
"\n"
"There are three callbacks that are invoked when functions are defined,\n"
"as well as before and immediately after the module bytecode is generated.\n"
"\n"
"### `@after_compile`\n"
"\n"
"A hook that will be invoked right after the current module is compiled.\n"
"\n"
"Accepts a module or a tuple `{<module>, <function atom>}`. The function\n"
"must take two arguments: the module environment and its bytecode.\n"
"When just a module is provided, the function is assumed to be\n"
"`__after_compile__/2`.\n"
"\n"
"#### Example\n"
"\n"
"    defmodule M do\n"
"      @after_compile __MODULE__\n"
"\n"
"      def __after_compile__(env, _bytecode) do\n"
"        IO.inspect env\n"
"      end\n"
"    end\n"
"\n"
"### `@before_compile`\n"
"\n"
"A hook that will be invoked before the module is compiled.\n"
"\n"
"Accepts a module or a tuple `{<module>, <function/macro atom>}`. The\n"
"function/macro must take one argument: the module environment. If it's a\n"
"macro, its returned value will be injected at the end of the module "
"definition\n"
"before the compilation starts.\n"
"\n"
"When just a module is provided, the function/macro is assumed to be\n"
"`__before_compile__/1`.\n"
"\n"
"Note: unlike `@after_compile`, the callback function/macro must\n"
"be placed in a separate module (because when the callback is invoked,\n"
"the current module does not yet exist).\n"
"\n"
"#### Example\n"
"\n"
"    defmodule A do\n"
"      defmacro __before_compile__(_env) do\n"
"        quote do\n"
"          def hello, do: \"world\"\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    defmodule B do\n"
"      @before_compile A\n"
"    end\n"
"\n"
"### `@on_definition`\n"
"\n"
"A hook that will be invoked when each function or macro in the current\n"
"module is defined. Useful when annotating functions.\n"
"\n"
"Accepts a module or a tuple `{<module>, <function atom>}`. The function\n"
"must take 6 arguments:\n"
"\n"
"  - the module environment\n"
"  - kind: `:def`, `:defp`, `:defmacro`, or `:defmacrop`\n"
"  - function/macro name\n"
"  - list of quoted arguments\n"
"  - list of quoted guards\n"
"  - quoted function body\n"
"\n"
"Note the hook receives the quoted arguments and it is invoked before\n"
"the function is stored in the module. So `Module.defines?/2` will return\n"
"`false` for the first clause of every function.\n"
"\n"
"If the function/macro being defined has multiple clauses, the hook will\n"
"be called for each clause.\n"
"\n"
"Unlike other hooks, `@on_definition` will only invoke functions\n"
"and never macros. This is because the hook is invoked inside the context\n"
"of the function (and nested function definitions are not allowed in\n"
"Elixir).\n"
"\n"
"When just a module is provided, the function is assumed to be\n"
"`__on_definition__/6`.\n"
"\n"
"#### Example\n"
"\n"
"    defmodule H do\n"
"      def on_def(_env, kind, name, args, guards, body) do\n"
"        IO.puts \"Defining #{kind} named #{name} with args:\"\n"
"        IO.inspect args\n"
"        IO.puts \"and guards\"\n"
"        IO.inspect guards\n"
"        IO.puts \"and body\"\n"
"        IO.puts Macro.to_string(body)\n"
"      end\n"
"    end\n"
"\n"
"    defmodule M do\n"
"      @on_definition {H, :on_def}\n"
"\n"
"      def hello(arg) when is_binary(arg) or is_list(arg) do\n"
"        \"Hello\" <> to_string(arg)\n"
"      end\n"
"\n"
"      def hello(_) do\n"
"        :ok\n"
"      end\n"
"    end\n"
"\n"
"## Compile options\n"
"\n"
"The `@compile` attribute accepts diverse options that is used by both\n"
"Elixir and Erlang compilers. Some of the common use cases are documented\n"
"below:\n"
"\n"
"  * `@compile :debug_info` - includes `:debug_info` regardless of the\n"
"    setting in `Code.compiler_options`\n"
"\n"
"  * `@compile {:debug_info, false} - disables `:debug_info` regardless\n"
"    of the setting in `Code.compiler_options`\n"
"\n"
"  * `@compile {:inline, some_fun: 2, other_fun: 3}` - inlines the given\n"
"    name/arity pairs\n"
"\n"
"  * `@compile {:autoload, false}` - disables automatic loading of\n"
"    modules after compilation. Instead, the module will be loaded after\n"
"    it is dispatched to\n"
"\n"
"You can see a handful more options used by the Erlang compiler in\n"
"the documentation for the `:compile` module.\n"
msgstr ""
"コンパイル時にモジュールを取り扱う多くの関数を提供します。\n"
"\n"
"それらは、開発者に動的にドキュメントを添付したり、アトリビュートや\n"
"その他を追加、削除、登録することを許可します。\n"
"\n"
"モジュールがコンパイルされた後では、実行時データを調べるそれらのスコー\n"
"プの外にあるため、このモジュールの関数の多くは利用すると、エラーを上げ\n"
"ます。多くの実行時データはそれぞれコンパイルされたモジュールにアタッチ\n"
"された`__info__(attr)`関数により調べることができます。\n"
"\n"
"## Module attributes\n"
"\n"
"それぞののモジュールは一つ以上のアトリビュートで装飾することができます。\n"
"以下は現在のElixirで定義されているものです:\n"
"\n"
"  * `@after_compile`\n"
"\n"
"    カレントモジュールがコンパイルされた直後に実行されるフックです。\n"
"    モジュールまたは、`{<module>, <function atom>}`タプルを受け付けます。\n"
"    詳細は下の\"Compile callbacks\"セクションを参照してください。\n"
"\n"
"  * `@before_compile`\n"
"\n"
"    モジュールがコンパイルされる前に実行されるフックです。\n"
"    モジュールまたは、`{<module>, <function/macro atom>}`タプルを受け\n"
"    付けます。\n"
"    詳細は下の\"Compile callbacks\"セクションを参照してください。\n"
"\n"
"  * `@behaviour` (英国式綴であることに注意してください)\n"
"\n"
"    ビヘイビアはモジュールが要求する`@callback`によって定義された\n"
"    関数を実装することを確実にします。\n"
"\n"
"    例えば、URI.Parserビヘイビアを以下のように指定することができます:\n"
"\n"
"        defmodule URI.Parser do\n"
"          @doc \"Parses the given URL\"\n"
"          @callback parse(uri_info :: URI.t) :: URI.t\n"
"\n"
"          @doc \"Defines a default port\"\n"
"          @callback default_port() :: integer\n"
"        end\n"
"\n"
"\n"
"        それからモジュールを以下のようにして使います:\n"
"\n"
"        defmodule URI.HTTP do\n"
"          @behaviour URI.Parser\n"
"          def default_port(), do: 80\n"
"          def parse(info), do: info\n"
"        end\n"
"\n"
"    もしビヘイビアが変更したり、URI.HTTPがコールバックを\n"
"    一つでも実装していないなら、警告が上るでしょう。\n"
"\n"
"    OTPあるいはユーザ定義のビヘイビアを指定します。\n"
"\n"
"    ### Example\n"
"\n"
"        defmodule M do\n"
"          @behaviour gen_event\n"
"\n"
"          # ...\n"
"        end\n"
"\n"
"  * `@compile`\n"
"\n"
"    モジュールのコンパイルオプションを定義します。\n"
"    外部のツールによって追加される任意の他のコンパイルパスとして、\n"
"    これは、ErlangとElixirの両方のコンパイラを構成するために使われます。\n"
"\n"
"    `@compile`を何度か使うと、前のものを上書きするかわりに、\n"
"    累積します。下の\"Compile options\"セクションを参照してください。\n"
"\n"
"    ### Example\n"
"\n"
"        defmodule M do\n"
"          @compile {:inline, myfun: 1}\n"
"\n"
"          def myfun(arg) do\n"
"            to_string(arg)\n"
"          end\n"
"        end\n"
"\n"
"  * `@doc`\n"
"\n"
"    アトリビュートの後の関数またはマクロへのドキュメントを提供します。\n"
"\n"
"    文字列(しばしばヒアドキュメントです)または、`false`を受け付けます。\n"
"    `@doc false`とした関数/マクロはExDocの様なドキュメント抽出ツールに\n"
"    より非表示にされるでしょう。\n"
"\n"
"    ひとつ以上記述することができます。\n"
"\n"
"    ### Example\n"
"\n"
"        defmodule M do\n"
"          @doc \"Hello world\"\n"
"          def hello do\n"
"            \"world\"\n"
"          end\n"
"\n"
"          @doc \"\"\"\n"
"          Sums `a` to `b`.\n"
"          \"\"\"\n"
"          def sum(a, b) do\n"
"            a + b\n"
"          end\n"
"        end\n"
"\n"
"  * `@dialyzer`\n"
"\n"
"    モジュールアトリビュートをサポートする\n"
"    `:dialyzer`のバージョンを使用している時に、\n"
"    要求または抑制するwarningを定義します。\n"
"\n"
"    アトム、タプルまたはアトムとタプルのリストを受け付けます。\n"
"\n"
"    サポートしているwarningのリストは\n"
"    [`:dialyzer モジュール](http://www.erlang.org/doc/man/dialyzer.html)\n"
"    を参照してください。\n"
"\n"
"    `@dialyzer`を何度か使うと以前の値を上書きするかわりに\n"
"    累積されます。\n"
"\n"
"    ### Example\n"
"\n"
"        defmodule M do\n"
"          @dialyzer {:nowarn_function, myfun: 1}\n"
"\n"
"          def myfun(arg) do\n"
"            M.not_a_function(arg)\n"
"          end\n"
"        end\n"
"\n"
"  * `@external_resource`\n"
"\n"
"    カレントモジュールに外部リソースを指定します。\n"
"\n"
"    しばしば、モジュールは外部から情報を埋め込みます。\n"
"    このアトリビュートはモジュールにどの外部リソースが使われたかに\n"
"    ついて注釈を付けることを許可します。\n"
"\n"
"    Mixの様なツールはこの情報を、外部リソースが変更された場合に\n"
"    モジュールが再コンパイルされることを確実にするために、使うかも\n"
"    しれません。\n"
"\n"
"  * `@file`\n"
"\n"
"    アトリビュートの後の関数またはマクロについてのスタックトレースで\n"
"    使われるファイル名を変更します。\n"
"\n"
"    文字列を受け付けます。ひとつ以上使うことができます。\n"
"\n"
"    ### Example\n"
"\n"
"        defmodule M do\n"
"          @doc \"Hello world\"\n"
"          @file \"hello.ex\"\n"
"          def hello do\n"
"            \"world\"\n"
"          end\n"
"        end\n"
"\n"
"  * `@moduledoc`\n"
"\n"
"    カレントモジュールについてのドキュメントを提供します。\n"
"\n"
"    文字列(しばしばヒアドキュメントです)または、`false`を受け付けます。\n"
"    `@moduledoc false`としたモジュールはExDocの様なドキュメント抽出\n"
"    ツールにより非表示にされるでしょう。\n"
"\n"
"    ### Example\n"
"\n"
"        defmodule M do\n"
"          @moduledoc \"\"\"\n"
"          A very useful module\n"
"          \"\"\"\n"
"        end\n"
"\n"
"  * `@on_definition`\n"
"\n"
"    カレントモジュールのそれぞれの関数あるいはマクロが定義されたれた時\n"
"    に実行されるフックです。関数に注をつけるときに役に立ちます。\n"
"\n"
"    モジュールあるいは、`{<module>, <function atom>}`タプルを受け付けます。\n"
"    下の\"Compile options\"セクションを参照してください。\n"
"\n"
"  * `@on_load`\n"
"\n"
"    モジュールがロードされる時には何時でも実行されるフックです。\n"
"\n"
"    カレントモジュール内の関数名を示すアトムを\n"
"    受け付けます。関数は、アリティ0(引数なし)で、`:ok`を返さなければ\n"
"    なりません。さもなくば、モジュールのローディングは中止されます。\n"
"\n"
"    ### Example\n"
"\n"
"        defmodule M do\n"
"          @on_load :load_check\n"
"\n"
"          def load_check do\n"
"            if some_condition() do\n"
"              :ok\n"
"            else\n"
"              nil\n"
"            end\n"
"          end\n"
"\n"
"          def some_condition do\n"
"            false\n"
"          end\n"
"        end\n"
"\n"
"  * `@vsn`\n"
"\n"
"    モジュールのバージョンを指定します。任意の正しいElixirの値を\n"
"    受け付けます。\n"
"\n"
"    ### Example\n"
"\n"
"        defmodule M do\n"
"          @vsn \"1.0\"\n"
"        end\n"
"\n"
"以下のアトリビュートはtypespecの一部で、Elixirにより予約されています:\n"
"\n"
"  * `@type`          - defines a type to be used in `@spec`\n"
"  * `@typep`         - defines a private type to be used in `@spec`\n"
"  * `@opaque`        - defines an opaque type to be used in `@spec`\n"
"  * `@spec`          - provides a specification for a function\n"
"  * `@callback`      - provides a specification for a behaviour callback\n"
"  * `@macrocallback` - provides a specification for a macro behaviour callback\n"
"\n"
"上で概説されたビルトインのアトリビュートに加えて、カスタムアトリビュートも\n"
"追加できます。カスタムアトリビュートは`@`が前についた有効な識別子なら\n"
"なんてもよく、後ろに有効なElixirの値がつきます:\n"
"\n"
"    defmodule M do\n"
"      @custom_attr [some: \"stuff\"]\n"
"    end\n"
"\n"
"カスタムアトリビュートの定義時のより進んだオプションについては\n"
"`register_attribute/3`を参照してください。\n"
"\n"
"## Compile callbacks\n"
"\n"
"モジュールが定義されるとき、定義される直前、そしてバイトコードが\n"
"生成された直後に起動される3つのコールバック関数があります。\n"
"\n"
"### `@after_compile`\n"
"\n"
"これは現在のモジュールがコンパイルされた直後に起動されるフックです。\n"
"\n"
"モジュールか`{<module>, <function atom>}`タプルを受け付けます。\n"
"functionは二つの引数をとらなければなりません: モジュールの環境と\n"
"バイトコードです。引数としてモジュールのみが提供されたとき、\n"
"functionは`__after_compile__/2`であるとされます。\n"
"\n"
"#### Example\n"
"\n"
"    defmodule M do\n"
"      @after_compile __MODULE__\n"
"\n"
"      def __after_compile__(env, _bytecode) do\n"
"        IO.inspect env\n"
"      end\n"
"    end\n"
"\n"
"### `@before_compile`\n"
"\n"
"モジュールがコンパイルされる前に実行されるフックです。\n"
"\n"
"モジュールまたは、`{<module>, <function/macro atom>}`タプルを受け\n"
"付けます。そのfunction/macroは一つの引数をとらなければなりません: \n"
"モジュールの環境です。もしマクロであるならば、その戻値がコンパイルが\n"
"始まる前にモジュール定義の最後に差し込まれます。\n"
"\n"
"引数としてモジュールが提供されたとき、そのfunction/macroは\n"
"`__before_compile__/1`であるとされます。\n"
"\n"
"注: `@after_compile`と異なり、コールバック関数/マクロは\n"
"別のモジュールに置かれなければなりません(何故なら、\n"
"コールバックが実行されるとき、カレントモジュールはまだ存在して\n"
"いないからです)。\n"
"\n"
"#### Example\n"
"\n"
"    defmodule A do\n"
"      defmacro __before_compile__(_env) do\n"
"        quote do\n"
"          def hello, do: \"world\"\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    defmodule B do\n"
"      @before_compile A\n"
"    end\n"
"\n"
"### `@on_definition`\n"
"\n"
"カレントモジュールのそれぞれの関数あるいはマクロが定義されたれた時\n"
"に実行されるフックです。関数に注をつけるときに役に立ちます。\n"
"\n"
"モジュールあるいは、`{<module>, <function atom>}`タプルを受け付けます。\n"
"functionは6個の引数を取らなければなりません: \n"
"\n"
"  - モジュールの環境\n"
"  - 種類: `:def`, `:defp`, `:defmacro`, あるいは `:defmacrop`\n"
"  - 関数/マクロの名前\n"
"  - quoteされた引数のリスト\n"
"  - quoteされたガードのリスト\n"
"  - quoteされた関数本体\n"
"\n"
"フックは、関数がモジュールにストアされる前に実行され、quoteされた引数を\n"
"受信することに注意してください。だから、`Module.defines?/2`はそれぞれの\n"
"関数について最初の節なので`false`で返るでしょう。\n"
"\n"
"もし定義しようとしている関数/マクロが複数の節をもつなら、\n"
"フックはそれぞれの節毎に呼ばれるでしょう。\n"
"\n"
"他のフックと異なり、`@on_definition`はマクロでは決してなく、\n"
"関数だけを実行します。これは、関数のコンテキストの内側で\n"
"フックが実行されるからです(そしてElixirはネストした関数定義は\n"
"許されていないのです)。\n"
"\n"
"引数としてモジュールのみが提供されたとき、そのfunctionは\n"
"`__on_definition__/6` であるとされます。\n"
"\n"
"#### Example\n"
"\n"
"    defmodule H do\n"
"      def on_def(_env, kind, name, args, guards, body) do\n"
"        IO.puts \"Defining #{kind} named #{name} with args:\"\n"
"        IO.inspect args\n"
"        IO.puts \"and guards\"\n"
"        IO.inspect guards\n"
"        IO.puts \"and body\"\n"
"        IO.puts Macro.to_string(body)\n"
"      end\n"
"    end\n"
"\n"
"    defmodule M do\n"
"      @on_definition {H, :on_def}\n"
"\n"
"      def hello(arg) when is_binary(arg) or is_list(arg) do\n"
"        \"Hello\" <> to_string(arg)\n"
"      end\n"
"\n"
"      def hello(_) do\n"
"        :ok\n"
"      end\n"
"    end\n"
"\n"
"## Compile options\n"
"\n"
"`@compile`アトリビュートはElixirとErlangコンパイラ両方で使われる多様な\n"
"オプションを受け付けます。\n"
"共通のユースケースの幾つかを以下に示します:\n"
"\n"
"  * `@compile :debug_info` - `Code.compiler_options`の設定に\n"
"    かかわらず、`:debug_info`を含みます\n"
"\n"
"  * `@compile {:debug_info, false} - `Code.compiler_options`の設定に\n"
"    かかわらず、`:debug_info`を無効にします\n"
"\n"
"  * `@compile {:inline, some_fun: 2, other_fun: 3}` - 与えられた\n"
"    name/arityペアをインラインにします\n"
"\n"
"  * `@compile {:autoload, false}` - コンパイル後の自動ローディングを\n"
"    無効にします。かわりにモジュールは呼ばれたときにロード\n"
"    されます。\n"
"\n"
"Erlangコンパイラドキュメントの`:compile`モジュールに沢山の\n"
"オプションを見付けることができます。\n"

#. TRANSLATORS: def Module.delete_attribute(module, key)
#: lib/module.ex:923
msgid ""
"Deletes all attributes that match the given key.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule MyModule do\n"
"      Module.put_attribute __MODULE__, :custom_threshold_for_lib, 10\n"
"      Module.delete_attribute __MODULE__, :custom_threshold_for_lib\n"
"    end\n"
"\n"
msgstr ""
"与えられたkeyにマッチする属性を全て削除します。\n"
"\n"
"## 例\n"
"\n"
"    defmodule MyModule do\n"
"      Module.put_attribute __MODULE__, :custom_threshold_for_lib, 10\n"
"      Module.delete_attribute __MODULE__, :custom_threshold_for_lib\n"
"    end\n"
"\n"

#. TRANSLATORS: def Module.__info__(kind)
#: lib/module.ex:376
msgid ""
"Provides runtime information about functions and macros defined by the\n"
"module, enables docstring extraction, etc.\n"
"\n"
"Each module gets an `__info__/1` function when it's compiled. The function\n"
"takes one of the following atoms:\n"
"\n"
"  * `:functions`  - keyword list of public functions along with their "
"arities\n"
"\n"
"  * `:macros`     - keyword list of public macros along with their arities\n"
"\n"
"  * `:module`     - module name (`Module == Module.__info__(:module)`)\n"
"\n"
"In addition to the above, you may also pass to `__info__/1` any atom "
"supported\n"
"by `:erlang.module_info/0` which also gets defined for each compiled "
"module.\n"
"\n"
"For a list of supported attributes and more information, see [Modules – "
"Erlang Reference Manual](http://www.erlang.org/doc/reference_manual/modules."
"html#id77056).\n"
msgstr ""
"モジュールで定義された、関数とマクロについての実行時情報を提供して、\n"
"docstringの抽出などを可能にします。\n"
"\n"
"それぞれのモジュールはコンパイル時に`__info__/1`関数を取得します。\n"
"関数は以下のアトムを引数として取ります:\n"
"\n"
"  * `:functions`  -  公開関数とそのアリティのキーワードリスト\n"
"\n"
"  * `:macros`     -  公開マクロとそのアリティのキーワードリスト\n"
"\n"
"  * `:module`     -  モジュール名 (`Module == Module.__info__(:module)`)\n"
"\n"
"上記に加えて、`__info__/1`に、コンパイルされたモジュール毎に定義される\n"
"`:erlang.module_info/0`関数でサポートされた、任意のアトムをパスすること\n"
"も出来ます。\n"
"\n"
"サポートされたアトリビュートやその他詳細は、\n"
"[Modules – Erlang Reference Manual](http://www.erlang.org/doc/"
"reference_manual/modules.html#id77056)\n"
"を参照してください。\n"

#. TRANSLATORS: def Module.definitions_in(module)
#: lib/module.ex:772
msgid ""
"Returns all functions defined in `module`.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Example do\n"
"      def version, do: 1\n"
"      Module.definitions_in __MODULE__ #=> [{:version, 0}]\n"
"    end\n"
"\n"
msgstr ""
"`module`で定義されている全ての関数を返します。\n"
"\n"
"## 例\n"
"\n"
"    defmodule Example do\n"
"      def version, do: 1\n"
"      Module.definitions_in __MODULE__ #=> [{:version,0}]\n"
"    end\n"
"\n"

#. TRANSLATORS: def Module.overridable?(module, tuple)
#: lib/module.ex:843
msgid "Returns `true` if `tuple` in `module` is marked as overridable.\n"
msgstr ""
"もし、`module`の中の`tuple`がoverridableとしてマークされていれば、\n"
"`true`を返します。\n"

#. TRANSLATORS: def Module.make_overridable(module, tuples)
#: lib/module.ex:808
msgid ""
"Makes the given functions in `module` overridable.\n"
"\n"
"An overridable function is lazily defined, allowing a\n"
"developer to customize it. See `Kernel.defoverridable/1` for\n"
"more information and documentation.\n"
msgstr ""
"`module`の与えられた関数をoverridableにします。\n"
"\n"
"overridable関数は、遅延して定義され、\n"
"開発者にカスタマイズすることを許します。\n"
"詳細については、`Kernel.defoverridable/1` を参照してください。\n"

#. TRANSLATORS: def Module.concat(left, right)
#: lib/module.ex:515
msgid ""
"Concatenates two aliases and returns a new alias.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Module.concat(Foo, Bar)\n"
"    Foo.Bar\n"
"\n"
"    iex> Module.concat(Foo, \"Bar\")\n"
"    Foo.Bar\n"
"\n"
msgstr ""
"二つのエイリアスを連結し、新しいエイリアスを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Module.concat(Foo, Bar)\n"
"    Foo.Bar\n"
"\n"
"    iex> Module.concat(Foo, \"Bar\")\n"
"    Foo.Bar\n"
"\n"

#. TRANSLATORS: def Module.safe_concat(list)
#: lib/module.ex:532
msgid ""
"Concatenates a list of aliases and returns a new alias only if the alias\n"
"was already referenced.\n"
"\n"
"If the alias was not referenced yet, fails with `ArgumentError`.\n"
"It handles char lists, binaries and atoms.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Module.safe_concat([Module, Unknown])\n"
"    ** (ArgumentError) argument error\n"
"\n"
"    iex> Module.safe_concat([List, Chars])\n"
"    List.Chars\n"
"\n"
msgstr ""
"エイリアスのリストを連結し、出来た新しいエイリアスが、\n"
"それが既に参照されていた時だけ、それを返します。\n"
"\n"
"もしそのエイリアスがまだ参照されていなかったなら、\n"
"`ArgumentError`で失敗します。\n"
"文字リスト、バイナリ、アトムをハンドルします。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Module.safe_concat([Module, Unknown])\n"
"    ** (ArgumentError) argument error\n"
"\n"
"    iex> Module.safe_concat([List, Chars])\n"
"    List.Chars\n"
"\n"

#. TRANSLATORS: def Module.register_attribute(module, new, opts)
#: lib/module.ex:942
msgid ""
"Registers an attribute. By registering an attribute, a developer\n"
"is able to customize how Elixir will store and accumulate the\n"
"attribute values.\n"
"\n"
"## Options\n"
"\n"
"When registering an attribute, two options can be given:\n"
"\n"
"  * `:accumulate` - several calls to the same attribute will\n"
"    accumulate instead of override the previous one. New attributes\n"
"    are always added to the top of the accumulated list.\n"
"\n"
"  * `:persist` - the attribute will be persisted in the Erlang\n"
"    Abstract Format. Useful when interfacing with Erlang libraries.\n"
"\n"
"By default, both options are `false`.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule MyModule do\n"
"      Module.register_attribute __MODULE__,\n"
"        :custom_threshold_for_lib,\n"
"        accumulate: true, persist: false\n"
"\n"
"      @custom_threshold_for_lib 10\n"
"      @custom_threshold_for_lib 20\n"
"      @custom_threshold_for_lib #=> [20, 10]\n"
"    end\n"
"\n"
msgstr ""
"アトリビュートを登録します。アトリビュートを登録するとき、\n"
"開発者は、Elixirがアトリビュート値を保存して、累積する方法を、\n"
"カスタマイズできます。\n"
"\n"
"## オプション\n"
"\n"
"アトリビュートを登録するとき、二つのオプションを与えることができます:\n"
"\n"
"  * `:accumulate` - 同じアトリビュートへの幾つかの呼び出しは、\n"
"     前のものを上書きする替わりに累積します。新しいアトリビュートは\n"
"     常に累積リストの先頭に追加されます。\n"
"\n"
"  * `:persist` - アトリビュートはErlang Abstract Formatで保存\n"
"     されます。Erlangライブラリと相互作用するとき役立ちます。\n"
"\n"
"デフォルトでは、両方のオプションは`false`です。\n"
"\n"
"## 例\n"
"\n"
"    defmodule MyModule do\n"
"      Module.register_attribute __MODULE__,\n"
"        :custom_threshold_for_lib,\n"
"        accumulate: true, persist: false\n"
"\n"
"      @custom_threshold_for_lib 10\n"
"      @custom_threshold_for_lib 20\n"
"      @custom_threshold_for_lib #=> [20, 10]\n"
"    end\n"
"\n"

#. TRANSLATORS: def Module.defines?(module, tuple)
#: lib/module.ex:728
msgid ""
"Checks if the module defines the given function or macro.\n"
"\n"
"Use `defines?/3` to assert for a specific type.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Example do\n"
"      Module.defines? __MODULE__, {:version, 0} #=> false\n"
"      def version, do: 1\n"
"      Module.defines? __MODULE__, {:version, 0} #=> true\n"
"    end\n"
"\n"
msgstr ""
"与えられた関数かマクロがmoduleで定義されているかチェックします。\n"
"\n"
"特定のタイプを主張するためには、`defines?/3`を使ってください。\n"
"\n"
"## 例\n"
"\n"
"    defmodule Example do\n"
"      Module.defines? __MODULE__, {:version, 0} #=> false\n"
"      def version, do: 1\n"
"      Module.defines? __MODULE__, {:version, 0} #=> true\n"
"    end\n"
"\n"

#. TRANSLATORS: def Module.create(module, quoted, opts)
#: lib/module.ex:450
msgid ""
"Creates a module with the given name and defined by\n"
"the given quoted expressions.\n"
"\n"
"The line where the module is defined and its file **must**\n"
"be passed as options.\n"
"\n"
"## Examples\n"
"\n"
"    contents =\n"
"      quote do\n"
"        def world, do: true\n"
"      end\n"
"\n"
"    Module.create(Hello, contents, Macro.Env.location(__ENV__))\n"
"\n"
"    Hello.world #=> true\n"
"\n"
"## Differences from `defmodule`\n"
"\n"
"`Module.create/3` works similarly to `defmodule` and\n"
"return the same results. While one could also use\n"
"`defmodule` to define modules dynamically, this\n"
"function is preferred when the module body is given\n"
"by a quoted expression.\n"
"\n"
"Another important distinction is that `Module.create/3`\n"
"allows you to control the environment variables used\n"
"when defining the module, while `defmodule` automatically\n"
"shares the same environment.\n"
msgstr ""
"与えられた名前とquoteされた式により定義されるモジュールを\n"
"作ります。\n"
"\n"
"モジュールが定義された行とそのファイル名は、オプションとして\n"
"**渡されなければなりません**。\n"
"\n"
"## 例\n"
"\n"
"    contents =\n"
"      quote do\n"
"        def world, do: true\n"
"      end\n"
"\n"
"    Module.create(Hello, contents, Macro.Env.location(__ENV__))\n"
"\n"
"    Hello.world #=> true\n"
"\n"
"## `defmodule`との違い\n"
"\n"
"`Module.create`は`defmodule`と似た働きをし、同じ戻り値を返します。\n"
"`defmodule`がモジュールを動的に定義するために使われる一方、この関数はモ\n"
"ジュール本体がquoteされた式により与えられた時に好まれます。\n"
"\n"
"もう一つの重要な違いは、モジュールを定義するときに、`defmodule`は自動的\n"
"に同じ環境を共有する一方、`Module.create`が環境変数を制御することを許\n"
"します。\n"

#. TRANSLATORS: def Module.get_attribute(module, key)
#: lib/module.ex:889
msgid ""
"Gets the given attribute from a module.\n"
"\n"
"If the attribute was marked with `accumulate` with\n"
"`Module.register_attribute/3`, a list is always returned. `nil` is returned\n"
"if the attribute has not been marked with `accumulate` and has not been set\n"
"to any value.\n"
"\n"
"The `@` macro compiles to a call to this function. For example,\n"
"the following code:\n"
"\n"
"    @foo\n"
"\n"
"Expands close to:\n"
"\n"
"    Module.get_attribute(__MODULE__, :foo)\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Foo do\n"
"      Module.put_attribute __MODULE__, :value, 1\n"
"      Module.get_attribute __MODULE__, :value #=> 1\n"
"\n"
"      Module.register_attribute __MODULE__, :value, accumulate: true\n"
"      Module.put_attribute __MODULE__, :value, 1\n"
"      Module.get_attribute __MODULE__, :value #=> [1]\n"
"    end\n"
"\n"
msgstr ""
"モジュールから与えられた属性を取得します。\n"
"\n"
"もし属性が\n"
"`Module.register_attribute/3`で`accumulate`とマークされていたら、\n"
"常にリストを返します。\n"
"\n"
"`@`マクロは、この関数の呼び出しに、コンパイルします。\n"
"例えば以下のコードは:\n"
"\n"
"    @foo\n"
"\n"
"以下に展開されます:\n"
"\n"
"    Module.get_attribute(__MODULE__, :foo)\n"
"\n"
"## 例\n"
"\n"
"    defmodule Foo do\n"
"      Module.put_attribute __MODULE__, :value, 1\n"
"      Module.get_attribute __MODULE__, :value #=> 1\n"
"\n"
"      Module.register_attribute __MODULE__, :value, accumulate: true\n"
"      Module.put_attribute __MODULE__, :value, 1\n"
"      Module.get_attribute __MODULE__, :value #=> [1]\n"
"    end\n"
"\n"

#. TRANSLATORS: def Module.open?(module)
#: lib/module.ex:396
msgid ""
"Checks if a module is open, i.e. it is currently being defined\n"
"and its attributes and functions can be modified.\n"
msgstr ""
"moduleがオープンされたかをチェックします。\n"
"即ち、オープンされているとは、現在定義されていて、\n"
"属性と関数は修正可能ということです。\n"

#. TRANSLATORS: def Module.add_doc(module, line, kind, tuple, signature \\ [], doc)
#: lib/module.ex:574
msgid ""
"Attaches documentation to a given function or type.\n"
"\n"
"It expects the module the function/type belongs to, the line (a non\n"
"negative integer), the kind (`def` or `defmacro`), a tuple representing\n"
"the function and its arity, the function signature (the signature\n"
"should be omitted for types) and the documentation, which should\n"
"be either a binary or a boolean.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule MyModule do\n"
"      Module.add_doc(__MODULE__, __ENV__.line + 1, :def, {:version, 0}, [], "
"\"Manually added docs\")\n"
"      def version, do: 1\n"
"    end\n"
"\n"
msgstr ""
"与えられた関数あるいはタイプにドキュメントをアタッチします。\n"
"\n"
"関数/タイプが属しているモジュール、行(非負の整数)、種類(`def`か"
"`defmacro`)、\n"
"関数とアリティのタプル表現、関数のシグネチャ(シグネチャはタイプでは\n"
"省略されなければなりません)、そしてドキュメント(それはバイナリかブーリアン\n"
"でなければなりません)を期待します。\n"
"\n"
"## 例\n"
"\n"
"    defmodule MyModule do\n"
"      Module.add_doc(__MODULE__, __ENV__.line + 1, :def, {:version, 0}, [], "
"\"Manually added docs\")\n"
"      def version, do: 1\n"
"    end\n"
"\n"

#. TRANSLATORS: def Module.concat(list)
#: lib/module.ex:498
msgid ""
"Concatenates a list of aliases and returns a new alias.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Module.concat([Foo, Bar])\n"
"    Foo.Bar\n"
"\n"
"    iex> Module.concat([Foo, \"Bar\"])\n"
"    Foo.Bar\n"
"\n"
msgstr ""
"エイリアスのリストを連結し、新しいエイリアスを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Module.concat([Foo, Bar])\n"
"    Foo.Bar\n"
"\n"
"    iex> Module.concat([Foo, \"Bar\"])\n"
"    Foo.Bar\n"
"\n"

#. TRANSLATORS: def Module.split(module)
#: lib/module.ex:988
msgid ""
"Splits the given module name into binary parts.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Module.split Very.Long.Module.Name.And.Even.Longer\n"
"    [\"Very\", \"Long\", \"Module\", \"Name\", \"And\", \"Even\", \"Longer"
"\"]\n"
"\n"
msgstr ""
"与えられたモジュール名をバイナリの部分に分割します。\n"
"\n"
"## 例\n"
"\n"
"    Module.split Very.Long.Module.Name.And.Even.Longer\n"
"    #=> [\"Very\", \"Long\", \"Module\", \"Name\", \"And\", \"Even\", \"Longer\"]\n"
"\n"

#~ msgid ""
#~ "Provides functions to deal with modules during compilation time.\n"
#~ "\n"
#~ "It allows a developer to dynamically add, delete and register\n"
#~ "attributes, attach documentation and so forth.\n"
#~ "\n"
#~ "After a module is compiled, using many of the functions in\n"
#~ "this module will raise errors, since it is out of their scope\n"
#~ "to inspect runtime data. Most of the runtime data can be inspected\n"
#~ "via the `__info__(attr)` function attached to each compiled module.\n"
#~ "\n"
#~ "## Module attributes\n"
#~ "\n"
#~ "Each module can be decorated with one or more attributes. The following "
#~ "ones\n"
#~ "are currently defined by Elixir:\n"
#~ "\n"
#~ "  * `@after_compile`\n"
#~ "\n"
#~ "    A hook that will be invoked right after the current module is "
#~ "compiled.\n"
#~ "\n"
#~ "    Accepts a module or a tuple `{<module>, <function atom>}`. The "
#~ "function\n"
#~ "    must take two arguments: the module environment and its bytecode.\n"
#~ "    When just a module is provided, the function is assumed to be\n"
#~ "    `__after_compile__/2`.\n"
#~ "\n"
#~ "    ### Example\n"
#~ "\n"
#~ "        defmodule M do\n"
#~ "          @after_compile __MODULE__\n"
#~ "\n"
#~ "          def __after_compile__(env, _bytecode) do\n"
#~ "            IO.inspect env\n"
#~ "          end\n"
#~ "        end\n"
#~ "\n"
#~ "  * `@before_compile`\n"
#~ "\n"
#~ "    A hook that will be invoked before the module is compiled.\n"
#~ "\n"
#~ "    Accepts a module or a tuple `{<module>, <function/macro atom>}`. The\n"
#~ "    function/macro must take one argument: the module environment. If "
#~ "it's a\n"
#~ "    macro, its returned value will be injected at the end of the module "
#~ "definition\n"
#~ "    before the compilation starts.\n"
#~ "\n"
#~ "    When just a module is provided, the function/macro is assumed to be\n"
#~ "    `__before_compile__/1`.\n"
#~ "\n"
#~ "    Note: unlike `@after_compile`, the callback function/macro must\n"
#~ "    be placed in a separate module (because when the callback is "
#~ "invoked,\n"
#~ "    the current module does not yet exist).\n"
#~ "\n"
#~ "    ### Example\n"
#~ "\n"
#~ "        defmodule A do\n"
#~ "          defmacro __before_compile__(_env) do\n"
#~ "            quote do\n"
#~ "              def hello, do: \"world\"\n"
#~ "            end\n"
#~ "          end\n"
#~ "        end\n"
#~ "\n"
#~ "        defmodule B do\n"
#~ "          @before_compile A\n"
#~ "        end\n"
#~ "\n"
#~ "  * `@behaviour`   (notice the British spelling)\n"
#~ "\n"
#~ "    Behaviours can be referenced by modules to ensure they implement\n"
#~ "    required specific function signatures defined by `@callback`.\n"
#~ "\n"
#~ "    For example, you can specify the URI.Parser behaviour as follows:\n"
#~ "\n"
#~ "        defmodule URI.Parser do\n"
#~ "          @doc \"Parses the given URL\"\n"
#~ "          @callback parse(uri_info :: URI.t) :: URI.t\n"
#~ "\n"
#~ "          @doc \"Defines a default port\"\n"
#~ "          @callback default_port() :: integer\n"
#~ "        end\n"
#~ "\n"
#~ "        And then a module may use it as:\n"
#~ "\n"
#~ "        defmodule URI.HTTP do\n"
#~ "          @behaviour URI.Parser\n"
#~ "          def default_port(), do: 80\n"
#~ "          def parse(info), do: info\n"
#~ "        end\n"
#~ "\n"
#~ "    If the behaviour changes or URI.HTTP does not implement one of the\n"
#~ "    callbacks, a warning will be raised.\n"
#~ "\n"
#~ "    Specifies an OTP or user-defined behaviour.\n"
#~ "\n"
#~ "    ### Example\n"
#~ "\n"
#~ "        defmodule M do\n"
#~ "          @behaviour gen_event\n"
#~ "\n"
#~ "          # ...\n"
#~ "        end\n"
#~ "\n"
#~ "  * `@compile`\n"
#~ "\n"
#~ "    Defines options for module compilation that are passed to the Erlang\n"
#~ "    compiler.\n"
#~ "\n"
#~ "    Accepts an atom, a tuple, or a list of atoms and tuples.\n"
#~ "\n"
#~ "    For the list of supported options, see Erlang's\n"
#~ "    [`:compile` module](http://www.erlang.org/doc/man/compile.html).\n"
#~ "\n"
#~ "    Multiple uses of `@compile` will accumulate instead of overriding\n"
#~ "    previous ones.\n"
#~ "\n"
#~ "    ### Example\n"
#~ "\n"
#~ "        defmodule M do\n"
#~ "          @compile {:inline, myfun: 1}\n"
#~ "\n"
#~ "          def myfun(arg) do\n"
#~ "            to_string(arg)\n"
#~ "          end\n"
#~ "        end\n"
#~ "\n"
#~ "  * `@doc`\n"
#~ "\n"
#~ "    Provides documentation for the function or macro that follows the\n"
#~ "    attribute.\n"
#~ "\n"
#~ "    Accepts a string (often a heredoc) or `false` where `@doc false` "
#~ "will\n"
#~ "    make the function/macro invisible to the documentation extraction "
#~ "tools\n"
#~ "    like ExDoc.\n"
#~ "\n"
#~ "    Can be invoked more than once.\n"
#~ "\n"
#~ "    ### Example\n"
#~ "\n"
#~ "        defmodule M do\n"
#~ "          @doc \"Hello world\"\n"
#~ "          def hello do\n"
#~ "            \"world\"\n"
#~ "          end\n"
#~ "\n"
#~ "          @doc \"\"\"\n"
#~ "          Sums `a` to `b`.\n"
#~ "          \"\"\"\n"
#~ "          def sum(a, b) do\n"
#~ "            a + b\n"
#~ "          end\n"
#~ "        end\n"
#~ "\n"
#~ "  * `@file`\n"
#~ "\n"
#~ "    Changes the filename used in stacktraces for the function or macro "
#~ "that\n"
#~ "    follows the attribute.\n"
#~ "\n"
#~ "    Accepts a string. Can be used more than once.\n"
#~ "\n"
#~ "    ### Example\n"
#~ "\n"
#~ "        defmodule M do\n"
#~ "          @doc \"Hello world\"\n"
#~ "          @file \"hello.ex\"\n"
#~ "          def hello do\n"
#~ "            \"world\"\n"
#~ "          end\n"
#~ "        end\n"
#~ "\n"
#~ "  * `@moduledoc`\n"
#~ "\n"
#~ "    Provides documentation for the current module.\n"
#~ "\n"
#~ "    Accepts a string (which is often a heredoc) or `false` where\n"
#~ "    `@moduledoc false` will make the module invisible to the\n"
#~ "    documentation extraction tools like ExDoc.\n"
#~ "\n"
#~ "    ### Example\n"
#~ "\n"
#~ "        defmodule M do\n"
#~ "          @moduledoc \"\"\"\n"
#~ "          A very useful module\n"
#~ "          \"\"\"\n"
#~ "        end\n"
#~ "\n"
#~ "\n"
#~ "  * `@on_definition`\n"
#~ "\n"
#~ "    A hook that will be invoked when each function or macro in the "
#~ "current\n"
#~ "    module is defined. Useful when annotating functions.\n"
#~ "\n"
#~ "    Accepts a module or a tuple `{<module>, <function atom>}`. The "
#~ "function\n"
#~ "    must take 6 arguments:\n"
#~ "\n"
#~ "      - the module environment\n"
#~ "      - kind: `:def`, `:defp`, `:defmacro`, or `:defmacrop`\n"
#~ "      - function/macro name\n"
#~ "      - list of quoted arguments\n"
#~ "      - list of quoted guards\n"
#~ "      - quoted function body\n"
#~ "\n"
#~ "    Note the hook receives the quoted arguments and it is invoked before\n"
#~ "    the function is stored in the module. So `Module.defines?/2` will "
#~ "return\n"
#~ "    `false` for the first clause of every function.\n"
#~ "\n"
#~ "    If the function/macro being defined has multiple clauses, the hook "
#~ "will\n"
#~ "    be called for each clause.\n"
#~ "\n"
#~ "    Unlike other hooks, `@on_definition` will only invoke functions\n"
#~ "    and never macros. This is because the hook is invoked inside the "
#~ "context\n"
#~ "    of the function (and nested function definitions are not allowed in\n"
#~ "    Elixir).\n"
#~ "\n"
#~ "    When just a module is provided, the function is assumed to be\n"
#~ "    `__on_definition__/6`.\n"
#~ "\n"
#~ "    ### Example\n"
#~ "\n"
#~ "        defmodule H do\n"
#~ "          def on_def(_env, kind, name, args, guards, body) do\n"
#~ "            IO.puts \"Defining #{kind} named #{name} with args:\"\n"
#~ "            IO.inspect args\n"
#~ "            IO.puts \"and guards\"\n"
#~ "            IO.inspect guards\n"
#~ "            IO.puts \"and body\"\n"
#~ "            IO.puts Macro.to_string(body)\n"
#~ "          end\n"
#~ "        end\n"
#~ "\n"
#~ "        defmodule M do\n"
#~ "          @on_definition {H, :on_def}\n"
#~ "\n"
#~ "          def hello(arg) when is_binary(arg) or is_list(arg) do\n"
#~ "            \"Hello\" <> to_string(arg)\n"
#~ "          end\n"
#~ "\n"
#~ "          def hello(_) do\n"
#~ "            :ok\n"
#~ "          end\n"
#~ "        end\n"
#~ "\n"
#~ "  * `@on_load`\n"
#~ "\n"
#~ "    A hook that will be invoked whenever the module is loaded.\n"
#~ "\n"
#~ "    Accepts a function atom of a function in the current module. The "
#~ "function\n"
#~ "    must have arity 0 (no arguments) and has to return `:ok`, otherwise "
#~ "the\n"
#~ "    loading of the module will be aborted.\n"
#~ "\n"
#~ "    ### Example\n"
#~ "\n"
#~ "        defmodule M do\n"
#~ "          @on_load :load_check\n"
#~ "\n"
#~ "          def load_check do\n"
#~ "            if some_condition() do\n"
#~ "              :ok\n"
#~ "            else\n"
#~ "              nil\n"
#~ "            end\n"
#~ "          end\n"
#~ "\n"
#~ "          def some_condition do\n"
#~ "            false\n"
#~ "          end\n"
#~ "        end\n"
#~ "\n"
#~ "  * `@vsn`\n"
#~ "\n"
#~ "    Specify the module version. Accepts any valid Elixir value.\n"
#~ "\n"
#~ "    ### Example\n"
#~ "\n"
#~ "        defmodule M do\n"
#~ "          @vsn \"1.0\"\n"
#~ "        end\n"
#~ "\n"
#~ "  * `@external_resource`\n"
#~ "\n"
#~ "    Specifies an external resource to the current module.\n"
#~ "\n"
#~ "    Many times a module embeds information from an external file. This\n"
#~ "    attribute allows the module to annotate which external resources\n"
#~ "    have been used.\n"
#~ "\n"
#~ "    Tools like Mix may use this information to ensure the module is\n"
#~ "    recompiled in case any of the external resources change.\n"
#~ "\n"
#~ "  * `@dialyzer`\n"
#~ "\n"
#~ "    Defines warnings to request or suppress when using a version of\n"
#~ "    `:dialyzer` that supports module attributes.\n"
#~ "\n"
#~ "    Accepts an atom, a tuple, or a list of atoms and tuples.\n"
#~ "\n"
#~ "    For the list of supported warnings, see\n"
#~ "    [`:dialyzer` module](http://www.erlang.org/doc/man/dialyzer.html).\n"
#~ "\n"
#~ "    Multiple uses of `@dialyzer` will accumulate instead of overriding\n"
#~ "    previous ones.\n"
#~ "\n"
#~ "    ### Example\n"
#~ "\n"
#~ "        defmodule M do\n"
#~ "          @dialyzer {:nowarn_function, myfun: 1}\n"
#~ "\n"
#~ "          def myfun(arg) do\n"
#~ "            M.not_a_function(arg)\n"
#~ "          end\n"
#~ "        end\n"
#~ "\n"
#~ "The following attributes are part of typespecs and are also reserved by\n"
#~ "Elixir (see `Kernel.Typespec` for more information about typespecs):\n"
#~ "\n"
#~ "  * `@type`          - defines a type to be used in `@spec`\n"
#~ "  * `@typep`         - defines a private type to be used in `@spec`\n"
#~ "  * `@opaque`        - defines an opaque type to be used in `@spec`\n"
#~ "  * `@spec`          - provides a specification for a function\n"
#~ "  * `@callback`      - provides a specification for a behaviour callback\n"
#~ "  * `@macrocallback` - provides a specification for a macro behaviour "
#~ "callback\n"
#~ "\n"
#~ "In addition to the built-in attributes outlined above, custom attributes "
#~ "may\n"
#~ "also be added. A custom attribute is any valid identifier prefixed with "
#~ "an\n"
#~ "`@` and followed by a valid Elixir value:\n"
#~ "\n"
#~ "    defmodule M do\n"
#~ "      @custom_attr [some: \"stuff\"]\n"
#~ "    end\n"
#~ "\n"
#~ "For more advanced options available when defining custom attributes, see\n"
#~ "`register_attribute/3`.\n"
#~ "\n"
#~ "## Runtime information about a module\n"
#~ "\n"
#~ "It is possible to query a module at runtime to find out which functions "
#~ "and\n"
#~ "macros it defines, extract its docstrings, etc. See `__info__/1`.\n"
#~ msgstr ""
#~ "コンパイル時にモジュールを取り扱う多くの関数を提供します。\n"
#~ "\n"
#~ "それらは、開発者に動的にドキュメントを添付したり、アトリビュートや\n"
#~ "その他を追加、削除、登録することを許可します。\n"
#~ "\n"
#~ "モジュールがコンパイルされた後では、実行時データを調べるそれらのスコー\n"
#~ "プの外にあるため、このモジュールの関数の多くは利用すると、エラーを上げ\n"
#~ "ます。多くの実行時データはそれぞれコンパイルされたモジュールにアタッチ\n"
#~ "された`__info__(attr)`関数により調べることができます。\n"
#~ "\n"
#~ "## モジュールアトリビュート\n"
#~ "\n"
#~ "それぞののモジュールは一つ以上のアトリビュートで装飾することができます。\n"
#~ "以下は現在のElixirで定義されているものです:\n"
#~ "\n"
#~ "  * `@after_compile`\n"
#~ "\n"
#~ "    カレントモジュールがコンパイルされた直後に実行されるフックです。\n"
#~ "\n"
#~ "    モジュールまたは、`{<module>, <function atom>}`タプルを受け付けま"
#~ "す。\n"
#~ "    functionは二つの引数をとらなければなりません: モジュールの環境と\n"
#~ "    バイトコードです。\n"
#~ "    引数としてモジュールのみが提供されたとき、その関数は\n"
#~ "    `__after_compile__/2`であるとされます。\n"
#~ "\n"
#~ "    ### 例\n"
#~ "\n"
#~ "        defmodule M do\n"
#~ "          @after_compile __MODULE__\n"
#~ "\n"
#~ "          def __after_compile__(env, _bytecode) do\n"
#~ "            IO.inspect env\n"
#~ "          end\n"
#~ "        end\n"
#~ "\n"
#~ "  * `@before_compile`\n"
#~ "\n"
#~ "    モジュールがコンパイルされる前に実行されるフックです。\n"
#~ "\n"
#~ "    モジュールまたは、`{<module>, <function/macro atom>}`タプルを受け\n"
#~ "    付けます。そのfunction/macroは一つの引数をとらなければなりません: \n"
#~ "    モジュールの環境です。もしマクロであるならば、その戻値がコンパイルが\n"
#~ "    初まる前にモジュール定義の最後に差し込まれます。\n"
#~ "\n"
#~ "    引数としてモジュールが提供されたとき、その関数/マクロは\n"
#~ "    `__before_compile__/1`であるとされます。\n"
#~ "\n"
#~ "    注: `@after_compile`と異なり、コールバック関数/マクロは\n"
#~ "    別のモジュールに置かれなければなりません(何故なら、\n"
#~ "    コールバックが実行されるとき、カレントモジュールはまだ存在して\n"
#~ "    いないからです)。\n"
#~ "\n"
#~ "    ### 例\n"
#~ "\n"
#~ "        defmodule A do\n"
#~ "          defmacro __before_compile__(_env) do\n"
#~ "            quote do\n"
#~ "              def hello, do: \"world\"\n"
#~ "            end\n"
#~ "          end\n"
#~ "        end\n"
#~ "\n"
#~ "        defmodule B do\n"
#~ "          @before_compile A\n"
#~ "        end\n"
#~ "\n"
#~ "  * `@behaviour`   (英式綴であることに注意してください)\n"
#~ "\n"
#~ "    ビヘイビアはモジュールが要求する`@callback`によって定義された\n"
#~ "    関数を実装することを確実にします。\n"
#~ "\n"
#~ "    例えば、URI.Parserビヘイビアを以下のように指定することができます:\n"
#~ "\n"
#~ "        defmodule URI.Parser do\n"
#~ "          @doc \"Parses the given URL\"\n"
#~ "          @callback parse(uri_info :: URI.t) :: URI.t\n"
#~ "\n"
#~ "          @doc \"Defines a default port\"\n"
#~ "          @callback default_port() :: integer\n"
#~ "        end\n"
#~ "\n"
#~ "        それからモジュールを以下のようにして使います:\n"
#~ "\n"
#~ "        defmodule URI.HTTP d\n"
#~ "          @behaviour URI.Parser\n"
#~ "          def default_port(), do: 80\n"
#~ "          def parse(info), do: info\n"
#~ "        end\n"
#~ "\n"
#~ "    もしビヘイビアが変更したり、URI.HTTPがコールバックを\n"
#~ "    一つでも実装していないなら、警告が上るでしょう。\n"
#~ "\n"
#~ "    OTPあるいはユーザ定義のビヘイビアを指定します。\n"
#~ "\n"
#~ "\n"
#~ "    ### 例\n"
#~ "\n"
#~ "        defmodule M do\n"
#~ "          @behaviour gen_event\n"
#~ "\n"
#~ "          # ...\n"
#~ "        end\n"
#~ "\n"
#~ "  * `@compile`\n"
#~ "\n"
#~ "    モジュールのErlangコンパイラに渡されるコンパイルオプションを定義しま"
#~ "す。\n"
#~ "\n"
#~ "    アトム、タプルあるいはアトムやタプルのリストを受け付けます。\n"
#~ "\n"
#~ "    サポートされるオプションのリストについては、Erlangの\n"
#~ "    [`:compile` モジュール](http://www.erlang.org/doc/man/compile.html)\n"
#~ "    を参照してください。\n"
#~ "\n"
#~ "    '@compile`を何度か使うと、前のものを上書きするかわりに、\n"
#~ "    累積します。\n"
#~ "\n"
#~ "    ### 例\n"
#~ "\n"
#~ "          defmodule M do\n"
#~ "            @compile {:inline, myfun: 1}\n"
#~ "\n"
#~ "            def myfun(arg) do\n"
#~ "              to_string(arg)\n"
#~ "            end\n"
#~ "          end\n"
#~ "\n"
#~ "  * `@doc`\n"
#~ "\n"
#~ "    アトリビュートの後の関数またはマクロへのドキュメントを提供します。\n"
#~ "\n"
#~ "    文字列(しばしばヒアドキュメントです)または、`false`を受け付けます。\n"
#~ "    `@doc false`とした関数/マクロはExDocの様なドキュメント抽出ツールに\n"
#~ "    より非表示にされるでしょう。\n"
#~ "\n"
#~ "    ひとつ以上記述することができます。\n"
#~ "\n"
#~ "    ### 例\n"
#~ "\n"
#~ "          defmodule M do\n"
#~ "            @doc \"Hello world\"\n"
#~ "            def hello do\n"
#~ "              \"world\"\n"
#~ "            end\n"
#~ "\n"
#~ "            @doc \"\"\"\n"
#~ "            Sums `a` to `b`.\n"
#~ "            \"\"\"\n"
#~ "            def sum(a, b) do\n"
#~ "              a + b\n"
#~ "            end\n"
#~ "          end\n"
#~ "\n"
#~ "  * `@file`\n"
#~ "\n"
#~ "    アトリビュートの後の関数またはマクロについてのスタックトレースで\n"
#~ "    使われるファイル名を変更します。\n"
#~ "\n"
#~ "    文字列を受け付けます。ひとつ以上使うことができます。\n"
#~ "\n"
#~ "    ### 例\n"
#~ "\n"
#~ "          defmodule M do\n"
#~ "            @doc \"Hello world\"\n"
#~ "            @file \"hello.ex\"\n"
#~ "            def hello do\n"
#~ "              \"world\"\n"
#~ "            end\n"
#~ "          end\n"
#~ "\n"
#~ "  * `@moduledoc`\n"
#~ "\n"
#~ "    カレントモジュールについてのドキュメントを提供します。\n"
#~ "\n"
#~ "    文字列(しばしばヒアドキュメントです)または、`false`を受け付けます。\n"
#~ "    `@moduledoc false`としたモジュールはExDocの様なドキュメント抽出\n"
#~ "    ツールにより非表示にされるでしょう。\n"
#~ "\n"
#~ "    ### 例\n"
#~ "\n"
#~ "          defmodule M do\n"
#~ "            @moduledoc \"\"\"\n"
#~ "            A very useful module\n"
#~ "            \"\"\"\n"
#~ "          end\n"
#~ "\n"
#~ "\n"
#~ "  * `@on_definition`\n"
#~ "\n"
#~ "    カレントモジュールのそれぞれの関数あるいはマクロが定義されたれた時\n"
#~ "    に実行されるフックです。関数に注をつけるときに役に立ちます。\n"
#~ "\n"
#~ "    モジュールあるいは、`{<module>, <function atom>}`タプルを受け付けま"
#~ "す。\n"
#~ "    関数は6個の引数を取らなければなりません: \n"
#~ "\n"
#~ "      - モジュールの環境\n"
#~ "      - 種類: `:def`, `:defp`, `:defmacro`, あるいは `:defmacrop`\n"
#~ "      - 関数/マクロの名前\n"
#~ "      - quoteされた引数のリスト\n"
#~ "      - quoteされたガードのリスト\n"
#~ "      - quoteされた関数本体\n"
#~ "\n"
#~ "    フックは、関数がモジュールにストアされる前に実行され、\n"
#~ "    quoteされた引数を受信することに注意してください。\n"
#~ "    だから、`Module.defines?/2`はそれぞれの関数について最初の節の\n"
#~ "    ため`false`で返るでしょう。\n"
#~ "\n"
#~ "    もし定義しようとしている関数/マクロが複数の節をもつなら、\n"
#~ "    フックはそれぞれの節毎に呼ばれるでしょう。\n"
#~ "\n"
#~ "    他のフックと異なり、`@on_definition`はマクロでは決してなく、\n"
#~ "    関数だけを実行します。これは、関数のコンテキストの内側で\n"
#~ "    フックが実行されるからです(そしてElixirはネストした関数定義は\n"
#~ "    許されていないのです)。\n"
#~ "\n"
#~ "    引数としてモジュールのみが提供されたとき、その関数は\n"
#~ "    `__on_definition__/6` であるとされます。\n"
#~ "\n"
#~ "    ### 例\n"
#~ "\n"
#~ "          defmodule H do\n"
#~ "            def on_def(_env, kind, name, args, guards, body) do\n"
#~ "              IO.puts \"Defining #{kind} named #{name} with args:\"\n"
#~ "              IO.inspect args\n"
#~ "              IO.puts \"and guards\"\n"
#~ "              IO.inspect guards\n"
#~ "              IO.puts \"and body\"\n"
#~ "              IO.puts Macro.to_string(body)\n"
#~ "            end\n"
#~ "          end\n"
#~ "\n"
#~ "          defmodule M do\n"
#~ "            @on_definition {H, :on_def}\n"
#~ "\n"
#~ "            def hello(arg) when is_binary(arg) or is_list(arg) do\n"
#~ "              \"Hello\" <> to_string(arg)\n"
#~ "            end\n"
#~ "\n"
#~ "            def hello(_) do\n"
#~ "              :ok\n"
#~ "            end\n"
#~ "          end\n"
#~ "\n"
#~ "  * `@on_load`\n"
#~ "\n"
#~ "    モジュールがロードされる時には何時でも実行されるフックです。    \n"
#~ "\n"
#~ "    カレントモジュール内の関数名を示すアトムを\n"
#~ "    受け付けます。関数は、アリティ0(引数なし)で、`:ok`を返さなければ\n"
#~ "    なりません。さもなくば、モジュールのローディングは中止されます。\n"
#~ "\n"
#~ "    ### 例\n"
#~ "\n"
#~ "          defmodule M do\n"
#~ "            @on_load :load_check\n"
#~ "\n"
#~ "            def load_check do\n"
#~ "              if some_condition() do\n"
#~ "                :ok\n"
#~ "              else\n"
#~ "                nil\n"
#~ "              end\n"
#~ "            end\n"
#~ "\n"
#~ "            def some_condition do\n"
#~ "              false\n"
#~ "            end\n"
#~ "          end\n"
#~ "\n"
#~ "  * `@vsn`\n"
#~ "\n"
#~ "    モジュールのバージョンを指定します。任意の正しいElixirの値を\n"
#~ "    受け付けます。\n"
#~ "\n"
#~ "    ### 例\n"
#~ "\n"
#~ "          defmodule M do\n"
#~ "            @vsn \"1.0\"\n"
#~ "          end\n"
#~ "\n"
#~ "  * `@external_resource`\n"
#~ "\n"
#~ "    カレントモジュールに外部リソースを指定します。\n"
#~ "\n"
#~ "    しばしば、モジュールは外部から情報を埋め込みます。\n"
#~ "    このアトリビュートはモジュールにどの外部リソースが使われたかに\n"
#~ "    ついて注釈を付けることを許可します。\n"
#~ "\n"
#~ "    Mixの様なツールはこの情報を、外部リソースが変更された場合に\n"
#~ "    モジュールが再コンパイルされることを確実にするために、使うかも\n"
#~ "    しれません。\n"
#~ "\n"
#~ "  * `@dialyzer`\n"
#~ "\n"
#~ "    モジュールアトリビュートをサポートする\n"
#~ "    `:dialyzer`のバージョンを使用している時に、\n"
#~ "    要求または抑制するwarningを定義します。\n"
#~ "\n"
#~ "    アトム、タプルまたはアトムとタプルのリストを受け付けます。\n"
#~ "\n"
#~ "    サポートしているwarningのリストは\n"
#~ "    [`:dialyzer モジュール](http://www.erlang.org/doc/man/dialyzer.html)\n"
#~ "    を参照してください。\n"
#~ "\n"
#~ "    `@dialyzer`を何度か使うと以前の値を上書きするかわりに\n"
#~ "    累積されます。\n"
#~ "\n"
#~ "    ### Example\n"
#~ "\n"
#~ "          defmodule M do\n"
#~ "            @dialyzer {:nowarn_function, myfun: 1}\n"
#~ "\n"
#~ "            def myfun(arg) do\n"
#~ "              M.not_a_function(arg)\n"
#~ "            end\n"
#~ "          end\n"
#~ "\n"
#~ "以下のアトリビュートはtypespecの一部で、Elixirにより予約されています\n"
#~ "(typespecについての詳細は`Kernel.Typespec`を参照してください):\n"
#~ "\n"
#~ "  * `@type`          - `@spec` でタイプの定義に使われます。\n"
#~ "  * `@typep`         - `@spec`でプライベートタイプの定義に使われます。\n"
#~ "  * `@opaque`        - `@spec`不透明なタイプの定義に使われます。\n"
#~ "  * `@spec`          - 関数のspecを提供します。\n"
#~ "  * `@callback`      - ビヘイビアコールバックのspecを提供します。\n"
#~ "  * `@macrocallback` - マクロビヘイビアコールバックのspecを提供します。\n"
#~ "\n"
#~ "上で概説されたビルトインのアトリビュートに加えて、カスタムアトリビュート"
#~ "も\n"
#~ "追加できます。カスタムアトリビュートは`@`が前についた有効な識別子なら\n"
#~ "なんてもよく、後ろにElixirの値がつきます:\n"
#~ "\n"
#~ "      defmodule M do\n"
#~ "        @custom_attr [some: \"stuff\"]\n"
#~ "      end\n"
#~ "\n"
#~ "カスタムアトリビュートの定義時のより進んだオプションについては\n"
#~ "`register_attribute/3`を参照してください。\n"
#~ "\n"
#~ "## モジュールについての実行時情報\n"
#~ "\n"
#~ "どの関数やマクロが定義を見付けるため、あるいはドキュメント\n"
#~ "文字列を抽出するために、実行時にモジュールに問合せることが可能です。\n"
#~ "`__info__/1`を参照してください。\n"
