msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2015-05-20 21:54+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: Elixir.Module Summary
#: lib/module.ex:1
msgid ""
"This module provides many functions to deal with modules during\n"
"compilation time. It allows a developer to dynamically attach\n"
"documentation, add, delete and register attributes and so forth.\n"
"\n"
"After a module is compiled, using many of the functions in\n"
"this module will raise errors, since it is out of their scope\n"
"to inspect runtime data. Most of the runtime data can be inspected\n"
"via the `__info__(attr)` function attached to each compiled module.\n"
"\n"
"## Module attributes\n"
"\n"
"Each module can be decorated with one or more attributes. The following "
"ones\n"
"are currently defined by Elixir:\n"
"\n"
"  * `@after_compile`\n"
"\n"
"    A hook that will be invoked right after the current module is compiled.\n"
"\n"
"    Accepts a module or a tuple `{<module>, <function atom>}`. The function\n"
"    must take two arguments: the module environment and its bytecode.\n"
"    When just a module is provided, the function is assumed to be\n"
"    `__after_compile__/2`.\n"
"\n"
"    ### Example\n"
"\n"
"        defmodule M do\n"
"          @after_compile __MODULE__\n"
"\n"
"          def __after_compile__(env, _bytecode) do\n"
"            IO.inspect env\n"
"          end\n"
"        end\n"
"\n"
"  * `@before_compile`\n"
"\n"
"    A hook that will be invoked before the module is compiled.\n"
"\n"
"    Accepts a module or a tuple `{<module>, <function/macro atom>}`. The\n"
"    function/macro must take one argument: the module environment. If it's "
"a\n"
"    macro, its returned value will be injected at the end of the module "
"definition\n"
"    before the compilation starts.\n"
"\n"
"    When just a module is provided, the function/macro is assumed to be\n"
"    `__before_compile__/1`.\n"
"\n"
"    Note: unlike `@after_compile`, the callback function/macro must\n"
"    be placed in a separate module (because when the callback is invoked,\n"
"    the current module does not yet exist).\n"
"\n"
"    ### Example\n"
"\n"
"        defmodule A do\n"
"          defmacro __before_compile__(_env) do\n"
"            quote do\n"
"              def hello, do: \"world\"\n"
"            end\n"
"          end\n"
"        end\n"
"\n"
"        defmodule B do\n"
"          @before_compile A\n"
"        end\n"
"\n"
"  * `@behaviour`   (notice the British spelling)\n"
"\n"
"    Specifies an OTP or user-defined behaviour.\n"
"\n"
"    ### Example\n"
"\n"
"        defmodule M do\n"
"          @behaviour gen_event\n"
"\n"
"          # ...\n"
"        end\n"
"\n"
"  * `@compile`\n"
"\n"
"    Defines options for module compilation that are passed to the Erlang\n"
"    compiler.\n"
"\n"
"    Accepts an atom, a tuple, or a list of atoms and tuples.\n"
"\n"
"    See http://www.erlang.org/doc/man/compile.html for the list of "
"supported\n"
"    options.\n"
"\n"
"    Several uses of `@compile` will accumulate instead of overriding\n"
"    previous ones.\n"
"\n"
"    ### Example\n"
"\n"
"          defmodule M do\n"
"            @compile {:inline, myfun: 1}\n"
"\n"
"            def myfun(arg) do\n"
"              to_string(arg)\n"
"            end\n"
"          end\n"
"\n"
"  * `@doc`\n"
"\n"
"    Provides documentation for the function or macro that follows the\n"
"    attribute.\n"
"\n"
"    Accepts a string (often a heredoc) or `false` where `@doc false` will\n"
"    make the function/macro invisible to the documentation extraction tools\n"
"    like ExDoc.\n"
"\n"
"    Can be invoked more than once.\n"
"\n"
"    ### Example\n"
"\n"
"          defmodule M do\n"
"            @doc \"Hello world\"\n"
"            def hello do\n"
"              \"world\"\n"
"            end\n"
"\n"
"            @doc \"\"\"\n"
"            Sum.\n"
"            \"\"\"\n"
"            def sum(a, b) do\n"
"              a + b\n"
"            end\n"
"          end\n"
"\n"
"  * `@file`\n"
"\n"
"    Changes the filename used in stacktraces for the function or macro that\n"
"    follows the attribute.\n"
"\n"
"    Accepts a string. Can be used more than once.\n"
"\n"
"    ### Example\n"
"\n"
"          defmodule M do\n"
"            @doc \"Hello world\"\n"
"            @file \"hello.ex\"\n"
"            def hello do\n"
"              \"world\"\n"
"            end\n"
"          end\n"
"\n"
"  * `@moduledoc`\n"
"\n"
"    Provides documentation for the current module.\n"
"\n"
"    Accepts a string (which is often a heredoc) or `false` where\n"
"    `@moduledoc false` will make the module invisible to the\n"
"    documentation extraction tools like ExDoc.\n"
"\n"
"    ### Example\n"
"\n"
"          defmodule M do\n"
"            @moduledoc \"\"\"\n"
"            A very useful module\n"
"            \"\"\"\n"
"          end\n"
"\n"
"\n"
"  * `@on_definition`\n"
"\n"
"    A hook that will be invoked when each function or macro in the current\n"
"    module is defined. Useful when annotating functions.\n"
"\n"
"    Accepts a module or a tuple `{<module>, <function atom>}`. The function\n"
"    must take 6 arguments:\n"
"\n"
"      - the module environment\n"
"      - kind: `:def`, `:defp`, `:defmacro`, or `:defmacrop`\n"
"      - function/macro name\n"
"      - list of expanded arguments\n"
"      - list of expanded guards\n"
"      - expanded function body\n"
"\n"
"    Note the hook receives the expanded arguments and it is invoked before\n"
"    the function is stored in the module. So `Module.defines?/2` will "
"return\n"
"    false for the first clause of every function.\n"
"\n"
"    If the function/macro being defined has multiple clauses, the hook will\n"
"    be called for each clause.\n"
"\n"
"    Unlike other hooks, `@on_definition` will only invoke functions\n"
"    and never macros. This is because the hook is invoked inside the "
"context\n"
"    of the function (and nested function definitions are not allowed in\n"
"    Elixir).\n"
"\n"
"    When just a module is provided, the function is assumed to be\n"
"    `__on_definition__/6`.\n"
"\n"
"    ### Example\n"
"\n"
"          defmodule H do\n"
"            def on_def(_env, kind, name, args, guards, body) do\n"
"              IO.puts \"Defining #{kind} named #{name} with args:\"\n"
"              IO.inspect args\n"
"              IO.puts \"and guards\"\n"
"              IO.inspect guards\n"
"              IO.puts \"and body\"\n"
"              IO.puts Macro.to_string(body)\n"
"            end\n"
"          end\n"
"\n"
"          defmodule M do\n"
"            @on_definition {H, :on_def}\n"
"\n"
"            def hello(arg) when is_binary(arg) or is_list(arg) do\n"
"              \"Hello\" <> to_string(arg)\n"
"            end\n"
"\n"
"            def hello(_) do\n"
"              :ok\n"
"            end\n"
"          end\n"
"\n"
"  * `@on_load`\n"
"\n"
"    A hook that will be invoked whenever the module is loaded.\n"
"\n"
"    Accepts a function atom of a function in the current module. The "
"function\n"
"    must have arity 0 (no arguments) and has to return `:ok`, otherwise the\n"
"    loading of the module will be aborted.\n"
"\n"
"    ### Example\n"
"\n"
"          defmodule M do\n"
"            @on_load :load_check\n"
"\n"
"            def load_check do\n"
"              if some_condition() do\n"
"                :ok\n"
"              else\n"
"                nil\n"
"              end\n"
"            end\n"
"\n"
"            def some_condition do\n"
"              false\n"
"            end\n"
"          end\n"
"\n"
"  * `@vsn`\n"
"\n"
"    Specify the module version. Accepts any valid Elixir value.\n"
"\n"
"    ### Example\n"
"\n"
"          defmodule M do\n"
"            @vsn \"1.0\"\n"
"          end\n"
"\n"
"  * `@external_resource`\n"
"\n"
"    Specifies an external resource to the current module.\n"
"\n"
"    Many times a module embeds information from an external file. This\n"
"    attribute allows the module to annotate which external resources\n"
"    have been used.\n"
"\n"
"    Tools like Mix may use this information to ensure the module is\n"
"    recompiled in case any of the external resources change.\n"
"\n"
"The following attributes are part of typespecs and are also reserved by\n"
"Elixir (see `Kernel.Typespec` for more information about typespecs):\n"
"\n"
"  * `@type`        - defines a type to be used in `@spec`\n"
"  * `@typep`       - defines a private type to be used in `@spec`\n"
"  * `@opaque`      - defines an opaque type to be used in `@spec`\n"
"  * `@spec`        - provides a specification for a function\n"
"  * `@callback`    - provides a specification for the behaviour callback\n"
"\n"
"In addition to the built-in attributes outlined above, custom attributes "
"may\n"
"also be added. A custom attribute is any valid identifier prefixed with an\n"
"`@` and followed by a valid Elixir value:\n"
"\n"
"      defmodule M do\n"
"        @custom_attr [some: \"stuff\"]\n"
"      end\n"
"\n"
"For more advanced options available when defining custom attributes, see\n"
"`register_attribute/3`.\n"
"\n"
"## Runtime information about a module\n"
"\n"
"It is possible to query a module at runtime to find out which functions and\n"
"macros it defines, extract its docstrings, etc. See `__info__/1`.\n"
msgstr ""
"このモジュールはコンパイル時にモジュールを取り扱う多くの関数を提供しま\n"
"す。それらは、開発者に動的にドキュメントを添付したり、アトリビュートや\n"
"その他を追加、削除、登録することを許可します。\n"
"\n"
"モジュールがコンパイルされた後では、実行時データを調べるそれらのスコー\n"
"プの外にあるため、このモジュールの関数の多くは利用すると、エラーを上げ\n"
"ます。多くの実行時データはそれぞれコンパイルされたモジュールにアタッチ\n"
"された`__info__(attr)`関数により調べることができます。\n"
"\n"
"## モジュールアトリビュート\n"
"\n"
"それぞののモジュールは一つ以上のアトリビュートで装飾することができます。\n"
"以下は現在のElixirで定義されているものです:\n"
"\n"
"  * `@after_compile`\n"
"\n"
"    カレントモジュールがコンパイルされた直後に実行されるフックです。\n"
"\n"
"    モジュールまたは、`{<module>, <function atom>}`タプルを受け付けます。\n"
"    functionは二つの引数をとらなければなりません: モジュールの環境と\n"
"    バイトコードです。\n"
"    引数としてモジュールのみが提供されたとき、その関数は\n"
"     `__after_compile__/2`であるとされます。\n"
"\n"
"    ### 例\n"
"\n"
"        defmodule M do\n"
"          @after_compile __MODULE__\n"
"\n"
"          def __after_compile__(env, _bytecode) do\n"
"            IO.inspect env\n"
"          end\n"
"        end\n"
"\n"
"  * `@before_compile`\n"
"\n"
"    モジュールがコンパイルされる前に実行されるフックです。\n"
"\n"
"    モジュールまたは、`{<module>, <function/macro atom>}`タプルを受け\n"
"    付けます。そのfunction/macroは一つの引数をとらなければなりません: \n"
"    モジュールの環境です。もしマクロであるならば、その戻値がコンパイルが\n"
"    初まる前にモジュール定義の最後に差し込まれます。\n"
"\n"
"    引数としてモジュールが提供されたとき、その関数/マクロは\n"
"     `__before_compile__/1`であるとされます。\n"
"\n"
"    注: `@after_compile`と異なり、コールバック関数/マクロは\n"
"    別のモジュールに置かれなければなりません(何故なら、\n"
"    コールバックが実行されるとき、カレントモジュールはまだ存在して\n"
"    いないからです)。\n"
"\n"
"    ### 例\n"
"\n"
"        defmodule A do\n"
"          defmacro __before_compile__(_env) do\n"
"            quote do\n"
"              def hello, do: \"world\"\n"
"            end\n"
"          end\n"
"        end\n"
"\n"
"        defmodule B do\n"
"          @before_compile A\n"
"        end\n"
"\n"
"  * `@behaviour`   (英式綴であることに注意してください)\n"
"\n"
"    OTPまたはユーザ定義のビヘイビアを指定します。\n"
"\n"
"    ### 例\n"
"\n"
"        defmodule M do\n"
"          @behaviour gen_event\n"
"\n"
"          # ...\n"
"        end\n"
"\n"
"  * `@compile`\n"
"\n"
"    モジュールのErlangコンパイラに渡されるコンパイルオプションを定義しま"
"す。\n"
"\n"
"    アトム、タプルあるいはアトムやタプルのリストを受け付けます。\n"
"\n"
"    サポートされるオプションのリストについては\n"
"    http://www.erlang.org/doc/man/compile.html\n"
"    を参照してください。\n"
"\n"
"    '@compile`を何度か使うと、前のものを上書きするかわりに、\n"
"    累積します。\n"
"\n"
"    ### 例\n"
"\n"
"          defmodule M do\n"
"            @compile {:inline, myfun: 1}\n"
"\n"
"            def myfun(arg) do\n"
"              to_string(arg)\n"
"            end\n"
"          end\n"
"\n"
"  * `@doc`\n"
"\n"
"    アトリビュートの後の関数またはマクロへのドキュメントを提供します。\n"
"\n"
"    文字列(しばしばヒアドキュメントです)または、`false`を受け付けます。\n"
"    `@doc false`とした関数/マクロはExDocの様なドキュメント抽出ツールに\n"
"    より非表示にされるでしょう。\n"
"\n"
"    ひとつ以上記述することができます。\n"
"\n"
"    ### 例\n"
"\n"
"          defmodule M do\n"
"            @doc \"Hello world\"\n"
"            def hello do\n"
"              \"world\"\n"
"            end\n"
"\n"
"            @doc \"\"\"\n"
"            Sum.\n"
"            \"\"\"\n"
"            def sum(a, b) do\n"
"              a + b\n"
"            end\n"
"          end\n"
"\n"
"  * `@file`\n"
"\n"
"    アトリビュートの後の関数またはマクロについてのスタックトレースで\n"
"    使われるファイル名を変更します。\n"
"\n"
"    文字列を受け付けます。ひとつ以上使うことができます。\n"
"\n"
"    ### 例\n"
"\n"
"          defmodule M do\n"
"            @doc \"Hello world\"\n"
"            @file \"hello.ex\"\n"
"            def hello do\n"
"              \"world\"\n"
"            end\n"
"          end\n"
"\n"
"  * `@moduledoc`\n"
"\n"
"    カレントモジュールについてのドキュメントを提供します。\n"
"\n"
"    文字列(しばしばヒアドキュメントです)または、`false`を受け付けます。\n"
"    `@moduledoc false`としたモジュールはExDocの様なドキュメント抽出\n"
"    ツールにより非表示にされるでしょう。\n"
"\n"
"    ### 例\n"
"\n"
"          defmodule M do\n"
"            @moduledoc \"\"\"\n"
"            A very useful module\n"
"            \"\"\"\n"
"          end\n"
"\n"
"\n"
"  * `@on_definition`\n"
"\n"
"    カレントモジュールのそれぞれの関数あるいはマクロが定義されたれた時\n"
"    に実行されるフックです。関数に注をつけるときに役に立ちます。\n"
"\n"
"    モジュールあるいは、`{<module>, <function atom>}`タプルを受け付けます。\n"
"    関数は6個の引数を取らなければなりません: \n"
"\n"
"      - モジュールの環境\n"
"      - 種類: `:def`, `:defp`, `:defmacro`, あるいは `:defmacrop`\n"
"      - 関数/マクロの名前\n"
"      - 展開された引数のリスト\n"
"      - 展開されたガードのリスト\n"
"      - 展開された関数本体\n"
"\n"
"    フックは、関数がモジュールにストアされる前に実行され、\n"
"    展開された引数を受信することに注意してください。\n"
"    だから、`Module.defines?/2`はそれぞれの関数について最初の節の\n"
"    ためfalseで返るでしょう。\n"
"\n"
"    もし定義しようとしている関数/マクロが複数の節をもつなら、\n"
"    フックはそれぞれの節毎に呼ばれるでしょう。\n"
"\n"
"    他のフックと異なり、`@on_definition`はマクロでは決してなく、\n"
"    関数だけを実行します。これは、関数のコンテキストの内側で\n"
"    フックが実行されるからです(そしてElixirはネストした関数定義は\n"
"    許されていないのです)。\n"
"\n"
"    引数としてモジュールのみが提供されたとき、その関数は\n"
"    `__on_definition__/6` であるとされます。\n"
"\n"
"    ### 例\n"
"\n"
"          defmodule H do\n"
"            def on_def(_env, kind, name, args, guards, body) do\n"
"              IO.puts \"Defining #{kind} named #{name} with args:\"\n"
"              IO.inspect args\n"
"              IO.puts \"and guards\"\n"
"              IO.inspect guards\n"
"              IO.puts \"and body\"\n"
"              IO.puts Macro.to_string(body)\n"
"            end\n"
"          end\n"
"\n"
"          defmodule M do\n"
"            @on_definition {H, :on_def}\n"
"\n"
"            def hello(arg) when is_binary(arg) or is_list(arg) do\n"
"              \"Hello\" <> to_string(arg)\n"
"            end\n"
"\n"
"            def hello(_) do\n"
"              :ok\n"
"            end\n"
"          end\n"
"\n"
"  * `@on_load`\n"
"\n"
"    モジュールがロードされる時には何時でも実行されるフックです。    \n"
"\n"
"    カレントモジュール内の関数名を示すアトムを\n"
"    受け付けます。関数は、アリティ0(引数なし)で、`:ok`を返さなければ\n"
"    なりません。さもなくば、モジュールのローディングは中止されます。\n"
"\n"
"    ### 例\n"
"\n"
"          defmodule M do\n"
"            @on_load :load_check\n"
"\n"
"            def load_check do\n"
"              if some_condition() do\n"
"                :ok\n"
"              else\n"
"                nil\n"
"              end\n"
"            end\n"
"\n"
"            def some_condition do\n"
"              false\n"
"            end\n"
"          end\n"
"\n"
"  * `@vsn`\n"
"\n"
"    モジュールのバージョンを指定します。任意の正しいElixirの値を\n"
"    受け付けます。\n"
"\n"
"    ### 例\n"
"\n"
"          defmodule M do\n"
"            @vsn \"1.0\"\n"
"          end\n"
"\n"
"  * `@external_resource`\n"
"\n"
"    カレントモジュールに外部リソースを指定します。\n"
"\n"
"    しばしば、モジュールは外部から情報を埋め込みます。\n"
"    このアトリビュートはモジュールにどの外部リソースが使われたかに\n"
"    ついて注釈を付けることを許可します。\n"
"\n"
"    Mixの様なツールはこの情報を、外部リソースが変更された場合に\n"
"    モジュールが再コンパイルされることを確実にするために、使うかも\n"
"    しれません。\n"
"\n"
"以下のアトリビュートはtypespecの一部で、Elixirにより予約されています\n"
"(typespecについての詳細は`Kernel.Typespec`を参照してください):\n"
"\n"
"  * `@type`        - `@spec` でタイプの定義に使われます。\n"
"  * `@typep`       - `@spec`でプライベートタイプの定義に使われます。\n"
"  * `@opaque`      - `@spec`不透明なタイプの定義に使われます。\n"
"  * `@spec`        - 関数のspecを提供します。\n"
"  * `@callback`    - ビヘイビアコールバックのspecを提供します。\n"
"\n"
"上で概説されたビルトインのアトリビュートに加えて、カスタムアトリビュートも\n"
"追加できます。カスタムアトリビュートは`@`が前についた有効な識別子なら\n"
"なんてもよく、後ろにElixirの値がつきます:\n"
"\n"
"      defmodule M do\n"
"        @custom_attr [some: \"stuff\"]\n"
"      end\n"
"\n"
"カスタムアトリビュートの定義時のより進んだオプションについては\n"
"`register_attribute/3`を参照してください。\n"
"\n"
"## モジュールについての実行時情報\n"
"\n"
"どの関数やマクロが定義を見付けるため、あるいはドキュメント\n"
"文字列を抽出するために、実行時にモジュールに問合せることが可能です。\n"
"`__info__/1`を参照してください。\n"

#. TRANSLATORS: def Module.overridable?(module, tuple)
#: lib/module.ex:713
msgid "Returns `true` if `tuple` in `module` is marked as overridable.\n"
msgstr ""
"もし、`module`の中の`tuple`がoverridableとしてマークされていれば、\n"
"`true`を返します。\n"

#. TRANSLATORS: def Module.register_attribute(module, new, opts)
#: lib/module.ex:829
msgid ""
"Registers an attribute. By registering an attribute, a developer\n"
"is able to customize how Elixir will store and accumulate the\n"
"attribute values.\n"
"\n"
"## Options\n"
"\n"
"When registering an attribute, two options can be given:\n"
"\n"
"  * `:accumulate` - several calls to the same attribute will\n"
"    accumulate instead of override the previous one. New attributes\n"
"    are always added to the top of the accumulated list.\n"
"\n"
"  * `:persist` - the attribute will be persisted in the Erlang\n"
"    Abstract Format. Useful when interfacing with Erlang libraries.\n"
"\n"
"By default, both options are `false`.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule MyModule do\n"
"      Module.register_attribute __MODULE__,\n"
"        :custom_threshold_for_lib,\n"
"        accumulate: true, persist: false\n"
"\n"
"      @custom_threshold_for_lib 10\n"
"      @custom_threshold_for_lib 20\n"
"      @custom_threshold_for_lib #=> [20, 10]\n"
"    end\n"
"\n"
msgstr ""
"アトリビュートを登録します。アトリビュートを登録するとき、\n"
"開発者は、Elixirがアトリビュート値を保存して、累積する方法を、\n"
"カスタマイズできます。\n"
"\n"
"## オプション\n"
"\n"
"アトリビュートを登録するとき、二つのオプションを与えることができます:\n"
"\n"
"  * `:accumulate` - 同じアトリビュートへの幾つかの呼び出しは、\n"
"     前のものを上書きする替わりに累積します。新しいアトリビュートは\n"
"     常に累積リストの先頭に追加されます。\n"
"\n"
"  * `:persist` - アトリビュートはErlang Abstract Formatで保存\n"
"     されます。Erlangライブラリと相互作用するとき役立ちます。\n"
"\n"
"デフォルトでは、両方のオプションは`false`です。\n"
"\n"
"## 例\n"
"\n"
"    defmodule MyModule do\n"
"      Module.register_attribute __MODULE__,\n"
"        :custom_threshold_for_lib,\n"
"        accumulate: true, persist: false\n"
"\n"
"      @custom_threshold_for_lib 10\n"
"      @custom_threshold_for_lib 20\n"
"      @custom_threshold_for_lib #=> [20, 10]\n"
"    end\n"
"\n"

#. TRANSLATORS: def Module.put_attribute(module, key, value)
#: lib/module.ex:729
msgid ""
"Puts an Erlang attribute to the given module with the given\n"
"key and value. The semantics of putting the attribute depends\n"
"if the attribute was registered or not via `register_attribute/3`.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule MyModule do\n"
"      Module.put_attribute __MODULE__, :custom_threshold_for_lib, 10\n"
"    end\n"
"\n"
msgstr ""
"Erlangアトリビュートを与えられたモジュールに与えられたキーと値でプット\n"
"します。アトリビュートをプットするセマンティクスは、\n"
"`register_attribute/3`によってアトリビュートが登録されていたか否かに、\n"
"依存します。\n"
"\n"
"## 例\n"
"\n"
"    defmodule MyModule do\n"
"      Module.put_attribute __MODULE__, :custom_threshold_for_lib, 10\n"
"    end\n"
"\n"

#. TRANSLATORS: def Module.__info__(kind)
#: lib/module.ex:308
msgid ""
"Provides runtime information about functions and macros defined by the\n"
"module, enables docstring extraction, etc.\n"
"\n"
"Each module gets an `__info__/1` function when it's compiled. The function\n"
"takes one of the following atoms:\n"
"\n"
"  * `:functions`  - keyword list of public functions along with their "
"arities\n"
"\n"
"  * `:macros`     - keyword list of public macros along with their arities\n"
"\n"
"  * `:module`     - module name (`Module == Module.__info__(:module)`)\n"
"\n"
"In addition to the above, you may also pass to `__info__/1` any atom "
"supported\n"
"by Erlang's `module_info` function which also gets defined for each "
"compiled\n"
"module. See http://erlang.org/doc/reference_manual/modules.html#id69430 for\n"
"more information.\n"
msgstr ""
"モジュールで定義された、関数とマクロについての実行時情報を提供して、\n"
"docstringの抽出などを可能にします。\n"
"\n"
"それぞれのモジュールはコンパイル時に`__info__/1`関数を取得します。\n"
"関数は以下のアトムを引数として取ります:\n"
"\n"
"  * `:functions`  -  公開関数とそのアリティのキーワードリスト\n"
"\n"
"  * `:macros`     -  公開マクロとそのアリティのキーワードリスト\n"
"\n"
"  * `:module`     -  モジュール名 (`Module == Module.__info__(:module)`)\n"
"\n"
"上記に加えて、`__info__/1`に、コンパイルされたモジュール毎に定義される\n"
"Erlangの `module_info`関数でサポートされた、任意のアトムをパスすること\n"
"も出来ます。詳細は、\n"
"http://erlang.org/doc/reference_manual/modules.html#id69430 を参照して\n"
"ください。\n"

#. TRANSLATORS: def Module.make_overridable(module, tuples)
#: lib/module.ex:684
msgid ""
"Makes the given functions in `module` overridable.\n"
"An overridable function is lazily defined, allowing a\n"
"developer to customize it. See `Kernel.defoverridable/1` for\n"
"more information and documentation.\n"
msgstr ""
"`module`の与えられた関数をoverridableにします。\n"
"overridable関数は、遅延して定義され、\n"
"開発者にカスタマイズすることを許します。\n"
"詳細については、`Kernel.defoverridable/1` を参照してください。\n"

#. TRANSLATORS: def Module.split(module)
#: lib/module.ex:853
msgid ""
"Splits the given module name into binary parts.\n"
"\n"
"## Examples\n"
"\n"
"    Module.split Very.Long.Module.Name.And.Even.Longer\n"
"    #=> [\"Very\", \"Long\", \"Module\", \"Name\", \"And\", \"Even\", "
"\"Longer\"]\n"
"\n"
msgstr ""
"与えられたモジュール名をバイナリの部分に分割します。\n"
"\n"
"## 例\n"
"\n"
"    Module.split Very.Long.Module.Name.And.Even.Longer\n"
"    #=> [\"Very\", \"Long\", \"Module\", \"Name\", \"And\", \"Even\", "
"\"Longer\"]\n"
"\n"

#. TRANSLATORS: def Module.eval_quoted(module, quoted, binding \\ [], opts \\ [])
#: lib/module.ex:346
msgid ""
"Evaluates the quoted contents in the given module's context.\n"
"\n"
"A list of environment options can also be given as argument.\n"
"See `Code.eval_string/3` for more information.\n"
"\n"
"Raises an error if the module was already compiled.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Foo do\n"
"      contents = quote do: (def sum(a, b), do: a + b)\n"
"      Module.eval_quoted __MODULE__, contents\n"
"    end\n"
"\n"
"    Foo.sum(1, 2) #=> 3\n"
"\n"
"For convenience, you can my pass `__ENV__` as argument and\n"
"all options will be automatically extracted from the environment:\n"
"\n"
"    defmodule Foo do\n"
"      contents = quote do: (def sum(a, b), do: a + b)\n"
"      Module.eval_quoted __MODULE__, contents, [], __ENV__\n"
"    end\n"
"\n"
"    Foo.sum(1, 2) #=> 3\n"
"\n"
msgstr ""
"与えられたモジュールのコンテキストで、quoteされたコンテンツを、評価します。\n"
"\n"
"環境のリストのオプションも引数として与えることができます。\n"
"詳細は、`Code.eval_string/3`を\n"
"参照してください。\n"
"\n"
"もしモジュールがすでにコンパイルされていたら、エラーを上げます。\n"
"\n"
"## 例\n"
"\n"
"    defmodule Foo do\n"
"      contents = quote do: (def sum(a, b), do: a + b)\n"
"      Module.eval_quoted __MODULE__, contents\n"
"    end\n"
"\n"
"    Foo.sum(1, 2) #=> 3\n"
"\n"
"便宜上、引数として`__ENV__`を渡すことができ、その環境から全てのオプショ\n"
"ンが自動的に抽出されます\n"
"\n"
"    defmodule Foo do\n"
"      contents = quote do: (def sum(a, b), do: a + b)\n"
"      Module.eval_quoted __MODULE__, contents, [], __ENV__\n"
"    end\n"
"\n"
"    Foo.sum(1, 2) #=> 3\n"
"\n"

#. TRANSLATORS: def Module.delete_attribute(module, key)
#: lib/module.ex:791
msgid ""
"Deletes all attributes that match the given key.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule MyModule do\n"
"      Module.put_attribute __MODULE__, :custom_threshold_for_lib, 10\n"
"      Module.delete_attribute __MODULE__, :custom_threshold_for_lib\n"
"    end\n"
"\n"
msgstr ""
"与えられたkeyにマッチする属性を全て削除します。\n"
"\n"
"## 例\n"
"\n"
"    defmodule MyModule do\n"
"      Module.put_attribute __MODULE__, :custom_threshold_for_lib, 10\n"
"      Module.delete_attribute __MODULE__, :custom_threshold_for_lib\n"
"    end\n"
"\n"

#. TRANSLATORS: def Module.get_attribute(module, key)
#: lib/module.ex:775
msgid ""
"Gets the given attribute from a module. If the attribute\n"
"was marked with `accumulate` with `Module.register_attribute/3`,\n"
"a list is always returned.\n"
"\n"
"The `@` macro compiles to a call to this function. For example,\n"
"the following code:\n"
"\n"
"    @foo\n"
"\n"
"Expands close to:\n"
"\n"
"    Module.get_attribute(__MODULE__, :foo)\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Foo do\n"
"      Module.put_attribute __MODULE__, :value, 1\n"
"      Module.get_attribute __MODULE__, :value #=> 1\n"
"\n"
"      Module.register_attribute __MODULE__, :value, accumulate: true\n"
"      Module.put_attribute __MODULE__, :value, 1\n"
"      Module.get_attribute __MODULE__, :value #=> [1]\n"
"    end\n"
"\n"
msgstr ""
"モジュールから与えられた属性を取得します。もし属性が\n"
"`Module.register_attribute/3`で`accumulate`とマークされていたら、\n"
"常にリストを返します。\n"
"\n"
"`@`マクロは、この関数の呼び出しに、コンパイルします。\n"
"例えば以下のコードは:\n"
"\n"
"    @foo\n"
"\n"
"以下に展開されます:\n"
"\n"
"    Module.get_attribute(__MODULE__, :foo)\n"
"\n"
"## 例\n"
"\n"
"    defmodule Foo do\n"
"      Module.put_attribute __MODULE__, :value, 1\n"
"      Module.get_attribute __MODULE__, :value #=> 1\n"
"\n"
"      Module.register_attribute __MODULE__, :value, accumulate: true\n"
"      Module.put_attribute __MODULE__, :value, 1\n"
"      Module.get_attribute __MODULE__, :value #=> [1]\n"
"    end\n"
"\n"

#. TRANSLATORS: def Module.create(module, quoted, opts)
#: lib/module.ex:395
msgid ""
"Creates a module with the given name and defined by\n"
"the given quoted expressions.\n"
"\n"
"The line where the module is defined and its file **must**\n"
"be passed as options.\n"
"\n"
"## Examples\n"
"\n"
"    contents =\n"
"      quote do\n"
"        def world, do: true\n"
"      end\n"
"\n"
"    Module.create(Hello, contents, Macro.Env.location(__ENV__))\n"
"\n"
"    Hello.world #=> true\n"
"\n"
"## Differences from `defmodule`\n"
"\n"
"`Module.create` works similarly to `defmodule` and\n"
"return the same results. While one could also use\n"
"`defmodule` to define modules dynamically, this\n"
"function is preferred when the module body is given\n"
"by a quoted expression.\n"
"\n"
"Another important distinction is that `Module.create`\n"
"allows you to control the environment variables used\n"
"when defining the module, while `defmodule` automatically\n"
"shares the same environment.\n"
msgstr ""
"与えられた名前とquoteされた式により定義されるモジュールを\n"
"作ります。\n"
"\n"
"モジュールが定義された行とそのファイル名は、オプションとして\n"
"**渡されなければなりません**。\n"
"\n"
"## 例\n"
"\n"
"    contents =\n"
"      quote do\n"
"        def world, do: true\n"
"      end\n"
"\n"
"    Module.create(Hello, contents, Macro.Env.location(__ENV__))\n"
"\n"
"    Hello.world #=> true\n"
"\n"
"## `defmodule`との違い\n"
"\n"
"`Module.create`は`defmodule`と似た働きをし、同じ戻り値を返します。\n"
"`defmodule`がモジュールを動的に定義するために使われる一方、この関数はモ\n"
"ジュール本体がquoteされた式により与えられた時に好まれます。\n"
"\n"
"もう一つの重要な違いは、モジュールを定義するときに、`defmodule`は自動的\n"
"におなじ環境を共有する一方、`Module.create`が環境変数を制御することを許\n"
"します。\n"

#. TRANSLATORS: def Module.concat(left, right)
#: lib/module.ex:438
msgid ""
"Concatenates two aliases and returns a new alias.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Module.concat(Foo, Bar)\n"
"    Foo.Bar\n"
"\n"
"    iex> Module.concat(Foo, \"Bar\")\n"
"    Foo.Bar\n"
"\n"
msgstr ""
"二つのエイリアスを連結し、新しいエイリアスを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Module.concat(Foo, Bar)\n"
"    Foo.Bar\n"
"\n"
"    iex> Module.concat(Foo, \"Bar\")\n"
"    Foo.Bar\n"
"\n"

#. TRANSLATORS: def Module.concat(list)
#: lib/module.ex:421
msgid ""
"Concatenates a list of aliases and returns a new alias.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Module.concat([Foo, Bar])\n"
"    Foo.Bar\n"
"\n"
"    iex> Module.concat([Foo, \"Bar\"])\n"
"    Foo.Bar\n"
"\n"
msgstr ""
"エイリアスのリストを連結し、新しいエイリアスを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Module.concat([Foo, Bar])\n"
"    Foo.Bar\n"
"\n"
"    iex> Module.concat([Foo, \"Bar\"])\n"
"    Foo.Bar\n"
"\n"

#. TRANSLATORS: def Module.safe_concat(list)
#: lib/module.ex:458
msgid ""
"Concatenates a list of aliases and returns a new alias only\n"
"if the alias was already referenced. If the alias was not\n"
"referenced yet, fails with `ArgumentError`.\n"
"It handles char lists, binaries and atoms.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Module.safe_concat([Unknown, Module])\n"
"    ** (ArgumentError) argument error\n"
"\n"
"    iex> Module.safe_concat([List, Chars])\n"
"    List.Chars\n"
"\n"
msgstr ""
"エイリアスのリストを連結し、出来た新しいエイリアスが、\n"
"それが既に参照されていた時だけ、それを返します。\n"
"もしそのエイリアスがまだ参照されていなかったなら、`ArgumentError`で失敗しま"
"す。\n"
"文字リスト、バイナリ、アトムをハンドルします。\n"
"\n"
"## 例\n"
"\n"
"    iex> Module.safe_concat([Unknown, Module])\n"
"    ** (ArgumentError) argument error\n"
"\n"
"    iex> Module.safe_concat([List, Chars])\n"
"    List.Chars\n"
"\n"

#. TRANSLATORS: def Module.defines?(module, tuple)
#: lib/module.ex:613
msgid ""
"Checks if the module defines the given function or macro.\n"
"Use `defines?/3` to assert for a specific type.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Example do\n"
"      Module.defines? __MODULE__, {:version, 0} #=> false\n"
"      def version, do: 1\n"
"      Module.defines? __MODULE__, {:version, 0} #=> true\n"
"    end\n"
"\n"
msgstr ""
"与えられた関数かマクロがmoduleで定義されているかチェックします。\n"
"特定のタイプを主張するためには、`defines?/3`を使ってください。\n"
"\n"
"## 例\n"
"\n"
"    defmodule Example do\n"
"      Module.defines? __MODULE__, {:version, 0} #=> false\n"
"      def version, do: 1\n"
"      Module.defines? __MODULE__, {:version, 0} #=> true\n"
"    end\n"
"\n"

#. TRANSLATORS: def Module.defines?(module, tuple, kind)
#: lib/module.ex:633
msgid ""
"Checks if the module defines a function or macro of the\n"
"given `kind`. `kind` can be any of `:def`, `:defp`,\n"
"`:defmacro` or `:defmacrop`.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Example do\n"
"      Module.defines? __MODULE__, {:version, 0}, :defp #=> false\n"
"      def version, do: 1\n"
"      Module.defines? __MODULE__, {:version, 0}, :defp #=> false\n"
"    end\n"
"\n"
msgstr ""
"与えられた`kind`の関数かマクロがmoduleで定義されているかチェックします。\n"
"`kind`は`:def`、`:defp`、`:defmacro`、`:defmacrop`の何れかです。\n"
"\n"
"## 例\n"
"\n"
"    defmodule Example do\n"
"      Module.defines? __MODULE__, {:version, 0}, :defp #=> false\n"
"      def version, do: 1\n"
"      Module.defines? __MODULE__, {:version, 0}, :defp #=> false\n"
"    end\n"
"\n"

#. TRANSLATORS: def Module.open?(module)
#: lib/module.ex:314
msgid ""
"Checks if a module is open, i.e. it is currently being defined\n"
"and its attributes and functions can be modified.\n"
msgstr ""
"moduleがオープンされたかをチェックします。\n"
"即ち、オープンされているとは、現在定義されていて、\n"
"属性と関数は修正可能ということです。\n"

#. TRANSLATORS: def Module.definitions_in(module)
#: lib/module.ex:653
msgid ""
"Returns all functions defined in `module`.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Example do\n"
"      def version, do: 1\n"
"      Module.definitions_in __MODULE__ #=> [{:version,0}]\n"
"    end\n"
"\n"
msgstr ""
"`module`で定義されている全ての関数を返します。\n"
"\n"
"## 例\n"
"\n"
"    defmodule Example do\n"
"      def version, do: 1\n"
"      Module.definitions_in __MODULE__ #=> [{:version,0}]\n"
"    end\n"
"\n"

#. TRANSLATORS: def Module.definitions_in(module, kind)
#: lib/module.ex:672
msgid ""
"Returns all functions defined in `module`, according\n"
"to its kind.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Example do\n"
"      def version, do: 1\n"
"      Module.definitions_in __MODULE__, :def  #=> [{:version,0}]\n"
"      Module.definitions_in __MODULE__, :defp #=> []\n"
"    end\n"
"\n"
msgstr ""
"その種別(kind)によって、`module`で定義されている全ての関数を返します。\n"
"\n"
"## 例\n"
"\n"
"    defmodule Example do\n"
"      def version, do: 1\n"
"      Module.definitions_in __MODULE__, :def  #=> [{:version,0}]\n"
"      Module.definitions_in __MODULE__, :defp #=> []\n"
"    end\n"
"\n"

#. TRANSLATORS: def Module.add_doc(module, line, kind, tuple, signature \\ [], doc)
#: lib/module.ex:498
msgid ""
"Attaches documentation to a given function or type. It expects\n"
"the module the function/type belongs to, the line (a non negative\n"
"integer), the kind (`def` or `defmacro`), a tuple representing\n"
"the function and its arity, the function signature (the signature\n"
"should be omitted for types) and the documentation, which should\n"
"be either a binary or a boolean.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule MyModule do\n"
"      Module.add_doc(__MODULE__, __ENV__.line + 1, :def, {:version, 0}, [], "
"\"Manually added docs\")\n"
"      def version, do: 1\n"
"    end\n"
"\n"
msgstr ""
"与えられた関数あるいはタイプにドキュメントをアタッチします。\n"
"\n"
"関数/タイプが属しているモジュール、行(非負の整数)、種類(`def`か"
"`defmacro`)、\n"
"関数とアリティのタプル表現、関数のシグネチャ(シグネチャはタイプでは\n"
"省略されなければなりません)、そしてドキュメント(それはバイナリかブーリアン\n"
"でなければなりません)を期待します。\n"
"\n"
"## 例\n"
"\n"
"    defmodule MyModule do\n"
"      Module.add_doc(__MODULE__, __ENV__.line + 1, :def, {:version, 0}, [], "
"\"Manually added docs\")\n"
"      def version, do: 1\n"
"    end\n"
"\n"

#. TRANSLATORS: def Module.safe_concat(left, right)
#: lib/module.ex:478
msgid ""
"Concatenates two aliases and returns a new alias only\n"
"if the alias was already referenced. If the alias was not\n"
"referenced yet, fails with `ArgumentError`.\n"
"It handles char lists, binaries and atoms.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Module.safe_concat(Unknown, Module)\n"
"    ** (ArgumentError) argument error\n"
"\n"
"    iex> Module.safe_concat(List, Chars)\n"
"    List.Chars\n"
"\n"
msgstr ""
"二つのエイリアスを連結し、それが既に参照されているなら、新しいエイリア\n"
"スを返します。もしエイリアスがまだ参照されていなかったら、\n"
"`ArgumentError`で失敗します。\n"
"文字のリスト、バイナリ、アトムを取り扱います。\n"
"\n"
"## 例\n"
"\n"
"    iex> Module.safe_concat(Unknown, Module)\n"
"    ** (ArgumentError) argument error\n"
"\n"
"    iex> Module.safe_concat(List, Chars)\n"
"    List.Chars\n"
"\n"
