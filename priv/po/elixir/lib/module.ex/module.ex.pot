#. TRANSLATORS: Elixir.Module Summary
#: lib/module.ex:1 
msgid ""
"This module provides many functions to deal with modules during\n"
"compilation time. It allows a developer to dynamically attach\n"
"documentation, add, delete and register attributes and so forth.\n"
"\n"
"After a module is compiled, using many of the functions in\n"
"this module will raise errors, since it is out of their scope\n"
"to inspect runtime data. Most of the runtime data can be inspected\n"
"via the `__info__(attr)` function attached to each compiled module.\n"
"\n"
"## Module attributes\n"
"\n"
"Each module can be decorated with one or more attributes. The following ones\n"
"are currently defined by Elixir:\n"
"\n"
"  * `@after_compile`\n"
"\n"
"    A hook that will be invoked right after the current module is compiled.\n"
"\n"
"    Accepts a module or a tuple `{<module>, <function atom>}`. The function\n"
"    must take two arguments: the module environment and its bytecode.\n"
"    When just a module is provided, the function is assumed to be\n"
"    `__after_compile__/2`.\n"
"\n"
"    ### Example\n"
"\n"
"        defmodule M do\n"
"          @after_compile __MODULE__\n"
"\n"
"          def __after_compile__(env, _bytecode) do\n"
"            IO.inspect env\n"
"          end\n"
"        end\n"
"\n"
"  * `@before_compile`\n"
"\n"
"    A hook that will be invoked before the module is compiled.\n"
"\n"
"    Accepts a module or a tuple `{<module>, <function/macro atom>}`. The\n"
"    function/macro must take one argument: the module environment. If it's a\n"
"    macro, its returned value will be injected at the end of the module definition\n"
"    before the compilation starts.\n"
"\n"
"    When just a module is provided, the function/macro is assumed to be\n"
"    `__before_compile__/1`.\n"
"\n"
"    Note: unlike `@after_compile`, the callback function/macro must\n"
"    be placed in a separate module (because when the callback is invoked,\n"
"    the current module does not yet exist).\n"
"\n"
"    ### Example\n"
"\n"
"        defmodule A do\n"
"          defmacro __before_compile__(_env) do\n"
"            quote do\n"
"              def hello, do: \"world\"\n"
"            end\n"
"          end\n"
"        end\n"
"\n"
"        defmodule B do\n"
"          @before_compile A\n"
"        end\n"
"\n"
"  * `@behaviour`   (notice the British spelling)\n"
"\n"
"    Specifies an OTP or user-defined behaviour.\n"
"\n"
"    ### Example\n"
"\n"
"        defmodule M do\n"
"          @behaviour gen_event\n"
"\n"
"          # ...\n"
"        end\n"
"\n"
"  * `@compile`\n"
"\n"
"    Defines options for module compilation that are passed to the Erlang\n"
"    compiler.\n"
"\n"
"    Accepts an atom, a tuple, or a list of atoms and tuples.\n"
"\n"
"    See http://www.erlang.org/doc/man/compile.html for the list of supported\n"
"    options.\n"
"\n"
"    Several uses of `@compile` will accumulate instead of overriding\n"
"    previous ones.\n"
"\n"
"    ### Example\n"
"\n"
"          defmodule M do\n"
"            @compile {:inline, myfun: 1}\n"
"\n"
"            def myfun(arg) do\n"
"              to_string(arg)\n"
"            end\n"
"          end\n"
"\n"
"  * `@doc`\n"
"\n"
"    Provides documentation for the function or macro that follows the\n"
"    attribute.\n"
"\n"
"    Accepts a string (often a heredoc) or `false` where `@doc false` will\n"
"    make the function/macro invisible to the documentation extraction tools\n"
"    like ExDoc.\n"
"\n"
"    Can be invoked more than once.\n"
"\n"
"    ### Example\n"
"\n"
"          defmodule M do\n"
"            @doc \"Hello world\"\n"
"            def hello do\n"
"              \"world\"\n"
"            end\n"
"\n"
"            @doc \"\"\"\n"
"            Sum.\n"
"            \"\"\"\n"
"            def sum(a, b) do\n"
"              a + b\n"
"            end\n"
"          end\n"
"\n"
"  * `@file`\n"
"\n"
"    Changes the filename used in stacktraces for the function or macro that\n"
"    follows the attribute.\n"
"\n"
"    Accepts a string. Can be used more than once.\n"
"\n"
"    ### Example\n"
"\n"
"          defmodule M do\n"
"            @doc \"Hello world\"\n"
"            @file \"hello.ex\"\n"
"            def hello do\n"
"              \"world\"\n"
"            end\n"
"          end\n"
"\n"
"  * `@moduledoc`\n"
"\n"
"    Provides documentation for the current module.\n"
"\n"
"    Accepts a string (which is often a heredoc) or `false` where\n"
"    `@moduledoc false` will make the module invisible to the\n"
"    documentation extraction tools like ExDoc.\n"
"\n"
"    ### Example\n"
"\n"
"          defmodule M do\n"
"            @moduledoc \"\"\"\n"
"            A very useful module\n"
"            \"\"\"\n"
"          end\n"
"\n"
"\n"
"  * `@on_definition`\n"
"\n"
"    A hook that will be invoked when each function or macro in the current\n"
"    module is defined. Useful when annotating functions.\n"
"\n"
"    Accepts a module or a tuple `{<module>, <function atom>}`. The function\n"
"    must take 6 arguments:\n"
"\n"
"      - the module environment\n"
"      - kind: `:def`, `:defp`, `:defmacro`, or `:defmacrop`\n"
"      - function/macro name\n"
"      - list of expanded arguments\n"
"      - list of expanded guards\n"
"      - expanded function body\n"
"\n"
"    Note the hook receives the expanded arguments and it is invoked before\n"
"    the function is stored in the module. So `Module.defines?/2` will return\n"
"    false for the first clause of every function.\n"
"\n"
"    If the function/macro being defined has multiple clauses, the hook will\n"
"    be called for each clause.\n"
"\n"
"    Unlike other hooks, `@on_definition` will only invoke functions\n"
"    and never macros. This is because the hook is invoked inside the context\n"
"    of the function (and nested function definitions are not allowed in\n"
"    Elixir).\n"
"\n"
"    When just a module is provided, the function is assumed to be\n"
"    `__on_definition__/6`.\n"
"\n"
"    ### Example\n"
"\n"
"          defmodule H do\n"
"            def on_def(_env, kind, name, args, guards, body) do\n"
"              IO.puts \"Defining #{kind} named #{name} with args:\"\n"
"              IO.inspect args\n"
"              IO.puts \"and guards\"\n"
"              IO.inspect guards\n"
"              IO.puts \"and body\"\n"
"              IO.puts Macro.to_string(body)\n"
"            end\n"
"          end\n"
"\n"
"          defmodule M do\n"
"            @on_definition {H, :on_def}\n"
"\n"
"            def hello(arg) when is_binary(arg) or is_list(arg) do\n"
"              \"Hello\" <> to_string(arg)\n"
"            end\n"
"\n"
"            def hello(_) do\n"
"              :ok\n"
"            end\n"
"          end\n"
"\n"
"  * `@on_load`\n"
"\n"
"    A hook that will be invoked whenever the module is loaded.\n"
"\n"
"    Accepts a function atom of a function in the current module. The function\n"
"    must have arity 0 (no arguments) and has to return `:ok`, otherwise the\n"
"    loading of the module will be aborted.\n"
"\n"
"    ### Example\n"
"\n"
"          defmodule M do\n"
"            @on_load :load_check\n"
"\n"
"            def load_check do\n"
"              if some_condition() do\n"
"                :ok\n"
"              else\n"
"                nil\n"
"              end\n"
"            end\n"
"\n"
"            def some_condition do\n"
"              false\n"
"            end\n"
"          end\n"
"\n"
"  * `@vsn`\n"
"\n"
"    Specify the module version. Accepts any valid Elixir value.\n"
"\n"
"    ### Example\n"
"\n"
"          defmodule M do\n"
"            @vsn \"1.0\"\n"
"          end\n"
"\n"
"  * `@external_resource`\n"
"\n"
"    Specifies an external resource to the current module.\n"
"\n"
"    Many times a module embeds information from an external file. This\n"
"    attribute allows the module to annotate which external resources\n"
"    have been used.\n"
"\n"
"    Tools like Mix may use this information to ensure the module is\n"
"    recompiled in case any of the external resources change.\n"
"\n"
"The following attributes are part of typespecs and are also reserved by\n"
"Elixir (see `Kernel.Typespec` for more information about typespecs):\n"
"\n"
"  * `@type`        - defines a type to be used in `@spec`\n"
"  * `@typep`       - defines a private type to be used in `@spec`\n"
"  * `@opaque`      - defines an opaque type to be used in `@spec`\n"
"  * `@spec`        - provides a specification for a function\n"
"  * `@callback`    - provides a specification for the behaviour callback\n"
"\n"
"In addition to the built-in attributes outlined above, custom attributes may\n"
"also be added. A custom attribute is any valid identifier prefixed with an\n"
"`@` and followed by a valid Elixir value:\n"
"\n"
"      defmodule M do\n"
"        @custom_attr [some: \"stuff\"]\n"
"      end\n"
"\n"
"For more advanced options available when defining custom attributes, see\n"
"`register_attribute/3`.\n"
"\n"
"## Runtime information about a module\n"
"\n"
"It is possible to query a module at runtime to find out which functions and\n"
"macros it defines, extract its docstrings, etc. See `__info__/1`.\n"
msgstr ""
#. TRANSLATORS: def Module.overridable?(module, tuple)
#: lib/module.ex:713 
msgid ""
"Returns `true` if `tuple` in `module` is marked as overridable.\n"
msgstr ""
#. TRANSLATORS: def Module.register_attribute(module, new, opts)
#: lib/module.ex:829 
msgid ""
"Registers an attribute. By registering an attribute, a developer\n"
"is able to customize how Elixir will store and accumulate the\n"
"attribute values.\n"
"\n"
"## Options\n"
"\n"
"When registering an attribute, two options can be given:\n"
"\n"
"  * `:accumulate` - several calls to the same attribute will\n"
"    accumulate instead of override the previous one. New attributes\n"
"    are always added to the top of the accumulated list.\n"
"\n"
"  * `:persist` - the attribute will be persisted in the Erlang\n"
"    Abstract Format. Useful when interfacing with Erlang libraries.\n"
"\n"
"By default, both options are `false`.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule MyModule do\n"
"      Module.register_attribute __MODULE__,\n"
"        :custom_threshold_for_lib,\n"
"        accumulate: true, persist: false\n"
"\n"
"      @custom_threshold_for_lib 10\n"
"      @custom_threshold_for_lib 20\n"
"      @custom_threshold_for_lib #=> [20, 10]\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def Module.put_attribute(module, key, value)
#: lib/module.ex:729 
msgid ""
"Puts an Erlang attribute to the given module with the given\n"
"key and value. The semantics of putting the attribute depends\n"
"if the attribute was registered or not via `register_attribute/3`.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule MyModule do\n"
"      Module.put_attribute __MODULE__, :custom_threshold_for_lib, 10\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def Module.__info__(kind)
#: lib/module.ex:308 
msgid ""
"Provides runtime information about functions and macros defined by the\n"
"module, enables docstring extraction, etc.\n"
"\n"
"Each module gets an `__info__/1` function when it's compiled. The function\n"
"takes one of the following atoms:\n"
"\n"
"  * `:functions`  - keyword list of public functions along with their arities\n"
"\n"
"  * `:macros`     - keyword list of public macros along with their arities\n"
"\n"
"  * `:module`     - module name (`Module == Module.__info__(:module)`)\n"
"\n"
"In addition to the above, you may also pass to `__info__/1` any atom supported\n"
"by Erlang's `module_info` function which also gets defined for each compiled\n"
"module. See http://erlang.org/doc/reference_manual/modules.html#id69430 for\n"
"more information.\n"
msgstr ""
#. TRANSLATORS: def Module.make_overridable(module, tuples)
#: lib/module.ex:684 
msgid ""
"Makes the given functions in `module` overridable.\n"
"An overridable function is lazily defined, allowing a\n"
"developer to customize it. See `Kernel.defoverridable/1` for\n"
"more information and documentation.\n"
msgstr ""
#. TRANSLATORS: def Module.split(module)
#: lib/module.ex:853 
msgid ""
"Splits the given module name into binary parts.\n"
"\n"
"## Examples\n"
"\n"
"    Module.split Very.Long.Module.Name.And.Even.Longer\n"
"    #=> [\"Very\", \"Long\", \"Module\", \"Name\", \"And\", \"Even\", \"Longer\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Module.eval_quoted(module, quoted, binding \\ [], opts \\ [])
#: lib/module.ex:346 
msgid ""
"Evaluates the quoted contents in the given module's context.\n"
"\n"
"A list of environment options can also be given as argument.\n"
"See `Code.eval_string/3` for more information.\n"
"\n"
"Raises an error if the module was already compiled.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Foo do\n"
"      contents = quote do: (def sum(a, b), do: a + b)\n"
"      Module.eval_quoted __MODULE__, contents\n"
"    end\n"
"\n"
"    Foo.sum(1, 2) #=> 3\n"
"\n"
"For convenience, you can my pass `__ENV__` as argument and\n"
"all options will be automatically extracted from the environment:\n"
"\n"
"    defmodule Foo do\n"
"      contents = quote do: (def sum(a, b), do: a + b)\n"
"      Module.eval_quoted __MODULE__, contents, [], __ENV__\n"
"    end\n"
"\n"
"    Foo.sum(1, 2) #=> 3\n"
"\n"
msgstr ""
#. TRANSLATORS: def Module.delete_attribute(module, key)
#: lib/module.ex:791 
msgid ""
"Deletes all attributes that match the given key.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule MyModule do\n"
"      Module.put_attribute __MODULE__, :custom_threshold_for_lib, 10\n"
"      Module.delete_attribute __MODULE__, :custom_threshold_for_lib\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def Module.get_attribute(module, key)
#: lib/module.ex:775 
msgid ""
"Gets the given attribute from a module. If the attribute\n"
"was marked with `accumulate` with `Module.register_attribute/3`,\n"
"a list is always returned.\n"
"\n"
"The `@` macro compiles to a call to this function. For example,\n"
"the following code:\n"
"\n"
"    @foo\n"
"\n"
"Expands close to:\n"
"\n"
"    Module.get_attribute(__MODULE__, :foo)\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Foo do\n"
"      Module.put_attribute __MODULE__, :value, 1\n"
"      Module.get_attribute __MODULE__, :value #=> 1\n"
"\n"
"      Module.register_attribute __MODULE__, :value, accumulate: true\n"
"      Module.put_attribute __MODULE__, :value, 1\n"
"      Module.get_attribute __MODULE__, :value #=> [1]\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def Module.create(module, quoted, opts)
#: lib/module.ex:395 
msgid ""
"Creates a module with the given name and defined by\n"
"the given quoted expressions.\n"
"\n"
"The line where the module is defined and its file **must**\n"
"be passed as options.\n"
"\n"
"## Examples\n"
"\n"
"    contents =\n"
"      quote do\n"
"        def world, do: true\n"
"      end\n"
"\n"
"    Module.create(Hello, contents, Macro.Env.location(__ENV__))\n"
"\n"
"    Hello.world #=> true\n"
"\n"
"## Differences from `defmodule`\n"
"\n"
"`Module.create` works similarly to `defmodule` and\n"
"return the same results. While one could also use\n"
"`defmodule` to define modules dynamically, this\n"
"function is preferred when the module body is given\n"
"by a quoted expression.\n"
"\n"
"Another important distinction is that `Module.create`\n"
"allows you to control the environment variables used\n"
"when defining the module, while `defmodule` automatically\n"
"shares the same environment.\n"
msgstr ""
#. TRANSLATORS: def Module.concat(left, right)
#: lib/module.ex:438 
msgid ""
"Concatenates two aliases and returns a new alias.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Module.concat(Foo, Bar)\n"
"    Foo.Bar\n"
"\n"
"    iex> Module.concat(Foo, \"Bar\")\n"
"    Foo.Bar\n"
"\n"
msgstr ""
#. TRANSLATORS: def Module.concat(list)
#: lib/module.ex:421 
msgid ""
"Concatenates a list of aliases and returns a new alias.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Module.concat([Foo, Bar])\n"
"    Foo.Bar\n"
"\n"
"    iex> Module.concat([Foo, \"Bar\"])\n"
"    Foo.Bar\n"
"\n"
msgstr ""
#. TRANSLATORS: def Module.safe_concat(list)
#: lib/module.ex:458 
msgid ""
"Concatenates a list of aliases and returns a new alias only\n"
"if the alias was already referenced. If the alias was not\n"
"referenced yet, fails with `ArgumentError`.\n"
"It handles char lists, binaries and atoms.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Module.safe_concat([Unknown, Module])\n"
"    ** (ArgumentError) argument error\n"
"\n"
"    iex> Module.safe_concat([List, Chars])\n"
"    List.Chars\n"
"\n"
msgstr ""
#. TRANSLATORS: def Module.defines?(module, tuple)
#: lib/module.ex:613 
msgid ""
"Checks if the module defines the given function or macro.\n"
"Use `defines?/3` to assert for a specific type.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Example do\n"
"      Module.defines? __MODULE__, {:version, 0} #=> false\n"
"      def version, do: 1\n"
"      Module.defines? __MODULE__, {:version, 0} #=> true\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def Module.defines?(module, tuple, kind)
#: lib/module.ex:633 
msgid ""
"Checks if the module defines a function or macro of the\n"
"given `kind`. `kind` can be any of `:def`, `:defp`,\n"
"`:defmacro` or `:defmacrop`.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Example do\n"
"      Module.defines? __MODULE__, {:version, 0}, :defp #=> false\n"
"      def version, do: 1\n"
"      Module.defines? __MODULE__, {:version, 0}, :defp #=> false\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def Module.open?(module)
#: lib/module.ex:314 
msgid ""
"Checks if a module is open, i.e. it is currently being defined\n"
"and its attributes and functions can be modified.\n"
msgstr ""
#. TRANSLATORS: def Module.definitions_in(module)
#: lib/module.ex:653 
msgid ""
"Returns all functions defined in `module`.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Example do\n"
"      def version, do: 1\n"
"      Module.definitions_in __MODULE__ #=> [{:version,0}]\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def Module.definitions_in(module, kind)
#: lib/module.ex:672 
msgid ""
"Returns all functions defined in `module`, according\n"
"to its kind.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Example do\n"
"      def version, do: 1\n"
"      Module.definitions_in __MODULE__, :def  #=> [{:version,0}]\n"
"      Module.definitions_in __MODULE__, :defp #=> []\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def Module.add_doc(module, line, kind, tuple, signature \\ [], doc)
#: lib/module.ex:498 
msgid ""
"Attaches documentation to a given function or type. It expects\n"
"the module the function/type belongs to, the line (a non negative\n"
"integer), the kind (`def` or `defmacro`), a tuple representing\n"
"the function and its arity, the function signature (the signature\n"
"should be omitted for types) and the documentation, which should\n"
"be either a binary or a boolean.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule MyModule do\n"
"      Module.add_doc(__MODULE__, __ENV__.line + 1, :def, {:version, 0}, [], \"Manually added docs\")\n"
"      def version, do: 1\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def Module.safe_concat(left, right)
#: lib/module.ex:478 
msgid ""
"Concatenates two aliases and returns a new alias only\n"
"if the alias was already referenced. If the alias was not\n"
"referenced yet, fails with `ArgumentError`.\n"
"It handles char lists, binaries and atoms.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Module.safe_concat(Unknown, Module)\n"
"    ** (ArgumentError) argument error\n"
"\n"
"    iex> Module.safe_concat(List, Chars)\n"
"    List.Chars\n"
"\n"
msgstr ""
