#. TRANSLATORS: def Module.put_attribute(module, key, value)
#: lib/module.ex:850 
msgid ""
"Puts an Erlang attribute to the given module with the given\n"
"key and value.\n"
"\n"
"The semantics of putting the attribute depends\n"
"if the attribute was registered or not via `register_attribute/3`.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule MyModule do\n"
"      Module.put_attribute __MODULE__, :custom_threshold_for_lib, 10\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def Module.safe_concat(left, right)
#: lib/module.ex:553 
msgid ""
"Concatenates two aliases and returns a new alias only if the alias was\n"
"already referenced.\n"
"\n"
"If the alias was not referenced yet, fails with `ArgumentError`.\n"
"It handles char lists, binaries and atoms.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Module.safe_concat(Module, Unknown)\n"
"    ** (ArgumentError) argument error\n"
"\n"
"    iex> Module.safe_concat(List, Chars)\n"
"    List.Chars\n"
"\n"
msgstr ""
#. TRANSLATORS: def Module.defines?(module, tuple, kind)
#: lib/module.ex:748 
msgid ""
"Checks if the module defines a function or macro of the\n"
"given `kind`.\n"
"\n"
"`kind` can be any of `:def`, `:defp`, `:defmacro` or `:defmacrop`.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Example do\n"
"      Module.defines? __MODULE__, {:version, 0}, :defp #=> false\n"
"      def version, do: 1\n"
"      Module.defines? __MODULE__, {:version, 0}, :defp #=> false\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.Module Summary
#: lib/module.ex:2 
msgid ""
"Provides functions to deal with modules during compilation time.\n"
"\n"
"It allows a developer to dynamically add, delete and register\n"
"attributes, attach documentation and so forth.\n"
"\n"
"After a module is compiled, using many of the functions in\n"
"this module will raise errors, since it is out of their scope\n"
"to inspect runtime data. Most of the runtime data can be inspected\n"
"via the `__info__(attr)` function attached to each compiled module.\n"
"\n"
"## Module attributes\n"
"\n"
"Each module can be decorated with one or more attributes. The following ones\n"
"are currently defined by Elixir:\n"
"\n"
"  * `@after_compile`\n"
"\n"
"    A hook that will be invoked right after the current module is compiled.\n"
"    Accepts a module or a tuple `{<module>, <function atom>}`.\n"
"    See the \"Compile callbacks\" section below.\n"
"\n"
"  * `@before_compile`\n"
"\n"
"    A hook that will be invoked before the module is compiled.\n"
"    Accepts a module or a tuple `{<module>, <function/macro atom>}`.\n"
"    See the \"Compile callbacks\" section below.\n"
"\n"
"  * `@behaviour` (notice the British spelling)\n"
"\n"
"    Behaviours can be referenced by modules to ensure they implement\n"
"    required specific function signatures defined by `@callback`.\n"
"\n"
"    For example, you can specify the URI.Parser behaviour as follows:\n"
"\n"
"        defmodule URI.Parser do\n"
"          @doc \"Parses the given URL\"\n"
"          @callback parse(uri_info :: URI.t) :: URI.t\n"
"\n"
"          @doc \"Defines a default port\"\n"
"          @callback default_port() :: integer\n"
"        end\n"
"\n"
"        And then a module may use it as:\n"
"\n"
"        defmodule URI.HTTP do\n"
"          @behaviour URI.Parser\n"
"          def default_port(), do: 80\n"
"          def parse(info), do: info\n"
"        end\n"
"\n"
"    If the behaviour changes or URI.HTTP does not implement one of the\n"
"    callbacks, a warning will be raised.\n"
"\n"
"    Specifies an OTP or user-defined behaviour.\n"
"\n"
"    ### Example\n"
"\n"
"        defmodule M do\n"
"          @behaviour :gen_event\n"
"\n"
"          # ...\n"
"        end\n"
"\n"
"  * `@compile`\n"
"\n"
"    Defines options for module compilation. This is used to configure\n"
"    both Elixir and Erlang compilers, as any other compilation pass\n"
"    added by external tools.\n"
"\n"
"    Multiple uses of `@compile` will accumulate instead of overriding\n"
"    previous ones. See the \"Compile options\" section below.\n"
"\n"
"    ### Example\n"
"\n"
"        defmodule M do\n"
"          @compile {:inline, myfun: 1}\n"
"\n"
"          def myfun(arg) do\n"
"            to_string(arg)\n"
"          end\n"
"        end\n"
"\n"
"  * `@doc`\n"
"\n"
"    Provides documentation for the function or macro that follows the\n"
"    attribute.\n"
"\n"
"    Accepts a string (often a heredoc) or `false` where `@doc false` will\n"
"    make the function/macro invisible to the documentation extraction tools\n"
"    like ExDoc.\n"
"\n"
"    Can be invoked more than once.\n"
"\n"
"    ### Example\n"
"\n"
"        defmodule M do\n"
"          @doc \"Hello world\"\n"
"          def hello do\n"
"            \"world\"\n"
"          end\n"
"\n"
"          @doc \"\"\"\n"
"          Sums `a` to `b`.\n"
"          \"\"\"\n"
"          def sum(a, b) do\n"
"            a + b\n"
"          end\n"
"        end\n"
"\n"
"  * `@dialyzer`\n"
"\n"
"    Defines warnings to request or suppress when using a version of\n"
"    `:dialyzer` that supports module attributes.\n"
"\n"
"    Accepts an atom, a tuple, or a list of atoms and tuples.\n"
"\n"
"    For the list of supported warnings, see\n"
"    [`:dialyzer` module](http://www.erlang.org/doc/man/dialyzer.html).\n"
"\n"
"    Multiple uses of `@dialyzer` will accumulate instead of overriding\n"
"    previous ones.\n"
"\n"
"    ### Example\n"
"\n"
"        defmodule M do\n"
"          @dialyzer {:nowarn_function, myfun: 1}\n"
"\n"
"          def myfun(arg) do\n"
"            M.not_a_function(arg)\n"
"          end\n"
"        end\n"
"\n"
"  * `@external_resource`\n"
"\n"
"    Specifies an external resource to the current module.\n"
"\n"
"    Many times a module embeds information from an external file. This\n"
"    attribute allows the module to annotate which external resources\n"
"    have been used.\n"
"\n"
"    Tools like Mix may use this information to ensure the module is\n"
"    recompiled in case any of the external resources change.\n"
"\n"
"  * `@file`\n"
"\n"
"    Changes the filename used in stacktraces for the function or macro that\n"
"    follows the attribute.\n"
"\n"
"    Accepts a string. Can be used more than once.\n"
"\n"
"    ### Example\n"
"\n"
"        defmodule M do\n"
"          @doc \"Hello world\"\n"
"          @file \"hello.ex\"\n"
"          def hello do\n"
"            \"world\"\n"
"          end\n"
"        end\n"
"\n"
"  * `@moduledoc`\n"
"\n"
"    Provides documentation for the current module.\n"
"\n"
"    Accepts a string (which is often a heredoc) or `false` where\n"
"    `@moduledoc false` will make the module invisible to the\n"
"    documentation extraction tools like ExDoc.\n"
"\n"
"    ### Example\n"
"\n"
"        defmodule M do\n"
"          @moduledoc \"\"\"\n"
"          A very useful module\n"
"          \"\"\"\n"
"        end\n"
"\n"
"  * `@on_definition`\n"
"\n"
"    A hook that will be invoked when each function or macro in the current\n"
"    module is defined. Useful when annotating functions.\n"
"\n"
"    Accepts a module or a tuple `{<module>, <function atom>}`. See the\n"
"    \"Compile callbacks\" section below.\n"
"\n"
"  * `@on_load`\n"
"\n"
"    A hook that will be invoked whenever the module is loaded.\n"
"\n"
"    Accepts a function atom of a function in the current module. The function\n"
"    must have arity 0 (no arguments) and has to return `:ok`, otherwise the\n"
"    loading of the module will be aborted.\n"
"\n"
"    ### Example\n"
"\n"
"        defmodule M do\n"
"          @on_load :load_check\n"
"\n"
"          def load_check do\n"
"            if some_condition() do\n"
"              :ok\n"
"            else\n"
"              nil\n"
"            end\n"
"          end\n"
"\n"
"          def some_condition do\n"
"            false\n"
"          end\n"
"        end\n"
"\n"
"  * `@vsn`\n"
"\n"
"    Specify the module version. Accepts any valid Elixir value.\n"
"\n"
"    ### Example\n"
"\n"
"        defmodule M do\n"
"          @vsn \"1.0\"\n"
"        end\n"
"\n"
"The following attributes are part of typespecs and are also reserved by\n"
"Elixir:\n"
"\n"
"  * `@type`          - defines a type to be used in `@spec`\n"
"  * `@typep`         - defines a private type to be used in `@spec`\n"
"  * `@opaque`        - defines an opaque type to be used in `@spec`\n"
"  * `@spec`          - provides a specification for a function\n"
"  * `@callback`      - provides a specification for a behaviour callback\n"
"  * `@macrocallback` - provides a specification for a macro behaviour callback\n"
"\n"
"In addition to the built-in attributes outlined above, custom attributes may\n"
"also be added. A custom attribute is any valid identifier prefixed with an\n"
"`@` and followed by a valid Elixir value:\n"
"\n"
"    defmodule M do\n"
"      @custom_attr [some: \"stuff\"]\n"
"    end\n"
"\n"
"For more advanced options available when defining custom attributes, see\n"
"`register_attribute/3`.\n"
"\n"
"## Compile callbacks\n"
"\n"
"There are three callbacks that are invoked when functions are defined,\n"
"as well as before and immediately after the module bytecode is generated.\n"
"\n"
"### `@after_compile`\n"
"\n"
"A hook that will be invoked right after the current module is compiled.\n"
"\n"
"Accepts a module or a tuple `{<module>, <function atom>}`. The function\n"
"must take two arguments: the module environment and its bytecode.\n"
"When just a module is provided, the function is assumed to be\n"
"`__after_compile__/2`.\n"
"\n"
"#### Example\n"
"\n"
"    defmodule M do\n"
"      @after_compile __MODULE__\n"
"\n"
"      def __after_compile__(env, _bytecode) do\n"
"        IO.inspect env\n"
"      end\n"
"    end\n"
"\n"
"### `@before_compile`\n"
"\n"
"A hook that will be invoked before the module is compiled.\n"
"\n"
"Accepts a module or a tuple `{<module>, <function/macro atom>}`. The\n"
"function/macro must take one argument: the module environment. If it's a\n"
"macro, its returned value will be injected at the end of the module definition\n"
"before the compilation starts.\n"
"\n"
"When just a module is provided, the function/macro is assumed to be\n"
"`__before_compile__/1`.\n"
"\n"
"Note: unlike `@after_compile`, the callback function/macro must\n"
"be placed in a separate module (because when the callback is invoked,\n"
"the current module does not yet exist).\n"
"\n"
"#### Example\n"
"\n"
"    defmodule A do\n"
"      defmacro __before_compile__(_env) do\n"
"        quote do\n"
"          def hello, do: \"world\"\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    defmodule B do\n"
"      @before_compile A\n"
"    end\n"
"\n"
"### `@on_definition`\n"
"\n"
"A hook that will be invoked when each function or macro in the current\n"
"module is defined. Useful when annotating functions.\n"
"\n"
"Accepts a module or a tuple `{<module>, <function atom>}`. The function\n"
"must take 6 arguments:\n"
"\n"
"  - the module environment\n"
"  - kind: `:def`, `:defp`, `:defmacro`, or `:defmacrop`\n"
"  - function/macro name\n"
"  - list of quoted arguments\n"
"  - list of quoted guards\n"
"  - quoted function body\n"
"\n"
"Note the hook receives the quoted arguments and it is invoked before\n"
"the function is stored in the module. So `Module.defines?/2` will return\n"
"`false` for the first clause of every function.\n"
"\n"
"If the function/macro being defined has multiple clauses, the hook will\n"
"be called for each clause.\n"
"\n"
"Unlike other hooks, `@on_definition` will only invoke functions\n"
"and never macros. This is because the hook is invoked inside the context\n"
"of the function (and nested function definitions are not allowed in\n"
"Elixir).\n"
"\n"
"When just a module is provided, the function is assumed to be\n"
"`__on_definition__/6`.\n"
"\n"
"#### Example\n"
"\n"
"    defmodule H do\n"
"      def on_def(_env, kind, name, args, guards, body) do\n"
"        IO.puts \"Defining #{kind} named #{name} with args:\"\n"
"        IO.inspect args\n"
"        IO.puts \"and guards\"\n"
"        IO.inspect guards\n"
"        IO.puts \"and body\"\n"
"        IO.puts Macro.to_string(body)\n"
"      end\n"
"    end\n"
"\n"
"    defmodule M do\n"
"      @on_definition {H, :on_def}\n"
"\n"
"      def hello(arg) when is_binary(arg) or is_list(arg) do\n"
"        \"Hello\" <> to_string(arg)\n"
"      end\n"
"\n"
"      def hello(_) do\n"
"        :ok\n"
"      end\n"
"    end\n"
"\n"
"## Compile options\n"
"\n"
"The `@compile` attribute accepts diverse options that is used by both\n"
"Elixir and Erlang compilers. Some of the common use cases are documented\n"
"below:\n"
"\n"
"  * `@compile :debug_info` - includes `:debug_info` regardless of the\n"
"    setting in `Code.compiler_options`\n"
"\n"
"  * `@compile {:debug_info, false} - disables `:debug_info` regardless\n"
"    of the setting in `Code.compiler_options`\n"
"\n"
"  * `@compile {:inline, some_fun: 2, other_fun: 3}` - inlines the given\n"
"    name/arity pairs\n"
"\n"
"  * `@compile {:autoload, false}` - disables automatic loading of\n"
"    modules after compilation. Instead, the module will be loaded after\n"
"    it is dispatched to\n"
"\n"
"You can see a handful more options used by the Erlang compiler in\n"
"the documentation for the `:compile` module.\n"
msgstr ""
#. TRANSLATORS: def Module.definitions_in(module, kind)
#: lib/module.ex:789 
msgid ""
"Returns all functions defined in `module`, according\n"
"to its kind.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Example do\n"
"      def version, do: 1\n"
"      Module.definitions_in __MODULE__, :def  #=> [{:version, 0}]\n"
"      Module.definitions_in __MODULE__, :defp #=> []\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def Module.eval_quoted(module, quoted, binding \\ [], opts \\ [])
#: lib/module.ex:404 
msgid ""
"Evaluates the quoted contents in the given module's context.\n"
"\n"
"A list of environment options can also be given as argument.\n"
"See `Code.eval_string/3` for more information.\n"
"\n"
"Raises an error if the module was already compiled.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Foo do\n"
"      contents = quote do: (def sum(a, b), do: a + b)\n"
"      Module.eval_quoted __MODULE__, contents\n"
"    end\n"
"\n"
"    Foo.sum(1, 2) #=> 3\n"
"\n"
"For convenience, you can pass `__ENV__` as an argument and\n"
"all options will be automatically extracted from the environment:\n"
"\n"
"    defmodule Foo do\n"
"      contents = quote do: (def sum(a, b), do: a + b)\n"
"      Module.eval_quoted __MODULE__, contents, [], __ENV__\n"
"    end\n"
"\n"
"    Foo.sum(1, 2) #=> 3\n"
"\n"
msgstr ""
#. TRANSLATORS: def Module.delete_attribute(module, key)
#: lib/module.ex:923 
msgid ""
"Deletes all attributes that match the given key.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule MyModule do\n"
"      Module.put_attribute __MODULE__, :custom_threshold_for_lib, 10\n"
"      Module.delete_attribute __MODULE__, :custom_threshold_for_lib\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def Module.make_overridable(module, tuples)
#: lib/module.ex:808 
msgid ""
"Makes the given functions in `module` overridable.\n"
"\n"
"An overridable function is lazily defined, allowing a\n"
"developer to customize it. See `Kernel.defoverridable/1` for\n"
"more information and documentation.\n"
msgstr ""
#. TRANSLATORS: def Module.__info__(kind)
#: lib/module.ex:376 
msgid ""
"Provides runtime information about functions and macros defined by the\n"
"module, enables docstring extraction, etc.\n"
"\n"
"Each module gets an `__info__/1` function when it's compiled. The function\n"
"takes one of the following atoms:\n"
"\n"
"  * `:functions`  - keyword list of public functions along with their arities\n"
"\n"
"  * `:macros`     - keyword list of public macros along with their arities\n"
"\n"
"  * `:module`     - module name (`Module == Module.__info__(:module)`)\n"
"\n"
"In addition to the above, you may also pass to `__info__/1` any atom supported\n"
"by `:erlang.module_info/0` which also gets defined for each compiled module.\n"
"\n"
"For a list of supported attributes and more information, see [Modules – Erlang Reference Manual](http://www.erlang.org/doc/reference_manual/modules.html#id77056).\n"
msgstr ""
#. TRANSLATORS: def Module.definitions_in(module)
#: lib/module.ex:772 
msgid ""
"Returns all functions defined in `module`.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Example do\n"
"      def version, do: 1\n"
"      Module.definitions_in __MODULE__ #=> [{:version, 0}]\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def Module.overridable?(module, tuple)
#: lib/module.ex:843 
msgid ""
"Returns `true` if `tuple` in `module` is marked as overridable.\n"
msgstr ""
#. TRANSLATORS: def Module.concat(left, right)
#: lib/module.ex:515 
msgid ""
"Concatenates two aliases and returns a new alias.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Module.concat(Foo, Bar)\n"
"    Foo.Bar\n"
"\n"
"    iex> Module.concat(Foo, \"Bar\")\n"
"    Foo.Bar\n"
"\n"
msgstr ""
#. TRANSLATORS: def Module.register_attribute(module, new, opts)
#: lib/module.ex:942 
msgid ""
"Registers an attribute. By registering an attribute, a developer\n"
"is able to customize how Elixir will store and accumulate the\n"
"attribute values.\n"
"\n"
"## Options\n"
"\n"
"When registering an attribute, two options can be given:\n"
"\n"
"  * `:accumulate` - several calls to the same attribute will\n"
"    accumulate instead of override the previous one. New attributes\n"
"    are always added to the top of the accumulated list.\n"
"\n"
"  * `:persist` - the attribute will be persisted in the Erlang\n"
"    Abstract Format. Useful when interfacing with Erlang libraries.\n"
"\n"
"By default, both options are `false`.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule MyModule do\n"
"      Module.register_attribute __MODULE__,\n"
"        :custom_threshold_for_lib,\n"
"        accumulate: true, persist: false\n"
"\n"
"      @custom_threshold_for_lib 10\n"
"      @custom_threshold_for_lib 20\n"
"      @custom_threshold_for_lib #=> [20, 10]\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def Module.open?(module)
#: lib/module.ex:396 
msgid ""
"Checks if a module is open, i.e. it is currently being defined\n"
"and its attributes and functions can be modified.\n"
msgstr ""
#. TRANSLATORS: def Module.get_attribute(module, key)
#: lib/module.ex:889 
msgid ""
"Gets the given attribute from a module.\n"
"\n"
"If the attribute was marked with `accumulate` with\n"
"`Module.register_attribute/3`, a list is always returned. `nil` is returned\n"
"if the attribute has not been marked with `accumulate` and has not been set\n"
"to any value.\n"
"\n"
"The `@` macro compiles to a call to this function. For example,\n"
"the following code:\n"
"\n"
"    @foo\n"
"\n"
"Expands close to:\n"
"\n"
"    Module.get_attribute(__MODULE__, :foo)\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Foo do\n"
"      Module.put_attribute __MODULE__, :value, 1\n"
"      Module.get_attribute __MODULE__, :value #=> 1\n"
"\n"
"      Module.register_attribute __MODULE__, :value, accumulate: true\n"
"      Module.put_attribute __MODULE__, :value, 1\n"
"      Module.get_attribute __MODULE__, :value #=> [1]\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def Module.create(module, quoted, opts)
#: lib/module.ex:450 
msgid ""
"Creates a module with the given name and defined by\n"
"the given quoted expressions.\n"
"\n"
"The line where the module is defined and its file **must**\n"
"be passed as options.\n"
"\n"
"## Examples\n"
"\n"
"    contents =\n"
"      quote do\n"
"        def world, do: true\n"
"      end\n"
"\n"
"    Module.create(Hello, contents, Macro.Env.location(__ENV__))\n"
"\n"
"    Hello.world #=> true\n"
"\n"
"## Differences from `defmodule`\n"
"\n"
"`Module.create/3` works similarly to `defmodule` and\n"
"return the same results. While one could also use\n"
"`defmodule` to define modules dynamically, this\n"
"function is preferred when the module body is given\n"
"by a quoted expression.\n"
"\n"
"Another important distinction is that `Module.create/3`\n"
"allows you to control the environment variables used\n"
"when defining the module, while `defmodule` automatically\n"
"shares the same environment.\n"
msgstr ""
#. TRANSLATORS: def Module.defines?(module, tuple)
#: lib/module.ex:728 
msgid ""
"Checks if the module defines the given function or macro.\n"
"\n"
"Use `defines?/3` to assert for a specific type.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Example do\n"
"      Module.defines? __MODULE__, {:version, 0} #=> false\n"
"      def version, do: 1\n"
"      Module.defines? __MODULE__, {:version, 0} #=> true\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def Module.add_doc(module, line, kind, tuple, signature \\ [], doc)
#: lib/module.ex:574 
msgid ""
"Attaches documentation to a given function or type.\n"
"\n"
"It expects the module the function/type belongs to, the line (a non\n"
"negative integer), the kind (`def` or `defmacro`), a tuple representing\n"
"the function and its arity, the function signature (the signature\n"
"should be omitted for types) and the documentation, which should\n"
"be either a binary or a boolean.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule MyModule do\n"
"      Module.add_doc(__MODULE__, __ENV__.line + 1, :def, {:version, 0}, [], \"Manually added docs\")\n"
"      def version, do: 1\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def Module.concat(list)
#: lib/module.ex:498 
msgid ""
"Concatenates a list of aliases and returns a new alias.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Module.concat([Foo, Bar])\n"
"    Foo.Bar\n"
"\n"
"    iex> Module.concat([Foo, \"Bar\"])\n"
"    Foo.Bar\n"
"\n"
msgstr ""
#. TRANSLATORS: def Module.split(module)
#: lib/module.ex:988 
msgid ""
"Splits the given module name into binary parts.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Module.split Very.Long.Module.Name.And.Even.Longer\n"
"    [\"Very\", \"Long\", \"Module\", \"Name\", \"And\", \"Even\", \"Longer\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Module.safe_concat(list)
#: lib/module.ex:532 
msgid ""
"Concatenates a list of aliases and returns a new alias only if the alias\n"
"was already referenced.\n"
"\n"
"If the alias was not referenced yet, fails with `ArgumentError`.\n"
"It handles char lists, binaries and atoms.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Module.safe_concat([Module, Unknown])\n"
"    ** (ArgumentError) argument error\n"
"\n"
"    iex> Module.safe_concat([List, Chars])\n"
"    List.Chars\n"
"\n"
msgstr ""
