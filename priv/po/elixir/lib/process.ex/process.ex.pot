#. TRANSLATORS: def Process.flag(flag, value)
#: lib/process.ex:464 
msgid ""
"Sets certain flags for the process which calls this function.\n"
"Returns the old value of the flag.\n"
"\n"
"See [`:erlang.process_flag/2`](http://www.erlang.org/doc/man/erlang.html#process_flag-2) for more info.\n"
msgstr ""
#. TRANSLATORS: def Process.group_leader()
#: lib/process.ex:436 
msgid ""
"Returns the pid of the group leader for the process which evaluates the function.\n"
msgstr ""
#. TRANSLATORS: def Process.monitor(item)
#: lib/process.ex:329 
msgid ""
"The calling process starts monitoring the item given.\n"
"It returns the monitor reference.\n"
"\n"
"See [the need for monitoring](http://elixir-lang.org/getting-started/mix-otp/genserver.html#the-need-for-monitoring)\n"
"for an example.\n"
"See [`:erlang.monitor/2`](http://www.erlang.org/doc/man/erlang.html#monitor-2) for more info.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Process.sleep(timeout)
#: lib/process.ex:124 
msgid ""
"Sleeps the current process by `timeout`.\n"
"\n"
"`timeout` is either the number of miliseconds to sleep as an\n"
"integer or the atom `:infinity`. When `:infinity` is given,\n"
"the current process will suspend forever.\n"
"\n"
"**Use this function with extreme care**. For almost all situations\n"
"where you would use `sleep/1` in Elixir, there is likely a\n"
"more correct, faster and precise way of achieving it with\n"
"message passing.\n"
"\n"
"For example, if you are waiting a process to perform some\n"
"action, it is better to communicate.\n"
"\n"
"In other words, **do not**:\n"
"\n"
"    Task.start_link fn ->\n"
"      do_something()\n"
"      ...\n"
"    end\n"
"\n"
"    # Wait until work is done\n"
"    Process.sleep(2000)\n"
"\n"
"But **do**:\n"
"\n"
"    parent = self()\n"
"    Task.start_link fn ->\n"
"      do_something()\n"
"      send parent, :work_is_done\n"
"      ...\n"
"    end\n"
"\n"
"    receive do\n"
"      :work_is_done -> :ok\n"
"    after\n"
"      30_000 -> :timeout # Optional timeout\n"
"    end\n"
"\n"
"Or even use `Task.async/1` and `Task.await/2` in the example\n"
"above.\n"
"\n"
"Similarly, if you are waiting for a process to terminate,\n"
"use monitor instead of sleep. **Do not**:\n"
"\n"
"    Task.start_link fn ->\n"
"      ...\n"
"    end\n"
"\n"
"    # Wait until task terminates\n"
"    Process.sleep(2000)\n"
"\n"
"Instead **do**:\n"
"\n"
"    {:ok, pid} =\n"
"      Task.start_link fn ->\n"
"        ...\n"
"      end\n"
"\n"
"    ref = Process.monitor(pid)\n"
"    receive do\n"
"      {:DOWN, ^ref, _, _, _} -> :task_is_down\n"
"    after\n"
"      30_000 -> :timeout # Optional timeout\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def Process.get()
#: lib/process.ex:30 
msgid ""
"Returns all key-values in the process dictionary.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Process.group_leader(pid, leader)
#: lib/process.ex:444 
msgid ""
"Sets the group leader of `pid` to `leader`. Typically, this is used when a processes\n"
"started from a certain shell should have a group leader other than `:init`.\n"
msgstr ""
#. TRANSLATORS: def Process.hibernate(mod, fun, args)
#: lib/process.ex:520 
msgid ""
"Puts the calling process into a wait state\n"
"where its memory allocation has been reduced as much as possible,\n"
"which is useful if the process does not expect to receive any messages\n"
"in the near future.\n"
"\n"
"See [`:erlang.hibernate/3`](http://www.erlang.org/doc/man/erlang.html#hibernate-3) for more info.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Process.send(dest, msg, options)
#: lib/process.ex:198 
msgid ""
"Sends a message to the given process.\n"
"\n"
"If the option `:noconnect` is used and sending the message would require an\n"
"auto-connection to another node the message is not sent and `:noconnect` is\n"
"returned.\n"
"\n"
"If the option `:nosuspend` is used and sending the message would cause the\n"
"sender to be suspended the message is not sent and `:nosuspend` is returned.\n"
"\n"
"Otherwise the message is sent and `:ok` is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Process.send({:name, :node_does_not_exist}, :hi, [:noconnect])\n"
"    :noconnect\n"
"\n"
msgstr ""
#. TRANSLATORS: def Process.unlink(pid)
#: lib/process.ex:387 
msgid ""
"Removes the link, if there is one, between the calling process and\n"
"the process or port referred to by `pid`. Returns `true` and does not\n"
"fail, even if there is no link or `id` does not exist\n"
"\n"
"See [`:erlang.unlink/1`](http://www.erlang.org/doc/man/erlang.html#unlink-1) for more info.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Process.info(pid)
#: lib/process.ex:487 
msgid ""
"Returns information about the process identified by `pid` or `nil` if the process\n"
"is not alive.\n"
"Use this only for debugging information.\n"
"\n"
"See [`:erlang.process_info/1`](http://www.erlang.org/doc/man/erlang.html#process_info-1) for more info.\n"
msgstr ""
#. TRANSLATORS: def Process.exit(pid, reason)
#: lib/process.ex:93 
msgid ""
"Sends an exit signal with the given reason to the pid.\n"
"\n"
"The following behaviour applies if reason is any term except `:normal` or `:kill`:\n"
"\n"
"  1. If pid is not trapping exits, pid will exit with the given reason.\n"
"\n"
"  2. If pid is trapping exits, the exit signal is transformed into a message\n"
"     `{:EXIT, from, reason}` and delivered to the message queue of pid.\n"
"\n"
"  3. If reason is the atom `:normal`, pid will not exit (unless it is the calling\n"
"     process's pid, in which case it will exit with the reason `:normal`).\n"
"     If it is trapping exits, the exit signal is transformed into a message\n"
"     `{:EXIT, from, :normal}` and delivered to its message queue.\n"
"\n"
"  4. If reason is the atom `:kill`, that is if `exit(pid, :kill)` is called,\n"
"     an untrappable exit signal is sent to pid which will unconditionally\n"
"     exit with exit reason `:killed`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    Process.exit(pid, :kill)\n"
"\n"
msgstr ""
#. TRANSLATORS: def Process.link(pid)
#: lib/process.ex:374 
msgid ""
"Creates a link between the calling process and another process\n"
"(or port) `pid`, if there is not such a link already.\n"
"\n"
"See [`:erlang.link/1`](http://www.erlang.org/doc/man/erlang.html#link-1) for more info.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Process.get_keys(value)
#: lib/process.ex:64 
msgid ""
"Returns all keys that have the given `value`.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Process.register(pid, name)
#: lib/process.ex:401 
msgid ""
"Associates the name with a pid or a port identifier. `name`, which must\n"
"be an atom, can be used instead of the pid / port identifier with the\n"
"`Kernel.send/2` function.\n"
"\n"
"`Process.register/2` will fail with `ArgumentError` if the pid supplied\n"
"is no longer alive, (check with `alive?/1`) or if the name is\n"
"already registered (check with `whereis/1`).\n"
msgstr ""
#. TRANSLATORS: def Process.get_keys()
#: lib/process.ex:54 
msgid ""
"Returns all keys in the process dictionary.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Process.demonitor(monitor_ref, options \\ [])
#: lib/process.ex:344 
msgid ""
"If `monitor_ref` is a reference which the calling process\n"
"obtained by calling `monitor/1`, this monitoring is turned off.\n"
"If the monitoring is already turned off, nothing happens.\n"
"\n"
"See [`:erlang.demonitor/2`](http://www.erlang.org/doc/man/erlang.html#demonitor-2) for more info.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Process.cancel_timer(timer_ref)
#: lib/process.ex:245 
msgid ""
"Cancels a timer created by `send_after/3`.\n"
"\n"
"When the result is an integer, it represents the time in milli-seconds\n"
"left until the timer will expire.\n"
"\n"
"When the result is `false`, a timer corresponding to `timer_ref` could\n"
"not be found. This can be either because the timer expired, already has\n"
"been canceled, or because `timer_ref` never corresponded to a timer.\n"
"\n"
"If the timer has expired, the timeout message has been sent, but it does\n"
"not tell you whether or not it has arrived at its destination yet.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Process.list()
#: lib/process.ex:359 
msgid ""
"Returns a list of process identifiers corresponding to all the\n"
"processes currently existing on the local node.\n"
"\n"
"Note that a process that is exiting, exists but is not alive, i.e.,\n"
"`alive?/1` will return `false` for a process that is exiting,\n"
"but its process identifier will be part of the result returned.\n"
"\n"
"See [`:erlang.processes/0`](http://www.erlang.org/doc/man/erlang.html#processes-0) for more info.\n"
msgstr ""
#. TRANSLATORS: def Process.flag(pid, flag, value)
#: lib/process.ex:475 
msgid ""
"Sets certain flags for the process `pid`, in the same manner as `flag/2`.\n"
"Returns the old value of the flag. The allowed values for `flag` are\n"
"only a subset of those allowed in `flag/2`, namely: `save_calls`.\n"
"\n"
"See [`:erlang.process_flag/3`](http://www.erlang.org/doc/man/erlang.html#process_flag-3) for more info.\n"
msgstr ""
#. TRANSLATORS: def Process.alive?(pid)
#: lib/process.ex:17 
msgid ""
"Returns `true` if the process exists and is alive (i.e. it is not exiting\n"
"and has not exited yet). Otherwise, returns `false`.\n"
"\n"
"`pid` must refer to a process at the local node.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Process.spawn(mod, fun, args, opts)
#: lib/process.ex:310 
msgid ""
"Spawns the given module and function passing the given args\n"
"according to the given options.\n"
"\n"
"The result depends on the given options. In particular,\n"
"if `:monitor` is given as an option, it will return a tuple\n"
"containing the pid and the monitoring reference, otherwise\n"
"just the spawned process pid.\n"
"\n"
"It also accepts extra options, for the list of available options\n"
"check [`:erlang.spawn_opt/4`](http://www.erlang.org/doc/man/erlang.html#spawn_opt-4).\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Process.info(pid, spec)
#: lib/process.ex:499 
msgid ""
"Returns information about the process identified by `pid`\n"
"or `nil` if the process is not alive.\n"
"\n"
"See [`:erlang.process_info/2`](http://www.erlang.org/doc/man/erlang.html#process_info-2) for more info.\n"
msgstr ""
#. TRANSLATORS: Elixir.Process Summary
#: lib/process.ex:2 
msgid ""
"Conveniences for working with processes and the process dictionary.\n"
"\n"
"Besides the functions available in this module, the `Kernel` module\n"
"exposes and auto-imports some basic functionality related to processes\n"
"available through the functions:\n"
"\n"
"  * `Kernel.spawn/1` and `Kernel.spawn/3`\n"
"  * `Kernel.spawn_link/1` and `Kernel.spawn_link/3`\n"
"  * `Kernel.spawn_monitor/1` and `Kernel.spawn_monitor/3`\n"
"  * `Kernel.self/0`\n"
"  * `Kernel.send/2`\n"
"\n"
msgstr ""
#. TRANSLATORS: def Process.registered()
#: lib/process.ex:453 
msgid ""
"Returns a list of names which have been registered using `register/2`.\n"
msgstr ""
#. TRANSLATORS: def Process.put(key, value)
#: lib/process.ex:74 
msgid ""
"Stores the given key-value in the process dictionary.\n"
"\n"
"The return value is the value that was previously stored under the key `key`\n"
"(or `nil` in case no value was stored under `key`).\n"
msgstr ""
#. TRANSLATORS: def Process.whereis(name)
#: lib/process.ex:425 
msgid ""
"Returns the pid or port identifier with the registered name.\n"
"Returns `nil` if the name is not registered.\n"
"\n"
"See [`:erlang.whereis/1`](http://www.erlang.org/doc/man/erlang.html#whereis-1) for more info.\n"
msgstr ""
#. TRANSLATORS: def Process.get(key, default \\ nil)
#: lib/process.ex:40 
msgid ""
"Returns the value for the given `key`.\n"
msgstr ""
#. TRANSLATORS: def Process.delete(key)
#: lib/process.ex:85 
msgid ""
"Deletes the given `key` from the process dictionary.\n"
msgstr ""
#. TRANSLATORS: def Process.send_after(dest, msg, time)
#: lib/process.ex:224 
msgid ""
"Sends `msg` to `dest` after `time` milliseconds.\n"
"\n"
"If `dest` is a pid, it must be the pid of a local process, dead or alive.\n"
"If `dest` is an atom, it must be the name of a registered process\n"
"which is looked up at the time of delivery. No error is given if the name does\n"
"not refer to a process.\n"
"\n"
"This function returns a timer reference, which can be read or canceled with\n"
"`read_timer/1` and `cancel_timer/1`.\n"
"\n"
"Finally, the timer will be automatically canceled if the given `dest` is a pid\n"
"which is not alive or when the given pid exits. Note that timers will not be\n"
"automatically canceled when `dest` is an atom (as the atom resolution is done\n"
"on delivery).\n"
msgstr ""
#. TRANSLATORS: def Process.read_timer(timer_ref)
#: lib/process.ex:265 
msgid ""
"Reads a timer created by `send_after/3`.\n"
"\n"
"When the result is an integer, it represents the time in milli-seconds\n"
"left until the timer will expire.\n"
"\n"
"When the result is `false`, a timer corresponding to `timer_ref` could\n"
"not be found. This can be either because the timer expired, already has\n"
"been canceled, or because `timer_ref` never corresponded to a timer.\n"
"\n"
"If the timer has expired, the timeout message has been sent, but it does\n"
"not tell you whether or not it has arrived at its destination yet.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Process.unregister(name)
#: lib/process.ex:415 
msgid ""
"Removes the registered name, associated with a pid or a port identifier.\n"
"\n"
"See [`:erlang.unregister/1`](http://www.erlang.org/doc/man/erlang.html#unregister-1) for more info.\n"
msgstr ""
