msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2016-02-28 22:35+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: def Process.flag(flag, value)
#: lib/process.ex:464
msgid ""
"Sets certain flags for the process which calls this function.\n"
"Returns the old value of the flag.\n"
"\n"
"See [`:erlang.process_flag/2`](http://www.erlang.org/doc/man/erlang."
"html#process_flag-2) for more info.\n"
msgstr ""
"特定のフラグをこの関数を呼び出したプロセスにセットします。\n"
"そのフラグの古い値を返します。\n"
"\n"
"更なる情報は\n"
"[`:erlang.process_flag/2`](http://www.erlang.org/doc/man/erlang."
"html#process_flag-2)\n"
"を参照してください。\n"

#. TRANSLATORS: def Process.group_leader()
#: lib/process.ex:436
msgid ""
"Returns the pid of the group leader for the process which evaluates the "
"function.\n"
msgstr "関数を評価しているプロセスのグループリーダのpidを返します。\n"

#. TRANSLATORS: def Process.monitor(item)
#: lib/process.ex:329
msgid ""
"The calling process starts monitoring the item given.\n"
"It returns the monitor reference.\n"
"\n"
"See [the need for monitoring](http://elixir-lang.org/getting-started/mix-otp/"
"genserver.html#the-need-for-monitoring)\n"
"for an example.\n"
"See [`:erlang.monitor/2`](http://www.erlang.org/doc/man/erlang."
"html#monitor-2) for more info.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"呼び出したプロセスは与えられたアイテムのモニタを開始します。\n"
"モニタリファレンスを返します。\n"
"\n"
"例は [the need for monitoring](http://elixir-lang.org/getting-started/mix-"
"otp/genserver.html#the-need-for-monitoring)\n"
"を参照してください。\n"
"\n"
"更なる情報は \n"
"[`:erlang.monitor/2`](http://www.erlang.org/doc/man/erlang.html#monitor-2)\n"
"を参照してください。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Process.sleep(timeout)
#: lib/process.ex:124
msgid ""
"Sleeps the current process by `timeout`.\n"
"\n"
"`timeout` is either the number of miliseconds to sleep as an\n"
"integer or the atom `:infinity`. When `:infinity` is given,\n"
"the current process will suspend forever.\n"
"\n"
"**Use this function with extreme care**. For almost all situations\n"
"where you would use `sleep/1` in Elixir, there is likely a\n"
"more correct, faster and precise way of achieving it with\n"
"message passing.\n"
"\n"
"For example, if you are waiting a process to perform some\n"
"action, it is better to communicate.\n"
"\n"
"In other words, **do not**:\n"
"\n"
"    Task.start_link fn ->\n"
"      do_something()\n"
"      ...\n"
"    end\n"
"\n"
"    # Wait until work is done\n"
"    Process.sleep(2000)\n"
"\n"
"But **do**:\n"
"\n"
"    parent = self()\n"
"    Task.start_link fn ->\n"
"      do_something()\n"
"      send parent, :work_is_done\n"
"      ...\n"
"    end\n"
"\n"
"    receive do\n"
"      :work_is_done -> :ok\n"
"    after\n"
"      30_000 -> :timeout # Optional timeout\n"
"    end\n"
"\n"
"Or even use `Task.async/1` and `Task.await/2` in the example\n"
"above.\n"
"\n"
"Similarly, if you are waiting for a process to terminate,\n"
"use monitor instead of sleep. **Do not**:\n"
"\n"
"    Task.start_link fn ->\n"
"      ...\n"
"    end\n"
"\n"
"    # Wait until task terminates\n"
"    Process.sleep(2000)\n"
"\n"
"Instead **do**:\n"
"\n"
"    {:ok, pid} =\n"
"      Task.start_link fn ->\n"
"        ...\n"
"      end\n"
"\n"
"    ref = Process.monitor(pid)\n"
"    receive do\n"
"      {:DOWN, ^ref, _, _, _} -> :task_is_down\n"
"    after\n"
"      30_000 -> :timeout # Optional timeout\n"
"    end\n"
"\n"
msgstr ""
"`timeout`だけ現在のプロセスをスリープさせます。\n"
"\n"
"`timeout`はスリープさせるミリ秒を表す数値か、アトム`:infinity`です。\n"
"`:infinity`が与えられると、現在のプロセスは永久にサスペンドします。\n"
"\n"
"**この関数は最新の注意を払って使用してください**。\n"
"Elixirで`sleep/1`を使いたいと思う殆どの場合、\n"
"メッセージパッシングで遣るほうが、もっと正しく、速く、正確です。\n"
"\n"
"例えば、もしいくつかのアクションを実施するためにプロセスを\n"
"待たせるなら、通信するのがよりよいやり方です。\n"
"\n"
"言い替えると、 **以下のようには使わないでください**:\n"
"\n"
"    Task.start_link fn ->\n"
"      do_something()\n"
"      ...\n"
"    end\n"
"\n"
"    # Wait until work is done\n"
"    Process.sleep(2000)\n"
"\n"
"このように **してください**:\n"
"\n"
"    parent = self()\n"
"    Task.start_link fn ->\n"
"      do_something()\n"
"      send parent, :work_is_done\n"
"      ...\n"
"    end\n"
"\n"
"    receive do\n"
"      :work_is_done -> :ok\n"
"    after\n"
"      30_000 -> :timeout # Optional timeout\n"
"    end\n"
"\n"
"あるいは、上の例では`Task.async/1`と`Task.await/2`をそれぞれ\n"
"使ってください。\n"
"\n"
"同じように、もしプロセスの終了を待つなら、sleepのかわりに\n"
"monitorを使ってください。**このようにしないでください**:\n"
"\n"
"    Task.start_link fn ->\n"
"      ...\n"
"    end\n"
"\n"
"    # Wait until task terminates\n"
"    Process.sleep(2000)\n"
"\n"
"かわりに **こうしてください**:\n"
"\n"
"    {:ok, pid} =\n"
"      Task.start_link fn ->\n"
"        ...\n"
"      end\n"
"\n"
"    ref = Process.monitor(pid)\n"
"    receive do\n"
"      {:DOWN, ^ref, _, _, _} -> :task_is_down\n"
"    after\n"
"      30_000 -> :timeout # Optional timeout\n"
"    end\n"
"\n"

#. TRANSLATORS: def Process.get()
#: lib/process.ex:30
msgid ""
"Returns all key-values in the process dictionary.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"プロセス辞書の全てのkey-valueの組を全て返します。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Process.group_leader(pid, leader)
#: lib/process.ex:444
msgid ""
"Sets the group leader of `pid` to `leader`. Typically, this is used when a "
"processes\n"
"started from a certain shell should have a group leader other than `:init`.\n"
msgstr ""
"`pid`のグループリーダーを`leader`にセットします。一般的に、特定のシェル\n"
"からスタートするプロセスが`:init`以外のグループリーダーをを持っていなけ\n"
"ればならないとき、これが使われます。\n"

#. TRANSLATORS: def Process.hibernate(mod, fun, args)
#: lib/process.ex:520
msgid ""
"Puts the calling process into a wait state\n"
"where its memory allocation has been reduced as much as possible,\n"
"which is useful if the process does not expect to receive any messages\n"
"in the near future.\n"
"\n"
"See [`:erlang.hibernate/3`](http://www.erlang.org/doc/man/erlang."
"html#hibernate-3) for more info.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"呼出しプロセスをwaitステートにします。\n"
"これは可能な限りメモリアロケーションを縮小します。\n"
"プロセスが近い将来にメッセージをなにも受信することを\n"
"期待しない時に便利です。\n"
"\n"
"詳細は、\n"
"[`:erlang.hibernate/3`](http://www.erlang.org/doc/man/erlang."
"html#hibernate-3)\n"
"を参照してください。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Process.send(dest, msg, options)
#: lib/process.ex:198
msgid ""
"Sends a message to the given process.\n"
"\n"
"If the option `:noconnect` is used and sending the message would require an\n"
"auto-connection to another node the message is not sent and `:noconnect` is\n"
"returned.\n"
"\n"
"If the option `:nosuspend` is used and sending the message would cause the\n"
"sender to be suspended the message is not sent and `:nosuspend` is "
"returned.\n"
"\n"
"Otherwise the message is sent and `:ok` is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Process.send({:name, :node_does_not_exist}, :hi, [:noconnect])\n"
"    :noconnect\n"
"\n"
msgstr ""
"与えられたプロセスへメッセージを送信します。\n"
"\n"
"`:noconnect`オプションが使われ、送信するメッセージがもう一つのノードへ\n"
"の自動接続を要求するならば、メッセージは送信されず、`:noconnect`が返さ\n"
"れます。\n"
"\n"
"`:nosuspend`オプションが使われ、送信するメッセージが送信者をサスペンド\n"
"させることにことになる場合、メッセージは送信されず、`:nosuspend`が返さ\n"
"れます。\n"
"\n"
"さもなくば、メッセージは送信され、`:ok`が返されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Process.send({:name, :node_does_not_exist}, :hi, [:noconnect])\n"
"    :noconnect\n"
"\n"

#. TRANSLATORS: def Process.unlink(pid)
#: lib/process.ex:387
msgid ""
"Removes the link, if there is one, between the calling process and\n"
"the process or port referred to by `pid`. Returns `true` and does not\n"
"fail, even if there is no link or `id` does not exist\n"
"\n"
"See [`:erlang.unlink/1`](http://www.erlang.org/doc/man/erlang.html#unlink-1) "
"for more info.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"もし、呼び出したプロセスと、`pid`で参照されたプロセスあるいはポートとの\n"
"間にリンクがあれば、それを削除します。\n"
"もしリンクが無い、あるいは`pid`が存在しないとしても、\n"
"失敗せず、`true`を返します。\n"
"\n"
"詳細は \n"
"[`:erlang.unlink/1`](http://www.erlang.org/doc/man/erlang.html#unlink-1)\n"
"を参照してください。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Process.info(pid)
#: lib/process.ex:487
msgid ""
"Returns information about the process identified by `pid` or `nil` if the "
"process\n"
"is not alive.\n"
"Use this only for debugging information.\n"
"\n"
"See [`:erlang.process_info/1`](http://www.erlang.org/doc/man/erlang."
"html#process_info-1) for more info.\n"
msgstr ""
"`pid`によるプロセス識別子についての情報を返します。\n"
"プロセスが生きていないなら、`nil`を返します。\n"
"これはデバッギング情報のためにだけ使います。\n"
"\n"
"詳細は、\n"
"[`:erlang.process_info/1`](http://www.erlang.org/doc/man/erlang."
"html#process_info-1)\n"
"を参照してください。\n"

#. TRANSLATORS: def Process.exit(pid, reason)
#: lib/process.ex:93
msgid ""
"Sends an exit signal with the given reason to the pid.\n"
"\n"
"The following behaviour applies if reason is any term except `:normal` or `:"
"kill`:\n"
"\n"
"  1. If pid is not trapping exits, pid will exit with the given reason.\n"
"\n"
"  2. If pid is trapping exits, the exit signal is transformed into a "
"message\n"
"     `{:EXIT, from, reason}` and delivered to the message queue of pid.\n"
"\n"
"  3. If reason is the atom `:normal`, pid will not exit (unless it is the "
"calling\n"
"     process's pid, in which case it will exit with the reason `:normal`).\n"
"     If it is trapping exits, the exit signal is transformed into a message\n"
"     `{:EXIT, from, :normal}` and delivered to its message queue.\n"
"\n"
"  4. If reason is the atom `:kill`, that is if `exit(pid, :kill)` is "
"called,\n"
"     an untrappable exit signal is sent to pid which will unconditionally\n"
"     exit with exit reason `:killed`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    Process.exit(pid, :kill)\n"
"\n"
msgstr ""
"与えられたreasonとともにexitシグナルをpidに送ります。\n"
"\n"
"reasonが`:normal`または`:kill`を除いた任意の語なら、以下の振舞いが適用\n"
"されます:\n"
"\n"
"  1. pidがexitをトラップなければ、pidは与えられたreasonで終了します。\n"
"\n"
"  2. pidがexitをトラップしていたら、exitシグナルは`{:EXIT, from, reason}`\n"
"     というメッセージに変換され、pidのメッセージキューに配送されます。\n"
"\n"
"  3. reasonがアトム`:normal`なら、pidは終了しないでしょう。\n"
"     (それが呼出しプロセス自身のpidなら、reason `:normal`で終了します)\n"
"     pidがexitをトラップしていたら、exitシグナルは`{:EXIT, from, :normal}`"
"と\n"
"     いうメッセージに変換され、メッセージキューに配送されます。\n"
"\n"
"  4. reasonがアトム`:kill`なら、つまり、`exit(pid, :kill)`が呼ばれたら、\n"
"     exitをトラップ出来ないシグナルがpidへ送られ、pidは無条件で\n"
"     exit reasonとして`:killed`で終了します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    Process.exit(pid, :kill)\n"
"\n"

#. TRANSLATORS: def Process.link(pid)
#: lib/process.ex:374
msgid ""
"Creates a link between the calling process and another process\n"
"(or port) `pid`, if there is not such a link already.\n"
"\n"
"See [`:erlang.link/1`](http://www.erlang.org/doc/man/erlang.html#link-1) for "
"more info.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"呼び出し側プロセスと他のプロセス(またはport)`pid`の間に、まだ\n"
"リンクがなければ、リンクを作成します。\n"
"\n"
"詳細は、\n"
"[`:erlang.link/1`](http://www.erlang.org/doc/man/erlang.html#link-1)\n"
"を参照してください。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Process.get_keys(value)
#: lib/process.ex:64
msgid ""
"Returns all keys that have the given `value`.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"与えられた`value`をもつキーを全て返します。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Process.register(pid, name)
#: lib/process.ex:401
msgid ""
"Associates the name with a pid or a port identifier. `name`, which must\n"
"be an atom, can be used instead of the pid / port identifier with the\n"
"`Kernel.send/2` function.\n"
"\n"
"`Process.register/2` will fail with `ArgumentError` if the pid supplied\n"
"is no longer alive, (check with `alive?/1`) or if the name is\n"
"already registered (check with `whereis/1`).\n"
msgstr ""
"名前をpidまたはポート識別子と関連付けます。`name`(それはアトムでなくては\n"
"なりません)が、`Kernel.send/2`関数でpid/ポート識別子のかわりに使うことが\n"
"できます。\n"
"\n"
"`Process.register/2`は、供給された(`alive?/1`でチェックして)pidが最早生\n"
"きていない、あるいは、(`whereis/1`でチェックして)名前がすでに登録ずみな\n"
"ら、`ArgumentError`で失敗します。\n"

#. TRANSLATORS: def Process.get_keys()
#: lib/process.ex:54
msgid ""
"Returns all keys in the process dictionary.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"プロセス辞書の全てのキー/値の組を全て返します。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Process.demonitor(monitor_ref, options \\ [])
#: lib/process.ex:344
msgid ""
"If `monitor_ref` is a reference which the calling process\n"
"obtained by calling `monitor/1`, this monitoring is turned off.\n"
"If the monitoring is already turned off, nothing happens.\n"
"\n"
"See [`:erlang.demonitor/2`](http://www.erlang.org/doc/man/erlang."
"html#demonitor-2) for more info.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"もし`monitor_ref`が`monitor/1`を呼ぶことにより得た参照であるなら、この\n"
"モニタリングはoffにされます。もしモニタリングが既にoffなら、何も起きま\n"
"せん。\n"
"\n"
"詳細は\n"
"[`:erlang.demonitor/2`](http://www.erlang.org/doc/man/erlang."
"html#demonitor-2)\n"
"を参照してください。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Process.cancel_timer(timer_ref)
#: lib/process.ex:245
msgid ""
"Cancels a timer created by `send_after/3`.\n"
"\n"
"When the result is an integer, it represents the time in milli-seconds\n"
"left until the timer will expire.\n"
"\n"
"When the result is `false`, a timer corresponding to `timer_ref` could\n"
"not be found. This can be either because the timer expired, already has\n"
"been canceled, or because `timer_ref` never corresponded to a timer.\n"
"\n"
"If the timer has expired, the timeout message has been sent, but it does\n"
"not tell you whether or not it has arrived at its destination yet.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"`send_after/3`で作成されたタイマをキャンセルします。\n"
"\n"
"結果が整数のとき、タイマが期限切れになるまでの時間をミリセカンドで\n"
"表現しています。\n"
"\n"
"結果が`false`のとき、`timer_ref`に一致するタイマがみつからなかった\n"
"ことを示します。これはタイマが期限切れになった、既にキャンセルされた、\n"
"`timer_ref`がタイマに一致しなかった、のいずれも有り得ます。\n"
"\n"
"もしタイマが期限切れになったら、timeoutメッセージが送信されますが、\n"
"それが宛先に到着したか、まだ到着していないかを教えません。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Process.list()
#: lib/process.ex:359
msgid ""
"Returns a list of process identifiers corresponding to all the\n"
"processes currently existing on the local node.\n"
"\n"
"Note that a process that is exiting, exists but is not alive, i.e.,\n"
"`alive?/1` will return `false` for a process that is exiting,\n"
"but its process identifier will be part of the result returned.\n"
"\n"
"See [`:erlang.processes/0`](http://www.erlang.org/doc/man/erlang."
"html#processes-0) for more info.\n"
msgstr ""
"ローカルノードに現在存在する、全てのプロセスに対応する\n"
"プロセス識別子のリストを返します。\n"
"\n"
"生きていないが、存在する、即ち`alive?/1`が`false`を返すような、終了しよ\n"
"うとしているプロセスのプロセス識別子は、返された結果の一部に含まれるこ\n"
"とに気を付けてください。\n"
"\n"
"詳細は \n"
"[`:erlang.processes/0`](http://www.erlang.org/doc/man/erlang."
"html#processes-0)\n"
"を参照してください。\n"

#. TRANSLATORS: def Process.flag(pid, flag, value)
#: lib/process.ex:475
msgid ""
"Sets certain flags for the process `pid`, in the same manner as `flag/2`.\n"
"Returns the old value of the flag. The allowed values for `flag` are\n"
"only a subset of those allowed in `flag/2`, namely: `save_calls`.\n"
"\n"
"See [`:erlang.process_flag/3`](http://www.erlang.org/doc/man/erlang."
"html#process_flag-3) for more info.\n"
msgstr ""
"`flag/2`と同じマナーで、特定のフラグを`pid`プロセスにセットします。\n"
"そのフラグの古い値を返します。`flag`の許された値は`flag/2`のサブセット\n"
"である`save_calls`だけです。\n"
"\n"
"更なる情報は\n"
"[`:erlang.process_flag/3`](http://www.erlang.org/doc/man/erlang."
"html#process_flag-3)\n"
"を参照してください。\n"

#. TRANSLATORS: def Process.alive?(pid)
#: lib/process.ex:17
msgid ""
"Returns `true` if the process exists and is alive (i.e. it is not exiting\n"
"and has not exited yet). Otherwise, returns `false`.\n"
"\n"
"`pid` must refer to a process at the local node.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"プロセスが存在して生きている(つまり、終了中でなく、\n"
"まだ終了が完了していないということです)そのとき、`true`を返します。\n"
"さもなければ`false`を返します。\n"
"\n"
"`pid`はローカルノードのプロセスの参照でなければなりません。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Process.spawn(mod, fun, args, opts)
#: lib/process.ex:310
msgid ""
"Spawns the given module and function passing the given args\n"
"according to the given options.\n"
"\n"
"The result depends on the given options. In particular,\n"
"if `:monitor` is given as an option, it will return a tuple\n"
"containing the pid and the monitoring reference, otherwise\n"
"just the spawned process pid.\n"
"\n"
"It also accepts extra options, for the list of available options\n"
"check [`:erlang.spawn_opt/4`](http://www.erlang.org/doc/man/erlang."
"html#spawn_opt-4).\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"与えられたオプションによって、与えられたモジュールと関数に与えられた引\n"
"数を送ってプロセスを生成します。\n"
"\n"
"戻値は、与えられたオプションによります。特に、`:monitor`オプションが与\n"
"えられると、pidとモニタリファレンスを含むタプルを返し、さもなければ、生\n"
"成されたプロセスのpidを返します。\n"
"\n"
"\n"
"他のオプションも受け入れます。利用できるオプションのリストについては\n"
"[`:erlang.spawn_opt/4`](http://www.erlang.org/doc/man/erlang."
"html#spawn_opt-4)\n"
"をチェックしてください。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Process.info(pid, spec)
#: lib/process.ex:499
msgid ""
"Returns information about the process identified by `pid`\n"
"or `nil` if the process is not alive.\n"
"\n"
"See [`:erlang.process_info/2`](http://www.erlang.org/doc/man/erlang."
"html#process_info-2) for more info.\n"
msgstr ""
"`pid`によるプロセス識別子についての情報を返します。\n"
"プロセスが生きていないなら、`nil`を返します。\n"
"\n"
"詳細は、\n"
"[`:erlang.process_info/2`](http://www.erlang.org/doc/man/erlang."
"html#process_info-2)\n"
"を参照してください。\n"

#. TRANSLATORS: Elixir.Process Summary
#: lib/process.ex:2
msgid ""
"Conveniences for working with processes and the process dictionary.\n"
"\n"
"Besides the functions available in this module, the `Kernel` module\n"
"exposes and auto-imports some basic functionality related to processes\n"
"available through the functions:\n"
"\n"
"  * `Kernel.spawn/1` and `Kernel.spawn/3`\n"
"  * `Kernel.spawn_link/1` and `Kernel.spawn_link/3`\n"
"  * `Kernel.spawn_monitor/1` and `Kernel.spawn_monitor/3`\n"
"  * `Kernel.self/0`\n"
"  * `Kernel.send/2`\n"
"\n"
msgstr ""
"プロセスとプロセス辞書で働くための便利なものです。\n"
"\n"
"このモジュールで利用できる関数の他に、`Kernel`モジュールは、以下の関数\n"
"を通じて利用できるプロセス関連の、基本的機能を公開し、自動インポートし\n"
"ます。\n"
"\n"
"  * `Kernel.spawn/1` 、 `Kernel.spawn/3`\n"
"  * `Kernel.spawn_link/1` 、 `Kernel.spawn_link/3`\n"
"  * `Kernel.spawn_monitor/1` 、 `Kernel.spawn_monitor/3`\n"
"  * `Kernel.self/0`\n"
"  * `Kernel.send/2`\n"
"\n"

#. TRANSLATORS: def Process.registered()
#: lib/process.ex:453
msgid ""
"Returns a list of names which have been registered using `register/2`.\n"
msgstr "`register/2`を使って登録された、名前のリストを返します。\n"

#. TRANSLATORS: def Process.put(key, value)
#: lib/process.ex:74
msgid ""
"Stores the given key-value in the process dictionary.\n"
"\n"
"The return value is the value that was previously stored under the key "
"`key`\n"
"(or `nil` in case no value was stored under `key`).\n"
msgstr ""
"与えられたkey-valueをプロセス辞書に保存します。\n"
"\n"
"キー`key`のもとで保存されていた前の値(`key`で保存された値が\n"
"無い場合は`nil`)を返します。\n"

#. TRANSLATORS: def Process.whereis(name)
#: lib/process.ex:425
msgid ""
"Returns the pid or port identifier with the registered name.\n"
"Returns `nil` if the name is not registered.\n"
"\n"
"See [`:erlang.whereis/1`](http://www.erlang.org/doc/man/erlang."
"html#whereis-1) for more info.\n"
msgstr ""
"pidまたはnameで登録されたポート識別子を返します。nameが登録されていない\n"
"とき、`nil`を返します。\n"
"\n"
"更なる情報は \n"
"[`:erlang.whereis/1`](http://www.erlang.org/doc/man/erlang.html#whereis-1)\n"
"を参照してください。\n"

#. TRANSLATORS: def Process.get(key, default \\ nil)
#: lib/process.ex:40
msgid "Returns the value for the given `key`.\n"
msgstr "与えられた`key`の値を返します。\n"

#. TRANSLATORS: def Process.delete(key)
#: lib/process.ex:85
msgid "Deletes the given `key` from the process dictionary.\n"
msgstr "プロセス辞書から与えられた`key`を削除します。\n"

#. TRANSLATORS: def Process.send_after(dest, msg, time)
#: lib/process.ex:224
msgid ""
"Sends `msg` to `dest` after `time` milliseconds.\n"
"\n"
"If `dest` is a pid, it must be the pid of a local process, dead or alive.\n"
"If `dest` is an atom, it must be the name of a registered process\n"
"which is looked up at the time of delivery. No error is given if the name "
"does\n"
"not refer to a process.\n"
"\n"
"This function returns a timer reference, which can be read or canceled with\n"
"`read_timer/1` and `cancel_timer/1`.\n"
"\n"
"Finally, the timer will be automatically canceled if the given `dest` is a "
"pid\n"
"which is not alive or when the given pid exits. Note that timers will not "
"be\n"
"automatically canceled when `dest` is an atom (as the atom resolution is "
"done\n"
"on delivery).\n"
msgstr ""
"`msg`を`dest`へ`time`ミリ秒後に送信します。\n"
"\n"
"もし`dest`がpidなら、ローカルプロセスのpidで死んでいるか生きているかで\n"
"なければなりません。もし`dest`がアトムなら、配送時に調べられる登録済み\n"
"プロセスの名前でなければなりません。名前がプロセスを差さないならば、エ\n"
"ラーとなりません。\n"
"\n"
"この関数は`read_timer/1`、`:erlang.cancel_timer/1`で読み込み、\n"
"キャンセルができるタイマリファレンスを返します。\n"
"\n"
"最後に、与えられた`pid`が生きていなかったり、存在しなかったりした場合、\n"
"タイマは自動的にキャンセルされます。タイマは`dest`がアトム(アトムは配送\n"
"時に解決されます)の場合、自動的にキャンセルされないことに注意してくださ\n"
"い。\n"

#. TRANSLATORS: def Process.read_timer(timer_ref)
#: lib/process.ex:265
msgid ""
"Reads a timer created by `send_after/3`.\n"
"\n"
"When the result is an integer, it represents the time in milli-seconds\n"
"left until the timer will expire.\n"
"\n"
"When the result is `false`, a timer corresponding to `timer_ref` could\n"
"not be found. This can be either because the timer expired, already has\n"
"been canceled, or because `timer_ref` never corresponded to a timer.\n"
"\n"
"If the timer has expired, the timeout message has been sent, but it does\n"
"not tell you whether or not it has arrived at its destination yet.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"`send_after/3`で作成されたタイマを読みます。\n"
"\n"
"結果が整数のとき、タイマが期限切れになるまでの残りの時間を\n"
"ミリセカンドで表現しています。\n"
"\n"
"結果が`false`のとき、`timer_ref`に一致するタイマがみつからなかった\n"
"ことを示します。これはタイマが期限切れになった、既にキャンセルされた、\n"
"`timer_ref`がタイマに一致しなかった、のいずれも有り得ます。\n"
"\n"
"もしタイマが期限切れになったら、timeoutメッセージが送信されますが、\n"
"それが宛先に到着したか、まだ到着していないかを教えません。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Process.unregister(name)
#: lib/process.ex:415
msgid ""
"Removes the registered name, associated with a pid or a port identifier.\n"
"\n"
"See [`:erlang.unregister/1`](http://www.erlang.org/doc/man/erlang."
"html#unregister-1) for more info.\n"
msgstr ""
"登録されたnameと、それに関連付けられたpidあるいはport識別子を、\n"
"削除します。\n"
"\n"
"詳細は、\n"
"[`:erlang.unregister/1`](http://www.erlang.org/doc/man/erlang."
"html#unregister-1)\n"
"を参照してください。\n"

#~ msgid ""
#~ "Returns all key-values in the dictionary.\n"
#~ "\n"
#~ "Inlined by the compiler.\n"
#~ msgstr ""
#~ "プロセス辞書の全てのキー/値の組を全て返します。\n"
#~ "\n"
#~ "コンパイラによりインライン化されます。\n"

#~ msgid "Stores the given key-value in the process dictionary.\n"
#~ msgstr "プロセス辞書に与えられたキーバリューを保存します。\n"
