msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2016-04-02 20:11+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: def Process.info(pid, spec)
#: lib/process.ex:503
msgid ""
"Returns information about the process identified by `pid`,\n"
"or returns `nil` if the process is not alive.\n"
"\n"
"See [`:erlang.process_info/2`](http://www.erlang.org/doc/man/erlang."
"html#process_info-2) for more info.\n"
msgstr ""
"`pid`によるプロセス識別子についての情報を返します。\n"
"プロセスが生きていないなら、`nil`を返します。\n"
"\n"
"詳細は、\n"
"[`:erlang.process_info/2`](http://www.erlang.org/doc/man/erlang.html#process_info-2)\n"
"を参照してください。\n"

#. TRANSLATORS: def Process.group_leader()
#: lib/process.ex:440
msgid ""
"Returns the pid of the group leader for the process which evaluates the "
"function.\n"
msgstr "関数を評価しているプロセスのグループリーダのpidを返します。\n"

#. TRANSLATORS: def Process.sleep(timeout)
#: lib/process.ex:128
msgid ""
"Sleeps the current process by `timeout`.\n"
"\n"
"`timeout` is either the number of miliseconds to sleep as an\n"
"integer or the atom `:infinity`. When `:infinity` is given,\n"
"the current process will suspend forever.\n"
"\n"
"**Use this function with extreme care**. For almost all situations\n"
"where you would use `sleep/1` in Elixir, there is likely a\n"
"more correct, faster and precise way of achieving it with\n"
"message passing.\n"
"\n"
"For example, if you are waiting a process to perform some\n"
"action, it is better to communicate.\n"
"\n"
"In other words, **do not**:\n"
"\n"
"    Task.start_link fn ->\n"
"      do_something()\n"
"      ...\n"
"    end\n"
"\n"
"    # Wait until work is done\n"
"    Process.sleep(2000)\n"
"\n"
"But **do**:\n"
"\n"
"    parent = self()\n"
"    Task.start_link fn ->\n"
"      do_something()\n"
"      send parent, :work_is_done\n"
"      ...\n"
"    end\n"
"\n"
"    receive do\n"
"      :work_is_done -> :ok\n"
"    after\n"
"      30_000 -> :timeout # Optional timeout\n"
"    end\n"
"\n"
"Or even use `Task.async/1` and `Task.await/2` in the example\n"
"above.\n"
"\n"
"Similarly, if you are waiting for a process to terminate,\n"
"use monitor instead of sleep. **Do not**:\n"
"\n"
"    Task.start_link fn ->\n"
"      ...\n"
"    end\n"
"\n"
"    # Wait until task terminates\n"
"    Process.sleep(2000)\n"
"\n"
"Instead **do**:\n"
"\n"
"    {:ok, pid} =\n"
"      Task.start_link fn ->\n"
"        ...\n"
"      end\n"
"\n"
"    ref = Process.monitor(pid)\n"
"    receive do\n"
"      {:DOWN, ^ref, _, _, _} -> :task_is_down\n"
"    after\n"
"      30_000 -> :timeout # Optional timeout\n"
"    end\n"
"\n"
msgstr ""
"`timeout`だけ現在のプロセスをスリープさせます。\n"
"\n"
"`timeout`はスリープさせるミリ秒を表す数値か、アトム`:infinity`です。\n"
"`:infinity`が与えられると、現在のプロセスは永久にサスペンドします。\n"
"\n"
"**この関数は最新の注意を払って使用してください**。\n"
"Elixirで`sleep/1`を使いたいと思う殆どの場合、\n"
"メッセージパッシングで遣るほうが、もっと正しく、速く、正確です。\n"
"\n"
"例えば、もしいくつかのアクションを実施するためにプロセスを\n"
"待たせるなら、通信するのがよりよいやり方です。\n"
"\n"
"言い替えると、 **以下のようには使わないでください**:\n"
"\n"
"    Task.start_link fn ->\n"
"      do_something()\n"
"      ...\n"
"    end\n"
"\n"
"    # Wait until work is done\n"
"    Process.sleep(2000)\n"
"\n"
"このように **してください**:\n"
"\n"
"    parent = self()\n"
"    Task.start_link fn ->\n"
"      do_something()\n"
"      send parent, :work_is_done\n"
"      ...\n"
"    end\n"
"\n"
"    receive do\n"
"      :work_is_done -> :ok\n"
"    after\n"
"      30_000 -> :timeout # Optional timeout\n"
"    end\n"
"\n"
"あるいは、上の例では`Task.async/1`と`Task.await/2`をそれぞれ\n"
"使ってください。\n"
"\n"
"同じように、もしプロセスの終了を待つなら、sleepのかわりに\n"
"monitorを使ってください。**このようにしないでください**:\n"
"\n"
"    Task.start_link fn ->\n"
"      ...\n"
"    end\n"
"\n"
"    # Wait until task terminates\n"
"    Process.sleep(2000)\n"
"\n"
"かわりに **こうしてください**:\n"
"\n"
"    {:ok, pid} =\n"
"      Task.start_link fn ->\n"
"        ...\n"
"      end\n"
"\n"
"    ref = Process.monitor(pid)\n"
"    receive do\n"
"      {:DOWN, ^ref, _, _, _} -> :task_is_down\n"
"    after\n"
"      30_000 -> :timeout # Optional timeout\n"
"    end\n"
"\n"

#. TRANSLATORS: def Process.group_leader(pid, leader)
#: lib/process.ex:448
msgid ""
"Sets the group leader of `pid` to `leader`. Typically, this is used when a "
"processes\n"
"started from a certain shell should have a group leader other than `:init`.\n"
msgstr ""
"`pid`のグループリーダーを`leader`にセットします。一般的に、特定のシェル\n"
"からスタートするプロセスが`:init`以外のグループリーダーをを持っていなけ\n"
"ればならないとき、これが使われます。\n"

#. TRANSLATORS: def Process.register(pid, name)
#: lib/process.ex:404
msgid ""
"Associates the atom `name` with a `pid` or a port identifier.\n"
"\n"
"`name`, can then be used instead of the `pid` / port identifier with the "
"`Kernel.send/2`\n"
"function. `Process.register/2` will fail with `ArgumentError` if the pid "
"supplied\n"
"is no longer alive, (check with `alive?/1`) or if the name is already "
"registered\n"
"(check with `whereis/1`) or if the `pid` is already registered to a "
"different `name`.\n"
msgstr ""
"`name`を`pid`またはポート識別子と関連付けます。`name`(そ\n"
"れはアトムでなくてはなりません)が、`Kernel.send/2`関数で\n"
"`pid` / ポート識別子のかわりに使うことができます。\n"
"`Process.register/2`は、供給された(`alive?/1`でチェックし\n"
"て)pidが最早生きていない、あるいは、(`whereis/1`でチェッ\n"
"クして)名前がすでに登録ずみなら、`ArgumentError`で失敗し\n"
"ます。\n"

#. TRANSLATORS: def Process.hibernate(mod, fun, args)
#: lib/process.ex:524
msgid ""
"Puts the calling process into a wait state\n"
"where its memory allocation has been reduced as much as possible,\n"
"which is useful if the process does not expect to receive any messages\n"
"in the near future.\n"
"\n"
"See [`:erlang.hibernate/3`](http://www.erlang.org/doc/man/erlang."
"html#hibernate-3) for more info.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"呼出しプロセスをwaitステートにします。\n"
"これは可能な限りメモリアロケーションを縮小します。\n"
"プロセスが近い将来にメッセージをなにも受信することを\n"
"期待しない時に便利です。\n"
"\n"
"詳細は、\n"
"[`:erlang.hibernate/3`](http://www.erlang.org/doc/man/erlang."
"html#hibernate-3)\n"
"を参照してください。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Process.spawn(fun, opts)
#: lib/process.ex:295
msgid ""
"Spawns the given function according to the given options.\n"
"\n"
"The result depends on the given options. In particular,\n"
"if `:monitor` is given as an option, it will return a tuple\n"
"containing the pid and the monitoring reference, otherwise\n"
"just the spawned process pid.\n"
"\n"
"It also accepts extra options, for the list of available options\n"
"check [`:erlang.spawn_opt/4`](http://www.erlang.org/doc/man/erlang."
"html#spawn_opt-4).\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"与えられたオプションによって、与えられたモジュールと関数に与えられた引\n"
"数を送ってプロセスを生成します。\n"
"\n"
"戻値は、与えられたオプションによります。特に、`:monitor`オプションが与\n"
"えられると、pidとモニタリファレンスを含むタプルを返し、さもなければ、生\n"
"成されたプロセスのpidを返します。\n"
"\n"
"他のオプションも受け入れます。利用できるオプションのリストについては\n"
"[`:erlang.spawn_opt/4`](http://www.erlang.org/doc/man/erlang.html#spawn_opt-4)\n"
"をチェックしてください。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Process.link(pid)
#: lib/process.ex:377
msgid ""
"Creates a link between the calling process and another process\n"
"(or port) `pid`, if there is not such a link already.\n"
"\n"
"See [`:erlang.link/1`](http://www.erlang.org/doc/man/erlang.html#link-1) for "
"more info.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"呼び出し側プロセスと他のプロセス(またはport)`pid`の間に、まだ\n"
"リンクがなければ、リンクを作成します。\n"
"\n"
"詳細は、\n"
"[`:erlang.link/1`](http://www.erlang.org/doc/man/erlang.html#link-1)\n"
"を参照してください。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Process.exit(pid, reason)
#: lib/process.ex:93
msgid ""
"Sends an exit signal with the given `reason` to the `pid`.\n"
"\n"
"The following behaviour applies if `reason` is any term except `:normal`\n"
"or `:kill`:\n"
"\n"
"  1. If `pid` is not trapping exits, `pid` will exit with the given\n"
"     `reason`.\n"
"\n"
"  2. If `pid` is trapping exits, the exit signal is transformed into a\n"
"     message `{:EXIT, from, reason}` and delivered to the message queue\n"
"     of `pid`.\n"
"\n"
"  3. If `reason` is the atom `:normal`, `pid` will not exit (unless it\n"
"     is the calling process's pid, in which case it will exit with the\n"
"     reason `:normal`). If it is trapping exits, the exit signal is\n"
"     transformed into a message `{:EXIT, from, :normal}` and delivered\n"
"     to its message queue.\n"
"\n"
"  4. If `reason` is the atom `:kill`, that is if `exit(pid, :kill)` is\n"
"     called, an untrappable exit signal is sent to `pid` which will\n"
"     unconditionally exit with exit reason `:killed`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    Process.exit(pid, :kill)\n"
"\n"
msgstr ""
"与えられた`reason`とともにexitシグナルを`pid`に送ります。\n"
"\n"
"reasonが`:normal`または`:kill`を除いた任意の語なら、以下の振舞いが適用\n"
"されます:\n"
"\n"
"  1. `pid`がexitをトラップなければ、`pid`は与えられた`reason`で終了しま\n"
"     す。\n"
"\n"
"  2. `pid`がexitをトラップしていたら、exitシグナルは`{:EXIT, from,\n"
"     reason}`というメッセージに変換され、`pid`のメッセージキューに配送\n"
"     されます。\n"
"\n"
"  3. `reason`がアトム`:normal`なら、`pid`は終了しないでしょう。(それが\n"
"     呼出しプロセス自身のpidなら、reason `:normal`で終了します) pidが\n"
"     exitをトラップしていたら、exitシグナルは`{:EXIT, from, :normal}`と\n"
"     いうメッセージに変換され、メッセージキューに配送されます。\n"
"\n"
"  4. `reason`がアトム`:kill`なら、つまり、`exit(pid, :kill)`が呼ばれた\n"
"     ら、exitをトラップ出来ないシグナルが`pid`へ送られ、`pidは`無条件で\n"
"     exit reasonとして`:killed`で終了します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## Examples\n"
"\n"
"    Process.exit(pid, :kill)\n"
"\n"

#. TRANSLATORS: def Process.get_keys(value)
#: lib/process.ex:64
msgid ""
"Returns all keys that have the given `value`.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"与えられた`value`をもつキーを全て返します。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Process.flag(pid, flag, value)
#: lib/process.ex:479
msgid ""
"Sets certain flags for the process `pid`, in the same manner as `flag/2`.\n"
"Returns the old value of the `flag`. The allowed values for `flag` are\n"
"only a subset of those allowed in `flag/2`, namely `:save_calls`.\n"
"\n"
"See [`:erlang.process_flag/3`](http://www.erlang.org/doc/man/erlang."
"html#process_flag-3) for more info.\n"
msgstr ""
"`flag/2`と同じマナーで、特定のフラグを`pid`プロセスにセットします。\n"
"そのフラグの古い値を返します。`flag`の許された値は`flag/2`のサブセット\n"
"である`:save_calls`だけです。\n"
"\n"
"更なる情報は\n"
"[`:erlang.process_flag/3`](http://www.erlang.org/doc/man/erlang.html#process_flag-3)\n"
"を参照してください。\n"

#. TRANSLATORS: def Process.unregister(name)
#: lib/process.ex:417
msgid ""
"Removes the registered `name`, associated with a pid or a port identifier.\n"
"\n"
"Fails with `ArgumentError` if the name is not registered to any pid or "
"port.\n"
"\n"
"See [`:erlang.unregister/1`](http://www.erlang.org/doc/man/erlang."
"html#unregister-1) for more info.\n"
msgstr ""
"登録された`name`と、それに関連付けられたpidあるいはport識別子を、\n"
"削除します。\n"
"\n"
"nameがpidやportに登録されていないと、`ArgumentError`で失敗します。\n"
"\n"
"詳細は、\n"
"[`:erlang.unregister/1`](http://www.erlang.org/doc/man/erlang.html#unregister-1)\n"
"を参照してください。\n"

#. TRANSLATORS: def Process.send(dest, msg, options)
#: lib/process.ex:202
msgid ""
"Sends a message to the given process.\n"
"\n"
"If the option `:noconnect` is used and sending the message would require an\n"
"auto-connection to another node the message is not sent and `:noconnect` is\n"
"returned.\n"
"\n"
"If the option `:nosuspend` is used and sending the message would cause the\n"
"sender to be suspended the message is not sent and `:nosuspend` is "
"returned.\n"
"\n"
"Otherwise the message is sent and `:ok` is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Process.send({:name, :node_does_not_exist}, :hi, [:noconnect])\n"
"    :noconnect\n"
"\n"
msgstr ""
"与えられたプロセスへメッセージを送信します。\n"
"\n"
"`:noconnect`オプションが使われ、送信するメッセージがもう一つのノードへ\n"
"の自動接続を要求するならば、メッセージは送信されず、`:noconnect`が返さ\n"
"れます。\n"
"\n"
"`:nosuspend`オプションが使われ、送信するメッセージが送信者をサスペンド\n"
"させることにことになる場合、メッセージは送信されず、`:nosuspend`が返さ\n"
"れます。\n"
"\n"
"さもなくば、メッセージは送信され、`:ok`が返されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Process.send({:name, :node_does_not_exist}, :hi, [:noconnect])\n"
"    :noconnect\n"
"\n"

#. TRANSLATORS: def Process.get()
#: lib/process.ex:30
msgid ""
"Returns all key-value pairs in the process dictionary.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"プロセス辞書の全てのkey-valueの組を全て返します。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Process.unlink(pid)
#: lib/process.ex:390
msgid ""
"Removes the link, if there is one, between the calling process and\n"
"the process or port referred to by `pid`. Returns `true` and does not\n"
"fail, even if there is no link or `id` does not exist\n"
"\n"
"See [`:erlang.unlink/1`](http://www.erlang.org/doc/man/erlang.html#unlink-1) "
"for more info.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"もし、呼び出したプロセスと、`pid`で参照されたプロセスあるいはポートとの\n"
"間にリンクがあれば、それを削除します。\n"
"もしリンクが無い、あるいは`pid`が存在しないとしても、\n"
"失敗せず、`true`を返します。\n"
"\n"
"詳細は \n"
"[`:erlang.unlink/1`](http://www.erlang.org/doc/man/erlang.html#unlink-1)\n"
"を参照してください。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Process.monitor(item)
#: lib/process.ex:332
msgid ""
"The calling process starts monitoring the given `item`.\n"
"It returns the monitor reference.\n"
"\n"
"See [the need for monitoring](http://elixir-lang.org/getting-started/mix-otp/"
"genserver.html#the-need-for-monitoring)\n"
"for an example.\n"
"See [`:erlang.monitor/2`](http://www.erlang.org/doc/man/erlang."
"html#monitor-2) for more info.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"呼び出したプロセスは与えられた`item`のモニタを開始します。\n"
"モニタリファレンスを返します。\n"
"\n"
"例は [the need for monitoring](http://elixir-lang.org/getting-started/mix-otp/genserver.html#the-need-for-monitoring)\n"
"を参照してください。\n"
"\n"
"更なる情報は \n"
"[`:erlang.monitor/2`](http://www.erlang.org/doc/man/erlang.html#monitor-2)\n"
"を参照してください。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Process.get_keys()
#: lib/process.ex:54
msgid ""
"Returns all keys in the process dictionary.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"プロセス辞書の全てのキー/値の組を全て返します。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Process.demonitor(monitor_ref, options \\ [])
#: lib/process.ex:347
msgid ""
"If `monitor_ref` is a reference which the calling process\n"
"obtained by calling `monitor/1`, this monitoring is turned off.\n"
"If the monitoring is already turned off, nothing happens.\n"
"\n"
"See [`:erlang.demonitor/2`](http://www.erlang.org/doc/man/erlang."
"html#demonitor-2) for more info.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"もし`monitor_ref`が`monitor/1`を呼ぶことにより得た参照であるなら、この\n"
"モニタリングはoffにされます。もしモニタリングが既にoffなら、何も起きま\n"
"せん。\n"
"\n"
"詳細は\n"
"[`:erlang.demonitor/2`](http://www.erlang.org/doc/man/erlang."
"html#demonitor-2)\n"
"を参照してください。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Process.cancel_timer(timer_ref)
#: lib/process.ex:249
msgid ""
"Cancels a timer created by `send_after/3`.\n"
"\n"
"When the result is an integer, it represents the time in milliseconds\n"
"left until the timer would have expired.\n"
"\n"
"When the result is `false`, a timer corresponding to `timer_ref` could\n"
"not be found. This can be either because the timer expired, already has\n"
"been canceled, or because `timer_ref` never corresponded to a timer.\n"
"\n"
"If the timer has expired, the timeout message has been sent, but it does\n"
"not tell you whether or not it has arrived at its destination yet.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"`send_after/3`で作成されたタイマをキャンセルします。\n"
"\n"
"結果が整数のとき、タイマが期限切れになるまでの時間をミリセカンドで\n"
"表現しています。\n"
"\n"
"結果が`false`のとき、`timer_ref`に一致するタイマがみつからなかった\n"
"ことを示します。これはタイマが期限切れになった、既にキャンセルされた、\n"
"`timer_ref`がタイマに一致しなかった、のいずれも有り得ます。\n"
"\n"
"もしタイマが期限切れになったら、timeoutメッセージが送信されますが、\n"
"それが宛先に到着したか、まだ到着していないかを教えません。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Process.put(key, value)
#: lib/process.ex:74
msgid ""
"Stores the given `key`-`value` pair in the process dictionary.\n"
"\n"
"The return value is the value that was previously stored under the key "
"`key`\n"
"(or `nil` in case no value was stored under `key`).\n"
msgstr ""
"与えられた`key`-`value`ペアをプロセス辞書に保存します。\n"
"\n"
"キー`key`のもとで保存されていた前の値(`key`で保存された値が\n"
"無い場合は`nil`)を返します。\n"

#. TRANSLATORS: def Process.spawn(mod, fun, args, opts)
#: lib/process.ex:313
msgid ""
"Spawns the given function from module `mod`, passing the given `args`\n"
"according to the given options.\n"
"\n"
"The result depends on the given options. In particular,\n"
"if `:monitor` is given as an option, it will return a tuple\n"
"containing the pid and the monitoring reference, otherwise\n"
"just the spawned process pid.\n"
"\n"
"It also accepts extra options, for the list of available options\n"
"check [`:erlang.spawn_opt/4`](http://www.erlang.org/doc/man/erlang."
"html#spawn_opt-4).\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"与えられたオプションによって、与えられたモジュール`mod`と関数に\n"
"与えられた引数`args`を送ってプロセスを生成します。\n"
"\n"
"戻値は、与えられたオプションによります。特に、`:monitor`オプショ\n"
"ンが与えられると、pidとモニタリファレンスを含むタプルを返し、さ\n"
"もなければ、生成されたプロセスのpidを返します。\n"
"\n"
"\n"
"他のオプションも受け入れます。利用できるオプションのリストについ\n"
"ては\n"
"[`:erlang.spawn_opt/4`](http://www.erlang.org/doc/man/erlang.html#spawn_opt-4)\n"
"をチェックしてください。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Process.whereis(name)
#: lib/process.ex:429
msgid ""
"Returns the pid or port identifier with the registered `name`.\n"
"Returns `nil` if the name is not registered.\n"
"\n"
"See [`:erlang.whereis/1`](http://www.erlang.org/doc/man/erlang."
"html#whereis-1) for more info.\n"
msgstr ""
"pidまたは`name`で登録されたポート識別子を返します。nameが登\n"
"録されていないとき、`nil`を返します。\n"
"\n"
"更なる情報は \n"
"[`:erlang.whereis/1`](http://www.erlang.org/doc/man/erlang.html#whereis-1)\n"
"を参照してください。\n"

#. TRANSLATORS: def Process.flag(flag, value)
#: lib/process.ex:468
msgid ""
"Sets certain flags for the process which calls this function.\n"
"Returns the old value of the `flag`.\n"
"\n"
"See [`:erlang.process_flag/2`](http://www.erlang.org/doc/man/erlang."
"html#process_flag-2) for more info.\n"
msgstr ""
"特定のフラグをこの関数を呼び出したプロセスにセットします。\n"
"その`flag`の古い値を返します。\n"
"\n"
"更なる情報は\n"
"[`:erlang.process_flag/2`](http://www.erlang.org/doc/man/erlang.html#process_flag-2)\n"
"を参照してください。\n"

#. TRANSLATORS: def Process.list()
#: lib/process.ex:362
msgid ""
"Returns a list of process identifiers corresponding to all the\n"
"processes currently existing on the local node.\n"
"\n"
"Note that a process that is exiting, exists but is not alive, i.e.,\n"
"`alive?/1` will return `false` for a process that is exiting,\n"
"but its process identifier will be part of the result returned.\n"
"\n"
"See [`:erlang.processes/0`](http://www.erlang.org/doc/man/erlang."
"html#processes-0) for more info.\n"
msgstr ""
"ローカルノードに現在存在する、全てのプロセスに対応する\n"
"プロセス識別子のリストを返します。\n"
"\n"
"生きていないが、存在する、即ち`alive?/1`が`false`を返すような、終了しよ\n"
"うとしているプロセスのプロセス識別子は、返された結果の一部に含まれるこ\n"
"とに気を付けてください。\n"
"\n"
"詳細は \n"
"[`:erlang.processes/0`](http://www.erlang.org/doc/man/erlang."
"html#processes-0)\n"
"を参照してください。\n"

#. TRANSLATORS: Elixir.Process Summary
#: lib/process.ex:2
msgid ""
"Conveniences for working with processes and the process dictionary.\n"
"\n"
"Besides the functions available in this module, the `Kernel` module\n"
"exposes and auto-imports some basic functionality related to processes\n"
"available through the functions:\n"
"\n"
"  * `Kernel.spawn/1` and `Kernel.spawn/3`\n"
"  * `Kernel.spawn_link/1` and `Kernel.spawn_link/3`\n"
"  * `Kernel.spawn_monitor/1` and `Kernel.spawn_monitor/3`\n"
"  * `Kernel.self/0`\n"
"  * `Kernel.send/2`\n"
"\n"
msgstr ""
"プロセスとプロセス辞書で働くための便利なものです。\n"
"\n"
"このモジュールで利用できる関数の他に、`Kernel`モジュールは、以下の関数\n"
"を通じて利用できるプロセス関連の、基本的機能を公開し、自動インポートし\n"
"ます。\n"
"\n"
"  * `Kernel.spawn/1` 、 `Kernel.spawn/3`\n"
"  * `Kernel.spawn_link/1` 、 `Kernel.spawn_link/3`\n"
"  * `Kernel.spawn_monitor/1` 、 `Kernel.spawn_monitor/3`\n"
"  * `Kernel.self/0`\n"
"  * `Kernel.send/2`\n"
"\n"

#. TRANSLATORS: def Process.registered()
#: lib/process.ex:457
msgid ""
"Returns a list of names which have been registered using `register/2`.\n"
msgstr "`register/2`を使って登録された、名前のリストを返します。\n"

#. TRANSLATORS: def Process.alive?(pid)
#: lib/process.ex:17
msgid ""
"Returns `true` if the process exists and is alive (i.e. it is not exiting\n"
"and has not exited yet). Otherwise, returns `false`.\n"
"\n"
"`pid` must refer to a process at the local node.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"プロセスが存在して生きている(つまり、終了中でなく、\n"
"まだ終了が完了していないということです)そのとき、`true`を返します。\n"
"さもなければ`false`を返します。\n"
"\n"
"`pid`はローカルノードのプロセスの参照でなければなりません。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Process.info(pid)
#: lib/process.ex:491
msgid ""
"Returns information about the process identified by `pid`, or returns `nil` "
"if the process\n"
"is not alive.\n"
"Use this only for debugging information.\n"
"\n"
"See [`:erlang.process_info/1`](http://www.erlang.org/doc/man/erlang."
"html#process_info-1) for more info.\n"
msgstr ""
"`pid`によるプロセス識別子についての情報を返します。\n"
"プロセスが生きていないなら、`nil`を返します。\n"
"これはデバッギング情報のためにだけ使います。\n"
"\n"
"詳細は、\n"
"[`:erlang.process_info/1`](http://www.erlang.org/doc/man/erlang.html#process_info-1)\n"
"を参照してください。\n"

#. TRANSLATORS: def Process.read_timer(timer_ref)
#: lib/process.ex:269
msgid ""
"Reads a timer created by `send_after/3`.\n"
"\n"
"When the result is an integer, it represents the time in milliseconds\n"
"left until the timer will expire.\n"
"\n"
"When the result is `false`, a timer corresponding to `timer_ref` could\n"
"not be found. This can be either because the timer expired, already has\n"
"been canceled, or because `timer_ref` never corresponded to a timer.\n"
"\n"
"If the timer has expired, the timeout message has been sent, but it does\n"
"not tell you whether or not it has arrived at its destination yet.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"`send_after/3`で作成されたタイマを読みます。\n"
"\n"
"結果が整数のとき、タイマが期限切れになるまでの残りの時間を\n"
"ミリセカンドで表現しています。\n"
"\n"
"結果が`false`のとき、`timer_ref`に一致するタイマがみつからなかった\n"
"ことを示します。これはタイマが期限切れになった、既にキャンセルされた、\n"
"`timer_ref`がタイマに一致しなかった、のいずれも有り得ます。\n"
"\n"
"もしタイマが期限切れになったら、timeoutメッセージが送信されますが、\n"
"それが宛先に到着したか、まだ到着していないかを教えません。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Process.get(key, default \\ nil)
#: lib/process.ex:40
msgid ""
"Returns the value for the given `key` or `default` if `key` is not set.\n"
msgstr ""
"与えられた`key`の値を返します。`key`がセットされてなかったら、\n"
"`default`を返します。\n"

#. TRANSLATORS: def Process.delete(key)
#: lib/process.ex:85
msgid "Deletes the given `key` from the process dictionary.\n"
msgstr "プロセス辞書から与えられた`key`を削除します。\n"

#. TRANSLATORS: def Process.send_after(dest, msg, time)
#: lib/process.ex:228
msgid ""
"Sends `msg` to `dest` after `time` milliseconds.\n"
"\n"
"If `dest` is a pid, it must be the pid of a local process, dead or alive.\n"
"If `dest` is an atom, it must be the name of a registered process\n"
"which is looked up at the time of delivery. No error is given if the name "
"does\n"
"not refer to a process.\n"
"\n"
"This function returns a timer reference, which can be read or canceled with\n"
"`read_timer/1` and `cancel_timer/1`.\n"
"\n"
"Finally, the timer will be automatically canceled if the given `dest` is a "
"pid\n"
"which is not alive or when the given pid exits. Note that timers will not "
"be\n"
"automatically canceled when `dest` is an atom (as the atom resolution is "
"done\n"
"on delivery).\n"
msgstr ""
"`msg`を`dest`へ`time`ミリ秒後に送信します。\n"
"\n"
"もし`dest`がpidなら、ローカルプロセスのpidで死んでいるか生きているかで\n"
"なければなりません。もし`dest`がアトムなら、配送時に調べられる登録済み\n"
"プロセスの名前でなければなりません。名前がプロセスを差さないならば、エ\n"
"ラーとなりません。\n"
"\n"
"この関数は`read_timer/1`、`:erlang.cancel_timer/1`で読み込み、\n"
"キャンセルができるタイマリファレンスを返します。\n"
"\n"
"最後に、与えられた`pid`が生きていなかったり、存在しなかったりした場合、\n"
"タイマは自動的にキャンセルされます。タイマは`dest`がアトム(アトムは配送\n"
"時に解決されます)の場合、自動的にキャンセルされないことに注意してくださ\n"
"い。\n"

#~ msgid ""
#~ "Returns all key-values in the dictionary.\n"
#~ "\n"
#~ "Inlined by the compiler.\n"
#~ msgstr ""
#~ "プロセス辞書の全てのキー/値の組を全て返します。\n"
#~ "\n"
#~ "コンパイラによりインライン化されます。\n"

#~ msgid "Stores the given key-value in the process dictionary.\n"
#~ msgstr "プロセス辞書に与えられたキーバリューを保存します。\n"
