msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2015-09-17 14:59+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: @type supervisor
#: lib/supervisor.ex:237
msgid "The supervisor reference"
msgstr "スーパバイザのリファンレンス"

#. TRANSLATORS: def Supervisor.start_link(children, options)
#: lib/supervisor.ex:240
msgid ""
"Starts a supervisor with the given children.\n"
"\n"
"A strategy is required to be given as an option. Furthermore,\n"
"the `:max_restarts` and `:max_seconds` value can be configured\n"
"as described in `Supervisor.Spec.supervise/2` docs.\n"
"\n"
"The options can also be used to register a supervisor name.\n"
"The supported values are described under the `Name Registration`\n"
"section in the `GenServer` module docs.\n"
"\n"
"If the supervisor and its child processes are successfully created\n"
"(i.e. if the start function of all child processes returns `{:ok, child}`,\n"
"`{:ok, child, info}`, or `:ignore`) the function returns\n"
"`{:ok, pid}`, where `pid` is the pid of the supervisor. If there\n"
"already exists a process with the specified name, the function returns\n"
"`{:error, {:already_started, pid}}`, where pid is the pid of that\n"
"process.\n"
"\n"
"If any of the child process start functions fail or return an error tuple "
"or\n"
"an erroneous value, the supervisor will first terminate all already\n"
"started child processes with reason `:shutdown` and then terminate\n"
"itself and return `{:error, {:shutdown, reason}}`.\n"
"\n"
"Note that the `Supervisor` is linked to the parent process\n"
"and will exit not only on crashes but also if the parent process\n"
"exits with `:normal` reason.\n"
msgstr ""
"与えられた子プロセス仕様でスーパバイザを開始します。\n"
"\n"
"再起動戦略はオプションとして要求されます。さらにまた、\n"
"`:max_restarts`と`:max_seconds`の値は`Supervisor.Spec.supervise/2`の\n"
"ドキュメントで記述されているように構成することができます。\n"
"\n"
"オプションはスーパバイザ名を登録するために使うこともできます。\n"
"`GenServer`モジュールドキュメントの`Name Registration`セクションに\n"
"記述されている値がサポートされています。\n"
"\n"
"もしスーパバイザとその子プロセスがうまく作成された(すなわち、\n"
"全ての子プロセスのスタート関数が`{:ok, chlid}`か、`{:ok, child, info}`\n"
"または、`:ignore`を返したら)ならば、関数は`pid`はスーパバイザの\n"
"プロセス識別子として`{:ok, pid}`を返します。\n"
"もし既に指定された名前のプロセスが存在していたならば、関数は、\n"
"そのプロセスのプロセス識別子をpidとして`{:error, {:already_started, pid}}`\n"
"を返します。\n"
"\n"
"もし子プロセスのどれかのスタート関数が失敗するか、あるいは\n"
"エラータプルあるいは誤った値を返すならば、スーパバイザは\n"
"最初に全ての開始済の子プロセスを`:shutdown` reasonで停止し、それから\n"
"自分自身を停止して`{:error, {:shutdown, reason}}`を返します。\n"
"\n"
"`Supervisor`は親プロセスにリンクされていて、クラッシュするだけではなく\n"
"親プロセスが`:normal` reasonで終了するかもしれないことに気を付けてくだ\n"
"さい。\n"

#. TRANSLATORS: def Supervisor.start_link(module, arg, options \\ [])
#: lib/supervisor.ex:274
msgid ""
"Starts a supervisor module with the given `arg`.\n"
"\n"
"To start the supervisor, the `init/1` callback will be invoked\n"
"in the given module. The `init/1` callback must return a\n"
"supervision specification which can be created with the help\n"
"of `Supervisor.Spec` module.\n"
"\n"
"If the `init/1` callback returns `:ignore`, this function returns\n"
"`:ignore` as well and the supervisor terminates with reason `:normal`.\n"
"If it fails or returns an incorrect value, this function returns\n"
"`{:error, term}` where `term` is a term with information about the\n"
"error, and the supervisor terminates with reason `term`.\n"
"\n"
"The `:name` option can also be given in order to register a supervisor\n"
"name, the supported values are described under the `Name Registration`\n"
"section in the `GenServer` module docs.\n"
"\n"
"Other failure conditions are specified in `start_link/2` docs.\n"
msgstr ""
"与えられた引数でスーパバイザモジュールを開始します。\n"
"\n"
"スーパバイザを開始するために、与えられたモジュールの\n"
"`init/1`コールバックが実行されます。`init/1`コールバックは\n"
"`Supervisor.Spec`モジュールの助けで作成できる監督仕様を\n"
"返さなくてはなりません。\n"
"\n"
"もし`init/1`コールバックが`:ignore`を返したら、この関数も\n"
"`:ignore`を返し、スーパバイザは`:normal` reasonで終了します。\n"
"もし`init/`が失敗したり、間違った値を返してきたら、この関数は\n"
"`term`をエラーについての情報として、`{:error, term}`を返し、\n"
"スーパバイザは`term` reasonで終了します。\n"
"\n"
"`:name`オプションはスーパバイザ名を登録するために使うこともできます。\n"
"`GenServer`モジュールドキュメントの`Name Registration`セクションに\n"
"記述されている値がサポートされています。\n"
"\n"
"他の失敗の条件は`start_link/2`のドキュメントに説明されています。\n"

#. TRANSLATORS: @type name
#: lib/supervisor.ex:228
msgid "The Supervisor name"
msgstr "スーパバイザの名前"

#. TRANSLATORS: def Supervisor.terminate_child(supervisor, pid_or_child_id)
#: lib/supervisor.ex:341
msgid ""
"Terminates the given pid or child id.\n"
"\n"
"If the supervisor is not a `simple_one_for_one`, the child id is expected\n"
"and the process, if there is one, is terminated; the child specification is\n"
"kept unless the child is temporary.\n"
"\n"
"In case of a `simple_one_for_one` supervisor, a pid is expected. If the "
"child\n"
"specification identifier is given instead of a `pid`, the function will\n"
"return `{:error, :simple_one_for_one}`.\n"
"\n"
"A non-temporary child process may later be restarted by the supervisor. The "
"child\n"
"process can also be restarted explicitly by calling `restart_child/2`. Use\n"
"`delete_child/2` to remove the child specification.\n"
"\n"
"If successful, the function returns `:ok`. If there is no child "
"specification or\n"
"pid, the function returns `{:error, :not_found}`.\n"
msgstr ""
"与えられたpidかchild idを終了します。\n"
"\n"
"もしスーパバイザが`simple_one_for_one`でないなら、child idが期待され、\n"
"そのプロセスはまだ生きていれば終了されます; 子プロセスがテンポラ\n"
"リでない限り、child仕様は保持されます。\n"
"\n"
"`simple_one_for_one`スーパバイザの場合、pidが期待されます。もしchild仕\n"
"様識別子が`pid`の代りに与えられたなら、関数は`{:error,\n"
":simple_one_for_one}`を返します。\n"
"\n"
"非テンポラリ子プロセスはスーパバイザにより後でリスタートされます。子プ\n"
"ロセスは、`restart_child/2`を呼び出すことにより明示的にリスタートするこ\n"
"とも出来ます。child仕様を削除するには`delete_child/2`を使います。\n"
"\n"
"成功すると、関数は`:ok`を返します。もしchild仕様あるいはpidがないなら、\n"
"関数は`{:error, :not_found}`を返します。\n"

#. TRANSLATORS: @type on_start_child
#: lib/supervisor.ex:222
msgid "Return values of `start_child` functions"
msgstr "`start_child`関数の戻値"

#. TRANSLATORS: @type on_start
#: lib/supervisor.ex:218
msgid "Return values of `start_link` functions"
msgstr "`start_link`関数の戻値"

#. TRANSLATORS: def Supervisor.restart_child(supervisor, child_id)
#: lib/supervisor.ex:383
msgid ""
"Restarts a child process identified by `child_id`.\n"
"\n"
"The child specification must exist and the corresponding child process must "
"not\n"
"be running.\n"
"\n"
"Note that for temporary children, the child specification is automatically "
"deleted\n"
"when the child terminates, and thus it is not possible to restart such "
"children.\n"
"\n"
"If the child process start function returns `{:ok, child}` or\n"
"`{:ok, child, info}`, the pid is added to the supervisor and the function "
"returns\n"
"the same value.\n"
"\n"
"If the child process start function returns `:ignore`, the pid remains set "
"to\n"
"`:undefined` and the function returns `{:ok, :undefined}`.\n"
"\n"
"This function may error with an appropriate error tuple if the `child_id` is "
"not\n"
"found, or if the current process is running or being restarted.\n"
"\n"
"If the child process start function returns an error tuple or an erroneous "
"value,\n"
"or if it fails, the function returns `{:error, error}`.\n"
"\n"
"This operation is not supported by `simple_one_for_one` supervisors.\n"
msgstr ""
"`child_id`で指定される子プロセスをリスタートします。\n"
"\n"
"子仕様が存在しなくてはならず、対応する子プロセスは実行中では\n"
"いけません。\n"
"\n"
"テンポラリの子については、子仕様は子が終了すると自動的に削除され、リス\n"
"タートする可能性は無いことに注意してください。\n"
"\n"
"もし子プロセスのスタート関数が`{:ok, child}`または`{:ok, child,\n"
"info}`を返すと、そのpidがスーパバイザに追加され、\n"
"関数は同じ値を返します。\n"
"\n"
"もし子プロセスのスタート関数が`:ignore`を返したら、pidは`:undefined`に\n"
"セットされたままで、関数は`{:ok, :undefined}`を返します。\n"
"\n"
"この関数は、`child_id`が見付からない、あるいは、現在のプロセスが実行中\n"
"でリスタートされたときには、適切なエラーを示すタプルでエラーとなるかも\n"
"しれません。\n"
"\n"
"もし子プロセスのスタート関数がエラータプルあるいは、間違った値を返した\n"
"ら、あるいは失敗したら、関数は`{:error, error}`を返します。\n"
"\n"
"このオペレーションは`simple_one_for_one`スーパバイザではサポートされて\n"
"いません。\n"

#. TRANSLATORS: def Supervisor.count_children(supervisor)
#: lib/supervisor.ex:442
msgid ""
"Returns a map containing count values for the supervisor.\n"
"\n"
"The map contains the following keys:\n"
"\n"
"  * `:specs` - the total count of children, dead or alive\n"
"\n"
"  * `:active` - the count of all actively running child processes managed "
"by\n"
"    this supervisor\n"
"\n"
"  * `:supervisors` - the count of all supervisors whether or not the child\n"
"    process is still alive\n"
"\n"
"  * `:workers` - the count of all workers, whether or not the child process\n"
"    is still alive\n"
"\n"
msgstr ""
"スーパバイザの子の数を含むマップを返します。\n"
"\n"
"マップは以下のキーを含みます:\n"
"\n"
"  * `:specs` - 生死を問わず、子の全数\n"
"\n"
"  * `:active` - このスーパバイザで管理された実行中のアクティブな\n"
"     子プロセスの数\n"
"\n"
"  * `:supervisors` - 子プロセスが生きているかは問わず、全ての\n"
"     スーパバイザの数\n"
"\n"
"  * `:workers` - 子プロセスが生きているかは問わず、全ての\n"
"     ワーカの数\n"
"\n"

#. TRANSLATORS: def Supervisor.start_child(supervisor, child_spec_or_args)
#: lib/supervisor.ex:307
msgid ""
"Dynamically adds and starts a child specification to the supervisor.\n"
"\n"
"`child_spec` should be a valid child specification (unless the supervisor\n"
"is a `:simple_one_for_one` supervisor, see below). The child process will\n"
"be started as defined in the child specification.\n"
"\n"
"In the case of `:simple_one_for_one`, the child specification defined in\n"
"the supervisor will be used and instead of a `child_spec`, an arbitrary "
"list\n"
"of terms is expected. The child process will then be started by appending\n"
"the given list to the existing function arguments in the child "
"specification.\n"
"\n"
"If a child specification with the specified id already exists,\n"
"`child_spec` is discarded and the function returns an error with `:"
"already_started`\n"
"or `:already_present` if the corresponding child process is running or not.\n"
"\n"
"If the child process starts, function returns `{:ok, child}` or `{:ok, "
"child, info}`,\n"
"the child specification and pid is added to the supervisor and the function "
"returns\n"
"the same value.\n"
"\n"
"If the child process starts, function returns `:ignore`, the child "
"specification is\n"
"added to the supervisor, the pid is set to undefined and the function "
"returns\n"
"`{:ok, :undefined}`.\n"
"\n"
"If the child process starts, function returns an error tuple or an erroneous "
"value,\n"
"or if it fails, the child specification is discarded and the function "
"returns\n"
"`{:error, error}` where `error` is a term containing information about the "
"error\n"
"and child specification.\n"
msgstr ""
"スーパバイザに、子プロセス仕様を\n"
"動的に追加し、開始します。\n"
"\n"
"`child_spec`は有効な子プロセス仕様でなければなりません(スーパバイザが\n"
"`:simple_one_for_one`スーパバイザでない限り。下を参照してください)。\n"
"子プロセスは、子プロセス仕様に定義されているように開始されます。\n"
"\n"
"`:simple_one_for_one`の場合、スーパバイザで定義された子プロセス仕様が使\n"
"われ、`child_spec`のかわりに、任意の語のリストが予想されます。それから、\n"
"子プロセス仕様に存在する関数引数に与えられたリストを追加することによっ\n"
"て、子プロセスは開始します。\n"
"\n"
"指定されたIDの子プロセス仕様が既に存在していたら、\n"
"`child_spec`は捨てられ、関数は、\n"
"対応する子プロセスが動作しているか否かで、\n"
"`:already_started`か`:already_present`のエラーを返します。\n"
"\n"
"子プロセスのスタート関数が`{:ok, child}`か`{:ok, child, info}`を返したら、\n"
"子プロセス仕様とpidはスーパバイザに追加され、関数は\n"
"同じ値を返します。\n"
"\n"
"子プロセスのスタート関数が`:ignore`を返したら、\n"
"子プロセス仕様はスーパバイザに追加され、pidは`:undefined`にセットされ、\n"
"関数は`{:ok, :undefined}`を返します。\n"
"\n"
"子プロセスのスタート関数が、エラータプルか正しくない値を返すか、\n"
"あるいは、失敗したら、子プロセス仕様は捨てられ、関数は、\n"
"`error`を上記のエラーと子プロセス仕様についての情報を含む語として、\n"
"`{:error, error}`を返します。\n"

#. TRANSLATORS: def Supervisor.delete_child(supervisor, child_id)
#: lib/supervisor.ex:365
msgid ""
"Deletes the child specification identified by `child_id`.\n"
"\n"
"The corresponding child process must not be running, use "
"`terminate_child/2`\n"
"to terminate it.\n"
"\n"
"If successful, the function returns `:ok`. This function may error with an\n"
"appropriate error tuple if the `child_id` is not found, or if the current\n"
"process is running or being restarted.\n"
"\n"
"This operation is not supported by `simple_one_for_one` supervisors.\n"
msgstr ""
"`child_id`によって識別される子仕様を削除します。\n"
"\n"
"対応する子プロセスは動作していてはいけません。それを終了するために、\n"
"`terminate_child/2`を使ってください。\n"
"\n"
"成功すると、関数は`:ok`を返します。この関数は`child_id`が見付からないか、\n"
"現在のプロセスがそれを走らせているか、再起動中なら、適切なerrorタプルと\n"
"ともにエラーとなります。\n"
"\n"
"この操作は、`simple_one_for_one`スーパバイザはサポートされません。\n"

#. TRANSLATORS: @type options
#: lib/supervisor.ex:231
msgid "Options used by the `start*` functions"
msgstr "`start*`関数で使われるオプション"

#. TRANSLATORS: def Supervisor.which_children(supervisor)
#: lib/supervisor.ex:414
msgid ""
"Returns a list with information about all children.\n"
"\n"
"Note that calling this function when supervising a large number of children\n"
"under low memory conditions can cause an out of memory exception.\n"
"\n"
"This function returns a list of tuples containing:\n"
"\n"
"  * `id` - as defined in the child specification or `:undefined` in the "
"case\n"
"    of a `simple_one_for_one` supervisor\n"
"\n"
"  * `child` - the pid of the corresponding child process, the atom\n"
"    `:restarting` if the process is about to be restarted, or `:undefined` "
"if\n"
"    there is no such process\n"
"\n"
"  * `type` - `:worker` or `:supervisor` as defined in the child "
"specification\n"
"\n"
"  * `modules` – as defined in the child specification\n"
msgstr ""
"全ての子についての情報のリストを返します。\n"
"\n"
"この関数をローメモリ状況の下で、多数の子を監督している時にこの関数を\n"
"呼び出すことが、アウトオブメモリ例外を引き起すことが有り得ることに\n"
"注意してください。\n"
"\n"
"この関数は以下を含んだタプルのリストを返します:\n"
"\n"
"  * `id` - 子仕様で定義されたidまたは、`simple_one_for_one`スーパバイザでは\n"
"      `:undefined`です\n"
"\n"
"  * `child` - 子プロセスに対応したpidです。\n"
"    もしプロセスが再起動されていたら`:restarting`を、もしそのような\n"
"    プロセスがなければ`:undefined`を返します\n"
"\n"
"  * `type` - 子仕様で定義された、`:worker` または `:supervisor` です\n"
"\n"
"  * `modules` – 子仕様が定義されたモジュールです。\n"
"\n"

#. TRANSLATORS: Elixir.Supervisor Summary
#: lib/supervisor.ex:2
msgid ""
"A behaviour module for implementing supervision functionality.\n"
"\n"
"A supervisor is a process which supervises other processes called\n"
"child processes. Supervisors are used to build a hierarchical process\n"
"structure called a supervision tree, a nice way to structure fault-tolerant\n"
"applications.\n"
"\n"
"A supervisor implemented using this module will have a standard set\n"
"of interface functions and include functionality for tracing and error\n"
"reporting. It will also fit into a supervision tree.\n"
"\n"
"## Example\n"
"\n"
"In order to define a supervisor, we need to first define a child process\n"
"that is going to be supervised. In order to do so, we will define a "
"GenServer\n"
"that represents a stack:\n"
"\n"
"    defmodule Stack do\n"
"      use GenServer\n"
"\n"
"      def start_link(state, opts \\ []) do\n"
"        GenServer.start_link(__MODULE__, state, opts)\n"
"      end\n"
"\n"
"      def handle_call(:pop, _from, [h|t]) do\n"
"        {:reply, h, t}\n"
"      end\n"
"\n"
"      def handle_cast({:push, h}, t) do\n"
"        {:noreply, [h|t]}\n"
"      end\n"
"    end\n"
"\n"
"We can now define our supervisor and start it as follows:\n"
"\n"
"    # Import helpers for defining supervisors\n"
"    import Supervisor.Spec\n"
"\n"
"    # We are going to supervise the Stack server which\n"
"    # will be started with a single argument [:hello]\n"
"    # and the default name of :sup_stack.\n"
"    children = [\n"
"      worker(Stack, [[:hello], [name: :sup_stack]])\n"
"    ]\n"
"\n"
"    # Start the supervisor with our one child\n"
"    {:ok, pid} = Supervisor.start_link(children, strategy: :one_for_one)\n"
"\n"
"Notice that when starting the GenServer, we are registering it\n"
"with name `:sup_stack`, which allows us to call it directly and\n"
"get what is on the stack:\n"
"\n"
"    GenServer.call(:sup_stack, :pop)\n"
"    #=> :hello\n"
"\n"
"    GenServer.cast(:sup_stack, {:push, :world})\n"
"    #=> :ok\n"
"\n"
"    GenServer.call(:sup_stack, :pop)\n"
"    #=> :world\n"
"\n"
"However, there is a bug in our stack server. If we call `:pop` and\n"
"the stack is empty, it is going to crash because no clause matches.\n"
"Let's try it:\n"
"\n"
"    GenServer.call(:sup_stack, :pop)\n"
"    ** (exit) exited in: GenServer.call(:sup_stack, :pop, 5000)\n"
"\n"
"Luckily, since the server is being supervised by a supervisor, the\n"
"supervisor will automatically start a new one, with the default stack\n"
"of `[:hello]` like before:\n"
"\n"
"    GenServer.call(:sup_stack, :pop) == :hello\n"
"\n"
"Supervisors support different strategies; in the example above, we\n"
"have chosen `:one_for_one`. Furthermore, each supervisor can have many\n"
"workers and supervisors as children, each of them with their specific\n"
"configuration, shutdown values, and restart strategies.\n"
"\n"
"Continue reading this moduledoc to learn more about supervision strategies\n"
"and then follow to the `Supervisor.Spec` module documentation to learn\n"
"about the specification for workers and supervisors.\n"
"\n"
"## Module-based supervisors\n"
"\n"
"In the example above, a supervisor was dynamically created by passing\n"
"the supervision structure to `start_link/2`. However, supervisors\n"
"can also be created by explicitly defining a supervision module:\n"
"\n"
"    defmodule MyApp.Supervisor do\n"
"      use Supervisor\n"
"\n"
"      def start_link do\n"
"        Supervisor.start_link(__MODULE__, [])\n"
"      end\n"
"\n"
"      def init([]) do\n"
"        children = [\n"
"          worker(Stack, [[:hello]])\n"
"        ]\n"
"\n"
"        supervise(children, strategy: :one_for_one)\n"
"      end\n"
"    end\n"
"\n"
"You may want to use a module-based supervisor if:\n"
"\n"
"  * You need to do some particular action on supervisor\n"
"    initialization, like setting up an ETS table.\n"
"\n"
"  * You want to perform partial hot-code swapping of the\n"
"    tree. For example, if you add or remove children,\n"
"    the module-based supervision will add and remove the\n"
"    new children directly, while the dynamic supervision\n"
"    requires the whole tree to be restarted in order to\n"
"    perform such swaps.\n"
"\n"
"## Strategies\n"
"\n"
"  * `:one_for_one` - if a child process terminates, only that\n"
"    process is restarted.\n"
"\n"
"  * `:one_for_all` - if a child process terminates, all other child\n"
"    processes are terminated and then all child processes (including\n"
"    the terminated one) are restarted.\n"
"\n"
"  * `:rest_for_one` - if a child process terminates, the \"rest\" of\n"
"    the child processes, i.e. the child processes after the terminated\n"
"    one in start order, are terminated. Then the terminated child\n"
"    process and the rest of the child processes are restarted.\n"
"\n"
"  * `:simple_one_for_one` - similar to `:one_for_one` but suits better\n"
"    when dynamically attaching children. This strategy requires the\n"
"    supervisor specification to contain only one child. Many functions\n"
"    in this module behave slightly differently when this strategy is\n"
"    used.\n"
"\n"
"## Simple one for one\n"
"\n"
"The simple one for one supervisor is useful when you want to dynamically\n"
"start and stop supervisor children. For example, imagine you want to\n"
"dynamically create multiple stacks. We can do so by defining a simple one\n"
"for one supervisor:\n"
"\n"
"    # Import helpers for defining supervisors\n"
"    import Supervisor.Spec\n"
"\n"
"    # This time, we don't pass any argument because\n"
"    # the argument will be given when we start the child\n"
"    children = [\n"
"      worker(Stack, [], restart: :transient)\n"
"    ]\n"
"\n"
"    # Start the supervisor with our one child\n"
"    {:ok, sup_pid} = Supervisor.start_link(children, strategy: :"
"simple_one_for_one)\n"
"\n"
"There are a couple differences here:\n"
"\n"
"  * The simple one for one specification can define only one child which\n"
"    works as a template for when we call `start_child/2`\n"
"\n"
"  * We have define the child to have restart strategy of transient. This\n"
"    means that, if the child process exits due to a `:normal`, `:shutdown`\n"
"    or `{:shutdown, term}` reason, it won't be restarted. This is useful\n"
"    as it allows our workers to politely shutdown and be removed from the\n"
"    simple one for one supervisor, without being restarted. You can find\n"
"    more information about restart strategies on `Supervisor.Spec`\n"
"\n"
"With the supervisor defined, let's dynamically start stacks:\n"
"\n"
"    {:ok, pid} = Supervisor.start_child(sup_pid, [[:hello, :world], []])\n"
"    GenServer.call(pid, :pop) #=> :hello\n"
"    GenServer.call(pid, :pop) #=> :world\n"
"\n"
"    {:ok, pid} = Supervisor.start_child(sup_pid, [[:something, :else], []])\n"
"    GenServer.call(pid, :pop) #=> :something\n"
"    GenServer.call(pid, :pop) #=> :else\n"
"\n"
"    Supervisor.count_children(sup_pid)\n"
"    #=> %{active: 2, specs: 1, supervisors: 0, workers: 2}\n"
"\n"
"## Exit reasons\n"
"\n"
"From the example above, you may have noticed that the transient restart\n"
"strategy for the worker does not restart the child in case it crashes with\n"
"reason `:normal`, `:shutdown` or `{:shutdown, term}`.\n"
"\n"
"So one may ask: which exit reason should I choose when existing my worker?\n"
"There are three options:\n"
"\n"
"  * `:normal` - on such cases, the exit won't be logged, there is no "
"restart\n"
"    on transient mode and linked processes do not exit\n"
"\n"
"  * `:shutdown` or `{:shutdown, term}` - on such cases, the exit won't be\n"
"    logged, there is no restart on transient mode and linked processes exit\n"
"    with the same reason unless trapping exits\n"
"\n"
"  * any other term - on such cases, the exit will be logged, there are\n"
"    restarts on transient mode and linked processes exit with the same "
"reason\n"
"    unless trapping exits\n"
"\n"
"## Name Registration\n"
"\n"
"A supervisor is bound to the same name registration rules as a `GenServer`.\n"
"Read more about it in the `GenServer` docs.\n"
msgstr ""
"スーパビジョン機能を実装するためのビヘイビアモジュールです。\n"
"\n"
"スーパバイザは、子プロセスと呼ばれる他のプロセスをスーパバイズするプロ\n"
"セスです。スーパバイザは、フォールトトレラントアプリケーションを構築す\n"
"るための良い方法である、スーパビジョンツリーと呼ばれる、プロセスの階層\n"
"構造を作るために使われます。\n"
"\n"
"このモジュールを使って実装されたスーパバイザは、\n"
"標準的なインタフェース関数のセットを持ち、トレースと\n"
"エラーレポートの機能を含みます。それはスーパビジョンツリーにも\n"
"適合します。\n"
"\n"
"## 例\n"
"\n"
"スーパバイザを定義するために、スーパバイズされる子プロセスを最初に定義する\n"
"必要があります。それをするために、スタックを表現するGenServerを定義します:\n"
"\n"
"    defmodule Stack do\n"
"      use GenServer\n"
"\n"
"      def start_link(state) do\n"
"        GenServer.start_link(__MODULE__, state, [name: :sup_stack])\n"
"      end\n"
"\n"
"      def handle_call(:pop, _from, [h|t]) do\n"
"        {:reply, h, t}\n"
"      end\n"
"\n"
"      def handle_cast({:push, h}, t) do\n"
"        {:noreply, [h|t]}\n"
"      end\n"
"    end\n"
"\n"
"今や、私達のスーパバイザを定義し、それを下の様にして開始できます:\n"
"\n"
"    # Import helpers for defining supervisors\n"
"    import Supervisor.Spec\n"
"\n"
"    # We are going to supervise the Stack server which will\n"
"    # be started with a single argument [:hello]\n"
"    children = [\n"
"      worker(Stack, [[:hello], [name: :sup_stack]])\n"
"    ]\n"
"\n"
"    # Start the supervisor with our one child\n"
"    {:ok, pid} = Supervisor.start_link(children, strategy: :one_for_one)\n"
"\n"
"`:sup_stack`という名前で登録してGenServerをスタートするとき、\n"
"それを直接呼び出したり呼び出してスタックの値を得ることができる\n"
"ことに注意してください:\n"
"\n"
"    GenServer.call(:sup_stack, :pop)\n"
"    #=> :hello\n"
"\n"
"    GenServer.cast(:sup_stack, {:push, :world})\n"
"    #=> :ok\n"
"\n"
"    GenServer.call(:sup_stack, :pop)\n"
"    #=> :world\n"
"\n"
"しかしながら、私達のスタックサーバにはバグがあります。スタックが\n"
"空のときに`:pop`を呼び出したら、no clause matchesでクラッシュします:\n"
"\n"
"    GenServer.call(:sup_stack, :pop)\n"
"    ** (exit) exited in: GenServer.call(:sup_stack, :pop, 5000)\n"
"\n"
"幸運にも、サーバがスーパバイザによりスーパバイズされていたら、\n"
"スーパバイザは自動的に新しいサーバを開始します。前のような\n"
"`[:hello]`のデフォルトスタックもセットされます:\n"
"\n"
"    GenServer.call(:sup_stack, :pop) == :hello\n"
"\n"
"スーパバイザは異る戦略をサポートします; 上の例では、`:one_for_one`を選\n"
"択しました。更にまた、それぞれのスーパバイザは多くのワーカとスーパバイ\n"
"ザを子供として持つことができ、それぞれ特定のshutdown値やrestart戦略といっ\n"
"た構成を持つことができます。\n"
"\n"
"スーパビジョン戦略についてより学ぶために、このモジュールドキュメント\n"
"の続きを読んでください。そして、それから\n"
"workerとsupervisorのための子プロセス仕様について\n"
"学ぶために`Supervisor.Spec`モジュールドキュメントを読んでください。\n"
"\n"
"## Module-based supervisors\n"
"\n"
"上の例では、スーパバイザは、`start_link/2`へスーパビジョン構造を\n"
"送ることにより、動的に作成されました。しかしながら、スーパバイザは\n"
"スーパビジョンモジュールを明示的に定義することによって作成することも\n"
"出来ます:\n"
"\n"
"    defmodule MyApp.Supervisor do\n"
"      use Supervisor\n"
"\n"
"      def start_link do\n"
"        Supervisor.start_link(__MODULE__, [])\n"
"      end\n"
"\n"
"      def init([]) do\n"
"        children = [\n"
"          worker(Stack, [[:hello]])\n"
"        ]\n"
"\n"
"        supervise(children, strategy: :one_for_one)\n"
"      end\n"
"    end\n"
"\n"
"以下のようなとき、module-basedスーパバイザを使いたくなるかもしれません:\n"
"\n"
"  * ETSテーブルのセットアップのような、\n"
"    スーパバイザの初期化の特定のアクションをしたい。\n"
"\n"
"  * ツリーの部分的なホットコードスワッピングを実行したい。\n"
"    例えば、子プロセスを追加あるいは削除したとき、\n"
"    module-basedスーパビジョンは、直接、子プロセスを\n"
"    追加、削除します。一方、\n"
"    動的なスーパビジョンは、そのスワップを実行するために\n"
"    木全体の再起動を要求します。\n"
"\n"
"## Strategies\n"
"\n"
"  * `:one_for_one` - \n"
"    子プロセスが終了したら、そのプロセスだけが再起動されます\n"
"\n"
"  * `:one_for_all` - \n"
"    子プロセスが終了したら、他の全てのプロセスが終了され、\n"
"    それから、全ての子プロセス(終了したものも含みます)が、\n"
"    再起動されます。\n"
"\n"
"  * `:rest_for_one` - \n"
"    子プロセスが終了したら、子プロセスの\"rest\"(即ち、\n"
"    その子プロセスが開始した後にに開始した子プロセス)は終了します。\n"
"\n"
"  * `:simple_one_for_one` - `:one_for_one`に似ていますが、動的に\n"
"    子プロセスをアタッチする時には、より適合します。このストラテジは\n"
"    一種類の子プロセスだけを含むことをスーパバイザ仕様に要求します。\n"
"    このストラテジが使われるとき、このモジュールの多くの関数は僅かに\n"
"    異る振る舞いをします。\n"
"\n"
"## Simple one for one\n"
"\n"
"simple one for oneスーパバイザは動的にstart, stopしたい時に便利です。\n"
"たとえば、複数のスタックを動的に作成したい時などです。\n"
"simple one for oneスーパバイザを以下のようにして定義できます:\n"
"\n"
"    # Import helpers for defining supervisors\n"
"    import Supervisor.Spec\n"
"\n"
"    # This time, we don't pass any argument because\n"
"    # the argument will be given when we start the child\n"
"    children = [\n"
"      worker(Stack, [], restart: :transient)\n"
"    ]\n"
"\n"
"    # Start the supervisor with our one child\n"
"    {:ok, sup_pid} = Supervisor.start_link(children, strategy: :"
"simple_one_for_one)\n"
"\n"
"いくつかの違いがあります:\n"
"\n"
"  * simple one for one仕様は`start_child/2`を呼ぶときに\n"
"    テンプレートとして使われるだけです\n"
"    The simple one for one specification can define only one child which\n"
"    works as a template for when we call `start_child/2`\n"
"\n"
"  * childをtransient再起動ストラテジで定義します。\n"
"    これは以下を意味します。もしchildプロセスが`:normal,\n"
"    `:shutdown`または`{:shutdown, term}` reason で終了したら、\n"
"    再起動されません。これは礼儀正しくシャットダウンすることを\n"
"    workerに許し、それは再起動されることなくsimple one for one\n"
"    スーパバイザから削除され、便利です。\n"
"    再起動ストラテジの詳細は `Supervisor.Spec` を参照してください。\n"
"\n"
"supervisorを定義したので、動的にスタックを開始しましょう:\n"
"\n"
"    {:ok, pid} = Supervisor.start_child(sup_pid, [[:hello, :world], []])\n"
"    GenServer.call(pid, :pop) #=> :hello\n"
"    GenServer.call(pid, :pop) #=> :world\n"
"\n"
"    {:ok, pid} = Supervisor.start_child(sup_pid, [[:something, :else], []])\n"
"    GenServer.call(pid, :pop) #=> :something\n"
"    GenServer.call(pid, :pop) #=> :else\n"
"\n"
"    Supervisor.count_children(sup_pid)\n"
"    #=> %{active: 2, specs: 1, supervisors: 0, workers: 2}\n"
"\n"
"## Exit reasons\n"
"\n"
"上の例から、workerのためのtransient再起動ストラテジは\n"
"reason `:normal`, `:shutdown` または `{:shutdown, term}`で\n"
"クラッシュした場合、childは再起動されないことに気が付くでしょう。\n"
"\n"
"だから一つ疑問がでるでしょう: workerを終了させるとき、\n"
"どのexit reason を選べばいいのか?\n"
"3つのオプションがあります:\n"
"\n"
"  * `:normal` - この場合、logされず、再起動されず、リンクされた\n"
"    プロセスも終了されません\n"
"\n"
"  * `:shutdown` or `{:shutdown, term}` - この場合、logされず、\n"
"    再起動されず、リンクされたプロセスはexitがトラップされていない\n"
"    限り、同じreasonで終了します\n"
"\n"
"  * any other term - この場合、logされ、再起動され、\n"
"    リンクされたプロセスはexitがトラップされていない限り、同じ\n"
"    reasonで終了します\n"
"\n"
"## Name Registration\n"
"\n"
"Supervisorは、`GenServer`と同じ名前登録規則に従います。\n"
"それについてはの詳細は、`GenServer`のドキュメントを参照してください。\n"
