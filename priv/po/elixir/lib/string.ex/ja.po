msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2016-02-21 09:16+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: def String.chunk(string, trait)
#: lib/string.ex:1087
msgid ""
"Splits the string into chunks of characters that share a common trait.\n"
"\n"
"The trait can be one of two options:\n"
"\n"
"  * `:valid`     - the string is split into chunks of valid and invalid "
"character\n"
"    sequences\n"
"\n"
"  * `:printable` - the string is split into chunks of printable and\n"
"    non-printable character sequences\n"
"\n"
"Returns a list of binaries each of which contains only one kind of\n"
"characters.\n"
"\n"
"If the given string is empty, an empty list is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.chunk(<<?a, ?b, ?c, 0>>, :valid)\n"
"    [\"abc\\0\"]\n"
"\n"
"    iex> String.chunk(<<?a, ?b, ?c, 0, 0x0ffff::utf8>>, :valid)\n"
"    [\"abc\\0\", <<0x0ffff::utf8>>]\n"
"\n"
"    iex> String.chunk(<<?a, ?b, ?c, 0, 0x0ffff::utf8>>, :printable)\n"
"    [\"abc\", <<0, 0x0ffff::utf8>>]\n"
"\n"
msgstr ""
"文字列を共通するtrait(特質)の文字の塊に分割します。\n"
"\n"
"特質(trait)は二つのオプションのうちひとつを取ることができます:\n"
"\n"
"  * `:valid`     - 文字列は文字列として有効か無効かにより塊に分割されます。\n"
"\n"
"  * `:printable` - 文字列は文字列として表示可能か表示不可能かにより\n"
"    塊に分割されます。\n"
"\n"
"それぞれの種類のみを含むバイナリのリストを返します。\n"
"\n"
"与えられた文字列が空なら、空のリストが返されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.chunk(<<?a, ?b, ?c, 0>>, :valid)\n"
"    [\"abc\\0\"]\n"
"\n"
"    iex> String.chunk(<<?a, ?b, ?c, 0, 0x0ffff::utf8>>, :valid)\n"
"    [\"abc\\0\", <<0x0ffff::utf8>>]\n"
"\n"
"    iex> String.chunk(<<?a, ?b, ?c, 0, 0x0ffff::utf8>>, :printable)\n"
"    [\"abc\", <<0, 0x0ffff::utf8>>]\n"
"\n"

#. TRANSLATORS: def String.replace_trailing(string, match, replacement)
#: lib/string.ex:638
msgid ""
"Replaces all trailing occurences of `match` by `replacement` in `string`.\n"
"\n"
"Returns the string untouched if there are no occurrences.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.replace_trailing(\"hello world\", \" world\", \"\")\n"
"    \"hello\"\n"
"    iex> String.replace_trailing(\"hello world world\", \" world\", \"\")\n"
"    \"hello\"\n"
"\n"
"    iex> String.replace_trailing(\"hello world\", \" world\", \" mundo\")\n"
"    \"hello mundo\"\n"
"    iex> String.replace_trailing(\"hello world world\", \" world\", \" mundo"
"\")\n"
"    \"hello mundo mundo\"\n"
"\n"
msgstr ""
"`match`にマッチする`string`中のトレイリングを`replacement`に置換します。\n"
"\n"
"マッチしないなら文字列は変更されずに返されます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.replace_trailing(\"hello world\", \" world\", \"\")\n"
"    \"hello\"\n"
"    iex> String.replace_trailing(\"hello world world\", \" world\", \"\")\n"
"    \"hello\"\n"
"\n"
"    iex> String.replace_trailing(\"hello world\", \" world\", \" mundo\")\n"
"    \"hello mundo\"\n"
"    iex> String.replace_trailing(\"hello world world\", \" world\", \" mundo"
"\")\n"
"    \"hello mundo mundo\"\n"
"\n"

#. TRANSLATORS: def String.to_float(string)
#: lib/string.ex:1684
msgid ""
"Returns a float whose text representation is `string`.\n"
"\n"
"`string` must be the string representation of a float.\n"
"If a string representation of an integer wants to be used,\n"
"then `Float.parse/1` should be used instead,\n"
"otherwise an argument error will be raised.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.to_float(\"2.2017764e+0\")\n"
"    2.2017764\n"
"\n"
"    iex> String.to_float(\"3.0\")\n"
"    3.0\n"
"\n"
msgstr ""
"テキスト`string`が表現する浮動小数点数を返します。\n"
"\n"
"`string`は浮動小数点数の文字列表現でなくてはなりません。\n"
"もし整数の文字列表現を使いたいなら、`Float.parse/1`を代わりに\n"
"使うべきです。さもなければ、argument errorが上ります。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.to_float(\"2.2017764e+0\")\n"
"    2.2017764\n"
"\n"
"    iex> String.to_float(\"3.0\")\n"
"    3.0\n"
"\n"

#. TRANSLATORS: def String.replace_leading(string, match, replacement)
#: lib/string.ex:600
msgid ""
"Replaces all leading occurences of `match` by `replacement` of `match` in "
"`string`.\n"
"\n"
"Returns the string untouched if there are no occurrences.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.replace_leading(\"hello world\", \"hello \", \"\")\n"
"    \"world\"\n"
"    iex> String.replace_leading(\"hello hello world\", \"hello \", \"\")\n"
"    \"world\"\n"
"\n"
"    iex> String.replace_leading(\"hello world\", \"hello \", \"ola \")\n"
"    \"ola world\"\n"
"    iex> String.replace_leading(\"hello hello world\", \"hello \", \"ola "
"\")\n"
"    \"ola ola world\"\n"
"\n"
msgstr ""
"`string`中`match`にマッチする全ての文字列を`replacement`に置換します。\n"
"\n"
"マッチしないなら文字列は変更されずに返されます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.replace_leading(\"hello world\", \"hello \", \"\")\n"
"    \"world\"\n"
"    iex> String.replace_leading(\"hello hello world\", \"hello \", \"\")\n"
"    \"world\"\n"
"\n"
"    iex> String.replace_leading(\"hello world\", \"hello \", \"ola \")\n"
"    \"ola world\"\n"
"    iex> String.replace_leading(\"hello hello world\", \"hello \", \"ola "
"\")\n"
"    \"ola ola world\"\n"
"\n"

#. TRANSLATORS: def String.replace_suffix(string, match, replacement)
#: lib/string.ex:711
msgid ""
"Replaces suffix in `string` by `replacement` if it matches `match`.\n"
"\n"
"Returns the string untouched if there is no match.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.replace_suffix(\"hello\", \" world\", \"\")\n"
"    \"hello\"\n"
"    iex> String.replace_suffix(\"hello world\", \" world\", \"\")\n"
"    \"hello\"\n"
"    iex> String.replace_suffix(\"hello world world\", \" world\", \"\")\n"
"    \"hello world\"\n"
"\n"
"    iex> String.replace_suffix(\"hello\", \" world\", \" mundo\")\n"
"    \"hello\"\n"
"    iex> String.replace_suffix(\"hello world\", \" world\", \" mundo\")\n"
"    \"hello mundo\"\n"
"    iex> String.replace_suffix(\"hello world world\", \" world\", \" mundo"
"\")\n"
"    \"hello world mundo\"\n"
"\n"
msgstr ""
"`match`にマッチする`string`中のサフィックスを`replacement`に置換します。\n"
"\n"
"マッチしないなら文字列は変更されずに返されます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.replace_suffix(\"hello\", \" world\", \"\")\n"
"    \"hello\"\n"
"    iex> String.replace_suffix(\"hello world\", \" world\", \"\")\n"
"    \"hello\"\n"
"    iex> String.replace_suffix(\"hello world world\", \" world\", \"\")\n"
"    \"hello world\"\n"
"\n"
"    iex> String.replace_suffix(\"hello\", \" world\", \" mundo\")\n"
"    \"hello\"\n"
"    iex> String.replace_suffix(\"hello world\", \" world\", \" mundo\")\n"
"    \"hello mundo\"\n"
"    iex> String.replace_suffix(\"hello world world\", \" world\", \" mundo"
"\")\n"
"    \"hello world mundo\"\n"
"\n"

#. TRANSLATORS: def String.replace(subject, pattern, replacement, options \\ [])
#: lib/string.ex:869
msgid ""
"Returns a new string created by replacing occurences of `pattern` in\n"
"`subject` with `replacement`.\n"
"\n"
"By default, it replaces all occurences, unless the `global` option is\n"
"set to `false`, where it will only replace the first one\n"
"\n"
"The `pattern` may be a string or a regular expression.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.replace(\"a,b,c\", \",\", \"-\")\n"
"    \"a-b-c\"\n"
"\n"
"    iex> String.replace(\"a,b,c\", \",\", \"-\", global: false)\n"
"    \"a-b,c\"\n"
"\n"
"When the pattern is a regular expression, one can give `\\N` or\n"
"`\\g{N}` in the `replacement` string to access a specific capture in the\n"
"regular expression:\n"
"\n"
"    iex> String.replace(\"a,b,c\", ~r/,(.)/, \",\\\\1\\\\g{1}\")\n"
"    \"a,bb,cc\"\n"
"\n"
"Notice we had to escape the escape character `\\`. By giving `\\0`,\n"
"one can inject the whole matched pattern in the replacement string.\n"
"\n"
"When the pattern is a string, a developer can use the replaced part inside\n"
"the `replacement` by using the `:insert_replace` option and specifying the\n"
"position(s) inside the `replacement` where the string pattern will be\n"
"inserted:\n"
"\n"
"    iex> String.replace(\"a,b,c\", \"b\", \"[]\", insert_replaced: 1)\n"
"    \"a,[b],c\"\n"
"\n"
"    iex> String.replace(\"a,b,c\", \",\", \"[]\", insert_replaced: 2)\n"
"    \"a[],b[],c\"\n"
"\n"
"    iex> String.replace(\"a,b,c\", \",\", \"[]\", insert_replaced: [1, 1])\n"
"    \"a[,,]b[,,]c\"\n"
"\n"
"If any position given in the `:insert_replace` option is larger than the\n"
"replacement string, or is negative, an `ArgumentError` is raised.\n"
msgstr ""
"`subject`に基いて`pattern`にマッチした部分を`replacement`で置き換えた、\n"
"新しい文字列を返します。\n"
"\n"
"`global`オプションを`false`にしないかぎり、デフォルトでは、\n"
"全部のエントリを置き換えます。`false`にすると最初の一つの\n"
"エントリのみを置き換えます。\n"
"\n"
"`pattern`は文字列か正規表現です。\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.replace(\"a,b,c\", \",\", \"-\")\n"
"    \"a-b-c\"\n"
"\n"
"    iex> String.replace(\"a,b,c\", \",\", \"-\", global: false)\n"
"    \"a-b,c\"\n"
"\n"
"パターンが正規表現の時、それらのケースでは、`replacement`文字列\n"
"中で、正規表現中で捕捉した文字列にアクセスするために`\\N`または`\\g{N}`を\n"
"使うことができます:\n"
"\n"
"    iex> String.replace(\"a,b,c\", ~r/,(.)/, \",\\\\1\\\\1\")\n"
"    \"a,bb,cc\"\n"
"\n"
"エスケープ文字`\\`を使わなくてはならないことに注意してください。\n"
"`\\0`を与えることにより、置き換え文字列の中でパターンにマッチした\n"
"全体を捕捉することができます。\n"
"\n"
"パターンが文字列の時、開発者は`replacement`の\n"
"内側に、`:insert_replaced`オプションによりパターンを埋め込む\n"
"位置を指定することが出来ます。: \n"
"\n"
"    iex> String.replace(\"a,b,c\", \"b\", \"[]\", insert_replaced: 1)\n"
"    \"a,[b],c\"\n"
"\n"
"    iex> String.replace(\"a,b,c\", \",\", \"[]\", insert_replaced: 2)\n"
"    \"a[],b[],c\"\n"
"\n"
"    iex> String.replace(\"a,b,c\", \",\", \"[]\", insert_replaced: [1, 1])\n"
"    \"a[,,]b[,,]c\"\n"
"\n"
"`:inert_replace`オプションに与えられた位置がreplacement文字列より\n"
"大きい、または負の数なら、`ArgumentError`が上ります。\n"

#. TRANSLATORS: def String.at(string, position)
#: lib/string.ex:1268
msgid ""
"Returns the grapheme at the `position` of the given utf8 `string`.\n"
"If `position` is greater than `string` length, then it returns `nil`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.at(\"elixir\", 0)\n"
"    \"e\"\n"
"\n"
"    iex> String.at(\"elixir\", 1)\n"
"    \"l\"\n"
"\n"
"    iex> String.at(\"elixir\", 10)\n"
"    nil\n"
"\n"
"    iex> String.at(\"elixir\", -1)\n"
"    \"r\"\n"
"\n"
"    iex> String.at(\"elixir\", -10)\n"
"    nil\n"
"\n"
msgstr ""
"与えられたutf8の`string`の`position`の位置の書記素を返します。\n"
"`position`が`string`の長さより大きいなら、`nil`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.at(\"elixir\", 0)\n"
"    \"e\"\n"
"\n"
"    iex> String.at(\"elixir\", 1)\n"
"    \"l\"\n"
"\n"
"    iex> String.at(\"elixir\", 10)\n"
"    nil\n"
"\n"
"    iex> String.at(\"elixir\", -1)\n"
"    \"r\"\n"
"\n"
"    iex> String.at(\"elixir\", -10)\n"
"    nil\n"
"\n"

#. TRANSLATORS: def String.reverse(string)
#: lib/string.ex:933
msgid ""
"Reverses the graphemes in given string.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.reverse(\"abcd\")\n"
"    \"dcba\"\n"
"\n"
"    iex> String.reverse(\"hello world\")\n"
"    \"dlrow olleh\"\n"
"\n"
"    iex> String.reverse(\"hello ∂og\")\n"
"    \"go∂ olleh\"\n"
"\n"
"Keep in mind reversing the same string twice does\n"
"not necessarily yield the original string:\n"
"\n"
"    iex> \"̀e\"\n"
"    \"̀e\"\n"
"    iex> String.reverse(\"̀e\")\n"
"    \"è\"\n"
"    iex> String.reverse String.reverse(\"̀e\")\n"
"    \"è\"\n"
"\n"
"In the first example the accent is before the vowel, so\n"
"it is considered two graphemes. However, when you reverse\n"
"it once, you have the vowel followed by the accent, which\n"
"becomes one grapheme. Reversing it again will keep it as\n"
"one single grapheme.\n"
msgstr ""
"与えられた文字列の書記素を反対にします。\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.reverse(\"abcd\")\n"
"    \"dcba\"\n"
"\n"
"    iex> String.reverse(\"hello world\")\n"
"    \"dlrow olleh\"\n"
"\n"
"    iex> String.reverse(\"hello ∂og\")\n"
"    \"go∂ olleh\"\n"
"\n"
"同じ文字列を二回reverseしても元の文字列に戻るとは\n"
"限らないことに注意してください:\n"
"\n"
"    iex> \"̀e\"\n"
"    \"̀e\"\n"
"    iex> String.reverse(\"̀e\")\n"
"    \"è\"\n"
"    iex> String.reverse String.reverse(\"̀e\")\n"
"    \"è\"\n"
"\n"
"最初の例ではアクセント記号は母音の前にあるので、\n"
"二つの書記素と考えられます。しかしながら、\n"
"一度reverseすると、アクセントが続く母音となり、\n"
"一書記素となります。それを再びreverseしても一つの\n"
"書記素として維持されます。\n"

#. TRANSLATORS: def String.next_grapheme_size(string)
#: lib/string.ex:1192
msgid ""
"Returns the size of the next grapheme.\n"
"\n"
"The result is a tuple with the next grapheme size and\n"
"the remainder of the string or `nil` in case the string\n"
"reached its end.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.next_grapheme_size(\"olá\")\n"
"    {1, \"lá\"}\n"
"\n"
msgstr ""
"文字列の中の次の書記素のサイズを返します。\n"
"\n"
"結果は、書記素のサイズと、文字列の残りまたは、文字列が\n"
"その終わりに到達したときは`nil`、のタプルです。\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.next_grapheme_size(\"olá\")\n"
"    {1, \"lá\"}\n"
"\n"

#. TRANSLATORS: def String.strip(string, char)
#: lib/string.ex:794
msgid ""
"Returns a string where all leading and trailing `char`s have been\n"
"removed.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.strip(\"a  abc  a\", ?a)\n"
"    \"  abc  \"\n"
"\n"
msgstr ""
"先頭、末尾の全ての`char`を取り除いた文字列を返します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.strip(\"a  abc  a\", ?a)\n"
"    \"  abc  \"\n"
"\n"

#. TRANSLATORS: def String.ends_with?(string, suffixes)
#: lib/string.ex:1495
msgid ""
"Returns `true` if `string` ends with any of the suffixes given.\n"
"\n"
"`suffixes` can be either a single suffix or a list of suffixes.\n"
"\n"
"Raises argument error if an empty string is given.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.ends_with? \"language\", \"age\"\n"
"    true\n"
"\n"
"    iex> String.ends_with? \"language\", [\"youth\", \"age\"]\n"
"    true\n"
"\n"
"    iex> String.ends_with? \"language\", [\"youth\", \"elixir\"]\n"
"    false\n"
"\n"
msgstr ""
"もし、`string`が与えらえれたサフィックスの何れかで終了していれば、\n"
"`true`を返します。\n"
"\n"
"`suffixes`は一つの文字列でも、サフィイクスのリストでもよいです。\n"
"\n"
"空の文字列が与えられたらargument errorを上げます。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.ends_with? \"language\", \"age\"\n"
"    true\n"
"\n"
"    iex> String.ends_with? \"language\", [\"youth\", \"age\"]\n"
"    true\n"
"\n"
"    iex> String.ends_with? \"language\", [\"youth\", \"elixir\"]\n"
"    false\n"
"\n"

#. TRANSLATORS: def String.to_char_list(string)
#: lib/string.ex:1581
msgid ""
"Converts a string into a char list.\n"
"\n"
"Specifically, this functions takes a UTF-8 encoded binary and returns a list "
"of its integer\n"
"codepoints. It is similar to `codepoints/1` except that the latter returns a "
"list of codepoints as\n"
"strings.\n"
"\n"
"In case you need to work with bytes, take a look at the\n"
"[`:binary` module](http://www.erlang.org/doc/man/binary.html).\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.to_char_list(\"æß\")\n"
"    'æß'\n"
msgstr ""
"文字列を文字リスト(char list)に変換します。\n"
"\n"
"特に、この関数はUTF-8エンコードされた文字列をとり、\n"
"その整数コードポイントのリストを返します。\n"
"この関数は、文字列としてコードポイントのリストを返すことを除いては、\n"
"`codepoint/1`と似ています。\n"
"\n"
"バイト列で動くものが欲しい場合、\n"
"[`:binary` module](http://www.erlang.org/doc/man/binary.html)\n"
"を参照してください。\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.to_char_list(\"æß\")\n"
"    'æß'\n"

#. TRANSLATORS: def String.normalize(string, form)
#: lib/string.ex:482
msgid ""
"Converts all characters in `string` to Unicode normalization\n"
"form identified by `form`.\n"
"\n"
"## Forms\n"
"\n"
"The supported forms are:\n"
"\n"
"  * `:nfd` - Normalization Form Canonical Decomposition.\n"
"    Characters are decomposed by canonical equivalence, and\n"
"    multiple combining characters are arranged in a specific\n"
"    order.\n"
"\n"
"  * `:nfc` - Normalization Form Canonical Composition.\n"
"    Characters are decomposed and then recomposed by canonical equivalence.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.normalize(\"yêṩ\", :nfd)\n"
"    \"yêṩ\"\n"
"\n"
"    iex> String.normalize(\"leña\", :nfc)\n"
"    \"leña\"\n"
"\n"
msgstr ""
"`string`の全ての文字を`form`により示されたUnicode \n"
"normalization formに変換します。\n"
"\n"
"## Forms\n"
"\n"
"サポートしているformは:\n"
"\n"
"  * `:nfd` - Normalization Form Canonical Decomposition.\n"
"    文字は規範的な同等なものに分解され、\n"
"    複数の組合さった文字は特定の順序で整理されます。\n"
"\n"
"  * `:nfc` - Normalization Form Canonical Composition.\n"
"    文字は分解され、それから規範的な同等なもので作り直されます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.normalize(\"yêṩ\", :nfd)\n"
"    \"yêṩ\"\n"
"\n"
"    iex> String.normalize(\"leña\", :nfc)\n"
"    \"leña\"\n"
"\n"

#. TRANSLATORS: def String.strip(string)
#: lib/string.ex:778
msgid ""
"Returns a string where all leading and trailing Unicode whitespaces\n"
"have been removed.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.strip(\"   abc  \")\n"
"    \"abc\"\n"
"\n"
msgstr ""
"先頭、末尾の全てのUnicodeホワイトスペース文字を取り除いた文字列を返します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.strip(\"   abc  \")\n"
"    \"abc\"\n"
"\n"

#. TRANSLATORS: def String.capitalize(string)
#: lib/string.ex:546
msgid ""
"Converts the first character in the given string to\n"
"uppercase and the remainder to lowercase.\n"
"\n"
"This relies on the titlecase information provided\n"
"by the Unicode Standard. Note this function makes\n"
"no attempt to capitalize all words in the string\n"
"(usually known as titlecase).\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.capitalize(\"abcd\")\n"
"    \"Abcd\"\n"
"\n"
"    iex> String.capitalize(\"ﬁn\")\n"
"    \"Fin\"\n"
"\n"
"    iex> String.capitalize(\"olá\")\n"
"    \"Olá\"\n"
"\n"
msgstr ""
"与えられた文字列の最初の文字を大文字に、残りを\n"
"小文字に変換します。\n"
"\n"
"これはUnicode標準により提供される、titlecase情報に依存しています。\n"
"この関数は、(通常titlecaseとして知られる)文字列の全ての語を\n"
"大文字にしようとしない点に、注意してください。\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.capitalize(\"abcd\")\n"
"    \"Abcd\"\n"
"\n"
"    iex> String.capitalize(\"ﬁn\")\n"
"    \"Fin\"\n"
"\n"
"    iex> String.capitalize(\"olá\")\n"
"    \"Olá\"\n"
"\n"

#. TRANSLATORS: def String.upcase(binary)
#: lib/string.ex:510
msgid ""
"Converts all characters in the given string to uppercase.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.upcase(\"abcd\")\n"
"    \"ABCD\"\n"
"\n"
"    iex> String.upcase(\"ab 123 xpto\")\n"
"    \"AB 123 XPTO\"\n"
"\n"
"    iex> String.upcase(\"olá\")\n"
"    \"OLÁ\"\n"
"\n"
msgstr ""
"与えられた文字列の全ての文字を大文字に変換します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.upcase(\"abcd\")\n"
"    \"ABCD\"\n"
"\n"
"    iex> String.upcase(\"ab 123 xpto\")\n"
"    \"AB 123 XPTO\"\n"
"\n"
"    iex> String.upcase(\"olá\")\n"
"    \"OLÁ\"\n"
"\n"

#. TRANSLATORS: def String.contains?(string, contents)
#: lib/string.ex:1547
msgid ""
"Checks if `string` contains any of the given `contents`.\n"
"\n"
"`contents` can be either a single string or a list of strings.\n"
"\n"
"Raises argument error if an empty string is given.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.contains? \"elixir of life\", \"of\"\n"
"    true\n"
"\n"
"    iex> String.contains? \"elixir of life\", [\"life\", \"death\"]\n"
"    true\n"
"\n"
"    iex> String.contains? \"elixir of life\", [\"death\", \"mercury\"]\n"
"    false\n"
"\n"
"The argument can also be a precompiled pattern:\n"
"\n"
"    iex> pattern = :binary.compile_pattern([\"life\", \"death\"])\n"
"    iex> String.contains? \"elixir of life\", pattern\n"
"    true\n"
"\n"
msgstr ""
"`string`が与えられた`contents`のどれかを含んでいるかをチェックします。\n"
"\n"
"`contents`は単一の文字列でも文字列のリストでも構いません。\n"
"\n"
"空の文字列が与えられたら、argument errorを上げます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.contains? \"elixir of life\", \"of\"\n"
"    true\n"
"\n"
"    iex> String.contains? \"elixir of life\", [\"life\", \"death\"]\n"
"    true\n"
"\n"
"    iex> String.contains? \"elixir of life\", [\"death\", \"mercury\"]\n"
"    false\n"
"\n"
"引数はプリコンパイルされたパターンでも構いません:\n"
"\n"
"    iex> pattern = :binary.compile_pattern([\"life\", \"death\"])\n"
"    iex> String.contains? \"elixir of life\", pattern\n"
"    true\n"
"\n"

#. TRANSLATORS: def String.lstrip(string, char)
#: lib/string.ex:758
msgid ""
"Returns a string where all leading `char`s have been removed.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.lstrip(\"_  abc  _\", ?_)\n"
"    \"  abc  _\"\n"
"\n"
msgstr ""
"先頭の全ての`char`を取り除いた文字列を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.lstrip(\"_  abc  _\", ?_)\n"
"    \"  abc  _\"\n"
"\n"

#. TRANSLATORS: def String.lstrip(binary)
#: lib/string.ex:746
msgid ""
"Returns a string where all leading Unicode whitespaces\n"
"have been removed.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.lstrip(\"   abc  \")\n"
"    \"abc  \"\n"
"\n"
msgstr ""
"先頭の全てのUnicodeホワイトスペース文字を取り除いた文字列を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.lstrip(\"   abc  \")\n"
"    \"abc  \"\n"
"\n"

#. TRANSLATORS: def String.equivalent?(string1, string2)
#: lib/string.ex:450
msgid ""
"Returns `true` if `string1` is canonically equivalent to 'string2'.\n"
"\n"
"It performs Normalization Form Canonical Decomposition (NFD) on the\n"
"strings before comparing them. This function is equivalent to:\n"
"\n"
"    String.normalize(string1, :nfd) == String.normalize(string2, :nfd)\n"
"\n"
"Therefore, if you plan to compare multiple strings, multiple times\n"
"in a row, you may normalize them upfront and compare them directly\n"
"to avoid multiple normalization passes.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.equivalent?(\"abc\", \"abc\")\n"
"    true\n"
"\n"
"    iex> String.equivalent?(\"man\\u0303ana\", \"mañana\")\n"
"    true\n"
"\n"
"    iex> String.equivalent?(\"abc\", \"ABC\")\n"
"    false\n"
"\n"
"    iex> String.equivalent?(\"nø\", \"nó\")\n"
"    false\n"
"\n"
msgstr ""
"`string1`が`string2`に規範的に等しいなら`true`を返します。\n"
"\n"
"それらを比較する前に、Normalization Form Canonical Decomposition (NFD)\n"
"に変換します。この関数は以下と同等です:\n"
"\n"
"    String.normalize(string1, :nfd) == String.normalize(string2, :nfd)\n"
"\n"
"従って、複数の文字列の比較をする計画なら、複数の正規化パスを避けるため\n"
"に、事前に正規化した上で、直接比較するかもしれません。\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.equivalent?(\"abc\", \"abc\")\n"
"    true\n"
"\n"
"    iex> String.equivalent?(\"man\\u0303ana\", \"mañana\")\n"
"    true\n"
"\n"
"    iex> String.equivalent?(\"abc\", \"ABC\")\n"
"    false\n"
"\n"
"    iex> String.equivalent?(\"nø\", \"nó\")\n"
"    false\n"
"\n"

#. TRANSLATORS: def String.rstrip(binary)
#: lib/string.ex:573
msgid ""
"Returns a string where all trailing Unicode whitespaces\n"
"has been removed.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.rstrip(\"   abc  \")\n"
"    \"   abc\"\n"
"\n"
msgstr ""
"末尾の全てのUnicodeのホワイトスペース文字を取り除いた文字列を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.rstrip(\"   abc  \")\n"
"    \"   abc\"\n"
"\n"

#. TRANSLATORS: def String.split_at(string, position)
#: lib/string.ex:400
msgid ""
"Splits a string into two at the specified offset. When the offset given is\n"
"negative, location is counted from the end of the string.\n"
"\n"
"The offset is capped to the length of the string. Returns a tuple with\n"
"two elements.\n"
"\n"
"Note: keep in mind this function splits on graphemes and for such it\n"
"has to linearly traverse the string. If you want to split a string or\n"
"a binary based on the number of bytes, use `Kernel.binary_part/3`\n"
"instead.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.split_at \"sweetelixir\", 5\n"
"    {\"sweet\", \"elixir\"}\n"
"\n"
"    iex> String.split_at \"sweetelixir\", -6\n"
"    {\"sweet\", \"elixir\"}\n"
"\n"
"    iex> String.split_at \"abc\", 0\n"
"    {\"\", \"abc\"}\n"
"\n"
"    iex> String.split_at \"abc\", 1000\n"
"    {\"abc\", \"\"}\n"
"\n"
"    iex> String.split_at \"abc\", -1000\n"
"    {\"\", \"abc\"}\n"
"\n"
msgstr ""
"文字列を指定したオフセットで二つに分割します。与えられたオフセットが負\n"
"なら、文字列の終わりから場所を数えます。\n"
"\n"
"オフセットは文字列の長さでキャップされます。\n"
"二つの要素のタプルが返されます。\n"
"\n"
"この関数は書記素で分割し、そのため\n"
"線形に文字列をトラバースすることに注意してください。\n"
"もし、文字列やバイナリをバイト数に基いて分割したいなら、\n"
"代わりに`Kernel.binary_part/3`を使ってください。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.split_at \"sweetelixir\", 5\n"
"    {\"sweet\", \"elixir\"}\n"
"\n"
"    iex> String.split_at \"sweetelixir\", -6\n"
"    {\"sweet\", \"elixir\"}\n"
"\n"
"    iex> String.split_at \"abc\", 0\n"
"    {\"\", \"abc\"}\n"
"\n"
"    iex> String.split_at \"abc\", 1000\n"
"    {\"abc\", \"\"}\n"
"\n"
"    iex> String.split_at \"abc\", -1000\n"
"    {\"\", \"abc\"}\n"
"\n"

#. TRANSLATORS: def String.valid?(string)
#: lib/string.ex:1042
msgid ""
"Checks whether `string` contains only valid characters.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.valid?(\"a\")\n"
"    true\n"
"\n"
"    iex> String.valid?(\"ø\")\n"
"    true\n"
"\n"
"    iex> String.valid?(<<0xffff :: 16>>)\n"
"    false\n"
"\n"
"    iex> String.valid?(\"asd\" <> <<0xffff :: 16>>)\n"
"    false\n"
"\n"
msgstr ""
"`string`が有効な文字だけを含んでいるかどうかをチェックします。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.valid?(\"a\")\n"
"    true\n"
"\n"
"    iex> String.valid?(\"ø\")\n"
"    true\n"
"\n"
"    iex> String.valid?(<<0xffff :: 16>>)\n"
"    false\n"
"\n"
"    iex> String.valid?(\"asd\" <> <<0xffff :: 16>>)\n"
"    false\n"
"\n"

#. TRANSLATORS: def String.to_atom(string)
#: lib/string.ex:1610
msgid ""
"Converts a string to an atom.\n"
"\n"
"Currently Elixir does not support the conversion of strings\n"
"that contain Unicode codepoints greater than 0xFF.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.to_atom(\"my_atom\")\n"
"    :my_atom\n"
"\n"
msgstr ""
"文字列をアトムに変換します。\n"
"\n"
"現在のElixirは、0xFFを越えるUnicodeコードポイントを含む\n"
"文字列からの変換をサポートしていません。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.to_atom(\"my_atom\")\n"
"    :my_atom\n"
"\n"

#. TRANSLATORS: def String.ljust(subject, len, pad \\ 32)
#: lib/string.ex:831
msgid ""
"Returns a new string of length `len` with `subject` left justified and "
"padded\n"
"with `pad`. If `pad` is not present, it defaults to whitespace. When\n"
"`len` is less than the length of `subject`, `subject` is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.ljust(\"abc\", 5)\n"
"    \"abc  \"\n"
"\n"
"    iex> String.ljust(\"abc\", 5, ?-)\n"
"    \"abc--\"\n"
"\n"
msgstr ""
"`subject`を左寄せして、`pad`でパディングした、長さ`len`の新しい文字列を\n"
"返します。もし`pad`がなければ、空白文字がデフォルトです。`len`が\n"
"`subject`の長さより小さいとき、`subject`が返されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.ljust(\"abc\", 5)\n"
"    \"abc  \"\n"
"\n"
"    iex> String.ljust(\"abc\", 5, ?-)\n"
"    \"abc--\"\n"
"\n"

#. TRANSLATORS: def String.graphemes(string)
#: lib/string.ex:1145
msgid ""
"Returns Unicode graphemes in the string as per Extended Grapheme\n"
"Cluster algorithm.\n"
"\n"
"The algorithm is outlined in the [Unicode Standard Annex #29,\n"
"Unicode Text Segmentation](http://www.unicode.org/reports/tr29/).\n"
"\n"
"For details about codepoints and graphemes, see the `String` module "
"documentation.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.graphemes(\"Ńaïve\")\n"
"    [\"Ń\", \"a\", \"ï\", \"v\", \"e\"]\n"
"\n"
"    iex> String.graphemes(\"é\")\n"
"    [\"é\"]\n"
"\n"
"    iex> String.graphemes(\"é\")\n"
"    [\"é\"]\n"
"\n"
msgstr ""
"Extended Grapheme Clusterアルゴリズムに従って文字列のユニコード書記素を\n"
"返します。\n"
"\n"
"そのアルゴリズムは、[Unicode Standard Annex #29,\n"
"Unicode Text Segmentation](http://www.unicode.org/reports/tr29/)\n"
"に概説されています。\n"
"\n"
"コードポイントと書記素についての詳細は、`String`モジュール\n"
"ドキュメントを参照してください。\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.graphemes(\"Ńaïve\")\n"
"    [\"Ń\", \"a\", \"ï\", \"v\", \"e\"]\n"
"\n"
"    iex> String.graphemes(\"é\")\n"
"    [\"é\"]\n"
"\n"
"    iex> String.graphemes(\"é\")\n"
"    [\"é\"]\n"
"\n"

#. TRANSLATORS: def String.slice(string, range)
#: lib/string.ex:1371
msgid ""
"Returns a substring from the offset given by the start of the\n"
"range to the offset given by the end of the range.\n"
"\n"
"If the start of the range is not a valid offset for the given\n"
"string or if the range is in reverse order, returns `\"\"`.\n"
"\n"
"If the start or end of the range is negative, the whole string\n"
"is traversed first in order to convert the negative indices into\n"
"positive ones.\n"
"\n"
"Remember this function works with Unicode codepoints and considers\n"
"the slices to represent codepoints offsets. If you want to split\n"
"on raw bytes, check `Kernel.binary_part/3` instead.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.slice(\"elixir\", 1..3)\n"
"    \"lix\"\n"
"\n"
"    iex> String.slice(\"elixir\", 1..10)\n"
"    \"lixir\"\n"
"\n"
"    iex> String.slice(\"elixir\", 10..3)\n"
"    \"\"\n"
"\n"
"    iex> String.slice(\"elixir\", -4..-1)\n"
"    \"ixir\"\n"
"\n"
"    iex> String.slice(\"elixir\", 2..-1)\n"
"    \"ixir\"\n"
"\n"
"    iex> String.slice(\"elixir\", -4..6)\n"
"    \"ixir\"\n"
"\n"
"    iex> String.slice(\"elixir\", -1..-4)\n"
"    \"\"\n"
"\n"
"    iex> String.slice(\"elixir\", -10..-7)\n"
"    \"\"\n"
"\n"
"    iex> String.slice(\"a\", 0..1500)\n"
"    \"a\"\n"
"\n"
"    iex> String.slice(\"a\", 1..1500)\n"
"    \"\"\n"
"\n"
msgstr ""
"範囲(range)の始まりによって与えられるオフセットから\n"
"範囲の終りまでに与えられるオフセットまで部分文字列を返します。\n"
"\n"
"範囲の始まりが与えられた文字列のオフセットとして正しくない、\n"
"あるいは、範囲が逆順であったら、`\"\"`を返します。\n"
"\n"
"範囲の始まりや終わりが負の場合、負のインデックスを正に変えるために\n"
"文字列全体が最初に走査されます。\n"
"\n"
"この関数はunicodeコードポイントで動作すること、そして、コードポイントオ\n"
"フセットを表現するためにスライスを考慮していることを忘れないでください。\n"
"もし生のバイト列で分割したいなら、`Kernel.binary_part/3`を替わりにチェッ\n"
"クしてください。\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.slice(\"elixir\", 1..3)\n"
"    \"lix\"\n"
"\n"
"    iex> String.slice(\"elixir\", 1..10)\n"
"    \"lixir\"\n"
"\n"
"    iex> String.slice(\"elixir\", 10..3)\n"
"    \"\"\n"
"\n"
"    iex> String.slice(\"elixir\", -4..-1)\n"
"    \"ixir\"\n"
"\n"
"    iex> String.slice(\"elixir\", 2..-1)\n"
"    \"ixir\"\n"
"\n"
"    iex> String.slice(\"elixir\", -4..6)\n"
"    \"ixir\"\n"
"\n"
"    iex> String.slice(\"elixir\", -1..-4)\n"
"    \"\"\n"
"\n"
"    iex> String.slice(\"elixir\", -10..-7)\n"
"    \"\"\n"
"\n"
"    iex> String.slice(\"a\", 0..1500)\n"
"    \"a\"\n"
"\n"
"    iex> String.slice(\"a\", 1..1500)\n"
"    \"\"\n"
"\n"

#. TRANSLATORS: def String.duplicate(subject, n)
#: lib/string.ex:974
msgid ""
"Returns a string `subject` duplicated `n` times.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.duplicate(\"abc\", 0)\n"
"    \"\"\n"
"\n"
"    iex> String.duplicate(\"abc\", 1)\n"
"    \"abc\"\n"
"\n"
"    iex> String.duplicate(\"abc\", 2)\n"
"    \"abcabc\"\n"
"\n"
msgstr ""
"`subject`を`n`回複製した文字列を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.duplicate(\"abc\", 0)\n"
"    \"\"\n"
"\n"
"    iex> String.duplicate(\"abc\", 1)\n"
"    \"abc\"\n"
"\n"
"    iex> String.duplicate(\"abc\", 2)\n"
"    \"abcabc\"\n"
"\n"

#. TRANSLATORS: def String.length(string)
#: lib/string.ex:1253
msgid ""
"Returns the number of Unicode graphemes in a utf8 string.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.length(\"elixir\")\n"
"    6\n"
"\n"
"    iex> String.length(\"եոգլի\")\n"
"    5\n"
"\n"
msgstr ""
"utf8文字列中のunicode書記素の数を返します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.length(\"elixir\")\n"
"    6\n"
"\n"
"    iex> String.length(\"եոգլի\")\n"
"    5\n"
"\n"

#. TRANSLATORS: def String.last(string)
#: lib/string.ex:1229
msgid ""
"Returns the last grapheme from a utf8 string,\n"
"`nil` if the string is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.last(\"elixir\")\n"
"    \"r\"\n"
"\n"
"    iex> String.last(\"եոգլի\")\n"
"    \"ի\"\n"
"\n"
msgstr ""
"utf8文字列から最後の書記素を返します。\n"
"文字列が空なら`nil`を返します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.last(\"elixir\")\n"
"    \"r\"\n"
"\n"
"    iex> String.last(\"եոգլի\")\n"
"    \"ի\"\n"
"\n"

#. TRANSLATORS: def String.rjust(subject, len, pad \\ 32)
#: lib/string.ex:809
msgid ""
"Returns a new string of length `len` with `subject` right justified and\n"
"padded with `pad`. If `pad` is not present, it defaults to\n"
"whitespace. When `len` is less than the length of `subject`, `subject` is\n"
"returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.rjust(\"abc\", 5)\n"
"    \"  abc\"\n"
"\n"
"    iex> String.rjust(\"abc\", 5, ?-)\n"
"    \"--abc\"\n"
"\n"
msgstr ""
"`subject`を右寄せして、`pad`でパディングした、長さ`len`の新しい文字列\n"
"を返します。もし`pad`がなければ、空白文字がデフォルトです。\n"
"`len`が`subject`の長さより小さいとき、`subject`が返されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.rjust(\"abc\", 5)\n"
"    \"  abc\"\n"
"\n"
"    iex> String.rjust(\"abc\", 5, ?-)\n"
"    \"--abc\"\n"
"\n"

#. TRANSLATORS: def String.first(string)
#: lib/string.ex:1208
msgid ""
"Returns the first grapheme from a utf8 string,\n"
"`nil` if the string is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.first(\"elixir\")\n"
"    \"e\"\n"
"\n"
"    iex> String.first(\"եոգլի\")\n"
"    \"ե\"\n"
"\n"
msgstr ""
"utf8文字列から最初の書記素を返します。\n"
"文字列が空なら`nil`を返します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.first(\"elixir\")\n"
"    \"e\"\n"
"\n"
"    iex> String.first(\"եոգլի\")\n"
"    \"ե\"\n"
"\n"

#. TRANSLATORS: def String.split(binary)
#: lib/string.ex:241
msgid ""
"Divides a string into substrings at each Unicode whitespace\n"
"occurrence with leading and trailing whitespace ignored.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.split(\"foo bar\")\n"
"    [\"foo\", \"bar\"]\n"
"\n"
"    iex> String.split(\"foo\" <> <<194, 133>> <> \"bar\")\n"
"    [\"foo\", \"bar\"]\n"
"\n"
"    iex> String.split(\" foo bar \")\n"
"    [\"foo\", \"bar\"]\n"
"\n"
msgstr ""
"文字列を、先頭と末尾の空白を無視して、Unicode空白ごとに部分文字列に分割\n"
"します。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.split(\"foo bar\")\n"
"    [\"foo\", \"bar\"]\n"
"\n"
"    iex> String.split(\"foo\" <> <<194, 133>> <> \"bar\")\n"
"    [\"foo\", \"bar\"]\n"
"\n"
"    iex> String.split(\" foo bar \")\n"
"    [\"foo\", \"bar\"]\n"
"\n"

#. TRANSLATORS: def String.slice(string, start, len)
#: lib/string.ex:1311
msgid ""
"Returns a substring starting at the offset `start`, and of\n"
"length `len`.\n"
"\n"
"If the offset is greater than string length, then it returns `\"\"`.\n"
"\n"
"Remember this function works with Unicode graphemes and considers\n"
"the slices to represent grapheme offsets. If you want to split\n"
"on raw bytes, check `Kernel.binary_part/3` instead.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.slice(\"elixir\", 1, 3)\n"
"    \"lix\"\n"
"\n"
"    iex> String.slice(\"elixir\", 1, 10)\n"
"    \"lixir\"\n"
"\n"
"    iex> String.slice(\"elixir\", 10, 3)\n"
"    \"\"\n"
"\n"
"    iex> String.slice(\"elixir\", -4, 4)\n"
"    \"ixir\"\n"
"\n"
"    iex> String.slice(\"elixir\", -10, 3)\n"
"    \"\"\n"
"\n"
"    iex> String.slice(\"a\", 0, 1500)\n"
"    \"a\"\n"
"\n"
"    iex> String.slice(\"a\", 1, 1500)\n"
"    \"\"\n"
"\n"
"    iex> String.slice(\"a\", 2, 1500)\n"
"    \"\"\n"
"\n"
msgstr ""
"最初に与えられたオフセット`start`からスタートして\n"
"長さ`len`の部分文字列を返します。\n"
"\n"
"文字列の長さよりオフセットが大きいなら、`\"\"`を返します。\n"
"\n"
"この関数はunicodeコードポイントで動作すること、そして、コードポイントオ\n"
"フセットを表現するためにスライスを考慮していることを忘れないでください。\n"
"もし生のバイト列で分割したいなら、`Kernel.binary_part/3`を替わりにチェッ\n"
"クしてください。\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.slice(\"elixir\", 1, 3)\n"
"    \"lix\"\n"
"\n"
"    iex> String.slice(\"elixir\", 1, 10)\n"
"    \"lixir\"\n"
"\n"
"    iex> String.slice(\"elixir\", 10, 3)\n"
"    \"\"\n"
"\n"
"    iex> String.slice(\"elixir\", -4, 4)\n"
"    \"ixir\"\n"
"\n"
"    iex> String.slice(\"elixir\", -10, 3)\n"
"    \"\"\n"
"\n"
"    iex> String.slice(\"a\", 0, 1500)\n"
"    \"a\"\n"
"\n"
"    iex> String.slice(\"a\", 1, 1500)\n"
"    \"\"\n"
"\n"
"    iex> String.slice(\"a\", 2, 1500)\n"
"    \"\"\n"
"\n"

#. TRANSLATORS: def String.next_codepoint(string)
#: lib/string.ex:1020
msgid ""
"Returns the next codepoint in a string.\n"
"\n"
"The result is a tuple with the codepoint and the\n"
"remainder of the string or `nil` in case\n"
"the string reached its end.\n"
"\n"
"As with other functions in the String module, this\n"
"function does not check for the validity of the codepoint.\n"
"That said, if an invalid codepoint is found, it will\n"
"be returned by this function.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.next_codepoint(\"olá\")\n"
"    {\"o\", \"lá\"}\n"
"\n"
msgstr ""
"文字列の中の次のコードポイントを返します。\n"
"\n"
"結果は、コードポイントと、文字列の残りまたは、文字列が\n"
"その終わりに到達したときは`nil`、のタプルです。\n"
"\n"
"Stringモジュールの他の関数と同様に、この関数はコードポイントの\n"
"有効性についてチェックしません。\n"
"それは、もし無効なコードポイントを見付けたら、それは\n"
"この関数によって返される、ということを言っています。\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.next_codepoint(\"olá\")\n"
"    {\"o\", \"lá\"}\n"
"\n"

#. TRANSLATORS: Elixir.String Summary
#: lib/string.ex:4
msgid ""
"A String in Elixir is a UTF-8 encoded binary.\n"
"\n"
"## Codepoints and graphemes\n"
"\n"
"The functions in this module act according to the Unicode\n"
"Standard, version 6.3.0.\n"
"\n"
"As per the standard, a codepoint is a single Unicode Character,\n"
"which may be represented by one or more bytes.\n"
"\n"
"For example, the codepoint \"é\" is two bytes:\n"
"\n"
"    iex> byte_size(\"é\")\n"
"    2\n"
"\n"
"However, this module returns the proper length:\n"
"\n"
"    iex> String.length(\"é\")\n"
"    1\n"
"\n"
"Furthermore, this module also presents the concept of\n"
"graphemes. A single grapheme can consist of multiple codepoints\n"
"that may be perceived as a single character by readers. For example,\n"
"the \"é\" grapheme can be represented either as a single \"e with acute\"\n"
"codepoint (like above), or as the letter \"e\" followed by a\n"
"\"combining acute accent\" (two codepoints):\n"
"\n"
"    iex> string = \"\\u0065\\u0301\"\n"
"    iex> byte_size(string)\n"
"    3\n"
"    iex> String.length(string)\n"
"    1\n"
"    iex> String.codepoints(string)\n"
"    [\"e\", \"́\"]\n"
"    iex> String.graphemes(string)\n"
"    [\"é\"]\n"
"\n"
"Although the example above is made of two characters, it is\n"
"perceived by users as one.\n"
"\n"
"Graphemes can also be two characters that are interpreted\n"
"as one by some languages. For example, some languages may\n"
"consider \"ch\" as a grapheme. However, since this information\n"
"depends on the locale, it is not taken into account by this\n"
"module.\n"
"\n"
"In general, the functions in this module rely on the Unicode\n"
"Standard, but do not contain any of the locale specific behaviour.\n"
"\n"
"More information about graphemes can be found in the [Unicode\n"
"Standard Annex #29](http://www.unicode.org/reports/tr29/).\n"
"The current Elixir version implements Extended Grapheme Cluster\n"
"algorithm.\n"
"\n"
"## String and binary operations\n"
"\n"
"To act according to the Unicode Standard, many functions\n"
"in this module run in linear time, as they need to traverse\n"
"the whole string considering the proper Unicode codepoints.\n"
"\n"
"For example, `String.length/1` will take longer as\n"
"the input grows. On the other hand, `Kernel.byte_size/1` always runs\n"
"in constant time (i.e. regardless of the input size).\n"
"\n"
"This means often there are performance costs in using the\n"
"functions in this module, compared to the more low-level\n"
"operations that work directly with binaries:\n"
"\n"
"  * `Kernel.binary_part/3` - retrieves part of the binary\n"
"  * `Kernel.bit_size/1` and `Kernel.byte_size/1` - size related functions\n"
"  * `Kernel.is_bitstring/1` and `Kernel.is_binary/1` - type checking "
"function\n"
"  * Plus a number of functions for working with binaries (bytes)\n"
"    in the [`:binary` module](http://www.erlang.org/doc/man/binary.html)\n"
"\n"
"There are many situations where using the `String` module can\n"
"be avoided in favor of binary functions or pattern matching.\n"
"For example, imagine you have a string `prefix` and you want to\n"
"remove this prefix from another string named `full`.\n"
"\n"
"One may be tempted to write:\n"
"\n"
"    iex> take_prefix = fn full, prefix ->\n"
"    ...>   base = String.length(prefix)\n"
"    ...>   String.slice(full, base, String.length(full) - base)\n"
"    ...> end\n"
"    iex> take_prefix.(\"Mr. John\", \"Mr. \")\n"
"    \"John\"\n"
"\n"
"Although the function above works, it performs poorly. To\n"
"calculate the length of the string, we need to traverse it\n"
"fully, so we traverse both `prefix` and `full` strings, then\n"
"slice the `full` one, traversing it again.\n"
"\n"
"A first attempt at improving it could be with ranges:\n"
"\n"
"    iex> take_prefix = fn full, prefix ->\n"
"    ...>   base = String.length(prefix)\n"
"    ...>   String.slice(full, base..-1)\n"
"    ...> end\n"
"    iex> take_prefix.(\"Mr. John\", \"Mr. \")\n"
"    \"John\"\n"
"\n"
"While this is much better (we don't traverse `full` twice),\n"
"it could still be improved. In this case, since we want to\n"
"extract a substring from a string, we can use `byte_size/1`\n"
"and `binary_part/3` as there is no chance we will slice in\n"
"the middle of a codepoint made of more than one byte:\n"
"\n"
"    iex> take_prefix = fn full, prefix ->\n"
"    ...>   base = byte_size(prefix)\n"
"    ...>   binary_part(full, base, byte_size(full) - base)\n"
"    ...> end\n"
"    iex> take_prefix.(\"Mr. John\", \"Mr. \")\n"
"    \"John\"\n"
"\n"
"Or simply use pattern matching:\n"
"\n"
"    iex> take_prefix = fn full, prefix ->\n"
"    ...>   base = byte_size(prefix)\n"
"    ...>   <<_::binary-size(base), rest::binary>> = full\n"
"    ...>   rest\n"
"    ...> end\n"
"    iex> take_prefix.(\"Mr. John\", \"Mr. \")\n"
"    \"John\"\n"
"\n"
"On the other hand, if you want to dynamically slice a string\n"
"based on an integer value, then using `String.slice/3` is the\n"
"best option as it guarantees we won't incorrectly split a valid\n"
"codepoint into multiple bytes.\n"
"\n"
"## Integer codepoints\n"
"\n"
"Although codepoints could be represented as integers, this\n"
"module represents all codepoints as strings. For example:\n"
"\n"
"    iex> String.codepoints(\"olá\")\n"
"    [\"o\", \"l\", \"á\"]\n"
"\n"
"There are a couple of ways to retrieve a character integer\n"
"codepoint. One may use the `?` construct:\n"
"\n"
"    iex> ?o\n"
"    111\n"
"\n"
"    iex> ?á\n"
"    225\n"
"\n"
"Or also via pattern matching:\n"
"\n"
"    iex> <<eacute::utf8>> = \"á\"\n"
"    iex> eacute\n"
"    225\n"
"\n"
"As we have seen above, codepoints can be inserted into\n"
"a string by their hexadecimal code:\n"
"\n"
"    \"ol\\u0061\\u0301\" #=>\n"
"    \"olá\"\n"
"\n"
"## Self-synchronization\n"
"\n"
"The UTF-8 encoding is self-synchronizing. This means that\n"
"if malformed data (i.e., data that is not possible according\n"
"to the definition of the encoding) is encountered, only one\n"
"codepoint needs to be rejected.\n"
"\n"
"This module relies on this behaviour to ignore such invalid\n"
"characters. For example, `length/1` will return\n"
"a correct result even if an invalid codepoint is fed into it.\n"
"\n"
"In other words, this module expects invalid data to be detected\n"
"when retrieving data from the external source. For example, a\n"
"driver that reads strings from a database will be\n"
"responsible to check the validity of the encoding.\n"
"\n"
"## Patterns\n"
"\n"
"Many functions in this module work with patterns. For example,\n"
"String.split/2 can split a string into multiple patterns given\n"
"a pattern. This pattern can be a string, a list of strings or\n"
"a compiled pattern:\n"
"\n"
"    iex> String.split(\"foo bar\", \" \")\n"
"    [\"foo\", \"bar\"]\n"
"\n"
"    iex> String.split(\"foo bar!\", [\" \", \"!\"])\n"
"    [\"foo\", \"bar\", \"\"]\n"
"\n"
"    iex> pattern = :binary.compile_pattern([\" \", \"!\"])\n"
"    iex> String.split(\"foo bar!\", pattern)\n"
"    [\"foo\", \"bar\", \"\"]\n"
"\n"
"The compiled pattern is useful when the same match will\n"
"be done over and over again. Note though the compiled\n"
"pattern cannot be stored in a module attribute as the pattern\n"
"is generated at runtime and does not survive compile term.\n"
msgstr ""
"Elixirの文字列はUTF-8エンコードされたバイナリです。\n"
"\n"
"## Codepoints and graphemes\n"
"\n"
"このモジュールの関数はUnicode Standard, version 6.8.0に\n"
"従って動作します。\n"
"\n"
"標準に従って、コードポイントは一つ以上のバイトで表現されたUnicode\n"
"文字です。\n"
"\n"
"例えば、文字 \"é\" は2バイトで表現されます:\n"
"\n"
"    iex> byte_size(\"é\")\n"
"    2\n"
"\n"
"しかしながら、このモジュールは正しい長さを返します:\n"
"\n"
"    iex> String.length(\"é\")\n"
"    1\n"
"\n"
"さらにまた、このモジュールは、読者により\"一文字として認められる\"\n"
"複数の文字である、書記素の概念も示します。\n"
"例えば、上に書かれた\"é\"文字は、\"e\"にアクセント ́が続いたものとして\n"
"表現されることがあります:\n"
"\n"
"    iex> string = \"\\u0065\\u0301\"\n"
"    iex> byte_size(string)\n"
"    3\n"
"    iex> String.length(string)\n"
"    1\n"
"    iex> String.codepoints(string)\n"
"    [\"e\", \"́\"]\n"
"    iex> String.graphemes(string)\n"
"    [\"é\"]\n"
"\n"
"上の例は二つの文字から作られているが、一文字としてユーザには\n"
"認められます。\n"
"\n"
"書記素は、いくつかの言語によって一体となって解釈される二つの文字\n"
"でもありえます。例えば、いくつかの言語では、\"ch\"を書記素として\n"
"考えるかもしれません。しかしながら、これはロケールに依存した\n"
"情報なので、このモジュールでは考慮されません。\n"
"\n"
"一般に、このモジュールの関数は、Unicode Standardを信頼しますが、\n"
"ロケール固有の振る舞いは何も含みません。\n"
"\n"
"書記素についての詳細は、[Unicode Standard Annex #29](http://www.unicode.org/"
"reports/tr29/) にあります。\n"
"この現在のElixir versionはExtended Grapheme Cluster algorithmを\n"
"実装しています。\n"
"\n"
"## String and binary operations\n"
"\n"
"Unicode Standardに準拠して動作するために、このモジュールの\n"
"多くの関数は、文字列全体の適切なUnicodeコードポイントを\n"
"考慮するために、線形の時間がかかります。\n"
"\n"
"例えば、`String.length/1`は入力が大きくなるに従って\n"
"時間がかかるようになります。一方、`Kernel.byte_size/1`は\n"
"(入力の大きさに拘わらず)常に定数時間で動きます。\n"
"\n"
"これはこのモジュールの関数の使用には、以下のような直接binaryを\n"
"操作する、よりlow-levelオペレーションに比べて、パフォーマンスコスト\n"
"の問題が付き纏うことを意味します:\n"
"\n"
"  * `Kernel.binary_part/3` - binaryの一部を取り出す\n"
"  * `Kernel.bit_size/1` and `Kernel.byte_size/1` - サイズ関連\n"
"  * `Kernel.is_bitstring/1` and `Kernel.is_binary/1` - 型チェック\n"
"  * [`:binary` module](http://www.erlang.org/doc/man/binary.html)\n"
"    のバイナリ(バイト列)で動作する多くの関数。\n"
"\n"
"バイナリ関数やパターンマッチングの方が好まれ、`String`モジュールの\n"
"使用が避けられるケースがよくあります。\n"
"例えば、`prefix`文字列をもっていて、`full`と名付けられた\n"
"もう一つの文字列からこのprefixをとり除きたいと想像してください\n"
"\n"
"このように書きたくなるかもしれません:\n"
"\n"
"    iex> take_prefix = fn full, prefix ->\n"
"    ...>   base = String.length(prefix)\n"
"    ...>   String.slice(full, base, String.length(full) - base)\n"
"    ...> end\n"
"    iex> take_prefix.(\"Mr. John\", \"Mr. \")\n"
"    \"John\"\n"
"\n"
"上記は動作しますが、パフォーマンスはプアです。文字列の流さを\n"
"計算するために、`prefix`と`full`両方の文字列をトラバース\n"
"する必要があり、それから`full`をスライスするために再び\n"
"トラバースします。\n"
"\n"
"最初の改良の試みは、rangeを使うことです:\n"
"\n"
"    iex> take_prefix = fn full, prefix ->\n"
"    ...>   base = String.length(prefix)\n"
"    ...>   String.slice(full, base..-1)\n"
"    ...> end\n"
"    iex> take_prefix.(\"Mr. John\", \"Mr. \")\n"
"    \"John\"\n"
"\n"
"これは非常に良い(`full`を二回トラバースしません)ですが、\n"
"まだ改良することができます。この場合、文字列から部分\n"
"文字列を抽出したい時、複数のバイトからなるコードポイント\n"
"の中間でスライスすることがないと判っているなら、\n"
"`byte_size/1`と`binary_part/3`を使うことが出来ます:\n"
"\n"
"    iex> take_prefix = fn full, prefix ->\n"
"    ...>   base = byte_size(prefix)\n"
"    ...>   binary_part(full, base, byte_size(full) - base)\n"
"    ...> end\n"
"    iex> take_prefix.(\"Mr. John\", \"Mr. \")\n"
"    \"John\"\n"
"\n"
"あるいは、単にパターンマッチングを使えます:\n"
"\n"
"    iex> take_prefix = fn full, prefix ->\n"
"    ...>   base = byte_size(prefix)\n"
"    ...>   <<_ :: binary-size(base), rest :: binary>> = full\n"
"    ...>   rest\n"
"    ...> end\n"
"    iex> take_prefix.(\"Mr. John\", \"Mr. \")\n"
"    \"John\"\n"
"\n"
"一方、もし整数値に基いて動的に文字列をスライスしたいなら、\n"
"正しいマルチバイトのコードポイントを不正に分割しない\n"
"ことが保証されるので、`String.slice/3`がベストな選択です。\n"
"\n"
"## Integer codepoints\n"
"\n"
"コードポイントは整数として表現することもできますが、\n"
"このモジュールは全てのコードポイントを文字列として表現します。\n"
"例えば:\n"
"\n"
"    iex> String.codepoints(\"olá\")\n"
"    [\"o\", \"l\", \"á\"]\n"
"\n"
"文字の整数のコードポイントを取り出すいくつかの方法があります。\n"
"一つは、`?`constructです:\n"
"\n"
"    iex> ?o\n"
"    111\n"
"\n"
"    iex> ?á\n"
"    225\n"
"\n"
"或いは、パターンマッチングも使えます:\n"
"\n"
"    iex> << eacute :: utf8 >> = \"á\"\n"
"    iex> eacute\n"
"    225\n"
"\n"
"上記で見たように、コードポイントはその16進数コードで\n"
"文字列中に挿入することができます:\n"
"\n"
"    \"ol\\u0061\\u0301\" #=>\n"
"    \"olá\"\n"
"\n"
"## Self-synchronization\n"
"\n"
"UTF-8エンコーディングは自己同期的です。これは、もし\n"
"不正な形式のデータ(すなわち、符号化の定義に従っては有り得ないデータ)に\n"
"遭遇したら、そのコードポイントだけが拒絶されることを意味します。\n"
"\n"
"このモジュールは、そのような不正な文字列を無視する、\n"
"この振る舞いに頼っています。例えば、`length/1`は、たとえ無効な\n"
"コードポイントがそこに入れられていても、正しい結果を返すでしょう。\n"
"\n"
"言い替えると、このモジュールは外部ソースからデータを取り出す\n"
"とき、不正なデータが検出されることを予期しています。例えば、\n"
"データベースから文字列を読むドライバはエンコーディングの有効性の\n"
"チェックに責任があります。\n"
"\n"
"## Patterns\n"
"\n"
"このモジュールの多くの関数はパターンでも動作します。例えば、\n"
"String.split/2 は文字列を複数の与えられたパターンに分割します。\n"
"このパターンは文字列、文字列のリスト、あるいは、コンパイルされた\n"
"パターンが可能です:\n"
"\n"
"    iex> String.split(\"foo bar\", \" \")\n"
"    [\"foo\", \"bar\"]\n"
"\n"
"    iex> String.split(\"foo bar!\", [\" \", \"!\"])\n"
"    [\"foo\", \"bar\", \"\"]\n"
"\n"
"    iex> pattern = :binary.compile_pattern([\" \", \"!\"])\n"
"    iex> String.split(\"foo bar!\", pattern)\n"
"    [\"foo\", \"bar\", \"\"]\n"
"\n"
"コンパイルされたパターンは、同じマッチが何度も何度もされるとき\n"
"役に立ちます。\n"
"コンパイルされたパターンは、実行時に生成されるため、モジュール\n"
"アトリビュートに保存できず、コンパイル期間を生き残れない\n"
"ということに注意してください。\n"

#. TRANSLATORS: def String.downcase(binary)
#: lib/string.ex:528
msgid ""
"Converts all characters in the given string to lowercase.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.downcase(\"ABCD\")\n"
"    \"abcd\"\n"
"\n"
"    iex> String.downcase(\"AB 123 XPTO\")\n"
"    \"ab 123 xpto\"\n"
"\n"
"    iex> String.downcase(\"OLÁ\")\n"
"    \"olá\"\n"
"\n"
msgstr ""
"与えられた文字列の全ての文字を小文字に変換します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.downcase(\"ABCD\")\n"
"    \"abcd\"\n"
"\n"
"    iex> String.downcase(\"AB 123 XPTO\")\n"
"    \"ab 123 xpto\"\n"
"\n"
"    iex> String.downcase(\"OLÁ\")\n"
"    \"olá\"\n"
"\n"

#. TRANSLATORS: def String.next_grapheme(binary)
#: lib/string.ex:1171
msgid ""
"Returns the next grapheme in a string.\n"
"\n"
"The result is a tuple with the grapheme and the\n"
"remainder of the string or `nil` in case\n"
"the String reached its end.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.next_grapheme(\"olá\")\n"
"    {\"o\", \"lá\"}\n"
"\n"
msgstr ""
"文字列の中の次の書記素を返します。\n"
"\n"
"結果は、書記素と、文字列の残りまたは、文字列がその終わりに\n"
"到達したときは`nil`、のタプルです。\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.next_grapheme(\"olá\")\n"
"    {\"o\", \"lá\"}\n"
"\n"

#. TRANSLATORS: def String.printable?(string)
#: lib/string.ex:208
msgid ""
"Checks if a string contains only printable characters.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.printable?(\"abc\")\n"
"    true\n"
"\n"
msgstr ""
"文字列が印字可能文字(printable characters)だけを含んでいるかどうかチェッ\n"
"クします。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.printable?(\"abc\")\n"
"    true\n"
"\n"

#. TRANSLATORS: def String.jaro_distance(string1, string2)
#: lib/string.ex:1708
msgid ""
"Returns a float value between 0 (equates to no similarity) and 1 (is an "
"exact match)\n"
"representing [Jaro](https://en.wikipedia.org/wiki/Jaro–Winkler_distance)\n"
"distance between `string1` and `string2`.\n"
"\n"
"The Jaro distance metric is designed and best suited for short strings such "
"as person names.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.jaro_distance(\"dwayne\", \"duane\")\n"
"    0.8222222222222223\n"
"    iex> String.jaro_distance(\"even\", \"odd\")\n"
"    0.0\n"
"\n"
msgstr ""
"`string1`と`string2`の間の\n"
"[Jaro](https://en.wikipedia.org/wiki/Jaro–Winkler_distance)\n"
"distance を表す\n"
"0(全く近似していない)から1(完全に一致)の間のfloat値を返します。\n"
"\n"
"Jaro distanceメトリックは人名のような\n"
"短かい文字列にぴったりとなるように設計されています。\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.jaro_distance(\"dwayne\", \"duane\")\n"
"    0.8222222222222223\n"
"    iex> String.jaro_distance(\"even\", \"odd\")\n"
"    0.0\n"
"\n"

#. TRANSLATORS: def String.to_existing_atom(string)
#: lib/string.ex:1629
msgid ""
"Converts a string to an existing atom.\n"
"\n"
"Currently Elixir does not support the conversion of strings\n"
"that contain Unicode codepoints greater than 0xFF.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> _ = :my_atom\n"
"    iex> String.to_existing_atom(\"my_atom\")\n"
"    :my_atom\n"
"\n"
"    iex> String.to_existing_atom(\"this_atom_will_never_exist\")\n"
"    ** (ArgumentError) argument error\n"
"\n"
msgstr ""
"文字列を存在するアトムに変換します。\n"
"\n"
"現在のElixirは、0xFFを越えるUnicodeコードポイントを含む\n"
"文字列からの変換をサポートしていません。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> :my_atom\n"
"    iex> String.to_existing_atom(\"my_atom\")\n"
"    :my_atom\n"
"\n"
"    iex> String.to_existing_atom(\"this_atom_will_never_exist\")\n"
"    ** (ArgumentError) argument error\n"
"\n"

#. TRANSLATORS: def String.to_integer(string, base)
#: lib/string.ex:1668
msgid ""
"Returns an integer whose text representation is `string` in base `base`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.to_integer(\"3FF\", 16)\n"
"    1023\n"
"\n"
msgstr ""
"テキスト表現が基数`base`の`string`である整数を返します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.to_integer(\"3FF\", 16)\n"
"    1023\n"
"\n"

#. TRANSLATORS: def String.splitter(string, pattern, options \\ [])
#: lib/string.ex:354
msgid ""
"Returns an enumerable that splits a string on demand.\n"
"\n"
"This is in contrast to `split/3` which splits all\n"
"the string upfront.\n"
"\n"
"Note splitter does not support regular expressions\n"
"(as it is often more efficient to have the regular\n"
"expressions traverse the string at once than in\n"
"multiple passes).\n"
"\n"
"## Options\n"
"\n"
"  * :trim - when `true`, does not emit empty patterns\n"
msgstr ""
"オンデマンドに文字列を分割し、enumerableを返します。\n"
"\n"
"これは`split/3`が全文字列を最初に分割することと\n"
"対照をなします。\n"
"\n"
"splitterは正規表現をサポートしていないことに注意し\n"
"てください(複数囘パスするより一度にトラバースする\n"
"ほうがしばしばより効率的なのです)。\n"
"\n"
"## Options\n"
"\n"
"  * :trim - `true` のとき、空のパターンを発生させません\n"

#. TRANSLATORS: def String.starts_with?(string, prefix)
#: lib/string.ex:1467
msgid ""
"Returns `true` if `string` starts with any of the prefixes given.\n"
"\n"
"`prefixes` can be either a single prefix or a list of prefixes.\n"
"\n"
"Raises argument error if an empty string is given.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.starts_with? \"elixir\", \"eli\"\n"
"    true\n"
"\n"
"    iex> String.starts_with? \"elixir\", [\"erlang\", \"elixir\"]\n"
"    true\n"
"\n"
"    iex> String.starts_with? \"elixir\", [\"erlang\", \"ruby\"]\n"
"    false\n"
"\n"
msgstr ""
"もし、`string`が与えらえれたプレフィックスの何れかで開始していれば、\n"
"`true`を返します。\n"
"\n"
"`prefixes`は一つの文字列でも、プレフィックスのリストでもよいです。\n"
"\n"
"空の文字列が与えられたら、argument errorを上げます。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.starts_with? \"elixir\", \"eli\"\n"
"    true\n"
"\n"
"    iex> String.starts_with? \"elixir\", [\"erlang\", \"elixir\"]\n"
"    true\n"
"\n"
"    iex> String.starts_with? \"elixir\", [\"erlang\", \"ruby\"]\n"
"    false\n"
"\n"

#. TRANSLATORS: def String.rstrip(string, char)
#: lib/string.ex:586
msgid ""
"Returns a string where all trailing `char`s have been removed.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.rstrip(\"   abc _\", ?_)\n"
"    \"   abc \"\n"
"\n"
msgstr ""
"末尾の全ての`char`を取り除いた文字列を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.rstrip(\"   abc _\", ?_)\n"
"    \"   abc \"\n"
"\n"

#. TRANSLATORS: def String.match?(string, regex)
#: lib/string.ex:1530
msgid ""
"Checks if `string` matches the given regular expression.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.match?(\"foo\", ~r/foo/)\n"
"    true\n"
"\n"
"    iex> String.match?(\"bar\", ~r/foo/)\n"
"    false\n"
"\n"
msgstr ""
"`string`が与えられた正規表現にマッチするかをチェックします。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.match?(\"foo\", ~r/foo/)\n"
"    true\n"
"\n"
"    iex> String.match?(\"bar\", ~r/foo/)\n"
"    false\n"
"\n"

#. TRANSLATORS: def String.codepoints(string)
#: lib/string.ex:994
msgid ""
"Returns all codepoints in the string.\n"
"\n"
"For details about codepoints and graphemes, see the `String` module "
"documentation.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.codepoints(\"olá\")\n"
"    [\"o\", \"l\", \"á\"]\n"
"\n"
"    iex> String.codepoints(\"оптими зации\")\n"
"    [\"о\", \"п\", \"т\", \"и\", \"м\", \"и\", \" \", \"з\", \"а\", \"ц\", "
"\"и\", \"и\"]\n"
"\n"
"    iex> String.codepoints(\"ἅἪῼ\")\n"
"    [\"ἅ\", \"Ἢ\", \"ῼ\"]\n"
"\n"
"    iex> String.codepoints(\"é\")\n"
"    [\"é\"]\n"
"\n"
"    iex> String.codepoints(\"é\")\n"
"    [\"e\", \"́\"]\n"
"\n"
msgstr ""
"文字列の全てのコードポイントを返します。\n"
"\n"
"コードポイントと書記素についての詳細は、`String`モジュール\n"
"ドキュメントを参照してください。\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.codepoints(\"olá\")\n"
"    [\"o\", \"l\", \"á\"]\n"
"\n"
"    iex> String.codepoints(\"оптими зации\")\n"
"    [\"о\", \"п\", \"т\", \"и\", \"м\", \"и\", \" \", \"з\", \"а\", \"ц\", "
"\"и\", \"и\"]\n"
"\n"
"    iex> String.codepoints(\"ἅἪῼ\")\n"
"    [\"ἅ\", \"Ἢ\", \"ῼ\"]\n"
"\n"
"    iex> String.codepoints(\"é\")\n"
"    [\"é\"]\n"
"\n"
"    iex> String.codepoints(\"é\")\n"
"    [\"e\", \"́\"]\n"
"\n"

#. TRANSLATORS: def String.to_integer(string)
#: lib/string.ex:1652
msgid ""
"Returns an integer whose text representation is `string`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.to_integer(\"123\")\n"
"    123\n"
"\n"
msgstr ""
"テキスト表現が`string`となる整数を返します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.to_integer(\"123\")\n"
"    123\n"
"\n"

#. TRANSLATORS: def String.replace_prefix(string, match, replacement)
#: lib/string.ex:676
msgid ""
"Replaces prefix in `string` by `replacement` if it matches `match`.\n"
"\n"
"Returns the string untouched if there is no match.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.replace_prefix(\"world\", \"hello \", \"\")\n"
"    \"world\"\n"
"    iex> String.replace_prefix(\"hello world\", \"hello \", \"\")\n"
"    \"world\"\n"
"    iex> String.replace_prefix(\"hello hello world\", \"hello \", \"\")\n"
"    \"hello world\"\n"
"\n"
"    iex> String.replace_prefix(\"world\", \"hello \", \"ola \")\n"
"    \"world\"\n"
"    iex> String.replace_prefix(\"hello world\", \"hello \", \"ola \")\n"
"    \"ola world\"\n"
"    iex> String.replace_prefix(\"hello hello world\", \"hello \", \"ola \")\n"
"    \"ola hello world\"\n"
"\n"
msgstr ""
"`match`にマッチする`string`中のプレフィックスを`replacement`に置換します。\n"
"\n"
"マッチしないなら文字列は変更されずに返されます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.replace_prefix(\"world\", \"hello \", \"\")\n"
"    \"world\"\n"
"    iex> String.replace_prefix(\"hello world\", \"hello \", \"\")\n"
"    \"world\"\n"
"    iex> String.replace_prefix(\"hello hello world\", \"hello \", \"\")\n"
"    \"hello world\"\n"
"\n"
"    iex> String.replace_prefix(\"world\", \"hello \", \"ola \")\n"
"    \"world\"\n"
"    iex> String.replace_prefix(\"hello world\", \"hello \", \"ola \")\n"
"    \"ola world\"\n"
"    iex> String.replace_prefix(\"hello hello world\", \"hello \", \"ola \")\n"
"    \"ola hello world\"\n"
"\n"

#. TRANSLATORS: def String.split(string, pattern, options \\ [])
#: lib/string.ex:260
msgid ""
"Divides a string into substrings based on a pattern.\n"
"\n"
"Returns a list of these substrings. The pattern can\n"
"be a string, a list of strings or a regular expression.\n"
"\n"
"The string is split into as many parts as possible by\n"
"default, but can be controlled via the `parts: num` option.\n"
"If you pass `parts: :infinity`, it will return all possible parts\n"
"(being this one the default behaviour).\n"
"\n"
"Empty strings are only removed from the result if the\n"
"`trim` option is set to `true` (default is `false`).\n"
"\n"
"## Examples\n"
"\n"
"Splitting with a string pattern:\n"
"\n"
"    iex> String.split(\"a,b,c\", \",\")\n"
"    [\"a\", \"b\", \"c\"]\n"
"\n"
"    iex> String.split(\"a,b,c\", \",\", parts: 2)\n"
"    [\"a\", \"b,c\"]\n"
"\n"
"    iex> String.split(\" a b c \", \" \", trim: true)\n"
"    [\"a\", \"b\", \"c\"]\n"
"\n"
"A list of patterns:\n"
"\n"
"    iex> String.split(\"1,2 3,4\", [\" \", \",\"])\n"
"    [\"1\", \"2\", \"3\", \"4\"]\n"
"\n"
"A regular expression:\n"
"\n"
"    iex> String.split(\"a,b,c\", ~r{,})\n"
"    [\"a\", \"b\", \"c\"]\n"
"\n"
"    iex> String.split(\"a,b,c\", ~r{,}, parts: 2)\n"
"    [\"a\", \"b,c\"]\n"
"\n"
"    iex> String.split(\" a b c \", ~r{\\s}, trim: true)\n"
"    [\"a\", \"b\", \"c\"]\n"
"\n"
"Splitting on empty patterns returns graphemes:\n"
"\n"
"    iex> String.split(\"abc\", ~r{})\n"
"    [\"a\", \"b\", \"c\", \"\"]\n"
"\n"
"    iex> String.split(\"abc\", \"\")\n"
"    [\"a\", \"b\", \"c\", \"\"]\n"
"\n"
"    iex> String.split(\"abc\", \"\", trim: true)\n"
"    [\"a\", \"b\", \"c\"]\n"
"\n"
"    iex> String.split(\"abc\", \"\", parts: 2)\n"
"    [\"a\", \"bc\"]\n"
"\n"
"A precompiled pattern can also be given:\n"
"\n"
"    iex> pattern = :binary.compile_pattern([\" \", \",\"])\n"
"    iex> String.split(\"1,2 3,4\", pattern)\n"
"    [\"1\", \"2\", \"3\", \"4\"]\n"
"\n"
msgstr ""
"文字列をpatternに基いて部分文字列に分割します。\n"
"\n"
"部分文字列のリストを返します。パターンは、\n"
"文字列、文字列のリストあるいは、正規表現が使えます。\n"
"\n"
"文字列はデフォルトでは出来るだけ多くの部分になるように\n"
"分割されますが、`parts: num`オプションにより制御すること\n"
"できます。\n"
"もし`parts: :infinity`を渡すと、出来るだけ多くの部分を返します。\n"
"(この振る舞いがデフォルトです)\n"
"\n"
"`trim`オプションが`true`にセットされると、\n"
"分割の結果の空の文字列は削除されます。\n"
"\n"
"## 例\n"
"\n"
"文字列パターンによる分割:\n"
"\n"
"    iex> String.split(\"a,b,c\", \",\")\n"
"    [\"a\", \"b\", \"c\"]\n"
"\n"
"    iex> String.split(\"a,b,c\", \",\", parts: 2)\n"
"    [\"a\", \"b,c\"]\n"
"\n"
"    iex> String.split(\" a b c \", \" \", trim: true)\n"
"    [\"a\", \"b\", \"c\"]\n"
"\n"
"パターンのリスト:\n"
"\n"
"    iex> String.split(\"1,2 3,4\", [\" \", \",\"])\n"
"    [\"1\", \"2\", \"3\", \"4\"]\n"
"\n"
"正規表現:\n"
"\n"
"    iex> String.split(\"a,b,c\", ~r{,})\n"
"    [\"a\", \"b\", \"c\"]\n"
"\n"
"    iex> String.split(\"a,b,c\", ~r{,}, parts: 2)\n"
"    [\"a\", \"b,c\"]\n"
"\n"
"    iex> String.split(\" a b c \", ~r{\\s}, trim: true)\n"
"    [\"a\", \"b\", \"c\"]\n"
"\n"
"空のパターンによる分割はコードポイントのリストを返します:\n"
"\n"
"    iex> String.split(\"abc\", ~r{})\n"
"    [\"a\", \"b\", \"c\", \"\"]\n"
"\n"
"    iex> String.split(\"abc\", \"\")\n"
"    [\"a\", \"b\", \"c\", \"\"]\n"
"\n"
"    iex> String.split(\"abc\", \"\", trim: true)\n"
"    [\"a\", \"b\", \"c\"]\n"
"\n"
"    iex> String.split(\"abc\", \"\", parts: 2)\n"
"    [\"a\", \"bc\"]\n"
"\n"
"プリコンパイルされたパターンを渡すこともできます:\n"
"\n"
"    iex> pattern = :binary.compile_pattern([\" \", \",\"])\n"
"    iex> String.split(\"1,2 3,4\", pattern)\n"
"    [\"1\", \"2\", \"3\", \"4\"]\n"
"\n"

#~ msgid ""
#~ "Checks whether `string` is a valid character.\n"
#~ "\n"
#~ "All characters are codepoints, but some codepoints\n"
#~ "are not valid characters. They may be reserved, private,\n"
#~ "or other.\n"
#~ "\n"
#~ "More info at: [Non-characters – Wikipedia](https://en.wikipedia.org/wiki/"
#~ "Universal_Character_Set_characters#Non-characters)\n"
#~ "\n"
#~ "## Examples\n"
#~ "\n"
#~ "    iex> String.valid_character?(\"a\")\n"
#~ "    true\n"
#~ "\n"
#~ "    iex> String.valid_character?(\"ø\")\n"
#~ "    true\n"
#~ "\n"
#~ "    iex> String.valid_character?(\"\\uFFFF\")\n"
#~ "    false\n"
#~ "\n"
#~ msgstr ""
#~ "`string`が有効な文字かどうかをチェックします。\n"
#~ "\n"
#~ "全て文字がコードポイントですが、いくつかのコードポイントは\n"
#~ "有効な文字ではありません。それらは予約、プライベート、あるいは\n"
#~ "その他であるかもしれません。\n"
#~ "\n"
#~ "詳細は以下を参照してください:\n"
#~ "[Non-characters – Wikipedia](https://en.wikipedia.org/wiki/"
#~ "Universal_Character_Set_characters#Non-characters)\n"
#~ "\n"
#~ "## Examples\n"
#~ "\n"
#~ "    iex> String.valid_character?(\"a\")\n"
#~ "    true\n"
#~ "\n"
#~ "    iex> String.valid_character?(\"ø\")\n"
#~ "    true\n"
#~ "\n"
#~ "    iex> String.valid_character?(\"\\x{ffff}\")\n"
#~ "    false\n"
#~ "\n"

#~ msgid ""
#~ "Reverses the given string. Works on graphemes.\n"
#~ "\n"
#~ "## Examples\n"
#~ "\n"
#~ "    iex> String.reverse(\"abcd\")\n"
#~ "    \"dcba\"\n"
#~ "\n"
#~ "    iex> String.reverse(\"hello world\")\n"
#~ "    \"dlrow olleh\"\n"
#~ "\n"
#~ "    iex> String.reverse(\"hello ∂og\")\n"
#~ "    \"go∂ olleh\"\n"
#~ "\n"
#~ msgstr ""
#~ "与えられた文字列を逆順にします。書記素ベースで働きます。\n"
#~ "\n"
#~ "## 例\n"
#~ "\n"
#~ "    iex> String.reverse(\"abcd\")\n"
#~ "    \"dcba\"\n"
#~ "\n"
#~ "    iex> String.reverse(\"hello world\")\n"
#~ "    \"dlrow olleh\"\n"
#~ "\n"
#~ "    iex> String.reverse(\"hello ∂og\")\n"
#~ "    \"go∂ olleh\"\n"
#~ "\n"

#~ msgid ""
#~ "Converts a string into a char list.\n"
#~ "\n"
#~ "## Examples\n"
#~ "\n"
#~ "    iex> String.to_char_list(\"æß\")\n"
#~ "    'æß'\n"
#~ "\n"
#~ "Notice that this function expects a list of integers representing\n"
#~ "UTF-8 codepoints. If you have a raw binary, you must instead use\n"
#~ "[the `:binary` module](http://erlang.org/doc/man/binary.html).\n"
#~ msgstr ""
#~ "文字列を文字リストに変換します。\n"
#~ "\n"
#~ "## 例\n"
#~ "\n"
#~ "    iex> String.to_char_list(\"æß\")\n"
#~ "    'æß'\n"
#~ "\n"
#~ "この関数は、UTF-8コードポイントで表現される整数のリストを期待している\n"
#~ "ことに、注意してください。もしrawバイナリをもっていたら、\n"
#~ "[`:binary`モジュール](http://erlang.org/doc/man/binary.html)\n"
#~ "を代りに使わなければなりません。\n"
