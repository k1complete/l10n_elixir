msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2015-05-20 21:54+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: def String.to_float(string)
#: lib/string.ex:1439
msgid ""
"Returns a float whose text representation is `string`.\n"
"\n"
"`string` must be the string representation of a float.\n"
"If a string representation of an integer wants to be used,\n"
"then `Float.parse/1` should be used instead,\n"
"otherwise an argument error will be raised.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.to_float(\"2.2017764e+0\")\n"
"    2.2017764\n"
"\n"
"    iex> String.to_float(\"3.0\")\n"
"    3.0\n"
"\n"
msgstr ""
"テキスト`string`が表現する浮動小数点数を返します。\n"
"\n"
"`string`は浮動小数点数の文字列表現でなくてはなりません。\n"
"もし整数の文字列表現を使いたいなら、`Float.parse/1`を代わりに\n"
"使うべきです。さもなければ、argument errorが上ります。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.to_float(\"2.2017764e+0\")\n"
"    2.2017764\n"
"\n"
"    iex> String.to_float(\"3.0\")\n"
"    3.0\n"
"\n"

#. TRANSLATORS: def String.duplicate(subject, n)
#: lib/string.ex:727
msgid ""
"Returns a binary `subject` duplicated `n` times.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.duplicate(\"abc\", 0)\n"
"    \"\"\n"
"\n"
"    iex> String.duplicate(\"abc\", 1)\n"
"    \"abc\"\n"
"\n"
"    iex> String.duplicate(\"abc\", 2)\n"
"    \"abcabc\"\n"
"\n"
msgstr ""
"`subject`を`n`回複製したバイナリを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.duplicate(\"abc\", 0)\n"
"    \"\"\n"
"\n"
"    iex> String.duplicate(\"abc\", 1)\n"
"    \"abc\"\n"
"\n"
"    iex> String.duplicate(\"abc\", 2)\n"
"    \"abcabc\"\n"
"\n"

#. TRANSLATORS: def String.starts_with?(string, prefixes)
#: lib/string.ex:1214
msgid ""
"Returns `true` if `string` starts with any of the prefixes given, otherwise\n"
"returns `false`. `prefixes` can be either a single prefix or a list of "
"prefixes.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.starts_with? \"elixir\", \"eli\"\n"
"    true\n"
"\n"
"    iex> String.starts_with? \"elixir\", [\"erlang\", \"elixir\"]\n"
"    true\n"
"\n"
"    iex> String.starts_with? \"elixir\", [\"erlang\", \"ruby\"]\n"
"    false\n"
"\n"
msgstr ""
"もし、`string`が与えらえれたプレフィックスの何れかで開始していれば、\n"
"`true`を返します。さもなければ`false`を返します。`prefixes`は一つの\n"
"文字列でも、プレフィックスのリストでもよいです。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.starts_with? \"elixir\", \"eli\"\n"
"    true\n"
"\n"
"    iex> String.starts_with? \"elixir\", [\"erlang\", \"elixir\"]\n"
"    true\n"
"\n"
"    iex> String.starts_with? \"elixir\", [\"erlang\", \"ruby\"]\n"
"    false\n"
"\n"

#. TRANSLATORS: def String.ends_with?(string, suffixes)
#: lib/string.ex:1248
msgid ""
"Returns `true` if `string` ends with any of the suffixes given, otherwise\n"
"returns `false`. `suffixes` can be either a single suffix or a list of "
"suffixes.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.ends_with? \"language\", \"age\"\n"
"    true\n"
"\n"
"    iex> String.ends_with? \"language\", [\"youth\", \"age\"]\n"
"    true\n"
"\n"
"    iex> String.ends_with? \"language\", [\"youth\", \"elixir\"]\n"
"    false\n"
"\n"
msgstr ""
"もし、`string`が与えらえれたサフィックスの何れかで終了していれば、\n"
"`true`を返します。さもなければ`false`を返します。`suffixes`は一つの\n"
"文字列でも、サフィイクスのリストでもよいです。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.ends_with? \"language\", \"age\"\n"
"    true\n"
"\n"
"    iex> String.ends_with? \"language\", [\"youth\", \"age\"]\n"
"    true\n"
"\n"
"    iex> String.ends_with? \"language\", [\"youth\", \"elixir\"]\n"
"    false\n"
"\n"

#. TRANSLATORS: def String.chunk(string, trait)
#: lib/string.ex:861
msgid ""
"Splits the string into chunks of characters that share a common trait.\n"
"\n"
"The trait can be one of two options:\n"
"\n"
"  * `:valid` – the string is split into chunks of valid and invalid "
"character\n"
"    sequences\n"
"\n"
"  * `:printable` – the string is split into chunks of printable and\n"
"    non-printable character sequences\n"
"\n"
"Returns a list of binaries each of which contains only one kind of\n"
"characters.\n"
"\n"
"If the given string is empty, an empty list is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.chunk(<<?a, ?b, ?c, 0>>, :valid)\n"
"    [\"abc\\0\"]\n"
"\n"
"    iex> String.chunk(<<?a, ?b, ?c, 0, 0x0ffff::utf8>>, :valid)\n"
"    [\"abc\\0\", <<0x0ffff::utf8>>]\n"
"\n"
"    iex> String.chunk(<<?a, ?b, ?c, 0, 0x0ffff::utf8>>, :printable)\n"
"    [\"abc\", <<0, 0x0ffff::utf8>>]\n"
"\n"
msgstr ""
"文字列を共通するtrait(特質)の文字の塊に分割します。\n"
"\n"
"特質(trait)は二つのオプションのうちひとつを取ることができます:\n"
"\n"
"  * `:valid` - 文字列は文字列として有効か無効かにより塊に分割されます。\n"
"\n"
"  * `:printable` - 文字列は文字列として表示可能か表示不可能かにより\n"
"    塊に分割されます。\n"
"\n"
"それぞれの種類のみを含むバイナリのリストを返します。\n"
"\n"
"与えられた文字列が空なら、空のリストが返されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.chunk(<<?a, ?b, ?c, 0>>, :valid)\n"
"    [\"abc\\0\"]\n"
"\n"
"    iex> String.chunk(<<?a, ?b, ?c, 0, 0x0ffff::utf8>>, :valid)\n"
"    [\"abc\\0\", <<0x0ffff::utf8>>]\n"
"\n"
"    iex> String.chunk(<<?a, ?b, ?c, 0, 0x0ffff::utf8>>, :printable)\n"
"    [\"abc\", <<0, 0x0ffff::utf8>>]\n"
"\n"

#. TRANSLATORS: def String.split_at(string, offset)
#: lib/string.ex:366
msgid ""
"Splits a string into two at the specified offset. When the offset given is\n"
"negative, location is counted from the end of the string.\n"
"\n"
"The offset is capped to the length of the string.\n"
"\n"
"Returns a tuple with two elements.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.split_at \"sweetelixir\", 5\n"
"    {\"sweet\", \"elixir\"}\n"
"\n"
"    iex> String.split_at \"sweetelixir\", -6\n"
"    {\"sweet\", \"elixir\"}\n"
"\n"
"    iex> String.split_at \"abc\", 0\n"
"    {\"\", \"abc\"}\n"
"\n"
"    iex> String.split_at \"abc\", 1000\n"
"    {\"abc\", \"\"}\n"
"\n"
"    iex> String.split_at \"abc\", -1000\n"
"    {\"\", \"abc\"}\n"
"\n"
msgstr ""
"文字列を指定したオフセットで二つに分割します。与えられたオフセットが負\n"
"なら、文字列の終わりから場所を数えます。\n"
"\n"
"オフセットは文字列の長さでキャップされます。\n"
"\n"
"二つの要素のタプルが返されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.split_at \"sweetelixir\", 5\n"
"    {\"sweet\", \"elixir\"}\n"
"\n"
"    iex> String.split_at \"sweetelixir\", -6\n"
"    {\"sweet\", \"elixir\"}\n"
"\n"
"    iex> String.split_at \"abc\", 0\n"
"    {\"\", \"abc\"}\n"
"\n"
"    iex> String.split_at \"abc\", 1000\n"
"    {\"abc\", \"\"}\n"
"\n"
"    iex> String.split_at \"abc\", -1000\n"
"    {\"\", \"abc\"}\n"
"\n"

#. TRANSLATORS: def String.split(string, pattern, options \\ [])
#: lib/string.ex:289
msgid ""
"Divides a string into substrings based on a pattern.\n"
"\n"
"Returns a list of these substrings. The pattern can\n"
"be a string, a list of strings or a regular expression.\n"
"\n"
"The string is split into as many parts as possible by\n"
"default, but can be controlled via the `parts: num` option.\n"
"If you pass `parts: :infinity`, it will return all possible parts.\n"
"\n"
"Empty strings are only removed from the result if the\n"
"`trim` option is set to `true`.\n"
"\n"
"## Examples\n"
"\n"
"Splitting with a string pattern:\n"
"\n"
"    iex> String.split(\"a,b,c\", \",\")\n"
"    [\"a\", \"b\", \"c\"]\n"
"\n"
"    iex> String.split(\"a,b,c\", \",\", parts: 2)\n"
"    [\"a\", \"b,c\"]\n"
"\n"
"    iex> String.split(\" a b c \", \" \", trim: true)\n"
"    [\"a\", \"b\", \"c\"]\n"
"\n"
"A list of patterns:\n"
"\n"
"    iex> String.split(\"1,2 3,4\", [\" \", \",\"])\n"
"    [\"1\", \"2\", \"3\", \"4\"]\n"
"\n"
"A regular expression:\n"
"\n"
"    iex> String.split(\"a,b,c\", ~r{,})\n"
"    [\"a\", \"b\", \"c\"]\n"
"\n"
"    iex> String.split(\"a,b,c\", ~r{,}, parts: 2)\n"
"    [\"a\", \"b,c\"]\n"
"\n"
"    iex> String.split(\" a b c \", ~r{\\s}, trim: true)\n"
"    [\"a\", \"b\", \"c\"]\n"
"\n"
"Splitting on empty patterns returns codepoints:\n"
"\n"
"    iex> String.split(\"abc\", ~r{})\n"
"    [\"a\", \"b\", \"c\", \"\"]\n"
"\n"
"    iex> String.split(\"abc\", \"\")\n"
"    [\"a\", \"b\", \"c\", \"\"]\n"
"\n"
"    iex> String.split(\"abc\", \"\", trim: true)\n"
"    [\"a\", \"b\", \"c\"]\n"
"\n"
"    iex> String.split(\"abc\", \"\", parts: 2)\n"
"    [\"a\", \"bc\"]\n"
"\n"
msgstr ""
"文字列をpatternに基いて部分文字列に分割します。\n"
"\n"
"部分文字列のリストを返します。パターンは、\n"
"文字列、文字列のリストあるいは、正規表現が使えます。\n"
"\n"
"文字列はデフォルトでは出来るだけ多くの部分になるように\n"
"分割されますが、`parts: num`オプションにより制御すること\n"
"できます。\n"
"もし`parts: :infinity`を渡すと、出来るだけ多くの部分を返します。\n"
"\n"
"`trim`オプションが`true`にセットされると、\n"
"分割の結果の空の文字列は削除されます。\n"
"\n"
"## 例\n"
"\n"
"文字列パターンによる分割:\n"
"\n"
"    iex> String.split(\"a,b,c\", \",\")\n"
"    [\"a\", \"b\", \"c\"]\n"
"\n"
"    iex> String.split(\"a,b,c\", \",\", parts: 2)\n"
"    [\"a\", \"b,c\"]\n"
"\n"
"    iex> String.split(\" a b c \", \" \", trim: true)\n"
"    [\"a\", \"b\", \"c\"]\n"
"\n"
"パターンのリスト:\n"
"\n"
"    iex> String.split(\"1,2 3,4\", [\" \", \",\"])\n"
"    [\"1\", \"2\", \"3\", \"4\"]\n"
"\n"
"正規表現:\n"
"\n"
"    iex> String.split(\"a,b,c\", ~r{,})\n"
"    [\"a\", \"b\", \"c\"]\n"
"\n"
"    iex> String.split(\"a,b,c\", ~r{,}, parts: 2)\n"
"    [\"a\", \"b,c\"]\n"
"\n"
"    iex> String.split(\" a b c \", ~r{\\s}, trim: true)\n"
"    [\"a\", \"b\", \"c\"]\n"
"\n"
"空のパターンによる分割はコードポイントのリストを返します:\n"
"\n"
"    iex> String.split(\"abc\", ~r{})\n"
"    [\"a\", \"b\", \"c\", \"\"]\n"
"\n"
"    iex> String.split(\"abc\", \"\")\n"
"    [\"a\", \"b\", \"c\", \"\"]\n"
"\n"
"    iex> String.split(\"abc\", \"\", trim: true)\n"
"    [\"a\", \"b\", \"c\"]\n"
"\n"
"    iex> String.split(\"abc\", \"\", parts: 2)\n"
"    [\"a\", \"bc\"]\n"
"\n"

#. TRANSLATORS: def String.split(binary)
#: lib/string.ex:228
msgid ""
"Divides a string into substrings at each Unicode whitespace\n"
"occurrence with leading and trailing whitespace ignored.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.split(\"foo bar\")\n"
"    [\"foo\", \"bar\"]\n"
"\n"
"    iex> String.split(\"foo\" <> <<194, 133>> <> \"bar\")\n"
"    [\"foo\", \"bar\"]\n"
"\n"
"    iex> String.split(\" foo bar \")\n"
"    [\"foo\", \"bar\"]\n"
"\n"
msgstr ""
"文字列を、先頭と末尾の空白を無視して、Unicode空白ごとに部分文字列に分割\n"
"します。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.split(\"foo bar\")\n"
"    [\"foo\", \"bar\"]\n"
"\n"
"    iex> String.split(\"foo\" <> <<194, 133>> <> \"bar\")\n"
"    [\"foo\", \"bar\"]\n"
"\n"
"    iex> String.split(\" foo bar \")\n"
"    [\"foo\", \"bar\"]\n"
"\n"

#. TRANSLATORS: def String.capitalize(string)
#: lib/string.ex:443
msgid ""
"Converts the first character in the given string to\n"
"uppercase and the remaining to lowercase.\n"
"\n"
"This relies on the titlecase information provided\n"
"by the Unicode Standard. Note this function makes\n"
"no attempt to capitalize all words in the string\n"
"(usually known as titlecase).\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.capitalize(\"abcd\")\n"
"    \"Abcd\"\n"
"\n"
"    iex> String.capitalize(\"ﬁn\")\n"
"    \"Fin\"\n"
"\n"
"    iex> String.capitalize(\"olá\")\n"
"    \"Olá\"\n"
"\n"
msgstr ""
"与えられた文字列の最初の文字を大文字に、残りを\n"
"小文字に変換します。\n"
"\n"
"これはUnicode標準により提供される、titlecase情報に依存しています。\n"
"この関数は、(通常titlecaseとして知られる)文字列の全ての語を\n"
"大文字にしようとしない点に、注意してください。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.capitalize(\"abcd\")\n"
"    \"Abcd\"\n"
"\n"
"    iex> String.capitalize(\"ﬁn\")\n"
"    \"Fin\"\n"
"\n"
"    iex> String.capitalize(\"olá\")\n"
"    \"Olá\"\n"
"\n"

#. TRANSLATORS: def String.printable?(b)
#: lib/string.ex:190
msgid ""
"Checks if a string is printable considering it is encoded\n"
"as UTF-8. Returns `true` if so, `false` otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.printable?(\"abc\")\n"
"    true\n"
"\n"
msgstr ""
"文字列がUTC-8でエンコードされているとみなし、印字可能かどうか\n"
"チェックします。そうなら`true`を返し、さもなくば`false`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.printable?(\"abc\")\n"
"    true\n"
"\n"

#. TRANSLATORS: def String.match?(string, regex)
#: lib/string.ex:1280
msgid ""
"Checks if `string` matches the given regular expression.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.match?(\"foo\", ~r/foo/)\n"
"    true\n"
"\n"
"    iex> String.match?(\"bar\", ~r/foo/)\n"
"    false\n"
"\n"
msgstr ""
"`string`が与えられた正規表現にマッチするかをチェックします。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.match?(\"foo\", ~r/foo/)\n"
"    true\n"
"\n"
"    iex> String.match?(\"bar\", ~r/foo/)\n"
"    false\n"
"\n"

#. TRANSLATORS: def String.contains?(string, contents)
#: lib/string.ex:1303
msgid ""
"Checks if `string` contains any of the given `contents`.\n"
"\n"
"`matches` can be either a single string or a list of strings.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.contains? \"elixir of life\", \"of\"\n"
"    true\n"
"\n"
"    iex> String.contains? \"elixir of life\", [\"life\", \"death\"]\n"
"    true\n"
"\n"
"    iex> String.contains? \"elixir of life\", [\"death\", \"mercury\"]\n"
"    false\n"
"\n"
msgstr ""
"`string`が与えられた`contents`のどれかを含んでいるかをチェックします。\n"
"\n"
"`matches`は単一の文字列でも文字列のリストでも構いません。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.contains? \"elixir of life\", \"of\"\n"
"    true\n"
"\n"
"    iex> String.contains? \"elixir of life\", [\"life\", \"death\"]\n"
"    true\n"
"\n"
"    iex> String.contains? \"elixir of life\", [\"death\", \"mercury\"]\n"
"    false\n"
"\n"

#. TRANSLATORS: def String.valid_character?(codepoint)
#: lib/string.ex:828
msgid ""
"Checks whether `str` is a valid character.\n"
"\n"
"All characters are codepoints, but some codepoints\n"
"are not valid characters. They may be reserved, private,\n"
"or other.\n"
"\n"
"More info at: http://en.wikipedia.org/wiki/"
"Mapping_of_Unicode_characters#Noncharacters\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.valid_character?(\"a\")\n"
"    true\n"
"\n"
"    iex> String.valid_character?(\"ø\")\n"
"    true\n"
"\n"
"    iex> String.valid_character?(\"\\x{ffff}\")\n"
"    false\n"
"\n"
msgstr ""
"`str`が有効な文字かどうかをチェックします。\n"
"全て文字がコードポイントですが、いくつかのコードポイントは\n"
"有効な文字ではありません。それらは予約、プライベート、あるいは\n"
"その他であるかもしれません。\n"
"\n"
"詳細は以下を参照してください:\n"
"http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Noncharacters\n"
"\n"
"## 例\n"
"\n"
"    iex> String.valid_character?(\"a\")\n"
"    true\n"
"\n"
"    iex> String.valid_character?(\"ø\")\n"
"    true\n"
"\n"
"    iex> String.valid_character?(\"\\x{ffff}\")\n"
"    false\n"
"\n"

#. TRANSLATORS: def String.valid?(arg1)
#: lib/string.ex:798
msgid ""
"Checks whether `str` contains only valid characters.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.valid?(\"a\")\n"
"    true\n"
"\n"
"    iex> String.valid?(\"ø\")\n"
"    true\n"
"\n"
"    iex> String.valid?(<<0xffff :: 16>>)\n"
"    false\n"
"\n"
"    iex> String.valid?(\"asd\" <> <<0xffff :: 16>>)\n"
"    false\n"
"\n"
msgstr ""
"`str`が有効な文字だけを含んでいるかどうかをチェックします。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.valid?(\"a\")\n"
"    true\n"
"\n"
"    iex> String.valid?(\"ø\")\n"
"    true\n"
"\n"
"    iex> String.valid?(<<0xffff :: 16>>)\n"
"    false\n"
"\n"
"    iex> String.valid?(\"asd\" <> <<0xffff :: 16>>)\n"
"    false\n"
"\n"

#. TRANSLATORS: def String.graphemes(string)
#: lib/string.ex:902
msgid ""
"Returns unicode graphemes in the string as per Extended Grapheme\n"
"Cluster algorithm outlined in the [Unicode Standard Annex #29,\n"
"Unicode Text Segmentation](http://www.unicode.org/reports/tr29/).\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.graphemes(\"Ńaïve\")\n"
"    [\"Ń\", \"a\", \"ï\", \"v\", \"e\"]\n"
"\n"
msgstr ""
"[Unicode Text Segmentation](http://www.unicode.org/reports/tr29/)\n"
"に概説されている、Extended Grapheme Cluster アルゴリズムに従って\n"
"文字列のユニコード書記素を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.graphemes(\"Ńaïve\")\n"
"    [\"Ń\", \"a\", \"ï\", \"v\", \"e\"]\n"
"\n"

#. TRANSLATORS: def String.reverse(string)
#: lib/string.ex:701
msgid ""
"Reverses the given string. Works on graphemes.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.reverse(\"abcd\")\n"
"    \"dcba\"\n"
"\n"
"    iex> String.reverse(\"hello world\")\n"
"    \"dlrow olleh\"\n"
"\n"
"    iex> String.reverse(\"hello ∂og\")\n"
"    \"go∂ olleh\"\n"
"\n"
msgstr ""
"与えられた文字列を逆順にします。書記素ベースで働きます。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.reverse(\"abcd\")\n"
"    \"dcba\"\n"
"\n"
"    iex> String.reverse(\"hello world\")\n"
"    \"dlrow olleh\"\n"
"\n"
"    iex> String.reverse(\"hello ∂og\")\n"
"    \"go∂ olleh\"\n"
"\n"

#. TRANSLATORS: def String.length(string)
#: lib/string.ex:979
msgid ""
"Returns the number of unicode graphemes in an utf8 string.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.length(\"elixir\")\n"
"    6\n"
"\n"
"    iex> String.length(\"եոգլի\")\n"
"    5\n"
"\n"
msgstr ""
"utf8文字列中のunicode書記素の数を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.length(\"elixir\")\n"
"    6\n"
"\n"
"    iex> String.length(\"եոգլի\")\n"
"    5\n"
"\n"

#. TRANSLATORS: def String.last(string)
#: lib/string.ex:956
msgid ""
"Returns the last grapheme from an utf8 string,\n"
"`nil` if the string is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.last(\"elixir\")\n"
"    \"r\"\n"
"\n"
"    iex> String.last(\"եոգլի\")\n"
"    \"ի\"\n"
"\n"
msgstr ""
"utf8文字列から最後の書記素を返します。\n"
"文字列が空なら`nil`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.last(\"elixir\")\n"
"    \"r\"\n"
"\n"
"    iex> String.last(\"եոգլի\")\n"
"    \"ի\"\n"
"\n"

#. TRANSLATORS: def String.at(string, position)
#: lib/string.ex:1013
msgid ""
"Returns the grapheme in the `position` of the given utf8 `string`.\n"
"If `position` is greater than `string` length, then it returns `nil`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.at(\"elixir\", 0)\n"
"    \"e\"\n"
"\n"
"    iex> String.at(\"elixir\", 1)\n"
"    \"l\"\n"
"\n"
"    iex> String.at(\"elixir\", 10)\n"
"    nil\n"
"\n"
"    iex> String.at(\"elixir\", -1)\n"
"    \"r\"\n"
"\n"
"    iex> String.at(\"elixir\", -10)\n"
"    nil\n"
"\n"
msgstr ""
"与えられたutf8の`string`の`position`の位置の書記素を返します。\n"
"`position`が`string`の長さより大きいなら、`nil`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.at(\"elixir\", 0)\n"
"    \"e\"\n"
"\n"
"    iex> String.at(\"elixir\", 1)\n"
"    \"l\"\n"
"\n"
"    iex> String.at(\"elixir\", 10)\n"
"    nil\n"
"\n"
"    iex> String.at(\"elixir\", -1)\n"
"    \"r\"\n"
"\n"
"    iex> String.at(\"elixir\", -10)\n"
"    nil\n"
"\n"

#. TRANSLATORS: def String.first(string)
#: lib/string.ex:935
msgid ""
"Returns the first grapheme from an utf8 string,\n"
"nil if the string is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.first(\"elixir\")\n"
"    \"e\"\n"
"\n"
"    iex> String.first(\"եոգլի\")\n"
"    \"ե\"\n"
"\n"
msgstr ""
"utf8文字列から最初の書記素を返します。\n"
"文字列が空ならnilを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.first(\"elixir\")\n"
"    \"e\"\n"
"\n"
"    iex> String.first(\"եոգլի\")\n"
"    \"ե\"\n"
"\n"

#. TRANSLATORS: def String.codepoints(string)
#: lib/string.ex:747
msgid ""
"Returns all codepoints in the string.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.codepoints(\"olá\")\n"
"    [\"o\", \"l\", \"á\"]\n"
"\n"
"    iex> String.codepoints(\"оптими зации\")\n"
"    [\"о\",\"п\",\"т\",\"и\",\"м\",\"и\",\" \",\"з\",\"а\",\"ц\",\"и\",\"и"
"\"]\n"
"\n"
"    iex> String.codepoints(\"ἅἪῼ\")\n"
"    [\"ἅ\",\"Ἢ\",\"ῼ\"]\n"
"\n"
msgstr ""
"文字列の全てのコードポイントを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.codepoints(\"olá\")\n"
"    [\"o\", \"l\", \"á\"]\n"
"\n"
"    iex> String.codepoints(\"оптими зации\")\n"
"    [\"о\",\"п\",\"т\",\"и\",\"м\",\"и\",\" \",\"з\",\"а\",\"ц\",\"и\",\"и"
"\"]\n"
"\n"
"    iex> String.codepoints(\"ἅἪῼ\")\n"
"    [\"ἅ\",\"Ἢ\",\"ῼ\"]\n"
"\n"

#. TRANSLATORS: def String.next_grapheme(string)
#: lib/string.ex:919
msgid ""
"Returns the next grapheme in a String.\n"
"\n"
"The result is a tuple with the grapheme and the\n"
"remaining of the string or `nil` in case\n"
"the String reached its end.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.next_grapheme(\"olá\")\n"
"    {\"o\", \"lá\"}\n"
"\n"
msgstr ""
"文字列の中の次の書記素を返します。\n"
"\n"
"結果は、書記素と、文字列の残りまたは、文字列がその終わりに到達したとき\n"
"は`nil`、のタプルです。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.next_grapheme(\"olá\")\n"
"    {\"o\", \"lá\"}\n"
"\n"

#. TRANSLATORS: def String.next_codepoint(string)
#: lib/string.ex:769
msgid ""
"Returns the next codepoint in a String.\n"
"\n"
"The result is a tuple with the codepoint and the\n"
"remaining of the string or `nil` in case\n"
"the string reached its end.\n"
"\n"
"As with other functions in the String module, this\n"
"function does not check for the validity of the codepoint.\n"
"That said, if an invalid codepoint is found, it will\n"
"be returned by this function.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.next_codepoint(\"olá\")\n"
"    {\"o\", \"lá\"}\n"
"\n"
msgstr ""
"文字列の中の次のコードポイントを返します。\n"
"\n"
"結果は、コードポイントと、文字列の残りまたは、文字列がその終わりに到達したと"
"き\n"
"は`nil`、のタプルです。\n"
"\n"
"Stringモジュールの他の関数と同様に、この関数はコードポイントの\n"
"有効性についてチェックしません。\n"
"それは、もし無効なコードポイントを見付けたら、それは\n"
"この関数によって返される、ということを言っています。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.next_codepoint(\"olá\")\n"
"    {\"o\", \"lá\"}\n"
"\n"

#. TRANSLATORS: def String.to_integer(string)
#: lib/string.ex:1399
msgid ""
"Returns an integer whose text representation is `string`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.to_integer(\"123\")\n"
"    123\n"
"\n"
msgstr ""
"テキスト表現が`string`となる整数を返します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.to_integer(\"123\")\n"
"    123\n"
"\n"

#. TRANSLATORS: def String.to_integer(string, base)
#: lib/string.ex:1415
msgid ""
"Returns an integer whose text representation is `string` in base `base`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.to_integer(\"3FF\", 16)\n"
"    1023\n"
"\n"
msgstr ""
"テキスト表現が基数`base`の`string`である整数を返します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.to_integer(\"3FF\", 16)\n"
"    1023\n"
"\n"

#. TRANSLATORS: def String.slice(string, start, len)
#: lib/string.ex:1074
msgid ""
"Returns a substring starting at the offset given by the first, and\n"
"a length given by the second.\n"
"\n"
"If the offset is greater than string length, then it returns `\"\"`.\n"
"\n"
"Remember this function works with unicode codepoints and considers\n"
"the slices to represent codepoints offsets. If you want to split\n"
"on raw bytes, check `Kernel.binary_part/3` instead.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.slice(\"elixir\", 1, 3)\n"
"    \"lix\"\n"
"\n"
"    iex> String.slice(\"elixir\", 1, 10)\n"
"    \"lixir\"\n"
"\n"
"    iex> String.slice(\"elixir\", 10, 3)\n"
"    \"\"\n"
"\n"
"    iex> String.slice(\"elixir\", -4, 4)\n"
"    \"ixir\"\n"
"\n"
"    iex> String.slice(\"elixir\", -10, 3)\n"
"    \"\"\n"
"\n"
"    iex> String.slice(\"a\", 0, 1500)\n"
"    \"a\"\n"
"\n"
"    iex> String.slice(\"a\", 1, 1500)\n"
"    \"\"\n"
"\n"
"    iex> String.slice(\"a\", 2, 1500)\n"
"    \"\"\n"
"\n"
msgstr ""
"最初に与えられたオフセットからスタートして\n"
"二番めに与えらえた長さの部分文字列を返します。\n"
"\n"
"文字列の長さよりオフセットが大きいなら、`\"\"`を返します。\n"
"\n"
"この関数はunicodeコードポイントで動作すること、そして、コードポイントオ\n"
"フセットを表現するためにスライスを考慮していることを忘れないでください。\n"
"もし生のバイト列で分割したいなら、`Kernel.binary_part/3`を替わりにチェッ\n"
"クしてください。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.slice(\"elixir\", 1, 3)\n"
"    \"lix\"\n"
"\n"
"    iex> String.slice(\"elixir\", 1, 10)\n"
"    \"lixir\"\n"
"\n"
"    iex> String.slice(\"elixir\", 10, 3)\n"
"    \"\"\n"
"\n"
"    iex> String.slice(\"elixir\", -4, 4)\n"
"    \"ixir\"\n"
"\n"
"    iex> String.slice(\"elixir\", -10, 3)\n"
"    \"\"\n"
"\n"
"    iex> String.slice(\"a\", 0, 1500)\n"
"    \"a\"\n"
"\n"
"    iex> String.slice(\"a\", 1, 1500)\n"
"    \"\"\n"
"\n"
"    iex> String.slice(\"a\", 2, 1500)\n"
"    \"\"\n"
"\n"

#. TRANSLATORS: def String.slice(string, range)
#: lib/string.ex:1152
msgid ""
"Returns a substring from the offset given by the start of the\n"
"range to the offset given by the end of the range.\n"
"\n"
"If the start of the range is not a valid offset for the given\n"
"string or if the range is in reverse order, returns `\"\"`.\n"
"\n"
"If the start or end of the range is negative, the whole string\n"
"is traversed first in order to convert the negative indices into\n"
"positive ones.\n"
"\n"
"Remember this function works with unicode codepoints and considers\n"
"the slices to represent codepoints offsets. If you want to split\n"
"on raw bytes, check `Kernel.binary_part/3` instead.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.slice(\"elixir\", 1..3)\n"
"    \"lix\"\n"
"\n"
"    iex> String.slice(\"elixir\", 1..10)\n"
"    \"lixir\"\n"
"\n"
"    iex> String.slice(\"elixir\", 10..3)\n"
"    \"\"\n"
"\n"
"    iex> String.slice(\"elixir\", -4..-1)\n"
"    \"ixir\"\n"
"\n"
"    iex> String.slice(\"elixir\", 2..-1)\n"
"    \"ixir\"\n"
"\n"
"    iex> String.slice(\"elixir\", -4..6)\n"
"    \"ixir\"\n"
"\n"
"    iex> String.slice(\"elixir\", -1..-4)\n"
"    \"\"\n"
"\n"
"    iex> String.slice(\"elixir\", -10..-7)\n"
"    \"\"\n"
"\n"
"    iex> String.slice(\"a\", 0..1500)\n"
"    \"a\"\n"
"\n"
"    iex> String.slice(\"a\", 1..1500)\n"
"    \"\"\n"
"\n"
msgstr ""
"範囲(range)の始まりによって与えられるオフセットから\n"
"範囲の終りまでに与えられるオフセットまで部分文字列を返します。\n"
"\n"
"範囲の始まりが与えられた文字列のオフセットとして正しくない、\n"
"あるいは、範囲が逆順であったら、`\"\"`を返します。\n"
"\n"
"範囲の始まりや終わりが負の場合、負のインデックスを正に変えるために\n"
"文字列全体が最初に走査されます。\n"
"\n"
"この関数はunicodeコードポイントで動作すること、そして、コードポイントオ\n"
"フセットを表現するためにスライスを考慮していることを忘れないでください。\n"
"もし生のバイト列で分割したいなら、`Kernel.binary_part/3`を替わりにチェッ\n"
"クしてください。\n"
"\n"
"\n"
"## 例\n"
"\n"
"    iex> String.slice(\"elixir\", 1..3)\n"
"    \"lix\"\n"
"\n"
"    iex> String.slice(\"elixir\", 1..10)\n"
"    \"lixir\"\n"
"\n"
"    iex> String.slice(\"elixir\", 10..3)\n"
"    \"\"\n"
"\n"
"    iex> String.slice(\"elixir\", -4..-1)\n"
"    \"ixir\"\n"
"\n"
"    iex> String.slice(\"elixir\", 2..-1)\n"
"    \"ixir\"\n"
"\n"
"    iex> String.slice(\"elixir\", -4..6)\n"
"    \"ixir\"\n"
"\n"
"    iex> String.slice(\"elixir\", -1..-4)\n"
"    \"\"\n"
"\n"
"    iex> String.slice(\"elixir\", -10..-7)\n"
"    \"\"\n"
"\n"
"    iex> String.slice(\"a\", 0..1500)\n"
"    \"a\"\n"
"\n"
"    iex> String.slice(\"a\", 1..1500)\n"
"    \"\"\n"
"\n"

#. TRANSLATORS: def String.rjust(subject, len, pad \\ 32)
#: lib/string.ex:583
msgid ""
"Returns a new string of length `len` with `subject` right justified and\n"
"padded with `padding`. If `padding` is not present, it defaults to\n"
"whitespace. When `len` is less than the length of `subject`, `subject` is\n"
"returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.rjust(\"abc\", 5)\n"
"    \"  abc\"\n"
"\n"
"    iex> String.rjust(\"abc\", 5, ?-)\n"
"    \"--abc\"\n"
"\n"
msgstr ""
"`subject`を右寄して、`padding`でパディングした、長さ`len`の新しい文字列\n"
"を返します。もし`padding`がなければ、空白文字がデフォルトです。\n"
"`len`が`subject`の長さより小さいとき、`subject`が返されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.rjust(\"abc\", 5)\n"
"    \"  abc\"\n"
"\n"
"    iex> String.rjust(\"abc\", 5, ?-)\n"
"    \"--abc\"\n"
"\n"

#. TRANSLATORS: def String.ljust(subject, len, pad \\ 32)
#: lib/string.ex:604
msgid ""
"Returns a new string of length `len` with `subject` left justified and "
"padded\n"
"with `padding`. If `padding` is not present, it defaults to whitespace. "
"When\n"
"`len` is less than the length of `subject`, `subject` is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.ljust(\"abc\", 5)\n"
"    \"abc  \"\n"
"\n"
"    iex> String.ljust(\"abc\", 5, ?-)\n"
"    \"abc--\"\n"
"\n"
msgstr ""
"`subject`を左寄して、`padding`でパディングした、長さ`len`の新しい文字列\n"
"を返します。もし`padding`がなければ、空白文字がデフォルトです。\n"
"`len`が`subject`の長さより小さいとき、`subject`が返されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.ljust(\"abc\", 5)\n"
"    \"abc  \"\n"
"\n"
"    iex> String.ljust(\"abc\", 5, ?-)\n"
"    \"abc--\"\n"
"\n"

#. TRANSLATORS: def String.rstrip(string, char)
#: lib/string.ex:472
msgid ""
"Returns a string where trailing `char` have been removed.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.rstrip(\"   abc _\", ?_)\n"
"    \"   abc \"\n"
"\n"
msgstr ""
"末尾の`char`を取り除いた文字列を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.rstrip(\"   abc _\", ?_)\n"
"    \"   abc \"\n"
"\n"

#. TRANSLATORS: def String.rstrip(binary)
#: lib/string.ex:459
msgid ""
"Returns a string where trailing Unicode whitespace\n"
"has been removed.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.rstrip(\"   abc  \")\n"
"    \"   abc\"\n"
"\n"
msgstr ""
"末尾のUnicodeのホワイトスペース文字を取り除いた文字列を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.rstrip(\"   abc  \")\n"
"    \"   abc\"\n"
"\n"

#. TRANSLATORS: def String.strip(string, char)
#: lib/string.ex:561
msgid ""
"Returns a string where leading/trailing `char` have been\n"
"removed.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.strip(\"a  abc  a\", ?a)\n"
"    \"  abc  \"\n"
"\n"
msgstr ""
"先頭、末尾の`char`を取り除いた文字列を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.strip(\"a  abc  a\", ?a)\n"
"    \"  abc  \"\n"
"\n"

#. TRANSLATORS: def String.strip(string)
#: lib/string.ex:545
msgid ""
"Returns a string where leading/trailing Unicode whitespace\n"
"has been removed.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.strip(\"   abc  \")\n"
"    \"abc\"\n"
"\n"
msgstr ""
"先頭、末尾のUnicodeホワイトスペース文字を取り除いた文字列を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.strip(\"   abc  \")\n"
"    \"abc\"\n"
"\n"

#. TRANSLATORS: def String.lstrip(other, char)
#: lib/string.ex:525
msgid ""
"Returns a string where leading `char` have been removed.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.lstrip(\"_  abc  _\", ?_)\n"
"    \"  abc  _\"\n"
"\n"
msgstr ""
"先頭の`char`を取り除いた文字列を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.lstrip(\"_  abc  _\", ?_)\n"
"    \"  abc  _\"\n"
"\n"

#. TRANSLATORS: def String.lstrip(binary)
#: lib/string.ex:511
msgid ""
"Returns a string where leading Unicode whitespace\n"
"has been removed.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.lstrip(\"   abc  \")\n"
"    \"abc  \"\n"
"\n"
msgstr ""
"先頭のUnicodeホワイトスペース文字を取り除いた文字列を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.lstrip(\"   abc  \")\n"
"    \"abc  \"\n"
"\n"

#. TRANSLATORS: def String.replace(subject, pattern, replacement, options \\ [])
#: lib/string.ex:666
msgid ""
"Returns a new binary based on `subject` by replacing the parts\n"
"matching `pattern` by `replacement`. By default, it replaces\n"
"all entries, except if the `global` option is set to `false`.\n"
"\n"
"A `pattern` may be a string or a regex.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.replace(\"a,b,c\", \",\", \"-\")\n"
"    \"a-b-c\"\n"
"\n"
"    iex> String.replace(\"a,b,c\", \",\", \"-\", global: false)\n"
"    \"a-b,c\"\n"
"\n"
"The pattern can also be a regex. In those cases, one can give `\\N` or\n"
"`\\g{N}` in the `replacement` string to access a specific capture in the\n"
"regex:\n"
"\n"
"    iex> String.replace(\"a,b,c\", ~r/,(.)/, \",\\\\1\\\\1\")\n"
"    \"a,bb,cc\"\n"
"\n"
"Notice we had to escape the escape character `\\`. By giving `\\0`,\n"
"one can inject the whole matched pattern in the replacement string.\n"
"\n"
"When strings are used as a pattern, a developer can also use the\n"
"replaced part inside the `replacement` via the `:insert_replaced` option:\n"
"\n"
"    iex> String.replace(\"a,b,c\", \"b\", \"[]\", insert_replaced: 1)\n"
"    \"a,[b],c\"\n"
"\n"
"    iex> String.replace(\"a,b,c\", \",\", \"[]\", insert_replaced: 2)\n"
"    \"a[],b[],c\"\n"
"\n"
"    iex> String.replace(\"a,b,c\", \",\", \"[]\", insert_replaced: [1, 1])\n"
"    \"a[,,]b[,,]c\"\n"
"\n"
msgstr ""
"`subject`に基いて`pattern`にマッチした部分を`replacement`で置き換えた、\n"
"新しいバイナリを返します。`global`オプションを`false`にしないかぎり、デ\n"
"フォルトでは、全部のエントリを置き換えます。\n"
"\n"
"`pattern`は文字列か正規表現です。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.replace(\"a,b,c\", \",\", \"-\")\n"
"    \"a-b-c\"\n"
"\n"
"    iex> String.replace(\"a,b,c\", \",\", \"-\", global: false)\n"
"    \"a-b,c\"\n"
"\n"
"パターンは正規表現でもよいです。それらのケースでは、`replacement`文字列\n"
"中で、正規表現中で捕捉した文字列にアクセスするために`\\N`または`\\g{N}`を\n"
"使うことができます:\n"
"\n"
"    iex> String.replace(\"a,b,c\", ~r/,(.)/, \",\\\\1\\\\1\")\n"
"    \"a,bb,cc\"\n"
"\n"
"エスケープ文字`\\`を使わなくてはならないことに注意してください。\n"
"`\\0`を与えることにより、置き換え文字列の中でパターンにマッチした\n"
"全体を捕捉することができます。\n"
"\n"
"パターンとして文字列が使われたとき、開発者は`replacement`の\n"
"内側に、`:insert_replaced`オプションによりパターンを埋め込む\n"
"ことが出来ます: \n"
"\n"
"    iex> String.replace(\"a,b,c\", \"b\", \"[]\", insert_replaced: 1)\n"
"    \"a,[b],c\"\n"
"\n"
"    iex> String.replace(\"a,b,c\", \",\", \"[]\", insert_replaced: 2)\n"
"    \"a[],b[],c\"\n"
"\n"
"    iex> String.replace(\"a,b,c\", \",\", \"[]\", insert_replaced: [1, 1])\n"
"    \"a[,,]b[,,]c\"\n"
"\n"

#. TRANSLATORS: def String.upcase(binary)
#: lib/string.ex:401
msgid ""
"Converts all characters on the given string to uppercase.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.upcase(\"abcd\")\n"
"    \"ABCD\"\n"
"\n"
"    iex> String.upcase(\"ab 123 xpto\")\n"
"    \"AB 123 XPTO\"\n"
"\n"
"    iex> String.upcase(\"olá\")\n"
"    \"OLÁ\"\n"
"\n"
msgstr ""
"与えられた文字列の全ての文字を大文字に変換します。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.upcase(\"abcd\")\n"
"    \"ABCD\"\n"
"\n"
"    iex> String.upcase(\"ab 123 xpto\")\n"
"    \"AB 123 XPTO\"\n"
"\n"
"    iex> String.upcase(\"olá\")\n"
"    \"OLÁ\"\n"
"\n"

#. TRANSLATORS: def String.downcase(binary)
#: lib/string.ex:419
msgid ""
"Converts all characters on the given string to lowercase.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.downcase(\"ABCD\")\n"
"    \"abcd\"\n"
"\n"
"    iex> String.downcase(\"AB 123 XPTO\")\n"
"    \"ab 123 xpto\"\n"
"\n"
"    iex> String.downcase(\"OLÁ\")\n"
"    \"olá\"\n"
"\n"
msgstr ""
"与えられた文字列の全ての文字を小文字に変換します。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.downcase(\"ABCD\")\n"
"    \"abcd\"\n"
"\n"
"    iex> String.downcase(\"AB 123 XPTO\")\n"
"    \"ab 123 xpto\"\n"
"\n"
"    iex> String.downcase(\"OLÁ\")\n"
"    \"olá\"\n"
"\n"

#. TRANSLATORS: def String.to_existing_atom(string)
#: lib/string.ex:1383
msgid ""
"Converts a string to an existing atom.\n"
"\n"
"Currently Elixir does not support conversions from strings\n"
"which contains Unicode codepoints greater than 0xFF.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> :my_atom\n"
"    iex> String.to_existing_atom(\"my_atom\")\n"
"    :my_atom\n"
"\n"
"    iex> String.to_existing_atom(\"this_atom_will_never_exist\")\n"
"    ** (ArgumentError) argument error\n"
"\n"
msgstr ""
"文字列を存在するアトムに変換します。\n"
"\n"
"現在のElixirは、0xFFを越えるUnicodeコードポイントを含む\n"
"文字列からの変換をサポートしていません。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> :my_atom\n"
"    iex> String.to_existing_atom(\"my_atom\")\n"
"    :my_atom\n"
"\n"
"    iex> String.to_existing_atom(\"this_atom_will_never_exist\")\n"
"    ** (ArgumentError) argument error\n"
"\n"

#. TRANSLATORS: def String.to_atom(string)
#: lib/string.ex:1360
msgid ""
"Converts a string to an atom.\n"
"\n"
"Currently Elixir does not support conversions from strings\n"
"which contain Unicode codepoints greater than 0xFF.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.to_atom(\"my_atom\")\n"
"    :my_atom\n"
"\n"
msgstr ""
"文字列をアトムに変換します。\n"
"\n"
"現在のElixirは、0xFFを越えるUnicodeコードポイントを含む\n"
"文字列からの変換をサポートしていません。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.to_atom(\"my_atom\")\n"
"    :my_atom\n"
"\n"

#. TRANSLATORS: def String.to_char_list(string)
#: lib/string.ex:1332
msgid ""
"Converts a string into a char list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.to_char_list(\"æß\")\n"
"    'æß'\n"
"\n"
"Notice that this function expects a list of integers representing\n"
"UTF-8 codepoints. If you have a raw binary, you must instead use\n"
"[the `:binary` module](http://erlang.org/doc/man/binary.html).\n"
msgstr ""
"文字列を文字リストに変換します。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.to_char_list(\"æß\")\n"
"    'æß'\n"
"\n"
"この関数は、UTF-8コードポイントで表現される整数のリストを期待している\n"
"ことに、注意してください。もしrawバイナリをもっていたら、\n"
"[`:binary`モジュール](http://erlang.org/doc/man/binary.html)\n"
"を代りに使わなければなりません。\n"

#. TRANSLATORS: Elixir.String Summary
#: lib/string.ex:3
msgid ""
"A String in Elixir is a UTF-8 encoded binary.\n"
"\n"
"## Codepoints and graphemes\n"
"\n"
"The functions in this module act according to the Unicode\n"
"Standard, version 6.3.0. As per the standard, a codepoint is\n"
"an Unicode Character, which may be represented by one or more\n"
"bytes. For example, the character \"é\" is represented with two\n"
"bytes:\n"
"\n"
"    iex> byte_size(\"é\")\n"
"    2\n"
"\n"
"However, this module returns the proper length:\n"
"\n"
"    iex> String.length(\"é\")\n"
"    1\n"
"\n"
"Furthermore, this module also presents the concept of\n"
"graphemes, which are multiple characters that may be\n"
"\"perceived as a single character\" by readers. For example,\n"
"the same \"é\" character written above could be represented\n"
"by the letter \"e\" followed by the accent ́:\n"
"\n"
"    iex> string = \"\\x{0065}\\x{0301}\"\n"
"    iex> byte_size(string)\n"
"    3\n"
"    iex> String.length(string)\n"
"    1\n"
"\n"
"Although the example above is made of two characters, it is\n"
"perceived by users as one.\n"
"\n"
"Graphemes can also be two characters that are interpreted\n"
"as one by some languages. For example, some languages may\n"
"consider \"ch\" as a grapheme. However, since this information\n"
"depends on the locale, it is not taken into account by this\n"
"module.\n"
"\n"
"In general, the functions in this module rely on the Unicode\n"
"Standard, but do not contain any of the locale specific behaviour.\n"
"\n"
"More information about graphemes can be found in the [Unicode\n"
"Standard Annex #29](http://www.unicode.org/reports/tr29/).\n"
"This current Elixir version implements Extended Grapheme Cluster\n"
"algorithm.\n"
"\n"
"## String and binary operations\n"
"\n"
"To act accordingly to the Unicode Standard, many functions\n"
"in this module runs in linear time, as it needs to traverse\n"
"the whole string considering the proper Unicode codepoints.\n"
"\n"
"For example, `String.length/1` is going to take longer as\n"
"the input grows. On the other hand, `Kernel.byte_size/1` always runs\n"
"in constant time (i.e. regardless of the input size).\n"
"\n"
"This means often there are performance costs in using the\n"
"functions in this module, compared to the more low-level\n"
"operations that work directly with binaries:\n"
"\n"
"  * `Kernel.binary_part/3` - retrieves part of the binary\n"
"  * `Kernel.bit_size/1` and `Kernel.byte_size/1` - size related functions\n"
"  * `Kernel.is_bitstring/1` and `Kernel.is_binary/1` - type checking "
"function\n"
"  * Plus a number of functions for working with binaries (bytes)\n"
"    [in the `:binary` module](http://erlang.org/doc/man/binary.html)\n"
"\n"
"There are many situations where using the `String` module can\n"
"be avoided in favor of binary functions or pattern matching.\n"
"For example, imagine you have a string `prefix` and you want to\n"
"remove this prefix from another string named `full`.\n"
"\n"
"One may be tempted to write:\n"
"\n"
"    iex> take_prefix = fn full, prefix ->\n"
"    ...>   base = String.length(prefix)\n"
"    ...>   String.slice(full, base, String.length(full) - base)\n"
"    ...> end\n"
"    iex> take_prefix.(\"Mr. John\", \"Mr. \")\n"
"    \"John\"\n"
"\n"
"Although the function above works, it performs poorly. To\n"
"calculate the length of the string, we need to traverse it\n"
"fully, so we traverse both `prefix` and `full` strings, then\n"
"slice the `full` one, traversing it again.\n"
"\n"
"A first attempting at improving it could be with ranges:\n"
"\n"
"    iex> take_prefix = fn full, prefix ->\n"
"    ...>   base = String.length(prefix)\n"
"    ...>   String.slice(full, base..-1)\n"
"    ...> end\n"
"    iex> take_prefix.(\"Mr. John\", \"Mr. \")\n"
"    \"John\"\n"
"\n"
"While this is much better (we don't traverse `full` twice),\n"
"it could still be improved. In this case, since we want to\n"
"extract a substring from a string, we can use `byte_size/1`\n"
"and `binary_part/3` as there is no chance we will slice in\n"
"the middle of a codepoint made of more than one byte:\n"
"\n"
"    iex> take_prefix = fn full, prefix ->\n"
"    ...>   base = byte_size(prefix)\n"
"    ...>   binary_part(full, base, byte_size(full) - base)\n"
"    ...> end\n"
"    iex> take_prefix.(\"Mr. John\", \"Mr. \")\n"
"    \"John\"\n"
"\n"
"Or simply use pattern matching:\n"
"\n"
"    iex> take_prefix = fn full, prefix ->\n"
"    ...>   base = byte_size(prefix)\n"
"    ...>   <<_ :: binary-size(base), rest :: binary>> = full\n"
"    ...>   rest\n"
"    ...> end\n"
"    iex> take_prefix.(\"Mr. John\", \"Mr. \")\n"
"    \"John\"\n"
"\n"
"On the other hand, if you want to dynamically slice a string\n"
"based on an integer value, then using `String.slice/3` is the\n"
"best option as it guarantees we won't incorrectly split a valid\n"
"codepoint in multiple bytes.\n"
"\n"
"## Integer codepoints\n"
"\n"
"Although codepoints could be represented as integers, this\n"
"module represents all codepoints as strings. For example:\n"
"\n"
"    iex> String.codepoints(\"olá\")\n"
"    [\"o\", \"l\", \"á\"]\n"
"\n"
"There are a couple of ways to retrieve a character integer\n"
"codepoint. One may use the `?` construct:\n"
"\n"
"    iex> ?o\n"
"    111\n"
"\n"
"    iex> ?á\n"
"    225\n"
"\n"
"Or also via pattern matching:\n"
"\n"
"    iex> << eacute :: utf8 >> = \"á\"\n"
"    iex> eacute\n"
"    225\n"
"\n"
"As we have seen above, codepoints can be inserted into\n"
"a string by their hexadecimal code:\n"
"\n"
"    \"ol\\x{0061}\\x{0301}\" #=>\n"
"    \"olá\"\n"
"\n"
"## Self-synchronization\n"
"\n"
"The UTF-8 encoding is self-synchronizing. This means that\n"
"if malformed data (i.e., data that is not possible according\n"
"to the definition of the encoding) is encountered, only one\n"
"codepoint needs to be rejected.\n"
"\n"
"This module relies on this behaviour to ignore such invalid\n"
"characters. For example, `length/1` is going to return\n"
"a correct result even if an invalid codepoint is fed into it.\n"
"\n"
"In other words, this module expects invalid data to be detected\n"
"when retrieving data from the external source. For example, a\n"
"driver that reads strings from a database will be the one\n"
"responsible to check the validity of the encoding.\n"
msgstr ""
"Elixirでの文字列はUTF-8でエンコードされたバイナリです。\n"
"\n"
"## Codepoints and graphemes\n"
"\n"
"このモジュールの関数はUnicode標準 version 6.3.0に\n"
"準拠して動作します。\n"
"Unicode標準に従って、コードポイントはUnicode文字で、1つ以上の\n"
"バイトにより表現されます。例えば、文字 \\\"é\\\" は2バイトで\n"
"表現されます:\n"
"\n"
"    iex> byte_size(\\\"é\\\")\n"
"    2\n"
"\n"
"しかしながら、このモジュールは正しい長さを返します:\n"
"\n"
"    iex> String.length(\\\"é\\\")\n"
"    1\n"
"\n"
"さらにまた、このモジュールは書記素の概念も示します。それは\n"
"読者により、\\\"ひとつの文字として認められる\\\"\n"
"複数の文字です。\n"
"例えば、上で書かれた同じ \\\"é\\\" 文字は、アクセント  ́ が\n"
"続く、文字 \\\"e\\\" によっても表現できます:\n"
"\n"
"    iex> string = \\\"\\\\x{0065}\\\\x{0301}\\\"\n"
"    iex> byte_size(string)\n"
"    3\n"
"    iex> String.length(string)\n"
"    1\n"
"\n"
"上の例は二つの文字で作られているが、それは一体となって\n"
"ユーザにより認められます。\n"
"\n"
"書記素は、いくつかの言語によっては、一体となって解釈される\n"
"二つの文字でも有り得ます。例えば、いくつかの言語は、\n"
"\\\"ch\\\"を書記素として考えるかもしれません。\n"
"しかしながら、この情報がロケールに依存するので、このモジュール\n"
"では考慮されません。\n"
"\n"
"一般には、このモジュールの関数は、Unicode標準を\n"
"信頼しますが、ロケールに特有のいかなる振る舞いも含みません。\n"
"\n"
"書記素についての詳細情報は、[Unicode Standard Annex\n"
"#29](http://www.unicode.org/reports/tr29/)で見つかります。現在のElixir\n"
"のバージョンは拡張書記素クラスタ(Extended Grapheme Cluster algorithm)を\n"
"実装しています。\n"
"\n"
"## 文字列とバイナリの操作\n"
"\n"
"Unicode標準に準拠するために、このモジュールの多くの関数は、\n"
"適当なUnicodeコードポイントを考慮するのに、\n"
"文字列全体の取り出しが必要になる場合があるため、線形の時間が\n"
"かかります。\n"
"\n"
"例えば、`String.length/1`は、入力の増大に従って、時間が\n"
"かかります。一方、`byte_size/1`は常に定数時間で\n"
"動作します(即ち、入力の大きさを気にしません)。\n"
"\n"
"以下のような、より低レベルのバイナリを直接操作することと\n"
"比較して、このモジュールの関数を使うことに、パフォーマンス上の\n"
"コストがあることを、しばしば、意味します:\n"
"\n"
"  * `Kernel.binary_part/3` - バイナリの一部の取り出し\n"
"  * `Kernel.bit_size/1` と `Kernel.byte_size/1` - サイズ関連関数\n"
"  * `Kernel.is_bitstring/1` と `Kernel.is_binary/1` - タイプチェック関数\n"
"  * 加えて、\n"
"    バイナリ(バイト)で動作する[`:binary` モジュールにある]\n"
"    (http://erlang.org/doc/man/binary.html)、いくつかの関数\n"
"\n"
"バイナリ関数やパターンマッチングのほうを選んで、\n"
"`String`モジュールを使うことを避けられる、\n"
"多くのシチュエーションがあります。\n"
"例えば、文字列`prefix`を持っていて、`full`に名付けられたもう一つの\n"
"文字列からプレフィックスを削除したい場合があります。\n"
"\n"
"以下のように書きたくなるかもしれません:\n"
"\n"
"    iex> take_prefix = fn full, prefix ->\n"
"    ...>   base = String.length(prefix)\n"
"    ...>   String.slice(full, base, String.length(full) - base)\n"
"    ...> end\n"
"    iex> take_prefix.(\"Mr. John\", \"Mr. \")\n"
"    \"John\"\n"
"\n"
"上の関数は動作しますが、パフォーマンスは貧弱です。\n"
"文字列の長さを計算するために、全てをトラバースする必\n"
"要があり、`prefix`と`full`の文字列をどちらもトラバース\n"
"し、それから`full`を再びトラバースしてスライスします。\n"
"\n"
"良くするための最初の試みは、範囲(range)を使うことです:\n"
"\n"
"    iex> take_prefix = fn full, prefix ->\n"
"    ...>   base = String.length(prefix)\n"
"    ...>   String.slice(full, base..-1)\n"
"    ...> end\n"
"    iex> take_prefix.(\"Mr. John\", \"Mr. \")\n"
"    \"John\"\n"
"\n"
"これはより良いです(`full`を二度トラバースしません)が、\n"
"まだ良くできます。この場合、\n"
"文字列から部分文字列を抽出したいので、複数のバイトから\n"
"なるコードポイントの中央でスライスする危険性がないので、\n"
"`byte_size/1`と`binary_patr/3`を使うことができます:\n"
"\n"
"    iex> take_prefix = fn full, prefix ->\n"
"    ...>   base = byte_size(prefix)\n"
"    ...>   binary_part(full, base, byte_size(full) - base)\n"
"    ...> end\n"
"    iex> take_prefix.(\"Mr. John\", \"Mr. \")\n"
"    \"John\"\n"
"\n"
"または単にパターンマッチングを使えます:\n"
"\n"
"    iex> take_prefix = fn full, prefix ->\n"
"    ...>   base = byte_size(prefix)\n"
"    ...>   <<_ :: binary-size(base), rest :: binary>> = full\n"
"    ...>   rest\n"
"    ...> end\n"
"    iex> take_prefix.(\"Mr. John\", \"Mr. \")\n"
"    \"John\"\n"
"\n"
"一方、整数値により文字列を動的にスライスしたいなら、\n"
"複数バイトでの有効なコードポイントを、誤ってに分割しない\n"
"ように保証するために、`String.slice/3`がベストの選択肢です。\n"
"\n"
"## Integer codepoints\n"
"\n"
"コードポイントは整数として表現されることが出来ますが、\n"
"このモジュールは、全てのコードポイントを文字列として\n"
"表現します。例えば:\n"
"\n"
"    iex> String.codepoints(\\\"olá\\\")\n"
"    [\\\"o\\\", \\\"l\\\", \\\"á\\\"]\n"
"   \n"
"文字の整数のコードポイントを取り出す方法はいくつかあります。一つは\n"
"`?`文法構造を使う方法です:\n"
"\n"
"    iex> ?o\n"
"    111\n"
"\n"
"    iex> ?á\n"
"    225\n"
"\n"
"あるいは、パターンマッチングによる方法もあります:\n"
"\n"
"    iex> << eacute :: utf8 >> = \\\"á\\\"\n"
"    iex> eacute\n"
"    225\n"
"\n"
"上で見たように、コードポイントは16進コードにより文字列に\n"
"挿入することができます:\n"
"\n"
"    \\\"ol\\\\x{0061}\\\\x{0301}\\\" #=>\n"
"    \\\"olá\\\"\n"
"\n"
"## Self-synchronization\\n\"\n"
"\n"
"UTF-8エンコーディングは自己同期しています。これは、不正な形式のデータ\n"
"(即ち、エンコーディングの定義によって可能でないデータ)が遭遇したなら、\n"
"そのコードポイントだけが拒否される必要があるだけということを、意味して\n"
"います。\n"
"\n"
"このモジュールは、そのような無効な文字を無視するために\n"
"この振る舞いに頼ります。例えば、例え無効なコードポイントが\n"
"それに入れられていても、`length/1`は正しい結果を返すでしょう。\n"
"\n"
"言い替えると、外部ソースからデータを取り出すとき、無効な\n"
"データが見つけられることを、このモジュールは予想します。\n"
"例えば、データベースから文字列を読み出すドライバは\"\n"
"エンコーディングの有効性をチェックする責任があります。\n"
