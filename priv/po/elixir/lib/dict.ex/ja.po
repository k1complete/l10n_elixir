msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2015-09-25 23:49+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: def Dict.update(dict, key, initial, fun)
#: lib/dict.ex:733
msgid ""
"Updates a value in `dict` by calling `fun` on the value to get a new value. "
"If\n"
"`key` is not present in `dict` then `initial` will be stored as the first\n"
"value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.update(dict, :c, 3, fn(val) -> -val end)\n"
"    iex> Dict.get(dict, :c)\n"
"    3\n"
"\n"
msgstr ""
"値から新しい値を取得する`fun`を呼ぶことによって`dict`の値を更新します。\n"
"もし`key`が`dict`に表れなかったら`initial`が最初の値として格納されるで\n"
"しょう。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.update(dict, :c, 3, fn(val) -> -val end)\n"
"    iex> Dict.get(dict, :c)\n"
"    3\n"
"\n"

#. TRANSLATORS: def Dict.update!(dict, key, fun)
#: lib/dict.ex:716
msgid ""
"Updates a value in `dict` by calling `fun` on the value to get a new\n"
"value. An exception is generated if `key` is not present in the dict.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.update!(dict, :a, fn(val) -> -val end)\n"
"    iex> Dict.get(dict, :a)\n"
"    -1\n"
"\n"
msgstr ""
"値から新しい値を取得する`fun`を呼ぶことによって`dict`の値を更新します。\n"
"もし`key`が`dict`に表れなかったら例外が生成されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.update!(dict, :a, fn(val) -> -val end)\n"
"    iex> Dict.get(dict, :a)\n"
"    -1\n"
"\n"

#. TRANSLATORS: def Dict.size(dict)
#: lib/dict.ex:360
msgid ""
"Returns the number of elements in `dict`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> Dict.size(dict)\n"
"    2\n"
"\n"
msgstr ""
"`dict`の要素の数を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> Dict.size(dict)\n"
"    2\n"
"\n"

#. TRANSLATORS: Elixir.Dict Summary
#: lib/dict.ex:2
msgid ""
"This module specifies the Dict API expected to be\n"
"implemented by different dictionaries.\n"
"\n"
"It also provides functions that redirect to the underlying\n"
"Dict, allowing a developer to work with different Dict\n"
"implementations using one API.\n"
"\n"
"To create a new dict, use the `new` functions defined\n"
"by each dict type:\n"
"\n"
"    HashDict.new  #=> creates an empty HashDict\n"
"\n"
"In the examples below, `dict_impl` means a specific\n"
"`Dict` implementation, for example `HashDict` or `Map`.\n"
"\n"
"## Warning\n"
"\n"
"Do not use this module if you expect a certain `Dict`\n"
"implementation. For example, if you are working with\n"
"maps and you don't need polymorphism, it is preferrable\n"
"to use the `Map` module instead of the `Dict` one.\n"
"\n"
"## Protocols\n"
"\n"
"Besides implementing the functions in this module, all\n"
"dictionaries are required to implement the `Access`\n"
"protocol:\n"
"\n"
"    iex> dict = dict_impl.new\n"
"    iex> dict = Dict.put(dict, :hello, :world)\n"
"    iex> dict[:hello]\n"
"    :world\n"
"\n"
"As well as the `Enumerable` and `Collectable` protocols.\n"
"\n"
"## Match\n"
"\n"
"Dictionaries are required to implement all operations\n"
"using the match (`===`) operator.\n"
"\n"
"## Default implementation\n"
"\n"
"Default implementations for some functions in the `Dict` module\n"
"are provided via `use Dict`.\n"
"\n"
"For example:\n"
"\n"
"    defmodule MyDict do\n"
"      use Dict\n"
"\n"
"      # implement required functions (see below)\n"
"      # override default implementations if optimization\n"
"      # is needed\n"
"    end\n"
"\n"
"The client module must contain the following functions:\n"
"\n"
"  * `delete/2`\n"
"  * `fetch/2`\n"
"  * `put/3`\n"
"  * `reduce/3`\n"
"  * `size/1`\n"
"\n"
"All functions, except `reduce/3`, are required by the Dict behaviour.\n"
"`reduce/3` must be implemented as per the Enumerable protocol.\n"
"\n"
"Based on these functions, `Dict` generates default implementations\n"
"for the following functions:\n"
"\n"
"  * `drop/2`\n"
"  * `equal?/2`\n"
"  * `fetch!/2`\n"
"  * `get/2`\n"
"  * `get/3`\n"
"  * `get_lazy/3`\n"
"  * `get_and_update/3`\n"
"  * `has_key?/2`\n"
"  * `keys/1`\n"
"  * `merge/2`\n"
"  * `merge/3`\n"
"  * `pop/2`\n"
"  * `pop/3`\n"
"  * `pop_lazy/3`\n"
"  * `put_new/3`\n"
"  * `put_new_lazy/3`\n"
"  * `split/2`\n"
"  * `take/2`\n"
"  * `to_list/1`\n"
"  * `update/4`\n"
"  * `update!/3`\n"
"  * `values/1`\n"
"\n"
"All of these functions are defined as overridable, so you can provide\n"
"your own implementation if needed.\n"
"\n"
"Note you can also test your custom module via `Dict`'s doctests:\n"
"\n"
"    defmodule MyDict do\n"
"      # ...\n"
"    end\n"
"\n"
"    defmodule MyTests do\n"
"      use ExUnit.Case\n"
"      doctest Dict\n"
"      defp dict_impl, do: MyDict\n"
"    end\n"
"\n"
msgstr ""
"このモジュールは異った辞書による実装に期待されるべき、Dict API仕様を\n"
"指定します。\n"
"\n"
"一つのAPIを使って異るDictの実装で開発者が仕事をすることを許す、基礎をな\n"
"すDictへリダイレクトする関数も提供します。\n"
"\n"
"新しいDictを作成するために、それぞれのDictのタイプ毎に定義された`new`関\n"
"数を使います:\n"
"\n"
"    HashDict.new  #=> creates an empty HashDict\n"
"\n"
"下の例では、`dict_impl`は特定の`Dict`実装、例えば`HashDict` または\n"
"`Map`を意味します。\n"
"\n"
"## Warning\n"
"\n"
"特定の`Dict`実装を期待しているなら、このモジュールを使わない\n"
"でください。例えば、もしmapで作業していて、ポリモーフィズムを\n"
"必要としない場合、`Dict`にかわって`Map`モジュールを使うことが\n"
"好ましいでしょう。\n"
"\n"
"## プロトコル\n"
"\n"
"このモジュールで実装している関数の他に、全ての辞書は\n"
"`Access`プロトコルを実装することが要求されます:\n"
"\n"
"    iex> dict = dict_impl.new\n"
"    iex> dict = Dict.put(dict, :hello, :world)\n"
"    iex> dict[:hello]\n"
"    :world\n"
"\n"
"`Enumerable`と`Collectable`プロトコルの実装も同様です。\n"
"\n"
"## マッチ\n"
"\n"
"Dictは実装をマッチオペレータ(`===`)を使う全ての操作の実装を\n"
"要求します。\n"
"\n"
"## デフォルトの実装\n"
"\n"
"`Dict`モジュールの幾つかの関数でのデフォルトの実装は`use Dict`により\n"
"提供されます。\n"
"\n"
"例えば:\n"
"\n"
"    defmodule MyDict do\n"
"      use Dict\n"
"\n"
"      # 要求された関数(下記参照)の実装をします\n"
"      # 最適化が必要ならデフォルトの実装を\n"
"      # オーバーライドします\n"
"    end\n"
"\n"
"クライアントモジュールは以下の関数を含んでいなければなりません:\n"
"\n"
"  * `delete/2`\n"
"  * `fetch/2`\n"
"  * `put/3`\n"
"  * `reduce/3`\n"
"  * `size/1`\n"
"\n"
"`reduce/3`を除く全ての関数はDictビヘイビアにより要求されます。\n"
"`reduce/3`はEnumerableプロトコルにより実装されなければなりません。\n"
"\n"
"これらの関数の基いて、`Dict`は以下の関数のデフォルトの実装を生成します:\n"
"\n"
"  * `drop/2`\n"
"  * `equal?/2`\n"
"  * `fetch!/2`\n"
"  * `get/2`\n"
"  * `get/3`\n"
"  * `has_key?/2`\n"
"  * `keys/1`\n"
"  * `merge/2`\n"
"  * `merge/3`\n"
"  * `pop/2`\n"
"  * `pop/3`\n"
"  * `put_new/3`\n"
"  * `split/2`\n"
"  * `take/2`\n"
"  * `to_list/1`\n"
"  * `update/4`\n"
"  * `update!/3`\n"
"  * `values/1`\n"
"\n"
"これらの関数の全てはオーバーライド可能に定義されていますので、\n"
"必要に応じて自分で実装を提供することができます。\n"
"\n"
"`Dict`のdoctestによりカスタムモジュールをテストすることもできる\n"
"ことに注意してください:\n"
"\n"
"    defmodule MyDict do\n"
"      # ...\n"
"    end\n"
"\n"
"    defmodule MyTests do\n"
"      use ExUnit.Case\n"
"      doctest Dict\n"
"      defp dict_impl, do: MyDict\n"
"    end\n"
"\n"

#. TRANSLATORS: def Dict.put(dict, key, val)
#: lib/dict.ex:498
msgid ""
"Stores the given `value` under `key` in `dict`.\n"
"If `dict` already has `key`, the stored value is replaced by the new one.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.put(dict, :a, 3)\n"
"    iex> Dict.get(dict, :a)\n"
"    3\n"
"\n"
msgstr ""
"与えられた`value`と`key`を`dict`に保存します。\n"
"もし`dict`が既に`key`を持っていたら、新しい値により置き換えられます。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.put(dict, :a, 3)\n"
"    iex> Dict.get(dict, :a)\n"
"    3\n"
"\n"

#. TRANSLATORS: def Dict.has_key?(dict, key)
#: lib/dict.ex:375
msgid ""
"Returns whether the given `key` exists in the given `dict`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> Dict.has_key?(dict, :a)\n"
"    true\n"
"    iex> Dict.has_key?(dict, :b)\n"
"    false\n"
"\n"
msgstr ""
"与えられた`key`が`dict`に存在するかを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> Dict.has_key?(dict, :a)\n"
"    true\n"
"    iex> Dict.has_key?(dict, :b)\n"
"    false\n"
"\n"

#. TRANSLATORS: def Dict.get(dict, key, default \\ nil)
#: lib/dict.ex:392
msgid ""
"Returns the value associated with `key` in `dict`. If `dict` does not\n"
"contain `key`, returns `default` (or `nil` if not provided).\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> Dict.get(dict, :a)\n"
"    1\n"
"    iex> Dict.get(dict, :b)\n"
"    nil\n"
"    iex> Dict.get(dict, :b, 3)\n"
"    3\n"
msgstr ""
"`dict`の`key`に関連付けられた値を返します。もし`dict`が`key`を含んでい\n"
"ない場合、`default`(それも提供されていない場合は`nil`)を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> Dict.get(dict, :a)\n"
"    1\n"
"    iex> Dict.get(dict, :b)\n"
"    nil\n"
"    iex> Dict.get(dict, :b, 3)\n"
"    3\n"

#. TRANSLATORS: def Dict.fetch!(dict, key)
#: lib/dict.ex:482
msgid ""
"Returns the value associated with `key` in `dict`. If `dict` does not\n"
"contain `key`, it raises `KeyError`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> Dict.fetch!(dict, :a)\n"
"    1\n"
"\n"
msgstr ""
"`dict`中の`key`に関連した値を返します。もし`dict`が`key`を含んでいない\n"
"場合、`KeyError`を上げます。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> Dict.fetch!(dict, :a)\n"
"    1\n"
"\n"

#. TRANSLATORS: def Dict.get_lazy(dict, key, fun)
#: lib/dict.ex:411
msgid ""
"Returns the value associated with `key` in `dict`. If `dict` does not\n"
"contain `key`, it lazily evaluates `fun` and returns its result.\n"
"\n"
"This is useful if the default value is very expensive to calculate or\n"
"generally difficult to set-up and tear-down again.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> fun = fn ->\n"
"    ...>   # some expensive operation here\n"
"    ...>   :result\n"
"    ...> end\n"
"    iex> Dict.get_lazy(dict, :a, fun)\n"
"    1\n"
"    iex> Dict.get_lazy(dict, :b, fun)\n"
"    :result\n"
"\n"
msgstr ""
"`dict`の`key`に関連付けられた値を返します。もし`dict`が`key`を含んでい\n"
"ない場合、`fun`が評価され、その結果を返します。\n"
"\n"
"これはデフォルト値の計算をするのに、非常にコストがかかる、あるいは、\n"
"set-upとtear-downをするのが困難な場合に便利です。\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> fun = fn ->\n"
"    ...>   # some expensive operation here\n"
"    ...>   :result\n"
"    ...> end\n"
"    iex> Dict.get_lazy(dict, :a, fun)\n"
"    1\n"
"    iex> Dict.get_lazy(dict, :b, fun)\n"
"    :result\n"
"\n"

#. TRANSLATORS: def Dict.pop(dict, key, default \\ nil)
#: lib/dict.ex:649
msgid ""
"Returns the value associated with `key` in `dict` as\n"
"well as the `dict` without `key`.\n"
"\n"
"If `key` is not present in `dict`, then the `dict` will\n"
"be returned unmodified.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> {v, dict} = Dict.pop dict, :a\n"
"    iex> {v, Enum.sort(dict)}\n"
"    {1, []}\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> {v, dict} = Dict.pop dict, :b\n"
"    iex> {v, Enum.sort(dict)}\n"
"    {nil, [a: 1]}\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> {v, dict} = Dict.pop dict, :b, 3\n"
"    iex> {v, Enum.sort(dict)}\n"
"    {3, [a: 1]}\n"
"\n"
msgstr ""
"`dict`の中の`key`に関連した値と`key`を取り除いた`dict`を返します。\n"
"\n"
"`key`が`dict`に無いなら、`dict`は変更されずに返されます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> {v, dict} = Dict.pop dict, :a\n"
"    iex> {v, Enum.sort(dict)}\n"
"    {1, []}\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> {v, dict} = Dict.pop dict, :b\n"
"    iex> {v, Enum.sort(dict)}\n"
"    {nil, [a: 1]}\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> {v, dict} = Dict.pop dict, :b, 3\n"
"    iex> {v, Enum.sort(dict)}\n"
"    {3, [a: 1]}\n"
"\n"

#. TRANSLATORS: def Dict.pop_lazy(dict, key, fun)
#: lib/dict.ex:679
msgid ""
"Returns the value associated with `key` in `dict` as\n"
"well as the `dict` without `key`.\n"
"\n"
"If `key` is not present in `dict`, then the `dict` will\n"
"be returned unmodified, and it will lazily evaluate `fun`\n"
"and return its result instead of the missing value.\n"
"\n"
"This is useful if the default value is very expensive to calculate or\n"
"generally difficult to set-up and tear-down again.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> fun = fn ->\n"
"    ...>   # some expensive operation here\n"
"    ...>   :result\n"
"    ...> end\n"
"    iex> {v, dict} = Dict.pop_lazy dict, :a, fun\n"
"    iex> {v, Enum.sort(dict)}\n"
"    {1, []}\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> fun = fn ->\n"
"    ...>   # some expensive operation here\n"
"    ...>   :result\n"
"    ...> end\n"
"    iex> {v, dict} = Dict.pop_lazy dict, :b, fun\n"
"    iex> {v, Enum.sort(dict)}\n"
"    {:result, [a: 1]}\n"
"\n"
msgstr ""
"`dict`の中の`key`に関連した値と`key`を取り除いた`dict`を返します。\n"
"\n"
"`key`が`dict`に無いなら、`dict`は変更されずに返され、\n"
"かわりに`fun`が評価されその戻値が返されます。\n"
"\n"
"これはデフォルト値の計算をするのに、非常にコストがかかる、あるいは、\n"
"set-upとtear-downをするのが困難な場合に便利です。\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> fun = fn ->\n"
"    ...>   # some expensive operation here\n"
"    ...>   :result\n"
"    ...> end\n"
"    iex> {v, dict} = Dict.pop_lazy dict, :a, fun\n"
"    iex> {v, Enum.sort(dict)}\n"
"    {1, []}\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> fun = fn ->\n"
"    ...>   # some expensive operation here\n"
"    ...>   :result\n"
"    ...> end\n"
"    iex> {v, dict} = Dict.pop_lazy dict, :b, fun\n"
"    iex> {v, Enum.sort(dict)}\n"
"    {:result, [a: 1]}\n"
"\n"

#. TRANSLATORS: def Dict.delete(dict, key)
#: lib/dict.ex:558
msgid ""
"Removes the entry stored under the given `key` from `dict`.\n"
"If `dict` does not contain `key`, returns the dictionary unchanged.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.delete(dict, :a)\n"
"    iex> Dict.get(dict, :a)\n"
"    nil\n"
"\n"
"    iex> dict = Enum.into([b: 2], dict_impl.new)\n"
"    iex> Dict.delete(dict, :a) == dict\n"
"    true\n"
"\n"
msgstr ""
"`dict`から与えられた`key`でストアされたエントリを取り除きます。\n"
"`dict`が`key`を含んでいないなら、返される辞書は変更されていません。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.delete(dict, :a)\n"
"    iex> Dict.get(dict, :a)\n"
"    nil\n"
"\n"
"    iex> dict = Enum.into([b: 2], dict_impl.new)\n"
"    iex> Dict.delete(dict, :a) == dict\n"
"    true\n"
"\n"

#. TRANSLATORS: def Dict.to_list(dict)
#: lib/dict.ex:872
msgid ""
"Returns a list of key-value pairs stored in `dict`.\n"
"No particular order is enforced.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = dict_impl.new\n"
"    iex> dict = Dict.put(dict, :a, 1)\n"
"    iex> Dict.to_list(dict)\n"
"    [a: 1]\n"
msgstr ""
"`dict`に保存されているキーバリューペアのリストを返します。\n"
"特定の順序に整列はされません。\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = dict_impl.new\n"
"    iex> dict = Dict.put(dict, :a, 1)\n"
"    iex> Dict.to_list(dict)\n"
"    [a: 1]\n"

#. TRANSLATORS: def Dict.values(dict)
#: lib/dict.ex:344
msgid ""
"Returns a list of all values in `dict`.\n"
"The values are not guaranteed to be in any order.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> Enum.sort(Dict.values(dict))\n"
"    [1, 2]\n"
"\n"
msgstr ""
"`dict`の全ての値のリストを返します。\n"
"値の整列は保証されません。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> Enum.sort(Dict.values(dict))\n"
"    [1,2]\n"
"\n"

#. TRANSLATORS: def Dict.keys(dict)
#: lib/dict.ex:328
msgid ""
"Returns a list of all keys in `dict`.\n"
"The keys are not guaranteed to be in any order.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> Enum.sort(Dict.keys(dict))\n"
"    [:a, :b]\n"
"\n"
msgstr ""
"`dict`の全てのキーのリストを返します。\n"
"キーの整列は保証されません。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> Enum.sort(Dict.keys(dict))\n"
"    [:a,:b]\n"
"\n"

#. TRANSLATORS: def Dict.fetch(dict, key)
#: lib/dict.ex:464
msgid ""
"Returns `{:ok, value}` associated with `key` in `dict`.\n"
"If `dict` does not contain `key`, returns `:error`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> Dict.fetch(dict, :a)\n"
"    {:ok, 1}\n"
"    iex> Dict.fetch(dict, :b)\n"
"    :error\n"
"\n"
msgstr ""
"`dict`中の`key`に関連した値をvalueとして、`{:ok, value}`を返します。\n"
"もし`dict`が`key`含んでいなかったら、`:error`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> Dict.fetch(dict, :a)\n"
"    {:ok, 1}\n"
"    iex> Dict.fetch(dict, :b)\n"
"    :error\n"
"\n"

#. TRANSLATORS: def Dict.drop(dict, keys)
#: lib/dict.ex:781
msgid ""
"Returns a new dict where the given `keys` are removed from `dict`.\n"
"All non-member keys are ignored.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.drop(dict, [:a, :c, :d])\n"
"    iex> Dict.to_list(dict)\n"
"    [b: 2]\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.drop(dict, [:c, :d])\n"
"    iex> Dict.to_list(dict) |> Enum.sort\n"
"    [a: 1, b: 2]\n"
"\n"
msgstr ""
"与えられた`keys`を`dict`から取り除いた新しいdictを返します。\n"
"メンバーでないキーは全て無視されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.drop(dict, [:a, :c, :d])\n"
"    iex> Dict.to_list(dict)\n"
"    [b: 2]\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.drop(dict, [:c, :d])\n"
"    iex> Dict.to_list(dict) |> Enum.sort\n"
"    [a: 1, b: 2]\n"
"\n"

#. TRANSLATORS: def Dict.take(dict, keys)
#: lib/dict.ex:803
msgid ""
"Returns a new dict where only the keys in `keys` from `dict` are included.\n"
"\n"
"All non-member keys are ignored.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.take(dict, [:a, :c, :d])\n"
"    iex> Dict.to_list(dict)\n"
"    [a: 1]\n"
"    iex> dict = Dict.take(dict, [:c, :d])\n"
"    iex> Dict.to_list(dict)\n"
"    []\n"
"\n"
msgstr ""
"`dict`から`keys`だけを含む新しいdictを作成して返します。\n"
"\n"
"メンバーでないキーは全て無視されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.take(dict, [:a, :c, :d])\n"
"    iex> Dict.to_list(dict)\n"
"    [a: 1]\n"
"    iex> dict = Dict.take(dict, [:c, :d])\n"
"    iex> Dict.to_list(dict)\n"
"    []\n"
"\n"

#. TRANSLATORS: def Dict.split(dict, keys)
#: lib/dict.ex:751
msgid ""
"Returns a tuple of two dicts, where the first dict contains only\n"
"entries from `dict` with keys in `keys`, and the second dict\n"
"contains only entries from `dict` with keys not in `keys`.\n"
"\n"
"All non-member keys are ignored.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2, c: 3, d: 4], dict_impl.new)\n"
"    iex> {dict1, dict2} = Dict.split(dict, [:a, :c, :e])\n"
"    iex> {Dict.to_list(dict1) |> Enum.sort, Dict.to_list(dict2) |> Enum."
"sort}\n"
"    {[a: 1, c: 3], [b: 2, d: 4]}\n"
"\n"
"    iex> dict = Enum.into([], dict_impl.new)\n"
"    iex> {dict1, dict2} = Dict.split(dict, [:a, :c])\n"
"    iex> {Dict.to_list(dict1), Dict.to_list(dict2)}\n"
"    {[], []}\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> {dict1, dict2} = Dict.split(dict, [:a, :b, :c])\n"
"    iex> {Dict.to_list(dict1) |> Enum.sort, Dict.to_list(dict2)}\n"
"    {[a: 1, b: 2], []}\n"
"\n"
msgstr ""
"二つのdictのタプルを返します。最初のdictは`dict`からキーのリスト\n"
"`keys`を含むエントリだけのdictで、二つめのdictは`dict`からキーのリスト\n"
"`keys`を含まないエントリのだけのdictです。\n"
"\n"
"メンバーでないkeysは全て無視されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2, c: 3, d: 4], dict_impl.new)\n"
"    iex> {dict1, dict2} = Dict.split(dict, [:a, :c, :e])\n"
"    iex> {Dict.to_list(dict1) |> Enum.sort, Dict.to_list(dict2) |> Enum."
"sort}\n"
"    {[a: 1, c: 3], [b: 2, d: 4]}\n"
"\n"
"    iex> dict = Enum.into([], dict_impl.new)\n"
"    iex> {dict1, dict2} = Dict.split(dict, [:a, :c])\n"
"    iex> {Dict.to_list(dict1), Dict.to_list(dict2)}\n"
"    {[], []}\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> {dict1, dict2} = Dict.split(dict, [:a, :b, :c])\n"
"    iex> {Dict.to_list(dict1) |> Enum.sort, Dict.to_list(dict2)}\n"
"    {[a: 1, b: 2], []}\n"
"\n"

#. TRANSLATORS: def Dict.put_new(dict, key, val)
#: lib/dict.ex:515
msgid ""
"Puts the given `value` under `key` in `dict` unless `key` is already "
"present.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.put_new(dict, :a, 3)\n"
"    iex> Dict.get(dict, :a)\n"
"    1\n"
"\n"
msgstr ""
"既に`key`のエントリが存在しないかぎり、与えられた`value`を`key`の\n"
"下で`dict`にプットします。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.put_new(dict, :a, 3)\n"
"    iex> Dict.get(dict, :a)\n"
"    1\n"
"\n"

#. TRANSLATORS: def Dict.merge(dict1, dict2, fun)
#: lib/dict.ex:610
msgid ""
"Merges the dict `dict2` into dict `dict1`.\n"
"\n"
"If one of the `dict2` entries is found in `dict1`, the function\n"
"will be invoked to resolve the conflict.\n"
"\n"
"Notice this function is polymorphic as it merges dicts of any\n"
"type. Each dict implementation also provides a `merge` function,\n"
"but they can only merge dicts of the same type.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict1 = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict2 = Enum.into([a: 3, d: 4], dict_impl.new)\n"
"    iex> dict = Dict.merge(dict1, dict2, fn(_k, v1, v2) ->\n"
"    ...>   v1 + v2\n"
"    ...> end)\n"
"    iex> [a: Dict.get(dict, :a), b: Dict.get(dict, :b), d: Dict.get(dict, :"
"d)]\n"
"    [a: 4, b: 2, d: 4]\n"
"\n"
msgstr ""
"dict`dicdt2`をdict`dict1`にマージします。\n"
"\n"
"もし、`dict2`のエントリの一つが既に`dict1`に存在したら、\n"
"衝突を解決するために関数が起動されます。\n"
"\n"
"任意のタイプのdictをマージするので、この関数はポリモーフィック(多態的)\n"
"であることに注意してください。\n"
"それぞれのdict実装も、`merge`関数を提供しますが、それらは同じタイプの\n"
"dict同士のマージが出来るだけです。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict1 = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict2 = Enum.into([a: 3, d: 4], dict_impl.new)\n"
"    iex> dict = Dict.merge(dict1, dict2, fn(_k, v1, v2) ->\n"
"    ...>   v1 + v2\n"
"    ...> end)\n"
"    iex> [a: Dict.get(dict, :a), b: Dict.get(dict, :b), d: Dict.get(dict, :"
"d)]\n"
"    [a: 4, b: 2, d: 4]\n"
"\n"

#. TRANSLATORS: def Dict.merge(dict1, dict2)
#: lib/dict.ex:579
msgid ""
"Merges the dict `dict2` into dict `dict1`.\n"
"\n"
"If one of the `dict2` entries is found in `dict1`, the\n"
"conflicting entries in `dict2` have higher precedence.\n"
"\n"
"Notice this function is polymorphic as it merges dicts of any\n"
"type. Each dict implementation also provides a `merge` function,\n"
"but they can only merge dicts of the same type.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict1 = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict2 = Enum.into([a: 3, d: 4], dict_impl.new)\n"
"    iex> dict = Dict.merge(dict1, dict2)\n"
"    iex> [a: Dict.get(dict, :a), b: Dict.get(dict, :b), d: Dict.get(dict, :"
"d)]\n"
"    [a: 3, b: 2, d: 4]\n"
"\n"
msgstr ""
"dict`dicdt2`をdict`dict1`にマージします。\n"
"\n"
"もし、`dict2`のエントリの一つが既に`dict1`に存在したら、\n"
"衝突を解決するための関数が与えられていないかぎり、\n"
"`dict2`のエントリがより高い優先順位を持ちます。\n"
"\n"
"任意のタイプのdictをマージするので、この関数はポリモーフィック(多態的)\n"
"であることに注意してください。\n"
"それぞれのdict実装も、`merge`関数を提供しますが、それらは同じタイプの\n"
"dict同士のマージが出来るだけです。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict1 = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict2 = Enum.into([a: 3, d: 4], dict_impl.new)\n"
"    iex> dict = Dict.merge(dict1, dict2)\n"
"    iex> [a: Dict.get(dict, :a), b: Dict.get(dict, :b), d: Dict.get(dict, :"
"d)]\n"
"    [a: 3, b: 2, d: 4]\n"
"\n"

#. TRANSLATORS: def Dict.put_new_lazy(dict, key, fun)
#: lib/dict.ex:531
msgid ""
"Evaluates `fun` and puts the result under `key` in `dict` unless `key`\n"
"is already present.\n"
"\n"
"This is useful if the value is very expensive to calculate or generally\n"
"difficult to set-up and tear-down again.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> fun = fn ->\n"
"    ...>   # some expensive operation here\n"
"    ...>   3\n"
"    ...> end\n"
"    iex> dict = Dict.put_new_lazy(dict, :a, fun)\n"
"    iex> Dict.get(dict, :a)\n"
"    1\n"
"    iex> dict = Dict.put_new_lazy(dict, :c, fun)\n"
"    iex> Dict.get(dict, :c)\n"
"    3\n"
"\n"
msgstr ""
"`key`が既に存在しない限り、`fun`を評価してその結果を`key`の値と\n"
"して`dict`にプットします。\n"
"\n"
"これは値の計算をするのに、非常にコストがかかる、あるいは、\n"
"set-upとtear-downをするのが困難な場合に便利です。\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> fun = fn ->\n"
"    ...>   # some expensive operation here\n"
"    ...>   3\n"
"    ...> end\n"
"    iex> dict = Dict.put_new_lazy(dict, :a, fun)\n"
"    iex> Dict.get(dict, :a)\n"
"    1\n"
"    iex> dict = Dict.put_new_lazy(dict, :c, fun)\n"
"    iex> Dict.get(dict, :c)\n"
"    3\n"
"\n"

#. TRANSLATORS: def Dict.get_and_update(dict, key, fun)
#: lib/dict.ex:436
msgid ""
"Gets a value from `dict` and updates the value at `key` in one pass.\n"
"\n"
"This `fun` argument receives the value of `key` in `dict` (or `nil` if "
"`key`\n"
"is not present) and must return a two-elements tuple: the \"get\" value "
"(the\n"
"value retrieved from the dict which can be operated on before being "
"returned)\n"
"and the new value to be stored under `key` in `dict`.\n"
"\n"
"The returned value is a tuple with the \"get\" value returned by `fun` and a "
"new\n"
"dict with the updated value under `key`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> {get, new_dict} = Dict.get_and_update dict, :a, fn(current_value) -"
">\n"
"    ...>   {current_value + 1, \"foo\"}\n"
"    ...> end\n"
"    iex> get\n"
"    2\n"
"    iex> Dict.get(new_dict, :a)\n"
"    \"foo\"\n"
"\n"
msgstr ""
"一回のパスで`dict`から値を取得し、`key`の値を更新します。\n"
"\n"
"`fun`引数は`dict`中の`key`の値(`key`が存在しない場合は`nil`)を受取り、\n"
"2要素のタプルを返します: (dictから取得して何らかの操作をした)\"get\"した値"
"と、\n"
"`dict`に格納される`key`に対する新しい値からなるタプルです。\n"
"\n"
"戻値は、`fun`から戻された\"get\"値と`key`の下で更新された\n"
"新しいdictからなるタプルです。\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> {get, new_dict} = Dict.get_and_update dict, :a, fn(current_value) -"
">\n"
"    ...>   {current_value + 1, \"foo\"}\n"
"    ...> end\n"
"    iex> get\n"
"    2\n"
"    iex> Dict.get(new_dict, :a)\n"
"    \"foo\"\n"
"\n"

#. TRANSLATORS: def Dict.equal?(dict1, dict2)
#: lib/dict.ex:830
msgid ""
"Checks if two dicts are equal using `===`.\n"
"\n"
"Notice this function is polymorphic as it compares dicts of any\n"
"type. Each dict implementation also provides an `equal?` function,\n"
"but they can only compare dicts of the same type.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict1 = Enum.into([a: 2, b: 3, f: 5, c: 123], dict_impl.new)\n"
"    iex> dict2 = [a: 2, b: 3, f: 5, c: 123]\n"
"    iex> Dict.equal?(dict1, dict2)\n"
"    true\n"
"\n"
"    iex> dict1 = Enum.into([a: 2, b: 3, f: 5, c: 123], dict_impl.new)\n"
"    iex> dict2 = []\n"
"    iex> Dict.equal?(dict1, dict2)\n"
"    false\n"
"\n"
msgstr ""
"`===`を使って二つのdictが等しいかを\n"
"チェックします。\n"
"\n"
"任意のタイプのdictの比較をするので、この関数はポリモーフィック(多態的)\n"
"であることに注意してください。\n"
"それぞれのdict実装も、`equal?`関数を提供しますが、それらは同じタイプの\n"
"dict同士で動作するだけです。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict1 = Enum.into([a: 2, b: 3, f: 5, c: 123], dict_impl.new)\n"
"    iex> dict2 = [a: 2, b: 3, f: 5, c: 123]\n"
"    iex> Dict.equal?(dict1, dict2)\n"
"    true\n"
"\n"
"    iex> dict1 = Enum.into([a: 2, b: 3, f: 5, c: 123], dict_impl.new)\n"
"    iex> dict2 = []\n"
"    iex> Dict.equal?(dict1, dict2)\n"
"    false\n"
"\n"
