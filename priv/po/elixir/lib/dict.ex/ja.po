msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2015-05-20 21:53+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: def Dict.update(dict, key, initial, fun)
#: lib/dict.ex:559
msgid ""
"Updates a value in `dict` by calling `fun` on the value to get a new value. "
"If\n"
"`key` is not present in `dict` then `initial` will be stored as the first\n"
"value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.update(dict, :c, 3, fn(val) -> -val end)\n"
"    iex> Dict.get(dict, :c)\n"
"    3\n"
"\n"
msgstr ""
"値から新しい値を取得する`fun`を呼ぶことによって`dict`の値を更新します。\n"
"もし`key`が`dict`に表れなかったら`initial`が最初の値として格納されるで\n"
"しょう。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.update(dict, :c, 3, fn(val) -> -val end)\n"
"    iex> Dict.get(dict, :c)\n"
"    3\n"
"\n"

#. TRANSLATORS: def Dict.update!(dict, key, fun)
#: lib/dict.ex:541
msgid ""
"Updates a value in `dict` by calling `fun` on the value to get a new\n"
"value. An exception is generated if `key` is not present in the dict.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.update!(dict, :a, fn(val) -> -val end)\n"
"    iex> Dict.get(dict, :a)\n"
"    -1\n"
"\n"
msgstr ""
"値から新しい値を取得する`fun`を呼ぶことによって`dict`の値を更新します。\n"
"もし`key`が`dict`に表れなかったら例外が生成されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.update!(dict, :a, fn(val) -> -val end)\n"
"    iex> Dict.get(dict, :a)\n"
"    -1\n"
"\n"

#. TRANSLATORS: Elixir.Dict Summary
#: lib/dict.ex:1
msgid ""
"This module specifies the Dict API expected to be\n"
"implemented by different dictionaries. It also provides\n"
"functions that redirect to the underlying Dict, allowing\n"
"a developer to work with different Dict implementations\n"
"using one API.\n"
"\n"
"To create a new dict, use the `new` functions defined\n"
"by each dict type:\n"
"\n"
"    HashDict.new  #=> creates an empty HashDict\n"
"\n"
"In the examples below, `dict_impl` means a specific\n"
"`Dict` implementation, for example `HashDict` or `Map`.\n"
"\n"
"## Protocols\n"
"\n"
"Besides implementing the functions in this module, all\n"
"dictionaries are required to implement the `Access`\n"
"protocol:\n"
"\n"
"    iex> dict = dict_impl.new\n"
"    iex> dict = Dict.put(dict, :hello, :world)\n"
"    iex> dict[:hello]\n"
"    :world\n"
"\n"
"As well as the `Enumerable` and `Collectable` protocols.\n"
"\n"
"## Match\n"
"\n"
"Dictionaries are required to implement all operations\n"
"using the match (`===`) operator.\n"
"\n"
"## Default implementation\n"
"\n"
"Default implementations for some functions in the `Dict` module\n"
"are provided via `use Dict`.\n"
"\n"
"For example:\n"
"\n"
"    defmodule MyDict do\n"
"      use Dict\n"
"\n"
"      # implement required functions (see below)\n"
"      # override default implementations if optimization\n"
"      # is needed\n"
"    end\n"
"\n"
"The client module must contain the following functions:\n"
"\n"
"  * `delete/2`\n"
"  * `fetch/2`\n"
"  * `put/3`\n"
"  * `reduce/3`\n"
"  * `size/1`\n"
"\n"
"All functions, except `reduce/3`, are required by the Dict behaviour.\n"
"`reduce/3` must be implemented as per the Enumerable protocol.\n"
"\n"
"Based on these functions, `Dict` generates default implementations\n"
"for the following functions:\n"
"\n"
"  * `drop/2`\n"
"  * `equal?/2`\n"
"  * `fetch!/2`\n"
"  * `get/2`\n"
"  * `get/3`\n"
"  * `has_key?/2`\n"
"  * `keys/1`\n"
"  * `merge/2`\n"
"  * `merge/3`\n"
"  * `pop/2`\n"
"  * `pop/3`\n"
"  * `put_new/3`\n"
"  * `split/2`\n"
"  * `take/2`\n"
"  * `to_list/1`\n"
"  * `update/4`\n"
"  * `update!/3`\n"
"  * `values/1`\n"
"\n"
"All of these functions are defined as overridable, so you can provide\n"
"your own implementation if needed.\n"
"\n"
"Note you can also test your custom module via `Dict`'s doctests:\n"
"\n"
"    defmodule MyDict do\n"
"      # ...\n"
"    end\n"
"\n"
"    defmodule MyTests do\n"
"      use ExUnit.Case\n"
"      doctest Dict\n"
"      defp dict_impl, do: MyDict\n"
"    end\n"
"\n"
msgstr ""
"このモジュールは異った辞書による実装に期待されるべき、Dict API仕様を\n"
"指定します。\n"
"\n"
"一つのAPIを使って異るDictの実装で開発者が仕事をすることを許す、基礎をな\n"
"すDictへリダイレクトする関数も提供します。\n"
"\n"
"新しいDictを作成するために、それぞれのDictのタイプ毎に定義された`new`関\n"
"数を使います:\n"
"\n"
"    HashDict.new  #=> creates an empty HashDict\n"
"\n"
"下の例では、`dict_impl`は特定の`Dict`実装、例えば`HashDict` または\n"
"`Map`を意味します。\n"
"\n"
"## プロトコル\n"
"\n"
"このモジュールで実装している関数の他に、全ての辞書は\n"
"`Access`プロトコルを実装することが要求されます:\n"
"\n"
"    iex> dict = dict_impl.new\n"
"    iex> dict = Dict.put(dict, :hello, :world)\n"
"    iex> dict[:hello]\n"
"    :world\n"
"\n"
"`Enumerable`と`Collectable`プロトコルの実装も同様です。\n"
"\n"
"## マッチ\n"
"\n"
"Dictは実装をマッチオペレータ(`===`)を使う全ての操作の実装を\n"
"要求します。\n"
"\n"
"## デフォルトの実装\n"
"\n"
"`Dict`モジュールの幾つかの関数でのデフォルトの実装は`use Dict`により\n"
"提供されます。\n"
"\n"
"例えば:\n"
"\n"
"    defmodule MyDict do\n"
"      use Dict\n"
"\n"
"      # 要求された関数(下記参照)の実装をします\n"
"      # 最適化が必要ならデフォルトの実装を\n"
"      # オーバーライドします\n"
"    end\n"
"\n"
"クライアントモジュールは以下の関数を含んでいなければなりません:\n"
"\n"
"  * `delete/2`\n"
"  * `fetch/2`\n"
"  * `put/3`\n"
"  * `reduce/3`\n"
"  * `size/1`\n"
"\n"
"`reduce/3`を除く全ての関数はDictビヘイビアにより要求されます。\n"
"`reduce/3`はEnumerableプロトコルにより実装されなければなりません。\n"
"\n"
"これらの関数の基いて、`Dict`は以下の関数のデフォルトの実装を生成します:\n"
"\n"
"  * `drop/2`\n"
"  * `equal?/2`\n"
"  * `fetch!/2`\n"
"  * `get/2`\n"
"  * `get/3`\n"
"  * `has_key?/2`\n"
"  * `keys/1`\n"
"  * `merge/2`\n"
"  * `merge/3`\n"
"  * `pop/2`\n"
"  * `pop/3`\n"
"  * `put_new/3`\n"
"  * `split/2`\n"
"  * `take/2`\n"
"  * `to_list/1`\n"
"  * `update/4`\n"
"  * `update!/3`\n"
"  * `values/1`\n"
"\n"
"これらの関数の全てはオーバーライド可能に定義されていますので、\n"
"必要に応じて自分で実装を提供することができます。\n"
"\n"
"`Dict`のdoctestによりカスタムモジュールをテストすることもできる\n"
"ことに注意してください:\n"
"\n"
"    defmodule MyDict do\n"
"      # ...\n"
"    end\n"
"\n"
"    defmodule MyTests do\n"
"      use ExUnit.Case\n"
"      doctest Dict\n"
"      defp dict_impl, do: MyDict\n"
"    end\n"
"\n"

#. TRANSLATORS: def Dict.put(dict, key, val)
#: lib/dict.ex:415
msgid ""
"Stores the given `value` under `key` in `dict`.\n"
"If `dict` already has `key`, the stored value is replaced by the new one.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.put(dict, :a, 3)\n"
"    iex> Dict.get(dict, :a)\n"
"    3\n"
"\n"
msgstr ""
"与えられた`value`と`key`を`dict`に保存します。\n"
"もし`dict`が既に`key`を持っていたら、新しい値により置き換えられます。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.put(dict, :a, 3)\n"
"    iex> Dict.get(dict, :a)\n"
"    3\n"
"\n"

#. TRANSLATORS: def Dict.to_list(dict)
#: lib/dict.ex:689
msgid ""
"Returns a list of key-value pairs stored in `dict`.\n"
"No particular order is enforced.\n"
msgstr ""
"`dict`に保存されているキーバリューペアのリストを返します。\n"
"\n"
"特定の順序に整列はされません。\n"

#. TRANSLATORS: def Dict.values(dict)
#: lib/dict.ex:313
msgid ""
"Returns a list of all values in `dict`.\n"
"The values are not guaranteed to be in any order.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> Enum.sort(Dict.values(dict))\n"
"    [1,2]\n"
"\n"
msgstr ""
"`dict`の全ての値のリストを返します。\n"
"値の整列は保証されません。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> Enum.sort(Dict.values(dict))\n"
"    [1,2]\n"
"\n"

#. TRANSLATORS: def Dict.keys(dict)
#: lib/dict.ex:297
msgid ""
"Returns a list of all keys in `dict`.\n"
"The keys are not guaranteed to be in any order.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> Enum.sort(Dict.keys(dict))\n"
"    [:a,:b]\n"
"\n"
msgstr ""
"`dict`の全てのキーのリストを返します。\n"
"キーの整列は保証されません。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> Enum.sort(Dict.keys(dict))\n"
"    [:a,:b]\n"
"\n"

#. TRANSLATORS: def Dict.fetch(dict, key)
#: lib/dict.ex:382
msgid ""
"Returns `{:ok, value}` associated with `key` in `dict`.\n"
"If `dict` does not contain `key`, returns `:error`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> Dict.fetch(dict, :a)\n"
"    {:ok, 1}\n"
"    iex> Dict.fetch(dict, :b)\n"
"    :error\n"
"\n"
msgstr ""
"`dict`中の`key`に関連した値をvalueとして、`{:ok, value}`を返します。\n"
"もし`dict`が`key`含んでいなかったら、`:error`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> Dict.fetch(dict, :a)\n"
"    {:ok, 1}\n"
"    iex> Dict.fetch(dict, :b)\n"
"    :error\n"
"\n"

#. TRANSLATORS: def Dict.delete(dict, key)
#: lib/dict.ex:452
msgid ""
"Removes the entry stored under the given `key` from `dict`.\n"
"If `dict` does not contain `key`, returns the dictionary unchanged.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.delete(dict, :a)\n"
"    iex> Dict.get(dict, :a)\n"
"    nil\n"
"\n"
"    iex> dict = Enum.into([b: 2], dict_impl.new)\n"
"    iex> Dict.delete(dict, :a) == dict\n"
"    true\n"
"\n"
msgstr ""
"`dict`から与えられた`key`でストアされたエントリを取り除きます。\n"
"`dict`が`key`を含んでいないなら、返される辞書は変更されていません。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.delete(dict, :a)\n"
"    iex> Dict.get(dict, :a)\n"
"    nil\n"
"\n"
"    iex> dict = Enum.into([b: 2], dict_impl.new)\n"
"    iex> Dict.delete(dict, :a) == dict\n"
"    true\n"
"\n"

#. TRANSLATORS: def Dict.put_new(dict, key, val)
#: lib/dict.ex:431
msgid ""
"Puts the given `value` under `key` in `dict` unless `key` already existed.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.put_new(dict, :a, 3)\n"
"    iex> Dict.get(dict, :a)\n"
"    1\n"
"\n"
msgstr ""
"既に`key`のエントリが存在しないかぎり、与えられた`value`を`key`の\n"
"下で`dictにプットします。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.put_new(dict, :a, 3)\n"
"    iex> Dict.get(dict, :a)\n"
"    1\n"
"\n"

#. TRANSLATORS: def Dict.merge(dict1, dict2, fun \\ fn _k, _v1, v2 -> v2 end)
#: lib/dict.ex:485
msgid ""
"Merges the dict `dict2` into dict `dict1`.\n"
"\n"
"If one of the `dict2` entries already existed in `dict1`, the\n"
"conflicting entries in `dict2` have higher precedence unless a\n"
"function is given to resolve conflicts.\n"
"\n"
"Notice this function is polymorphic as it merges dicts of any\n"
"type. Each dict implementation also provides a `merge` function,\n"
"but they can only merge dicts of the same type.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict1 = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict2 = Enum.into([a: 3, d: 4], dict_impl.new)\n"
"    iex> dict = Dict.merge(dict1, dict2)\n"
"    iex> [a: Dict.get(dict, :a), b: Dict.get(dict, :b), d: Dict.get(dict, :"
"d)]\n"
"    [a: 3, b: 2, d: 4]\n"
"\n"
"    iex> dict1 = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict2 = Enum.into([a: 3, d: 4], dict_impl.new)\n"
"    iex> dict = Dict.merge(dict1, dict2, fn(_k, v1, v2) ->\n"
"    ...>   v1 + v2\n"
"    ...> end)\n"
"    iex> [a: Dict.get(dict, :a), b: Dict.get(dict, :b), d: Dict.get(dict, :"
"d)]\n"
"    [a: 4, b: 2, d: 4]\n"
"\n"
msgstr ""
"dict`dicdt2`をdict`dict1`にマージします。\n"
"\n"
"もし、`dict2`のエントリの一つが既に`dict1`に存在したら、\n"
"衝突を解決するための関数が与えられていないかぎり、\n"
"`dict2`のエントリがより高い優先順位を持ちます。\n"
"\n"
"任意のタイプのdictをマージするので、この関数はポリモーフィック(多態的)\n"
"であることに注意してください。\n"
"それぞれのdict実装も、`merge`関数を提供しますが、それらは同じタイプの\n"
"dict同士のマージが出来るだけです。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict1 = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict2 = Enum.into([a: 3, d: 4], dict_impl.new)\n"
"    iex> dict = Dict.merge(dict1, dict2)\n"
"    iex> [a: Dict.get(dict, :a), b: Dict.get(dict, :b), d: Dict.get(dict, :"
"d)]\n"
"    [a: 3, b: 2, d: 4]\n"
"\n"
"    iex> dict1 = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict2 = Enum.into([a: 3, d: 4], dict_impl.new)\n"
"    iex> dict = Dict.merge(dict1, dict2, fn(_k, v1, v2) ->\n"
"    ...>   v1 + v2\n"
"    ...> end)\n"
"    iex> [a: Dict.get(dict, :a), b: Dict.get(dict, :b), d: Dict.get(dict, :"
"d)]\n"
"    [a: 4, b: 2, d: 4]\n"
"\n"

#. TRANSLATORS: def Dict.get(dict, key, default \\ nil)
#: lib/dict.ex:364
msgid ""
"Returns the value associated with `key` in `dict`. If `dict` does not\n"
"contain `key`, returns `default` (or `nil` if not provided).\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> Dict.get(dict, :a)\n"
"    1\n"
"    iex> Dict.get(dict, :b)\n"
"    nil\n"
"    iex> Dict.get(dict, :b, 3)\n"
"    3\n"
msgstr ""
"`dict`の`key`に関連付けられた値を返します。もし`dict`が`key`を含んでい\n"
"ない場合、`default`(それも提供されていない場合は`nil`)を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> Dict.get(dict, :a)\n"
"    1\n"
"    iex> Dict.get(dict, :b)\n"
"    nil\n"
"    iex> Dict.get(dict, :b, 3)\n"
"    3\n"

#. TRANSLATORS: def Dict.fetch!(dict, key)
#: lib/dict.ex:398
msgid ""
"Returns the value associated with `key` in `dict`. If `dict` does not\n"
"contain `key`, it raises `KeyError`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> Dict.fetch!(dict, :a)\n"
"    1\n"
"\n"
msgstr ""
"`dict`中の`key`に関連した値を返します。もし`dict`が`key`を含んでいない\n"
"場合、`KeyError`を上げます。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> Dict.fetch!(dict, :a)\n"
"    1\n"
"\n"

#. TRANSLATORS: def Dict.pop(dict, key, default \\ nil)
#: lib/dict.ex:524
msgid ""
"Returns the value associated with `key` in `dict` as\n"
"well as the `dict` without `key`.\n"
"\n"
"If `key` is not present in `dict`, then the `dict` will\n"
"be returned unmodified.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> {v, dict} = Dict.pop dict, :a\n"
"    iex> {v, Enum.sort(dict)}\n"
"    {1,[]}\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> {v, dict} = Dict.pop dict, :b\n"
"    iex> {v, Enum.sort(dict)}\n"
"    {nil,[a: 1]}\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> {v, dict} = Dict.pop dict, :b, 3\n"
"    iex> {v, Enum.sort(dict)}\n"
"    {3,[a: 1]}\n"
"\n"
msgstr ""
"`dict`の中の`key`に関連した値と`key`を取り除いた`dict`を返します。\n"
"\n"
"`key`が`dict`に無いなら、`dict`は変更されずに返されます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> {v, dict} = Dict.pop dict, :a\n"
"    iex> {v, Enum.sort(dict)}\n"
"    {1,[]}\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> {v, dict} = Dict.pop dict, :b\n"
"    iex> {v, Enum.sort(dict)}\n"
"    {nil,[a: 1]}\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> {v, dict} = Dict.pop dict, :b, 3\n"
"    iex> {v, Enum.sort(dict)}\n"
"    {3,[a: 1]}\n"
"\n"

#. TRANSLATORS: def Dict.equal?(dict1, dict2)
#: lib/dict.ex:663
msgid ""
"Checks if two dicts are equal using `===`.\n"
"\n"
"Notice this function is polymorphic as it compares dicts of any\n"
"type. Each dict implementation also provides an `equal?` function,\n"
"but they can only compare dicts of the same type.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict1 = Enum.into([a: 2, b: 3, f: 5, c: 123], dict_impl.new)\n"
"    iex> dict2 = [a: 2, b: 3, f: 5, c: 123]\n"
"    iex> Dict.equal?(dict1, dict2)\n"
"    true\n"
"\n"
"    iex> dict1 = Enum.into([a: 2, b: 3, f: 5, c: 123], dict_impl.new)\n"
"    iex> dict2 = []\n"
"    iex> Dict.equal?(dict1, dict2)\n"
"    false\n"
"\n"
msgstr ""
"`===`を使って二つのdictが等しいかを\n"
"チェックします。\n"
"\n"
"任意のタイプのdictの比較をするので、この関数はポリモーフィック(多態的)\n"
"であることに注意してください。\n"
"それぞれのdict実装も、`equal?`関数を提供しますが、それらは同じタイプの\n"
"dict同士で動作するだけです。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict1 = Enum.into([a: 2, b: 3, f: 5, c: 123], dict_impl.new)\n"
"    iex> dict2 = [a: 2, b: 3, f: 5, c: 123]\n"
"    iex> Dict.equal?(dict1, dict2)\n"
"    true\n"
"\n"
"    iex> dict1 = Enum.into([a: 2, b: 3, f: 5, c: 123], dict_impl.new)\n"
"    iex> dict2 = []\n"
"    iex> Dict.equal?(dict1, dict2)\n"
"    false\n"
"\n"

#. TRANSLATORS: def Dict.has_key?(dict, key)
#: lib/dict.ex:345
msgid ""
"Returns whether the given `key` exists in the given `dict`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> Dict.has_key?(dict, :a)\n"
"    true\n"
"    iex> Dict.has_key?(dict, :b)\n"
"    false\n"
"\n"
msgstr ""
"与えられた`key`が`dict`に存在するかを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> Dict.has_key?(dict, :a)\n"
"    true\n"
"    iex> Dict.has_key?(dict, :b)\n"
"    false\n"
"\n"

#. TRANSLATORS: def Dict.size(dict)
#: lib/dict.ex:328
msgid ""
"Returns the number of elements in `dict`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> Dict.size(dict)\n"
"    2\n"
"\n"
msgstr ""
"`dict`の要素の数を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> Dict.size(dict)\n"
"    2\n"
"\n"

#. TRANSLATORS: def Dict.split(dict, keys)
#: lib/dict.ex:589
msgid ""
"Returns a tuple of two dicts, where the first dict contains only\n"
"entries from `dict` with keys in `keys`, and the second dict\n"
"contains only entries from `dict` with keys not in `keys`.\n"
"\n"
"All non-member keys are ignored.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2, c: 3, d: 4], dict_impl.new)\n"
"    iex> {dict1, dict2} = Dict.split(dict, [:a, :c, :e])\n"
"    iex> {Dict.to_list(dict1) |> Enum.sort, Dict.to_list(dict2) |> Enum."
"sort}\n"
"    {[a: 1, c: 3], [b: 2, d: 4]}\n"
"\n"
"    iex> dict = Enum.into([], dict_impl.new)\n"
"    iex> {dict1, dict2} = Dict.split(dict, [:a, :c])\n"
"    iex> {Dict.to_list(dict1), Dict.to_list(dict2)}\n"
"    {[], []}\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> {dict1, dict2} = Dict.split(dict, [:a, :b, :c])\n"
"    iex> {Dict.to_list(dict1) |> Enum.sort, Dict.to_list(dict2)}\n"
"    {[a: 1, b: 2], []}\n"
"\n"
msgstr ""
"二つのdictのタプルを返します。最初のdictは`dict`からキーのリスト\n"
"`keys`を含むエントリだけのdictで、二つめのdictは`dict`からキーのリスト\n"
"`keys`を含まないエントリのだけのdictです。\n"
"\n"
"メンバーでないkeysは全て無視されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2, c: 3, d: 4], dict_impl.new)\n"
"    iex> {dict1, dict2} = Dict.split(dict, [:a, :c, :e])\n"
"    iex> {Dict.to_list(dict1) |> Enum.sort, Dict.to_list(dict2) |> Enum."
"sort}\n"
"    {[a: 1, c: 3], [b: 2, d: 4]}\n"
"\n"
"    iex> dict = Enum.into([], dict_impl.new)\n"
"    iex> {dict1, dict2} = Dict.split(dict, [:a, :c])\n"
"    iex> {Dict.to_list(dict1), Dict.to_list(dict2)}\n"
"    {[], []}\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> {dict1, dict2} = Dict.split(dict, [:a, :b, :c])\n"
"    iex> {Dict.to_list(dict1) |> Enum.sort, Dict.to_list(dict2)}\n"
"    {[a: 1, b: 2], []}\n"
"\n"

#. TRANSLATORS: def Dict.drop(dict, keys)
#: lib/dict.ex:611
msgid ""
"Returns a new dict where the given `keys` are removed from `dict`.\n"
"All non-member keys are ignored.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.drop(dict, [:a, :c, :d])\n"
"    iex> Dict.to_list(dict)\n"
"    [b: 2]\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.drop(dict, [:c, :d])\n"
"    iex> Dict.to_list(dict) |> Enum.sort\n"
"    [a: 1, b: 2]\n"
"\n"
msgstr ""
"与えられた`keys`を`dict`から取り除いた新しいdictを返します。\n"
"メンバーでないキーは全て無視されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.drop(dict, [:a, :c, :d])\n"
"    iex> Dict.to_list(dict)\n"
"    [b: 2]\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.drop(dict, [:c, :d])\n"
"    iex> Dict.to_list(dict) |> Enum.sort\n"
"    [a: 1, b: 2]\n"
"\n"

#. TRANSLATORS: def Dict.take(dict, keys)
#: lib/dict.ex:632
msgid ""
"Returns a new dict where only the keys in `keys` from `dict` are included.\n"
"\n"
"All non-member keys are ignored.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.take(dict, [:a, :c, :d])\n"
"    iex> Dict.to_list(dict)\n"
"    [a: 1]\n"
"    iex> dict = Dict.take(dict, [:c, :d])\n"
"    iex> Dict.to_list(dict)\n"
"    []\n"
"\n"
msgstr ""
"`dict`から`keys`だけを含む新しいdictを作成して返します。\n"
"\n"
"メンバーでないキーは全て無視されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.take(dict, [:a, :c, :d])\n"
"    iex> Dict.to_list(dict)\n"
"    [a: 1]\n"
"    iex> dict = Dict.take(dict, [:c, :d])\n"
"    iex> Dict.to_list(dict)\n"
"    []\n"
"\n"
