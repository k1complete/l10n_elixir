#. TRANSLATORS: def Dict.has_key?(dict, key)
#: lib/dict.ex:375 
msgid ""
"Returns whether the given `key` exists in the given `dict`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> Dict.has_key?(dict, :a)\n"
"    true\n"
"    iex> Dict.has_key?(dict, :b)\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Dict.get(dict, key, default \\ nil)
#: lib/dict.ex:392 
msgid ""
"Returns the value associated with `key` in `dict`. If `dict` does not\n"
"contain `key`, returns `default` (or `nil` if not provided).\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> Dict.get(dict, :a)\n"
"    1\n"
"    iex> Dict.get(dict, :b)\n"
"    nil\n"
"    iex> Dict.get(dict, :b, 3)\n"
"    3\n"
msgstr ""
#. TRANSLATORS: def Dict.fetch!(dict, key)
#: lib/dict.ex:482 
msgid ""
"Returns the value associated with `key` in `dict`. If `dict` does not\n"
"contain `key`, it raises `KeyError`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> Dict.fetch!(dict, :a)\n"
"    1\n"
"\n"
msgstr ""
#. TRANSLATORS: def Dict.get_lazy(dict, key, fun)
#: lib/dict.ex:411 
msgid ""
"Returns the value associated with `key` in `dict`. If `dict` does not\n"
"contain `key`, it lazily evaluates `fun` and returns its result.\n"
"\n"
"This is useful if the default value is very expensive to calculate or\n"
"generally difficult to set-up and tear-down again.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> fun = fn ->\n"
"    ...>   # some expensive operation here\n"
"    ...>   :result\n"
"    ...> end\n"
"    iex> Dict.get_lazy(dict, :a, fun)\n"
"    1\n"
"    iex> Dict.get_lazy(dict, :b, fun)\n"
"    :result\n"
"\n"
msgstr ""
#. TRANSLATORS: def Dict.pop(dict, key, default \\ nil)
#: lib/dict.ex:649 
msgid ""
"Returns the value associated with `key` in `dict` as\n"
"well as the `dict` without `key`.\n"
"\n"
"If `key` is not present in `dict`, then the `dict` will\n"
"be returned unmodified.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> {v, dict} = Dict.pop dict, :a\n"
"    iex> {v, Enum.sort(dict)}\n"
"    {1, []}\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> {v, dict} = Dict.pop dict, :b\n"
"    iex> {v, Enum.sort(dict)}\n"
"    {nil, [a: 1]}\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> {v, dict} = Dict.pop dict, :b, 3\n"
"    iex> {v, Enum.sort(dict)}\n"
"    {3, [a: 1]}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Dict.pop_lazy(dict, key, fun)
#: lib/dict.ex:679 
msgid ""
"Returns the value associated with `key` in `dict` as\n"
"well as the `dict` without `key`.\n"
"\n"
"If `key` is not present in `dict`, then the `dict` will\n"
"be returned unmodified, and it will lazily evaluate `fun`\n"
"and return its result instead of the missing value.\n"
"\n"
"This is useful if the default value is very expensive to calculate or\n"
"generally difficult to set-up and tear-down again.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> fun = fn ->\n"
"    ...>   # some expensive operation here\n"
"    ...>   :result\n"
"    ...> end\n"
"    iex> {v, dict} = Dict.pop_lazy dict, :a, fun\n"
"    iex> {v, Enum.sort(dict)}\n"
"    {1, []}\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> fun = fn ->\n"
"    ...>   # some expensive operation here\n"
"    ...>   :result\n"
"    ...> end\n"
"    iex> {v, dict} = Dict.pop_lazy dict, :b, fun\n"
"    iex> {v, Enum.sort(dict)}\n"
"    {:result, [a: 1]}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Dict.size(dict)
#: lib/dict.ex:360 
msgid ""
"Returns the number of elements in `dict`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> Dict.size(dict)\n"
"    2\n"
"\n"
msgstr ""
#. TRANSLATORS: def Dict.drop(dict, keys)
#: lib/dict.ex:781 
msgid ""
"Returns a new dict where the given `keys` are removed from `dict`.\n"
"All non-member keys are ignored.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.drop(dict, [:a, :c, :d])\n"
"    iex> Dict.to_list(dict)\n"
"    [b: 2]\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.drop(dict, [:c, :d])\n"
"    iex> Dict.to_list(dict) |> Enum.sort\n"
"    [a: 1, b: 2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Dict.update(dict, key, initial, fun)
#: lib/dict.ex:733 
msgid ""
"Updates a value in `dict` by calling `fun` on the value to get a new value. If\n"
"`key` is not present in `dict` then `initial` will be stored as the first\n"
"value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.update(dict, :c, 3, fn(val) -> -val end)\n"
"    iex> Dict.get(dict, :c)\n"
"    3\n"
"\n"
msgstr ""
#. TRANSLATORS: def Dict.update!(dict, key, fun)
#: lib/dict.ex:716 
msgid ""
"Updates a value in `dict` by calling `fun` on the value to get a new\n"
"value. An exception is generated if `key` is not present in the dict.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.update!(dict, :a, fn(val) -> -val end)\n"
"    iex> Dict.get(dict, :a)\n"
"    -1\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.Dict Summary
#: lib/dict.ex:2 
msgid ""
"This module specifies the Dict API expected to be\n"
"implemented by different dictionaries.\n"
"\n"
"It also provides functions that redirect to the underlying\n"
"Dict, allowing a developer to work with different Dict\n"
"implementations using one API.\n"
"\n"
"To create a new dict, use the `new` functions defined\n"
"by each dict type:\n"
"\n"
"    HashDict.new  #=> creates an empty HashDict\n"
"\n"
"In the examples below, `dict_impl` means a specific\n"
"`Dict` implementation, for example `HashDict` or `Map`.\n"
"\n"
"## Warning\n"
"\n"
"Do not use this module if you expect a certain `Dict`\n"
"implementation. For example, if you are working with\n"
"maps and you don't need polymorphism, it is preferrable\n"
"to use the `Map` module instead of the `Dict` one.\n"
"\n"
"## Protocols\n"
"\n"
"Besides implementing the functions in this module, all\n"
"dictionaries are required to implement the `Access`\n"
"protocol:\n"
"\n"
"    iex> dict = dict_impl.new\n"
"    iex> dict = Dict.put(dict, :hello, :world)\n"
"    iex> dict[:hello]\n"
"    :world\n"
"\n"
"As well as the `Enumerable` and `Collectable` protocols.\n"
"\n"
"## Match\n"
"\n"
"Dictionaries are required to implement all operations\n"
"using the match (`===`) operator.\n"
"\n"
"## Default implementation\n"
"\n"
"Default implementations for some functions in the `Dict` module\n"
"are provided via `use Dict`.\n"
"\n"
"For example:\n"
"\n"
"    defmodule MyDict do\n"
"      use Dict\n"
"\n"
"      # implement required functions (see below)\n"
"      # override default implementations if optimization\n"
"      # is needed\n"
"    end\n"
"\n"
"The client module must contain the following functions:\n"
"\n"
"  * `delete/2`\n"
"  * `fetch/2`\n"
"  * `put/3`\n"
"  * `reduce/3`\n"
"  * `size/1`\n"
"\n"
"All functions, except `reduce/3`, are required by the Dict behaviour.\n"
"`reduce/3` must be implemented as per the Enumerable protocol.\n"
"\n"
"Based on these functions, `Dict` generates default implementations\n"
"for the following functions:\n"
"\n"
"  * `drop/2`\n"
"  * `equal?/2`\n"
"  * `fetch!/2`\n"
"  * `get/2`\n"
"  * `get/3`\n"
"  * `get_lazy/3`\n"
"  * `get_and_update/3`\n"
"  * `has_key?/2`\n"
"  * `keys/1`\n"
"  * `merge/2`\n"
"  * `merge/3`\n"
"  * `pop/2`\n"
"  * `pop/3`\n"
"  * `pop_lazy/3`\n"
"  * `put_new/3`\n"
"  * `put_new_lazy/3`\n"
"  * `split/2`\n"
"  * `take/2`\n"
"  * `to_list/1`\n"
"  * `update/4`\n"
"  * `update!/3`\n"
"  * `values/1`\n"
"\n"
"All of these functions are defined as overridable, so you can provide\n"
"your own implementation if needed.\n"
"\n"
"Note you can also test your custom module via `Dict`'s doctests:\n"
"\n"
"    defmodule MyDict do\n"
"      # ...\n"
"    end\n"
"\n"
"    defmodule MyTests do\n"
"      use ExUnit.Case\n"
"      doctest Dict\n"
"      defp dict_impl, do: MyDict\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def Dict.put(dict, key, val)
#: lib/dict.ex:498 
msgid ""
"Stores the given `value` under `key` in `dict`.\n"
"If `dict` already has `key`, the stored value is replaced by the new one.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.put(dict, :a, 3)\n"
"    iex> Dict.get(dict, :a)\n"
"    3\n"
"\n"
msgstr ""
#. TRANSLATORS: def Dict.split(dict, keys)
#: lib/dict.ex:751 
msgid ""
"Returns a tuple of two dicts, where the first dict contains only\n"
"entries from `dict` with keys in `keys`, and the second dict\n"
"contains only entries from `dict` with keys not in `keys`.\n"
"\n"
"All non-member keys are ignored.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2, c: 3, d: 4], dict_impl.new)\n"
"    iex> {dict1, dict2} = Dict.split(dict, [:a, :c, :e])\n"
"    iex> {Dict.to_list(dict1) |> Enum.sort, Dict.to_list(dict2) |> Enum.sort}\n"
"    {[a: 1, c: 3], [b: 2, d: 4]}\n"
"\n"
"    iex> dict = Enum.into([], dict_impl.new)\n"
"    iex> {dict1, dict2} = Dict.split(dict, [:a, :c])\n"
"    iex> {Dict.to_list(dict1), Dict.to_list(dict2)}\n"
"    {[], []}\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> {dict1, dict2} = Dict.split(dict, [:a, :b, :c])\n"
"    iex> {Dict.to_list(dict1) |> Enum.sort, Dict.to_list(dict2)}\n"
"    {[a: 1, b: 2], []}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Dict.take(dict, keys)
#: lib/dict.ex:803 
msgid ""
"Returns a new dict where only the keys in `keys` from `dict` are included.\n"
"\n"
"All non-member keys are ignored.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.take(dict, [:a, :c, :d])\n"
"    iex> Dict.to_list(dict)\n"
"    [a: 1]\n"
"    iex> dict = Dict.take(dict, [:c, :d])\n"
"    iex> Dict.to_list(dict)\n"
"    []\n"
"\n"
msgstr ""
#. TRANSLATORS: def Dict.to_list(dict)
#: lib/dict.ex:872 
msgid ""
"Returns a list of key-value pairs stored in `dict`.\n"
"No particular order is enforced.\n"
msgstr ""
#. TRANSLATORS: def Dict.values(dict)
#: lib/dict.ex:344 
msgid ""
"Returns a list of all values in `dict`.\n"
"The values are not guaranteed to be in any order.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> Enum.sort(Dict.values(dict))\n"
"    [1, 2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Dict.keys(dict)
#: lib/dict.ex:328 
msgid ""
"Returns a list of all keys in `dict`.\n"
"The keys are not guaranteed to be in any order.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> Enum.sort(Dict.keys(dict))\n"
"    [:a, :b]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Dict.fetch(dict, key)
#: lib/dict.ex:464 
msgid ""
"Returns `{:ok, value}` associated with `key` in `dict`.\n"
"If `dict` does not contain `key`, returns `:error`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> Dict.fetch(dict, :a)\n"
"    {:ok, 1}\n"
"    iex> Dict.fetch(dict, :b)\n"
"    :error\n"
"\n"
msgstr ""
#. TRANSLATORS: def Dict.delete(dict, key)
#: lib/dict.ex:558 
msgid ""
"Removes the entry stored under the given `key` from `dict`.\n"
"If `dict` does not contain `key`, returns the dictionary unchanged.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.delete(dict, :a)\n"
"    iex> Dict.get(dict, :a)\n"
"    nil\n"
"\n"
"    iex> dict = Enum.into([b: 2], dict_impl.new)\n"
"    iex> Dict.delete(dict, :a) == dict\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: def Dict.put_new(dict, key, val)
#: lib/dict.ex:515 
msgid ""
"Puts the given `value` under `key` in `dict` unless `key` is already present.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.put_new(dict, :a, 3)\n"
"    iex> Dict.get(dict, :a)\n"
"    1\n"
"\n"
msgstr ""
#. TRANSLATORS: def Dict.merge(dict1, dict2, fun)
#: lib/dict.ex:610 
msgid ""
"Merges the dict `dict2` into dict `dict1`.\n"
"\n"
"If one of the `dict2` entries is found in `dict1`, the function\n"
"will be invoked to resolve the conflict.\n"
"\n"
"Notice this function is polymorphic as it merges dicts of any\n"
"type. Each dict implementation also provides a `merge` function,\n"
"but they can only merge dicts of the same type.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict1 = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict2 = Enum.into([a: 3, d: 4], dict_impl.new)\n"
"    iex> dict = Dict.merge(dict1, dict2, fn(_k, v1, v2) ->\n"
"    ...>   v1 + v2\n"
"    ...> end)\n"
"    iex> [a: Dict.get(dict, :a), b: Dict.get(dict, :b), d: Dict.get(dict, :d)]\n"
"    [a: 4, b: 2, d: 4]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Dict.merge(dict1, dict2)
#: lib/dict.ex:579 
msgid ""
"Merges the dict `dict2` into dict `dict1`.\n"
"\n"
"If one of the `dict2` entries is found in `dict1`, the\n"
"conflicting entries in `dict2` have higher precedence.\n"
"\n"
"Notice this function is polymorphic as it merges dicts of any\n"
"type. Each dict implementation also provides a `merge` function,\n"
"but they can only merge dicts of the same type.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict1 = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict2 = Enum.into([a: 3, d: 4], dict_impl.new)\n"
"    iex> dict = Dict.merge(dict1, dict2)\n"
"    iex> [a: Dict.get(dict, :a), b: Dict.get(dict, :b), d: Dict.get(dict, :d)]\n"
"    [a: 3, b: 2, d: 4]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Dict.get_and_update(dict, key, fun)
#: lib/dict.ex:436 
msgid ""
"Gets a value from `dict` and updates the value at `key` in one pass.\n"
"\n"
"This `fun` argument receives the value of `key` in `dict` (or `nil` if `key`\n"
"is not present) and must return a two-elements tuple: the \"get\" value (the\n"
"value retrieved from the dict which can be operated on before being returned)\n"
"and the new value to be stored under `key` in `dict`.\n"
"\n"
"The returned value is a tuple with the \"get\" value returned by `fun` and a new\n"
"dict with the updated value under `key`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> {get, new_dict} = Dict.get_and_update dict, :a, fn(current_value) ->\n"
"    ...>   {current_value + 1, \"foo\"}\n"
"    ...> end\n"
"    iex> get\n"
"    2\n"
"    iex> Dict.get(new_dict, :a)\n"
"    \"foo\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Dict.put_new_lazy(dict, key, fun)
#: lib/dict.ex:531 
msgid ""
"Evaluates `fun` and puts the result under `key` in `dict` unless `key`\n"
"is already present.\n"
"\n"
"This is useful if the value is very expensive to calculate or generally\n"
"difficult to set-up and tear-down again.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> fun = fn ->\n"
"    ...>   # some expensive operation here\n"
"    ...>   3\n"
"    ...> end\n"
"    iex> dict = Dict.put_new_lazy(dict, :a, fun)\n"
"    iex> Dict.get(dict, :a)\n"
"    1\n"
"    iex> dict = Dict.put_new_lazy(dict, :c, fun)\n"
"    iex> Dict.get(dict, :c)\n"
"    3\n"
"\n"
msgstr ""
#. TRANSLATORS: def Dict.equal?(dict1, dict2)
#: lib/dict.ex:830 
msgid ""
"Checks if two dicts are equal using `===`.\n"
"\n"
"Notice this function is polymorphic as it compares dicts of any\n"
"type. Each dict implementation also provides an `equal?` function,\n"
"but they can only compare dicts of the same type.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict1 = Enum.into([a: 2, b: 3, f: 5, c: 123], dict_impl.new)\n"
"    iex> dict2 = [a: 2, b: 3, f: 5, c: 123]\n"
"    iex> Dict.equal?(dict1, dict2)\n"
"    true\n"
"\n"
"    iex> dict1 = Enum.into([a: 2, b: 3, f: 5, c: 123], dict_impl.new)\n"
"    iex> dict2 = []\n"
"    iex> Dict.equal?(dict1, dict2)\n"
"    false\n"
"\n"
msgstr ""
