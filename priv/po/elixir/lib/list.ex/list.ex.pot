#. TRANSLATORS: def List.zip(list_of_lists)
#: lib/list.ex:322 
msgid ""
"Zips corresponding elements from each list in `list_of_lists`.\n"
"\n"
"The zipping finishes as soon as any list terminates.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.zip([[1, 2], [3, 4], [5, 6]])\n"
"    [{1, 3, 5}, {2, 4, 6}]\n"
"\n"
"    iex> List.zip([[1, 2], [3], [5, 6]])\n"
"    [{1, 3, 5}]\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.wrap(list)
#: lib/list.ex:295 
msgid ""
"Wraps the argument in a list.\n"
"If the argument is already a list, returns the list.\n"
"If the argument is `nil`, returns an empty list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.wrap(\"hello\")\n"
"    [\"hello\"]\n"
"\n"
"    iex> List.wrap([1, 2, 3])\n"
"    [1,2,3]\n"
"\n"
"    iex> List.wrap(nil)\n"
"    []\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.update_at(list, index, fun)
#: lib/list.ex:406 
msgid ""
"Returns a list with an updated value at the specified `index`.\n"
"Negative indices indicate an offset from the end of the list.\n"
"If `index` is out of bounds, the original `list` is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.update_at([1, 2, 3], 0, &(&1 + 10))\n"
"    [11, 2, 3]\n"
"\n"
"    iex> List.update_at([1, 2, 3], 10, &(&1 + 10))\n"
"    [1, 2, 3]\n"
"\n"
"    iex> List.update_at([1, 2, 3], -1, &(&1 + 10))\n"
"    [1, 2, 13]\n"
"\n"
"    iex> List.update_at([1, 2, 3], -10, &(&1 + 10))\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.replace_at(list, index, value)
#: lib/list.ex:377 
msgid ""
"Returns a list with a replaced value at the specified `index`.\n"
"Negative indices indicate an offset from the end of the list.\n"
"If `index` is out of bounds, the original `list` is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.replace_at([1, 2, 3], 0, 0)\n"
"    [0, 2, 3]\n"
"\n"
"    iex> List.replace_at([1, 2, 3], 10, 0)\n"
"    [1, 2, 3]\n"
"\n"
"    iex> List.replace_at([1, 2, 3], -1, 0)\n"
"    [1, 2, 0]\n"
"\n"
"    iex> List.replace_at([1, 2, 3], -10, 0)\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.insert_at(list, index, value)
#: lib/list.ex:348 
msgid ""
"Returns a list with `value` inserted at the specified `index`.\n"
"Note that `index` is capped at the list length. Negative indices\n"
"indicate an offset from the end of the list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.insert_at([1, 2, 3, 4], 2, 0)\n"
"    [1, 2, 0, 3, 4]\n"
"\n"
"    iex> List.insert_at([1, 2, 3], 10, 0)\n"
"    [1, 2, 3, 0]\n"
"\n"
"    iex> List.insert_at([1, 2, 3], -1, 0)\n"
"    [1, 2, 3, 0]\n"
"\n"
"    iex> List.insert_at([1, 2, 3], -10, 0)\n"
"    [0, 1, 2, 3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.keysort(list, position)
#: lib/list.ex:232 
msgid ""
"Receives a list of tuples and sorts the items\n"
"at `position` of the tuples. The sort is stable.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.keysort([a: 5, b: 1, c: 3], 1)\n"
"    [b: 1, c: 3, a: 5]\n"
"\n"
"    iex> List.keysort([a: 5, c: 1, b: 3], 0)\n"
"    [a: 5, b: 3, c: 1]\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.keyfind(list, key, position, default \\ nil)
#: lib/list.ex:177 
msgid ""
"Receives a list of tuples and returns the first tuple\n"
"where the item at `position` in the tuple matches the\n"
"given `key`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.keyfind([a: 1, b: 2], :a, 0)\n"
"    {:a, 1}\n"
"\n"
"    iex> List.keyfind([a: 1, b: 2], 2, 1)\n"
"    {:b, 2}\n"
"\n"
"    iex> List.keyfind([a: 1, b: 2], :c, 0)\n"
"    nil\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.keymember?(list, key, position)
#: lib/list.ex:199 
msgid ""
"Receives a list of tuples and returns `true` if there is\n"
"a tuple where the item at `position` in the tuple matches\n"
"the given `key`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.keymember?([a: 1, b: 2], :a, 0)\n"
"    true\n"
"\n"
"    iex> List.keymember?([a: 1, b: 2], 2, 1)\n"
"    true\n"
"\n"
"    iex> List.keymember?([a: 1, b: 2], :c, 0)\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.keystore(list, key, position, new_tuple)
#: lib/list.ex:251 
msgid ""
"Receives a list of tuples and replaces the item\n"
"identified by `key` at `position`. If the item\n"
"does not exist, it is added to the end of the list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.keystore([a: 1, b: 2], :a, 0, {:a, 3})\n"
"    [a: 3, b: 2]\n"
"\n"
"    iex> List.keystore([a: 1, b: 2], :c, 0, {:c, 3})\n"
"    [a: 1, b: 2, c: 3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.keyreplace(list, key, position, new_tuple)
#: lib/list.ex:214 
msgid ""
"Receives a list of tuples and replaces the item\n"
"identified by `key` at `position` if it exists.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.keyreplace([a: 1, b: 2], :a, 0, {:a, 3})\n"
"    [a: 3, b: 2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.keydelete(list, key, position)
#: lib/list.ex:273 
msgid ""
"Receives a list of tuples and deletes the first tuple\n"
"where the item at `position` matches the\n"
"given `key`. Returns the new list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.keydelete([a: 1, b: 2], :a, 0)\n"
"    [b: 2]\n"
"\n"
"    iex> List.keydelete([a: 1, b: 2], 2, 1)\n"
"    [a: 1]\n"
"\n"
"    iex> List.keydelete([a: 1, b: 2], :c, 0)\n"
"    [a: 1, b: 2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.delete_at(list, index)
#: lib/list.ex:432 
msgid ""
"Produces a new list by removing the value at the specified `index`.\n"
"Negative indices indicate an offset from the end of the list.\n"
"If `index` is out of bounds, the original `list` is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.delete_at([1, 2, 3], 0)\n"
"    [2, 3]\n"
"\n"
"    iex List.delete_at([1, 2, 3], 10)\n"
"    [1, 2, 3]\n"
"\n"
"    iex> List.delete_at([1, 2, 3], -1)\n"
"    [1, 2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.foldr(list, acc, function)
#: lib/list.ex:116 
msgid ""
"Folds (reduces) the given list from the right with\n"
"a function. Requires an accumulator.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.foldr([1, 2, 3, 4], 0, fn (x, acc) -> x - acc end)\n"
"    -2\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.foldl(list, acc, function)
#: lib/list.ex:101 
msgid ""
"Folds (reduces) the given list from the left with\n"
"a function. Requires an accumulator.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.foldl([5, 5], 10, fn (x, acc) -> x + acc end)\n"
"    20\n"
"\n"
"    iex> List.foldl([1, 2, 3, 4], 0, fn (x, acc) -> x - acc end)\n"
"    2\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.flatten(list, tail)
#: lib/list.ex:83 
msgid ""
"Flattens the given `list` of nested lists.\n"
"The list `tail` will be added at the end of\n"
"the flattened list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.flatten([1, [[2], 3]], [4, 5])\n"
"    [1,2,3,4,5]\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.flatten(list)
#: lib/list.ex:67 
msgid ""
"Flattens the given `list` of nested lists.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.flatten([1, [[2], 3]])\n"
"    [1,2,3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.delete(list, item)
#: lib/list.ex:36 
msgid ""
"Deletes the given item from the list. Returns a list without\n"
"the item. If the item occurs more than once in the list, just\n"
"the first occurrence is removed.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.delete([1, 2, 3], 1)\n"
"    [2,3]\n"
"\n"
"    iex> List.delete([1, 2, 2, 3], 2)\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.List Summary
#: lib/list.ex:1 
msgid ""
"Implements functions that only make sense for lists\n"
"and cannot be part of the Enum protocol. In general,\n"
"favor using the Enum API instead of List.\n"
"\n"
"Some functions in this module expect an index. Index\n"
"access for list is linear. Negative indexes are also\n"
"supported but they imply the list will be iterated twice,\n"
"one to calculate the proper index and another to the\n"
"operation.\n"
"\n"
"A decision was taken to delegate most functions to\n"
"Erlang's standard library but follow Elixir's convention\n"
"of receiving the target (in this case, a list) as the\n"
"first argument.\n"
msgstr ""
#. TRANSLATORS: def List.duplicate(elem, n)
#: lib/list.ex:53 
msgid ""
"Duplicates the given element `n` times in a list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.duplicate(\"hello\", 3)\n"
"    [\"hello\",\"hello\",\"hello\"]\n"
"\n"
"    iex> List.duplicate([1, 2], 2)\n"
"    [[1,2],[1,2]]\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.last(list1)
#: lib/list.ex:155 
msgid ""
"Returns the last element in `list` or `nil` if `list` is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.last([])\n"
"    nil\n"
"\n"
"    iex> List.last([1])\n"
"    1\n"
"\n"
"    iex> List.last([1, 2, 3])\n"
"    3\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.first(list1)
#: lib/list.ex:136 
msgid ""
"Returns the first element in `list` or `nil` if `list` is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.first([])\n"
"    nil\n"
"\n"
"    iex> List.first([1])\n"
"    1\n"
"\n"
"    iex> List.first([1, 2, 3])\n"
"    1\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.to_float(char_list)
#: lib/list.ex:484 
msgid ""
"Returns the float whose text representation is `char_list`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.to_float('2.2017764e+0')\n"
"    2.2017764\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.to_integer(char_list)
#: lib/list.ex:500 
msgid ""
"Returns an integer whose text representation is `char_list`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.to_integer('123')\n"
"    123\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.to_integer(char_list, base)
#: lib/list.ex:516 
msgid ""
"Returns an integer whose text representation is `char_list` in base `base`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.to_integer('3FF', 16)\n"
"    1023\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.to_tuple(list)
#: lib/list.ex:532 
msgid ""
"Converts a list to a tuple.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.to_tuple([:share, [:elixir, 163]])\n"
"    {:share, [:elixir, 163]}\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.to_string(list)
#: lib/list.ex:554 
msgid ""
"Converts a list of integers representing codepoints, lists or\n"
"strings into a string.\n"
"\n"
"Notice that this function expects a list of integers representing\n"
"UTF-8 codepoints. If you have a list of bytes, you must instead use\n"
"[the `:binary` module](http://erlang.org/doc/man/binary.html).\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.to_string([0x00E6, 0x00DF])\n"
"    \"æß\"\n"
"\n"
"    iex> List.to_string([0x0061, \"bc\"])\n"
"    \"abc\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.to_existing_atom(char_list)
#: lib/list.ex:468 
msgid ""
"Converts a char list to an existing atom.\n"
"\n"
"Currently Elixir does not support conversions from char lists\n"
"which contains Unicode codepoints greater than 0xFF.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def List.to_atom(char_list)
#: lib/list.ex:455 
msgid ""
"Converts a char list to an atom.\n"
"\n"
"Currently Elixir does not support conversions from char lists\n"
"which contains Unicode codepoints greater than 0xFF.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.to_atom('elixir')\n"
"    :elixir\n"
"\n"
msgstr ""
