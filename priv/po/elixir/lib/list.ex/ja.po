msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2015-12-16 23:29+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: def List.keydelete(list, key, position)
#: lib/list.ex:282
msgid ""
"Receives a list of tuples and deletes the first tuple\n"
"where the item at `position` matches the\n"
"given `key`. Returns the new list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.keydelete([a: 1, b: 2], :a, 0)\n"
"    [b: 2]\n"
"\n"
"    iex> List.keydelete([a: 1, b: 2], 2, 1)\n"
"    [a: 1]\n"
"\n"
"    iex> List.keydelete([a: 1, b: 2], :c, 0)\n"
"    [a: 1, b: 2]\n"
"\n"
msgstr ""
"タプルのリストを受け取り、`position`の位置のアイテムが\n"
"与えられた`item`にマッチする最初のタプルを削除します。\n"
"新しいリストを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.keydelete([a: 1, b: 2], :a, 0)\n"
"    [b: 2]\n"
"\n"
"    iex> List.keydelete([a: 1, b: 2], 2, 1)\n"
"    [a: 1]\n"
"\n"
"    iex> List.keydelete([a: 1, b: 2], :c, 0)\n"
"    [a: 1, b: 2]\n"
"\n"

#. TRANSLATORS: def List.first(list)
#: lib/list.ex:147
msgid ""
"Returns the first element in `list` or `nil` if `list` is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.first([])\n"
"    nil\n"
"\n"
"    iex> List.first([1])\n"
"    1\n"
"\n"
"    iex> List.first([1, 2, 3])\n"
"    1\n"
"\n"
msgstr ""
"`list`の最初の要素を返します。`list`が空なら`nil`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.first([])\n"
"    nil\n"
"\n"
"    iex> List.first([1])\n"
"    1\n"
"\n"
"    iex> List.first([1, 2, 3])\n"
"    1\n"
"\n"

#. TRANSLATORS: def List.flatten(list)
#: lib/list.ex:84
msgid ""
"Flattens the given `list` of nested lists.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.flatten([1, [[2], 3]])\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
"与えられた、ネストしたリスト`list`をフラット化します。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.flatten([1, [[2], 3]])\n"
"    [1, 2, 3]\n"
"\n"

#. TRANSLATORS: def List.replace_at(list, index, value)
#: lib/list.ex:410
msgid ""
"Returns a list with a replaced value at the specified `index`.\n"
"Negative indices indicate an offset from the end of the list.\n"
"If `index` is out of bounds, the original `list` is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.replace_at([1, 2, 3], 0, 0)\n"
"    [0, 2, 3]\n"
"\n"
"    iex> List.replace_at([1, 2, 3], 10, 0)\n"
"    [1, 2, 3]\n"
"\n"
"    iex> List.replace_at([1, 2, 3], -1, 0)\n"
"    [1, 2, 0]\n"
"\n"
"    iex> List.replace_at([1, 2, 3], -10, 0)\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
"`index`で指定された場所の値を入れ替えたリストを返します。\n"
"負のインデックスはリストの末尾からのオフセットを示します。\n"
"もし`index`が境界の外なら、オリジナルの`list`が返されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.replace_at([1, 2, 3], 0, 0)\n"
"    [0, 2, 3]\n"
"\n"
"    iex> List.replace_at([1, 2, 3], 10, 0)\n"
"    [1, 2, 3]\n"
"\n"
"    iex> List.replace_at([1, 2, 3], -1, 0)\n"
"    [1, 2, 0]\n"
"\n"
"    iex> List.replace_at([1, 2, 3], -10, 0)\n"
"    [1, 2, 3]\n"
"\n"

#. TRANSLATORS: def List.flatten(list, tail)
#: lib/list.ex:98
msgid ""
"Flattens the given `list` of nested lists.\n"
"The list `tail` will be added at the end of\n"
"the flattened list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.flatten([1, [[2], 3]], [4, 5])\n"
"    [1, 2, 3, 4, 5]\n"
"\n"
msgstr ""
"与えられた、ネストしたリスト`list`をフラット化します。\n"
"リスト`tail`はフラット化されたlistの終わりに追加されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.flatten([1, [[2], 3]], [4, 5])\n"
"    [1, 2, 3, 4, 5]\n"
"\n"

#. TRANSLATORS: def List.to_atom(char_list)
#: lib/list.ex:494
msgid ""
"Converts a char list to an atom.\n"
"\n"
"Currently Elixir does not support conversions from char lists\n"
"which contains Unicode codepoints greater than 0xFF.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.to_atom('elixir')\n"
"    :elixir\n"
"\n"
msgstr ""
"文字リストをアトムに変換します。\n"
"\n"
"現在のElixirは、0xFFを越えるUnicodeコードポイントを含む\n"
"文字リストからの変換をサポートしていません。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.to_atom('elixir')\n"
"    :elixir\n"
"\n"

#. TRANSLATORS: def List.update_at(list, index, fun)
#: lib/list.ex:439
msgid ""
"Returns a list with an updated value at the specified `index`.\n"
"Negative indices indicate an offset from the end of the list.\n"
"If `index` is out of bounds, the original `list` is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.update_at([1, 2, 3], 0, &(&1 + 10))\n"
"    [11, 2, 3]\n"
"\n"
"    iex> List.update_at([1, 2, 3], 10, &(&1 + 10))\n"
"    [1, 2, 3]\n"
"\n"
"    iex> List.update_at([1, 2, 3], -1, &(&1 + 10))\n"
"    [1, 2, 13]\n"
"\n"
"    iex> List.update_at([1, 2, 3], -10, &(&1 + 10))\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
"`index`で指定された場所の値をfunで更新したリストを返します。\n"
"負のインデックスはリストの末尾からのオフセットを示します。\n"
"もし`index`が境界の外なら、オリジナルの`list`が返されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.update_at([1, 2, 3], 0, &(&1 + 10))\n"
"    [11, 2, 3]\n"
"\n"
"    iex> List.update_at([1, 2, 3], 10, &(&1 + 10))\n"
"    [1, 2, 3]\n"
"\n"
"    iex> List.update_at([1, 2, 3], -1, &(&1 + 10))\n"
"    [1, 2, 13]\n"
"\n"
"    iex> List.update_at([1, 2, 3], -10, &(&1 + 10))\n"
"    [1, 2, 3]\n"
"\n"

#. TRANSLATORS: def List.to_string(list)
#: lib/list.ex:601
msgid ""
"Converts a list of integers representing codepoints, lists or\n"
"strings into a string.\n"
"\n"
"Notice that this function expects a list of integers representing\n"
"UTF-8 codepoints. If you have a list of bytes, you must instead use\n"
"the [`:binary` module](http://www.erlang.org/doc/man/binary.html).\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.to_string([0x00E6, 0x00DF])\n"
"    \"æß\"\n"
"\n"
"    iex> List.to_string([0x0061, \"bc\"])\n"
"    \"abc\"\n"
"\n"
msgstr ""
"コードポイントで表現された整数、リスト、文字列のリストを、\n"
"文字列に変換します。\n"
"\n"
"この関数は、UTF-8コードポイントで表現される整数のリストを期待している\n"
"ことに、注意してください。\n"
"もしバイトのリストをもっていたら、[`:binary`モジュール](http://erlang.org/"
"doc/man/binary.html)\n"
"を代りに使わなければなりません。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.to_string([0x00E6, 0x00DF])\n"
"    \"æß\"\n"
"\n"
"    iex> List.to_string([0x0061, \"bc\"])\n"
"    \"abc\"\n"
"\n"

#. TRANSLATORS: def List.to_float(char_list)
#: lib/list.ex:537
msgid ""
"Returns the float whose text representation is `char_list`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.to_float('2.2017764e+0')\n"
"    2.2017764\n"
"\n"
msgstr ""
"テキスト表現が`char_list`である浮動小数点数を返します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.to_float('2.2017764e+0')\n"
"    2.2017764\n"
"\n"

#. TRANSLATORS: def List.keytake(list, key, position)
#: lib/list.ex:304
msgid ""
"Receives a `list` of tuples and returns the first tuple\n"
"where the element at `position` in the tuple matches the\n"
"given `key`, as well as the `list` without found tuple.\n"
"\n"
"If such a tuple is not found, `nil` will be returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.keytake([a: 1, b: 2], :a, 0)\n"
"    {{:a, 1}, [b: 2]}\n"
"\n"
"    iex> List.keytake([a: 1, b: 2], 2, 1)\n"
"    {{:b, 2}, [a: 1]}\n"
"\n"
"    iex> List.keytake([a: 1, b: 2], :c, 0)\n"
"    nil\n"
"\n"
msgstr ""
"タプルのリストを受け取り、リストの各タプル内の\n"
"`position`番目のアイテムが、与えられた`key`にマッチする、\n"
"最初のタプルと、それを取り除いたリストで出来たタプルを返\n"
"します。\n"
"\n"
"そのようなタプルがない時は`nil`を返します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.keytake([a: 1, b: 2], :a, 0)\n"
"    {{:a, 1}, [b: 2]}\n"
"\n"
"    iex> List.keytake([a: 1, b: 2], 2, 1)\n"
"    {{:b, 2}, [a: 1]}\n"
"\n"
"    iex> List.keytake([a: 1, b: 2], :c, 0)\n"
"    nil\n"
"\n"

#. TRANSLATORS: def List.to_tuple(list)
#: lib/list.ex:585
msgid ""
"Converts a list to a tuple.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.to_tuple([:share, [:elixir, 163]])\n"
"    {:share, [:elixir, 163]}\n"
"\n"
msgstr ""
"リストをタプルに変換します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.to_tuple([:share, [:elixir, 163]])\n"
"    {:share, [:elixir, 163]}\n"
"\n"

#. TRANSLATORS: def List.keysort(list, position)
#: lib/list.ex:245
msgid ""
"Receives a list of tuples and sorts the items\n"
"at `position` of the tuples. The sort is stable.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.keysort([a: 5, b: 1, c: 3], 1)\n"
"    [b: 1, c: 3, a: 5]\n"
"\n"
"    iex> List.keysort([a: 5, c: 1, b: 3], 0)\n"
"    [a: 5, b: 3, c: 1]\n"
"\n"
msgstr ""
"タプルの`position`でアイテムをソートしタプルのリストを返します。\n"
"ソートは安定的です。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.keysort([a: 5, b: 1, c: 3], 1)\n"
"    [b: 1, c: 3, a: 5]\n"
"\n"
"    iex> List.keysort([a: 5, c: 1, b: 3], 0)\n"
"    [a: 5, b: 3, c: 1]\n"
"\n"

#. TRANSLATORS: def List.to_integer(char_list)
#: lib/list.ex:553
msgid ""
"Returns an integer whose text representation is `char_list`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.to_integer('123')\n"
"    123\n"
"\n"
msgstr ""
"テキスト表現が`char_list`である整数を返します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.to_integer('123')\n"
"    123\n"
"\n"

#. TRANSLATORS: def List.to_integer(char_list, base)
#: lib/list.ex:569
msgid ""
"Returns an integer whose text representation is `char_list` in base `base`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.to_integer('3FF', 16)\n"
"    1023\n"
"\n"
msgstr ""
"テキスト表現が基数`base`の`char_list`である整数を返します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.to_integer('3FF', 16)\n"
"    1023\n"
"\n"

#. TRANSLATORS: def List.keyfind(list, key, position, default \\ nil)
#: lib/list.ex:186
msgid ""
"Receives a list of tuples and returns the first tuple\n"
"where the item at `position` in the tuple matches the\n"
"given `key`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.keyfind([a: 1, b: 2], :a, 0)\n"
"    {:a, 1}\n"
"\n"
"    iex> List.keyfind([a: 1, b: 2], 2, 1)\n"
"    {:b, 2}\n"
"\n"
"    iex> List.keyfind([a: 1, b: 2], :c, 0)\n"
"    nil\n"
"\n"
msgstr ""
"タプルのリストを受け取り、リストの各タプル内の`position`番目のアイテム\n"
"が、与えられた`key`にマッチする、最初のタプルを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.keyfind([a: 1, b: 2], :a, 0)\n"
"    {:a, 1}\n"
"\n"
"    iex> List.keyfind([a: 1, b: 2], 2, 1)\n"
"    {:b, 2}\n"
"\n"
"    iex> List.keyfind([a: 1, b: 2], :c, 0)\n"
"    nil\n"
"\n"

#. TRANSLATORS: def List.insert_at(list, index, value)
#: lib/list.ex:381
msgid ""
"Returns a list with `value` inserted at the specified `index`.\n"
"Note that `index` is capped at the list length. Negative indices\n"
"indicate an offset from the end of the list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.insert_at([1, 2, 3, 4], 2, 0)\n"
"    [1, 2, 0, 3, 4]\n"
"\n"
"    iex> List.insert_at([1, 2, 3], 10, 0)\n"
"    [1, 2, 3, 0]\n"
"\n"
"    iex> List.insert_at([1, 2, 3], -1, 0)\n"
"    [1, 2, 3, 0]\n"
"\n"
"    iex> List.insert_at([1, 2, 3], -10, 0)\n"
"    [0, 1, 2, 3]\n"
"\n"
msgstr ""
"`value`を指定された`index`の位置に挿入したリストを返します。\n"
"`index`は、リストの長さでキャップされることに注意してください。\n"
"負のインデックスはリストの末尾からのオフセットを指示します。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.insert_at([1, 2, 3, 4], 2, 0)\n"
"    [1, 2, 0, 3, 4]\n"
"\n"
"    iex> List.insert_at([1, 2, 3], 10, 0)\n"
"    [1, 2, 3, 0]\n"
"\n"
"    iex> List.insert_at([1, 2, 3], -1, 0)\n"
"    [1, 2, 3, 0]\n"
"\n"
"    iex> List.insert_at([1, 2, 3], -10, 0)\n"
"    [0, 1, 2, 3]\n"
"\n"

#. TRANSLATORS: Elixir.List Summary
#: lib/list.ex:2
msgid ""
"Specialized functions that only work on lists.\n"
"\n"
"In general, favor using the `Enum` API instead of `List`.\n"
"\n"
"Index access for list is linear. Negative indexes are also\n"
"supported but they imply the list will be iterated twice,\n"
"one to calculate the proper index and another to perform the\n"
"operation.\n"
"\n"
"A decision was taken to delegate most functions to\n"
"Erlang's standard library but follow Elixir's convention\n"
"of receiving the subject (in this case, a list) as the\n"
"first argument.\n"
"\n"
"## Char lists\n"
"\n"
"If a list is made of non-negative integers, it can also\n"
"be called as a char list. Elixir uses single quotes to\n"
"define char lists:\n"
"\n"
"    iex> 'héllo'\n"
"    [104, 233, 108, 108, 111]\n"
"\n"
"In particular, char lists may be printed back in single\n"
"quotes if they contain only ASCII-printable codepoints:\n"
"\n"
"    iex> 'abc'\n"
"    'abc'\n"
"\n"
"The rationale behind this behaviour is to better support\n"
"Erlang libraries which may return text as char lists\n"
"instead of Elixir strings. One example of such functions\n"
"is `Application.loaded_applications`:\n"
"\n"
"    Application.loaded_applications\n"
"    #=>  [{:stdlib, 'ERTS  CXC 138 10', '2.6'},\n"
"          {:compiler, 'ERTS  CXC 138 10', '6.0.1'},\n"
"          {:elixir, 'elixir', '1.0.0'},\n"
"          {:kernel, 'ERTS  CXC 138 10', '4.1'},\n"
"          {:logger, 'logger', '1.0.0'}]\n"
msgstr ""
"リストでのみ働く特別な関数です。\n"
"\n"
"一般に、`List`の代りに`Enum` API を使うことを好みます。\n"
"\n"
"リストのインデックスアクセスは線形の時間が掛ります。\n"
"負のインデックスもサポートされていますが、リストは\n"
"暗黙的に2囘走査されます。一つは適切なインデックスを\n"
"計算するために、そしてもう一つは操作を実行するためです。\n"
"\n"
"\n"
"Erlangの標準ライブラリに殆どの関数は委譲することを決定\n"
"しましたが、最初の引数として処理対象(この場合、\n"
"リストです)を渡すというElixirの習慣に従っています。\n"
"\n"
"## Char lists\n"
"\n"
"もしリストが非負整数で作られたなら、それはchar listとも\n"
"呼ばれることもあります。Elixirはchar listを定義する\n"
"為にシングルクォーテーションを使います:\n"
"\n"
"    iex> 'héllo'\n"
"    [104, 233, 108, 108, 111]\n"
"\n"
"具体的には、char listはASCII-printableコードポイントのみを\n"
"含むなら、シングルクォーテーションでプリントバックされる\n"
"でしょう:\n"
"\n"
"    iex> 'abc'\n"
"    'abc'\n"
"\n"
"この振る舞いの背後の理論的根拠はElixir文字列の代りに\n"
"char listとしてテキストを返すErlangライブラリのよりよい\n"
"サポートのためです。そのような関数の一つの例が\n"
"`Application.loaded_applications`です:\n"
"\n"
"    Application.loaded_applications\n"
"    #=>  [{:stdlib, 'ERTS  CXC 138 10', '2.6'},\n"
"          {:compiler, 'ERTS  CXC 138 10', '6.0.1'},\n"
"          {:elixir, 'elixir', '1.0.0'},\n"
"          {:kernel, 'ERTS  CXC 138 10', '4.1'},\n"
"          {:logger, 'logger', '1.0.0'}]\n"

#. TRANSLATORS: def List.last(list)
#: lib/list.ex:166
msgid ""
"Returns the last element in `list` or `nil` if `list` is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.last([])\n"
"    nil\n"
"\n"
"    iex> List.last([1])\n"
"    1\n"
"\n"
"    iex> List.last([1, 2, 3])\n"
"    3\n"
"\n"
msgstr ""
"`list`の最後の要素、または`list`が空なら`nil`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.last([])\n"
"    nil\n"
"\n"
"    iex> List.last([1])\n"
"    1\n"
"\n"
"    iex> List.last([1, 2, 3])\n"
"    3\n"
"\n"

#. TRANSLATORS: def List.foldr(list, acc, function)
#: lib/list.ex:132
msgid ""
"Folds (reduces) the given list from the right with\n"
"a function. Requires an accumulator.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.foldr([1, 2, 3, 4], 0, fn (x, acc) -> x - acc end)\n"
"    -2\n"
"\n"
msgstr ""
"与えられたリストを、関数で右からフォールド(reduce)ます。\n"
"アキュムレータは必須です。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.foldr([1, 2, 3, 4], 0, fn (x, acc) -> x - acc end)\n"
"    -2\n"
"\n"

#. TRANSLATORS: def List.foldl(list, acc, function)
#: lib/list.ex:114
msgid ""
"Folds (reduces) the given list from the left with\n"
"a function. Requires an accumulator.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.foldl([5, 5], 10, fn (x, acc) -> x + acc end)\n"
"    20\n"
"\n"
"    iex> List.foldl([1, 2, 3, 4], 0, fn (x, acc) -> x - acc end)\n"
"    2\n"
"\n"
msgstr ""
"与えられたリストを、関数で左からフォールド(reduce)ます。\n"
"アキュムレータは必須です。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.foldl([5, 5], 10, fn (x, acc) -> x + acc end)\n"
"    20\n"
"\n"
"    iex> List.foldl([1, 2, 3, 4], 0, fn (x, acc) -> x - acc end)\n"
"    2\n"
"\n"

#. TRANSLATORS: def List.delete(list, item)
#: lib/list.ex:47
msgid ""
"Deletes the given item from the list. Returns a list without\n"
"the item. If the item occurs more than once in the list, just\n"
"the first occurrence is removed.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.delete([1, 2, 3], 1)\n"
"    [2, 3]\n"
"\n"
"    iex> List.delete([1, 2, 2, 3], 2)\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
"リストから与えられたアイテムを削除します。\n"
"そのアイテムを除いたリストを返します。\n"
"もしリストに一つより多くのアイテムがあったら、\n"
"最初の一つだけが削除されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.delete([1, 2, 3], 1)\n"
"    [2,3]\n"
"\n"
"    iex> List.delete([1, 2, 2, 3], 2)\n"
"    [1, 2, 3]\n"
"\n"

#. TRANSLATORS: def List.wrap(list)
#: lib/list.ex:331
msgid ""
"Wraps the argument in a list.\n"
"If the argument is already a list, returns the list.\n"
"If the argument is `nil`, returns an empty list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.wrap(\"hello\")\n"
"    [\"hello\"]\n"
"\n"
"    iex> List.wrap([1, 2, 3])\n"
"    [1, 2, 3]\n"
"\n"
"    iex> List.wrap(nil)\n"
"    []\n"
"\n"
msgstr ""
"リストに引数をラップします。\n"
"もし引数が既にリストなら、そのリストを返します。\n"
"もし引数が`nil`なら、空のリストを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.wrap(\"hello\")\n"
"    [\"hello\"]\n"
"\n"
"    iex> List.wrap([1, 2, 3])\n"
"    [1, 2, 3]\n"
"\n"
"    iex> List.wrap(nil)\n"
"    []\n"
"\n"

#. TRANSLATORS: def List.keymember?(list, key, position)
#: lib/list.ex:208
msgid ""
"Receives a list of tuples and returns `true` if there is\n"
"a tuple where the item at `position` in the tuple matches\n"
"the given `key`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.keymember?([a: 1, b: 2], :a, 0)\n"
"    true\n"
"\n"
"    iex> List.keymember?([a: 1, b: 2], 2, 1)\n"
"    true\n"
"\n"
"    iex> List.keymember?([a: 1, b: 2], :c, 0)\n"
"    false\n"
"\n"
msgstr ""
"タプルのリストを受け取り、リストの各タプル内の`position`番目のアイテム\n"
"が、与えられた`item`にマッチするタプルがあれば、`true`を\n"
"返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.keymember?([a: 1, b: 2], :a, 0)\n"
"    true\n"
"\n"
"    iex> List.keymember?([a: 1, b: 2], 2, 1)\n"
"    true\n"
"\n"
"    iex> List.keymember?([a: 1, b: 2], :c, 0)\n"
"    false\n"
"\n"

#. TRANSLATORS: def List.delete_at(list, index)
#: lib/list.ex:468
msgid ""
"Produces a new list by removing the value at the specified `index`.\n"
"Negative indices indicate an offset from the end of the list.\n"
"If `index` is out of bounds, the original `list` is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.delete_at([1, 2, 3], 0)\n"
"    [2, 3]\n"
"\n"
"    iex> List.delete_at([1, 2, 3], 10)\n"
"    [1, 2, 3]\n"
"\n"
"    iex> List.delete_at([1, 2, 3], -1)\n"
"    [1, 2]\n"
"\n"
msgstr ""
"指定された`index`の値を削除した、新しいリストを提供します。\n"
"負のインデックスはリストの終わりからのオフセットを示します。\n"
"もし`index`が範囲外なら、オリジナルの`list`が返されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.delete_at([1, 2, 3], 0)\n"
"    [2, 3]\n"
"\n"
"    iex List.delete_at([1, 2, 3], 10)\n"
"    [1, 2, 3]\n"
"\n"
"    iex> List.delete_at([1, 2, 3], -1)\n"
"    [1, 2]\n"
"\n"

#. TRANSLATORS: def List.keyreplace(list, key, position, new_tuple)
#: lib/list.ex:230
msgid ""
"Receives a list of tuples and replaces the item\n"
"identified by `key` at `position` if it exists.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.keyreplace([a: 1, b: 2], :a, 0, {:a, 3})\n"
"    [a: 3, b: 2]\n"
"\n"
msgstr ""
"タプルのリストを受け取り、もしあれば、`position`の位置の\n"
"`key`により指定されたアイテムを置き換えます。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.keyreplace([a: 1, b: 2], :a, 0, {:a, 3})\n"
"    [a: 3, b: 2]\n"
"\n"

#. TRANSLATORS: def List.duplicate(elem, n)
#: lib/list.ex:66
msgid ""
"Duplicates the given element `n` times in a list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.duplicate(\"hello\", 3)\n"
"    [\"hello\", \"hello\", \"hello\"]\n"
"\n"
"    iex> List.duplicate([1, 2], 2)\n"
"    [[1, 2], [1, 2]]\n"
"\n"
"\n"
msgstr ""
"リストの与えられた要素を`n`回複製します。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.duplicate(\"hello\", 3)\n"
"    [\"hello\", \"hello\", \"hello\"]\n"
"\n"
"    iex> List.duplicate([1, 2], 2)\n"
"    [[1, 2], [1, 2]]\n"
"\n"

#. TRANSLATORS: def List.zip(list_of_lists)
#: lib/list.ex:361
msgid ""
"Zips corresponding elements from each list in `list_of_lists`.\n"
"\n"
"The zipping finishes as soon as any list terminates.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.zip([[1, 2], [3, 4], [5, 6]])\n"
"    [{1, 3, 5}, {2, 4, 6}]\n"
"\n"
"    iex> List.zip([[1, 2], [3], [5, 6]])\n"
"    [{1, 3, 5}]\n"
"\n"
msgstr ""
"`list_of_list`のそれぞれのリストから対応する要素をzipします。\n"
"\n"
"どれかのリストが終了するとすぐに、zippingも終了します。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.zip([[1, 2], [3, 4], [5, 6]])\n"
"    [{1, 3, 5}, {2, 4, 6}]\n"
"\n"
"    iex> List.zip([[1, 2], [3], [5, 6]])\n"
"    [{1, 3, 5}]\n"
"\n"

#. TRANSLATORS: def List.keystore(list, key, position, new_tuple)
#: lib/list.ex:263
msgid ""
"Receives a list of tuples and replaces the item\n"
"identified by `key` at `position`. If the item\n"
"does not exist, it is added to the end of the list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.keystore([a: 1, b: 2], :a, 0, {:a, 3})\n"
"    [a: 3, b: 2]\n"
"\n"
"    iex> List.keystore([a: 1, b: 2], :c, 0, {:c, 3})\n"
"    [a: 1, b: 2, c: 3]\n"
"\n"
msgstr ""
"タプルのリストを受け取り、`position`の位置の`key`により指定された、アイ\n"
"テムを置き換えます。アイテムが存在しないなら、それは、リストの末尾に追\n"
"加されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.keystore([a: 1, b: 2], :a, 0, {:a, 3})\n"
"    [a: 3, b: 2]\n"
"\n"
"    iex> List.keystore([a: 1, b: 2], :c, 0, {:c, 3})\n"
"    [a: 1, b: 2, c: 3]\n"
"\n"

#. TRANSLATORS: def List.to_existing_atom(char_list)
#: lib/list.ex:513
msgid ""
"Converts a char list to an existing atom. Raises an `ArgumentError`\n"
"if the atom does not exist.\n"
"\n"
"Currently Elixir does not support conversions from char lists\n"
"which contains Unicode codepoints greater than 0xFF.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> _ = :my_atom\n"
"    iex> List.to_existing_atom('my_atom')\n"
"    :my_atom\n"
"\n"
"    iex> List.to_existing_atom('this_atom_will_never_exist')\n"
"    ** (ArgumentError) argument error\n"
"\n"
msgstr ""
"文字リストを既存のatomに変換します。もしatomが存在しないなら\n"
"`ArgumentError`が上ります。\n"
"\n"
"現在のElixirは、0xFFを越えるUnicodeコードポイントを含む\n"
"文字リストからの変換をサポートしていません。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> _ = :my_atom\n"
"    iex> List.to_existing_atom('my_atom')\n"
"    :my_atom\n"
"\n"
"    iex> List.to_existing_atom('this_atom_will_never_exist')\n"
"    ** (ArgumentError) argument error\n"
"\n"
