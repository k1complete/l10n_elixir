msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2015-05-20 21:54+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: Elixir.Set Summary
#: lib/set.ex:1
msgid ""
"This module specifies the Set API expected to be\n"
"implemented by different representations.\n"
"\n"
"It also provides functions that redirect to the\n"
"underlying Set, allowing a developer to work with\n"
"different Set implementations using one API.\n"
"\n"
"To create a new set, use the `new` functions defined\n"
"by each set type:\n"
"\n"
"    HashSet.new  #=> creates an empty HashSet\n"
"\n"
"In the examples below, `set_impl` means a specific\n"
"`Set` implementation, for example `HashSet`.\n"
"\n"
"## Protocols\n"
"\n"
"Sets are required to implement both `Enumerable` and `Collectable`\n"
"protocols.\n"
"\n"
"## Match\n"
"\n"
"Sets are required to implement all operations using the match (`===`)\n"
"operator.\n"
msgstr ""
"このモジュールは異った表現による実装に期待されるべき、Set API仕様を\n"
"指定します。\n"
"\n"
"一つのAPIを使って異るSetの実装で開発者が仕事をすることを許す、基礎をな\n"
"すSetへリダイレクトする関数も提供します。\n"
"\n"
"新しい集合を作成するために、それぞれの集合のタイプ毎に\n"
"定義された`new`関数を使います:\n"
"\n"
"    HashSet.new  #=> creates an empty HashSet\n"
"\n"
"下の例では、`set_impl`は特定の`Set`実装、例えば`HashSet`を意味します。\n"
"\n"
"## プロトコル\n"
"\n"
"Setは`Enumerable`と`Collectable`プロトコルの両方の実装を要求します。\n"
"\n"
"## マッチ\n"
"\n"
"Setは実装をマッチオペレータ(`===`)を使う全ての操作の実装を\n"
"要求します。\n"

#. TRANSLATORS: def Set.delete(set, value)
#: lib/set.ex:74
msgid ""
"Deletes `value` from `set`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> s = Enum.into([1, 2, 3], set_impl.new)\n"
"    iex> Set.delete(s, 4) |> Enum.sort\n"
"    [1, 2, 3]\n"
"\n"
"    iex> s = Enum.into([1, 2, 3], set_impl.new)\n"
"    iex> Set.delete(s, 2) |> Enum.sort\n"
"    [1, 3]\n"
"\n"
msgstr ""
"`set`から`value`を削除します。\n"
"\n"
"## 例\n"
"\n"
"    iex> s = Enum.into([1, 2, 3], set_impl.new)\n"
"    iex> Set.delete(s, 4) |> Enum.sort\n"
"    [1, 2, 3]\n"
"\n"
"    iex> s = Enum.into([1, 2, 3], set_impl.new)\n"
"    iex> Set.delete(s, 2) |> Enum.sort\n"
"    [1, 3]\n"
"\n"

#. TRANSLATORS: def Set.put(set, value)
#: lib/set.ex:237
msgid ""
"Inserts `value` into `set` if it does not already contain it.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Set.put(Enum.into([1, 2, 3], set_impl.new), 3) |> Enum.sort\n"
"    [1, 2, 3]\n"
"\n"
"    iex> Set.put(Enum.into([1, 2, 3], set_impl.new), 4) |> Enum.sort\n"
"    [1, 2, 3, 4]\n"
"\n"
msgstr ""
"もしまだそれを含んでいないなら、`set`に`value`を挿入します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Set.put(Enum.into([1, 2, 3], set_impl.new), 3) |> Enum.sort\n"
"    [1, 2, 3]\n"
"\n"
"    iex> Set.put(Enum.into([1, 2, 3], set_impl.new), 4) |> Enum.sort\n"
"    [1, 2, 3, 4]\n"
"\n"

#. TRANSLATORS: def Set.equal?(set1, set2)
#: lib/set.ex:161
msgid ""
"Checks if two sets are equal using `===`.\n"
"\n"
"Notice this function is polymorphic as it compares sets of\n"
"any type. Each set implementation also provides an `equal?`\n"
"function, but they can only work with sets of the same type.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Set.equal?(Enum.into([1, 2], set_impl.new), Enum.into([2, 1, 1], "
"set_impl.new))\n"
"    true\n"
"\n"
"    iex> Set.equal?(Enum.into([1, 2], set_impl.new), Enum.into([3, 4], "
"set_impl.new))\n"
"    false\n"
"\n"
msgstr ""
"`===`を使って二つのsetが等しいかを\n"
"チェックします。\n"
"\n"
"任意のタイプのsetの比較をするので、この関数はポリモーフィック(多態的)\n"
"であることに注意してください。\n"
"それぞれのset実装も、`equal?`関数を提供しますが、それらは同じタイプの\n"
"set同士で動作するだけです。\n"
"\n"
"## 例\n"
"\n"
"    iex> Set.equal?(Enum.into([1, 2], set_impl.new), Enum.into([2, 1, 1], "
"set_impl.new))\n"
"    true\n"
"\n"
"    iex> Set.equal?(Enum.into([1, 2], set_impl.new), Enum.into([3, 4], "
"set_impl.new))\n"
"    false\n"
"\n"

#. TRANSLATORS: def Set.member?(set, value)
#: lib/set.ex:220
msgid ""
"Checks if `set` contains `value`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Set.member?(Enum.into([1, 2, 3], set_impl.new), 2)\n"
"    true\n"
"\n"
"    iex> Set.member?(Enum.into([1, 2, 3], set_impl.new), 4)\n"
"    false\n"
"\n"
msgstr ""
"`set`が`value`を含んでいるかをチェックします。\n"
"\n"
"## 例\n"
"\n"
"    iex> Set.member?(Enum.into([1, 2, 3], set_impl.new), 2)\n"
"    true\n"
"\n"
"    iex> Set.member?(Enum.into([1, 2, 3], set_impl.new), 4)\n"
"    false\n"
"\n"

#. TRANSLATORS: def Set.subset?(set1, set2)
#: lib/set.ex:272
msgid ""
"Checks if `set1`'s members are all contained in `set2`.\n"
"\n"
"Notice this function is polymorphic as it checks the subset for\n"
"any type. Each set implementation also provides a `subset?` function,\n"
"but they can only work with sets of the same type.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Set.subset?(Enum.into([1, 2], set_impl.new), Enum.into([1, 2, 3], "
"set_impl.new))\n"
"    true\n"
"\n"
"    iex> Set.subset?(Enum.into([1, 2, 3], set_impl.new), Enum.into([1, 2], "
"set_impl.new))\n"
"    false\n"
"\n"
msgstr ""
"`set1`のメンバが`set2`に全て含まれているかチェックします。\n"
"\n"
"任意のタイプのsubsetをチェックするので、この関数はポリモーフィック(多態的)\n"
"であることに注意してください。\n"
"それぞれのset実装も、`subset?`関数を提供しますが、それらは同じタイプの\n"
"set同士で動作するだけです。\n"
"\n"
"## 例\n"
"\n"
"    iex> Set.subset?(Enum.into([1, 2], set_impl.new), Enum.into([1, 2, 3], "
"set_impl.new))\n"
"    true\n"
"\n"
"    iex> Set.subset?(Enum.into([1, 2, 3], set_impl.new), Enum.into([1, 2], "
"set_impl.new))\n"
"    false\n"
"\n"

#. TRANSLATORS: def Set.disjoint?(set1, set2)
#: lib/set.ex:122
msgid ""
"Checks if `set1` and `set2` have no members in common.\n"
"\n"
"Notice this function is polymorphic as it checks for disjoint sets of\n"
"any type. Each set implementation also provides a `disjoint?` function,\n"
"but they can only work with sets of the same type.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Set.disjoint?(Enum.into([1, 2], set_impl.new), Enum.into([3, 4], "
"set_impl.new))\n"
"    true\n"
"\n"
"    iex> Set.disjoint?(Enum.into([1, 2], set_impl.new), Enum.into([2, 3], "
"set_impl.new))\n"
"    false\n"
"\n"
msgstr ""
"`set1`と`set2`が共通のメンバを持っていないかを\n"
"チェックします。\n"
"\n"
"任意のタイプのdisjointをチェックするので、この関数はポリモーフィック(多態"
"的)\n"
"であることに注意してください。\n"
"それぞれのset実装も、`disjoint?`関数を提供しますが、それらは同じタイプの\n"
"set同士で動作するだけです。\n"
"\n"
"## 例\n"
"\n"
"    iex> Set.disjoint?(Enum.into([1, 2], set_impl.new), Enum.into([3, 4], "
"set_impl.new))\n"
"    true\n"
"\n"
"    iex> Set.disjoint?(Enum.into([1, 2], set_impl.new), Enum.into([2, 3], "
"set_impl.new))\n"
"    false\n"
"\n"

#. TRANSLATORS: def Set.size(set)
#: lib/set.ex:251
msgid ""
"Returns the number of elements in `set`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Set.size(Enum.into([1, 2, 3], set_impl.new))\n"
"    3\n"
"\n"
msgstr ""
"`set`の要素の数を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Set.size(Enum.into([1, 2, 3], set_impl.new))\n"
"    3\n"
"\n"

#. TRANSLATORS: def Set.difference(set1, set2)
#: lib/set.ex:92
msgid ""
"Returns a set that is `set1` without the members of `set2`.\n"
"\n"
"Notice this function is polymorphic as it calculates the difference\n"
"for of any type. Each set implementation also provides a `difference`\n"
"function, but they can only work with sets of the same type.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Set.difference(Enum.into([1,2], set_impl.new), Enum.into([2,3,4], "
"set_impl.new)) |> Enum.sort\n"
"    [1]\n"
"\n"
msgstr ""
"`set1`から`set2`のメンバを取り除いた集合を返します。\n"
"\n"
"この関数は、任意のタイプの差を計算するので、polymorphic(多態的) であること"
"に\n"
"注意してください。集合のそれぞれの実装は、`difference`関数も\n"
"提供しますが、それらは同じタイプの集合で動くことができる\n"
"だけです。\n"
"\n"
"## 例\n"
"\n"
"    iex> Set.difference(Enum.into([1,2], set_impl.new), Enum.into([2,3,4], "
"set_impl.new)) |> Enum.sort\n"
"    [1]\n"
"\n"

#. TRANSLATORS: def Set.intersection(set1, set2)
#: lib/set.ex:194
msgid ""
"Returns a set containing only members in common between `set1` and `set2`.\n"
"\n"
"Notice this function is polymorphic as it calculates the intersection of\n"
"any type. Each set implementation also provides a `intersection` function,\n"
"but they can only work with sets of the same type.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Set.intersection(Enum.into([1,2], set_impl.new), Enum.into([2,3,4], "
"set_impl.new)) |> Enum.sort\n"
"    [2]\n"
"\n"
"    iex> Set.intersection(Enum.into([1,2], set_impl.new), Enum.into([3,4], "
"set_impl.new)) |> Enum.sort\n"
"    []\n"
"\n"
msgstr ""
"`set1`と`set2`の共通のメンバを含む集合を返します。\n"
"\n"
"この関数は、任意のタイプの共通部分を計算するので、polymorphic であることに\n"
"注意してください。集合のそれぞれの実装は、`intersection`関数も\n"
"提供しますが、それらは同じタイプの集合で動くことができる\n"
"だけです。\n"
"\n"
"## 例\n"
"\n"
"    iex> Set.intersection(Enum.into([1,2], set_impl.new), Enum.into([2,3,4], "
"set_impl.new)) |> Enum.sort\n"
"    [2]\n"
"\n"
"    iex> Set.intersection(Enum.into([1,2], set_impl.new), Enum.into([3,4], "
"set_impl.new)) |> Enum.sort\n"
"    []\n"
"\n"

#. TRANSLATORS: def Set.to_list(set)
#: lib/set.ex:293
msgid ""
"Converts `set` to a list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> set_impl.to_list(Enum.into([1, 2, 3], set_impl.new)) |> Enum.sort\n"
"    [1,2,3]\n"
"\n"
msgstr ""
"`set`をリストに変換します。\n"
"\n"
"## 例\n"
"\n"
"    iex> set_impl.to_list(Enum.into([1, 2, 3], set_impl.new)) |> Enum.sort\n"
"    [1,2,3]\n"
"\n"

#. TRANSLATORS: def Set.union(set1, set2)
#: lib/set.ex:311
msgid ""
"Returns a set containing all members of `set1` and `set2`.\n"
"\n"
"Notice this function is polymorphic as it calculates the union of\n"
"any type. Each set implementation also provides a `union` function,\n"
"but they can only work with sets of the same type.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Set.union(Enum.into([1,2], set_impl.new), Enum.into([2,3,4], "
"set_impl.new)) |> Enum.sort\n"
"    [1,2,3,4]\n"
"\n"
msgstr ""
"`set1`と`set2`の全てのメンバを含む集合を返します。\n"
"\n"
"この関数は、任意のタイプの和集合を計算するので、polymorphic であることに\n"
"注意してください。集合のそれぞれの実装は、`union`関数も\n"
"提供しますが、それらは同じタイプの集合で動くことができる\n"
"だけです。\n"
"\n"
"## 例\n"
"\n"
"    iex> Set.union(Enum.into([1,2], set_impl.new), Enum.into([2,3,4], "
"set_impl.new)) |> Enum.sort\n"
"    [1,2,3,4]\n"
"\n"
