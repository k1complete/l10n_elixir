#. TRANSLATORS: Elixir.Set Summary
#: lib/set.ex:1 
msgid ""
"This module specifies the Set API expected to be\n"
"implemented by different representations.\n"
"\n"
"It also provides functions that redirect to the\n"
"underlying Set, allowing a developer to work with\n"
"different Set implementations using one API.\n"
"\n"
"To create a new set, use the `new` functions defined\n"
"by each set type:\n"
"\n"
"    HashSet.new  #=> creates an empty HashSet\n"
"\n"
"In the examples below, `set_impl` means a specific\n"
"`Set` implementation, for example `HashSet`.\n"
"\n"
"## Protocols\n"
"\n"
"Sets are required to implement both `Enumerable` and `Collectable`\n"
"protocols.\n"
"\n"
"## Match\n"
"\n"
"Sets are required to implement all operations using the match (`===`)\n"
"operator.\n"
msgstr ""
#. TRANSLATORS: def Set.delete(set, value)
#: lib/set.ex:74 
msgid ""
"Deletes `value` from `set`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> s = Enum.into([1, 2, 3], set_impl.new)\n"
"    iex> Set.delete(s, 4) |> Enum.sort\n"
"    [1, 2, 3]\n"
"\n"
"    iex> s = Enum.into([1, 2, 3], set_impl.new)\n"
"    iex> Set.delete(s, 2) |> Enum.sort\n"
"    [1, 3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Set.put(set, value)
#: lib/set.ex:237 
msgid ""
"Inserts `value` into `set` if it does not already contain it.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Set.put(Enum.into([1, 2, 3], set_impl.new), 3) |> Enum.sort\n"
"    [1, 2, 3]\n"
"\n"
"    iex> Set.put(Enum.into([1, 2, 3], set_impl.new), 4) |> Enum.sort\n"
"    [1, 2, 3, 4]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Set.equal?(set1, set2)
#: lib/set.ex:161 
msgid ""
"Checks if two sets are equal using `===`.\n"
"\n"
"Notice this function is polymorphic as it compares sets of\n"
"any type. Each set implementation also provides an `equal?`\n"
"function, but they can only work with sets of the same type.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Set.equal?(Enum.into([1, 2], set_impl.new), Enum.into([2, 1, 1], set_impl.new))\n"
"    true\n"
"\n"
"    iex> Set.equal?(Enum.into([1, 2], set_impl.new), Enum.into([3, 4], set_impl.new))\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Set.member?(set, value)
#: lib/set.ex:220 
msgid ""
"Checks if `set` contains `value`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Set.member?(Enum.into([1, 2, 3], set_impl.new), 2)\n"
"    true\n"
"\n"
"    iex> Set.member?(Enum.into([1, 2, 3], set_impl.new), 4)\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Set.subset?(set1, set2)
#: lib/set.ex:272 
msgid ""
"Checks if `set1`'s members are all contained in `set2`.\n"
"\n"
"Notice this function is polymorphic as it checks the subset for\n"
"any type. Each set implementation also provides a `subset?` function,\n"
"but they can only work with sets of the same type.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Set.subset?(Enum.into([1, 2], set_impl.new), Enum.into([1, 2, 3], set_impl.new))\n"
"    true\n"
"\n"
"    iex> Set.subset?(Enum.into([1, 2, 3], set_impl.new), Enum.into([1, 2], set_impl.new))\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Set.disjoint?(set1, set2)
#: lib/set.ex:122 
msgid ""
"Checks if `set1` and `set2` have no members in common.\n"
"\n"
"Notice this function is polymorphic as it checks for disjoint sets of\n"
"any type. Each set implementation also provides a `disjoint?` function,\n"
"but they can only work with sets of the same type.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Set.disjoint?(Enum.into([1, 2], set_impl.new), Enum.into([3, 4], set_impl.new))\n"
"    true\n"
"\n"
"    iex> Set.disjoint?(Enum.into([1, 2], set_impl.new), Enum.into([2, 3], set_impl.new))\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Set.size(set)
#: lib/set.ex:251 
msgid ""
"Returns the number of elements in `set`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Set.size(Enum.into([1, 2, 3], set_impl.new))\n"
"    3\n"
"\n"
msgstr ""
#. TRANSLATORS: def Set.difference(set1, set2)
#: lib/set.ex:92 
msgid ""
"Returns a set that is `set1` without the members of `set2`.\n"
"\n"
"Notice this function is polymorphic as it calculates the difference\n"
"for of any type. Each set implementation also provides a `difference`\n"
"function, but they can only work with sets of the same type.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Set.difference(Enum.into([1,2], set_impl.new), Enum.into([2,3,4], set_impl.new)) |> Enum.sort\n"
"    [1]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Set.intersection(set1, set2)
#: lib/set.ex:194 
msgid ""
"Returns a set containing only members in common between `set1` and `set2`.\n"
"\n"
"Notice this function is polymorphic as it calculates the intersection of\n"
"any type. Each set implementation also provides a `intersection` function,\n"
"but they can only work with sets of the same type.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Set.intersection(Enum.into([1,2], set_impl.new), Enum.into([2,3,4], set_impl.new)) |> Enum.sort\n"
"    [2]\n"
"\n"
"    iex> Set.intersection(Enum.into([1,2], set_impl.new), Enum.into([3,4], set_impl.new)) |> Enum.sort\n"
"    []\n"
"\n"
msgstr ""
#. TRANSLATORS: def Set.to_list(set)
#: lib/set.ex:293 
msgid ""
"Converts `set` to a list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> set_impl.to_list(Enum.into([1, 2, 3], set_impl.new)) |> Enum.sort\n"
"    [1,2,3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Set.union(set1, set2)
#: lib/set.ex:311 
msgid ""
"Returns a set containing all members of `set1` and `set2`.\n"
"\n"
"Notice this function is polymorphic as it calculates the union of\n"
"any type. Each set implementation also provides a `union` function,\n"
"but they can only work with sets of the same type.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Set.union(Enum.into([1,2], set_impl.new), Enum.into([2,3,4], set_impl.new)) |> Enum.sort\n"
"    [1,2,3,4]\n"
"\n"
msgstr ""
