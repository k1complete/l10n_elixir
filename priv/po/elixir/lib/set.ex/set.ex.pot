#. TRANSLATORS: def Set.size(set)
#: lib/set.ex:242 
msgid ""
"Returns the number of elements in `set`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Set.size(Enum.into([1, 2, 3], set_impl.new))\n"
"    3\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.Set Summary
#: lib/set.ex:2 
msgid ""
"This module specifies the `Set` behaviour expected to be\n"
"implemented by different representations of sets.\n"
"\n"
"It also provides functions that redirect to the\n"
"underlying implementation, allowing a developer to work with\n"
"different `Set` implementations using a common API.\n"
"\n"
"To create a new set, use the `new` function which each set implementation\n"
"defines:\n"
"\n"
"    HashSet.new  #=> creates an empty HashSet\n"
"\n"
"In the examples below, `set_impl` means a specific\n"
"`Set` implementation, for example `HashSet`.\n"
"\n"
"## Protocols\n"
"\n"
"Sets are required to implement both the `Enumerable` and `Collectable`\n"
"protocols.\n"
"\n"
"## Matching\n"
"\n"
"Sets are required to implement all equality checks using the match (`===`)\n"
"operator.\n"
msgstr ""
#. TRANSLATORS: def Set.difference(set1, set2)
#: lib/set.ex:78 
msgid ""
"Returns a set that is `set1` without the members of `set2`.\n"
"\n"
"Note that this function is polymorphic as it calculates the difference for\n"
"sets of the same type as well as of sets of different types. Each set\n"
"implementation also provides a `difference` function which only works with\n"
"sets of that type.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Set.difference(Enum.into([1, 2], set_impl.new), Enum.into([2, 3, 4], set_impl.new)) |> Enum.sort\n"
"    [1]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Set.intersection(set1, set2)
#: lib/set.ex:178 
msgid ""
"Returns a set containing only members that `set1` and `set2` have in common.\n"
"\n"
"Note that this function is polymorphic as it calculates the intersection of\n"
"any type. Each set implementation also provides an `intersection` function,\n"
"but that function can only work with sets of the same type.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Set.intersection(Enum.into([1, 2], set_impl.new), Enum.into([2, 3, 4], set_impl.new)) |> Enum.sort\n"
"    [2]\n"
"\n"
"    iex> Set.intersection(Enum.into([1, 2], set_impl.new), Enum.into([3, 4], set_impl.new)) |> Enum.sort\n"
"    []\n"
"\n"
msgstr ""
#. TRANSLATORS: def Set.put(set, value)
#: lib/set.ex:225 
msgid ""
"Inserts `value` into `set` if `set` doesn't already contain it.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Set.put(Enum.into([1, 2, 3], set_impl.new), 3) |> Enum.sort\n"
"    [1, 2, 3]\n"
"\n"
"    iex> Set.put(Enum.into([1, 2, 3], set_impl.new), 4) |> Enum.sort\n"
"    [1, 2, 3, 4]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Set.delete(set, value)
#: lib/set.ex:57 
msgid ""
"Deletes `value` from `set`.\n"
"\n"
"Returns a new set which is a copy of `set` but without `value`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> s = Enum.into([1, 2, 3], set_impl.new)\n"
"    iex> Set.delete(s, 4) |> Enum.sort\n"
"    [1, 2, 3]\n"
"\n"
"    iex> s = Enum.into([1, 2, 3], set_impl.new)\n"
"    iex> Set.delete(s, 2) |> Enum.sort\n"
"    [1, 3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Set.to_list(set)
#: lib/set.ex:286 
msgid ""
"Converts `set` to a list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> set_impl.to_list(Enum.into([1, 2, 3], set_impl.new)) |> Enum.sort\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Set.equal?(set1, set2)
#: lib/set.ex:145 
msgid ""
"Checks if two sets are equal using `===`.\n"
"\n"
"Note that this function is polymorphic as it compares sets of\n"
"any type. Each set implementation also provides an `equal?`\n"
"function, but that function can only work with sets of the same type.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Set.equal?(Enum.into([1, 2], set_impl.new), Enum.into([2, 1, 1], set_impl.new))\n"
"    true\n"
"\n"
"    iex> Set.equal?(Enum.into([1, 2], set_impl.new), Enum.into([3, 4], set_impl.new))\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Set.member?(set, value)
#: lib/set.ex:208 
msgid ""
"Checks if `set` contains `value`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Set.member?(Enum.into([1, 2, 3], set_impl.new), 2)\n"
"    true\n"
"\n"
"    iex> Set.member?(Enum.into([1, 2, 3], set_impl.new), 4)\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Set.subset?(set1, set2)
#: lib/set.ex:256 
msgid ""
"Checks if `set1`'s members are all contained in `set2`.\n"
"\n"
"This function checks if `set1` is a subset of `set2`.\n"
"\n"
"Note that this function is polymorphic as it checks the subset for\n"
"any type. Each set implementation also provides a `subset?` function,\n"
"but that function can only work with sets of the same type.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Set.subset?(Enum.into([1, 2], set_impl.new), Enum.into([1, 2, 3], set_impl.new))\n"
"    true\n"
"\n"
"    iex> Set.subset?(Enum.into([1, 2, 3], set_impl.new), Enum.into([1, 2], set_impl.new))\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Set.disjoint?(set1, set2)
#: lib/set.ex:106 
msgid ""
"Checks if `set1` and `set2` have no members in common.\n"
"\n"
"Note that this function is polymorphic as it checks for disjoint sets of\n"
"any type. Each set implementation also provides a `disjoint?` function,\n"
"but that function can only work with sets of the same type.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Set.disjoint?(Enum.into([1, 2], set_impl.new), Enum.into([3, 4], set_impl.new))\n"
"    true\n"
"\n"
"    iex> Set.disjoint?(Enum.into([1, 2], set_impl.new), Enum.into([2, 3], set_impl.new))\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Set.union(set1, set2)
#: lib/set.ex:300 
msgid ""
"Returns a set containing all members of `set1` and `set2`.\n"
"\n"
"Note that this function is polymorphic as it calculates the union of sets of\n"
"any type. Each set implementation also provides a `union` function,\n"
"but that function can only work with sets of the same type.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Set.union(Enum.into([1, 2], set_impl.new), Enum.into([2, 3, 4], set_impl.new)) |> Enum.sort\n"
"    [1, 2, 3, 4]\n"
"\n"
msgstr ""
