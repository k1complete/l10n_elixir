#. TRANSLATORS: def IO.write(device \\ :erlang.group_leader(), item)
#: lib/io.ex:150 
msgid ""
"Writes the given argument to the given device.\n"
"\n"
"By default the device is the standard output.\n"
"It returns `:ok` if it succeeds.\n"
"\n"
"## Examples\n"
"\n"
"    IO.write \"sample\"\n"
"    #=> \"sample\"\n"
"\n"
"    IO.write :stderr, \"error\"\n"
"    #=> \"error\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def IO.binwrite(device \\ :erlang.group_leader(), item)
#: lib/io.ex:164 
msgid ""
"Writes the given argument to the given device\n"
"as a binary, no unicode conversion happens.\n"
"\n"
"Check `write/2` for more information.\n"
"\n"
"Note: do not use this function on IO devices in unicode mode\n"
"as it will return the wrong result.\n"
msgstr ""
#. TRANSLATORS: def IO.puts(device \\ :erlang.group_leader(), item)
#: lib/io.ex:174 
msgid ""
"Writes the argument to the device, similar to `write/2`,\n"
"but adds a newline at the end. The argument is expected\n"
"to be a chardata.\n"
msgstr ""
#. TRANSLATORS: def IO.gets(device \\ :erlang.group_leader(), prompt)
#: lib/io.ex:258 
msgid ""
"Reads a line from the IO device. It returns:\n"
"\n"
"  * `data` - the characters in the line terminated\n"
"    by a LF (or end of file)\n"
"\n"
"  * `:eof` - end of file was encountered\n"
"\n"
"  * `{:error, reason}` - other (rare) error condition;\n"
"    for instance, `{:error, :estale}` if reading from an\n"
"    NFS volume\n"
msgstr ""
#. TRANSLATORS: def IO.binread(device \\ :erlang.group_leader(), chars_or_line)
#: lib/io.ex:106 
msgid ""
"Reads `count` characters from the IO device, a whole\n"
"`:line` or the whole device with `:all`.\n"
"\n"
"It returns:\n"
"\n"
"  * `data` - the input characters\n"
"\n"
"  * `:eof` - end of file was encountered\n"
"\n"
"  * `{:error, reason}` - other (rare) error condition;\n"
"    for instance, `{:error, :estale}` if reading from an\n"
"    NFS volume\n"
"\n"
"If `:all` is given, `:eof` is never returned, but an\n"
"empty string in case the device has reached EOF.\n"
"\n"
"Note: do not use this function on IO devices in unicode mode\n"
"as it will return the wrong result.\n"
msgstr ""
#. TRANSLATORS: def IO.read(device \\ :erlang.group_leader(), chars_or_line)
#: lib/io.ex:63 
msgid ""
"Reads `count` characters from the IO device, a whole\n"
"`:line` or the whole device with `:all`.\n"
"\n"
"It returns:\n"
"\n"
"  * `data` - the input characters\n"
"\n"
"  * `:eof` - end of file was encountered\n"
"\n"
"  * `{:error, reason}` - other (rare) error condition;\n"
"    for instance, `{:error, :estale}` if reading from an\n"
"    NFS volume\n"
"\n"
"If `:all` is given, `:eof` is never returned, but an\n"
"empty string in case the device has reached EOF.\n"
msgstr ""
#. TRANSLATORS: def IO.iodata_length(item)
#: lib/io.ex:389 
msgid ""
"Returns the size of an iodata.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> IO.iodata_length([1, 2|<<3, 4>>])\n"
"    4\n"
"\n"
msgstr ""
#. TRANSLATORS: def IO.inspect(device, item, opts)
#: lib/io.ex:200 
msgid ""
"Inspects the item with options using the given device.\n"
msgstr ""
#. TRANSLATORS: def IO.inspect(item, opts \\ [])
#: lib/io.ex:192 
msgid ""
"Inspects and writes the given argument to the device.\n"
"\n"
"It enables pretty printing by default with width of\n"
"80 characters. The width can be changed by explicitly\n"
"passing the `:width` option.\n"
"\n"
"## Examples\n"
"\n"
"    IO.inspect Process.list, width: 40\n"
"\n"
msgstr ""
#. TRANSLATORS: def IO.getn(prompt, count \\ 1)
#: lib/io.ex:224 
msgid ""
"Gets a number of bytes from the io device. If the\n"
"io device is a unicode device, `count` implies\n"
"the number of unicode codepoints to be retrieved.\n"
"Otherwise, `count` is the number of raw bytes to be retrieved.\n"
"It returns:\n"
"\n"
"  * `data` - the input characters\n"
"\n"
"  * `:eof` - end of file was encountered\n"
"\n"
"  * `{:error, reason}` - other (rare) error condition;\n"
"    for instance, `{:error, :estale}` if reading from an\n"
"    NFS volume\n"
msgstr ""
#. TRANSLATORS: def IO.getn(device, prompt, count)
#: lib/io.ex:241 
msgid ""
"Gets a number of bytes from the io device. If the\n"
"io device is a unicode device, `count` implies\n"
"the number of unicode codepoints to be retrieved.\n"
"Otherwise, `count` is the number of raw bytes to be retrieved.\n"
msgstr ""
#. TRANSLATORS: Elixir.IO Summary
#: lib/io.ex:1 
msgid ""
"Functions handling IO.\n"
"\n"
"Many functions in this module expect an IO device as an argument.\n"
"An IO device must be a pid or an atom representing a process.\n"
"For convenience, Elixir provides `:stdio` and `:stderr` as\n"
"shortcuts to Erlang's `:standard_io` and `:standard_error`.\n"
"\n"
"The majority of the functions expect char data, i.e. strings or\n"
"lists of characters and strings. In case another type is given,\n"
"it will do a conversion to string via the `String.Chars` protocol\n"
"(as shown in typespecs).\n"
"\n"
"The functions starting with `bin*` expect iodata as an argument,\n"
"i.e. binaries or lists of bytes and binaries.\n"
"\n"
"## IO devices\n"
"\n"
"An IO device may be an atom or a pid. In case it is an atom,\n"
"the atom must be the name of a registered process. However,\n"
"there are three exceptions for this rule:\n"
"\n"
"  * `:standard_io` - when the `:standard_io` atom is given,\n"
"    it is treated as a shortcut for `Process.group_leader`\n"
"\n"
"  * `:stdio` - is a shortcut for `:standard_io`\n"
"\n"
"  * `:stderr` - is a shortcut for `:standard_error`\n"
"\n"
msgstr ""
#. TRANSLATORS: def IO.stream(device, line_or_codepoints)
#: lib/io.ex:287 
msgid ""
"Converts the io device into a `IO.Stream`.\n"
"\n"
"An `IO.Stream` implements both `Enumerable` and\n"
"`Collectable`, allowing it to be used for both read\n"
"and write.\n"
"\n"
"The device is iterated line by line if `:line` is given or\n"
"by a given number of codepoints.\n"
"\n"
"This reads the IO as utf-8. Check out\n"
"`IO.binstream/2` to handle the IO as a raw binary.\n"
"\n"
"Note that an IO stream has side effects and every time\n"
"you go over the stream you may get different results.\n"
"\n"
"## Examples\n"
"\n"
"Here is an example on how we mimic an echo server\n"
"from the command line:\n"
"\n"
"    Enum.each IO.stream(:stdio, :line), &IO.write(&1)\n"
"\n"
msgstr ""
#. TRANSLATORS: def IO.binstream(device, line_or_bytes)
#: lib/io.ex:308 
msgid ""
"Converts the IO device into a `IO.Stream`.\n"
"\n"
"An `IO.Stream` implements both `Enumerable` and\n"
"`Collectable`, allowing it to be used for both read\n"
"and write.\n"
"\n"
"The device is iterated line by line or by a number of bytes.\n"
"This reads the IO device as a raw binary.\n"
"\n"
"Note that an IO stream has side effects and every time\n"
"you go over the stream you may get different results.\n"
"\n"
"Finally, do not use this function on IO devices in unicode\n"
"mode as it will return the wrong result.\n"
msgstr ""
#. TRANSLATORS: def IO.iodata_to_binary(item)
#: lib/io.ex:373 
msgid ""
"Converts iodata (a list of integers representing bytes, lists\n"
"and binaries) into a binary.\n"
"\n"
"Notice that this function treats lists of integers as raw bytes\n"
"and does not perform any kind of encoding conversion. If you want\n"
"to convert from a char list to a string (UTF-8 encoded), please\n"
"use `chardata_to_string/1` instead.\n"
"\n"
"If this function receives a binary, the same binary is returned.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> bin1 = <<1, 2, 3>>\n"
"    iex> bin2 = <<4, 5>>\n"
"    iex> bin3 = <<6>>\n"
"    iex> IO.iodata_to_binary([bin1, 1, [2, 3, bin2], 4|bin3])\n"
"    <<1,2,3,1,2,3,4,5,4,6>>\n"
"\n"
"    iex> bin = <<1, 2, 3>>\n"
"    iex> IO.iodata_to_binary(bin)\n"
"    <<1,2,3>>\n"
"\n"
msgstr ""
#. TRANSLATORS: def IO.chardata_to_string(string)
#: lib/io.ex:329 
msgid ""
"Converts chardata (a list of integers representing codepoints,\n"
"lists and strings) into a string.\n"
"\n"
"In case the conversion fails, it raises a `UnicodeConversionError`.\n"
"If a string is given, returns the string itself.\n"
"\n"
"## Examples\n"
"\n"
"    iex> IO.chardata_to_string([0x00E6, 0x00DF])\n"
"    \"æß\"\n"
"\n"
"    iex> IO.chardata_to_string([0x0061, \"bc\"])\n"
"    \"abc\"\n"
"\n"
msgstr ""
