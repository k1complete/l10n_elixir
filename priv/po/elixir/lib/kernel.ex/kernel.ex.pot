#. TRANSLATORS: def Kernel.==(left, right)
#: lib/kernel.ex:1051 
msgid ""
"Returns `true` if the two items are equal.\n"
"\n"
"This operator considers 1 and 1.0 to be equal. For match\n"
"semantics, use `===` instead.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 == 2\n"
"    false\n"
"\n"
"    iex> 1 == 1.0\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.and(left, right)
#: lib/kernel.ex:1205 
msgid ""
"Boolean and.\n"
"\n"
"If the first argument is `false`, `false` is returned; otherwise, the second\n"
"argument is returned.\n"
"\n"
"Requires only the first argument to be a boolean since it short-circuits. If\n"
"the first argument is not a boolean, an `ArgumentError` exception is raised.\n"
"\n"
"Allowed in guard tests.\n"
"\n"
"## Examples\n"
"\n"
"    iex> true and false\n"
"    false\n"
"    iex> true and \"yay!\"\n"
"    \"yay!\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.exit(reason)
#: lib/kernel.ex:179 
msgid ""
"Stops the execution of the calling process with the given reason.\n"
"\n"
"Since evaluating this function causes the process to terminate,\n"
"it has no return value.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"When a process reaches its end, by default it exits with\n"
"reason `:normal`. You can also call `exit/1` explicitly if you\n"
"want to terminate a process but not signal any failure:\n"
"\n"
"    exit(:normal)\n"
"\n"
"In case something goes wrong, you can also use `exit/1` with\n"
"a different reason:\n"
"\n"
"    exit(:seems_bad)\n"
"\n"
"If the exit reason is not `:normal`, all the processes linked to the process\n"
"that exited will crash (unless they are trapping exits).\n"
"\n"
"## OTP exits\n"
"\n"
"Exits are used by the OTP to determine if a process exited abnormally\n"
"or not. The following exits are considered \"normal\":\n"
"\n"
"  * `exit(:normal)`\n"
"  * `exit(:shutdown)`\n"
"  * `exit({:shutdown, term})`\n"
"\n"
"Exiting with any other reason is considered abnormal and treated\n"
"as a crash. This means the default supervisor behaviour kicks in,\n"
"error reports are emitted, etc.\n"
"\n"
"This behaviour is relied on in many different places. For example,\n"
"`ExUnit` uses `exit(:shutdown)` when exiting the test process to\n"
"signal linked processes, supervision trees and so on to politely\n"
"shutdown too.\n"
"\n"
"## CLI exits\n"
"\n"
"Building on top of the exit signals mentioned above, if the\n"
"process started by the command line exits with any of the three\n"
"reasons above, its exit is considered normal and the Operating\n"
"System process will exit with status 0.\n"
"\n"
"It is, however, possible to customize the Operating System exit\n"
"signal by invoking:\n"
"\n"
"    exit({:shutdown, integer})\n"
"\n"
"This will cause the OS process to exit with the status given by\n"
"`integer` while signaling all linked OTP processes to politely\n"
"shutdown.\n"
"\n"
"Any other exit reason will cause the OS process to exit with\n"
"status `1` and linked OTP processes to crash.\n"
msgstr ""
#. TRANSLATORS: def Kernel.round(number)
#: lib/kernel.ex:576 
msgid ""
"Rounds a number to the nearest integer.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> round(5.6)\n"
"    6\n"
"    iex> round(5.2)\n"
"    5\n"
"    iex> round(-9.9)\n"
"    -10\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.apply(fun, args)
#: lib/kernel.ex:60 
msgid ""
"Invokes the given `fun` with the array of arguments `args`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> apply(fn x -> x * 2 end, [2])\n"
"    4\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.!(arg)
#: lib/kernel.ex:1228 
msgid ""
"Boolean not.\n"
"\n"
"Receives any argument (not just booleans) and returns `true` if the argument\n"
"is `false` or `nil`; returns `false` otherwise.\n"
"\n"
"Not allowed in guard clauses.\n"
"\n"
"## Examples\n"
"\n"
"    iex> !Enum.empty?([])\n"
"    false\n"
"\n"
"    iex> !List.first([])\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.@(expr)
#: lib/kernel.ex:2236 
msgid ""
"Reads and writes attributes of the current module.\n"
"\n"
"The canonical example for attributes is annotating that a module\n"
"implements the OTP behaviour called `gen_server`:\n"
"\n"
"    defmodule MyServer do\n"
"      @behaviour :gen_server\n"
"      # ... callbacks ...\n"
"    end\n"
"\n"
"By default Elixir supports all the module attributes supported by Erlang, but\n"
"custom attributes can be used as well:\n"
"\n"
"    defmodule MyServer do\n"
"      @my_data 13\n"
"      IO.inspect @my_data #=> 13\n"
"    end\n"
"\n"
"Unlike Erlang, such attributes are not stored in the module by default since\n"
"it is common in Elixir to use custom attributes to store temporary data that\n"
"will be available at compile-time. Custom attributes may be configured to\n"
"behave closer to Erlang by using `Module.register_attribute/3`.\n"
"\n"
"Finally, notice that attributes can also be read inside functions:\n"
"\n"
"    defmodule MyServer do\n"
"      @my_data 11\n"
"      def first_data, do: @my_data\n"
"      @my_data 13\n"
"      def second_data, do: @my_data\n"
"    end\n"
"\n"
"    MyServer.first_data #=> 11\n"
"    MyServer.second_data #=> 13\n"
"\n"
"It is important to note that reading an attribute takes a snapshot of\n"
"its current value. In other words, the value is read at compilation\n"
"time and not at runtime. Check the `Module` module for other functions\n"
"to manipulate module attributes.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.&&(left, right)
#: lib/kernel.ex:2588 
msgid ""
"Provides a short-circuit operator that evaluates and returns\n"
"the second expression only if the first one evaluates to `true`\n"
"(i.e., it is not `nil` nor `false`). Returns the first expression\n"
"otherwise.\n"
"\n"
"Not allowed in guard clauses.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.empty?([]) && Enum.empty?([])\n"
"    true\n"
"\n"
"    iex> List.first([]) && true\n"
"    nil\n"
"\n"
"    iex> Enum.empty?([]) && List.first([1])\n"
"    1\n"
"\n"
"    iex> false && throw(:bad)\n"
"    false\n"
"\n"
"\n"
"Note that, unlike `and/2`, this operator accepts any expression\n"
"as the first argument, not only booleans.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.update_in(path, fun)
#: lib/kernel.ex:1926 
msgid ""
"Updates a nested structure via the given `path`.\n"
"\n"
"This is similar to `update_in/3`, except the path is extracted via\n"
"a macro rather than passing a list. For example:\n"
"\n"
"    update_in(opts[:foo][:bar], &(&1 + 1))\n"
"\n"
"Is equivalent to:\n"
"\n"
"    update_in(opts, [:foo, :bar], &(&1 + 1))\n"
"\n"
"Note that in order for this macro to work, the complete path must always\n"
"be visible by this macro. For more information about the supported path\n"
"expressions, please check `get_and_update_in/2` docs.\n"
"\n"
"## Examples\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> update_in(users[\"john\"][:age], &(&1 + 1))\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> update_in(users[\"john\"].age, &(&1 + 1))\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.send(dest, msg)
#: lib/kernel.ex:596 
msgid ""
"Sends a message to the given `dest` and returns the message.\n"
"\n"
"`dest` may be a remote or local pid, a (local) port, a locally\n"
"registered name, or a tuple `{registered_name, node}` for a registered\n"
"name at another node.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> send self(), :hello\n"
"    :hello\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.var!(var, context \\ nil)
#: lib/kernel.ex:2880 
msgid ""
"When used inside quoting, marks that the given variable should\n"
"not be hygienized.\n"
"\n"
"The argument can be either a variable unquoted or in standard tuple form\n"
"`{name, meta, context}`.\n"
"\n"
"Check `Kernel.SpecialForms.quote/2` for more information.\n"
msgstr ""
#. TRANSLATORS: def Kernel.is_number(term)
#: lib/kernel.ex:379 
msgid ""
"Returns `true` if `term` is either an integer or a floating point number;\n"
"otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Kernel.is_boolean(term)
#: lib/kernel.ex:309 
msgid ""
"Returns `true` if `term` is either the atom `true` or the atom `false` (i.e.,\n"
"a boolean); otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.reraise(exception, attrs, stacktrace)
#: lib/kernel.ex:1463 
msgid ""
"Raises an exception preserving a previous stacktrace.\n"
"\n"
"`reraise/3` works like `reraise/2`, except it passes arguments to the\n"
"`exception/1` function like explained in `raise/2`.\n"
"\n"
"## Examples\n"
"\n"
"    try do\n"
"      raise \"oops\"\n"
"    rescue\n"
"      exception ->\n"
"        stacktrace = System.stacktrace\n"
"        reraise WrapperError, [exception: exception], stacktrace\n"
"    end\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.sigil_C(term, modifiers)
#: lib/kernel.ex:3909 
msgid ""
"Handles the sigil `~C`.\n"
"\n"
"It simply returns a char list without escaping characters and without\n"
"interpolations.\n"
"\n"
"## Examples\n"
"\n"
"    iex> ~C(foo)\n"
"    'foo'\n"
"\n"
"    iex> ~C(f#{o}o)\n"
"    'f\\#{o}o'\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.apply(module, fun, args)
#: lib/kernel.ex:76 
msgid ""
"Invokes the given `fun` from `module` with the array of arguments `args`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> apply(Enum, :reverse, [[1, 2, 3]])\n"
"    [3, 2, 1]\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.get_and_update_in(path, fun)
#: lib/kernel.ex:1963 
msgid ""
"Gets a value and updates a nested data structure via the given `path`.\n"
"\n"
"This is similar to `get_and_update_in/3`, except the path is extracted\n"
"via a macro rather than passing a list. For example:\n"
"\n"
"    get_and_update_in(opts[:foo][:bar], &{&1, &1 + 1})\n"
"\n"
"Is equivalent to:\n"
"\n"
"    get_and_update_in(opts, [:foo, :bar], &{&1, &1 + 1})\n"
"\n"
"Note that in order for this macro to work, the complete path must always\n"
"be visible by this macro. See the Paths section below.\n"
"\n"
"## Examples\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> get_and_update_in(users[\"john\"].age, &{&1, &1 + 1})\n"
"    {27, %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}}\n"
"\n"
"## Paths\n"
"\n"
"A path may start with a variable, local or remote call, and must be\n"
"followed by one or more:\n"
"\n"
"  * `foo[bar]` - access a field; in case an intermediate field is not\n"
"    present or returns `nil`, an empty map is used\n"
"\n"
"  * `foo.bar` - access a map/struct field; in case the field is not\n"
"    present, an error is raised\n"
"\n"
"Here are some valid paths:\n"
"\n"
"    users[\"john\"][:age]\n"
"    users[\"john\"].age\n"
"    User.all[\"john\"].age\n"
"    all_users()[\"john\"].age\n"
"\n"
"Here are some invalid ones:\n"
"\n"
"    # Does a remote call after the initial value\n"
"    users[\"john\"].do_something(arg1, arg2)\n"
"\n"
"    # Does not access any field\n"
"    users\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel./(left, right)
#: lib/kernel.ex:890 
msgid ""
"Arithmetic division.\n"
"\n"
"The result is always a float. Use `div/2` and `rem/2` if you want\n"
"an integer division or the remainder.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 / 2\n"
"    0.5\n"
"\n"
"    iex> 2 / 1\n"
"    2.0\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.raise(msg)
#: lib/kernel.ex:1306 
msgid ""
"Raises an exception.\n"
"\n"
"If the argument `msg` is a binary, it raises a `RuntimeError` exception\n"
"using the given argument as message.\n"
"\n"
"If `msg` is an atom, it just calls `raise/2` with the atom as the first\n"
"argument and `[]` as the second argument.\n"
"\n"
"If `msg` is anything else, raises an `ArgumentError` exception.\n"
"\n"
"## Examples\n"
"\n"
"    iex> raise \"oops\"\n"
"    ** (RuntimeError) oops\n"
"\n"
"    try do\n"
"      1 + :foo\n"
"    rescue\n"
"      x in [ArithmeticError] ->\n"
"        IO.puts \"that was expected\"\n"
"        raise x\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.tuple_size(tuple)
#: lib/kernel.ex:792 
msgid ""
"Returns the size of a tuple.\n"
"\n"
"This operation happens in constant time.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> tuple_size {:a, :b, :c}\n"
"    3\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.if(condition, clauses)
#: lib/kernel.ex:2407 
msgid ""
"Provides an `if/2` macro.\n"
"\n"
"This macro expects the first argument to be a condition and the second\n"
"argument to be a keyword list.\n"
"\n"
"## One-liner examples\n"
"\n"
"    if(foo, do: bar)\n"
"\n"
"In the example above, `bar` will be returned if `foo` evaluates to\n"
"`true` (i.e., it is neither `false` nor `nil`). Otherwise, `nil` will be\n"
"returned.\n"
"\n"
"An `else` option can be given to specify the opposite:\n"
"\n"
"    if(foo, do: bar, else: baz)\n"
"\n"
"## Blocks examples\n"
"\n"
"It's also possible to pass a block to the `if/2` macro. The first\n"
"example above would be translated to:\n"
"\n"
"    if foo do\n"
"      bar\n"
"    end\n"
"\n"
"Note that `do/end` become delimiters. The second example would\n"
"translate to:\n"
"\n"
"    if foo do\n"
"      bar\n"
"    else\n"
"      baz\n"
"    end\n"
"\n"
"In order to compare more than two clauses, the `cond/1` macro has to be used.\n"
msgstr ""
#. TRANSLATORS: def Kernel.!==(left, right)
#: lib/kernel.ex:1124 
msgid ""
"Returns `true` if the two items do not match.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 !== 2\n"
"    true\n"
"\n"
"    iex> 1 !== 1.0\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.map_size(map)
#: lib/kernel.ex:474 
msgid ""
"Returns the size of a map.\n"
"\n"
"The size of a map is the number of key-value pairs that the map contains.\n"
"\n"
"This operation happens in constant time.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> map_size(%{a: \"foo\", b: \"bar\"})\n"
"    2\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.is_port(term)
#: lib/kernel.ex:400 
msgid ""
"Returns `true` if `term` is a port identifier; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Kernel.get_in(data, keys)
#: lib/kernel.ex:1661 
msgid ""
"Gets a value from a nested structure.\n"
"\n"
"Uses the `Access` module to traverse the structures\n"
"according to the given `keys`, unless the `key` is a\n"
"function.\n"
"\n"
"If a key is a function, the function will be invoked\n"
"passing three arguments, the operation (`:get`), the\n"
"data to be accessed, and a function to be invoked next.\n"
"\n"
"This means `get_in/2` can be extended to provide\n"
"custom lookups. The downside is that functions cannot be\n"
"stored as keys in the accessed data structures.\n"
"\n"
"## Examples\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> get_in(users, [\"john\", :age])\n"
"    27\n"
"\n"
"In case any of entries in the middle returns `nil`, `nil` will be returned\n"
"as per the Access module:\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> get_in(users, [\"unknown\", :age])\n"
"    nil\n"
"\n"
"When one of the keys is a function, the function is invoked.\n"
"In the example below, we use a function to get all the maps\n"
"inside a list:\n"
"\n"
"    iex> users = [%{name: \"john\", age: 27}, %{name: \"meg\", age: 23}]\n"
"    iex> all = fn :get, data, next -> Enum.map(data, next) end\n"
"    iex> get_in(users, [all, :age])\n"
"    [27, 23]\n"
"\n"
"If the previous value before invoking the function is `nil`,\n"
"the function *will* receive nil as a value and must handle it\n"
"accordingly.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.alias!(alias)
#: lib/kernel.ex:2912 
msgid ""
"When used inside quoting, marks that the given alias should not\n"
"be hygienized. This means the alias will be expanded when\n"
"the macro is expanded.\n"
"\n"
"Check `Kernel.SpecialForms.quote/2` for more information.\n"
msgstr ""
#. TRANSLATORS: def Kernel.++(left, right)
#: lib/kernel.ex:912 
msgid ""
"Concatenates two lists.\n"
"\n"
"The complexity of `a ++ b` is proportional to `length(a)`, so avoid repeatedly\n"
"appending to lists of arbitrary length, e.g. `list ++ [item]`.\n"
"\n"
"Instead, consider prepending via `[item | rest]` and then reversing.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> [1] ++ [2, 3]\n"
"    [1, 2, 3]\n"
"\n"
"    iex> 'foo' ++ 'bar'\n"
"    'foobar'\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.throw(term)
#: lib/kernel.ex:749 
msgid ""
"A non-local return from a function. Check `Kernel.SpecialForms.try/1` for more information.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Kernel.*(left, right)
#: lib/kernel.ex:874 
msgid ""
"Arithmetic multiplication.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 * 2\n"
"    2\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.struct(struct, kv \\ [])
#: lib/kernel.ex:1583 
msgid ""
"Creates and updates structs.\n"
"\n"
"The `struct` argument may be an atom (which defines `defstruct`)\n"
"or a `struct` itself. The second argument is any `Enumerable` that\n"
"emits two-element tuples (key-value pairs) during enumeration.\n"
"\n"
"Keys in the `Enumerable` that don't exist in the struct are automatically\n"
"discarded. Note that keys must be atoms, as only atoms are allowed when\n"
"defining a struct.\n"
"\n"
"This function is useful for dynamically creating and updating structs, as\n"
"well as for converting maps to structs; in the latter case, just inserting\n"
"the appropriate `:__struct__` field into the map may not be enough and\n"
"`struct/2` should be used instead.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule User do\n"
"      defstruct name: \"john\"\n"
"    end\n"
"\n"
"    struct(User)\n"
"    #=> %User{name: \"john\"}\n"
"\n"
"    opts = [name: \"meg\"]\n"
"    user = struct(User, opts)\n"
"    #=> %User{name: \"meg\"}\n"
"\n"
"    struct(user, unknown: \"value\")\n"
"    #=> %User{name: \"meg\"}\n"
"\n"
"    struct(User, %{name: \"meg\"})\n"
"    #=> %User{name: \"meg\"}\n"
"\n"
"    # String keys are ignored\n"
"    struct(User, %{\"name\" => \"meg\"})\n"
"    #=> %User{name: \"john\"}\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.in(left, right)
#: lib/kernel.ex:2761 
msgid ""
"Checks if the element on the left-hand side is a member of the\n"
"collection on the right-hand side.\n"
"\n"
"## Examples\n"
"\n"
"    iex> x = 1\n"
"    iex> x in [1, 2, 3]\n"
"    true\n"
"\n"
"This operator (which is a macro) simply translates to a call to\n"
"`Enum.member?/2`. The example above would translate to:\n"
"\n"
"    Enum.member?([1, 2, 3], x)\n"
"\n"
"## Guards\n"
"\n"
"The `in/2` operator can be used in guard clauses as long as the\n"
"right-hand side is a range or a list. In such cases, Elixir will expand the\n"
"operator to a valid guard expression. For example:\n"
"\n"
"    when x in [1, 2, 3]\n"
"\n"
"translates to:\n"
"\n"
"    when x === 1 or x === 2 or x === 3\n"
"\n"
"When using ranges:\n"
"\n"
"    when x in 1..3\n"
"\n"
"translates to:\n"
"\n"
"    when x >= 1 and x <= 3\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.match?(pattern, expr)
#: lib/kernel.ex:2172 
msgid ""
"A convenience macro that checks if the right side (an expression) matches the\n"
"left side (a pattern).\n"
"\n"
"## Examples\n"
"\n"
"    iex> match?(1, 1)\n"
"    true\n"
"\n"
"    iex> match?(1, 2)\n"
"    false\n"
"\n"
"    iex> match?({1, _}, {1, 2})\n"
"    true\n"
"\n"
"    iex> map = %{a: 1, b: 2}\n"
"    iex> match?(%{a: _}, map)\n"
"    true\n"
"\n"
"    iex> a = 1\n"
"    iex> match?(^a, 1)\n"
"    true\n"
"\n"
"`match?/2` is very useful when filtering of finding a value in an enumerable:\n"
"\n"
"    list = [{:a, 1}, {:b, 2}, {:a, 3}]\n"
"    Enum.filter list, &match?({:a, _}, &1)\n"
"    #=> [{:a, 1}, {:a, 3}]\n"
"\n"
"Guard clauses can also be given to the match:\n"
"\n"
"    list = [{:a, 1}, {:b, 2}, {:a, 3}]\n"
"    Enum.filter list, &match?({:a, x} when x < 2, &1)\n"
"    #=> [{:a, 1}]\n"
"\n"
"However, variables assigned in the match will not be available\n"
"outside of the function call (unlike regular pattern matching with the `=`\n"
"operator):\n"
"\n"
"    iex> match?(_x, 1)\n"
"    true\n"
"    iex> binding()\n"
"    []\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.tl(list)
#: lib/kernel.ex:759 
msgid ""
"Returns the tail of a list. Raises `ArgumentError` if the list is empty.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> tl([1, 2, 3, :go])\n"
"    [2, 3, :go]\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.def(call, expr \\ nil)
#: lib/kernel.ex:3119 
msgid ""
"Defines a function with the given name and body.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Foo do\n"
"      def bar, do: :baz\n"
"    end\n"
"\n"
"    Foo.bar #=> :baz\n"
"\n"
"A function that expects arguments can be defined as follows:\n"
"\n"
"    defmodule Foo do\n"
"      def sum(a, b) do\n"
"        a + b\n"
"      end\n"
"    end\n"
"\n"
"In the example above, a `sum/2` function is defined; this function receives\n"
"two arguments and returns their sum.\n"
"\n"
"## Function and variable names\n"
"\n"
"Function and variable names have the following syntax:\n"
"A _lowercase ASCII letter_ or an _underscore_, followed by any number of\n"
"_lowercase or uppercase ASCII letters_, _numbers_, or _underscores_.\n"
"Optionally they can end in either an _exclamation mark_ or a _question mark_.\n"
"\n"
"For variables, any identifier starting with an underscore should indicate an\n"
"unused variable. For example:\n"
"\n"
"    def foo(bar) do\n"
"      []\n"
"    end\n"
"    #=> warning: variable bar is unused\n"
"\n"
"    def foo(_bar) do\n"
"      []\n"
"    end\n"
"    #=> no warning\n"
"\n"
"    def foo(_bar) do\n"
"      _bar\n"
"    end\n"
"    #=> warning: the underscored variable \"_bar\" is used after being set\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.sigil_W(term, modifiers)
#: lib/kernel.ex:4043 
msgid ""
"Handles the sigil `~W`.\n"
"\n"
"It returns a list of \"words\" split by whitespace without escaping nor\n"
"interpreting interpolations.\n"
"\n"
"## Modifiers\n"
"\n"
"  * `s`: words in the list are strings (default)\n"
"  * `a`: words in the list are atoms\n"
"  * `c`: words in the list are char lists\n"
"\n"
"## Examples\n"
"\n"
"    iex> ~W(foo #{bar} baz)\n"
"    [\"foo\", \"\\#{bar}\", \"baz\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.>=(left, right)
#: lib/kernel.ex:1033 
msgid ""
"Returns `true` if left is more than or equal to right.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 >= 2\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.raise(exception, attrs)
#: lib/kernel.ex:1381 
msgid ""
"Raises an exception.\n"
"\n"
"Calls the `exception/1` function on the given argument (which has to be a\n"
"module name like `ArgumentError` or `RuntimeError`) passing `attrs` as the\n"
"attributes in order to retrieve the exception struct.\n"
"\n"
"Any module that contains a call to the `defexception/1` macro automatically\n"
"implements the `exception/1` callback expected by `raise/2`. See the docs for\n"
"`defexception/1` for more information.\n"
"\n"
"## Examples\n"
"\n"
"    iex> raise(ArgumentError, message: \"Sample\")\n"
"    ** (ArgumentError) Sample\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.<=(left, right)
#: lib/kernel.ex:1015 
msgid ""
"Returns `true` if left is less than or equal to right.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 <= 2\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.spawn_monitor(module, fun, args)
#: lib/kernel.ex:730 
msgid ""
"Spawns the given module and function passing the given args,\n"
"monitors it and returns its pid and monitoring reference.\n"
"\n"
"Check the `Process` and `Node` modules for other functions\n"
"to handle processes, including spawning functions in nodes.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    spawn_monitor(SomeModule, :function, [1, 2, 3])\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.destructure(left, right)
#: lib/kernel.ex:2511 
msgid ""
"Destructures two lists, assigning each term in the\n"
"right one to the matching term in the left one.\n"
"\n"
"Unlike pattern matching via `=`, if the sizes of the left\n"
"and right lists don't match, destructuring simply stops\n"
"instead of raising an error.\n"
"\n"
"## Examples\n"
"\n"
"    iex> destructure([x, y, z], [1, 2, 3, 4, 5])\n"
"    iex> {x, y, z}\n"
"    {1, 2, 3}\n"
"\n"
"In the example above, even though the right list has more entries than the\n"
"left one, destructuring works fine. If the right list is smaller, the\n"
"remaining items are simply set to `nil`:\n"
"\n"
"    iex> destructure([x, y, z], [1])\n"
"    iex> {x, y, z}\n"
"    {1, nil, nil}\n"
"\n"
"The left-hand side supports any expression you would use\n"
"on the left-hand side of a match:\n"
"\n"
"    x = 1\n"
"    destructure([^x, y, z], [1, 2, 3])\n"
"\n"
"The example above will only work if `x` matches the first value in the right\n"
"list. Otherwise, it will raise a `MatchError` (like the `=` operator would\n"
"do).\n"
msgstr ""
#. TRANSLATORS: def Kernel.struct!(struct, kv \\ [])
#: lib/kernel.ex:1633 
msgid ""
"Same as `struct/2` but raises if any of provided keys doesn't exist in the struct.\n"
msgstr ""
#. TRANSLATORS: def Kernel.--(left, right)
#: lib/kernel.ex:936 
msgid ""
"Removes the first occurrence of an item on the left list\n"
"for each item on the right.\n"
"\n"
"The complexity of `a -- b` is proportional to `length(a) * length(b)`,\n"
"meaning that it will be very slow if both `a` and `b` are long lists.\n"
"In such cases, consider converting each list to a `MapSet` and using\n"
"`MapSet.difference/2`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> [1, 2, 3] -- [1, 2]\n"
"    [3]\n"
"\n"
"    iex> [1, 2, 3, 2, 1] -- [1, 2, 2]\n"
"    [3, 1]\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.unless(condition, clauses)
#: lib/kernel.ex:2467 
msgid ""
"Provides an `unless` macro.\n"
"\n"
"This macro evaluates and returns the `do` block passed in as the second\n"
"argument unless `clause` evaluates to `true`. Otherwise, it returns the value\n"
"of the `else` block if present or `nil` if not.\n"
"\n"
"See also `if/2`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> unless(Enum.empty?([]), do: \"Hello\")\n"
"    nil\n"
"\n"
"    iex> unless(Enum.empty?([1, 2, 3]), do: \"Hello\")\n"
"    \"Hello\"\n"
"\n"
"    iex> unless Enum.sum([2, 2]) == 5 do\n"
"    ...>   \"Math still works\"\n"
"    ...> else\n"
"    ...>   \"Math is broken\"\n"
"    ...> end\n"
"    \"Math still works\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.pop_in(data, keys)
#: lib/kernel.ex:1822 
msgid ""
"Pops a key from the given nested structure.\n"
"\n"
"Uses the `Access` protocol to traverse the structures\n"
"according to the given `keys`, unless the `key` is a\n"
"function. If the key is a function, it will be invoked\n"
"as specified in `get_and_update_in/3`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> pop_in(users, [\"john\", :age])\n"
"    {27, %{\"john\" => %{}, \"meg\" => %{age: 23}}}\n"
"\n"
"In case any entry returns `nil`, its key will be removed\n"
"and the deletion will be considered a success.\n"
msgstr ""
#. TRANSLATORS: def Kernel.+(value)
#: lib/kernel.ex:842 
msgid ""
"Arithmetic unary plus.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> +1\n"
"    1\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.is_binary(term)
#: lib/kernel.ex:271 
msgid ""
"Returns `true` if `term` is a binary; otherwise returns `false`.\n"
"\n"
"A binary always contains a complete number of bytes.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> is_binary \"foo\"\n"
"    true\n"
"    iex> is_binary <<1::3>>\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.is_integer(term)
#: lib/kernel.ex:359 
msgid ""
"Returns `true` if `term` is an integer; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Kernel.is_bitstring(term)
#: lib/kernel.ex:291 
msgid ""
"Returns `true` if `term` is a bitstring (including a binary); otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> is_bitstring \"foo\"\n"
"    true\n"
"    iex> is_bitstring <<1::3>>\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.put_in(path, value)
#: lib/kernel.ex:1855 
msgid ""
"Puts a value in a nested structure via the given `path`.\n"
"\n"
"This is similar to `put_in/3`, except the path is extracted via\n"
"a macro rather than passing a list. For example:\n"
"\n"
"    put_in(opts[:foo][:bar], :baz)\n"
"\n"
"Is equivalent to:\n"
"\n"
"    put_in(opts, [:foo, :bar], :baz)\n"
"\n"
"Note that in order for this macro to work, the complete path must always\n"
"be visible by this macro. For more information about the supported path\n"
"expressions, please check `get_and_update_in/2` docs.\n"
"\n"
"## Examples\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> put_in(users[\"john\"][:age], 28)\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> put_in(users[\"john\"].age, 28)\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.rem(left, right)
#: lib/kernel.ex:557 
msgid ""
"Computes the remainder of an integer division.\n"
"\n"
"Raises an `ArithmeticError` exception if one of the arguments is not an\n"
"integer.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> rem(5, 2)\n"
"    1\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.is_function(term)
#: lib/kernel.ex:330 
msgid ""
"Returns `true` if `term` is a function; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.sigil_S(term, modifiers)
#: lib/kernel.ex:3865 
msgid ""
"Handles the sigil `~S`.\n"
"\n"
"It simply returns a string without escaping characters and without\n"
"interpolations.\n"
"\n"
"## Examples\n"
"\n"
"    iex> ~S(foo)\n"
"    \"foo\"\n"
"\n"
"    iex> ~S(f#{o}o)\n"
"    \"f\\#{o}o\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.spawn_link(module, fun, args)
#: lib/kernel.ex:691 
msgid ""
"Spawns the given module and function passing the given args,\n"
"links it to the current process and returns its pid.\n"
"\n"
"Check the `Process` and `Node` modules for other functions\n"
"to handle processes, including spawning functions in nodes.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    spawn_link(SomeModule, :function, [1, 2, 3])\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.>(left, right)
#: lib/kernel.ex:997 
msgid ""
"Returns `true` if left is more than right.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 > 2\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.Kernel Summary
#: lib/kernel.ex:9 
msgid ""
"Provides the default macros and functions Elixir imports into your\n"
"environment.\n"
"\n"
"These macros and functions can be skipped or cherry-picked via the\n"
"`import/2` macro. For instance, if you want to tell Elixir not to\n"
"import the `if/2` macro, you can do:\n"
"\n"
"    import Kernel, except: [if: 2]\n"
"\n"
"Elixir also has special forms that are always imported and\n"
"cannot be skipped. These are described in `Kernel.SpecialForms`.\n"
"\n"
"Some of the functions described in this module are inlined by\n"
"the Elixir compiler into their Erlang counterparts in the `:erlang`\n"
"module. Those functions are called BIFs (builtin internal functions)\n"
"in Erlang-land and they exhibit interesting properties, as some of\n"
"them are allowed in guards and others are used for compiler\n"
"optimizations.\n"
"\n"
"Most of the inlined functions can be seen in effect when capturing\n"
"the function:\n"
"\n"
"    iex> &Kernel.is_atom/1\n"
"    &:erlang.is_atom/1\n"
"\n"
"Those functions will be explicitly marked in their docs as\n"
"\"inlined by the compiler\".\n"
msgstr ""
#. TRANSLATORS: def Kernel.node()
#: lib/kernel.ex:534 
msgid ""
"Returns an atom representing the name of the local node.\n"
"If the node is not alive, `:nonode@nohost` is returned instead.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Kernel.===(left, right)
#: lib/kernel.ex:1099 
msgid ""
"Returns `true` if the two items are match.\n"
"\n"
"This operator gives the same semantics as the one existing in\n"
"pattern matching, i.e., `1` and `1.0` are equal, but they do\n"
"not match.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 === 2\n"
"    false\n"
"\n"
"    iex> 1 === 1.0\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.sigil_w(term, modifiers)
#: lib/kernel.ex:4009 
msgid ""
"Handles the sigil `~w`.\n"
"\n"
"It returns a list of \"words\" split by whitespace. Character unescaping and\n"
"interpolation happens for each word.\n"
"\n"
"## Modifiers\n"
"\n"
"  * `s`: words in the list are strings (default)\n"
"  * `a`: words in the list are atoms\n"
"  * `c`: words in the list are char lists\n"
"\n"
"## Examples\n"
"\n"
"    iex> ~w(foo #{:bar} baz)\n"
"    [\"foo\", \"bar\", \"baz\"]\n"
"\n"
"    iex> ~w(--source test/enum_test.exs)\n"
"    [\"--source\", \"test/enum_test.exs\"]\n"
"\n"
"    iex> ~w(foo bar baz)a\n"
"    [:foo, :bar, :baz]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.update_in(data, keys, fun)
#: lib/kernel.ex:1742 
msgid ""
"Updates a key in a nested structure.\n"
"\n"
"Uses the `Access` module to traverse the structures\n"
"according to the given `keys`, unless the `key` is a\n"
"function. If the key is a function, it will be invoked\n"
"as specified in `get_and_update_in/3`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> update_in(users, [\"john\", :age], &(&1 + 1))\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"In case any of entries in the middle returns `nil`,\n"
"an error will be raised when trying to access it next.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.use(module, opts \\ [])
#: lib/kernel.ex:3676 
msgid ""
"Uses the given module in the current context.\n"
"\n"
"## Examples\n"
"\n"
"For example, in order to write tests using the ExUnit framework,\n"
"a developer should use the `ExUnit.Case` module:\n"
"\n"
"    defmodule AssertionTest do\n"
"      use ExUnit.Case, async: true\n"
"\n"
"      test \"always pass\" do\n"
"        assert true\n"
"      end\n"
"    end\n"
"\n"
"By calling `use/2`, a hook called `__using__/1` will be invoked in\n"
"`ExUnit.Case` which will then do the proper setup.\n"
"\n"
"Simply put, `use/2` translates to:\n"
"\n"
"    defmodule AssertionTest do\n"
"      require ExUnit.Case\n"
"      ExUnit.Case.__using__([async: true])\n"
"\n"
"      test \"always pass\" do\n"
"        assert true\n"
"      end\n"
"    end\n"
"\n"
"Where `__using__/1` is just a regular macro that can be defined\n"
"in any module:\n"
"\n"
"    defmodule MyModule do\n"
"      defmacro __using__(opts) do\n"
"        quote do\n"
"          # code that will run in the module that uses MyModule\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"## Best practices\n"
"\n"
"`__using__/1` is typically used when there is a need to set some state\n"
"(via module attributes) or callbacks (like `@before_compile`)\n"
"into the caller.\n"
"\n"
"`__using__/1` may also be used to alias, require or import functionality\n"
"from different modules:\n"
"\n"
"    defmodule MyModule do\n"
"      defmacro __using__(opts) do\n"
"        quote do\n"
"          import MyModule.Foo\n"
"          import MyModule.Bar\n"
"          import MyModule.Baz\n"
"\n"
"          alias MyModule.Repo\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"However, do not provide `__using__/1` if all it does is to import,\n"
"alias or require the module itself. For example, do not:\n"
"\n"
"    defmodule MyModule do\n"
"      defmacro __using__(opts) do\n"
"        quote do\n"
"          import MyModule\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"In such cases, developers must just import or alias the module\n"
"directly, allowing developers to customize those as they wish,\n"
"without the indirection behind `use/2`.\n"
"\n"
"Finally, developers should also avoid defining functions inside\n"
"the `__using__/1` callback, unless those functions are the default\n"
"implementation of a previously defined `@callback`. In case you\n"
"want to provide some existing functionality to the user module,\n"
"please define it in a module which will be imported accordingly.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.<>(left, right)
#: lib/kernel.ex:1265 
msgid ""
"Concatenates two binaries.\n"
"\n"
"## Examples\n"
"\n"
"    iex> \"foo\" <> \"bar\"\n"
"    \"foobar\"\n"
"\n"
"The `<>` operator can also be used in pattern matching (and guard clauses) as\n"
"long as the first part is a literal binary:\n"
"\n"
"    iex> \"foo\" <> x = \"foobar\"\n"
"    iex> x\n"
"    \"bar\"\n"
"\n"
"`x <> \"bar\" = \"foobar\"` would have resulted in a `CompileError` exception.\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.is_tuple(term)
#: lib/kernel.ex:420 
msgid ""
"Returns `true` if `term` is a tuple; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.defmacro(call, expr \\ nil)
#: lib/kernel.ex:3198 
msgid ""
"Defines a macro with the given name and body.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule MyLogic do\n"
"      defmacro unless(expr, opts) do\n"
"        quote do\n"
"          if !unquote(expr), unquote(opts)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    require MyLogic\n"
"    MyLogic.unless false do\n"
"      IO.puts \"It works\"\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.spawn(fun)
#: lib/kernel.ex:626 
msgid ""
"Spawns the given function and returns its pid.\n"
"\n"
"Check the `Process` and `Node` modules for other functions\n"
"to handle processes, including spawning functions in nodes.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    current = self()\n"
"    child   = spawn(fn -> send current, {self(), 1 + 2} end)\n"
"\n"
"    receive do\n"
"      {^child, 3} -> IO.puts \"Received 3 back\"\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.=~(left, right)
#: lib/kernel.ex:1485 
msgid ""
"Matches the term on the left against the regular expression or string on the\n"
"right. Returns `true` if `left` matches `right` (if it's a regular expression)\n"
"or contains `right` (if it's a string).\n"
"\n"
"## Examples\n"
"\n"
"    iex> \"abcd\" =~ ~r/c(d)/\n"
"    true\n"
"\n"
"    iex> \"abcd\" =~ ~r/e/\n"
"    false\n"
"\n"
"    iex> \"abcd\" =~ \"bc\"\n"
"    true\n"
"\n"
"    iex> \"abcd\" =~ \"ad\"\n"
"    false\n"
"\n"
"    iex> \"abcd\" =~ \"\"\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.defmodule(alias, list)
#: lib/kernel.ex:2933 
msgid ""
"Defines a module given by name with the given contents.\n"
"\n"
"This macro defines a module with the given `alias` as its name and with the\n"
"given contents. It returns a tuple with four elements:\n"
"\n"
"  * `:module`\n"
"  * the module name\n"
"  * the binary contents of the module\n"
"  * the result of evaluating the contents block\n"
"\n"
"## Examples\n"
"\n"
"    iex> defmodule Foo do\n"
"    ...>   def bar, do: :baz\n"
"    ...> end\n"
"    iex> Foo.bar\n"
"    :baz\n"
"\n"
"## Nesting\n"
"\n"
"Nesting a module inside another module affects the name of the nested module:\n"
"\n"
"    defmodule Foo do\n"
"      defmodule Bar do\n"
"      end\n"
"    end\n"
"\n"
"In the example above, two modules - `Foo` and `Foo.Bar` - are created.\n"
"When nesting, Elixir automatically creates an alias to the inner module,\n"
"allowing the second module `Foo.Bar` to be accessed as `Bar` in the same\n"
"lexical scope where it's defined (the `Foo` module).\n"
"\n"
"If the `Foo.Bar` module is moved somewhere else, the references to `Bar` in\n"
"the `Foo` module need to be updated to the fully-qualified name (`Foo.Bar`) or\n"
"an alias has to be explicitly set in the `Foo` module with the help of\n"
"`Kernel.SpecialForms.alias/2`.\n"
"\n"
"    defmodule Foo.Bar do\n"
"      # code\n"
"    end\n"
"\n"
"    defmodule Foo do\n"
"      alias Foo.Bar\n"
"      # code here can refer to \"Foo.Bar\" as just \"Bar\"\n"
"    end\n"
"\n"
"## Module names\n"
"\n"
"A module name can be any atom, but Elixir provides a special syntax which is\n"
"usually used for module names. What is called a module name is an\n"
"_uppercase ASCII letter_ followed by any number of _lowercase or\n"
"uppercase ASCII letters_, _numbers_, or _underscores_.\n"
"This identifier is equivilant to an atom prefixed by `Elixir.`. So in the\n"
"`defmodule Foo` example `Foo` is equivalent to `:\"Elixir.Foo\"`\n"
"\n"
"## Dynamic names\n"
"\n"
"Elixir module names can be dynamically generated. This is very\n"
"useful when working with macros. For instance, one could write:\n"
"\n"
"    defmodule String.to_atom(\"Foo#{1}\") do\n"
"      # contents ...\n"
"    end\n"
"\n"
"Elixir will accept any module name as long as the expression passed as the\n"
"first argument to `defmodule/2` evaluates to an atom.\n"
"Note that, when a dynamic name is used, Elixir won't nest the name under the\n"
"current module nor automatically set up an alias.\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.inspect(arg, opts \\ [])
#: lib/kernel.ex:1520 
msgid ""
"Inspects the given argument according to the `Inspect` protocol.\n"
"The second argument is a keyword list with options to control\n"
"inspection.\n"
"\n"
"## Options\n"
"\n"
"`inspect/2` accepts a list of options that are internally\n"
"translated to an `Inspect.Opts` struct. Check the docs for\n"
"`Inspect.Opts` to see the supported options.\n"
"\n"
"## Examples\n"
"\n"
"    iex> inspect(:foo)\n"
"    \":foo\"\n"
"\n"
"    iex> inspect [1, 2, 3, 4, 5], limit: 3\n"
"    \"[1, 2, 3, ...]\"\n"
"\n"
"    iex> inspect [1, 2, 3], pretty: true, width: 0\n"
"    \"[1,\\n 2,\\n 3]\"\n"
"\n"
"    iex> inspect(\"olá\" <> <<0>>)\n"
"    \"<<111, 108, 195, 161, 0>>\"\n"
"\n"
"    iex> inspect(\"olá\" <> <<0>>, binaries: :as_strings)\n"
"    \"\\\"olá\\\\0\\\"\"\n"
"\n"
"    iex> inspect(\"olá\", binaries: :as_binaries)\n"
"    \"<<111, 108, 195, 161>>\"\n"
"\n"
"    iex> inspect('bar')\n"
"    \"'bar'\"\n"
"\n"
"    iex> inspect([0|'bar'])\n"
"    \"[0, 98, 97, 114]\"\n"
"\n"
"    iex> inspect(100, base: :octal)\n"
"    \"0o144\"\n"
"\n"
"    iex> inspect(100, base: :hex)\n"
"    \"0x64\"\n"
"\n"
"Note that the `Inspect` protocol does not necessarily return a valid\n"
"representation of an Elixir term. In such cases, the inspected result\n"
"must start with `#`. For example, inspecting a function will return:\n"
"\n"
"    inspect fn a, b -> a + b end\n"
"    #=> #Function<...>\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.max(first, second)
#: lib/kernel.ex:494 
msgid ""
"Returns the biggest of the two given terms according to\n"
"Erlang's term ordering. If the terms compare equal, the\n"
"first one is returned.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> max(1, 2)\n"
"    2\n"
"    iex> max(:a, :b)\n"
"    :b\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.bit_size(bitstring)
#: lib/kernel.ex:118 
msgid ""
"Returns an integer which is the size in bits of `bitstring`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> bit_size(<<433::16, 3::3>>)\n"
"    19\n"
"\n"
"    iex> bit_size(<<1, 2, 3>>)\n"
"    24\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel...(first, last)
#: lib/kernel.ex:2550 
msgid ""
"Returns a range with the specified start and end.\n"
"\n"
"Both ends are included.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 0 in 1..3\n"
"    false\n"
"\n"
"    iex> 1 in 1..3\n"
"    true\n"
"\n"
"    iex> 2 in 1..3\n"
"    true\n"
"\n"
"    iex> 3 in 1..3\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.is_function(term, arity)
#: lib/kernel.ex:340 
msgid ""
"Returns `true` if `term` is a function that can be applied with `arity` number of arguments;\n"
"otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> is_function(fn(x) -> x * 2 end, 1)\n"
"    true\n"
"    iex> is_function(fn(x) -> x * 2 end, 2)\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.defimpl(name, opts, do_block \\ [])
#: lib/kernel.ex:3624 
msgid ""
"Defines an implementation for the given protocol.\n"
"\n"
"See `defprotocol/2` for more information and examples on protocols.\n"
"\n"
"Inside an implementation, the name of the protocol can be accessed\n"
"via `@protocol` and the current target as `@for`.\n"
msgstr ""
#. TRANSLATORS: def Kernel.hd(list)
#: lib/kernel.ex:245 
msgid ""
"Returns the head of a list; raises `ArgumentError` if the list is empty.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> hd([1, 2, 3, 4])\n"
"    1\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.abs(number)
#: lib/kernel.ex:41 
msgid ""
"Returns an integer or float which is the arithmetical absolute value of `number`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> abs(-3.33)\n"
"    3.33\n"
"\n"
"    iex> abs(-3)\n"
"    3\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.div(left, right)
#: lib/kernel.ex:160 
msgid ""
"Performs an integer division.\n"
"\n"
"Raises an `ArithmeticError` exception if one of the arguments is not an\n"
"integer.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> div(5, 2)\n"
"    2\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.min(first, second)
#: lib/kernel.ex:514 
msgid ""
"Returns the smallest of the two given terms according to\n"
"Erlang's term ordering. If the terms compare equal, the\n"
"first one is returned.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> min(1, 2)\n"
"    1\n"
"    iex> min(\"foo\", \"bar\")\n"
"    \"bar\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.binary_part(binary, start, length)
#: lib/kernel.ex:92 
msgid ""
"Extracts the part of the binary starting at `start` with length `length`.\n"
"Binaries are zero-indexed.\n"
"\n"
"If `start` or `length` reference in any way outside the binary, an\n"
"`ArgumentError` exception is raised.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> binary_part(\"foo\", 1, 2)\n"
"    \"oo\"\n"
"\n"
"A negative `length` can be used to extract bytes that come *before* the byte\n"
"at `start`:\n"
"\n"
"    iex> binary_part(\"Hello\", 5, -3)\n"
"    \"llo\"\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.sigil_s(term, modifiers)
#: lib/kernel.ex:3883 
msgid ""
"Handles the sigil `~s`.\n"
"\n"
"It returns a string as if it was a double quoted string, unescaping characters\n"
"and replacing interpolations.\n"
"\n"
"## Examples\n"
"\n"
"    iex> ~s(foo)\n"
"    \"foo\"\n"
"\n"
"    iex> ~s(f#{:o}o)\n"
"    \"foo\"\n"
"\n"
"    iex> ~s(f\\#{:o}o)\n"
"    \"f\\#{:o}o\"\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.defoverridable(keywords)
#: lib/kernel.ex:3638 
msgid ""
"Makes the given functions in the current module overridable.\n"
"\n"
"An overridable function is lazily defined, allowing a developer to override\n"
"it.\n"
"\n"
"## Example\n"
"\n"
"    defmodule DefaultMod do\n"
"      defmacro __using__(_opts) do\n"
"        quote do\n"
"          def test(x, y) do\n"
"            x + y\n"
"          end\n"
"\n"
"          defoverridable [test: 2]\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    defmodule InheritMod do\n"
"      use DefaultMod\n"
"\n"
"      def test(x, y) do\n"
"        x * y + super(x, y)\n"
"      end\n"
"    end\n"
"\n"
"As seen as in the example above, `super` can be used to call the default\n"
"implementation.\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.byte_size(binary)
#: lib/kernel.ex:137 
msgid ""
"Returns the number of bytes needed to contain `bitstring`.\n"
"\n"
"That is, if the number of bits in `bitstring` is not divisible by 8, the\n"
"resulting number of bytes will be rounded up (by excess). This operation\n"
"happens in constant time.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> byte_size(<<433::16, 3::3>>)\n"
"    3\n"
"\n"
"    iex> byte_size(<<1, 2, 3>>)\n"
"    3\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.reraise(msg, stacktrace)
#: lib/kernel.ex:1404 
msgid ""
"Raises an exception preserving a previous stacktrace.\n"
"\n"
"Works like `raise/1` but does not generate a new stacktrace.\n"
"\n"
"Notice that `System.stacktrace/0` returns the stacktrace\n"
"of the last exception. That said, it is common to assign\n"
"the stacktrace as the first expression inside a `rescue`\n"
"clause as any other exception potentially raised (and\n"
"rescued) between the rescue clause and the raise call\n"
"may change the `System.stacktrace/0` value.\n"
"\n"
"## Examples\n"
"\n"
"    try do\n"
"      raise \"oops\"\n"
"    rescue\n"
"      exception ->\n"
"        stacktrace = System.stacktrace\n"
"        if Exception.message(exception) == \"oops\" do\n"
"          reraise exception, stacktrace\n"
"        end\n"
"    end\n"
msgstr ""
#. TRANSLATORS: def Kernel.is_list(term)
#: lib/kernel.ex:369 
msgid ""
"Returns `true` if `term` is a list with zero or more elements; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Kernel.-(value)
#: lib/kernel.ex:858 
msgid ""
"Arithmetic unary minus.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> -2\n"
"    -2\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.defexception(fields)
#: lib/kernel.ex:3364 
msgid ""
"Defines an exception.\n"
"\n"
"Exceptions are structs backed by a module that implements\n"
"the `Exception` behaviour. The `Exception` behaviour requires\n"
"two functions to be implemented:\n"
"\n"
"  * `exception/1` - receives the arguments given to `raise/2`\n"
"    and returns the exception struct. The default implementation\n"
"    accepts either a set of keyword arguments that is merged into\n"
"    the struct or a string to be used as the exception's message.\n"
"\n"
"  * `message/1` - receives the exception struct and must return its\n"
"    message. Most commonly exceptions have a message field which\n"
"    by default is accessed by this function. However, if an exception\n"
"    does not have a message field, this function must be explicitly\n"
"    implemented.\n"
"\n"
"Since exceptions are structs, the API supported by `defstruct/1`\n"
"is also available in `defexception/1`.\n"
"\n"
"## Raising exceptions\n"
"\n"
"The most common way to raise an exception is via `raise/2`:\n"
"\n"
"    defmodule MyAppError do\n"
"      defexception [:message]\n"
"    end\n"
"\n"
"    value = [:hello]\n"
"\n"
"    raise MyAppError,\n"
"      message: \"did not get what was expected, got: #{inspect value}\"\n"
"\n"
"In many cases it is more convenient to pass the expected value to\n"
"`raise/2` and generate the message in the `exception/1` callback:\n"
"\n"
"    defmodule MyAppError do\n"
"      defexception [:message]\n"
"\n"
"      def exception(value) do\n"
"        msg = \"did not get what was expected, got: #{inspect value}\"\n"
"        %MyAppError{message: msg}\n"
"      end\n"
"    end\n"
"\n"
"    raise MyAppError, value\n"
"\n"
"The example above shows the preferred strategy for customizing\n"
"exception messages.\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.make_ref()
#: lib/kernel.ex:456 
msgid ""
"Returns an almost unique reference.\n"
"\n"
"The returned reference will re-occur after approximately 2^82 calls;\n"
"therefore it is unique enough for practical purposes.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    make_ref() #=> #Reference<0.0.0.135>\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.spawn_link(fun)
#: lib/kernel.ex:668 
msgid ""
"Spawns the given function, links it to the current process and returns its pid.\n"
"\n"
"Check the `Process` and `Node` modules for other functions\n"
"to handle processes, including spawning functions in nodes.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    current = self()\n"
"    child   = spawn_link(fn -> send current, {self(), 1 + 2} end)\n"
"\n"
"    receive do\n"
"      {^child, 3} -> IO.puts \"Received 3 back\"\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.node(arg)
#: lib/kernel.ex:545 
msgid ""
"Returns the node where the given argument is located.\n"
"The argument can be a pid, a reference, or a port.\n"
"If the local node is not alive, `:nonode@nohost` is returned.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.||(left, right)
#: lib/kernel.ex:2625 
msgid ""
"Provides a short-circuit operator that evaluates and returns the second\n"
"expression only if the first one does not evaluate to `true` (i.e., it\n"
"is either `nil` or `false`). Returns the first expression otherwise.\n"
"\n"
"Not allowed in guard clauses.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.empty?([1]) || Enum.empty?([1])\n"
"    false\n"
"\n"
"    iex> List.first([]) || true\n"
"    true\n"
"\n"
"    iex> Enum.empty?([1]) || 1\n"
"    1\n"
"\n"
"    iex> Enum.empty?([]) || throw(:bad)\n"
"    true\n"
"\n"
"Note that, unlike `or/2`, this operator accepts any expression\n"
"as the first argument, not only booleans.\n"
msgstr ""
#. TRANSLATORS: def Kernel.elem(tuple, index)
#: lib/kernel.ex:1145 
msgid ""
"Gets the element at the zero-based `index` in `tuple`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> tuple = {:foo, :bar, 3}\n"
"    iex> elem(tuple, 1)\n"
"    :bar\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.defstruct(fields)
#: lib/kernel.ex:3252 
msgid ""
"Defines a struct.\n"
"\n"
"A struct is a tagged map that allows developers to provide\n"
"default values for keys, tags to be used in polymorphic\n"
"dispatches and compile time assertions.\n"
"\n"
"The only thing needed to define a struct is a `__struct__/0` function that\n"
"returns a map with the struct fields and their default values. `defstruct/1`\n"
"is a convenience macro which defines such a function (as well as a `t` type\n"
"and deriving conveniences).\n"
"\n"
"When using `defstruct/1`, a struct named like the enclosing module is defined.\n"
"\n"
"For more information about structs, please check `Kernel.SpecialForms.%/2`.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule User do\n"
"      defstruct name: nil, age: nil\n"
"    end\n"
"\n"
"Struct fields are evaluated at compile-time, which allows\n"
"them to be dynamic. In the example below, `10 + 11` is\n"
"evaluated at compile-time and the age field is stored\n"
"with value `21`:\n"
"\n"
"    defmodule User do\n"
"      defstruct name: nil, age: 10 + 11\n"
"    end\n"
"\n"
"The `fields` argument is usually a keyword list with fields as keys and\n"
"default values as corresponding values. `defstruct/1` also supports a list of\n"
"atoms as its argument: in that case, the atoms in the list will be used as\n"
"the struct's fields and they will all default to `nil`.\n"
"\n"
"    defmodule Post do\n"
"      defstruct [:title, :content, :author]\n"
"    end\n"
"\n"
"## Deriving\n"
"\n"
"Although structs are maps, by default structs do not implement\n"
"any of the protocols implemented for maps. For example, attempting\n"
"to use a protocol with the `User` struct leads to an error:\n"
"\n"
"    john = %User{name: \"John\"}\n"
"    MyProtocol.call(john)\n"
"    ** (Protocol.UndefinedError) protocol MyProtocol not implemented for %User{...}\n"
"\n"
"`defstruct/1`, however, allows protocol implementations to be\n"
"*derived*. This can be done by defining a `@derive` attribute as a\n"
"list before invoking `defstruct/1`:\n"
"\n"
"    defmodule User do\n"
"      @derive [MyProtocol]\n"
"      defstruct name: nil, age: 10 + 11\n"
"    end\n"
"\n"
"    MyProtocol.call(john) #=> works\n"
"\n"
"For each protocol in the `@derive` list, Elixir will assert there is an\n"
"implementation of that protocol for any (regardless if fallback to any\n"
"is `true`) and check if the any implementation defines a `__deriving__/3`\n"
"callback. If so, the callback is invoked, otherwise an implementation\n"
"that simply points to the any implementation is automatically derived.\n"
"\n"
"## Types\n"
"\n"
"It is recommended to define types for structs. By convention such type\n"
"is called `t`. To define a struct inside a type, the struct literal syntax\n"
"is used:\n"
"\n"
"    defmodule User do\n"
"      defstruct name: \"John\", age: 25\n"
"      @type t :: %User{name: String.t, age: non_neg_integer}\n"
"    end\n"
"\n"
"It is recommended to only use the struct syntax when defining the struct's\n"
"type. When referring to another struct it's better to use `User.t`instead of\n"
"`%User{}`.\n"
"\n"
"The types of the struct fields that are not included in the struct's type\n"
"default to `term`.\n"
"\n"
"Structs whose internal structure is private to the local module (pattern\n"
"matching them or directly accessing their fields should not be allowed) should\n"
"use the `@opaque` attribute. Structs whose internal structure is public should\n"
"use `@type`.\n"
msgstr ""
#. TRANSLATORS: def Kernel.trunc(number)
#: lib/kernel.ex:774 
msgid ""
"Returns the integer part of `number`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> trunc(5.4)\n"
"    5\n"
"    iex> trunc(5.99)\n"
"    5\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.<(left, right)
#: lib/kernel.ex:979 
msgid ""
"Returns `true` if left is less than right.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 < 2\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.is_atom(term)
#: lib/kernel.ex:261 
msgid ""
"Returns `true` if `term` is an atom; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Kernel.get_and_update_in(data, keys, fun)
#: lib/kernel.ex:1764 
msgid ""
"Gets a value and updates a nested structure.\n"
"\n"
"It expects a tuple to be returned, containing the value\n"
"retrieved and the update one.\n"
"\n"
"Uses the `Access` module to traverse the structures\n"
"according to the given `keys`, unless the `key` is a\n"
"function.\n"
"\n"
"If a key is a function, the function will be invoked\n"
"passing three arguments, the operation (`:get_and_update`),\n"
"the data to be accessed, and a function to be invoked next.\n"
"\n"
"This means `get_and_update_in/3` can be extended to provide\n"
"custom lookups. The downside is that functions cannot be stored\n"
"as keys in the accessed data structures.\n"
"\n"
"## Examples\n"
"\n"
"This function is useful when there is a need to retrieve the current\n"
"value (or something calculated in function of the current value) and\n"
"update it at the same time. For example, it could be used to increase\n"
"the age of a user by one and return the previous age in one pass:\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> get_and_update_in(users, [\"john\", :age], &{&1, &1 + 1})\n"
"    {27, %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}}\n"
"\n"
"When one of the keys is a function, the function is invoked.\n"
"In the example below, we use a function to get and increment all\n"
"ages inside a list:\n"
"\n"
"    iex> users = [%{name: \"john\", age: 27}, %{name: \"meg\", age: 23}]\n"
"    iex> all = fn :get_and_update, data, next ->\n"
"    ...>   Enum.map(data, next) |> :lists.unzip\n"
"    ...> end\n"
"    iex> get_and_update_in(users, [all, :age], &{&1, &1 + 1})\n"
"    {[27, 23], [%{name: \"john\", age: 28}, %{name: \"meg\", age: 24}]}\n"
"\n"
"If the previous value before invoking the function is `nil`,\n"
"the function *will* receive `nil` as a value and must handle it\n"
"accordingly (be it by failing or providing a sane default).\n"
msgstr ""
#. TRANSLATORS: def Kernel.is_map(term)
#: lib/kernel.ex:430 
msgid ""
"Returns `true` if `term` is a map; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Kernel.!=(left, right)
#: lib/kernel.ex:1075 
msgid ""
"Returns `true` if the two items are not equal.\n"
"\n"
"This operator considers 1 and 1.0 to be equal. For match\n"
"comparison, use `!==` instead.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 != 2\n"
"    true\n"
"\n"
"    iex> 1 != 1.0\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.not(arg)
#: lib/kernel.ex:961 
msgid ""
"Boolean not.\n"
"\n"
"`arg` must be a boolean; if it's not, an `ArgumentError` exception is raised.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> not false\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.length(list)
#: lib/kernel.ex:440 
msgid ""
"Returns the length of `list`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> length([1, 2, 3, 4, 5, 6, 7, 8, 9])\n"
"    9\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.-(left, right)
#: lib/kernel.ex:826 
msgid ""
"Arithmetic subtraction.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 - 2\n"
"    -1\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.defmacrop(call, expr \\ nil)
#: lib/kernel.ex:3221 
msgid ""
"Defines a private macro with the given name and body.\n"
"\n"
"Private macros are only accessible from the same module in which they are\n"
"defined.\n"
"\n"
"Check `defmacro/2` for more information.\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.to_string(arg)
#: lib/kernel.ex:2125 
msgid ""
"Converts the argument to a string according to the\n"
"`String.Chars` protocol.\n"
"\n"
"This is the function invoked when there is string interpolation.\n"
"\n"
"## Examples\n"
"\n"
"    iex> to_string(:foo)\n"
"    \"foo\"\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.or(left, right)
#: lib/kernel.ex:1181 
msgid ""
"Boolean or.\n"
"\n"
"If the first argument is `true`, `true` is returned; otherwise, the second\n"
"argument is returned.\n"
"\n"
"Requires only the first argument to be a boolean since it short-circuits.\n"
"If the first argument is not a boolean, an `ArgumentError` exception is\n"
"raised.\n"
"\n"
"Allowed in guard tests.\n"
"\n"
"## Examples\n"
"\n"
"    iex> true or false\n"
"    true\n"
"    iex> false or 42\n"
"    42\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.put_elem(tuple, index, value)
#: lib/kernel.ex:1162 
msgid ""
"Inserts `value` at the given zero-based `index` in `tuple`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> tuple = {:foo, :bar, 3}\n"
"    iex> put_elem(tuple, 0, :baz)\n"
"    {:baz, :bar, 3}\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.pop_in(path)
#: lib/kernel.ex:1892 
msgid ""
"Pops a key from the nested structure via the given `path`.\n"
"\n"
"This is similar to `pop_in/2`, except the path is extracted via\n"
"a macro rather than passing a list. For example:\n"
"\n"
"    pop_in(opts[:foo][:bar])\n"
"\n"
"Is equivalent to:\n"
"\n"
"    pop_in(opts, [:foo, :bar])\n"
"\n"
"Note that in order for this macro to work, the complete path must always\n"
"be visible by this macro. For more information about the supported path\n"
"expressions, please check `get_and_update_in/2` docs.\n"
"\n"
"## Examples\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> pop_in(users[\"john\"][:age])\n"
"    {27, %{\"john\" => %{}, \"meg\" => %{age: 23}}}\n"
"\n"
"    iex> users = %{john: %{age: 27}, meg: %{age: 23}}\n"
"    iex> pop_in(users.john[:age])\n"
"    {27, %{john: %{}, meg: %{age: 23}}}\n"
"\n"
"In case any entry returns `nil`, its key will be removed\n"
"and the deletion will be considered a success.\n"
msgstr ""
#. TRANSLATORS: def Kernel.is_reference(term)
#: lib/kernel.ex:410 
msgid ""
"Returns `true` if `term` is a reference; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Kernel.+(left, right)
#: lib/kernel.ex:810 
msgid ""
"Arithmetic addition.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 + 2\n"
"    3\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.sigil_c(term, modifiers)
#: lib/kernel.ex:3929 
msgid ""
"Handles the sigil `~c`.\n"
"\n"
"It returns a char list as if it were a single quoted string, unescaping\n"
"characters and replacing interpolations.\n"
"\n"
"## Examples\n"
"\n"
"    iex> ~c(foo)\n"
"    'foo'\n"
"\n"
"    iex> ~c(f#{:o}o)\n"
"    'foo'\n"
"\n"
"    iex> ~c(f\\#{:o}o)\n"
"    'f\\#{:o}o'\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.is_float(term)
#: lib/kernel.ex:320 
msgid ""
"Returns `true` if `term` is a floating point number; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.binding(context \\ nil)
#: lib/kernel.ex:2366 
msgid ""
"Returns the binding for the given context as a keyword list.\n"
"\n"
"In the returned result, keys are variable names and values are the\n"
"corresponding variable values.\n"
"\n"
"If the given `context` is `nil` (by default it is), the binding for the\n"
"current context is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> x = 1\n"
"    iex> binding()\n"
"    [x: 1]\n"
"    iex> x = 2\n"
"    iex> binding()\n"
"    [x: 2]\n"
"\n"
"    iex> binding(:foo)\n"
"    []\n"
"    iex> var!(x, :foo) = 1\n"
"    1\n"
"    iex> binding(:foo)\n"
"    [x: 1]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.macro_exported?(module, macro, arity)
#: lib/kernel.ex:2739 
msgid ""
"Returns `true` if `module` is loaded and contains a\n"
"public `macro` with the given `arity`, otherwise `false`.\n"
"\n"
"Note that this function does not load the module in case\n"
"it is not loaded. Check `Code.ensure_loaded/1` for more\n"
"information.\n"
"\n"
"## Examples\n"
"\n"
"    iex> macro_exported?(Kernel, :use, 2)\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.put_in(data, keys, value)
#: lib/kernel.ex:1720 
msgid ""
"Puts a value in a nested structure.\n"
"\n"
"Uses the `Access` module to traverse the structures\n"
"according to the given `keys`, unless the `key` is a\n"
"function. If the key is a function, it will be invoked\n"
"as specified in `get_and_update_in/3`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> put_in(users, [\"john\", :age], 28)\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"In case any of entries in the middle returns `nil`,\n"
"an error will be raised when trying to access it next.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.|>(left, right)
#: lib/kernel.ex:2660 
msgid ""
"Pipe operator.\n"
"\n"
"This operator introduces the expression on the left-hand side as\n"
"the first argument to the function call on the right-hand side.\n"
"\n"
"## Examples\n"
"\n"
"    iex> [1, [2], 3] |> List.flatten()\n"
"    [1, 2, 3]\n"
"\n"
"The example above is the same as calling `List.flatten([1, [2], 3])`.\n"
"\n"
"The `|>` operator is mostly useful when there is a desire to execute a series\n"
"of operations resembling a pipeline:\n"
"\n"
"    iex> [1, [2], 3] |> List.flatten |> Enum.map(fn x -> x * 2 end)\n"
"    [2, 4, 6]\n"
"\n"
"In the example above, the list `[1, [2], 3]` is passed as the first argument\n"
"to the `List.flatten/1` function, then the flattened list is passed as the\n"
"first argument to the `Enum.map/2` function which doubles each element of the\n"
"list.\n"
"\n"
"In other words, the expression above simply translates to:\n"
"\n"
"    Enum.map(List.flatten([1, [2], 3]), fn x -> x * 2 end)\n"
"\n"
"Beware of operator precedence when using the pipe operator.\n"
"For example, the following expression:\n"
"\n"
"    String.graphemes \"Hello\" |> Enum.reverse\n"
"\n"
"Translates to:\n"
"\n"
"    String.graphemes(\"Hello\" |> Enum.reverse)\n"
"\n"
"which results in an error as the `Enumerable` protocol is not defined\n"
"for binaries. Adding explicit parentheses resolves the ambiguity:\n"
"\n"
"    String.graphemes(\"Hello\") |> Enum.reverse\n"
"\n"
"Or, even better:\n"
"\n"
"    \"Hello\" |> String.graphemes |> Enum.reverse\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.spawn(module, fun, args)
#: lib/kernel.ex:649 
msgid ""
"Spawns the given module and function passing the given args\n"
"and returns its pid.\n"
"\n"
"Check the `Process` and `Node` modules for other functions\n"
"to handle processes, including spawning functions in nodes.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    spawn(SomeModule, :function, [1, 2, 3])\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.is_pid(term)
#: lib/kernel.ex:390 
msgid ""
"Returns `true` if `term` is a pid (process identifier); otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Kernel.self()
#: lib/kernel.ex:616 
msgid ""
"Returns the pid (process identifier) of the calling process.\n"
"\n"
"Allowed in guard clauses. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.is_nil(term)
#: lib/kernel.ex:2154 
msgid ""
"Returns `true` if `term` is `nil`, `false` otherwise.\n"
"\n"
"Allowed in guard clauses.\n"
"\n"
"## Examples\n"
"\n"
"    iex> is_nil(1)\n"
"    false\n"
"\n"
"    iex> is_nil(nil)\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.defp(call, expr \\ nil)
#: lib/kernel.ex:3171 
msgid ""
"Defines a private function with the given name and body.\n"
"\n"
"Private functions are only accessible from within the module in which they are\n"
"defined. Trying to access a private function from outside the module it's\n"
"defined in results in an `UndefinedFunctionError` exception.\n"
"\n"
"Check `def/2` for more information.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Foo do\n"
"      def bar do\n"
"        sum(1, 2)\n"
"      end\n"
"\n"
"      defp sum(a, b), do: a + b\n"
"    end\n"
"\n"
"    Foo.bar #=> 3\n"
"    Foo.sum(1, 2) #=> ** (UndefinedFunctionError) undefined function Foo.sum/2\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.defdelegate(funs, opts)
#: lib/kernel.ex:3787 
msgid ""
"Defines a function that delegates to another module.\n"
"\n"
"Functions defined with `defdelegate/2` are public and can be invoked from\n"
"outside the module they're defined in (like if they were defined using\n"
"`def/2`). When the desire is to delegate as private functions, `import/2` should\n"
"be used.\n"
"\n"
"Delegation only works with functions; delegating macros is not supported.\n"
"\n"
"## Options\n"
"\n"
"  * `:to` - the expression to delegate to. Any expression\n"
"    is allowed and its results will be evaluated at runtime. Usually\n"
"    evaluates to the name of a module.\n"
"\n"
"  * `:as` - the function to call on the target given in `:to`.\n"
"    This parameter is optional and defaults to the name being\n"
"    delegated (`funs`).\n"
"\n"
"  * `:append_first` - if `true`, when delegated, the first argument\n"
"    passed to the delegated function will be relocated to the end of the\n"
"    arguments when dispatched to the target.\n"
"\n"
"    The motivation behind this is because Elixir normalizes\n"
"    the \"handle\" as the first argument while some Erlang modules\n"
"    expect it as the last argument.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule MyList do\n"
"      defdelegate reverse(list), to: :lists\n"
"      defdelegate other_reverse(list), to: :lists, as: :reverse\n"
"      defdelegate [reverse(list), map(list, callback)], to: :lists, append_first: true\n"
"    end\n"
"\n"
"    MyList.reverse([1, 2, 3])\n"
"    #=> [3, 2, 1]\n"
"\n"
"    MyList.other_reverse([1, 2, 3])\n"
"    #=> [3, 2, 1]\n"
"\n"
"    MyList.map([1, 2, 3], &(&1 * 2))\n"
"    #=> [2, 4, 6]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.function_exported?(module, function, arity)
#: lib/kernel.ex:2720 
msgid ""
"Returns `true` if `module` is loaded and contains a\n"
"public `function` with the given `arity`, otherwise `false`.\n"
"\n"
"Note that this function does not load the module in case\n"
"it is not loaded. Check `Code.ensure_loaded/1` for more\n"
"information.\n"
"\n"
"## Examples\n"
"\n"
"    iex> function_exported?(Enum, :member?, 2)\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.sigil_R(term, modifiers)
#: lib/kernel.ex:3989 
msgid ""
"Handles the sigil `~R`.\n"
"\n"
"It returns a regular expression pattern without escaping\n"
"nor interpreting interpolations.\n"
"\n"
"More information on regexes can be found in the `Regex` module.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.match?(~R(f#{1,3}o), \"f#o\")\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.defprotocol(name, list)
#: lib/kernel.ex:3449 
msgid ""
"Defines a protocol.\n"
"\n"
"A protocol specifies an API that should be defined by its\n"
"implementations.\n"
"\n"
"## Examples\n"
"\n"
"In Elixir, only `false` and `nil` are considered falsy values.\n"
"Everything else evaluates to `true` in `if/2` clauses. Depending\n"
"on the application, it may be important to specify a `blank?`\n"
"protocol that returns a boolean for other data types that should\n"
"be considered \"blank\". For instance, an empty list or an empty\n"
"binary could be considered blank.\n"
"\n"
"Such protocol could be implemented as follows:\n"
"\n"
"    defprotocol Blank do\n"
"      @doc \"Returns `true` if `data` is considered blank/empty\"\n"
"      def blank?(data)\n"
"    end\n"
"\n"
"Now that the protocol is defined it can be implemented. It needs to be\n"
"implemented for each Elixir type; for example:\n"
"\n"
"    # Integers are never blank\n"
"    defimpl Blank, for: Integer do\n"
"      def blank?(number), do: false\n"
"    end\n"
"\n"
"    # The only blank list is the empty one\n"
"    defimpl Blank, for: List do\n"
"      def blank?([]), do: true\n"
"      def blank?(_),  do: false\n"
"    end\n"
"\n"
"    # The only blank atoms are \"false\" and \"nil\"\n"
"    defimpl Blank, for: Atom do\n"
"      def blank?(false), do: true\n"
"      def blank?(nil),   do: true\n"
"      def blank?(_),     do: false\n"
"    end\n"
"\n"
"The implementation of the `Blank` protocol would need to be defined for all\n"
"Elixir types. The available types are:\n"
"\n"
"  * Structs (see below)\n"
"  * `Tuple`\n"
"  * `Atom`\n"
"  * `List`\n"
"  * `BitString`\n"
"  * `Integer`\n"
"  * `Float`\n"
"  * `Function`\n"
"  * `PID`\n"
"  * `Map`\n"
"  * `Port`\n"
"  * `Reference`\n"
"  * `Any` (see below)\n"
"\n"
"## Protocols and Structs\n"
"\n"
"The real benefit of protocols comes when mixed with structs.\n"
"For instance, Elixir ships with many data types implemented as\n"
"structs, like `MapSet`. We can implement the `Blank` protocol\n"
"for those types as well:\n"
"\n"
"    defimpl Blank, for: MapSet do\n"
"      def blank?(enum_like), do: Enum.empty?(enum_like)\n"
"    end\n"
"\n"
"When implementing a protocol for a struct, the `:for` option can\n"
"be omitted if the `defimpl` call is inside the module that defines\n"
"the struct:\n"
"\n"
"    defmodule User do\n"
"      defstruct [:email, :name]\n"
"\n"
"      defimpl Blank do\n"
"        def blank?(%User{}), do: false\n"
"      end\n"
"    end\n"
"\n"
"If a protocol is not found for a given type, it will fallback to\n"
"`Any`. Protocols that are implemented for maps don't work by default\n"
"on structs; look at `defstruct/1` for more information about deriving\n"
"protocols.\n"
"\n"
"## Fallback to any\n"
"\n"
"In some cases, it may be convenient to provide a default\n"
"implementation for all types. This can be achieved by\n"
"setting the `@fallback_to_any` attribute to `true` in the protocol\n"
"definition:\n"
"\n"
"    defprotocol Blank do\n"
"      @fallback_to_any true\n"
"      def blank?(data)\n"
"    end\n"
"\n"
"The `Blank` protocol can now be implemented for `Any`:\n"
"\n"
"    defimpl Blank, for: Any do\n"
"      def blank?(_), do: true\n"
"    end\n"
"\n"
"One may wonder why such behaviour (fallback to any) is not the default one.\n"
"\n"
"It is two-fold: first, the majority of protocols cannot\n"
"implement an action in a generic way for all types; in fact,\n"
"providing a default implementation may be harmful, because users\n"
"may rely on the default implementation instead of providing a\n"
"specialized one.\n"
"\n"
"Second, falling back to `Any` adds an extra lookup to all types,\n"
"which is unnecessary overhead unless an implementation for `Any` is\n"
"required.\n"
"\n"
"## Types\n"
"\n"
"Defining a protocol automatically defines a type named `t`, which\n"
"can be used as follows:\n"
"\n"
"    @spec present?(Blank.t) :: boolean\n"
"    def present?(blank) do\n"
"      not Blank.blank?(blank)\n"
"    end\n"
"\n"
"The `@spec` above expresses that all types allowed to implement the\n"
"given protocol are valid argument types for the given function.\n"
"\n"
"## Reflection\n"
"\n"
"Any protocol module contains three extra functions:\n"
"\n"
"  * `__protocol__/1` - returns the protocol name when `:name` is given, and a\n"
"    keyword list with the protocol functions and their arities when\n"
"    `:functions` is given\n"
"\n"
"  * `impl_for/1` - receives a structure and returns the module that\n"
"    implements the protocol for the structure, `nil` otherwise\n"
"\n"
"  * `impl_for!/1` - same as above but raises an error if an implementation is\n"
"    not found\n"
"\n"
"        Enumerable.__protocol__(:functions)\n"
"        #=> [count: 1, member?: 2, reduce: 3]\n"
"\n"
"        Enumerable.impl_for([])\n"
"        #=> Enumerable.List\n"
"\n"
"        Enumerable.impl_for(42)\n"
"        #=> nil\n"
"\n"
"## Consolidation\n"
"\n"
"In order to cope with code loading in development, protocols in\n"
"Elixir provide a slow implementation of protocol dispatching specific\n"
"to development.\n"
"\n"
"In order to speed up dispatching in production environments, where\n"
"all implementations are known up-front, Elixir provides a feature\n"
"called protocol consolidation. For this reason, all protocols are\n"
"compiled with `debug_info` set to `true`, regardless of the option\n"
"set by `elixirc` compiler. The debug info though may be removed\n"
"after consolidation.\n"
"\n"
"For more information on how to apply protocol consolidation to\n"
"a given project, please check the functions in the `Protocol`\n"
"module or the `mix compile.protocols` task.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.sigil_r(term, modifiers)
#: lib/kernel.ex:3960 
msgid ""
"Handles the sigil `~r`.\n"
"\n"
"It returns a regular expression pattern, unescaping characters and replacing\n"
"interpolations.\n"
"\n"
"More information on regexes can be found in the `Regex` module.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.match?(~r(foo), \"foo\")\n"
"    true\n"
"\n"
"    iex> Regex.match?(~r/abc/, \"abc\")\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.to_char_list(arg)
#: lib/kernel.ex:2141 
msgid ""
"Converts the argument to a char list according to the `List.Chars` protocol.\n"
"\n"
"## Examples\n"
"\n"
"    iex> to_char_list(:foo)\n"
"    'foo'\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.spawn_monitor(fun)
#: lib/kernel.ex:710 
msgid ""
"Spawns the given function, monitors it and returns its pid\n"
"and monitoring reference.\n"
"\n"
"Check the `Process` and `Node` modules for other functions\n"
"to handle processes, including spawning functions in nodes.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    current = self()\n"
"    spawn_monitor(fn -> send current, {self(), 1 + 2} end)\n"
"\n"
msgstr ""
