#. TRANSLATORS: defmacro Kernel.|>(left, right)
#: lib/kernel.ex:2372 
msgid ""
"`|>` is the pipe operator.\n"
"\n"
"This operator introduces the expression on the left as\n"
"the first argument to the function call on the right.\n"
"\n"
"## Examples\n"
"\n"
"    iex> [1, [2], 3] |> List.flatten()\n"
"    [1, 2, 3]\n"
"\n"
"The example above is the same as calling `List.flatten([1, [2], 3])`,\n"
"i.e. the argument on the left side of `|>` is introduced as the first\n"
"argument of the function call on the right side.\n"
"\n"
"This pattern is mostly useful when there is a desire to execute\n"
"a bunch of operations, resembling a pipeline:\n"
"\n"
"    iex> [1, [2], 3] |> List.flatten |> Enum.map(fn x -> x * 2 end)\n"
"    [2, 4, 6]\n"
"\n"
"The example above will pass the list to `List.flatten/1`, then get\n"
"the flattened list and pass to `Enum.map/2`, which will multiply\n"
"each entry in the list per two.\n"
"\n"
"In other words, the expression above simply translates to:\n"
"\n"
"    Enum.map(List.flatten([1, [2], 3]), fn x -> x * 2 end)\n"
"\n"
"Beware of operator precedence when using the pipe operator.\n"
"For example, the following expression:\n"
"\n"
"    String.graphemes \"Hello\" |> Enum.reverse\n"
"\n"
"Translates to:\n"
"\n"
"    String.graphemes(\"Hello\" |> Enum.reverse)\n"
"\n"
"Which will result in an error as Enumerable protocol is not defined\n"
"for binaries. Adding explicit parenthesis resolves the ambiguity:\n"
"\n"
"    String.graphemes(\"Hello\") |> Enum.reverse\n"
"\n"
"Or, even better:\n"
"\n"
"    \"Hello\" |> String.graphemes |> Enum.reverse\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.use(module, opts \\ [])
#: lib/kernel.ex:3245 
msgid ""
"`use` is a simple mechanism for using a given module into\n"
"the current context.\n"
"\n"
"## Examples\n"
"\n"
"For example, in order to write tests using the ExUnit framework,\n"
"a developer should use the `ExUnit.Case` module:\n"
"\n"
"    defmodule AssertionTest do\n"
"      use ExUnit.Case, async: true\n"
"\n"
"      test \"always pass\" do\n"
"        assert true\n"
"      end\n"
"    end\n"
"\n"
"By calling `use`, a hook called `__using__` will be invoked in\n"
"`ExUnit.Case` which will then do the proper setup.\n"
"\n"
"Simply put, `use` is simply a translation to:\n"
"\n"
"    defmodule AssertionTest do\n"
"      require ExUnit.Case\n"
"      ExUnit.Case.__using__([async: true])\n"
"\n"
"      test \"always pass\" do\n"
"        assert true\n"
"      end\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.Kernel Summary
#: lib/kernel.ex:8 
msgid ""
"`Kernel` provides the default macros and functions\n"
"Elixir imports into your environment. These macros and functions\n"
"can be skipped or cherry-picked via the `import` macro. For\n"
"instance, if you want to tell Elixir not to import the `if`\n"
"macro, you can do:\n"
"\n"
"    import Kernel, except: [if: 2]\n"
"\n"
"Elixir also has special forms that are always imported and\n"
"cannot be skipped. These are described in `Kernel.SpecialForms`.\n"
"\n"
"Some of the functions described in this module are inlined by\n"
"the Elixir compiler into their Erlang counterparts in the `:erlang`\n"
"module. Those functions are called BIFs (builtin internal functions)\n"
"in Erlang-land and they exhibit interesting properties, as some of\n"
"them are allowed in guards and others are used for compiler\n"
"optimizations.\n"
"\n"
"Most of the inlined functions can be seen in effect when capturing\n"
"the function:\n"
"\n"
"    iex> &Kernel.is_atom/1\n"
"    &:erlang.is_atom/1\n"
"\n"
"Those functions will be explicitly marked in their docs as\n"
"\"inlined by the compiler\".\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.var!(var, context \\ nil)
#: lib/kernel.ex:2514 
msgid ""
"When used inside quoting, marks that the variable should\n"
"not be hygienized. The argument can be either a variable\n"
"unquoted or in standard tuple form `{name, meta, context}`.\n"
"\n"
"Check `Kernel.SpecialForms.quote/2` for more information.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.alias!(alias)
#: lib/kernel.ex:2544 
msgid ""
"When used inside quoting, marks that the alias should not\n"
"be hygienized. This means the alias will be expanded when\n"
"the macro is expanded.\n"
"\n"
"Check `Kernel.SpecialForms.quote/2` for more information.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.update_in(path, fun)
#: lib/kernel.ex:1729 
msgid ""
"Updates a nested structure via the given `path`.\n"
"\n"
"This is similar to `update_in/3`, except the path is extracted via\n"
"a macro rather than passing a list. For example:\n"
"\n"
"    update_in(opts[:foo][:bar], &(&1 + 1))\n"
"\n"
"Is equivalent to:\n"
"\n"
"    update_in(opts, [:foo, :bar], &(&1 + 1))\n"
"\n"
"Note that in order for this macro to work, the complete path must always\n"
"be visible by this macro. For more information about the supported path\n"
"expressions, please check `get_and_update_in/2` docs.\n"
"\n"
"## Examples\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> update_in(users[\"john\"][:age], &(&1 + 1))\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> update_in(users[\"john\"].age, &(&1 + 1))\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.update_in(data, keys, fun)
#: lib/kernel.ex:1607 
msgid ""
"Updates a key in a nested structure.\n"
"\n"
"Uses the `Access` protocol to traverse the structures\n"
"according to the given `keys`, unless the `key` is a\n"
"function. If the key is a function, it will be invoked\n"
"as specified in `get_and_update_in/3`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> update_in(users, [\"john\", :age], &(&1 + 1))\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"In case any of entries in the middle returns `nil`,\n"
"an error will be raised when trying to access it next.\n"
msgstr ""
#. TRANSLATORS: def Kernel.exit(reason)
#: lib/kernel.ex:238 
msgid ""
"Stops the execution of the calling process with the given reason.\n"
"\n"
"Since evaluating this function causes the process to terminate,\n"
"it has no return value.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"When a process reaches its end, by default it exits with\n"
"reason `:normal`. You can also call it explicitly if you\n"
"want to terminate a process but not signal any failure:\n"
"\n"
"    exit(:normal)\n"
"\n"
"In case something goes wrong, you can also use `exit/1` with\n"
"a different reason:\n"
"\n"
"    exit(:seems_bad)\n"
"\n"
"If the reason is not `:normal`, all linked process to the\n"
"exited process will crash (unless they are trapping exits).\n"
"\n"
"## OTP exits\n"
"\n"
"Exits are used by OTP to determine if a process exited abnormally\n"
"or not. The following exits are considered \"normal\":\n"
"\n"
"  * `exit(:normal)`\n"
"  * `exit(:shutdown)`\n"
"  * `exit({:shutdown, term})`\n"
"\n"
"Exiting with any other reason is considered abnormal and treated\n"
"as a crash. This means the default supervisor behaviour kicks in,\n"
"error reports are emitted, etc.\n"
"\n"
"This behaviour is relied on in many different places. For example,\n"
"`ExUnit` uses `exit(:shutdown)` when exiting the test process to\n"
"signal linked processes, supervision trees and so on to politely\n"
"shutdown too.\n"
"\n"
"## CLI exits\n"
"\n"
"Building on top of the exit signals mentioned above, if the\n"
"process started by the command line exits with any of the three\n"
"reasons above, its exit is considered normal and the Operating\n"
"System process will exit with status 0.\n"
"\n"
"It is, however, possible to customize the Operating System exit\n"
"signal by invoking:\n"
"\n"
"    exit({:shutdown, integer})\n"
"\n"
"This will cause the OS process to exit with the status given by\n"
"`integer` while signaling all linked OTP processes to politely\n"
"shutdown.\n"
"\n"
"Any other exit reason will cause the OS process to exit with\n"
"status `1` and linked OTP processes to crash.\n"
msgstr ""
#. TRANSLATORS: def Kernel.macro_exported?(module, macro, arity)
#: lib/kernel.ex:2399 
msgid ""
"Returns true if the `module` is loaded and contains a\n"
"public `macro` with the given `arity`, otherwise false.\n"
"\n"
"Notice that this function does not load the module in case\n"
"it is not loaded. Check `Code.ensure_loaded/1` for more\n"
"information.\n"
msgstr ""
#. TRANSLATORS: def Kernel.function_exported?(module, function, arity)
#: lib/kernel.ex:2386 
msgid ""
"Returns true if the `module` is loaded and contains a\n"
"public `function` with the given `arity`, otherwise false.\n"
"\n"
"Notice that this function does not load the module in case\n"
"it is not loaded. Check `Code.ensure_loaded/1` for more\n"
"information.\n"
msgstr ""
#. TRANSLATORS: def Kernel.bit_size(bitstring)
#: lib/kernel.ex:131 
msgid ""
"Returns an integer which is the size in bits of `bitstring`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> bit_size(<<433::16, 3::3>>)\n"
"    19\n"
"\n"
"    iex> bit_size(<<1, 2, 3>>)\n"
"    24\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.abs(number)
#: lib/kernel.ex:55 
msgid ""
"Returns an integer or float which is the arithmetical absolute value of `number`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> abs(-3.33)\n"
"    3.33\n"
"\n"
"    iex> abs(-3)\n"
"    3\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.defprotocol(name, list2)
#: lib/kernel.ex:3161 
msgid ""
"Defines a protocol.\n"
"\n"
"A protocol specifies an API that should be defined by its\n"
"implementations.\n"
"\n"
"## Examples\n"
"\n"
"In Elixir, only `false` and `nil` are considered falsy values.\n"
"Everything else evaluates to true in `if` clauses. Depending\n"
"on the application, it may be important to specify a `blank?`\n"
"protocol that returns a boolean for other data types that should\n"
"be considered `blank?`. For instance, an empty list or an empty\n"
"binary could be considered blanks.\n"
"\n"
"We could implement this protocol as follow:\n"
"\n"
"    defprotocol Blank do\n"
"      @doc \"Returns true if data is considered blank/empty\"\n"
"      def blank?(data)\n"
"    end\n"
"\n"
"Now that the protocol is defined, we can implement it. We need\n"
"to implement the protocol for each Elixir type. For example:\n"
"\n"
"    # Integers are never blank\n"
"    defimpl Blank, for: Integer do\n"
"      def blank?(number), do: false\n"
"    end\n"
"\n"
"    # Just empty list is blank\n"
"    defimpl Blank, for: List do\n"
"      def blank?([]), do: true\n"
"      def blank?(_),  do: false\n"
"    end\n"
"\n"
"    # Just the atoms false and nil are blank\n"
"    defimpl Blank, for: Atom do\n"
"      def blank?(false), do: true\n"
"      def blank?(nil),   do: true\n"
"      def blank?(_),     do: false\n"
"    end\n"
"\n"
"And we would have to define the implementation for all types.\n"
"The supported types available are:\n"
"\n"
"  * Structs (see below)\n"
"  * `Tuple`\n"
"  * `Atom`\n"
"  * `List`\n"
"  * `BitString`\n"
"  * `Integer`\n"
"  * `Float`\n"
"  * `Function`\n"
"  * `PID`\n"
"  * `Map`\n"
"  * `Port`\n"
"  * `Reference`\n"
"  * `Any` (see below)\n"
"\n"
"## Protocols + Structs\n"
"\n"
"The real benefit of protocols comes when mixed with structs.\n"
"For instance, Elixir ships with many data types implemented as\n"
"structs, like `HashDict` and `HashSet`. We can implement the\n"
"`Blank` protocol for those types as well:\n"
"\n"
"    defimpl Blank, for: [HashDict, HashSet] do\n"
"      def blank?(enum_like), do: Enum.empty?(enum_like)\n"
"    end\n"
"\n"
"If a protocol is not found for a given type, it will fallback to\n"
"`Any`.\n"
"\n"
"## Fallback to any\n"
"\n"
"In some cases, it may be convenient to provide a default\n"
"implementation for all types. This can be achieved by\n"
"setting `@fallback_to_any` to `true` in the protocol\n"
"definition:\n"
"\n"
"    defprotocol Blank do\n"
"      @fallback_to_any true\n"
"      def blank?(data)\n"
"    end\n"
"\n"
"Which can now be implemented as:\n"
"\n"
"    defimpl Blank, for: Any do\n"
"      def blank?(_), do: true\n"
"    end\n"
"\n"
"One may wonder why such fallback is not true by default.\n"
"\n"
"It is two-fold: first, the majority of protocols cannot\n"
"implement an action in a generic way for all types. In fact,\n"
"providing a default implementation may be harmful, because users\n"
"may rely on the default implementation instead of providing a\n"
"specialized one.\n"
"\n"
"Second, falling back to `Any` adds an extra lookup to all types,\n"
"which is unnecessary overhead unless an implementation for Any is\n"
"required.\n"
"\n"
"## Types\n"
"\n"
"Defining a protocol automatically defines a type named `t`, which\n"
"can be used as:\n"
"\n"
"    @spec present?(Blank.t) :: boolean\n"
"    def present?(blank) do\n"
"      not Blank.blank?(blank)\n"
"    end\n"
"\n"
"The `@spec` above expresses that all types allowed to implement the\n"
"given protocol are valid argument types for the given function.\n"
"\n"
"## Reflection\n"
"\n"
"Any protocol module contains three extra functions:\n"
"\n"
"\n"
"  * `__protocol__/1` - returns the protocol name when `:name` is given, and a\n"
"    keyword list with the protocol functions when `:functions` is given\n"
"\n"
"  * `impl_for/1` - receives a structure and returns the module that\n"
"    implements the protocol for the structure, `nil` otherwise\n"
"\n"
"  * `impl_for!/1` - same as above but raises an error if an implementation is\n"
"    not found\n"
"\n"
"## Consolidation\n"
"\n"
"In order to cope with code loading in development, protocols in\n"
"Elixir provide a slow implementation of protocol dispatching specific\n"
"to development.\n"
"\n"
"In order to speed up dispatching in production environments, where\n"
"all implementations are known up-front, Elixir provides a feature\n"
"called protocol consolidation. For this reason, all protocols are\n"
"compiled with `debug_info` set to true, regardless of the option\n"
"set by `elixirc` compiler. The debug info though may be removed\n"
"after consolidation.\n"
"\n"
"For more information on how to apply protocol consolidation to\n"
"a given project, please check the functions in the `Protocol`\n"
"module or the `mix compile.protocols` task.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.defmodule(alias, list2)
#: lib/kernel.ex:2604 
msgid ""
"Defines a module given by name with the given contents.\n"
"\n"
"It returns the module name, the module binary and the\n"
"block contents result.\n"
"\n"
"## Examples\n"
"\n"
"    iex> defmodule Foo do\n"
"    ...>   def bar, do: :baz\n"
"    ...> end\n"
"    iex> Foo.bar\n"
"    :baz\n"
"\n"
"## Nesting\n"
"\n"
"Nesting a module inside another module affects its name:\n"
"\n"
"    defmodule Foo do\n"
"      defmodule Bar do\n"
"      end\n"
"    end\n"
"\n"
"In the example above, two modules `Foo` and `Foo.Bar` are created.\n"
"When nesting, Elixir automatically creates an alias, allowing the\n"
"second module `Foo.Bar` to be accessed as `Bar` in the same lexical\n"
"scope.\n"
"\n"
"This means that, if the module `Bar` is moved to another file,\n"
"the references to `Bar` needs to be updated or an alias needs to\n"
"be explicitly set with the help of `Kernel.SpecialForms.alias/2`.\n"
"\n"
"## Dynamic names\n"
"\n"
"Elixir module names can be dynamically generated. This is very\n"
"useful for macros. For instance, one could write:\n"
"\n"
"    defmodule String.to_atom(\"Foo#{1}\") do\n"
"      # contents ...\n"
"    end\n"
"\n"
"Elixir will accept any module name as long as the expression\n"
"returns an atom. Note that, when a dynamic name is used, Elixir\n"
"won't nest the name under the current module nor automatically\n"
"set up an alias.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.defmacro(call, expr \\ nil)
#: lib/kernel.ex:2788 
msgid ""
"Defines a macro with the given name and contents.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule MyLogic do\n"
"      defmacro unless(expr, opts) do\n"
"        quote do\n"
"          if !unquote(expr), unquote(opts)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    require MyLogic\n"
"    MyLogic.unless false do\n"
"      IO.puts \"It works\"\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.defmacrop(call, expr \\ nil)
#: lib/kernel.ex:2798 
msgid ""
"Defines a macro that is private. Private macros are\n"
"only accessible from the same module in which they are defined.\n"
"\n"
"Check `defmacro/2` for more information\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.def(call, expr \\ nil)
#: lib/kernel.ex:2742 
msgid ""
"Defines a function with the given name and contents.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Foo do\n"
"      def bar, do: :baz\n"
"    end\n"
"\n"
"    Foo.bar #=> :baz\n"
"\n"
"A function that expects arguments can be defined as follow:\n"
"\n"
"    defmodule Foo do\n"
"      def sum(a, b) do\n"
"        a + b\n"
"      end\n"
"    end\n"
"\n"
"In the example above, we defined a function `sum` that receives\n"
"two arguments and sums them.\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.defp(call, expr \\ nil)
#: lib/kernel.ex:2765 
msgid ""
"Defines a function that is private. Private functions are\n"
"only accessible from within the module in which they are defined.\n"
"\n"
"Check `def/2` for more information\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Foo do\n"
"      def bar do\n"
"        sum(1, 2)\n"
"      end\n"
"\n"
"      defp sum(a, b), do: a + b\n"
"    end\n"
"\n"
"In the example above, `sum` is private and accessing it\n"
"through `Foo.sum` will raise an error.\n"
msgstr ""
#. TRANSLATORS: def Kernel.!==(left, right)
#: lib/kernel.ex:1066 
msgid ""
"Returns `true` if the two items do not match.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 !== 2\n"
"    true\n"
"\n"
"    iex> 1 !== 1.0\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.!=(left, right)
#: lib/kernel.ex:1020 
msgid ""
"Returns `true` if the two items are not equal.\n"
"\n"
"This operator considers 1 and 1.0 to be equal. For match\n"
"comparison, use `!==` instead.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 != 2\n"
"    true\n"
"\n"
"    iex> 1 != 1.0\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.===(left, right)
#: lib/kernel.ex:1045 
msgid ""
"Returns `true` if the two items are match.\n"
"\n"
"This operator gives the same semantics as the one existing in\n"
"pattern matching, i.e., `1` and `1.0` are equal, but they do\n"
"not match.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 === 2\n"
"    false\n"
"\n"
"    iex> 1 === 1.0\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.==(left, right)
#: lib/kernel.ex:996 
msgid ""
"Returns `true` if the two items are equal.\n"
"\n"
"This operator considers 1 and 1.0 to be equal. For match\n"
"semantics, use `===` instead.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 == 2\n"
"    false\n"
"\n"
"    iex> 1 == 1.0\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.>(left, right)
#: lib/kernel.ex:936 
msgid ""
"Returns `true` if left is more than right.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 > 2\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.>=(left, right)
#: lib/kernel.ex:972 
msgid ""
"Returns `true` if left is more than or equal to right.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 >= 2\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.<(left, right)
#: lib/kernel.ex:918 
msgid ""
"Returns `true` if left is less than right.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 < 2\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.<=(left, right)
#: lib/kernel.ex:954 
msgid ""
"Returns `true` if left is less than or equal to right.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 <= 2\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.--(left, right)
#: lib/kernel.ex:884 
msgid ""
"Removes the first occurrence of an item on the left\n"
"for each item on the right.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> [1, 2, 3] -- [1, 2]\n"
"    [3]\n"
"\n"
"    iex> [1, 2, 3, 2, 1] -- [1, 2, 2]\n"
"    [3,1]\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.is_nil(term)
#: lib/kernel.ex:1894 
msgid ""
"Returns `true` if `term` is nil; otherwise returns `false`.\n"
"\n"
"Allowed in guard clauses.\n"
"\n"
"## Examples\n"
"\n"
"    iex> is_nil(1)\n"
"    false\n"
"\n"
"    iex> is_nil(nil)\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.is_boolean(term)
#: lib/kernel.ex:291 
msgid ""
"Returns `true` if `term` is either the atom `true` or the atom `false` (i.e. a boolean);\n"
"otherwise returns false.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Kernel.is_number(term)
#: lib/kernel.ex:353 
msgid ""
"Returns `true` if `term` is either an integer or a floating point number;\n"
"otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Kernel.is_integer(term)
#: lib/kernel.ex:332 
msgid ""
"Returns `true` if `term` is an integer; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Kernel.is_atom(term)
#: lib/kernel.ex:258 
msgid ""
"Returns `true` if `term` is an atom; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Kernel.is_tuple(term)
#: lib/kernel.ex:393 
msgid ""
"Returns `true` if `term` is a tuple; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Kernel.is_reference(term)
#: lib/kernel.ex:383 
msgid ""
"Returns `true` if `term` is a reference; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Kernel.is_port(term)
#: lib/kernel.ex:373 
msgid ""
"Returns `true` if `term` is a port identifier; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Kernel.is_pid(term)
#: lib/kernel.ex:363 
msgid ""
"Returns `true` if `term` is a pid (process identifier); otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Kernel.is_map(term)
#: lib/kernel.ex:403 
msgid ""
"Returns `true` if `term` is a map; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Kernel.is_list(term)
#: lib/kernel.ex:342 
msgid ""
"Returns `true` if `term` is a list with zero or more elements; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Kernel.is_function(term)
#: lib/kernel.ex:311 
msgid ""
"Returns `true` if `term` is a function; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Kernel.is_function(term, arity)
#: lib/kernel.ex:322 
msgid ""
"Returns `true` if `term` is a function that can be applied with `arity` number of arguments;\n"
"otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Kernel.is_float(term)
#: lib/kernel.ex:301 
msgid ""
"Returns `true` if `term` is a floating point number; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Kernel.is_bitstring(term)
#: lib/kernel.ex:280 
msgid ""
"Returns `true` if `term` is a bitstring (including a binary); otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Kernel.is_binary(term)
#: lib/kernel.ex:270 
msgid ""
"Returns `true` if `term` is a binary; otherwise returns `false`.\n"
"\n"
"A binary always contains a complete number of bytes.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.!(arg)
#: lib/kernel.ex:1152 
msgid ""
"Receives any argument and returns `true` if it is `false`\n"
"or `nil`. Returns `false` otherwise. Not allowed in guard\n"
"clauses.\n"
"\n"
"## Examples\n"
"\n"
"    iex> !Enum.empty?([])\n"
"    false\n"
"\n"
"    iex> !List.first([])\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.@(expr)
#: lib/kernel.ex:1992 
msgid ""
"Read and write attributes of the current module.\n"
"\n"
"The canonical example for attributes is annotating that a module\n"
"implements the OTP behaviour called `gen_server`:\n"
"\n"
"    defmodule MyServer do\n"
"      @behaviour :gen_server\n"
"      # ... callbacks ...\n"
"    end\n"
"\n"
"By default Elixir supports all Erlang module attributes, but any developer\n"
"can also add custom attributes:\n"
"\n"
"    defmodule MyServer do\n"
"      @my_data 13\n"
"      IO.inspect @my_data #=> 13\n"
"    end\n"
"\n"
"Unlike Erlang, such attributes are not stored in the module by\n"
"default since it is common in Elixir to use such attributes to store\n"
"temporary data. A developer can configure an attribute to behave closer\n"
"to Erlang by calling `Module.register_attribute/3`.\n"
"\n"
"Finally, notice that attributes can also be read inside functions:\n"
"\n"
"    defmodule MyServer do\n"
"      @my_data 11\n"
"      def first_data, do: @my_data\n"
"      @my_data 13\n"
"      def second_data, do: @my_data\n"
"    end\n"
"\n"
"    MyServer.first_data #=> 11\n"
"    MyServer.second_data #=> 13\n"
"\n"
"It is important to note that reading an attribute takes a snapshot of\n"
"its current value. In other words, the value is read at compilation\n"
"time and not at runtime. Check the module `Module` for other functions\n"
"to manipulate module attributes.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.raise(msg)
#: lib/kernel.ex:1234 
msgid ""
"Raises an exception.\n"
"\n"
"If the argument is a binary, it raises `RuntimeError`\n"
"using the given argument as message.\n"
"\n"
"If an atom, it will become a call to `raise(atom, [])`.\n"
"\n"
"If anything else, it will just raise the given exception.\n"
"\n"
"## Examples\n"
"\n"
"    raise \"Given values do not match\"\n"
"\n"
"    try do\n"
"      1 + :foo\n"
"    rescue\n"
"      x in [ArithmeticError] ->\n"
"        IO.puts \"that was expected\"\n"
"        raise x\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.raise(exception, attrs)
#: lib/kernel.ex:1285 
msgid ""
"Raises an exception.\n"
"\n"
"Calls `.exception` on the given argument passing\n"
"the attributes in order to retrieve the appropriate exception\n"
"structure.\n"
"\n"
"Any module defined via `defexception/1` automatically\n"
"implements `exception(attrs)` callback expected by `raise/2`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> raise(ArgumentError, message: \"Sample\")\n"
"    ** (ArgumentError) Sample\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.reraise(exception, attrs, stacktrace)
#: lib/kernel.ex:1364 
msgid ""
"Raises an exception preserving a previous stacktrace.\n"
"\n"
"Works like `raise/2` but does not generate a new stacktrace.\n"
"\n"
"See `reraise/2` for more details.\n"
"\n"
"## Examples\n"
"\n"
"    try do\n"
"      raise \"Oops\"\n"
"    rescue\n"
"      exception ->\n"
"        stacktrace = System.stacktrace\n"
"        reraise WrapperError, [exception: exception], stacktrace\n"
"    end\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.reraise(msg, stacktrace)
#: lib/kernel.ex:1315 
msgid ""
"Raises an exception preserving a previous stacktrace.\n"
"\n"
"Works like `raise/1` but does not generate a new stacktrace.\n"
"\n"
"Notice that `System.stacktrace` returns the stacktrace\n"
"of the last exception. That said, it is common to assign\n"
"the stacktrace as the first expression inside a `rescue`\n"
"clause as any other exception potentially raised (and\n"
"rescued) in between the rescue clause and the raise call\n"
"may change the `System.stacktrace` value.\n"
"\n"
"## Examples\n"
"\n"
"    try do\n"
"      raise \"Oops\"\n"
"    rescue\n"
"      exception ->\n"
"        stacktrace = System.stacktrace\n"
"        if Exception.message(exception) == \"Oops\" do\n"
"          reraise exception, stacktrace\n"
"        end\n"
"    end\n"
msgstr ""
#. TRANSLATORS: def Kernel.put_elem(tuple, index, value)
#: lib/kernel.ex:1100 
msgid ""
"Puts the element in `tuple` at the zero-based `index` to the given `value`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Example\n"
"\n"
"    iex> tuple = {:foo, :bar, 3}\n"
"    iex> put_elem(tuple, 0, :baz)\n"
"    {:baz, :bar, 3}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.put_in(data, keys, value)
#: lib/kernel.ex:1585 
msgid ""
"Puts a value in a nested structure.\n"
"\n"
"Uses the `Access` protocol to traverse the structures\n"
"according to the given `keys`, unless the `key` is a\n"
"function. If the key is a function, it will be invoked\n"
"as specified in `get_and_update_in/3`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> put_in(users, [\"john\", :age], 28)\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"In case any of entries in the middle returns `nil`,\n"
"an error will be raised when trying to access it next.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.put_in(path, value)
#: lib/kernel.ex:1696 
msgid ""
"Puts a value in a nested structure via the given `path`.\n"
"\n"
"This is similar to `put_in/3`, except the path is extracted via\n"
"a macro rather than passing a list. For example:\n"
"\n"
"    put_in(opts[:foo][:bar], :baz)\n"
"\n"
"Is equivalent to:\n"
"\n"
"    put_in(opts, [:foo, :bar], :baz)\n"
"\n"
"Note that in order for this macro to work, the complete path must always\n"
"be visible by this macro. For more information about the supported path\n"
"expressions, please check `get_and_update_in/2` docs.\n"
"\n"
"## Examples\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> put_in(users[\"john\"][:age], 28)\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> put_in(users[\"john\"].age, 28)\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.if(condition, clauses)
#: lib/kernel.ex:2151 
msgid ""
"Provides an `if` macro. This macro expects the first argument to\n"
"be a condition and the rest are keyword arguments.\n"
"\n"
"## One-liner examples\n"
"\n"
"    if(foo, do: bar)\n"
"\n"
"In the example above, `bar` will be returned if `foo` evaluates to\n"
"`true` (i.e. it is neither `false` nor `nil`). Otherwise, `nil` will be returned.\n"
"\n"
"An `else` option can be given to specify the opposite:\n"
"\n"
"    if(foo, do: bar, else: baz)\n"
"\n"
"## Blocks examples\n"
"\n"
"Elixir also allows you to pass a block to the `if` macro. The first\n"
"example above would be translated to:\n"
"\n"
"    if foo do\n"
"      bar\n"
"    end\n"
"\n"
"Notice that `do/end` becomes delimiters. The second example would\n"
"then translate to:\n"
"\n"
"    if foo do\n"
"      bar\n"
"    else\n"
"      baz\n"
"    end\n"
"\n"
"If you want to compare more than two clauses, you can use the `cond/1`\n"
"macro.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.||(left, right)
#: lib/kernel.ex:2313 
msgid ""
"Provides a short-circuit operator that evaluates and returns the second\n"
"expression only if the first one does not evaluate to true (i.e. it\n"
"is either nil or false). Returns the first expression otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.empty?([1]) || Enum.empty?([1])\n"
"    false\n"
"\n"
"    iex> List.first([]) || true\n"
"    true\n"
"\n"
"    iex> Enum.empty?([1]) || 1\n"
"    1\n"
"\n"
"    iex> Enum.empty?([]) || throw(:bad)\n"
"    true\n"
"\n"
"Notice that, unlike Erlang's `or` operator,\n"
"this operator accepts any expression as an argument,\n"
"not only booleans, however it is not allowed in guards.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.&&(left, right)
#: lib/kernel.ex:2279 
msgid ""
"Provides a short-circuit operator that evaluates and returns\n"
"the second expression only if the first one evaluates to true\n"
"(i.e. it is not nil nor false). Returns the first expression\n"
"otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.empty?([]) && Enum.empty?([])\n"
"    true\n"
"\n"
"    iex> List.first([]) && true\n"
"    nil\n"
"\n"
"    iex> Enum.empty?([]) && List.first([1])\n"
"    1\n"
"\n"
"    iex> false && throw(:bad)\n"
"    false\n"
"\n"
"Notice that, unlike Erlang's `and` operator,\n"
"this operator accepts any expression as an argument,\n"
"not only booleans, however it is not allowed in guards.\n"
msgstr ""
#. TRANSLATORS: def Kernel.div(left, right)
#: lib/kernel.ex:172 
msgid ""
"Performs an integer division.\n"
"\n"
"Raises an error if one of the arguments is not an integer.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> div(5, 2)\n"
"    2\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.=~(left, right)
#: lib/kernel.ex:1390 
msgid ""
"Matches the term on the left against the regular expression or string on the\n"
"right. Returns true if `left` matches `right` (if it's a regular expression)\n"
"or contains `right` (if it's a string).\n"
"\n"
"## Examples\n"
"\n"
"    iex> \"abcd\" =~ ~r/c(d)/\n"
"    true\n"
"\n"
"    iex> \"abcd\" =~ ~r/e/\n"
"    false\n"
"\n"
"    iex> \"abcd\" =~ \"bc\"\n"
"    true\n"
"\n"
"    iex> \"abcd\" =~ \"ad\"\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.defoverridable(tuples)
#: lib/kernel.ex:3207 
msgid ""
"Makes the given functions in the current module overridable. An overridable\n"
"function is lazily defined, allowing a developer to customize it.\n"
"\n"
"## Example\n"
"\n"
"    defmodule DefaultMod do\n"
"      defmacro __using__(_opts) do\n"
"        quote do\n"
"          def test(x, y) do\n"
"            x + y\n"
"          end\n"
"\n"
"          defoverridable [test: 2]\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    defmodule InheritMod do\n"
"      use DefaultMod\n"
"\n"
"      def test(x, y) do\n"
"        x * y + super(x, y)\n"
"      end\n"
"    end\n"
"\n"
"As seen as in the example `super` can be used to call the default\n"
"implementation.\n"
msgstr ""
#. TRANSLATORS: def Kernel.binary_part(binary, start, length)
#: lib/kernel.ex:112 
msgid ""
"Extracts the part of the binary starting at `start` with length `length`.\n"
"Binaries are zero-indexed.\n"
"\n"
"If start or length references in any way outside the binary, an\n"
"`ArgumentError` exception is raised.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> binary_part(\"foo\", 1, 2)\n"
"    \"oo\"\n"
"\n"
"A negative length can be used to extract bytes at the end of a binary:\n"
"\n"
"    iex> binary_part(\"foo\", 3, -1)\n"
"    \"o\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.apply(fun, args)
#: lib/kernel.ex:71 
msgid ""
"Invokes the given `fun` with the array of arguments `args`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> apply(fn x -> x * 2 end, [2])\n"
"    4\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.apply(module, fun, args)
#: lib/kernel.ex:87 
msgid ""
"Invokes the given `fun` from `module` with the array of arguments `args`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> apply(Enum, :reverse, [[1, 2, 3]])\n"
"    [3,2,1]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.spawn_monitor(module, fun, args)
#: lib/kernel.ex:695 
msgid ""
"Spawns the given module and function passing the given args,\n"
"monitors it and returns its pid and monitoring reference.\n"
"\n"
"Check the modules `Process` and `Node` for other functions\n"
"to handle processes, including spawning functions in nodes.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    spawn_monitor(SomeModule, :function, [1, 2, 3])\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.spawn_link(module, fun, args)
#: lib/kernel.ex:656 
msgid ""
"Spawns the given module and function passing the given args,\n"
"links it to the current process and returns its pid.\n"
"\n"
"Check the modules `Process` and `Node` for other functions\n"
"to handle processes, including spawning functions in nodes.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    spawn_link(SomeModule, :function, [1, 2, 3])\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.spawn(module, fun, args)
#: lib/kernel.ex:614 
msgid ""
"Spawns the given module and function passing the given args\n"
"and returns its pid.\n"
"\n"
"Check the modules `Process` and `Node` for other functions\n"
"to handle processes, including spawning functions in nodes.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    spawn(SomeModule, :function, [1, 2, 3])\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.spawn_monitor(fun)
#: lib/kernel.ex:676 
msgid ""
"Spawns the given function, monitors it and returns its pid\n"
"and monitoring reference.\n"
"\n"
"Check the modules `Process` and `Node` for other functions\n"
"to handle processes, including spawning functions in nodes.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    current = Kernel.self\n"
"    spawn_monitor(fn -> send current, {Kernel.self, 1 + 2} end)\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.spawn_link(fun)
#: lib/kernel.ex:637 
msgid ""
"Spawns the given function, links it to the current process and returns its pid.\n"
"\n"
"Check the modules `Process` and `Node` for other functions\n"
"to handle processes, including spawning functions in nodes.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    current = Kernel.self\n"
"    child   = spawn_link(fn -> send current, {Kernel.self, 1 + 2} end)\n"
"\n"
"    receive do\n"
"      {^child, 3} -> IO.puts \"Received 3 back\"\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.spawn(fun)
#: lib/kernel.ex:595 
msgid ""
"Spawns the given function and returns its pid.\n"
"\n"
"Check the modules `Process` and `Node` for other functions\n"
"to handle processes, including spawning functions in nodes.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    current = Kernel.self\n"
"    child   = spawn(fn -> send current, {Kernel.self, 1 + 2} end)\n"
"\n"
"    receive do\n"
"      {^child, 3} -> IO.puts \"Received 3 back\"\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.min(first, second)
#: lib/kernel.ex:485 
msgid ""
"Returns the smallest of the two given terms according to\n"
"Erlang's term ordering. If the terms compare equal, the\n"
"first one is returned.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> min(1, 2)\n"
"    1\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.tuple_size(tuple)
#: lib/kernel.ex:743 
msgid ""
"Returns the size of a tuple.\n"
"\n"
"This operation happens in constant time.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Kernel.map_size(map)
#: lib/kernel.ex:449 
msgid ""
"Returns the size of a map.\n"
"\n"
"This operation happens in constant time.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Kernel.self()
#: lib/kernel.ex:572 
msgid ""
"Returns the pid (process identifier) of the calling process.\n"
"\n"
"Allowed in guard clauses. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Kernel.trunc(number)
#: lib/kernel.ex:731 
msgid ""
"Returns an integer by truncating the given number.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> trunc(5.5)\n"
"    5\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.round(number)
#: lib/kernel.ex:542 
msgid ""
"Returns an integer by rounding the given number.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> round(5.5)\n"
"    6\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.inspect(arg, opts \\ [])
#: lib/kernel.ex:1447 
msgid ""
"Inspects the given argument according to the `Inspect` protocol.\n"
"The second argument is a keywords list with options to control\n"
"inspection.\n"
"\n"
"## Options\n"
"\n"
"`inspect/2` accepts a list of options that are internally\n"
"translated to an `Inspect.Opts` struct. Check the docs for\n"
"`Inspect.Opts` to see the supported options.\n"
"\n"
"## Examples\n"
"\n"
"    iex> inspect(:foo)\n"
"    \":foo\"\n"
"\n"
"    iex> inspect [1, 2, 3, 4, 5], limit: 3\n"
"    \"[1, 2, 3, ...]\"\n"
"\n"
"    iex> inspect(\"olá\" <> <<0>>)\n"
"    \"<<111, 108, 195, 161, 0>>\"\n"
"\n"
"    iex> inspect(\"olá\" <> <<0>>, binaries: :as_strings)\n"
"    \"\\\"olá\\\\0\\\"\"\n"
"\n"
"    iex> inspect(\"olá\", binaries: :as_binaries)\n"
"    \"<<111, 108, 195, 161>>\"\n"
"\n"
"    iex> inspect('bar')\n"
"    \"'bar'\"\n"
"\n"
"    iex> inspect([0|'bar'])\n"
"    \"[0, 98, 97, 114]\"\n"
"\n"
"    iex> inspect(100, base: :octal)\n"
"    \"0o144\"\n"
"\n"
"    iex> inspect(100, base: :hex)\n"
"    \"0x64\"\n"
"\n"
"Note that the inspect protocol does not necessarily return a valid\n"
"representation of an Elixir term. In such cases, the inspected result\n"
"must start with `#`. For example, inspecting a function will return:\n"
"\n"
"    inspect fn a, b -> a + b end\n"
"    #=> #Function<...>\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.node()
#: lib/kernel.ex:496 
msgid ""
"Returns an atom representing the name of the local node.\n"
"If the node is not alive, `:nonode@nohost` is returned instead.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Kernel.make_ref()
#: lib/kernel.ex:437 
msgid ""
"Returns an almost unique reference.\n"
"\n"
"The returned reference will re-occur after approximately 2^82 calls;\n"
"therefore it is unique enough for practical purposes.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    make_ref() #=> #Reference<0.0.0.135>\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.elem(tuple, index)
#: lib/kernel.ex:1083 
msgid ""
"Gets the element at the zero-based `index` in `tuple`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Example\n"
"\n"
"    iex> tuple = {:foo, :bar, 3}\n"
"    iex> elem(tuple, 1)\n"
"    :bar\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.get_in(data, keys)
#: lib/kernel.ex:1550 
msgid ""
"Gets a value from a nested structure.\n"
"\n"
"Uses the `Access` protocol to traverse the structures\n"
"according to the given `keys`, unless the `key` is a\n"
"function.\n"
"\n"
"If a key is a function, the function will be invoked\n"
"passing three arguments, the operation (`:get`), the\n"
"data to be accessed, and a function to be invoked next.\n"
"\n"
"This means `get_in/2` can be extended to provide\n"
"custom lookups. The downside is that functions cannot be\n"
"stored as keys in the accessed data structures.\n"
"\n"
"## Examples\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> get_in(users, [\"john\", :age])\n"
"    27\n"
"\n"
"In case any of entries in the middle returns `nil`, `nil` will be returned\n"
"as per the Access protocol:\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> get_in(users, [\"unknown\", :age])\n"
"    nil\n"
"\n"
"When one of the keys is a function, the function is invoked.\n"
"In the example below, we use a function to get all the maps\n"
"inside a list:\n"
"\n"
"    iex> users = [%{name: \"john\", age: 27}, %{name: \"meg\", age: 23}]\n"
"    iex> all = fn :get, data, next -> Enum.map(data, next) end\n"
"    iex> get_in(users, [all, :age])\n"
"    [27, 23]\n"
"\n"
"If the previous value before invoking the function is nil,\n"
"the function *will* receive nil as a value and must handle it\n"
"accordingly.\n"
msgstr ""
#. TRANSLATORS: def Kernel.get_and_update_in(data, keys, fun)
#: lib/kernel.ex:1657 
msgid ""
"Gets a value and updates a nested structure.\n"
"\n"
"It expects a tuple to be returned, containing the value\n"
"retrieved and the update one.\n"
"\n"
"Uses the `Access` protocol to traverse the structures\n"
"according to the given `keys`, unless the `key` is a\n"
"function.\n"
"\n"
"If a key is a function, the function will be invoked\n"
"passing three arguments, the operation (`:get_and_update`),\n"
"the data to be accessed, and a function to be invoked next.\n"
"\n"
"This means `get_and_update_in/3` can be extended to provide\n"
"custom lookups. The downside is that functions cannot be stored\n"
"as keys in the accessed data structures.\n"
"\n"
"## Examples\n"
"\n"
"This function is useful when there is a need to retrieve the current\n"
"value (or something calculated in function of the current value) and\n"
"update it at the same time. For example, it could be used to increase\n"
"the age of a user by one and return the previous age in one pass:\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> get_and_update_in(users, [\"john\", :age], &{&1, &1 + 1})\n"
"    {27, %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}}\n"
"\n"
"When one of the keys is a function, the function is invoked.\n"
"In the example below, we use a function to get and increment all\n"
"ages inside a list:\n"
"\n"
"    iex> users = [%{name: \"john\", age: 27}, %{name: \"meg\", age: 23}]\n"
"    iex> all = fn :get_and_update, data, next ->\n"
"    ...>   Enum.map(data, next) |> :lists.unzip\n"
"    ...> end\n"
"    iex> get_and_update_in(users, [all, :age], &{&1, &1 + 1})\n"
"    {[27, 23], [%{name: \"john\", age: 28}, %{name: \"meg\", age: 24}]}\n"
"\n"
"If the previous value before invoking the function is nil,\n"
"the function *will* receive `nil` as a value and must handle it\n"
"accordingly (be it by failing or providing a sane default).\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.get_and_update_in(path, fun)
#: lib/kernel.ex:1783 
msgid ""
"Gets a value and updates a nested data structure via the given `path`.\n"
"\n"
"This is similar to `get_and_update_in/3`, except the path is extracted\n"
"via a macro rather than passing a list. For example:\n"
"\n"
"    get_and_update_in(opts[:foo][:bar], &{&1, &1 + 1})\n"
"\n"
"Is equivalent to:\n"
"\n"
"    get_and_update_in(opts, [:foo, :bar], &{&1, &1 + 1})\n"
"\n"
"Note that in order for this macro to work, the complete path must always\n"
"be visible by this macro. See the Paths section below.\n"
"\n"
"## Examples\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> get_and_update_in(users[\"john\"].age, &{&1, &1 + 1})\n"
"    {27, %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}}\n"
"\n"
"## Paths\n"
"\n"
"A path may start with a variable, local or remote call, and must be\n"
"followed by one or more:\n"
"\n"
"  * `foo[bar]` - access a field; in case an intermediate field is not\n"
"    present or returns nil, an empty map is used\n"
"\n"
"  * `foo.bar` - access a map/struct field; in case the field is not\n"
"    present, an error is raised\n"
"\n"
"Here are some valid paths:\n"
"\n"
"    users[\"john\"][:age]\n"
"    users[\"john\"].age\n"
"    User.all[\"john\"].age\n"
"    all_users()[\"john\"].age\n"
"\n"
"Here are some invalid ones:\n"
"\n"
"    # Does a remote call after the initial value\n"
"    users[\"john\"].do_something(arg1, arg2)\n"
"\n"
"    # Does not access any field\n"
"    users\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.unless(clause, options)
#: lib/kernel.ex:2178 
msgid ""
"Evaluates and returns the do-block passed in as a second argument\n"
"unless clause evaluates to true.\n"
"Returns nil otherwise.\n"
"See also `if`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> unless(Enum.empty?([]), do: \"Hello\")\n"
"    nil\n"
"\n"
"    iex> unless(Enum.empty?([1,2,3]), do: \"Hello\")\n"
"    \"Hello\"\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.defdelegate(funs, opts)
#: lib/kernel.ex:3302 
msgid ""
"Defines the given functions in the current module that will\n"
"delegate to the given `target`. Functions defined with\n"
"`defdelegate` are public and are allowed to be invoked\n"
"from external. If you find yourself wishing to define a\n"
"delegation as private, you should likely use import\n"
"instead.\n"
"\n"
"Delegation only works with functions, delegating to macros\n"
"is not supported.\n"
"\n"
"## Options\n"
"\n"
"  * `:to` - the expression to delegate to. Any expression\n"
"    is allowed and its results will be calculated on runtime.\n"
"\n"
"  * `:as` - the function to call on the target given in `:to`.\n"
"    This parameter is optional and defaults to the name being\n"
"    delegated.\n"
"\n"
"  * `:append_first` - if true, when delegated, first argument\n"
"    passed to the delegate will be relocated to the end of the\n"
"    arguments when dispatched to the target.\n"
"\n"
"    The motivation behind this is because Elixir normalizes\n"
"    the \"handle\" as a first argument and some Erlang modules\n"
"    expect it as last argument.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule MyList do\n"
"      defdelegate reverse(list), to: :lists\n"
"      defdelegate [reverse(list), map(callback, list)], to: :lists\n"
"      defdelegate other_reverse(list), to: :lists, as: :reverse\n"
"    end\n"
"\n"
"    MyList.reverse([1, 2, 3])\n"
"    #=> [3,2,1]\n"
"\n"
"    MyList.other_reverse([1, 2, 3])\n"
"    #=> [3,2,1]\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.sigil_w(arg1, modifiers)
#: lib/kernel.ex:3473 
msgid ""
"Handles the sigil ~w. It returns a list of \"words\" split by whitespace.\n"
"\n"
"## Modifiers\n"
"\n"
"  * `s`: strings (default)\n"
"  * `a`: atoms\n"
"  * `c`: char lists\n"
"\n"
"## Examples\n"
"\n"
"    iex> ~w(foo #{:bar} baz)\n"
"    [\"foo\", \"bar\", \"baz\"]\n"
"\n"
"    iex> ~w(--source test/enum_test.exs)\n"
"    [\"--source\", \"test/enum_test.exs\"]\n"
"\n"
"    iex> ~w(foo bar baz)a\n"
"    [:foo, :bar, :baz]\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.sigil_s(arg1, list2)
#: lib/kernel.ex:3367 
msgid ""
"Handles the sigil ~s. It returns a string as if it was double quoted\n"
"string, unescaping characters and replacing interpolations.\n"
"\n"
"## Examples\n"
"\n"
"    iex> ~s(foo)\n"
"    \"foo\"\n"
"\n"
"    iex> ~s(f#{:o}o)\n"
"    \"foo\"\n"
"\n"
"    iex> ~s(f\\#{:o}o)\n"
"    \"f\\#{:o}o\"\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.sigil_r(arg1, options)
#: lib/kernel.ex:3425 
msgid ""
"Handles the sigil ~r. It returns a Regex pattern.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.match?(~r(foo), \"foo\")\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.sigil_c(arg1, list2)
#: lib/kernel.ex:3407 
msgid ""
"Handles the sigil ~c. It returns a char list as if it were a single\n"
"quoted string, unescaping characters and replacing interpolations.\n"
"\n"
"## Examples\n"
"\n"
"    iex> ~c(foo)\n"
"    'foo'\n"
"\n"
"    iex> ~c(f#{:o}o)\n"
"    'foo'\n"
"\n"
"    iex> ~c(f\\#{:o}o)\n"
"    'f\\#{:o}o'\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.sigil_W(arg1, modifiers)
#: lib/kernel.ex:3498 
msgid ""
"Handles the sigil ~W. It returns a list of \"words\" split by whitespace\n"
"without escaping nor interpreting interpolations.\n"
"\n"
"## Modifiers\n"
"\n"
"  * `s`: strings (default)\n"
"  * `a`: atoms\n"
"  * `c`: char lists\n"
"\n"
"## Examples\n"
"\n"
"    iex> ~W(foo #{bar} baz)\n"
"    [\"foo\", \"\\#{bar}\", \"baz\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.sigil_S(string, list2)
#: lib/kernel.ex:3347 
msgid ""
"Handles the sigil ~S. It simply returns a string\n"
"without escaping characters and without interpolations.\n"
"\n"
"## Examples\n"
"\n"
"    iex> ~S(foo)\n"
"    \"foo\"\n"
"\n"
"    iex> ~S(f#{o}o)\n"
"    \"f\\#{o}o\"\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.sigil_R(arg1, options)
#: lib/kernel.ex:3446 
msgid ""
"Handles the sigil ~R. It returns a Regex pattern without escaping\n"
"nor interpreting interpolations.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.match?(~R(f#{1,3}o), \"f#o\")\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.sigil_C(arg1, list2)
#: lib/kernel.ex:3384 
msgid ""
"Handles the sigil ~C. It simply returns a char list\n"
"without escaping characters and without interpolations.\n"
"\n"
"## Examples\n"
"\n"
"    iex> ~C(foo)\n"
"    'foo'\n"
"\n"
"    iex> ~C(f#{o}o)\n"
"    'f\\#{o}o'\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.defimpl(name, opts, do_block \\ [])
#: lib/kernel.ex:3172 
msgid ""
"Defines an implementation for the given protocol. See\n"
"`defprotocol/2` for examples.\n"
"\n"
"Inside an implementation, the name of the protocol can be accessed\n"
"via `@protocol` and the current target as `@for`.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.defexception(fields)
#: lib/kernel.ex:2985 
msgid ""
"Defines an exception.\n"
"\n"
"Exceptions are structs backed by a module that implements\n"
"the Exception behaviour. The Exception behaviour requires\n"
"two functions to be implemented:\n"
"\n"
"  * `exception/1` - that receives the arguments given to `raise/2`\n"
"     and returns the exception struct. The default implementation\n"
"     accepts a set of keyword arguments that is merged into the\n"
"     struct.\n"
"\n"
"  * `message/1` - receives the exception struct and must return its\n"
"    message. Most commonly exceptions have a message field which\n"
"    by default is accessed by this function. However, if your exception\n"
"    does not have a message field, this function must be explicitly\n"
"    implemented.\n"
"\n"
"Since exceptions are structs, all the API supported by `defstruct/1`\n"
"is also available in `defexception/1`.\n"
"\n"
"## Raising exceptions\n"
"\n"
"The most common way to raise an exception is via the `raise/2`\n"
"function:\n"
"\n"
"    defmodule MyAppError do\n"
"      defexception [:message]\n"
"    end\n"
"\n"
"    value = [:hello]\n"
"\n"
"    raise MyAppError,\n"
"      message: \"did not get what was expected, got: #{inspect value}\"\n"
"\n"
"In many cases it is more convenient to pass the expected value to\n"
"`raise` and generate the message in the `exception/1` callback:\n"
"\n"
"    defmodule MyAppError do\n"
"      defexception [:message]\n"
"\n"
"      def exception(value) do\n"
"        msg = \"did not get what was expected, got: #{inspect value}\"\n"
"        %MyAppError{message: msg}\n"
"      end\n"
"    end\n"
"\n"
"    raise MyAppError, value\n"
"\n"
"The example above is the preferred mechanism for customizing\n"
"exception messages.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.defstruct(fields)
#: lib/kernel.ex:2899 
msgid ""
"Defines a struct for the current module.\n"
"\n"
"A struct is a tagged map that allows developers to provide\n"
"default values for keys, tags to be used in polymorphic\n"
"dispatches and compile time assertions.\n"
"\n"
"To define a struct, a developer needs to only define\n"
"a function named `__struct__/0` that returns a map with the\n"
"structs field. This macro is a convenience for defining such\n"
"function, with the addition of a type `t` and deriving\n"
"conveniences.\n"
"\n"
"For more information about structs, please check\n"
"`Kernel.SpecialForms.%/2`.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule User do\n"
"      defstruct name: nil, age: nil\n"
"    end\n"
"\n"
"Struct fields are evaluated at definition time, which allows\n"
"them to be dynamic. In the example below, `10 + 11` will be\n"
"evaluated at compilation time and the age field will be stored\n"
"with value `21`:\n"
"\n"
"    defmodule User do\n"
"      defstruct name: nil, age: 10 + 11\n"
"    end\n"
"\n"
"## Deriving\n"
"\n"
"Although structs are maps, by default structs do not implement\n"
"any of the protocols implemented for maps. For example, if you\n"
"attempt to use the access protocol with the User struct, it\n"
"will lead to an error:\n"
"\n"
"    %User{}[:age]\n"
"    ** (Protocol.UndefinedError) protocol Access not implemented for %User{...}\n"
"\n"
"However, `defstruct/1` allows implementation for protocols to\n"
"derived by defining a `@derive` attribute as a list before `defstruct/1`\n"
"is invoked:\n"
"\n"
"    defmodule User do\n"
"      @derive [Access]\n"
"      defstruct name: nil, age: 10 + 11\n"
"    end\n"
"\n"
"    %User{}[:age] #=> 21\n"
"\n"
"For each protocol given to `@derive`, Elixir will assert there is an\n"
"implementation of that protocol for maps and check if the map\n"
"implementation defines a `__deriving__/3` callback. If so, the callback\n"
"is invoked, otherwise an implementation that simply points to the map\n"
"one is automatically derived.\n"
"\n"
"## Types\n"
"\n"
"It is recommended to define types for structs, by convention this type\n"
"is called `t`. To define a struct in a type the struct literal syntax\n"
"is used:\n"
"\n"
"    defmodule User do\n"
"      defstruct name: \"john\", age: 25\n"
"      @type t :: %User{name: String.t, age: integer}\n"
"    end\n"
"\n"
"It is recommended to only use the struct syntax when defining the struct's\n"
"type. When referring to another struct use `User.t`, not `%User{}`. Fields\n"
"in the struct not included in the type defaults to `term`.\n"
"\n"
"Private structs that are not used outside its module should use the private\n"
"type attribute `@typep`. Public structs whose internal structure is private\n"
"to the local module (you are not allowed to pattern match it or directly\n"
"access fields) should use the `@opaque` attribute. Structs whose internal\n"
"structure is public should use `@type`.\n"
msgstr ""
#. TRANSLATORS: def Kernel.struct(struct, kv \\ [])
#: lib/kernel.ex:1489 
msgid ""
"Creates and updates structs.\n"
"\n"
"The struct argument may be an atom (which defines `defstruct`)\n"
"or a struct itself. The second argument is any Enumerable that\n"
"emits two-item tuples (key-value) during enumeration.\n"
"\n"
"If one of the keys in the Enumerable does not exist in the struct,\n"
"they are automatically discarded.\n"
"\n"
"This function is useful for dynamically creating and updating\n"
"structs.\n"
"\n"
"## Example\n"
"\n"
"    defmodule User do\n"
"      defstruct name: \"john\"\n"
"    end\n"
"\n"
"    struct(User)\n"
"    #=> %User{name: \"john\"}\n"
"\n"
"    opts = [name: \"meg\"]\n"
"    user = struct(User, opts)\n"
"    #=> %User{name: \"meg\"}\n"
"\n"
"    struct(user, unknown: \"value\")\n"
"    #=> %User{name: \"meg\"}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.++(left, right)
#: lib/kernel.ex:864 
msgid ""
"Concatenates two lists.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> [1] ++ [2, 3]\n"
"    [1,2,3]\n"
"\n"
"    iex> 'foo' ++ 'bar'\n"
"    'foobar'\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.<>(left, right)
#: lib/kernel.ex:1188 
msgid ""
"Concatenates two binaries.\n"
"\n"
"## Examples\n"
"\n"
"    iex> \"foo\" <> \"bar\"\n"
"    \"foobar\"\n"
"\n"
"The `<>` operator can also be used in guard clauses as\n"
"long as the first part is a literal binary:\n"
"\n"
"    iex> \"foo\" <> x = \"foobar\"\n"
"    iex> x\n"
"    \"bar\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.rem(left, right)
#: lib/kernel.ex:526 
msgid ""
"Calculates the remainder of an integer division.\n"
"\n"
"Raises an error if one of the arguments is not an integer.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> rem(5, 2)\n"
"    1\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.in(left, right)
#: lib/kernel.ex:2441 
msgid ""
"Checks if the element on the left side is member of the\n"
"collection on the right side.\n"
"\n"
"## Examples\n"
"\n"
"    iex> x = 1\n"
"    iex> x in [1, 2, 3]\n"
"    true\n"
"\n"
"This macro simply translates the expression above to:\n"
"\n"
"    Enum.member?([1,2,3], x)\n"
"\n"
"## Guards\n"
"\n"
"The `in` operator can be used on guard clauses as long as the\n"
"right side is a range or a list. Elixir will then expand the\n"
"operator to a valid guard expression. For example:\n"
"\n"
"    when x in [1,2,3]\n"
"\n"
"Translates to:\n"
"\n"
"    when x === 1 or x === 2 or x === 3\n"
"\n"
"When using ranges:\n"
"\n"
"    when x in 1..3\n"
"\n"
"Translates to:\n"
"\n"
"    when x >= 1 and x <= 3\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.or(left, right)
#: lib/kernel.ex:1118 
msgid ""
"Boolean or. Requires only the first argument to be a\n"
"boolean since it short-circuits.\n"
"\n"
"Allowed in guard tests.\n"
"\n"
"## Examples\n"
"\n"
"    iex> true or false\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.not(arg)
#: lib/kernel.ex:900 
msgid ""
"Boolean not. Argument must be a boolean.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> not false\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.and(left, right)
#: lib/kernel.ex:1134 
msgid ""
"Boolean and. Requires only the first argument to be a\n"
"boolean since it short-circuits.\n"
"\n"
"Allowed in guard tests.\n"
"\n"
"## Examples\n"
"\n"
"    iex> true and false\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel...(first, last)
#: lib/kernel.ex:2251 
msgid ""
"Returns a range with the specified start and end.\n"
"Includes both ends.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 0 in 1..3\n"
"    false\n"
"\n"
"    iex> 1 in 1..3\n"
"    true\n"
"\n"
"    iex> 2 in 1..3\n"
"    true\n"
"\n"
"    iex> 3 in 1..3\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.+(value)
#: lib/kernel.ex:791 
msgid ""
"Arithmetic unary plus.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> +1\n"
"    1\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.-(value)
#: lib/kernel.ex:807 
msgid ""
"Arithmetic unary minus.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> -2\n"
"    -2\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.+(left, right)
#: lib/kernel.ex:759 
msgid ""
"Arithmetic plus.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 + 2\n"
"    3\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.*(left, right)
#: lib/kernel.ex:823 
msgid ""
"Arithmetic multiplication.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 * 2\n"
"    2\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.-(left, right)
#: lib/kernel.ex:775 
msgid ""
"Arithmetic minus.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 - 2\n"
"    -1\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel./(left, right)
#: lib/kernel.ex:845 
msgid ""
"Arithmetic division.\n"
"\n"
"The result is always a float. Use `div` and `rem` if you want\n"
"a natural division or the remainder.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 / 2\n"
"    0.5\n"
"\n"
"    iex> 2 / 1\n"
"    2.0\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.byte_size(binary)
#: lib/kernel.ex:154 
msgid ""
"Returns the number of bytes needed to contain `bitstring`.\n"
"\n"
"That is, if the number of bits in `bitstring` is not divisible by 8,\n"
"the resulting number of bytes will be rounded up. This operation\n"
"happens in constant time.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> byte_size(<<433::16, 3::3>>)\n"
"    3\n"
"\n"
"    iex> byte_size(<<1, 2, 3>>)\n"
"    3\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.send(dest, msg)
#: lib/kernel.ex:562 
msgid ""
"Sends a message to the given `dest` and returns the message.\n"
"\n"
"`dest` may be a remote or local pid, a (local) port, a locally\n"
"registered name, or a tuple `{registered_name, node}` for a registered\n"
"name at another node.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> send self(), :hello\n"
"    :hello\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.length(list)
#: lib/kernel.ex:419 
msgid ""
"Returns the length of `list`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> length([1, 2, 3, 4, 5, 6, 7, 8, 9])\n"
"    9\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.hd(list)
#: lib/kernel.ex:248 
msgid ""
"Returns the head of a list, raises `badarg` if the list is empty.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.binding(context \\ nil)
#: lib/kernel.ex:2100 
msgid ""
"Returns the binding for the given context as a keyword list.\n"
"\n"
"The variable name is the key and the variable value is the value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> x = 1\n"
"    iex> binding()\n"
"    [x: 1]\n"
"    iex> x = 2\n"
"    iex> binding()\n"
"    [x: 2]\n"
"\n"
"    iex> binding(:foo)\n"
"    []\n"
"    iex> var!(x, :foo) = 1\n"
"    1\n"
"    iex> binding(:foo)\n"
"    [x: 1]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.max(first, second)
#: lib/kernel.ex:467 
msgid ""
"Returns the biggest of the two given terms according to\n"
"Erlang's term ordering. If the terms compare equal, the\n"
"first one is returned.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> max(1, 2)\n"
"    2\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.node(arg)
#: lib/kernel.ex:508 
msgid ""
"Returns the node where the given argument is located.\n"
"The argument can be a pid, a reference, or a port.\n"
"If the local node is not alive, `nonode@nohost` is returned.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.destructure(left, right)
#: lib/kernel.ex:2217 
msgid ""
"Allows you to destructure two lists, assigning each term in the right to the\n"
"matching term in the left. Unlike pattern matching via `=`, if the sizes of\n"
"the left and right lists don't match, destructuring simply stops instead of\n"
"raising an error.\n"
"\n"
"## Examples\n"
"\n"
"    iex> destructure([x, y, z], [1, 2, 3, 4, 5])\n"
"    iex> {x, y, z}\n"
"    {1, 2, 3}\n"
"\n"
"Notice in the example above, even though the right\n"
"size has more entries than the left, destructuring works\n"
"fine. If the right size is smaller, the remaining items\n"
"are simply assigned to nil:\n"
"\n"
"    iex> destructure([x, y, z], [1])\n"
"    iex> {x, y, z}\n"
"    {1, nil, nil}\n"
"\n"
"The left side supports any expression you would use\n"
"on the left side of a match:\n"
"\n"
"    x = 1\n"
"    destructure([^x, y, z], [1, 2, 3])\n"
"\n"
"The example above will only work if x matches\n"
"the first value from the right side. Otherwise,\n"
"it will raise a CaseClauseError.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.to_string(arg)
#: lib/kernel.ex:1861 
msgid ""
"Converts the argument to a string according to the\n"
"`String.Chars` protocol.\n"
"\n"
"This is the function invoked when there is string interpolation.\n"
"\n"
"## Examples\n"
"\n"
"    iex> to_string(:foo)\n"
"    \"foo\"\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.to_char_list(arg)
#: lib/kernel.ex:1876 
msgid ""
"Converts the argument to a list according to the List.Chars protocol.\n"
"\n"
"## Examples\n"
"\n"
"    iex> to_char_list(:foo)\n"
"    'foo'\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.tl(list)
#: lib/kernel.ex:715 
msgid ""
"Returns the tail of a list. Raises `ArgumentError` if the list is empty.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Kernel.throw(term)
#: lib/kernel.ex:705 
msgid ""
"A non-local return from a function. Check `Kernel.SpecialForms.try/1` for more information.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.match?(pattern, expr)
#: lib/kernel.ex:1933 
msgid ""
"A convenience macro that checks if the right side (an expression)\n"
"matches the left side (a pattern).\n"
"\n"
"## Examples\n"
"\n"
"    iex> match?(1, 1)\n"
"    true\n"
"\n"
"    iex> match?(1, 2)\n"
"    false\n"
"\n"
"    iex> match?({1, _}, {1, 2})\n"
"    true\n"
"\n"
"Match can also be used to filter or find a value in an enumerable:\n"
"\n"
"    list = [{:a, 1}, {:b, 2}, {:a, 3}]\n"
"    Enum.filter list, &match?({:a, _}, &1)\n"
"\n"
"Guard clauses can also be given to the match:\n"
"\n"
"    list = [{:a, 1}, {:b, 2}, {:a, 3}]\n"
"    Enum.filter list, &match?({:a, x} when x < 2, &1)\n"
"\n"
"However, variables assigned in the match will not be available\n"
"outside of the function call:\n"
"\n"
"    iex> match?(x, 1)\n"
"    true\n"
"\n"
"    iex> binding([:x]) == []\n"
"    true\n"
"\n"
msgstr ""
