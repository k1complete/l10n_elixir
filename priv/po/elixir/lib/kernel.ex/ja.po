msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2015-05-20 21:54+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: defmacro Kernel.|>(left, right)
#: lib/kernel.ex:2372
msgid ""
"`|>` is the pipe operator.\n"
"\n"
"This operator introduces the expression on the left as\n"
"the first argument to the function call on the right.\n"
"\n"
"## Examples\n"
"\n"
"    iex> [1, [2], 3] |> List.flatten()\n"
"    [1, 2, 3]\n"
"\n"
"The example above is the same as calling `List.flatten([1, [2], 3])`,\n"
"i.e. the argument on the left side of `|>` is introduced as the first\n"
"argument of the function call on the right side.\n"
"\n"
"This pattern is mostly useful when there is a desire to execute\n"
"a bunch of operations, resembling a pipeline:\n"
"\n"
"    iex> [1, [2], 3] |> List.flatten |> Enum.map(fn x -> x * 2 end)\n"
"    [2, 4, 6]\n"
"\n"
"The example above will pass the list to `List.flatten/1`, then get\n"
"the flattened list and pass to `Enum.map/2`, which will multiply\n"
"each entry in the list per two.\n"
"\n"
"In other words, the expression above simply translates to:\n"
"\n"
"    Enum.map(List.flatten([1, [2], 3]), fn x -> x * 2 end)\n"
"\n"
"Beware of operator precedence when using the pipe operator.\n"
"For example, the following expression:\n"
"\n"
"    String.graphemes \"Hello\" |> Enum.reverse\n"
"\n"
"Translates to:\n"
"\n"
"    String.graphemes(\"Hello\" |> Enum.reverse)\n"
"\n"
"Which will result in an error as Enumerable protocol is not defined\n"
"for binaries. Adding explicit parenthesis resolves the ambiguity:\n"
"\n"
"    String.graphemes(\"Hello\") |> Enum.reverse\n"
"\n"
"Or, even better:\n"
"\n"
"    \"Hello\" |> String.graphemes |> Enum.reverse\n"
"\n"
msgstr ""
"`|>` はパイプオペレータです。\n"
"\n"
"この演算子は右の関数呼び出しの最初の引数として左の式を送ります。\n"
"\n"
"## 例\n"
"\n"
"    iex> [1, [2], 3] |> List.flatten()\n"
"    [1, 2, 3]\n"
"\n"
"上の例は`List.flatten([1, [2], 3])`を呼び出すのと同じです。\n"
"すなわち、`|>`の左側の引数は右側の呼びだし関数の最初の引数として\n"
"送られます。\n"
"\n"
"沢山のオペレーションを実行したいとき、このパターンは非常に使い易いです。\n"
"そしてパイプラインに似ています:\n"
"\n"
"    iex> [1, [2], 3] |> List.flatten |> Enum.map(fn x -> x * 2 end)\n"
"    [2, 4, 6]\n"
"\n"
"上の例は`List.flatten/1`にリストを送り、それから平坦化されたリストを\n"
"得て、リストのそれぞれのエントリを2倍するために`Enum.map/2`へ送ります。\n"
"\n"
"言い替えると、上の式は単に以下のように翻訳できます:\n"
"\n"
"    Enum.map(List.flatten([1, [2], 3]), fn x -> x * 2 end)\n"
"\n"
"パイプオペレータを使用するとき、演算子の優先順位に注意してください。\n"
"例えば、以下の式は:\n"
"\n"
"    String.graphemes \"Hello\" |> Enum.reverse\n"
"\n"
"このように翻訳されます:\n"
"\n"
"    String.graphemes(\"Hello\" |> Enum.reverse)\n"
"\n"
"バイナリに対するEnumerableプロトコルが定義されていないのでエラーに終りま"
"す。\n"
"明示的に括弧を加えることで曖昧さを解決します:\n"
"\n"
"    String.graphemes(\"Hello\") |> Enum.reverse\n"
"\n"
"または、もっとよい方法で:\n"
"\n"
"    \"Hello\" |> String.graphemes |> Enum.reverse\n"
"\n"

#. TRANSLATORS: defmacro Kernel.use(module, opts \\ [])
#: lib/kernel.ex:3245
msgid ""
"`use` is a simple mechanism for using a given module into\n"
"the current context.\n"
"\n"
"## Examples\n"
"\n"
"For example, in order to write tests using the ExUnit framework,\n"
"a developer should use the `ExUnit.Case` module:\n"
"\n"
"    defmodule AssertionTest do\n"
"      use ExUnit.Case, async: true\n"
"\n"
"      test \"always pass\" do\n"
"        assert true\n"
"      end\n"
"    end\n"
"\n"
"By calling `use`, a hook called `__using__` will be invoked in\n"
"`ExUnit.Case` which will then do the proper setup.\n"
"\n"
"Simply put, `use` is simply a translation to:\n"
"\n"
"    defmodule AssertionTest do\n"
"      require ExUnit.Case\n"
"      ExUnit.Case.__using__([async: true])\n"
"\n"
"      test \"always pass\" do\n"
"        assert true\n"
"      end\n"
"    end\n"
"\n"
msgstr ""
"`use`はカレントコンテキストに与えられたモジュールを使うための\n"
"シンプルなメカニズムです。\n"
"\n"
"## 例\n"
"\n"
"例えば、ExUnitフレームワークを使ってテストを書くために、\n"
"開発者は`ExUnit.Case`モジュールをuseしなければなりません。\n"
"\n"
"    defmodule AssertionTest do\n"
"      use ExUnit.Case, async: true\n"
"\n"
"      test \"always pass\" do\n"
"        assert true\n"
"      end\n"
"    end\n"
"\n"
"`use`を呼ぶことにより、`ExUnit.Case`のセットアップをするために\n"
"`__using__`と呼ばれるフックが起動されます。\n"
"\n"
"単に、`use`は以下のように翻訳されます:\n"
"\n"
"    defmodule AssertionTest do\n"
"      require ExUnit.Case\n"
"      ExUnit.Case.__using__([async: true])\n"
"\n"
"      test \"always pass\" do\n"
"        assert true\n"
"      end\n"
"    end\n"
"\n"

#. TRANSLATORS: Elixir.Kernel Summary
#: lib/kernel.ex:8
msgid ""
"`Kernel` provides the default macros and functions\n"
"Elixir imports into your environment. These macros and functions\n"
"can be skipped or cherry-picked via the `import` macro. For\n"
"instance, if you want to tell Elixir not to import the `if`\n"
"macro, you can do:\n"
"\n"
"    import Kernel, except: [if: 2]\n"
"\n"
"Elixir also has special forms that are always imported and\n"
"cannot be skipped. These are described in `Kernel.SpecialForms`.\n"
"\n"
"Some of the functions described in this module are inlined by\n"
"the Elixir compiler into their Erlang counterparts in the `:erlang`\n"
"module. Those functions are called BIFs (builtin internal functions)\n"
"in Erlang-land and they exhibit interesting properties, as some of\n"
"them are allowed in guards and others are used for compiler\n"
"optimizations.\n"
"\n"
"Most of the inlined functions can be seen in effect when capturing\n"
"the function:\n"
"\n"
"    iex> &Kernel.is_atom/1\n"
"    &:erlang.is_atom/1\n"
"\n"
"Those functions will be explicitly marked in their docs as\n"
"\"inlined by the compiler\".\n"
msgstr ""
"Elixirが環境にインポートするデフォルトのマクロと関数を`Kernel`は提供し\n"
"ます。これらのマクロと関数は`import`マクロによってチェリーピッキングや\n"
"スキップすることが出来ます。例えば、もし`if`マクロをインポートしないよ\n"
"うにElixirへ言いたいならば、以下のようにできます:\n"
"\n"
"    import Kernel, except: [if: 2]\n"
"\n"
"Elixirは常にインポートされ、スキップできないスペシャルフォームももって\n"
"います。それらは`Kernel.SpecialForms`に記述されています。\n"
"\n"
"このモジュールで記述される関数のいくつかは、Elixirコンパイラによって\n"
"`:erlang`モジュールでErlangに対応するものにインライン化されます。それら\n"
"の関数はErlang-landでBIFs(builtin internal functions)と呼ばれ、それらの\n"
"幾つかはガードに使うことができたり、コンパイラの最適化に使われたり面白\n"
"い特性を示します。\n"
"\n"
"ほとんどのインライン関数はその関数をキャプチャすると実質的に見られます:\n"
"\n"
"    iex> &Kernel.is_atom/1\n"
"    &:erlang.is_atom/1\n"
"\n"
"それらの関数は\"コンパイラによりインライン化される\"ようにドキュメントで\n"
"明示的にマークされます。\n"

#. TRANSLATORS: defmacro Kernel.var!(var, context \\ nil)
#: lib/kernel.ex:2514
msgid ""
"When used inside quoting, marks that the variable should\n"
"not be hygienized. The argument can be either a variable\n"
"unquoted or in standard tuple form `{name, meta, context}`.\n"
"\n"
"Check `Kernel.SpecialForms.quote/2` for more information.\n"
msgstr ""
"quoteの内側で使われた時、その変数が衛生的(hygienized)であってはならない\n"
"とマークします。引数はunquoteされた変数か、標準タプルフォームの`{name,\n"
"meta, context}`です。\n"
"\n"
"更なる情報は、`Kernel.SpecialForms.quote/2`をチェックしてください。\n"

#. TRANSLATORS: defmacro Kernel.alias!(alias)
#: lib/kernel.ex:2544
msgid ""
"When used inside quoting, marks that the alias should not\n"
"be hygienized. This means the alias will be expanded when\n"
"the macro is expanded.\n"
"\n"
"Check `Kernel.SpecialForms.quote/2` for more information.\n"
msgstr ""
"quoteの内側で使われた時、その別名が健全(hygienezed)であっては\n"
"ならないとマークします。これは別名はマクロが展開された時に展開\n"
"されるだろうことを意味します。\n"
"\n"
"更なる情報は、`Kernel.SpecialForms.quote/2`をチェックしてくだ\n"
"さい。\n"

#. TRANSLATORS: defmacro Kernel.update_in(path, fun)
#: lib/kernel.ex:1729
msgid ""
"Updates a nested structure via the given `path`.\n"
"\n"
"This is similar to `update_in/3`, except the path is extracted via\n"
"a macro rather than passing a list. For example:\n"
"\n"
"    update_in(opts[:foo][:bar], &(&1 + 1))\n"
"\n"
"Is equivalent to:\n"
"\n"
"    update_in(opts, [:foo, :bar], &(&1 + 1))\n"
"\n"
"Note that in order for this macro to work, the complete path must always\n"
"be visible by this macro. For more information about the supported path\n"
"expressions, please check `get_and_update_in/2` docs.\n"
"\n"
"## Examples\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> update_in(users[\"john\"][:age], &(&1 + 1))\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> update_in(users[\"john\"].age, &(&1 + 1))\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
msgstr ""
"ネストした構造を与えられた`path`によって更新します。\n"
"\n"
"pathがリストを渡しているのではなく、マクロによって抽出\n"
"されていることを除けば、これは`update_in/3`と似ています。\n"
"例えば:\n"
"\n"
"    update_in(opts[:foo][:bar], &(&1 + 1))\n"
"\n"
"以下と等しいです:\n"
"\n"
"    update_in(opts, [:foo, :bar], &(&1 + 1))\n"
"\n"
"このマクロが機能するために、完全なパスが常にこのマクロによって見えていなけれ"
"ば\n"
"ならないことに注意してください。\n"
"サポートされたパス式についての更なる情報については、`get_and_update_in/2`の\n"
"ドキュメントをチェックしてください。\n"
"\n"
"## 例\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> update_in(users[\"john\"][:age], &(&1 + 1))\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> update_in(users[\"john\"].age, &(&1 + 1))\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"

#. TRANSLATORS: def Kernel.update_in(data, keys, fun)
#: lib/kernel.ex:1607
msgid ""
"Updates a key in a nested structure.\n"
"\n"
"Uses the `Access` protocol to traverse the structures\n"
"according to the given `keys`, unless the `key` is a\n"
"function. If the key is a function, it will be invoked\n"
"as specified in `get_and_update_in/3`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> update_in(users, [\"john\", :age], &(&1 + 1))\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"In case any of entries in the middle returns `nil`,\n"
"an error will be raised when trying to access it next.\n"
msgstr ""
"ネストした構造を与えられた`path`によって更新します。\n"
"\n"
"pathがリストを渡しているのではなく、マクロによって抽出\n"
"されていることを除けば、これは`update_in/3`と似ています。\n"
"例えば:\n"
"\n"
"    update_in(opts[:foo][:bar], &(&1 + 1))\n"
"\n"
"以下と等しいです:\n"
"\n"
"    update_in(opts, [:foo, :bar], &(&1 + 1))\n"
"\n"
"このマクロが機能するために、完全なパスが常にこのマクロによって見えていなけれ"
"ば\n"
"ならないことに注意してください。\n"
"サポートされたパス式についての更なる情報については、`get_and_update_in/2`の\n"
"ドキュメントをチェックしてください。\n"
"\n"
"ネストした構造のキーを更新します。\n"
"\n"
"`key`が関数でないかぎり、与えられた`key`によって構造を\n"
"トラバースするために`Access`プロトコルを使います。\n"
"もしキーが関数なら、`get_and_update_in/3`で規定により\n"
"実行されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> update_in(users, [\"john\", :age], &(&1 + 1))\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"途中のエントリの何れかが`nil`を返す場合、次に\n"
"それにアクセスしようとするときに、エラーを上げます。\n"

#. TRANSLATORS: def Kernel.exit(reason)
#: lib/kernel.ex:238
msgid ""
"Stops the execution of the calling process with the given reason.\n"
"\n"
"Since evaluating this function causes the process to terminate,\n"
"it has no return value.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"When a process reaches its end, by default it exits with\n"
"reason `:normal`. You can also call it explicitly if you\n"
"want to terminate a process but not signal any failure:\n"
"\n"
"    exit(:normal)\n"
"\n"
"In case something goes wrong, you can also use `exit/1` with\n"
"a different reason:\n"
"\n"
"    exit(:seems_bad)\n"
"\n"
"If the reason is not `:normal`, all linked process to the\n"
"exited process will crash (unless they are trapping exits).\n"
"\n"
"## OTP exits\n"
"\n"
"Exits are used by OTP to determine if a process exited abnormally\n"
"or not. The following exits are considered \"normal\":\n"
"\n"
"  * `exit(:normal)`\n"
"  * `exit(:shutdown)`\n"
"  * `exit({:shutdown, term})`\n"
"\n"
"Exiting with any other reason is considered abnormal and treated\n"
"as a crash. This means the default supervisor behaviour kicks in,\n"
"error reports are emitted, etc.\n"
"\n"
"This behaviour is relied on in many different places. For example,\n"
"`ExUnit` uses `exit(:shutdown)` when exiting the test process to\n"
"signal linked processes, supervision trees and so on to politely\n"
"shutdown too.\n"
"\n"
"## CLI exits\n"
"\n"
"Building on top of the exit signals mentioned above, if the\n"
"process started by the command line exits with any of the three\n"
"reasons above, its exit is considered normal and the Operating\n"
"System process will exit with status 0.\n"
"\n"
"It is, however, possible to customize the Operating System exit\n"
"signal by invoking:\n"
"\n"
"    exit({:shutdown, integer})\n"
"\n"
"This will cause the OS process to exit with the status given by\n"
"`integer` while signaling all linked OTP processes to politely\n"
"shutdown.\n"
"\n"
"Any other exit reason will cause the OS process to exit with\n"
"status `1` and linked OTP processes to crash.\n"
msgstr ""
"与えられたreasonで呼び出したプロセスの実行を停止します。\n"
"\n"
"この関数を評価するとき、プロセスは終了する結果となるので、\n"
"値を返しません。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"プロセスが終わりに達するとき、デフォルトでreasonが`:normal`で\n"
"exitが呼ばれます。もし失敗のシグナルを出さずにプロセスを\n"
"終了したいなら、明示的に呼ぶことも出来ます:\n"
"\n"
"    exit(:normal)\n"
"\n"
"何か悪い事が起ったケースでは、異ったreasonで`exit/1`を呼ぶこともできま\n"
"す:\n"
"\n"
"    exit(:seems_bad)\n"
"\n"
"`:normal`以外のreasonなら、exitしたプロセスにリンクされた\n"
"全てのプロセスはクラッシュします(exitをトラップしていない限り)。\n"
"\n"
"## OTPのexit\n"
"\n"
"exitは、OTPによって、プロセスが異常終了したか否かの決定に使われます。\n"
"以下のexitは\"normal\"として扱われます:\n"
"\n"
"  * `exit(:normal)`\n"
"  * `exit(:shutdown)`\n"
"  * `exit({:shutdown, term})`\n"
"\n"
"他のどんなreasonでも異常終了と思われ、クラッシュしたと見做されます。こ\n"
"れはエラーレポートを発行するなどの、デフォルトのスーパーバイザの振舞い\n"
"が効き始めることを意味します。\n"
"\n"
"この振舞いは多くの異る場所で依存されています。例えば、`ExUnit`はテスト\n"
"プロセスが終了する時、リンクされたプロセス、つまり、監督ツリーとその他\n"
"も礼儀正しくシャットダウンさせるときに、`exit(:shutdown)`を使います。\n"
"\n"
"## CLIの exit\n"
"\n"
"上記の終了シグナルの上に作り、もし\n"
"コマンドラインにより開始したプロセスが\n"
"上の3つの何れかのreasonで終了したら、その終了は、正常と\n"
"考え、オペレーティングシステムプロセスはステータス0で終了します。\n"
"\n"
"しかしながら、以下の様に実行することで、オペレーティングシステムのexit\n"
"シグナルをカスタマイズすることも可能です：\n"
"\n"
"    exit({:shutdown, integer})\n"
"\n"
"これは全てのリンクされたOTPプロセスを礼儀正しく終了したうえで、\n"
"OSプロセスを`integer`により与えられたステータスで終了します。\n"
"\n"
"他のexit reasonは全て、リンクされたOTPプロセスをクラッシュさせ、\n"
"OSプロセスをステータス1で終了します。\n"

#. TRANSLATORS: def Kernel.macro_exported?(module, macro, arity)
#: lib/kernel.ex:2399
msgid ""
"Returns true if the `module` is loaded and contains a\n"
"public `macro` with the given `arity`, otherwise false.\n"
"\n"
"Notice that this function does not load the module in case\n"
"it is not loaded. Check `Code.ensure_loaded/1` for more\n"
"information.\n"
msgstr ""
"`module`がロードされていて、与えられた`arity`の公開`macro`が\n"
"含まれていると真を返し、さもなくば偽を返します。\n"
"\n"
"この関数はモジュールがロードされていないときに、ロードを\n"
"しないことに注意してください。さらなる情報は`Code.ensure_loaded/1`\n"
"をチェックしてください。\n"

#. TRANSLATORS: def Kernel.function_exported?(module, function, arity)
#: lib/kernel.ex:2386
msgid ""
"Returns true if the `module` is loaded and contains a\n"
"public `function` with the given `arity`, otherwise false.\n"
"\n"
"Notice that this function does not load the module in case\n"
"it is not loaded. Check `Code.ensure_loaded/1` for more\n"
"information.\n"
msgstr ""
"`module`がロードされていて、与えられた`arity`の公開`function`が\n"
"含まれていると真を返し、さもなくば偽を返します。\n"
"\n"
"この関数はモジュールがロードされていないときに、ロードを\n"
"しないことに注意してください。さらなる情報は`Code.ensure_loaded/1`\n"
"をチェックしてください。\n"

#. TRANSLATORS: def Kernel.bit_size(bitstring)
#: lib/kernel.ex:131
msgid ""
"Returns an integer which is the size in bits of `bitstring`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> bit_size(<<433::16, 3::3>>)\n"
"    19\n"
"\n"
"    iex> bit_size(<<1, 2, 3>>)\n"
"    24\n"
"\n"
msgstr ""
"`bitstring`のビット列の大きさを整数で返します。\n"
"\n"
"ガード中のテストで使うことができます。コンパイラによりインライン化され\n"
"ます。\n"
"\n"
"## 例\n"
"\n"
"    iex> bit_size(<<433::16, 3::3>>)\n"
"    19\n"
"\n"
"    iex> bit_size(<<1, 2, 3>>)\n"
"    24\n"
"\n"

#. TRANSLATORS: def Kernel.abs(number)
#: lib/kernel.ex:55
msgid ""
"Returns an integer or float which is the arithmetical absolute value of "
"`number`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> abs(-3.33)\n"
"    3.33\n"
"\n"
"    iex> abs(-3)\n"
"    3\n"
"\n"
msgstr ""
"`number`の算術的絶対値を整数または小数で返します。\n"
"\n"
"ガード中のテストで使うことができます。コンパイラによりインライン化され\n"
"ます。\n"
"\n"
"## 例\n"
"\n"
"    iex> abs(-3.33)\n"
"    3.33\n"
"\n"
"    iex> abs(-3)\n"
"    3\n"
"\n"

#. TRANSLATORS: defmacro Kernel.defprotocol(name, list2)
#: lib/kernel.ex:3161
msgid ""
"Defines a protocol.\n"
"\n"
"A protocol specifies an API that should be defined by its\n"
"implementations.\n"
"\n"
"## Examples\n"
"\n"
"In Elixir, only `false` and `nil` are considered falsy values.\n"
"Everything else evaluates to true in `if` clauses. Depending\n"
"on the application, it may be important to specify a `blank?`\n"
"protocol that returns a boolean for other data types that should\n"
"be considered `blank?`. For instance, an empty list or an empty\n"
"binary could be considered blanks.\n"
"\n"
"We could implement this protocol as follow:\n"
"\n"
"    defprotocol Blank do\n"
"      @doc \"Returns true if data is considered blank/empty\"\n"
"      def blank?(data)\n"
"    end\n"
"\n"
"Now that the protocol is defined, we can implement it. We need\n"
"to implement the protocol for each Elixir type. For example:\n"
"\n"
"    # Integers are never blank\n"
"    defimpl Blank, for: Integer do\n"
"      def blank?(number), do: false\n"
"    end\n"
"\n"
"    # Just empty list is blank\n"
"    defimpl Blank, for: List do\n"
"      def blank?([]), do: true\n"
"      def blank?(_),  do: false\n"
"    end\n"
"\n"
"    # Just the atoms false and nil are blank\n"
"    defimpl Blank, for: Atom do\n"
"      def blank?(false), do: true\n"
"      def blank?(nil),   do: true\n"
"      def blank?(_),     do: false\n"
"    end\n"
"\n"
"And we would have to define the implementation for all types.\n"
"The supported types available are:\n"
"\n"
"  * Structs (see below)\n"
"  * `Tuple`\n"
"  * `Atom`\n"
"  * `List`\n"
"  * `BitString`\n"
"  * `Integer`\n"
"  * `Float`\n"
"  * `Function`\n"
"  * `PID`\n"
"  * `Map`\n"
"  * `Port`\n"
"  * `Reference`\n"
"  * `Any` (see below)\n"
"\n"
"## Protocols + Structs\n"
"\n"
"The real benefit of protocols comes when mixed with structs.\n"
"For instance, Elixir ships with many data types implemented as\n"
"structs, like `HashDict` and `HashSet`. We can implement the\n"
"`Blank` protocol for those types as well:\n"
"\n"
"    defimpl Blank, for: [HashDict, HashSet] do\n"
"      def blank?(enum_like), do: Enum.empty?(enum_like)\n"
"    end\n"
"\n"
"If a protocol is not found for a given type, it will fallback to\n"
"`Any`.\n"
"\n"
"## Fallback to any\n"
"\n"
"In some cases, it may be convenient to provide a default\n"
"implementation for all types. This can be achieved by\n"
"setting `@fallback_to_any` to `true` in the protocol\n"
"definition:\n"
"\n"
"    defprotocol Blank do\n"
"      @fallback_to_any true\n"
"      def blank?(data)\n"
"    end\n"
"\n"
"Which can now be implemented as:\n"
"\n"
"    defimpl Blank, for: Any do\n"
"      def blank?(_), do: true\n"
"    end\n"
"\n"
"One may wonder why such fallback is not true by default.\n"
"\n"
"It is two-fold: first, the majority of protocols cannot\n"
"implement an action in a generic way for all types. In fact,\n"
"providing a default implementation may be harmful, because users\n"
"may rely on the default implementation instead of providing a\n"
"specialized one.\n"
"\n"
"Second, falling back to `Any` adds an extra lookup to all types,\n"
"which is unnecessary overhead unless an implementation for Any is\n"
"required.\n"
"\n"
"## Types\n"
"\n"
"Defining a protocol automatically defines a type named `t`, which\n"
"can be used as:\n"
"\n"
"    @spec present?(Blank.t) :: boolean\n"
"    def present?(blank) do\n"
"      not Blank.blank?(blank)\n"
"    end\n"
"\n"
"The `@spec` above expresses that all types allowed to implement the\n"
"given protocol are valid argument types for the given function.\n"
"\n"
"## Reflection\n"
"\n"
"Any protocol module contains three extra functions:\n"
"\n"
"\n"
"  * `__protocol__/1` - returns the protocol name when `:name` is given, and "
"a\n"
"    keyword list with the protocol functions when `:functions` is given\n"
"\n"
"  * `impl_for/1` - receives a structure and returns the module that\n"
"    implements the protocol for the structure, `nil` otherwise\n"
"\n"
"  * `impl_for!/1` - same as above but raises an error if an implementation "
"is\n"
"    not found\n"
"\n"
"## Consolidation\n"
"\n"
"In order to cope with code loading in development, protocols in\n"
"Elixir provide a slow implementation of protocol dispatching specific\n"
"to development.\n"
"\n"
"In order to speed up dispatching in production environments, where\n"
"all implementations are known up-front, Elixir provides a feature\n"
"called protocol consolidation. For this reason, all protocols are\n"
"compiled with `debug_info` set to true, regardless of the option\n"
"set by `elixirc` compiler. The debug info though may be removed\n"
"after consolidation.\n"
"\n"
"For more information on how to apply protocol consolidation to\n"
"a given project, please check the functions in the `Protocol`\n"
"module or the `mix compile.protocols` task.\n"
msgstr ""
"プロトコルを定義します。\n"
"\n"
"プロトコルは、その実装により定義されるべきAPIを、\n"
"指定します。\n"
"\n"
"## 例\n"
"\n"
"Elixirでは、`false`と`nil`だけが偽の値として考慮されます。`if`節の中で\n"
"は、その他全ては真に評価します。アプリケーションによっては、`空白類?`と\n"
"思わなければならない他のデータタイプの為にブーリアンを返す、`blank?`プ\n"
"ロトコルを指定することが重要かもしれません。\n"
"例えば、空のリストや空のバイナリは空白類と考えることができます。\n"
"\n"
"以下のようにこのプロトコルを実装できます:\n"
"\n"
"    defprotocol Blank do\n"
"      @doc \"Returns true if data is considered blank/empty\"\n"
"      def blank?(data)\n"
"    end\n"
"\n"
"プロトコルが定義された今、それを実装することができます。\n"
"それぞれのElixirタイプについてプロトコルを実装する必要があります。\n"
"例えば:\n"
"\n"
"    # Integers are never blank\n"
"    defimpl Blank, for: Integer do\n"
"      def blank?(number), do: false\n"
"    end\n"
"\n"
"    # Just empty list is blank\n"
"    defimpl Blank, for: List do\n"
"      def blank?([]), do: true\n"
"      def blank?(_),  do: false\n"
"    end\n"
"\n"
"    # Just the atoms false and nil are blank\n"
"    defimpl Blank, for: Atom do\n"
"      def blank?(false), do: true\n"
"      def blank?(nil),   do: true\n"
"      def blank?(_),     do: false\n"
"    end\n"
"\n"
"そして、全てのタイプに実装を定義しなければなりません。\n"
"サポートされている有効なタイプは以下のとおりです:\n"
"\n"
"  * Structs (see below)\n"
"  * `Tuple`\n"
"  * `Atom`\n"
"  * `List`\n"
"  * `BitString`\n"
"  * `Integer`\n"
"  * `Float`\n"
"  * `Function`\n"
"  * `PID`\n"
"  * `Map`\n"
"  * `Port`\n"
"  * `Reference`\n"
"  * `Any` (see below)\n"
"\n"
"## Protocols + Structs\n"
"\n"
"プロトコルの本当の利点は構造体との組み合わせた時です。\n"
"例えば、Elixirは`HashDict`や`HashSet`のような構造体として\n"
"多くのデータタイプを提供しています。\n"
"それらのタイプのために`Blank`プロトコルを実装することが\n"
"できます:\n"
"\n"
"    defimpl Blank, for: [HashDict, HashSet] do\n"
"      def blank?(enum_like), do: Enum.empty?(enum_like)\n"
"    end\n"
"\n"
"もしプロトコルが与えられたタイプに見付からないなら、`Any`に\n"
"フォールバックします。\n"
"\n"
"## Fallback to any\n"
"\n"
"いくつかの場合、全てのタイプの為のデフォルト実装を提供することが\n"
"便利かもしれません。これはプロトコル定義で、\n"
"`@fallback_to_any`を`true`にセットすることで達成できます:\n"
"\n"
"    defprotocol Blank do\n"
"      @fallback_to_any true\n"
"      def blank?(data)\n"
"    end\n"
"\n"
"今や、このように実装できます:\n"
"\n"
"    defimpl Blank, for: Any do\n"
"      def blank?(_), do: true\n"
"    end\n"
"\n"
"なぜ、デフォルトでそのようなフォールバックがtrueでないのか、\n"
"疑問に思うかもしれません。\n"
"\n"
"二つの理由があります: 第一に、大多数のプロトコルが\n"
"全てのタイプのために一般的な方法でアクションを実装することが\n"
"出来ません。実際、ユーザは専門のものを提供する代りに、デフォルト\n"
"実装に頼るかもしれないので、デフォルト実装を提供することは、有害であるかも\n"
"しれません。\n"
"\n"
"第二に、`Any`へのフォールバックは全てのデータタイプに余分の検索を追加し\n"
"ます。Anyの実装を必要とされない限り、それは不必要なオーバーヘッドです。\n"
"\n"
"## Types\n"
"\n"
"プロトコルを定義すると、自動的に`t`と呼ばれるタイプを定義します。\n"
"それは以下のように使うことができます:\n"
"\n"
"    @spec present?(Blank.t) :: boolean\n"
"    def present?(blank) do\n"
"      not Blank.blank?(blank)\n"
"    end\n"
"\n"
"上の`@spec`は、与えられたプロトコルを実装することを許された全てのタイプ\n"
"が、与えられた関数の有効な引数のタイプであることを、表します。\n"
"\n"
"## Reflection\n"
"\n"
"任意のプトロコルモジュールは3つの特別な関数を含みます:\n"
"\n"
"  * `__protocol__/1` - `:name`が与えられたらプロトコル名を返します。\n"
"    `:functions`が与えられたらプロトコルの関数のキーワードリストを返します\n"
"\n"
"  * `impl_for/1` - 構造体を受け取り、その構造体のプロトコルを実装した\n"
"    モジュールを返します。さもなければ`nil`を返します\n"
"\n"
"  * `impl_for!/1` - 上と同じですが、実装が見付からないときにエラーを上げま"
"す\n"
"\n"
"## Consolidation\n"
"\n"
"開発においてコードローディングに対処するために、Elixirのプロトコルは\n"
"開発に特有の遲いプロトコルディスパッチ実装を提供します。\n"
"\n"
"プロダクション環境でディスパッチをスピードアップするために、\n"
"全ての実装は事前に知られているところで、Elixirはプロトコル強化と\n"
"呼ばれている機能を提供します。\n"
"このため、全てのプロトコルは、`elixirc`コンパイラに\n"
"よるオプションの設定に関わりなく、`debug_info`がtrueでコンパイルされます。\n"
"debug infoは強化の後で取り除かれます。\n"
"\n"
"どのようにプロトコル強化をプロジェクトに適用するかについての詳細は、\n"
"`Protocol`モジュールの関数か、`mix compile.protocols`タスクをチェックし\n"
"てください。\n"

#. TRANSLATORS: defmacro Kernel.defmodule(alias, list2)
#: lib/kernel.ex:2604
msgid ""
"Defines a module given by name with the given contents.\n"
"\n"
"It returns the module name, the module binary and the\n"
"block contents result.\n"
"\n"
"## Examples\n"
"\n"
"    iex> defmodule Foo do\n"
"    ...>   def bar, do: :baz\n"
"    ...> end\n"
"    iex> Foo.bar\n"
"    :baz\n"
"\n"
"## Nesting\n"
"\n"
"Nesting a module inside another module affects its name:\n"
"\n"
"    defmodule Foo do\n"
"      defmodule Bar do\n"
"      end\n"
"    end\n"
"\n"
"In the example above, two modules `Foo` and `Foo.Bar` are created.\n"
"When nesting, Elixir automatically creates an alias, allowing the\n"
"second module `Foo.Bar` to be accessed as `Bar` in the same lexical\n"
"scope.\n"
"\n"
"This means that, if the module `Bar` is moved to another file,\n"
"the references to `Bar` needs to be updated or an alias needs to\n"
"be explicitly set with the help of `Kernel.SpecialForms.alias/2`.\n"
"\n"
"## Dynamic names\n"
"\n"
"Elixir module names can be dynamically generated. This is very\n"
"useful for macros. For instance, one could write:\n"
"\n"
"    defmodule String.to_atom(\"Foo#{1}\") do\n"
"      # contents ...\n"
"    end\n"
"\n"
"Elixir will accept any module name as long as the expression\n"
"returns an atom. Note that, when a dynamic name is used, Elixir\n"
"won't nest the name under the current module nor automatically\n"
"set up an alias.\n"
msgstr ""
"与えられた名前とコンテンツのモジュールを定義します。\n"
"\n"
"モジュール名、モジュールバイナリとブロックコンテンツの\n"
"結果を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> defmodule Foo do\n"
"    ...>   def bar, do: :baz\n"
"    ...> end\n"
"    iex> Foo.bar\n"
"    :baz\n"
"\n"
"## ネスト\n"
"\n"
"もう一つのモジュールの中にモジュールをネストすることは、その名前に\n"
"影響を及ぼします:\n"
"\n"
"    defmodule Foo do\n"
"      defmodule Bar do\n"
"      end\n"
"    end\n"
"\n"
"上の例で、二つのモジュール`Foo`と`Foo.Bar`が作られます。\n"
"ネストするとき、Elixirは自動的にエイリアスを作ります。\n"
"そして、二つめのモジュール`Foo.Bar`が同じレキシカルスコープの\n"
"中で`Bar`としてアクセスされることを許します。\n"
"\n"
"これは、モジュール`Bar`が他のファイルに移動されるなら、`Bar`への参照は\n"
"更新される必要があること、または、`Kernel.SpecialForms.alias/2`の助けを\n"
"かりて、エイリアスを明示的にセットアップする必要があることを、意味しま\n"
"す。\n"
"\n"
"## 動的な名前\n"
"\n"
"Elixirモジュール名は、動的に生成することができます。これは\n"
"マクロにとって、非常に便利です。例えば、このように畫けます:\n"
"\n"
"    defmodule String.to_atom(\"Foo#{1}\") do\n"
"      # contents ...\n"
"    end\n"
"\n"
"Elixirはアトムを返す限り、任意のモジュール名を受け入れます。なお、動的\n"
"な名前が使われるとき、Elixirは現在のモジュールの下で、名前のネストもし\n"
"ないし、自動的なエイリアスのセットアップもしません。\n"

#. TRANSLATORS: defmacro Kernel.defmacro(call, expr \\ nil)
#: lib/kernel.ex:2788
msgid ""
"Defines a macro with the given name and contents.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule MyLogic do\n"
"      defmacro unless(expr, opts) do\n"
"        quote do\n"
"          if !unquote(expr), unquote(opts)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    require MyLogic\n"
"    MyLogic.unless false do\n"
"      IO.puts \"It works\"\n"
"    end\n"
"\n"
msgstr ""
"与えられた名前とコンテンツでマクロを定義します。\n"
"\n"
"## 例\n"
"\n"
"    defmodule MyLogic do\n"
"      defmacro unless(expr, opts) do\n"
"        quote do\n"
"          if !unquote(expr), unquote(opts)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    require MyLogic\n"
"    MyLogic.unless false do\n"
"      IO.puts \"It works\"\n"
"    end\n"
"\n"

#. TRANSLATORS: defmacro Kernel.defmacrop(call, expr \\ nil)
#: lib/kernel.ex:2798
msgid ""
"Defines a macro that is private. Private macros are\n"
"only accessible from the same module in which they are defined.\n"
"\n"
"Check `defmacro/2` for more information\n"
msgstr ""
"プライベートマクロを定義します。プライベートマクロは\n"
"それが定義された同じモジュールからのみアクセス可能です。\n"
"\n"
"詳細は `defmacro/2` をチェックしてください。\n"

#. TRANSLATORS: defmacro Kernel.def(call, expr \\ nil)
#: lib/kernel.ex:2742
msgid ""
"Defines a function with the given name and contents.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Foo do\n"
"      def bar, do: :baz\n"
"    end\n"
"\n"
"    Foo.bar #=> :baz\n"
"\n"
"A function that expects arguments can be defined as follow:\n"
"\n"
"    defmodule Foo do\n"
"      def sum(a, b) do\n"
"        a + b\n"
"      end\n"
"    end\n"
"\n"
"In the example above, we defined a function `sum` that receives\n"
"two arguments and sums them.\n"
"\n"
msgstr ""
"与えられた名前とコンテンツで関数を定義します。\n"
"\n"
"## 例\n"
"\n"
"    defmodule Foo do\n"
"      def bar, do: :baz\n"
"    end\n"
"\n"
"    Foo.bar #=> :baz\n"
"\n"
"関数は下のように、引数を付けて定義することもできます:\n"
"\n"
"    defmodule Foo do\n"
"      def sum(a, b) do\n"
"        a + b\n"
"      end\n"
"    end\n"
"\n"
"上の例では、二つの引数をとり、それらの和を返す関数`sum`を定義しました。\n"
"\n"

#. TRANSLATORS: defmacro Kernel.defp(call, expr \\ nil)
#: lib/kernel.ex:2765
msgid ""
"Defines a function that is private. Private functions are\n"
"only accessible from within the module in which they are defined.\n"
"\n"
"Check `def/2` for more information\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Foo do\n"
"      def bar do\n"
"        sum(1, 2)\n"
"      end\n"
"\n"
"      defp sum(a, b), do: a + b\n"
"    end\n"
"\n"
"In the example above, `sum` is private and accessing it\n"
"through `Foo.sum` will raise an error.\n"
msgstr ""
"プライベート関数を定義します。プライベート関数は\n"
"それが定義された同じモジュールからのみアクセス可能です。\n"
"\n"
"詳細は `def/2` をチェックしてください。\n"
"\n"
"## 例\n"
"\n"
"    defmodule Foo do\n"
"      def bar do\n"
"        sum(1, 2)\n"
"      end\n"
"\n"
"      defp sum(a, b), do: a + b\n"
"    end\n"
"\n"
"上の例では、`sum`はプライベートで、`Foo.sum`を通して\n"
"アクセスすると、エラーが上がります。\n"

#. TRANSLATORS: def Kernel.!==(left, right)
#: lib/kernel.ex:1066
msgid ""
"Returns `true` if the two items do not match.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 !== 2\n"
"    true\n"
"\n"
"    iex> 1 !== 1.0\n"
"    true\n"
"\n"
msgstr ""
"もし、二つのアイテムが一致しないなら、`true`を返します。\n"
"\n"
"Elixirの全てのアイテムはそれぞれ他と比較加能です。\n"
"\n"
"ガードの中のテストに使えます。\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> 1 !== 2\n"
"    true\n"
"\n"
"    iex> 1 !== 1.0\n"
"    true\n"
"\n"

#. TRANSLATORS: def Kernel.!=(left, right)
#: lib/kernel.ex:1020
msgid ""
"Returns `true` if the two items are not equal.\n"
"\n"
"This operator considers 1 and 1.0 to be equal. For match\n"
"comparison, use `!==` instead.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 != 2\n"
"    true\n"
"\n"
"    iex> 1 != 1.0\n"
"    false\n"
"\n"
msgstr ""
"もし、二つのアイテムが等しくないなら、`true`を返します。\n"
"\n"
"この演算子は1と1.0を等しいと考えます。一致するかどうかの\n"
"比較の為には、`!==`をかわりに使ってください。\n"
"\n"
"Elixirの全てのアイテムはそれぞれ他と比較加能です。\n"
"\n"
"ガードの中のテストに使えます。\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> 1 != 2\n"
"    true\n"
"\n"
"    iex> 1 != 1.0\n"
"    false\n"
"\n"

#. TRANSLATORS: def Kernel.===(left, right)
#: lib/kernel.ex:1045
msgid ""
"Returns `true` if the two items are match.\n"
"\n"
"This operator gives the same semantics as the one existing in\n"
"pattern matching, i.e., `1` and `1.0` are equal, but they do\n"
"not match.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 === 2\n"
"    false\n"
"\n"
"    iex> 1 === 1.0\n"
"    false\n"
"\n"
msgstr ""
"もし、二つのアイテムが一致するなら、`true`を返します。\n"
"\n"
"この演算子はパターンマッチの中に存在しているものと\n"
"同じセマンティクスを与えます。すなわち、`1`と`1.0`は等しいですが、\n"
"それらは一致しません。\n"
"\n"
"Elixirの全てのアイテムはそれぞれ他と比較加能です。\n"
"\n"
"ガードの中のテストに使えます。\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> 1 === 2\n"
"    false\n"
"\n"
"    iex> 1 === 1.0\n"
"    false\n"
"\n"

#. TRANSLATORS: def Kernel.==(left, right)
#: lib/kernel.ex:996
msgid ""
"Returns `true` if the two items are equal.\n"
"\n"
"This operator considers 1 and 1.0 to be equal. For match\n"
"semantics, use `===` instead.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 == 2\n"
"    false\n"
"\n"
"    iex> 1 == 1.0\n"
"    true\n"
"\n"
msgstr ""
"もし、二つのアイテムが等しいなら、`true`を返します。\n"
"\n"
"この演算子は1と1.0を等しいと考えます。一致するかどうかの\n"
"比較の為には、`===`をかわりに使ってください。\n"
"\n"
"Elixirの全てのアイテムはそれぞれ他と比較加能です。\n"
"\n"
"ガードの中のテストに使えます。\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> 1 == 2\n"
"    false\n"
"\n"
"    iex> 1 == 1.0\n"
"    true\n"
"\n"

#. TRANSLATORS: def Kernel.>(left, right)
#: lib/kernel.ex:936
msgid ""
"Returns `true` if left is more than right.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 > 2\n"
"    false\n"
"\n"
msgstr ""
"もし、leftがrightより大きければ、`true`を返します。\n"
"\n"
"Elixirの全てのアイテムはそれぞれ他と比較加能です。\n"
"\n"
"ガードの中のテストに使えます。\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> 1 > 2\n"
"    false\n"
"\n"

#. TRANSLATORS: def Kernel.>=(left, right)
#: lib/kernel.ex:972
msgid ""
"Returns `true` if left is more than or equal to right.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 >= 2\n"
"    false\n"
"\n"
msgstr ""
"もし、leftがrightと等しいか、より大きければ、`true`を返します。\n"
"\n"
"Elixirの全てのアイテムはそれぞれ他と比較加能です。\n"
"\n"
"ガードの中のテストに使えます。\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> 1 >= 2\n"
"    false\n"
"\n"

#. TRANSLATORS: def Kernel.<(left, right)
#: lib/kernel.ex:918
msgid ""
"Returns `true` if left is less than right.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 < 2\n"
"    true\n"
"\n"
msgstr ""
"もし、leftがrightより小ければ、`true`を返します。\n"
"\n"
"Elixirの全てのアイテムはそれぞれ他と比較加能です。\n"
"\n"
"ガードの中のテストに使えます。\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> 1 < 2\n"
"    true\n"
"\n"

#. TRANSLATORS: def Kernel.<=(left, right)
#: lib/kernel.ex:954
msgid ""
"Returns `true` if left is less than or equal to right.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 <= 2\n"
"    true\n"
"\n"
msgstr ""
"もし、leftがrightと等しいか、より小ければ、`true`を返します。\n"
"\n"
"Elixirの全てのアイテムはそれぞれ他と比較加能です。\n"
"\n"
"ガードの中のテストに使えます。\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> 1 <= 2\n"
"    true\n"
"\n"

#. TRANSLATORS: def Kernel.--(left, right)
#: lib/kernel.ex:884
msgid ""
"Removes the first occurrence of an item on the left\n"
"for each item on the right.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> [1, 2, 3] -- [1, 2]\n"
"    [3]\n"
"\n"
"    iex> [1, 2, 3, 2, 1] -- [1, 2, 2]\n"
"    [3,1]\n"
"\n"
msgstr ""
"右のそれぞれのアイテムについて左にあるアイテムを取り除きます。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> [1, 2, 3] -- [1, 2]\n"
"    [3]\n"
"\n"
"    iex> [1, 2, 3, 2, 1] -- [1, 2, 2]\n"
"    [3,1]\n"
"\n"

#. TRANSLATORS: defmacro Kernel.is_nil(term)
#: lib/kernel.ex:1894
msgid ""
"Returns `true` if `term` is nil; otherwise returns `false`.\n"
"\n"
"Allowed in guard clauses.\n"
"\n"
"## Examples\n"
"\n"
"    iex> is_nil(1)\n"
"    false\n"
"\n"
"    iex> is_nil(nil)\n"
"    true\n"
"\n"
msgstr ""
"`term`がnilなら`true`を、さもなければ`false`を返します。\n"
"\n"
"ガード節で使えます。\n"
"\n"
"## 例\n"
"\n"
"    iex> is_nil(1)\n"
"    false\n"
"\n"
"    iex> is_nil(nil)\n"
"    true\n"
"\n"

#. TRANSLATORS: def Kernel.is_boolean(term)
#: lib/kernel.ex:291
msgid ""
"Returns `true` if `term` is either the atom `true` or the atom `false` (i.e. "
"a boolean);\n"
"otherwise returns false.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"もし`term`がアトム`true`またはアトム`false`のいずれか(すなわちboolean)\n"
"ならば`true`を返します。さもなければflseを返します。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.is_number(term)
#: lib/kernel.ex:353
msgid ""
"Returns `true` if `term` is either an integer or a floating point number;\n"
"otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`が整数か浮動小数点数のいずれかなら`true`を返します。さもなければ\n"
"`false`を返します。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.is_integer(term)
#: lib/kernel.ex:332
msgid ""
"Returns `true` if `term` is an integer; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`が整数なら`true`を返します。さもなければ`false`を返します。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.is_atom(term)
#: lib/kernel.ex:258
msgid ""
"Returns `true` if `term` is an atom; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`がアトムなら`true`を返します。さもなければ`false`を返します。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.is_tuple(term)
#: lib/kernel.ex:393
msgid ""
"Returns `true` if `term` is a tuple; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`がタプルなら`true`を返します。さもなければ`false`を返します。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.is_reference(term)
#: lib/kernel.ex:383
msgid ""
"Returns `true` if `term` is a reference; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`がリファレンスなら`true`を返します。さもなければ`false`を返します。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.is_port(term)
#: lib/kernel.ex:373
msgid ""
"Returns `true` if `term` is a port identifier; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`がポート識別子なら`true`を返します。さもなければ`false`を返します。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.is_pid(term)
#: lib/kernel.ex:363
msgid ""
"Returns `true` if `term` is a pid (process identifier); otherwise returns "
"`false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`がpid(プロセス識別子)なら`true`を返します。さもなければ`false`を\n"
"返します。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.is_map(term)
#: lib/kernel.ex:403
msgid ""
"Returns `true` if `term` is a map; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`がマップなら`true`を返します。さもなければ`false`を返します。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.is_list(term)
#: lib/kernel.ex:342
msgid ""
"Returns `true` if `term` is a list with zero or more elements; otherwise "
"returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`が0個以上の要素をもつリストなら`true`を返します。さもなければ\n"
"`false`を返します。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.is_function(term)
#: lib/kernel.ex:311
msgid ""
"Returns `true` if `term` is a function; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`が関数なら`true`を返します。さもなければ`false`を返します。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.is_function(term, arity)
#: lib/kernel.ex:322
msgid ""
"Returns `true` if `term` is a function that can be applied with `arity` "
"number of arguments;\n"
"otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`が引数の数が`arity`個で適用可能な関数なら`true`を返します。さもな\n"
"ければ`false`を返します。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.is_float(term)
#: lib/kernel.ex:301
msgid ""
"Returns `true` if `term` is a floating point number; otherwise returns "
"`false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`が浮動小数点数なら`true`を返します。さもなければ`false`を返します。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.is_bitstring(term)
#: lib/kernel.ex:280
msgid ""
"Returns `true` if `term` is a bitstring (including a binary); otherwise "
"returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`がビット列(バイナリを含ふくみます)なら`true`を返します。さもなけ\n"
"れば`false`を返します。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.is_binary(term)
#: lib/kernel.ex:270
msgid ""
"Returns `true` if `term` is a binary; otherwise returns `false`.\n"
"\n"
"A binary always contains a complete number of bytes.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`がバイナリなら`true`を返します。さもなければ`false`を返します。\n"
"\n"
"バイナリは常に完全なバイトの数を含みます。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: defmacro Kernel.!(arg)
#: lib/kernel.ex:1152
msgid ""
"Receives any argument and returns `true` if it is `false`\n"
"or `nil`. Returns `false` otherwise. Not allowed in guard\n"
"clauses.\n"
"\n"
"## Examples\n"
"\n"
"    iex> !Enum.empty?([])\n"
"    false\n"
"\n"
"    iex> !List.first([])\n"
"    true\n"
"\n"
msgstr ""
"任意の引数を受け取って、`false`あるいは`nil`以外なら\n"
"`true`を返します。さもなくば`false`を返します。\n"
"ガード節での使用は許されません。\n"
"\n"
"## 例\n"
"\n"
"    iex> !Enum.empty?([])\n"
"    false\n"
"\n"
"    iex> !List.first([])\n"
"    true\n"
"\n"

#. TRANSLATORS: defmacro Kernel.@(expr)
#: lib/kernel.ex:1992
msgid ""
"Read and write attributes of the current module.\n"
"\n"
"The canonical example for attributes is annotating that a module\n"
"implements the OTP behaviour called `gen_server`:\n"
"\n"
"    defmodule MyServer do\n"
"      @behaviour :gen_server\n"
"      # ... callbacks ...\n"
"    end\n"
"\n"
"By default Elixir supports all Erlang module attributes, but any developer\n"
"can also add custom attributes:\n"
"\n"
"    defmodule MyServer do\n"
"      @my_data 13\n"
"      IO.inspect @my_data #=> 13\n"
"    end\n"
"\n"
"Unlike Erlang, such attributes are not stored in the module by\n"
"default since it is common in Elixir to use such attributes to store\n"
"temporary data. A developer can configure an attribute to behave closer\n"
"to Erlang by calling `Module.register_attribute/3`.\n"
"\n"
"Finally, notice that attributes can also be read inside functions:\n"
"\n"
"    defmodule MyServer do\n"
"      @my_data 11\n"
"      def first_data, do: @my_data\n"
"      @my_data 13\n"
"      def second_data, do: @my_data\n"
"    end\n"
"\n"
"    MyServer.first_data #=> 11\n"
"    MyServer.second_data #=> 13\n"
"\n"
"It is important to note that reading an attribute takes a snapshot of\n"
"its current value. In other words, the value is read at compilation\n"
"time and not at runtime. Check the module `Module` for other functions\n"
"to manipulate module attributes.\n"
msgstr ""
"現在のモジュールのアトリビュートを読み書きします。\n"
"\n"
"アトリビュートの規範的な例は、モジュールが`gen_server`と呼ばれている\n"
"OTPビヘイビアを実装するという注釈を付けていることです:\n"
"\n"
"    defmodule MyServer do\n"
"      @behaviour :gen_server\n"
"      # ... callbacks ...\n"
"    end\n"
"\n"
"デフォルトでElixirは全てのErlangモジュールアトリビュートをサポートし、\n"
"開発者は、任意のカスタムアトリビュートを追加することもできます:\n"
"\n"
"    defmodule MyServer do\n"
"      @my_data 13\n"
"      IO.inspect @my_data #=> 13\n"
"    end\n"
"\n"
"Erlangとは異なり、一時的なデータを格納するためにそのようなアトリビュー\n"
"トを使うことはElixirでは一般的になった時から、デフォルトではそのような\n"
"アトリビュートはモジュールにには保存されません。開発者は\n"
"`Module.register_attribute/3`を呼ぶことによって、Erlangにより近く振る舞\n"
"うように、アトリビュートを構成することができます。\n"
"\n"
"最後にアトリビュートは関数の内側で読むこともできることに注意してください:\n"
"\n"
"    defmodule MyServer do\n"
"      @my_data 11\n"
"      def first_data, do: @my_data\n"
"      @my_data 13\n"
"      def second_data, do: @my_data\n"
"    end\n"
"\n"
"    MyServer.first_data #=> 11\n"
"    MyServer.second_data #=> 13\n"
"\n"
"アトリビュートを読むことは、現在の値のスナップショットを取ることである\n"
"点に注意することは、重要です。言い替えると、値はコンパイル時に読み、実\n"
"行時ではありません。モジュールアトリビュートを操作する他の関数について\n"
"は、`Module`モジュールをチェックしてください。\n"

#. TRANSLATORS: defmacro Kernel.raise(msg)
#: lib/kernel.ex:1234
msgid ""
"Raises an exception.\n"
"\n"
"If the argument is a binary, it raises `RuntimeError`\n"
"using the given argument as message.\n"
"\n"
"If an atom, it will become a call to `raise(atom, [])`.\n"
"\n"
"If anything else, it will just raise the given exception.\n"
"\n"
"## Examples\n"
"\n"
"    raise \"Given values do not match\"\n"
"\n"
"    try do\n"
"      1 + :foo\n"
"    rescue\n"
"      x in [ArithmeticError] ->\n"
"        IO.puts \"that was expected\"\n"
"        raise x\n"
"    end\n"
"\n"
msgstr ""
"例外を上げます。\n"
"\n"
"もし引数がバイナリなら、メッセージとして与えられた\n"
"引数を使い、`RuntimeError`を上げます。\n"
"\n"
"もしアトムなら、`raise(atom, [])`を呼ぶことになります。\n"
"\n"
"もしそれ以外なら、与えられた例外を上げます。\n"
"\n"
"## 例\n"
"\n"
"    raise \"Given values do not match\"\n"
"\n"
"    try do\n"
"      1 + :foo\n"
"    rescue\n"
"      x in [ArithmeticError] ->\n"
"        IO.puts \"that was expected\"\n"
"        raise x\n"
"    end\n"
"\n"

#. TRANSLATORS: defmacro Kernel.raise(exception, attrs)
#: lib/kernel.ex:1285
msgid ""
"Raises an exception.\n"
"\n"
"Calls `.exception` on the given argument passing\n"
"the attributes in order to retrieve the appropriate exception\n"
"structure.\n"
"\n"
"Any module defined via `defexception/1` automatically\n"
"implements `exception(attrs)` callback expected by `raise/2`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> raise(ArgumentError, message: \"Sample\")\n"
"    ** (ArgumentError) Sample\n"
"\n"
msgstr ""
"例外を上げます。\n"
"\n"
"適切な例外構造を取得するために、アトリビュートを渡し、\n"
"与えられた引数の`.exception`を呼び出します。\n"
"\n"
"`defexception/1`により定義された任意のモジュールは、自動的に、\n"
"`raise/2`により期待された`exception(attrs)`コールバックを実装します。\n"
"\n"
"## 例\n"
"\n"
"    iex> raise(ArgumentError, message: \"Sample\")\n"
"    ** (ArgumentError) Sample\n"
"\n"

#. TRANSLATORS: defmacro Kernel.reraise(exception, attrs, stacktrace)
#: lib/kernel.ex:1364
msgid ""
"Raises an exception preserving a previous stacktrace.\n"
"\n"
"Works like `raise/2` but does not generate a new stacktrace.\n"
"\n"
"See `reraise/2` for more details.\n"
"\n"
"## Examples\n"
"\n"
"    try do\n"
"      raise \"Oops\"\n"
"    rescue\n"
"      exception ->\n"
"        stacktrace = System.stacktrace\n"
"        reraise WrapperError, [exception: exception], stacktrace\n"
"    end\n"
msgstr ""
"以前のスタックトレースを保ちながら、例外を上げます。\n"
"\n"
"`raise/2`と似た働きをしますが、新しいスタックトレースを生成しません。\n"
"\n"
"詳細は`reraise/2`を参照してください。\n"
"\n"
"## 例\n"
"\n"
"    try do\n"
"      raise \"Oops\"\n"
"    rescue\n"
"      exception ->\n"
"        stacktrace = System.stacktrace\n"
"        reraise WrapperError, [exception: exception], stacktrace\n"
"    end\n"

#. TRANSLATORS: defmacro Kernel.reraise(msg, stacktrace)
#: lib/kernel.ex:1315
msgid ""
"Raises an exception preserving a previous stacktrace.\n"
"\n"
"Works like `raise/1` but does not generate a new stacktrace.\n"
"\n"
"Notice that `System.stacktrace` returns the stacktrace\n"
"of the last exception. That said, it is common to assign\n"
"the stacktrace as the first expression inside a `rescue`\n"
"clause as any other exception potentially raised (and\n"
"rescued) in between the rescue clause and the raise call\n"
"may change the `System.stacktrace` value.\n"
"\n"
"## Examples\n"
"\n"
"    try do\n"
"      raise \"Oops\"\n"
"    rescue\n"
"      exception ->\n"
"        stacktrace = System.stacktrace\n"
"        if Exception.message(exception) == \"Oops\" do\n"
"          reraise exception, stacktrace\n"
"        end\n"
"    end\n"
msgstr ""
"以前のスタックトレースを保ちながら、例外を上げます。\n"
"\n"
"`raise/1`と似た働きをしますが、新しいスタックトレースを生成しません。\n"
"\n"
"`System.stacktrace`は、最後の例外のスタックトレースを返すことに、気を付\n"
"けてください。それは、レスキュー節とレイズの間で、潜在的に上げられた(そ\n"
"してレスキューされた)他の例外としての、`rescue`節の最初の式として、スタッ\n"
"クトレースを割り当てることは、一般的で、`System.stacktrace`値の変更を呼び\n"
"だすかもしれません。\n"
"\n"
"## 例\n"
"\n"
"    try do\n"
"      raise \"Oops\"\n"
"    rescue\n"
"      exception ->\n"
"        stacktrace = System.stacktrace\n"
"        if Exception.message(exception) == \"Oops\" do\n"
"          reraise exception, stacktrace\n"
"        end\n"
"    end\n"

#. TRANSLATORS: def Kernel.put_elem(tuple, index, value)
#: lib/kernel.ex:1100
msgid ""
"Puts the element in `tuple` at the zero-based `index` to the given `value`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Example\n"
"\n"
"    iex> tuple = {:foo, :bar, 3}\n"
"    iex> put_elem(tuple, 0, :baz)\n"
"    {:baz, :bar, 3}\n"
"\n"
msgstr ""
"`tuple`に要素をゼロ始まりの`index`の位置に与えられた`value`で\n"
"プットします。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> tuple = {:foo, :bar, 3}\n"
"    iex> put_elem(tuple, 0, :baz)\n"
"    {:baz, :bar, 3}\n"
"\n"

#. TRANSLATORS: def Kernel.put_in(data, keys, value)
#: lib/kernel.ex:1585
msgid ""
"Puts a value in a nested structure.\n"
"\n"
"Uses the `Access` protocol to traverse the structures\n"
"according to the given `keys`, unless the `key` is a\n"
"function. If the key is a function, it will be invoked\n"
"as specified in `get_and_update_in/3`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> put_in(users, [\"john\", :age], 28)\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"In case any of entries in the middle returns `nil`,\n"
"an error will be raised when trying to access it next.\n"
msgstr ""
"値をネストした構造にプットします。\n"
"\n"
"`keys`が関数でない限り、与えられた`keys`によって\n"
"構造を横断するために、`Access`プロトコルを使います。\n"
"もしキーが関数なら、`get_and_update_in/3`の仕様により\n"
"実行されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> put_in(users, [\"john\", :age], 28)\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"中間のエントリのいずれかが`nil`を返す場合、次にそれに\n"
"アクセスしようとするとき、エラーが上ります。\n"

#. TRANSLATORS: defmacro Kernel.put_in(path, value)
#: lib/kernel.ex:1696
msgid ""
"Puts a value in a nested structure via the given `path`.\n"
"\n"
"This is similar to `put_in/3`, except the path is extracted via\n"
"a macro rather than passing a list. For example:\n"
"\n"
"    put_in(opts[:foo][:bar], :baz)\n"
"\n"
"Is equivalent to:\n"
"\n"
"    put_in(opts, [:foo, :bar], :baz)\n"
"\n"
"Note that in order for this macro to work, the complete path must always\n"
"be visible by this macro. For more information about the supported path\n"
"expressions, please check `get_and_update_in/2` docs.\n"
"\n"
"## Examples\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> put_in(users[\"john\"][:age], 28)\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> put_in(users[\"john\"].age, 28)\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
msgstr ""
"値をネストした構造に`path`によりプットします。\n"
"\n"
"pathが、リストを渡しているよりはむしろ、マクロによって抽出される\n"
"こと以外は、`put_in/3`に似ています。例えば:\n"
"\n"
"`keys`が関数でない限り、与えられた`keys`によって\n"
"構造を横断するために、`Access`プロトコルを使います。\n"
"もしキーが関数なら、`get_and_update_in/3`の仕様により\n"
"実行されます。\n"
"\n"
"\n"
"中間のエントリのいずれかが`nil`を返す場合、次にそれに\n"
"アクセスしようとするとき、エラーが上ります。\n"
"\n"
"\n"
"    put_in(opts[:foo][:bar], :baz)\n"
"\n"
"は以下と等価です:\n"
"\n"
"    put_in(opts, [:foo, :bar], :baz)\n"
"\n"
"このマクロが機能するために、完全なパスは、常にこのマクロによって可視で\n"
"なければならないことに注意してください。サポートされたパス表現について\n"
"の詳細は、`get_and_update_in/2`ドキュメントをチェックしてください。\n"
"\n"
"## 例\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> put_in(users[\"john\"][:age], 28)\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> put_in(users[\"john\"].age, 28)\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"

#. TRANSLATORS: defmacro Kernel.if(condition, clauses)
#: lib/kernel.ex:2151
msgid ""
"Provides an `if` macro. This macro expects the first argument to\n"
"be a condition and the rest are keyword arguments.\n"
"\n"
"## One-liner examples\n"
"\n"
"    if(foo, do: bar)\n"
"\n"
"In the example above, `bar` will be returned if `foo` evaluates to\n"
"`true` (i.e. it is neither `false` nor `nil`). Otherwise, `nil` will be "
"returned.\n"
"\n"
"An `else` option can be given to specify the opposite:\n"
"\n"
"    if(foo, do: bar, else: baz)\n"
"\n"
"## Blocks examples\n"
"\n"
"Elixir also allows you to pass a block to the `if` macro. The first\n"
"example above would be translated to:\n"
"\n"
"    if foo do\n"
"      bar\n"
"    end\n"
"\n"
"Notice that `do/end` becomes delimiters. The second example would\n"
"then translate to:\n"
"\n"
"    if foo do\n"
"      bar\n"
"    else\n"
"      baz\n"
"    end\n"
"\n"
"If you want to compare more than two clauses, you can use the `cond/1`\n"
"macro.\n"
msgstr ""
"`if`マクロを提供します。このマクロは最初の引数をコンディションとして、\n"
"残りをキーワード引数として期待します。\n"
"\n"
"## ワンライナーの例\n"
"\n"
"    if(foo, do: bar)\n"
"\n"
"上の例では、`foo`が`true`(即ち、`false`でもなく、`nil`でもないなら)に評\n"
"価されたら、`bar`が返されます。さもなくば、`nil`が返ります。\n"
"\n"
"`else`オプションは正反対を指定させることができます:\n"
"\n"
"    if(foo, do: bar, else: baz)\n"
"\n"
"## ブロックの例\n"
"\n"
"Elixirは`if`マクロにブロックを渡すことも許しています。上の最初の\n"
"例は、以下のように翻訳されます:\n"
"\n"
"    if foo do\n"
"      bar\n"
"    end\n"
"\n"
"`do/end`がブロックのデリミタであることに注意してください。二番目の例は\n"
"次のように翻訳されます:\n"
"\n"
"    if foo do\n"
"      bar\n"
"    else\n"
"      baz\n"
"    end\n"
"\n"
"もし二つ以上の節を比較したいなら、`cond/1`マクロを使うことができます。\n"

#. TRANSLATORS: defmacro Kernel.||(left, right)
#: lib/kernel.ex:2313
msgid ""
"Provides a short-circuit operator that evaluates and returns the second\n"
"expression only if the first one does not evaluate to true (i.e. it\n"
"is either nil or false). Returns the first expression otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.empty?([1]) || Enum.empty?([1])\n"
"    false\n"
"\n"
"    iex> List.first([]) || true\n"
"    true\n"
"\n"
"    iex> Enum.empty?([1]) || 1\n"
"    1\n"
"\n"
"    iex> Enum.empty?([]) || throw(:bad)\n"
"    true\n"
"\n"
"Notice that, unlike Erlang's `or` operator,\n"
"this operator accepts any expression as an argument,\n"
"not only booleans, however it is not allowed in guards.\n"
msgstr ""
"最初の式が`true`(即ち、nilでもfalseでもない)に評価されなかったとき\n"
"だけ二番目の式を評価し、返す、ショートサーキット演算子を提供します。\n"
"さもなければ最初の式を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.empty?([1]) || Enum.empty?([1])\n"
"    false\n"
"\n"
"    iex> List.first([]) || true\n"
"    true\n"
"\n"
"    iex> Enum.empty?([1]) || 1\n"
"    1\n"
"\n"
"    iex> Enum.empty?([]) || throw(:bad)\n"
"    true\n"
"\n"
"Erlangの`or`演算子と違って、この演算子は、ガードの中では許されませんが、\n"
"引数としてブーリアンだけでなく任意の式を受け付けることに、注意してくだ\n"
"さい。\n"

#. TRANSLATORS: defmacro Kernel.&&(left, right)
#: lib/kernel.ex:2279
msgid ""
"Provides a short-circuit operator that evaluates and returns\n"
"the second expression only if the first one evaluates to true\n"
"(i.e. it is not nil nor false). Returns the first expression\n"
"otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.empty?([]) && Enum.empty?([])\n"
"    true\n"
"\n"
"    iex> List.first([]) && true\n"
"    nil\n"
"\n"
"    iex> Enum.empty?([]) && List.first([1])\n"
"    1\n"
"\n"
"    iex> false && throw(:bad)\n"
"    false\n"
"\n"
"Notice that, unlike Erlang's `and` operator,\n"
"this operator accepts any expression as an argument,\n"
"not only booleans, however it is not allowed in guards.\n"
msgstr ""
"最初の式が`true`(即ち、nilでもfalseでもない)に評価されたとき\n"
"だけ二番目の式を評価し、返す、ショートサーキット演算子を提供します。\n"
"さもなければ最初の式を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.empty?([]) && Enum.empty?([])\n"
"    true\n"
"\n"
"    iex> List.first([]) && true\n"
"    nil\n"
"\n"
"    iex> Enum.empty?([]) && List.first([1])\n"
"    1\n"
"\n"
"    iex> false && throw(:bad)\n"
"    false\n"
"\n"
"Erlangの`and`演算子と違って、この演算子は、ガードの中では許されませんが、\n"
"引数としてブーリアンだけでなく任意の式を受け付けることに、注意してくだ\n"
"さい。\n"

#. TRANSLATORS: def Kernel.div(left, right)
#: lib/kernel.ex:172
msgid ""
"Performs an integer division.\n"
"\n"
"Raises an error if one of the arguments is not an integer.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> div(5, 2)\n"
"    2\n"
"\n"
msgstr ""
"整数の除算を実行します。\n"
"\n"
"引数の一つが整数でないなら、エラーを上げます。\n"
"\n"
"ガードテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> div(5, 2)\n"
"    2\n"
"\n"

#. TRANSLATORS: def Kernel.=~(left, right)
#: lib/kernel.ex:1390
msgid ""
"Matches the term on the left against the regular expression or string on "
"the\n"
"right. Returns true if `left` matches `right` (if it's a regular "
"expression)\n"
"or contains `right` (if it's a string).\n"
"\n"
"## Examples\n"
"\n"
"    iex> \"abcd\" =~ ~r/c(d)/\n"
"    true\n"
"\n"
"    iex> \"abcd\" =~ ~r/e/\n"
"    false\n"
"\n"
"    iex> \"abcd\" =~ \"bc\"\n"
"    true\n"
"\n"
"    iex> \"abcd\" =~ \"ad\"\n"
"    false\n"
"\n"
msgstr ""
"右辺の正規表現か文字列に対して、左辺をマッチさせます。`left`が、正規表\n"
"現`right`にマッチしたか、文字列`right`を含んでいたら、trueを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> \"abcd\" =~ ~r/c(d)/\n"
"    true\n"
"\n"
"    iex> \"abcd\" =~ ~r/e/\n"
"    false\n"
"\n"
"    iex> \"abcd\" =~ \"bc\"\n"
"    true\n"
"\n"
"    iex> \"abcd\" =~ \"ad\"\n"
"    false\n"
"\n"

#. TRANSLATORS: defmacro Kernel.defoverridable(tuples)
#: lib/kernel.ex:3207
msgid ""
"Makes the given functions in the current module overridable. An overridable\n"
"function is lazily defined, allowing a developer to customize it.\n"
"\n"
"## Example\n"
"\n"
"    defmodule DefaultMod do\n"
"      defmacro __using__(_opts) do\n"
"        quote do\n"
"          def test(x, y) do\n"
"            x + y\n"
"          end\n"
"\n"
"          defoverridable [test: 2]\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    defmodule InheritMod do\n"
"      use DefaultMod\n"
"\n"
"      def test(x, y) do\n"
"        x * y + super(x, y)\n"
"      end\n"
"    end\n"
"\n"
"As seen as in the example `super` can be used to call the default\n"
"implementation.\n"
msgstr ""
"現在のモジュールの与えられた関数をoverridableにします。overridable関数\n"
"は、開発者がカスタマイズするために、後から定義することを許します。\n"
"\n"
"## 例\n"
"\n"
"    defmodule DefaultMod do\n"
"      defmacro __using__(_opts) do\n"
"        quote do\n"
"          def test(x, y) do\n"
"            x + y\n"
"          end\n"
"\n"
"          defoverridable [test: 2]\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    defmodule InheritMod do\n"
"      use DefaultMod\n"
"\n"
"      def test(x, y) do\n"
"        x * y + super(x, y)\n"
"      end\n"
"    end\n"
"\n"
"上は良くみられる例で、`super`はデオフォルトの実装を呼ぶため使われます。\n"

#. TRANSLATORS: def Kernel.binary_part(binary, start, length)
#: lib/kernel.ex:112
msgid ""
"Extracts the part of the binary starting at `start` with length `length`.\n"
"Binaries are zero-indexed.\n"
"\n"
"If start or length references in any way outside the binary, an\n"
"`ArgumentError` exception is raised.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> binary_part(\"foo\", 1, 2)\n"
"    \"oo\"\n"
"\n"
"A negative length can be used to extract bytes at the end of a binary:\n"
"\n"
"    iex> binary_part(\"foo\", 3, -1)\n"
"    \"o\"\n"
"\n"
msgstr ""
"`start`から長さ`length`のバイナリの部分を抽出します。\n"
"バイナリは0始まりです。\n"
"\n"
"もしstartかlengthがバイナリの外部を参照するなら、\n"
"`ArgumentError`例外が上ります。\n"
"\n"
"ガードテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> binary_part(\"foo\", 1, 2)\n"
"    \"oo\"\n"
"\n"
"start位置で終わるバイトを抽出するために、負の長さを使うことができます。\n"
"\n"
"    iex> binary_part(\"foo\", 3, -1)\n"
"    \"o\"\n"
"\n"

#. TRANSLATORS: def Kernel.apply(fun, args)
#: lib/kernel.ex:71
msgid ""
"Invokes the given `fun` with the array of arguments `args`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> apply(fn x -> x * 2 end, [2])\n"
"    4\n"
"\n"
msgstr ""
"引数の配列`args`で与えられた`fun`を起動します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> apply(fn x -> x * 2 end, [2])\n"
"    4\n"
"\n"

#. TRANSLATORS: def Kernel.apply(module, fun, args)
#: lib/kernel.ex:87
msgid ""
"Invokes the given `fun` from `module` with the array of arguments `args`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> apply(Enum, :reverse, [[1, 2, 3]])\n"
"    [3,2,1]\n"
"\n"
msgstr ""
"引数の配列`args`で与えられた`module`の`fun`を起動します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> apply(Enum, :reverse, [[1, 2, 3]])\n"
"    [3,2,1]\n"
"\n"

#. TRANSLATORS: def Kernel.spawn_monitor(module, fun, args)
#: lib/kernel.ex:695
msgid ""
"Spawns the given module and function passing the given args,\n"
"monitors it and returns its pid and monitoring reference.\n"
"\n"
"Check the modules `Process` and `Node` for other functions\n"
"to handle processes, including spawning functions in nodes.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    spawn_monitor(SomeModule, :function, [1, 2, 3])\n"
"\n"
msgstr ""
"与えられたモジュールと関数に与えられた引数を送ってプロセスを生成し、\n"
"生成したプロセスのpidと、そのプロセスのモニタリファレンスを返します。\n"
"\n"
"他のノードで関数を生成することを含む、プロセスを取り扱う他の関数につい\n"
"ては`Process`と`Node`モジュールをチェックしてください。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    spawn_monitor(SomeModule, :function, [1, 2, 3])\n"
"\n"

#. TRANSLATORS: def Kernel.spawn_link(module, fun, args)
#: lib/kernel.ex:656
msgid ""
"Spawns the given module and function passing the given args,\n"
"links it to the current process and returns its pid.\n"
"\n"
"Check the modules `Process` and `Node` for other functions\n"
"to handle processes, including spawning functions in nodes.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    spawn_link(SomeModule, :function, [1, 2, 3])\n"
"\n"
msgstr ""
"与えられたモジュールと関数に与えられた引数を送ってプロセスを生成し、\n"
"そのプロセスを現在のプロセスにリンクして、生成したプロセスのpidを\n"
"返します。\n"
"\n"
"他のノードで関数を生成することを含む、プロセスを取り扱う他の関数につい\n"
"ては`Process`と`Node`モジュールをチェックしてください。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    spawn_link(SomeModule, :function, [1, 2, 3])\n"
"\n"

#. TRANSLATORS: def Kernel.spawn(module, fun, args)
#: lib/kernel.ex:614
msgid ""
"Spawns the given module and function passing the given args\n"
"and returns its pid.\n"
"\n"
"Check the modules `Process` and `Node` for other functions\n"
"to handle processes, including spawning functions in nodes.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    spawn(SomeModule, :function, [1, 2, 3])\n"
"\n"
msgstr ""
"与えられたモジュールと関数に与えられた引数を送ってプロセスを生成し、\n"
"生成したプロセスのpidを返します。\n"
"\n"
"他のノードで関数を生成することを含む、プロセスを取り扱う他の関数につい\n"
"ては`Process`と`Node`モジュールをチェックしてください。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    spawn(SomeModule, :function, [1, 2, 3])\n"
"\n"

#. TRANSLATORS: def Kernel.spawn_monitor(fun)
#: lib/kernel.ex:676
msgid ""
"Spawns the given function, monitors it and returns its pid\n"
"and monitoring reference.\n"
"\n"
"Check the modules `Process` and `Node` for other functions\n"
"to handle processes, including spawning functions in nodes.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    current = Kernel.self\n"
"    spawn_monitor(fn -> send current, {Kernel.self, 1 + 2} end)\n"
"\n"
msgstr ""
"与えられた関数のプロセス生成し、生成したプロセスのpidと、そのプロセスの\n"
"モニタリファレンスを返します。\n"
"\n"
"他のノードで関数を生成することを含む、プロセスを取り扱う他の関数につい\n"
"ては`Process`と`Node`モジュールをチェックしてください。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    current = Kernel.self\n"
"    spawn_monitor(fn -> send current, {Kernel.self, 1 + 2} end)\n"
"\n"

#. TRANSLATORS: def Kernel.spawn_link(fun)
#: lib/kernel.ex:637
msgid ""
"Spawns the given function, links it to the current process and returns its "
"pid.\n"
"\n"
"Check the modules `Process` and `Node` for other functions\n"
"to handle processes, including spawning functions in nodes.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    current = Kernel.self\n"
"    child   = spawn_link(fn -> send current, {Kernel.self, 1 + 2} end)\n"
"\n"
"    receive do\n"
"      {^child, 3} -> IO.puts \"Received 3 back\"\n"
"    end\n"
"\n"
msgstr ""
"与えられた関数のプロセスを生成し、そのプロセスを現在のプロセスにリンク\n"
"して、生成したプロセスのpidを返します。\n"
"\n"
"他のノードで関数を生成することを含む、プロセスを取り扱う他の関数につい\n"
"ては`Process`と`Node`モジュールをチェックしてください。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    current = Kernel.self\n"
"    child   = spawn_link(fn -> send current, {Kernel.self, 1 + 2} end)\n"
"\n"
"    receive do\n"
"      {^child, 3} -> IO.puts \"Received 3 back\"\n"
"    end\n"
"\n"

#. TRANSLATORS: def Kernel.spawn(fun)
#: lib/kernel.ex:595
msgid ""
"Spawns the given function and returns its pid.\n"
"\n"
"Check the modules `Process` and `Node` for other functions\n"
"to handle processes, including spawning functions in nodes.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    current = Kernel.self\n"
"    child   = spawn(fn -> send current, {Kernel.self, 1 + 2} end)\n"
"\n"
"    receive do\n"
"      {^child, 3} -> IO.puts \"Received 3 back\"\n"
"    end\n"
"\n"
msgstr ""
"与えられた関数のプロセスを生成し、生成したプロセスのpidを返します。\n"
"\n"
"他のノードで関数を生成することを含む、プロセスを取り扱う他の関数につい\n"
"ては`Process`と`Node`モジュールをチェックしてください。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    current = Kernel.self\n"
"    child   = spawn(fn -> send current, {Kernel.self, 1 + 2} end)\n"
"\n"
"    receive do\n"
"      {^child, 3} -> IO.puts \"Received 3 back\"\n"
"    end\n"
"\n"

#. TRANSLATORS: def Kernel.min(first, second)
#: lib/kernel.ex:485
msgid ""
"Returns the smallest of the two given terms according to\n"
"Erlang's term ordering. If the terms compare equal, the\n"
"first one is returned.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> min(1, 2)\n"
"    1\n"
"\n"
msgstr ""
"与えられた二つのtermのうち、Erlangのtermの順序について、\n"
"小さいほうを返します。termが等しいなら、firstを返します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> min(1, 2)\n"
"    1\n"
"\n"

#. TRANSLATORS: def Kernel.tuple_size(tuple)
#: lib/kernel.ex:743
msgid ""
"Returns the size of a tuple.\n"
"\n"
"This operation happens in constant time.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"タプルのサイズを返します。\n"
"\n"
"このオペレーションは定数時間で実行されます。\n"
"\n"
"ガード中のテストに使うことができます。コンパイラによりインライン化され\n"
"ます。\n"

#. TRANSLATORS: def Kernel.map_size(map)
#: lib/kernel.ex:449
msgid ""
"Returns the size of a map.\n"
"\n"
"This operation happens in constant time.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"マップのサイズを返します。\n"
"\n"
"このオペレーションは定数時間で実行されます。\n"
"\n"
"ガード中のテストに使うことができます。コンパイラによりインライン化され\n"
"ます。\n"

#. TRANSLATORS: def Kernel.self()
#: lib/kernel.ex:572
msgid ""
"Returns the pid (process identifier) of the calling process.\n"
"\n"
"Allowed in guard clauses. Inlined by the compiler.\n"
msgstr ""
"呼び出したプロセスのpid(プロセス識別子)を返します。\n"
"\n"
"ガード節の中で使用できます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.trunc(number)
#: lib/kernel.ex:731
msgid ""
"Returns an integer by truncating the given number.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> trunc(5.5)\n"
"    5\n"
"\n"
msgstr ""
"与えられた数をトランケートした整数を返します。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> trunc(5.5)\n"
"    5\n"
"\n"

#. TRANSLATORS: def Kernel.round(number)
#: lib/kernel.ex:542
msgid ""
"Returns an integer by rounding the given number.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> round(5.5)\n"
"    6\n"
"\n"
msgstr ""
"与えられた数を丸めた整数を返します。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> round(5.5)\n"
"    6\n"
"\n"

#. TRANSLATORS: def Kernel.inspect(arg, opts \\ [])
#: lib/kernel.ex:1447
msgid ""
"Inspects the given argument according to the `Inspect` protocol.\n"
"The second argument is a keywords list with options to control\n"
"inspection.\n"
"\n"
"## Options\n"
"\n"
"`inspect/2` accepts a list of options that are internally\n"
"translated to an `Inspect.Opts` struct. Check the docs for\n"
"`Inspect.Opts` to see the supported options.\n"
"\n"
"## Examples\n"
"\n"
"    iex> inspect(:foo)\n"
"    \":foo\"\n"
"\n"
"    iex> inspect [1, 2, 3, 4, 5], limit: 3\n"
"    \"[1, 2, 3, ...]\"\n"
"\n"
"    iex> inspect(\"olá\" <> <<0>>)\n"
"    \"<<111, 108, 195, 161, 0>>\"\n"
"\n"
"    iex> inspect(\"olá\" <> <<0>>, binaries: :as_strings)\n"
"    \"\\\"olá\\\\0\\\"\"\n"
"\n"
"    iex> inspect(\"olá\", binaries: :as_binaries)\n"
"    \"<<111, 108, 195, 161>>\"\n"
"\n"
"    iex> inspect('bar')\n"
"    \"'bar'\"\n"
"\n"
"    iex> inspect([0|'bar'])\n"
"    \"[0, 98, 97, 114]\"\n"
"\n"
"    iex> inspect(100, base: :octal)\n"
"    \"0o144\"\n"
"\n"
"    iex> inspect(100, base: :hex)\n"
"    \"0x64\"\n"
"\n"
"Note that the inspect protocol does not necessarily return a valid\n"
"representation of an Elixir term. In such cases, the inspected result\n"
"must start with `#`. For example, inspecting a function will return:\n"
"\n"
"    inspect fn a, b -> a + b end\n"
"    #=> #Function<...>\n"
"\n"
msgstr ""
"`Inspect`プロトコルに従って、与えられた引数でインスペクトします。\n"
"2番目の引数はキーワードリストで、インスペクトを制御するオプションです。\n"
"\n"
"## オプション\n"
"\n"
"`inspect/2`は`Inspect.Opts`構造体に内部的に変換されるオプションの\n"
"リストを受け付けます。サポートするオプションについては、\n"
"`Inspect.Opts`のドキュメントをチェックしてください。\n"
"\n"
"## 例\n"
"\n"
"    iex> inspect(:foo)\n"
"    \":foo\"\n"
"\n"
"    iex> inspect [1, 2, 3, 4, 5], limit: 3\n"
"    \"[1, 2, 3, ...]\"\n"
"\n"
"    iex> inspect(\"olá\" <> <<0>>)\n"
"    \"<<111, 108, 195, 161, 0>>\"\n"
"\n"
"    iex> inspect(\"olá\" <> <<0>>, binaries: :as_strings)\n"
"    \"\\\"olá\\\\0\\\"\"\n"
"\n"
"    iex> inspect(\"olá\", binaries: :as_binaries)\n"
"    \"<<111, 108, 195, 161>>\"\n"
"\n"
"    iex> inspect('bar')\n"
"    \"'bar'\"\n"
"\n"
"    iex> inspect([0|'bar'])\n"
"    \"[0, 98, 97, 114]\"\n"
"\n"
"    iex> inspect(100, base: :octal)\n"
"    \"0o144\"\n"
"\n"
"    iex> inspect(100, base: :hex)\n"
"    \"0x64\"\n"
"\n"
"なお、インスペクトプロトコルは、Elixirタームの有効な表現を返す必要は、\n"
"必ずしもないです。そのような場合、インスペクトされた結果は、`#`から\n"
"始めなければなりません。例えば、関数をインスペクトすると、\n"
"以下のように返されます:\n"
"\n"
"    inspect fn a, b -> a + b end\n"
"    #=> #Function<...>\n"
"\n"

#. TRANSLATORS: def Kernel.node()
#: lib/kernel.ex:496
msgid ""
"Returns an atom representing the name of the local node.\n"
"If the node is not alive, `:nonode@nohost` is returned instead.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"ローカルノードの名前を表現するアトムを返します。\n"
"もしノードが生きていないなら、`:nonode@nohost`が替わりに返されます。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.make_ref()
#: lib/kernel.ex:437
msgid ""
"Returns an almost unique reference.\n"
"\n"
"The returned reference will re-occur after approximately 2^82 calls;\n"
"therefore it is unique enough for practical purposes.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    make_ref() #=> #Reference<0.0.0.135>\n"
"\n"
msgstr ""
"ほとんどユニークなリファレンスを返します。\n"
"\n"
"返されたリファレンスはおよそ2^82回の呼び出しの後、再度発生します;\n"
"従ってそれは実際上は十分にユニークです。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    make_ref() #=> #Reference<0.0.0.135>\n"
"\n"

#. TRANSLATORS: def Kernel.elem(tuple, index)
#: lib/kernel.ex:1083
msgid ""
"Gets the element at the zero-based `index` in `tuple`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Example\n"
"\n"
"    iex> tuple = {:foo, :bar, 3}\n"
"    iex> elem(tuple, 1)\n"
"    :bar\n"
"\n"
msgstr ""
"`tuple`の0始まりの`index`の場所の要素を取得します。\n"
"\n"
"ガードテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> tuple = {:foo, :bar, 3}\n"
"    iex> elem(tuple, 1)\n"
"    :bar\n"
"\n"

#. TRANSLATORS: def Kernel.get_in(data, keys)
#: lib/kernel.ex:1550
msgid ""
"Gets a value from a nested structure.\n"
"\n"
"Uses the `Access` protocol to traverse the structures\n"
"according to the given `keys`, unless the `key` is a\n"
"function.\n"
"\n"
"If a key is a function, the function will be invoked\n"
"passing three arguments, the operation (`:get`), the\n"
"data to be accessed, and a function to be invoked next.\n"
"\n"
"This means `get_in/2` can be extended to provide\n"
"custom lookups. The downside is that functions cannot be\n"
"stored as keys in the accessed data structures.\n"
"\n"
"## Examples\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> get_in(users, [\"john\", :age])\n"
"    27\n"
"\n"
"In case any of entries in the middle returns `nil`, `nil` will be returned\n"
"as per the Access protocol:\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> get_in(users, [\"unknown\", :age])\n"
"    nil\n"
"\n"
"When one of the keys is a function, the function is invoked.\n"
"In the example below, we use a function to get all the maps\n"
"inside a list:\n"
"\n"
"    iex> users = [%{name: \"john\", age: 27}, %{name: \"meg\", age: 23}]\n"
"    iex> all = fn :get, data, next -> Enum.map(data, next) end\n"
"    iex> get_in(users, [all, :age])\n"
"    [27, 23]\n"
"\n"
"If the previous value before invoking the function is nil,\n"
"the function *will* receive nil as a value and must handle it\n"
"accordingly.\n"
msgstr ""
"ネストした構造から値を取得します。\n"
"\n"
"\n"
"`key`が関数でない限り、与えられた`keys`に従って構造を渡り歩くために、\n"
"`Access`プトロコルを使います。\n"
"\n"
"もしキーが関数なら、関数は、オペレーション(`:get`)、アクセスされるデー\n"
"タ、次に実行される関数の、3個の引数を渡されて実行されます。\n"
"\n"
"この`get_in/2`の手段は、カスタムメイドの検索を提供するために拡張可能です。\n"
"不利な面は、関数がアクセスされたデータ構造のキーとして格納されないという\n"
"ことです。\n"
"\n"
"## 例\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> get_in(users, [\"john\", :age])\n"
"    27\n"
"\n"
"中間のエントリのいずれかが`nil`を返す場合、Accessプロトコルを使うたびに\n"
"`nil`を返します:\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> get_in(users, [\"unknown\", :age])\n"
"    nil\n"
"\n"
"キーの一つが関数のとき、関数は実行されます。\n"
"下の例では、リストの中の全てのマップを取得するために、\n"
"関数を使っています:\n"
"\n"
"    iex> users = [%{name: \"john\", age: 27}, %{name: \"meg\", age: 23}]\n"
"    iex> all = fn :get, data, next -> Enum.map(data, next) end\n"
"    iex> get_in(users, [all, :age])\n"
"    [27, 23]\n"
"\n"
"もし関数を実行する以前の値がnilなら、関数は、値としてnilを受け取る*でしょ\n"
"う*。そしてそれに従って取り扱わなければなりません。\n"

#. TRANSLATORS: def Kernel.get_and_update_in(data, keys, fun)
#: lib/kernel.ex:1657
msgid ""
"Gets a value and updates a nested structure.\n"
"\n"
"It expects a tuple to be returned, containing the value\n"
"retrieved and the update one.\n"
"\n"
"Uses the `Access` protocol to traverse the structures\n"
"according to the given `keys`, unless the `key` is a\n"
"function.\n"
"\n"
"If a key is a function, the function will be invoked\n"
"passing three arguments, the operation (`:get_and_update`),\n"
"the data to be accessed, and a function to be invoked next.\n"
"\n"
"This means `get_and_update_in/3` can be extended to provide\n"
"custom lookups. The downside is that functions cannot be stored\n"
"as keys in the accessed data structures.\n"
"\n"
"## Examples\n"
"\n"
"This function is useful when there is a need to retrieve the current\n"
"value (or something calculated in function of the current value) and\n"
"update it at the same time. For example, it could be used to increase\n"
"the age of a user by one and return the previous age in one pass:\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> get_and_update_in(users, [\"john\", :age], &{&1, &1 + 1})\n"
"    {27, %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}}\n"
"\n"
"When one of the keys is a function, the function is invoked.\n"
"In the example below, we use a function to get and increment all\n"
"ages inside a list:\n"
"\n"
"    iex> users = [%{name: \"john\", age: 27}, %{name: \"meg\", age: 23}]\n"
"    iex> all = fn :get_and_update, data, next ->\n"
"    ...>   Enum.map(data, next) |> :lists.unzip\n"
"    ...> end\n"
"    iex> get_and_update_in(users, [all, :age], &{&1, &1 + 1})\n"
"    {[27, 23], [%{name: \"john\", age: 28}, %{name: \"meg\", age: 24}]}\n"
"\n"
"If the previous value before invoking the function is nil,\n"
"the function *will* receive `nil` as a value and must handle it\n"
"accordingly (be it by failing or providing a sane default).\n"
msgstr ""
"ネストした構造から値を取得し、更新します。\n"
"\n"
"取得した値と、更新した値を含むタプルを返すことが、期待されます。\n"
"\n"
"`keys`が関数でない限り、与えられた`keys`によって\n"
"構造を渡り歩くために、`Access`プロトコルを使います。\n"
"\n"
"もしキーが関数なら、関数は、オペレーション(`:get_and_update`)、アクセス\n"
"されるデータ、次に実行される関数の、3個の引数を渡されて実行されます。\n"
"\n"
"この`get_and_update_in/3`の手段は、カスタムメイドの検索を提供するために\n"
"拡張可能です。不利な面は、関数がアクセスされたデータ構造のキーとして格\n"
"納されないということです。\n"
"\n"
"## 例\n"
"\n"
"この関数は、現在の値(または現在の値で計算される何か)の取得と、更新を同\n"
"時に行いたい場合に、便利です。例えば、ユーザの前の年齢を取得し、年齢を\n"
"増加することを一度に行うために、使うことができます:\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> get_and_update_in(users, [\"john\", :age], &{&1, &1 + 1})\n"
"    {27, %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}}\n"
"\n"
"キーの一つが関数の時、関数が起動されます。\n"
"下の例では、リスト中の全ての年齢を取得し、増加させるために\n"
"関数を使っています:\n"
"\n"
"    iex> users = [%{name: \"john\", age: 27}, %{name: \"meg\", age: 23}]\n"
"    iex> all = fn :get_and_update, data, next ->\n"
"    ...>   Enum.map(data, next) |> List.unzip() |> List.to_tuple()\n"
"    ...> end\n"
"    iex> get_and_update_in(users, [all, :age], &{&1, &1 + 1})\n"
"    {[27, 23], [%{name: \"john\", age: 28}, %{name: \"meg\", age: 24}]}\n"
"\n"
"もし関数を実行する以前の値がnilなら、関数は、値として`nil`を受け取る\n"
"*でしょう*。そしてそれに従って(失敗するか、デフォルトの正しい値を\n"
"提供することによって)取り扱わなければなりません。\n"

#. TRANSLATORS: defmacro Kernel.get_and_update_in(path, fun)
#: lib/kernel.ex:1783
msgid ""
"Gets a value and updates a nested data structure via the given `path`.\n"
"\n"
"This is similar to `get_and_update_in/3`, except the path is extracted\n"
"via a macro rather than passing a list. For example:\n"
"\n"
"    get_and_update_in(opts[:foo][:bar], &{&1, &1 + 1})\n"
"\n"
"Is equivalent to:\n"
"\n"
"    get_and_update_in(opts, [:foo, :bar], &{&1, &1 + 1})\n"
"\n"
"Note that in order for this macro to work, the complete path must always\n"
"be visible by this macro. See the Paths section below.\n"
"\n"
"## Examples\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> get_and_update_in(users[\"john\"].age, &{&1, &1 + 1})\n"
"    {27, %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}}\n"
"\n"
"## Paths\n"
"\n"
"A path may start with a variable, local or remote call, and must be\n"
"followed by one or more:\n"
"\n"
"  * `foo[bar]` - access a field; in case an intermediate field is not\n"
"    present or returns nil, an empty map is used\n"
"\n"
"  * `foo.bar` - access a map/struct field; in case the field is not\n"
"    present, an error is raised\n"
"\n"
"Here are some valid paths:\n"
"\n"
"    users[\"john\"][:age]\n"
"    users[\"john\"].age\n"
"    User.all[\"john\"].age\n"
"    all_users()[\"john\"].age\n"
"\n"
"Here are some invalid ones:\n"
"\n"
"    # Does a remote call after the initial value\n"
"    users[\"john\"].do_something(arg1, arg2)\n"
"\n"
"    # Does not access any field\n"
"    users\n"
"\n"
msgstr ""
"与えられた`path`によってネストしたデータ構造の値を取得、更新します。\n"
"\n"
"pathが、リストを渡しているよりはむしろ、マクロによって抽出される\n"
"こと以外は、`get_and_update_in/3`に似ています。例えば:\n"
"\n"
"    get_and_update_in(opts[:foo][:bar], &{&1, &1 + 1})\n"
"\n"
"は、以下と等しいです:\n"
"\n"
"    get_and_update_in(opts, [:foo, :bar], &{&1, &1 + 1})\n"
"\n"
"このマクロが機能するために、完全なパスが常にこのマクロによって見えてい\n"
"なければならないことに注意してください。以下のパスセクションを参照して\n"
"ください。\n"
"\n"
"## 例\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> get_and_update_in(users[\"john\"].age, &{&1, &1 + 1})\n"
"    {27, %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}}\n"
"\n"
"## パス\n"
"\n"
"パスは変数、ローカルかリモートコールで始まり、以下の一つ以上\n"
"が続かなければなりません:\n"
"\n"
"  * `foo[bar]` - フィールドアクセス; 中間のフィールドが存在しないか、\n"
"                 nilを返す場合、空のマップが使われます\n"
"\n"
"  * `foo.bar` - マップ/構造体フィルドのアクセス; フィールドが存在しない\n"
"                場合、エラーが上ります\n"
"\n"
"これらは正しいパスです:\n"
"\n"
"    users[\"john\"][:age]\n"
"    users[\"john\"].age\n"
"    User.all[\"john\"].age\n"
"    all_users()[\"john\"].age\n"
"\n"
"これらは間違ったパスです:\n"
"\n"
"    # Does a remote call after the initial value\n"
"    users[\"john\"].do_something(arg1, arg2)\n"
"\n"
"    # Does not access any field\n"
"    users\n"
"\n"

#. TRANSLATORS: defmacro Kernel.unless(clause, options)
#: lib/kernel.ex:2178
msgid ""
"Evaluates and returns the do-block passed in as a second argument\n"
"unless clause evaluates to true.\n"
"Returns nil otherwise.\n"
"See also `if`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> unless(Enum.empty?([]), do: \"Hello\")\n"
"    nil\n"
"\n"
"    iex> unless(Enum.empty?([1,2,3]), do: \"Hello\")\n"
"    \"Hello\"\n"
"\n"
msgstr ""
"clauseがtrueでない限り、2番目の引数として渡されたdo-blockを評価して返し\n"
"ます。\n"
"さもなければ、nilを返します。\n"
"`if`も参照してください。\n"
"\n"
"## 例\n"
"\n"
"    iex> unless(Enum.empty?([]), do: \"Hello\")\n"
"    nil\n"
"\n"
"    iex> unless(Enum.empty?([1,2,3]), do: \"Hello\")\n"
"    \"Hello\"\n"
"\n"

#. TRANSLATORS: defmacro Kernel.defdelegate(funs, opts)
#: lib/kernel.ex:3302
msgid ""
"Defines the given functions in the current module that will\n"
"delegate to the given `target`. Functions defined with\n"
"`defdelegate` are public and are allowed to be invoked\n"
"from external. If you find yourself wishing to define a\n"
"delegation as private, you should likely use import\n"
"instead.\n"
"\n"
"Delegation only works with functions, delegating to macros\n"
"is not supported.\n"
"\n"
"## Options\n"
"\n"
"  * `:to` - the expression to delegate to. Any expression\n"
"    is allowed and its results will be calculated on runtime.\n"
"\n"
"  * `:as` - the function to call on the target given in `:to`.\n"
"    This parameter is optional and defaults to the name being\n"
"    delegated.\n"
"\n"
"  * `:append_first` - if true, when delegated, first argument\n"
"    passed to the delegate will be relocated to the end of the\n"
"    arguments when dispatched to the target.\n"
"\n"
"    The motivation behind this is because Elixir normalizes\n"
"    the \"handle\" as a first argument and some Erlang modules\n"
"    expect it as last argument.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule MyList do\n"
"      defdelegate reverse(list), to: :lists\n"
"      defdelegate [reverse(list), map(callback, list)], to: :lists\n"
"      defdelegate other_reverse(list), to: :lists, as: :reverse\n"
"    end\n"
"\n"
"    MyList.reverse([1, 2, 3])\n"
"    #=> [3,2,1]\n"
"\n"
"    MyList.other_reverse([1, 2, 3])\n"
"    #=> [3,2,1]\n"
"\n"
msgstr ""
"与えられた`target`へ移譲する、\n"
"現在のモジュールで与えられた関数を\n"
"定義します。\n"
"`defdelegate`で定義された関数は、\n"
"パブリックで、外部から起動することができます。\n"
"もしプライベートとして移譲を定義したいと\n"
"思うなら、importを代りに使うべきです。\n"
"\n"
"移譲は関数でのみ動きます。マクロの移譲はサポートしていません。\n"
"\n"
"## オプション\n"
"\n"
"  * `:to` -  移譲先の式。\n"
"    任意の式が許され、戻値は実行時に計算されます。\n"
"\n"
"  * `:as` -  `:to`で与えられたターゲットを呼ぶ関数です。\n"
"    このパラメタはオプションで、デフォルトは移譲された名前です。\n"
"\n"
"  * `:append_first` -  trueなら、移譲されたとき、\n"
"    移譲先へ渡す最初の引数は、ターゲットへディスパッチするときに\n"
"    引数の最後に再配置されます。\n"
"\n"
"    この背後の動機は、\n"
"    Elixirは最初の引数として、\n"
"    いくつかのErlangモジュールが最後の\n"
"    引数として期待している\"handle\"を、正規化するからです。\n"
"\n"
"## 例\n"
"\n"
"    defmodule MyList do\n"
"      defdelegate reverse(list), to: :lists\n"
"      defdelegate [reverse(list), map(callback, list)], to: :lists\n"
"      defdelegate other_reverse(list), to: :lists, as: :reverse\n"
"    end\n"
"\n"
"    MyList.reverse([1, 2, 3])\n"
"    #=> [3,2,1]\n"
"\n"
"    MyList.other_reverse([1, 2, 3])\n"
"    #=> [3,2,1]\n"
"\n"

#. TRANSLATORS: defmacro Kernel.sigil_w(arg1, modifiers)
#: lib/kernel.ex:3473
msgid ""
"Handles the sigil ~w. It returns a list of \"words\" split by whitespace.\n"
"\n"
"## Modifiers\n"
"\n"
"  * `s`: strings (default)\n"
"  * `a`: atoms\n"
"  * `c`: char lists\n"
"\n"
"## Examples\n"
"\n"
"    iex> ~w(foo #{:bar} baz)\n"
"    [\"foo\", \"bar\", \"baz\"]\n"
"\n"
"    iex> ~w(--source test/enum_test.exs)\n"
"    [\"--source\", \"test/enum_test.exs\"]\n"
"\n"
"    iex> ~w(foo bar baz)a\n"
"    [:foo, :bar, :baz]\n"
"\n"
msgstr ""
"sigil ~wをハンドルします。空白によって区切られた\"words\"のリストを返しま"
"す。\n"
"\n"
"## モディファイア\n"
"\n"
"  * `s`: 文字列 (デフォルト)\n"
"  * `a`: アトム\n"
"  * `c`: 文字のリスト\n"
"\n"
"## 例\n"
"\n"
"    iex> ~w(foo #{:bar} baz)\n"
"    [\"foo\", \"bar\", \"baz\"]\n"
"\n"
"    iex> ~w(--source test/enum_test.exs)\n"
"    [\"--source\", \"test/enum_test.exs\"]\n"
"\n"
"    iex> ~w(foo bar baz)a\n"
"    [:foo, :bar, :baz]\n"
"\n"

#. TRANSLATORS: defmacro Kernel.sigil_s(arg1, list2)
#: lib/kernel.ex:3367
msgid ""
"Handles the sigil ~s. It returns a string as if it was double quoted\n"
"string, unescaping characters and replacing interpolations.\n"
"\n"
"## Examples\n"
"\n"
"    iex> ~s(foo)\n"
"    \"foo\"\n"
"\n"
"    iex> ~s(f#{:o}o)\n"
"    \"foo\"\n"
"\n"
"    iex> ~s(f\\#{:o}o)\n"
"    \"f\\#{:o}o\"\n"
"\n"
msgstr ""
"sigil ~sをハンドルします。\n"
"まるで二重引用苻付きの文字列であるかのように、文字列を\n"
"返します。そして文字のアンエスケープと、内挿の置き換えをします。\n"
"\n"
"## 例\n"
"\n"
"    iex> ~s(foo)\n"
"    \"foo\"\n"
"\n"
"    iex> ~s(f#{:o}o)\n"
"    \"foo\"\n"
"\n"
"    iex> ~s(f\\#{:o}o)\n"
"    \"f\\#{:o}o\"\n"
"\n"

#. TRANSLATORS: defmacro Kernel.sigil_r(arg1, options)
#: lib/kernel.ex:3425
msgid ""
"Handles the sigil ~r. It returns a Regex pattern.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.match?(~r(foo), \"foo\")\n"
"    true\n"
"\n"
msgstr ""
"sigil ~rをハンドルします。\n"
"Regexパターンを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Regex.match?(~r(foo), \"foo\")\n"
"    true\n"
"\n"

#. TRANSLATORS: defmacro Kernel.sigil_c(arg1, list2)
#: lib/kernel.ex:3407
msgid ""
"Handles the sigil ~c. It returns a char list as if it were a single\n"
"quoted string, unescaping characters and replacing interpolations.\n"
"\n"
"## Examples\n"
"\n"
"    iex> ~c(foo)\n"
"    'foo'\n"
"\n"
"    iex> ~c(f#{:o}o)\n"
"    'foo'\n"
"\n"
"    iex> ~c(f\\#{:o}o)\n"
"    'f\\#{:o}o'\n"
"\n"
msgstr ""
"sigil ~cをハンドルします。\n"
"まるで一重引用苻付きの文字列であるかのように、文字のリストを\n"
"返します。そして文字のアンエスケープと、内挿の置き換えをします。\n"
"\n"
"## 例\n"
"\n"
"    iex> ~c(foo)\n"
"    'foo'\n"
"\n"
"    iex> ~c(f#{:o}o)\n"
"    'foo'\n"
"\n"
"    iex> ~c(f\\#{:o}o)\n"
"    'f\\#{:o}o'\n"
"\n"

#. TRANSLATORS: defmacro Kernel.sigil_W(arg1, modifiers)
#: lib/kernel.ex:3498
msgid ""
"Handles the sigil ~W. It returns a list of \"words\" split by whitespace\n"
"without escaping nor interpreting interpolations.\n"
"\n"
"## Modifiers\n"
"\n"
"  * `s`: strings (default)\n"
"  * `a`: atoms\n"
"  * `c`: char lists\n"
"\n"
"## Examples\n"
"\n"
"    iex> ~W(foo #{bar} baz)\n"
"    [\"foo\", \"\\#{bar}\", \"baz\"]\n"
"\n"
msgstr ""
"sigil ~Wをハンドルします。エスケープも内挿の解釈もすることなく、空白に\n"
"よって区切られた\"words\"のリストを返します。\n"
"\n"
"## モディファイア\n"
"\n"
"  * `s`: 文字列 (デフォルト)\n"
"  * `a`: アトム\n"
"  * `c`: 文字のリスト\n"
"\n"
"## 例\n"
"\n"
"    iex> ~W(foo #{bar} baz)\n"
"    [\"foo\", \"\\#{bar}\", \"baz\"]\n"
"\n"

#. TRANSLATORS: defmacro Kernel.sigil_S(string, list2)
#: lib/kernel.ex:3347
msgid ""
"Handles the sigil ~S. It simply returns a string\n"
"without escaping characters and without interpolations.\n"
"\n"
"## Examples\n"
"\n"
"    iex> ~S(foo)\n"
"    \"foo\"\n"
"\n"
"    iex> ~S(f#{o}o)\n"
"    \"f\\#{o}o\"\n"
"\n"
msgstr ""
"sigil ~Sをハンドルします。エスケープも内挿の解釈もすることなく、単に文\n"
"字列を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> ~S(foo)\n"
"    \"foo\"\n"
"\n"
"    iex> ~S(f#{o}o)\n"
"    \"f\\#{o}o\"\n"
"\n"

#. TRANSLATORS: defmacro Kernel.sigil_R(arg1, options)
#: lib/kernel.ex:3446
msgid ""
"Handles the sigil ~R. It returns a Regex pattern without escaping\n"
"nor interpreting interpolations.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.match?(~R(f#{1,3}o), \"f#o\")\n"
"    true\n"
"\n"
msgstr ""
"sigil ~Rをハンドルします。エスケープも内挿の解釈もすることなく、Regexパ\n"
"ターンを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Regex.match?(~R(f#{1,3}o), \"f#o\")\n"
"    true\n"
"\n"

#. TRANSLATORS: defmacro Kernel.sigil_C(arg1, list2)
#: lib/kernel.ex:3384
msgid ""
"Handles the sigil ~C. It simply returns a char list\n"
"without escaping characters and without interpolations.\n"
"\n"
"## Examples\n"
"\n"
"    iex> ~C(foo)\n"
"    'foo'\n"
"\n"
"    iex> ~C(f#{o}o)\n"
"    'f\\#{o}o'\n"
"\n"
msgstr ""
"sigil ~Cをハンドルします。エスケープも内挿の解釈もすることなく、単に\n"
"文字のリストを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> ~C(foo)\n"
"    'foo'\n"
"\n"
"    iex> ~C(f#{o}o)\n"
"    'f\\#{o}o'\n"
"\n"

#. TRANSLATORS: defmacro Kernel.defimpl(name, opts, do_block \\ [])
#: lib/kernel.ex:3172
msgid ""
"Defines an implementation for the given protocol. See\n"
"`defprotocol/2` for examples.\n"
"\n"
"Inside an implementation, the name of the protocol can be accessed\n"
"via `@protocol` and the current target as `@for`.\n"
msgstr ""
"与えられたプロトコルの実装を定義します。\n"
"例は`defprotocol/2`を参照してください。\n"
"\n"
"実装の中で、プロトコルの名前は`@protocol`でアクセスでき、\n"
"現在のターゲットは`@for`でアクセスできます。\n"

#. TRANSLATORS: defmacro Kernel.defexception(fields)
#: lib/kernel.ex:2985
msgid ""
"Defines an exception.\n"
"\n"
"Exceptions are structs backed by a module that implements\n"
"the Exception behaviour. The Exception behaviour requires\n"
"two functions to be implemented:\n"
"\n"
"  * `exception/1` - that receives the arguments given to `raise/2`\n"
"     and returns the exception struct. The default implementation\n"
"     accepts a set of keyword arguments that is merged into the\n"
"     struct.\n"
"\n"
"  * `message/1` - receives the exception struct and must return its\n"
"    message. Most commonly exceptions have a message field which\n"
"    by default is accessed by this function. However, if your exception\n"
"    does not have a message field, this function must be explicitly\n"
"    implemented.\n"
"\n"
"Since exceptions are structs, all the API supported by `defstruct/1`\n"
"is also available in `defexception/1`.\n"
"\n"
"## Raising exceptions\n"
"\n"
"The most common way to raise an exception is via the `raise/2`\n"
"function:\n"
"\n"
"    defmodule MyAppError do\n"
"      defexception [:message]\n"
"    end\n"
"\n"
"    value = [:hello]\n"
"\n"
"    raise MyAppError,\n"
"      message: \"did not get what was expected, got: #{inspect value}\"\n"
"\n"
"In many cases it is more convenient to pass the expected value to\n"
"`raise` and generate the message in the `exception/1` callback:\n"
"\n"
"    defmodule MyAppError do\n"
"      defexception [:message]\n"
"\n"
"      def exception(value) do\n"
"        msg = \"did not get what was expected, got: #{inspect value}\"\n"
"        %MyAppError{message: msg}\n"
"      end\n"
"    end\n"
"\n"
"    raise MyAppError, value\n"
"\n"
"The example above is the preferred mechanism for customizing\n"
"exception messages.\n"
msgstr ""
"例外を定義します。\n"
"\n"
"例外は、Exceptionビヘイビアを実装するモジュールで支持される、\n"
"構造体です。\n"
"Exceptionビヘイビアは二つの関数の実装を要求します:\n"
"\n"
"  * `exception/1` -  `raise/2`へ与えられる引数を受けて、\n"
"     例外構造体を返します。デフォルト実装は、構造体に\n"
"     合併される、一組のキーワード引数を受け入れます。\n"
"\n"
"  * `message/1` -  例外構造体を受けて、そのメッセージを\n"
"     返さなければなりません。最も一般的な例外は、\n"
"     この関数によってデフォルトでアクセスされるメッセージ\n"
"     フィールドを持ちます。しかしながら、\n"
"     例外がメッセージフィールドを持っていないなら、\n"
"     この関数は明示的に実装されなければなりません。\n"
"\n"
"例外は構造体なので、`defstruct/1`によりサポートされる\n"
"全てのAPIもまた`defexception/1`で有効です。\n"
"\n"
"## Raising exceptions\n"
"\n"
"例外を上げる最も一般的な方法は、`raise/2`関数によってです:\n"
"\n"
"    defmodule MyAppError do\n"
"      defexception [:message]\n"
"    end\n"
"\n"
"    value = [:hello]\n"
"\n"
"    raise MyAppError,\n"
"      message: \"did not get what was expected, got: #{inspect value}\"\n"
"\n"
"多くの場合、`raise`に期待される値を渡し、\n"
"`exception/1`コールバックにおいてメッセージを生成することは、\n"
"より便利です:\n"
"\n"
"    defmodule MyAppError do\n"
"      defexception [:message]\n"
"\n"
"      def exception(value) do\n"
"        msg = \"did not get what was expected, got: #{inspect value}\"\n"
"        %MyAppError{message: msg}\n"
"      end\n"
"    end\n"
"\n"
"    raise MyAppError, value\n"
"\n"
"上の例は、例外メッセージをカスタマイズするための好ましいメカニズムです。\n"

#. TRANSLATORS: defmacro Kernel.defstruct(fields)
#: lib/kernel.ex:2899
msgid ""
"Defines a struct for the current module.\n"
"\n"
"A struct is a tagged map that allows developers to provide\n"
"default values for keys, tags to be used in polymorphic\n"
"dispatches and compile time assertions.\n"
"\n"
"To define a struct, a developer needs to only define\n"
"a function named `__struct__/0` that returns a map with the\n"
"structs field. This macro is a convenience for defining such\n"
"function, with the addition of a type `t` and deriving\n"
"conveniences.\n"
"\n"
"For more information about structs, please check\n"
"`Kernel.SpecialForms.%/2`.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule User do\n"
"      defstruct name: nil, age: nil\n"
"    end\n"
"\n"
"Struct fields are evaluated at definition time, which allows\n"
"them to be dynamic. In the example below, `10 + 11` will be\n"
"evaluated at compilation time and the age field will be stored\n"
"with value `21`:\n"
"\n"
"    defmodule User do\n"
"      defstruct name: nil, age: 10 + 11\n"
"    end\n"
"\n"
"## Deriving\n"
"\n"
"Although structs are maps, by default structs do not implement\n"
"any of the protocols implemented for maps. For example, if you\n"
"attempt to use the access protocol with the User struct, it\n"
"will lead to an error:\n"
"\n"
"    %User{}[:age]\n"
"    ** (Protocol.UndefinedError) protocol Access not implemented for "
"%User{...}\n"
"\n"
"However, `defstruct/1` allows implementation for protocols to\n"
"derived by defining a `@derive` attribute as a list before `defstruct/1`\n"
"is invoked:\n"
"\n"
"    defmodule User do\n"
"      @derive [Access]\n"
"      defstruct name: nil, age: 10 + 11\n"
"    end\n"
"\n"
"    %User{}[:age] #=> 21\n"
"\n"
"For each protocol given to `@derive`, Elixir will assert there is an\n"
"implementation of that protocol for maps and check if the map\n"
"implementation defines a `__deriving__/3` callback. If so, the callback\n"
"is invoked, otherwise an implementation that simply points to the map\n"
"one is automatically derived.\n"
"\n"
"## Types\n"
"\n"
"It is recommended to define types for structs, by convention this type\n"
"is called `t`. To define a struct in a type the struct literal syntax\n"
"is used:\n"
"\n"
"    defmodule User do\n"
"      defstruct name: \"john\", age: 25\n"
"      @type t :: %User{name: String.t, age: integer}\n"
"    end\n"
"\n"
"It is recommended to only use the struct syntax when defining the struct's\n"
"type. When referring to another struct use `User.t`, not `%User{}`. Fields\n"
"in the struct not included in the type defaults to `term`.\n"
"\n"
"Private structs that are not used outside its module should use the private\n"
"type attribute `@typep`. Public structs whose internal structure is private\n"
"to the local module (you are not allowed to pattern match it or directly\n"
"access fields) should use the `@opaque` attribute. Structs whose internal\n"
"structure is public should use `@type`.\n"
msgstr ""
"現在のモジュールに構造体を定義します。\n"
"\n"
"構造体はタグ付けされたマップです。それは、開発者に、\n"
"キーにデフォルト値と、ポリモーフィックディスパッチに\n"
"使われるタグ、そしてコンパイル時のアサーションを提供します。\n"
"\n"
"構造体を定義するために、開発者は構造体のフィールドを\n"
"マップで返す、`__struct__/0`という名前の関数を定義する\n"
"ことだけが必要です。このマクロは、その関数の定義に便利で、\n"
"タイプ`t`と派生する便利さを追加します。\n"
"\n"
"構造体についての詳細は、`Kernel.SpecialForms.%/2`\n"
"をチェックしてください。\n"
"\n"
"## 例\n"
"\n"
"    defmodule User do\n"
"      defstruct name: nil, age: nil\n"
"    end\n"
"\n"
"構造体のフィールドは定義時に評価されます。そしてそれは\n"
"動的であることを許します。下の例では、`10 + 11`はコンパイル時に\n"
"評価され、ageフィールドは値`21`が格納されます:\n"
"\n"
"    defmodule User do\n"
"      defstruct name: nil, age: 10 + 11\n"
"    end\n"
"\n"
"## Deriving\n"
"\n"
"構造体はマップですが、デフォルトでは、構造体はマップが\n"
"実装しているプロトコルをなにも実装していません。例えば、\n"
"User構造体でAccessプロトコルを使おうとすると、エラーに\n"
"なります:\n"
"\n"
"    %User{}[:age]\n"
"    ** (Protocol.UndefinedError) protocol Access not implemented for "
"%User{...}\n"
"\n"
"しかしながら、`defstruct/1`は\n"
"`defstruct/1`が起動される前にリストとして`@derive`属性を\n"
"定義することで、それに由来するプロトコルを実装を許します:\n"
"\n"
"    defmodule User do\n"
"      @derive [Access]\n"
"      defstruct name: nil, age: 10 + 11\n"
"    end\n"
"\n"
"    %User{}[:age] #=> 21\n"
"\n"
"`@derive`に与えられるそれぞれのプロトコル毎に、Elixirは\n"
"それがマップのためのプロトコルであると主張して、\n"
"マップ実装が`__deriving__/3`コールバックを定義しているかどうかを\n"
"チェックします。\n"
"もしそうならコールバックは起動され、さもなければ、単にマップの\n"
"実装が、自動的に引き出されます。\n"
"\n"
"## Types\n"
"\n"
"構造体のタイプを定義することが推奨され、慣例により、このタイプは`t`と呼\n"
"ばれます。構造体のタイプを定義するために、構造体リテラル構文が\n"
"使われます:\n"
"\n"
"    defmodule User do\n"
"      defstruct name: \"john\", age: 25\n"
"      @type t :: %User{name: String.t, age: integer}\n"
"    end\n"
"\n"
"構造体タイプを定義するときに、構造構文を使うことだけが推奨されています。\n"
"他の構造体を参照する時は、`%User{}`ではなく、`User.t`を使ってください。\n"
"タイプを含まない構造体のフィールドはデフォルトの`term`になります。\n"
"\n"
"そのモジュールの外で使われないプライベートな構造体は、\n"
"プライベートタイプ属性`@typep`を使うべきです。\n"
"パターンマッチや、直接フィールドへのアクセスを許さない、ローカル\n"
"モジュールに内部構造がプライベートであるパブリック構造体は、\n"
"`@opaque`属性を使うべきです。\n"
"内部構造がパブリックである構造体は`@type`を使うべきです。\n"

#. TRANSLATORS: def Kernel.struct(struct, kv \\ [])
#: lib/kernel.ex:1489
msgid ""
"Creates and updates structs.\n"
"\n"
"The struct argument may be an atom (which defines `defstruct`)\n"
"or a struct itself. The second argument is any Enumerable that\n"
"emits two-item tuples (key-value) during enumeration.\n"
"\n"
"If one of the keys in the Enumerable does not exist in the struct,\n"
"they are automatically discarded.\n"
"\n"
"This function is useful for dynamically creating and updating\n"
"structs.\n"
"\n"
"## Example\n"
"\n"
"    defmodule User do\n"
"      defstruct name: \"john\"\n"
"    end\n"
"\n"
"    struct(User)\n"
"    #=> %User{name: \"john\"}\n"
"\n"
"    opts = [name: \"meg\"]\n"
"    user = struct(User, opts)\n"
"    #=> %User{name: \"meg\"}\n"
"\n"
"    struct(user, unknown: \"value\")\n"
"    #=> %User{name: \"meg\"}\n"
"\n"
msgstr ""
"構造体を作成し、更新します。\n"
"\n"
"struct引数は(`defstruct`で定義された)アトムか、構造体自身です。\n"
"2番目の引数は、列挙のあいだ任意の2アイテムのタプル(キーバリュー)を\n"
"発するEnumerableです。\n"
"\n"
"Enumerableの中のキーの一つが構造体に存在しないなら、それは自動的に\n"
"捨てられます。\n"
"\n"
"この関数は動的に構造体を作成し、更新するのに便利です。\n"
"\n"
"## 例\n"
"\n"
"    defmodule User do\n"
"      defstruct name: \"john\"\n"
"    end\n"
"\n"
"    struct(User)\n"
"    #=> %User{name: \"john\"}\n"
"\n"
"    opts = [name: \"meg\"]\n"
"    user = struct(User, opts)\n"
"    #=> %User{name: \"meg\"}\n"
"\n"
"    struct(user, unknown: \"value\")\n"
"    #=> %User{name: \"meg\"}\n"
"\n"

#. TRANSLATORS: def Kernel.++(left, right)
#: lib/kernel.ex:864
msgid ""
"Concatenates two lists.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> [1] ++ [2, 3]\n"
"    [1,2,3]\n"
"\n"
"    iex> 'foo' ++ 'bar'\n"
"    'foobar'\n"
"\n"
msgstr ""
"二つのリストを連結します。\n"
"\n"
"ガードテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> [1] ++ [2, 3]\n"
"    [1,2,3]\n"
"\n"
"    iex> 'foo' ++ 'bar'\n"
"    'foobar'\n"
"\n"

#. TRANSLATORS: defmacro Kernel.<>(left, right)
#: lib/kernel.ex:1188
msgid ""
"Concatenates two binaries.\n"
"\n"
"## Examples\n"
"\n"
"    iex> \"foo\" <> \"bar\"\n"
"    \"foobar\"\n"
"\n"
"The `<>` operator can also be used in guard clauses as\n"
"long as the first part is a literal binary:\n"
"\n"
"    iex> \"foo\" <> x = \"foobar\"\n"
"    iex> x\n"
"    \"bar\"\n"
"\n"
msgstr ""
"二つのバイナリを連結します。\n"
"\n"
"## 例\n"
"\n"
"    iex> \"foo\" <> \"bar\"\n"
"    \"foobar\"\n"
"\n"
"`<>`演算子は最初の部分がリテラルバイナリである限り、\n"
"ガード節で使うこともできます:\n"
"\n"
"    iex> \"foo\" <> x = \"foobar\"\n"
"    iex> x\n"
"    \"bar\"\n"
"\n"

#. TRANSLATORS: def Kernel.rem(left, right)
#: lib/kernel.ex:526
msgid ""
"Calculates the remainder of an integer division.\n"
"\n"
"Raises an error if one of the arguments is not an integer.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> rem(5, 2)\n"
"    1\n"
"\n"
msgstr ""
"整数で割った余りを計算します。\n"
"\n"
"引数の一つが整数でないなら、エラーを上げます。\n"
"\n"
"ガードテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> rem(5, 2)\n"
"    1\n"
"\n"

#. TRANSLATORS: defmacro Kernel.in(left, right)
#: lib/kernel.ex:2441
msgid ""
"Checks if the element on the left side is member of the\n"
"collection on the right side.\n"
"\n"
"## Examples\n"
"\n"
"    iex> x = 1\n"
"    iex> x in [1, 2, 3]\n"
"    true\n"
"\n"
"This macro simply translates the expression above to:\n"
"\n"
"    Enum.member?([1,2,3], x)\n"
"\n"
"## Guards\n"
"\n"
"The `in` operator can be used on guard clauses as long as the\n"
"right side is a range or a list. Elixir will then expand the\n"
"operator to a valid guard expression. For example:\n"
"\n"
"    when x in [1,2,3]\n"
"\n"
"Translates to:\n"
"\n"
"    when x === 1 or x === 2 or x === 3\n"
"\n"
"When using ranges:\n"
"\n"
"    when x in 1..3\n"
"\n"
"Translates to:\n"
"\n"
"    when x >= 1 and x <= 3\n"
"\n"
msgstr ""
"左辺の要素が、右辺のコレクションのメンバであるかを\n"
"チェックします。\n"
"\n"
"## 例\n"
"\n"
"    iex> x = 1\n"
"    iex> x in [1, 2, 3]\n"
"    true\n"
"\n"
"このマクロは、単に上の式を以下に展開します:\n"
"\n"
"    Enum.member?([1,2,3], x)\n"
"\n"
"## ガード\n"
"\n"
"`in`オペレータは、右辺が範囲(range)かリストであるかぎり、\n"
"ガード節で使うことができます。Elixirはそのオペレータを\n"
"有効なガード式に展開します。例えば:\n"
"\n"
"    when x in [1,2,3]\n"
"\n"
"は以下のように展開します:\n"
"\n"
"    when x === 1 or x === 2 or x === 3\n"
"\n"
"範囲(range)を使うとき:\n"
"\n"
"    when x in 1..3\n"
"\n"
"は以下のように展開します:\n"
"\n"
"    when x >= 1 and x <= 3\n"
"\n"

#. TRANSLATORS: defmacro Kernel.or(left, right)
#: lib/kernel.ex:1118
msgid ""
"Boolean or. Requires only the first argument to be a\n"
"boolean since it short-circuits.\n"
"\n"
"Allowed in guard tests.\n"
"\n"
"## Examples\n"
"\n"
"    iex> true or false\n"
"    true\n"
"\n"
msgstr ""
"ブール代数のor です。ショートサーキットなので、\n"
"booleanであることを最初の引数だけに要求します。\n"
"\n"
"ガードテストで使えます。\n"
"\n"
"## 例\n"
"\n"
"    iex> true or false\n"
"    true\n"
"\n"

#. TRANSLATORS: def Kernel.not(arg)
#: lib/kernel.ex:900
msgid ""
"Boolean not. Argument must be a boolean.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> not false\n"
"    true\n"
"\n"
msgstr ""
"ブール代数のnot です。引数はbooleanでなくてはなりません。\n"
"\n"
"ガードテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> not false\n"
"    true\n"
"\n"

#. TRANSLATORS: defmacro Kernel.and(left, right)
#: lib/kernel.ex:1134
msgid ""
"Boolean and. Requires only the first argument to be a\n"
"boolean since it short-circuits.\n"
"\n"
"Allowed in guard tests.\n"
"\n"
"## Examples\n"
"\n"
"    iex> true and false\n"
"    false\n"
"\n"
msgstr ""
"ブール代数のand です。ショートサーキットなので、\n"
"booleanであることを最初の引数だけに要求します。\n"
"\n"
"ガードテストで使えます。\n"
"\n"
"## 例\n"
"\n"
"    iex> true and false\n"
"    false\n"
"\n"

#. TRANSLATORS: defmacro Kernel...(first, last)
#: lib/kernel.ex:2251
msgid ""
"Returns a range with the specified start and end.\n"
"Includes both ends.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 0 in 1..3\n"
"    false\n"
"\n"
"    iex> 1 in 1..3\n"
"    true\n"
"\n"
"    iex> 2 in 1..3\n"
"    true\n"
"\n"
"    iex> 3 in 1..3\n"
"    true\n"
"\n"
msgstr ""
"指定された始まりと終わりの範囲を返します。\n"
"両端を含みます。\n"
"\n"
"## 例\n"
"\n"
"    iex> 0 in 1..3\n"
"    false\n"
"\n"
"    iex> 1 in 1..3\n"
"    true\n"
"\n"
"    iex> 2 in 1..3\n"
"    true\n"
"\n"
"    iex> 3 in 1..3\n"
"    true\n"
"\n"

#. TRANSLATORS: def Kernel.+(value)
#: lib/kernel.ex:791
msgid ""
"Arithmetic unary plus.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> +1\n"
"    1\n"
"\n"
msgstr ""
"算術的単項プラスです。\n"
"\n"
"ガードテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> +1\n"
"    1\n"
"\n"

#. TRANSLATORS: def Kernel.-(value)
#: lib/kernel.ex:807
msgid ""
"Arithmetic unary minus.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> -2\n"
"    -2\n"
"\n"
msgstr ""
"算術的単項マイナスです。\n"
"\n"
"ガードテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> -2\n"
"    -2\n"
"\n"

#. TRANSLATORS: def Kernel.+(left, right)
#: lib/kernel.ex:759
msgid ""
"Arithmetic plus.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 + 2\n"
"    3\n"
"\n"
msgstr ""
"算術的加算です。\n"
"\n"
"ガードテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> 1 + 2\n"
"    3\n"
"\n"

#. TRANSLATORS: def Kernel.*(left, right)
#: lib/kernel.ex:823
msgid ""
"Arithmetic multiplication.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 * 2\n"
"    2\n"
"\n"
msgstr ""
"算術的乗算です。\n"
"\n"
"ガードテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> 1 * 2\n"
"    2\n"
"\n"

#. TRANSLATORS: def Kernel.-(left, right)
#: lib/kernel.ex:775
msgid ""
"Arithmetic minus.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 - 2\n"
"    -1\n"
"\n"
msgstr ""
"算術的減算です。\n"
"\n"
"ガードテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> 1 - 2\n"
"    -1\n"
"\n"

#. TRANSLATORS: def Kernel./(left, right)
#: lib/kernel.ex:845
msgid ""
"Arithmetic division.\n"
"\n"
"The result is always a float. Use `div` and `rem` if you want\n"
"a natural division or the remainder.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 / 2\n"
"    0.5\n"
"\n"
"    iex> 2 / 1\n"
"    2.0\n"
"\n"
msgstr ""
"算術的除算です。\n"
"\n"
"結果は常に浮動小数点数です。自然数の除算と余りには、\n"
"`div`と`rem`を使ってください。\n"
"\n"
"ガードテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> 1 / 2\n"
"    0.5\n"
"\n"
"    iex> 2 / 1\n"
"    2.0\n"
"\n"

#. TRANSLATORS: def Kernel.byte_size(binary)
#: lib/kernel.ex:154
msgid ""
"Returns the number of bytes needed to contain `bitstring`.\n"
"\n"
"That is, if the number of bits in `bitstring` is not divisible by 8,\n"
"the resulting number of bytes will be rounded up. This operation\n"
"happens in constant time.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> byte_size(<<433::16, 3::3>>)\n"
"    3\n"
"\n"
"    iex> byte_size(<<1, 2, 3>>)\n"
"    3\n"
"\n"
msgstr ""
"`bitstring`を格納するために必要なバイト数を返します。\n"
"\n"
"これは、もし`bitstring`のbit数が8で割り切れない場合、結果として生じるバ\n"
"イト数は切り上げられます。このオペレーションは定数時間で実行されます。\n"
"\n"
"ガード中でテストに使うことができます。コンパイラによってインライン化さ\n"
"れます。\n"
"\n"
"## 例\n"
"\n"
"    iex> byte_size(<<433::16, 3::3>>)\n"
"    3\n"
"\n"
"    iex> byte_size(<<1, 2, 3>>)\n"
"    3\n"
"\n"

#. TRANSLATORS: def Kernel.send(dest, msg)
#: lib/kernel.ex:562
msgid ""
"Sends a message to the given `dest` and returns the message.\n"
"\n"
"`dest` may be a remote or local pid, a (local) port, a locally\n"
"registered name, or a tuple `{registered_name, node}` for a registered\n"
"name at another node.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> send self(), :hello\n"
"    :hello\n"
"\n"
msgstr ""
"与えられた`dest`へメッセージを送信し、そのメッセージを返します。\n"
"\n"
"`dest`はリモートまたはローカルのpid、(ローカル)ポート、ローカルレジスター\n"
"された名前もしくは他のノードで登録された名前のタプル`{registered_name,\n"
"node}`です。\n"
"\n"
"コンパイラにより、インライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> send self(), :hello\n"
"    :hello\n"
"\n"

#. TRANSLATORS: def Kernel.length(list)
#: lib/kernel.ex:419
msgid ""
"Returns the length of `list`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> length([1, 2, 3, 4, 5, 6, 7, 8, 9])\n"
"    9\n"
"\n"
msgstr ""
"`list`の長さを返します。\n"
"\n"
"ガード中のテストに使うことができます。コンパイラによりインライン化され\n"
"ます。\n"
"\n"
"## 例\n"
"\n"
"    iex> length([1, 2, 3, 4, 5, 6, 7, 8, 9])\n"
"    9\n"
"\n"

#. TRANSLATORS: def Kernel.hd(list)
#: lib/kernel.ex:248
msgid ""
"Returns the head of a list, raises `badarg` if the list is empty.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"リストの先頭(ヘッド)を返します。もしリストが空なら`badarg`を上げます。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: defmacro Kernel.binding(context \\ nil)
#: lib/kernel.ex:2100
msgid ""
"Returns the binding for the given context as a keyword list.\n"
"\n"
"The variable name is the key and the variable value is the value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> x = 1\n"
"    iex> binding()\n"
"    [x: 1]\n"
"    iex> x = 2\n"
"    iex> binding()\n"
"    [x: 2]\n"
"\n"
"    iex> binding(:foo)\n"
"    []\n"
"    iex> var!(x, :foo) = 1\n"
"    1\n"
"    iex> binding(:foo)\n"
"    [x: 1]\n"
"\n"
msgstr ""
"キーワードリストとして与えられたコンテキストのバインディングを\n"
"返します。\n"
"\n"
"変数名はキーでその変数の値がバリューになります。\n"
"\n"
"## 例\n"
"\n"
"    iex> x = 1\n"
"    iex> binding()\n"
"    [x: 1]\n"
"    iex> x = 2\n"
"    iex> binding()\n"
"    [x: 2]\n"
"\n"
"    iex> binding(:foo)\n"
"    []\n"
"    iex> var!(x, :foo) = 1\n"
"    1\n"
"    iex> binding(:foo)\n"
"    [x: 1]\n"
"\n"

#. TRANSLATORS: def Kernel.max(first, second)
#: lib/kernel.ex:467
msgid ""
"Returns the biggest of the two given terms according to\n"
"Erlang's term ordering. If the terms compare equal, the\n"
"first one is returned.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> max(1, 2)\n"
"    2\n"
"\n"
msgstr ""
"与えられた二つのtermのうち、Erlangのtermの順序について、大きいほうを\n"
"返します。termが等しいなら、firstを返します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> max(1, 2)\n"
"    2\n"
"\n"

#. TRANSLATORS: def Kernel.node(arg)
#: lib/kernel.ex:508
msgid ""
"Returns the node where the given argument is located.\n"
"The argument can be a pid, a reference, or a port.\n"
"If the local node is not alive, `nonode@nohost` is returned.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"与えられた引数の場所のノードを返します。\n"
"引数はpid、リファレンス、又はポートです。\n"
"ローカルノードが生きていなければ、`nonode@nohost`が返ります。\n"
"\n"
"ガードテストに使えます。\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: defmacro Kernel.destructure(left, right)
#: lib/kernel.ex:2217
msgid ""
"Allows you to destructure two lists, assigning each term in the right to "
"the\n"
"matching term in the left. Unlike pattern matching via `=`, if the sizes of\n"
"the left and right lists don't match, destructuring simply stops instead of\n"
"raising an error.\n"
"\n"
"## Examples\n"
"\n"
"    iex> destructure([x, y, z], [1, 2, 3, 4, 5])\n"
"    iex> {x, y, z}\n"
"    {1, 2, 3}\n"
"\n"
"Notice in the example above, even though the right\n"
"size has more entries than the left, destructuring works\n"
"fine. If the right size is smaller, the remaining items\n"
"are simply assigned to nil:\n"
"\n"
"    iex> destructure([x, y, z], [1])\n"
"    iex> {x, y, z}\n"
"    {1, nil, nil}\n"
"\n"
"The left side supports any expression you would use\n"
"on the left side of a match:\n"
"\n"
"    x = 1\n"
"    destructure([^x, y, z], [1, 2, 3])\n"
"\n"
"The example above will only work if x matches\n"
"the first value from the right side. Otherwise,\n"
"it will raise a CaseClauseError.\n"
msgstr ""
"二つのリストを非構造化することを許し、\n"
"右のそれぞれのtermを左にマッチングするtermに代入します。\n"
"`=`によるパターンマッチングと違って、右と左のリストの大きさが\n"
"一致していなくても、エラーを上げるかわりに\n"
"処理を単に停止します。\n"
"\n"
"## 例\n"
"\n"
"    iex> destructure([x, y, z], [1, 2, 3, 4, 5])\n"
"    iex> {x, y, z}\n"
"    {1, 2, 3}\n"
"\n"
"上の例で、左より右のサイズが大きいにも拘わらず、\n"
"destructureは正しく動くことに注意してください。\n"
"もし右の大きさが小さいなら、残ったアイテムは単に\n"
"nilが代入されます:\n"
"\n"
"    iex> destructure([x, y, z], [1])\n"
"    iex> {x, y, z}\n"
"    {1, nil, nil}\n"
"\n"
"左側は、マッチの左辺で使うことができる、\n"
"任意の式をサポートします:\n"
"\n"
"    x = 1\n"
"    destructure([^x, y, z], [1, 2, 3])\n"
"\n"
"上の例は x が右側からの最初の値とマッチする場合のみ\n"
"動作します。さもなければCaseClauseErrorを上げます。\n"

#. TRANSLATORS: defmacro Kernel.to_string(arg)
#: lib/kernel.ex:1861
msgid ""
"Converts the argument to a string according to the\n"
"`String.Chars` protocol.\n"
"\n"
"This is the function invoked when there is string interpolation.\n"
"\n"
"## Examples\n"
"\n"
"    iex> to_string(:foo)\n"
"    \"foo\"\n"
"\n"
msgstr ""
"`String.Chars`プロトコルに従って、引数を文字列に変換します。\n"
"\n"
"これは、文字列展開がある時、起動される関数です。\n"
"\n"
"## 例\n"
"\n"
"    iex> to_string(:foo)\n"
"    \"foo\"\n"
"\n"

#. TRANSLATORS: defmacro Kernel.to_char_list(arg)
#: lib/kernel.ex:1876
msgid ""
"Converts the argument to a list according to the List.Chars protocol.\n"
"\n"
"## Examples\n"
"\n"
"    iex> to_char_list(:foo)\n"
"    'foo'\n"
"\n"
msgstr ""
"引数をList.Charsプロトコルに従って、リストに変換します。\n"
"\n"
"## 例\n"
"\n"
"    iex> to_char_list(:foo)\n"
"    'foo'\n"
"\n"

#. TRANSLATORS: def Kernel.tl(list)
#: lib/kernel.ex:715
msgid ""
"Returns the tail of a list. Raises `ArgumentError` if the list is empty.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"リストのtail(リストから先頭要素を取り除いたもの)を返します。\n"
"もしリストが空なら`ArgumentError`を上げます。\n"
"\n"
"ガード中のテストに使うことができます。コンパイラによりインライン化され\n"
"ます。\n"

#. TRANSLATORS: def Kernel.throw(term)
#: lib/kernel.ex:705
msgid ""
"A non-local return from a function. Check `Kernel.SpecialForms.try/1` for "
"more information.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"関数から非ローカルに戻ります。\n"
"詳細は`Kernel.SpecialForms.try/1`をチェックしてください。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: defmacro Kernel.match?(pattern, expr)
#: lib/kernel.ex:1933
msgid ""
"A convenience macro that checks if the right side (an expression)\n"
"matches the left side (a pattern).\n"
"\n"
"## Examples\n"
"\n"
"    iex> match?(1, 1)\n"
"    true\n"
"\n"
"    iex> match?(1, 2)\n"
"    false\n"
"\n"
"    iex> match?({1, _}, {1, 2})\n"
"    true\n"
"\n"
"Match can also be used to filter or find a value in an enumerable:\n"
"\n"
"    list = [{:a, 1}, {:b, 2}, {:a, 3}]\n"
"    Enum.filter list, &match?({:a, _}, &1)\n"
"\n"
"Guard clauses can also be given to the match:\n"
"\n"
"    list = [{:a, 1}, {:b, 2}, {:a, 3}]\n"
"    Enum.filter list, &match?({:a, x} when x < 2, &1)\n"
"\n"
"However, variables assigned in the match will not be available\n"
"outside of the function call:\n"
"\n"
"    iex> match?(x, 1)\n"
"    true\n"
"\n"
"    iex> binding([:x]) == []\n"
"    true\n"
"\n"
msgstr ""
"右辺(式)が左辺(パターン)にマッチするかどうかをチェックする、便利なマクロで"
"す。\n"
"\n"
"## 例\n"
"\n"
"    iex> match?(1, 1)\n"
"    true\n"
"\n"
"    iex> match?(1, 2)\n"
"    false\n"
"\n"
"    iex> match?({1, _}, {1, 2})\n"
"    true\n"
"\n"
"enumerableの中の値をフィルタするまたは、見付けるためにマッチを\n"
"使うこともできます:\n"
"\n"
"    list = [{:a, 1}, {:b, 2}, {:a, 3}]\n"
"    Enum.filter list, &match?({:a, _}, &1)\n"
"\n"
"ガード節もまたマッチで与えることができます:\n"
"\n"
"    list = [{:a, 1}, {:b, 2}, {:a, 3}]\n"
"    Enum.filter list, &match?({:a, x} when x < 2, &1)\n"
"\n"
"しかしながら、マッチで代入される変数は、関数呼びだしの\n"
"外側で利用できません:\n"
"\n"
"    iex> match?(x, 1)\n"
"    true\n"
"\n"
"    iex> binding([:x]) == []\n"
"    true\n"
"\n"
