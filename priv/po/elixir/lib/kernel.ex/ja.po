msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2015-09-16 17:27+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: Elixir.Kernel Summary
#: lib/kernel.ex:9
msgid ""
"`Kernel` provides the default macros and functions\n"
"Elixir imports into your environment. These macros and functions\n"
"can be skipped or cherry-picked via the `import` macro. For\n"
"instance, if you want to tell Elixir not to import the `if`\n"
"macro, you can do:\n"
"\n"
"    import Kernel, except: [if: 2]\n"
"\n"
"Elixir also has special forms that are always imported and\n"
"cannot be skipped. These are described in `Kernel.SpecialForms`.\n"
"\n"
"Some of the functions described in this module are inlined by\n"
"the Elixir compiler into their Erlang counterparts in the `:erlang`\n"
"module. Those functions are called BIFs (builtin internal functions)\n"
"in Erlang-land and they exhibit interesting properties, as some of\n"
"them are allowed in guards and others are used for compiler\n"
"optimizations.\n"
"\n"
"Most of the inlined functions can be seen in effect when capturing\n"
"the function:\n"
"\n"
"    iex> &Kernel.is_atom/1\n"
"    &:erlang.is_atom/1\n"
"\n"
"Those functions will be explicitly marked in their docs as\n"
"\"inlined by the compiler\".\n"
msgstr ""
"Elixirが環境にインポートするデフォルトのマクロと関数を`Kernel`は提供し\n"
"ます。これらのマクロと関数は`import`マクロによってチェリーピッキングや\n"
"スキップすることが出来ます。例えば、もし`if`マクロをインポートしないよ\n"
"うにElixirへ言いたいならば、以下のようにできます:\n"
"\n"
"    import Kernel, except: [if: 2]\n"
"\n"
"Elixirは常にインポートされ、スキップできないスペシャルフォームももって\n"
"います。それらは`Kernel.SpecialForms`に記述されています。\n"
"\n"
"このモジュールで記述される関数のいくつかは、Elixirコンパイラによって\n"
"`:erlang`モジュールでErlangに対応するものにインライン化されます。それら\n"
"の関数はErlang-landでBIFs(builtin internal functions)と呼ばれ、それらの\n"
"幾つかはガードに使うことができたり、コンパイラの最適化に使われたり面白\n"
"い特性を示します。\n"
"\n"
"ほとんどのインライン関数はその関数をキャプチャすると実質的に見られます:\n"
"\n"
"    iex> &Kernel.is_atom/1\n"
"    &:erlang.is_atom/1\n"
"\n"
"それらの関数は\"コンパイラによりインライン化される\"ようにドキュメントで\n"
"明示的にマークされます。\n"

#. TRANSLATORS: def Kernel.round(number)
#: lib/kernel.ex:575
msgid ""
"Rounds a number to the nearest integer.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> round(5.6)\n"
"    6\n"
"    iex> round(5.2)\n"
"    5\n"
"    iex> round(-9.9)\n"
"    -10\n"
"\n"
msgstr ""
"与えられた数を丸めた整数を返します。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> round(5.6)\n"
"    6\n"
"    iex> round(5.2)\n"
"    5\n"
"    iex> round(-9.9)\n"
"    -10\n"
"\n"

#. TRANSLATORS: defmacro Kernel.var!(var, context \\ nil)
#: lib/kernel.ex:2728
msgid ""
"When used inside quoting, marks that the given variable should\n"
"not be hygienized.\n"
"\n"
"The argument can be either a variable unquoted or in standard tuple form\n"
"`{name, meta, context}`.\n"
"\n"
"Check `Kernel.SpecialForms.quote/2` for more information.\n"
msgstr ""
"quoteの内側で使われた時、その変数が健全(hygienized)であってはならない\n"
"とマークします。\n"
"\n"
"引数はunquoteされた変数か、標準タプルフォームの`{name,\n"
"meta, context}`です。\n"
"\n"
"更なる情報は、`Kernel.SpecialForms.quote/2`をチェックしてください。\n"

#. TRANSLATORS: defmacro Kernel.alias!(alias)
#: lib/kernel.ex:2760
msgid ""
"When used inside quoting, marks that the given alias should not\n"
"be hygienized. This means the alias will be expanded when\n"
"the macro is expanded.\n"
"\n"
"Check `Kernel.SpecialForms.quote/2` for more information.\n"
msgstr ""
"quoteの内側で使われた時、その別名が健全(hygienezed)であっては\n"
"ならないとマークします。これは別名はマクロが展開された時に展開\n"
"されるだろうことを意味します。\n"
"\n"
"更なる情報は、`Kernel.SpecialForms.quote/2`をチェックしてくだ\n"
"さい。\n"

#. TRANSLATORS: def Kernel.spawn_monitor(module, fun, args)
#: lib/kernel.ex:729
msgid ""
"Spawns the given module and function passing the given args,\n"
"monitors it and returns its pid and monitoring reference.\n"
"\n"
"Check the `Process` and `Node` modules for other functions\n"
"to handle processes, including spawning functions in nodes.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    spawn_monitor(SomeModule, :function, [1, 2, 3])\n"
"\n"
msgstr ""
"与えられたモジュールと関数に与えられた引数を送ってプロセスを生成し、\n"
"生成したプロセスのpidと、そのプロセスのモニタリファレンスを返します。\n"
"\n"
"他のノードで関数を生成することを含む、プロセスを取り扱う他の関数につい\n"
"ては`Process`と`Node`モジュールをチェックしてください。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    spawn_monitor(SomeModule, :function, [1, 2, 3])\n"
"\n"

#. TRANSLATORS: def Kernel.spawn_link(module, fun, args)
#: lib/kernel.ex:690
msgid ""
"Spawns the given module and function passing the given args,\n"
"links it to the current process and returns its pid.\n"
"\n"
"Check the `Process` and `Node` modules for other functions\n"
"to handle processes, including spawning functions in nodes.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    spawn_link(SomeModule, :function, [1, 2, 3])\n"
"\n"
msgstr ""
"与えられたモジュールと関数に与えられた引数を送ってプロセスを生成し、\n"
"そのプロセスを現在のプロセスにリンクして、生成したプロセスのpidを\n"
"返します。\n"
"\n"
"他のノードで関数を生成することを含む、プロセスを取り扱う他の関数につい\n"
"ては`Process`と`Node`モジュールをチェックしてください。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    spawn_link(SomeModule, :function, [1, 2, 3])\n"
"\n"

#. TRANSLATORS: def Kernel.spawn(module, fun, args)
#: lib/kernel.ex:648
msgid ""
"Spawns the given module and function passing the given args\n"
"and returns its pid.\n"
"\n"
"Check the `Process` and `Node` modules for other functions\n"
"to handle processes, including spawning functions in nodes.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    spawn(SomeModule, :function, [1, 2, 3])\n"
"\n"
msgstr ""
"与えられたモジュールと関数に与えられた引数を送ってプロセスを生成し、\n"
"生成したプロセスのpidを返します。\n"
"\n"
"他のノードで関数を生成することを含む、プロセスを取り扱う他の関数につい\n"
"ては`Process`と`Node`モジュールをチェックしてください。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    spawn(SomeModule, :function, [1, 2, 3])\n"
"\n"

#. TRANSLATORS: def Kernel.spawn_monitor(fun)
#: lib/kernel.ex:709
msgid ""
"Spawns the given function, monitors it and returns its pid\n"
"and monitoring reference.\n"
"\n"
"Check the `Process` and `Node` modules for other functions\n"
"to handle processes, including spawning functions in nodes.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    current = self()\n"
"    spawn_monitor(fn -> send current, {self(), 1 + 2} end)\n"
"\n"
msgstr ""
"与えられた関数のプロセス生成し、生成したプロセスのpidと、そのプロセスの\n"
"モニタリファレンスを返します。\n"
"\n"
"他のノードで関数を生成することを含む、プロセスを取り扱う他の関数につい\n"
"ては`Process`と`Node`モジュールをチェックしてください。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## Examples\n"
"\n"
"    current = self()\n"
"    spawn_monitor(fn -> send current, {self(), 1 + 2} end)\n"
"\n"

#. TRANSLATORS: def Kernel.spawn_link(fun)
#: lib/kernel.ex:667
msgid ""
"Spawns the given function, links it to the current process and returns its "
"pid.\n"
"\n"
"Check the `Process` and `Node` modules for other functions\n"
"to handle processes, including spawning functions in nodes.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    current = self()\n"
"    child   = spawn_link(fn -> send current, {self(), 1 + 2} end)\n"
"\n"
"    receive do\n"
"      {^child, 3} -> IO.puts \"Received 3 back\"\n"
"    end\n"
"\n"
msgstr ""
"与えられた関数のプロセスを生成し、そのプロセスを現在のプロセスにリンク\n"
"して、生成したプロセスのpidを返します。\n"
"\n"
"他のノードで関数を生成することを含む、プロセスを取り扱う他の関数につい\n"
"ては`Process`と`Node`モジュールをチェックしてください。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## Examples\n"
"\n"
"    current = self()\n"
"    child   = spawn_link(fn -> send current, {self(), 1 + 2} end)\n"
"\n"
"    receive do\n"
"      {^child, 3} -> IO.puts \"Received 3 back\"\n"
"    end\n"
"\n"

#. TRANSLATORS: def Kernel.spawn(fun)
#: lib/kernel.ex:625
msgid ""
"Spawns the given function and returns its pid.\n"
"\n"
"Check the `Process` and `Node` modules for other functions\n"
"to handle processes, including spawning functions in nodes.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    current = self()\n"
"    child   = spawn(fn -> send current, {self(), 1 + 2} end)\n"
"\n"
"    receive do\n"
"      {^child, 3} -> IO.puts \"Received 3 back\"\n"
"    end\n"
"\n"
msgstr ""
"与えられた関数のプロセスを生成し、生成したプロセスのpidを返します。\n"
"\n"
"他のノードで関数を生成することを含む、プロセスを取り扱う他の関数につい\n"
"ては`Process`と`Node`モジュールをチェックしてください。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## Examples\n"
"\n"
"    current = self()\n"
"    child   = spawn(fn -> send current, {self(), 1 + 2} end)\n"
"\n"
"    receive do\n"
"      {^child, 3} -> IO.puts \"Received 3 back\"\n"
"    end\n"
"\n"

#. TRANSLATORS: def Kernel.send(dest, msg)
#: lib/kernel.ex:595
msgid ""
"Sends a message to the given `dest` and returns the message.\n"
"\n"
"`dest` may be a remote or local pid, a (local) port, a locally\n"
"registered name, or a tuple `{registered_name, node}` for a registered\n"
"name at another node.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> send self(), :hello\n"
"    :hello\n"
"\n"
msgstr ""
"与えられた`dest`へメッセージを送信し、そのメッセージを返します。\n"
"\n"
"`dest`はリモートまたはローカルのpid、(ローカル)ポート、ローカルレジスター\n"
"された名前もしくは他のノードで登録された名前のタプル`{registered_name,\n"
"node}`です。\n"
"\n"
"コンパイラにより、インライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> send self(), :hello\n"
"    :hello\n"
"\n"

#. TRANSLATORS: def Kernel.tl(list)
#: lib/kernel.ex:758
msgid ""
"Returns the tail of a list. Raises `ArgumentError` if the list is empty.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> tl([1, 2, 3, :go])\n"
"    [2, 3, :go]\n"
msgstr ""
"リストのtail(リストから先頭要素を取り除いたもの)を返します。\n"
"もしリストが空なら`ArgumentError`を上げます。\n"
"\n"
"ガード中のテストに使うことができます。コンパイラによりインライン化され\n"
"ます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> tl([1, 2, 3, :go])\n"
"    [2, 3, :go]\n"

#. TRANSLATORS: defmacro Kernel...(first, last)
#: lib/kernel.ex:2409
msgid ""
"Returns a range with the specified start and end.\n"
"\n"
"Both ends are included.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 0 in 1..3\n"
"    false\n"
"\n"
"    iex> 1 in 1..3\n"
"    true\n"
"\n"
"    iex> 2 in 1..3\n"
"    true\n"
"\n"
"    iex> 3 in 1..3\n"
"    true\n"
"\n"
msgstr ""
"指定された始まりと終わりの範囲を返します。\n"
"\n"
"両端を含みます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> 0 in 1..3\n"
"    false\n"
"\n"
"    iex> 1 in 1..3\n"
"    true\n"
"\n"
"    iex> 2 in 1..3\n"
"    true\n"
"\n"
"    iex> 3 in 1..3\n"
"    true\n"
"\n"

#. TRANSLATORS: def Kernel.min(first, second)
#: lib/kernel.ex:513
msgid ""
"Returns the smallest of the two given terms according to\n"
"Erlang's term ordering. If the terms compare equal, the\n"
"first one is returned.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> min(1, 2)\n"
"    1\n"
"    iex> min(\"foo\", \"bar\")\n"
"    \"bar\"\n"
"\n"
msgstr ""
"与えられた二つのtermのうち、Erlangのtermの順序について、\n"
"小さいほうを返します。termが等しいなら、firstを返します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> min(1, 2)\n"
"    1\n"
"    iex> min(\"foo\", \"bar\")\n"
"    \"bar\"\n"
"\n"

#. TRANSLATORS: def Kernel.tuple_size(tuple)
#: lib/kernel.ex:791
msgid ""
"Returns the size of a tuple.\n"
"\n"
"This operation happens in constant time.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> tuple_size {:a, :b, :c}\n"
"    3\n"
"\n"
msgstr ""
"タプルのサイズを返します。\n"
"\n"
"このオペレーションは定数時間で実行されます。\n"
"\n"
"ガード中のテストに使うことができます。コンパイラによりインライン化され\n"
"ます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> tuple_size {:a, :b, :c}\n"
"    3\n"
"\n"

#. TRANSLATORS: def Kernel.map_size(map)
#: lib/kernel.ex:473
msgid ""
"Returns the size of a map.\n"
"\n"
"The size of a map is the number of key-value pairs that the map contains.\n"
"\n"
"This operation happens in constant time.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> map_size(%{a: \"foo\", b: \"bar\"})\n"
"    2\n"
"\n"
msgstr ""
"mapのサイズを返します。\n"
"\n"
"mapのサイズはmapが含むkey-valueペアの数です。\n"
"\n"
"このオペレーションは定数時間で実行されます。\n"
"\n"
"ガード中のテストに使うことができます。コンパイラによりインライン化され\n"
"ます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> map_size(%{a: \"foo\", b: \"bar\"})\n"
"    2\n"
"\n"

#. TRANSLATORS: def Kernel.self()
#: lib/kernel.ex:615
msgid ""
"Returns the pid (process identifier) of the calling process.\n"
"\n"
"Allowed in guard clauses. Inlined by the compiler.\n"
msgstr ""
"呼び出したプロセスのpid(プロセス識別子)を返します。\n"
"\n"
"ガード節の中で使用できます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.length(list)
#: lib/kernel.ex:439
msgid ""
"Returns the length of `list`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> length([1, 2, 3, 4, 5, 6, 7, 8, 9])\n"
"    9\n"
"\n"
msgstr ""
"`list`の長さを返します。\n"
"\n"
"ガード中のテストに使うことができます。コンパイラによりインライン化され\n"
"ます。\n"
"\n"
"## 例\n"
"\n"
"    iex> length([1, 2, 3, 4, 5, 6, 7, 8, 9])\n"
"    9\n"
"\n"

#. TRANSLATORS: def Kernel.byte_size(binary)
#: lib/kernel.ex:136
msgid ""
"Returns the number of bytes needed to contain `bitstring`.\n"
"\n"
"That is, if the number of bits in `bitstring` is not divisible by 8, the\n"
"resulting number of bytes will be rounded up (by excess). This operation\n"
"happens in constant time.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> byte_size(<<433::16, 3::3>>)\n"
"    3\n"
"\n"
"    iex> byte_size(<<1, 2, 3>>)\n"
"    3\n"
"\n"
msgstr ""
"`bitstring`を格納するために必要なバイト数を返します。\n"
"\n"
"これは、もし`bitstring`のbit数が8で割り切れない場合、結果として生じるバ\n"
"イト数は切り上げられ(余り)ます。このオペレーションは定数時間で実行されます。\n"
"\n"
"ガード中でテストに使うことができます。コンパイラによってインライン化さ\n"
"れます。\n"
"\n"
"## 例\n"
"\n"
"    iex> byte_size(<<433::16, 3::3>>)\n"
"    3\n"
"\n"
"    iex> byte_size(<<1, 2, 3>>)\n"
"    3\n"
"\n"

#. TRANSLATORS: defmacro Kernel.use(module, opts \\ [])
#: lib/kernel.ex:3518
msgid ""
"Uses the given module in the current context.\n"
"\n"
"## Examples\n"
"\n"
"For example, in order to write tests using the ExUnit framework,\n"
"a developer should use the `ExUnit.Case` module:\n"
"\n"
"    defmodule AssertionTest do\n"
"      use ExUnit.Case, async: true\n"
"\n"
"      test \"always pass\" do\n"
"        assert true\n"
"      end\n"
"    end\n"
"\n"
"By calling `use`, a hook called `__using__` will be invoked in\n"
"`ExUnit.Case` which will then do the proper setup.\n"
"\n"
"Simply put, `use` translates to:\n"
"\n"
"    defmodule AssertionTest do\n"
"      require ExUnit.Case\n"
"      ExUnit.Case.__using__([async: true])\n"
"\n"
"      test \"always pass\" do\n"
"        assert true\n"
"      end\n"
"    end\n"
"\n"
"Where `__using__/1` is just a regular macro that can be defined\n"
"in any module:\n"
"\n"
"    defmodule MyModule do\n"
"      defmacro __using__(opts) do\n"
"        quote do\n"
"          # code that will run in the module that uses MyModule\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"## Best practices\n"
"\n"
"`__using__` is typically used when there is a need to set some state\n"
"(via module attributes) or callbacks (like `@before_compile`)\n"
"into the caller.\n"
"\n"
"`__using__` may also be used to alias, require or import functionality\n"
"from different modules:\n"
"\n"
"    defmodule MyModule do\n"
"      defmacro __using__(opts) do\n"
"        quote do\n"
"          import MyModule.Foo\n"
"          import MyModule.Bar\n"
"          import MyModule.Baz\n"
"\n"
"          alias MyModule.Repo\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"However, do not provide `__using__` if all it does is to import,\n"
"alias or require the module itself. For example, do not:\n"
"\n"
"    defmodule MyModule do\n"
"      defmacro __using__(opts) do\n"
"        quote do\n"
"          import MyModule\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"In such cases, developers must just import or alias the module\n"
"directly, allowing developers to customize those as they wish,\n"
"without the indirection behind `use`.\n"
"\n"
"Finally, developers should also avoid defining functions inside\n"
"the `__using__` callback, unless those functions are the default\n"
"implementation of a previously defined `@callback`. In case you\n"
"want to provide some existing functionality to the user module,\n"
"please define it a module which will be imported accordingly.\n"
msgstr ""
"与えられたモジュールを現在のコンテキストで使います。\n"
"\n"
"## Examples\n"
"\n"
"例えば、ExUnitフレームワークを使ってテストを書くとき、\n"
"開発者は`ExUnit.Case`モジュールをuseするべきです:\n"
"\n"
"    defmodule AssertionTest do\n"
"      use ExUnit.Case, async: true\n"
"\n"
"      test \"always pass\" do\n"
"        assert true\n"
"      end\n"
"    end\n"
"\n"
"`use`を呼ぶことにより、`__using__`フックが呼ばれ、\n"
"`ExUnit.Case`の適切なセットアップが行われます。\n"
"\n"
"単に、`use`は以下に変換されます:\n"
"\n"
"    defmodule AssertionTest do\n"
"      require ExUnit.Case\n"
"      ExUnit.Case.__using__([async: true])\n"
"\n"
"      test \"always pass\" do\n"
"        assert true\n"
"      end\n"
"    end\n"
"\n"
"`__using__/1`は全てのモジュールで定義される標準マクロです:\n"
"\n"
"    defmodule MyModule do\n"
"      defmacro __using__(opts) do\n"
"        quote do\n"
"          # code that will run in the module that uses MyModule\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"## Best practices\n"
"\n"
"`__using__`は典型的に(モジュールアトリビュートなどの)ステートや\n"
"(`@before_compile`のような)コールバックを呼出し側にセットする\n"
"ことが必要なときに使われます。\n"
"\n"
"`__using__`は違うモジュールからのalias、requireやimportも\n"
"使うかもしれません:\n"
"\n"
"    defmodule MyModule do\n"
"      defmacro __using__(opts) do\n"
"        quote do\n"
"          import MyModule.Foo\n"
"          import MyModule.Bar\n"
"          import MyModule.Baz\n"
"\n"
"          alias MyModule.Repo\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"しかしながら、自分自身をimport, alias, requireするような\n"
"`__using__`を提供してはいけません。駄目な例です:\n"
"\n"
"    defmodule MyModule do\n"
"      defmacro __using__(opts) do\n"
"        quote do\n"
"          import MyModule\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"そのような場合、開発者は直接importやaliasをしなければなり\n"
"ません。それにより`use`に関係せず、開発者は好きにカスタマイズ\n"
"できます。\n"
"\n"
"最後に、開発者は以前の`@callback`で定義されたデフォルト\n"
"実装でないかぎり、`__using__`コールバックでの関数定義を\n"
"避けてください。\n"
"ユーザモジュールにいくつかの既存の機能を提供したい場合、\n"
"それに応じたモジュール定義して、それをimportするように\n"
"してください。\n"

#. TRANSLATORS: defmacro Kernel.update_in(path, fun)
#: lib/kernel.ex:1814
msgid ""
"Updates a nested structure via the given `path`.\n"
"\n"
"This is similar to `update_in/3`, except the path is extracted via\n"
"a macro rather than passing a list. For example:\n"
"\n"
"    update_in(opts[:foo][:bar], &(&1 + 1))\n"
"\n"
"Is equivalent to:\n"
"\n"
"    update_in(opts, [:foo, :bar], &(&1 + 1))\n"
"\n"
"Note that in order for this macro to work, the complete path must always\n"
"be visible by this macro. For more information about the supported path\n"
"expressions, please check `get_and_update_in/2` docs.\n"
"\n"
"## Examples\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> update_in(users[\"john\"][:age], &(&1 + 1))\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> update_in(users[\"john\"].age, &(&1 + 1))\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
msgstr ""
"ネストした構造を与えられた`path`によって更新します。\n"
"\n"
"pathがリストを渡しているのではなく、マクロによって抽出\n"
"されていることを除けば、これは`update_in/3`と似ています。\n"
"例えば:\n"
"\n"
"    update_in(opts[:foo][:bar], &(&1 + 1))\n"
"\n"
"以下と等しいです:\n"
"\n"
"    update_in(opts, [:foo, :bar], &(&1 + 1))\n"
"\n"
"このマクロが機能するために、完全なパスが常にこのマクロによって見えていなけれ"
"ば\n"
"ならないことに注意してください。\n"
"サポートされたパス式についての更なる情報については、`get_and_update_in/2`の\n"
"ドキュメントをチェックしてください。\n"
"\n"
"## 例\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> update_in(users[\"john\"][:age], &(&1 + 1))\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> update_in(users[\"john\"].age, &(&1 + 1))\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"

#. TRANSLATORS: def Kernel.update_in(data, keys, fun)
#: lib/kernel.ex:1697
msgid ""
"Updates a key in a nested structure.\n"
"\n"
"Uses the `Access` protocol to traverse the structures\n"
"according to the given `keys`, unless the `key` is a\n"
"function. If the key is a function, it will be invoked\n"
"as specified in `get_and_update_in/3`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> update_in(users, [\"john\", :age], &(&1 + 1))\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"In case any of entries in the middle returns `nil`,\n"
"an error will be raised when trying to access it next.\n"
msgstr ""
"ネストした構造を与えられた`path`によって更新します。\n"
"\n"
"pathがリストを渡しているのではなく、マクロによって抽出\n"
"されていることを除けば、これは`update_in/3`と似ています。\n"
"例えば:\n"
"\n"
"    update_in(opts[:foo][:bar], &(&1 + 1))\n"
"\n"
"以下と等しいです:\n"
"\n"
"    update_in(opts, [:foo, :bar], &(&1 + 1))\n"
"\n"
"このマクロが機能するために、完全なパスが常にこのマクロによって見えていなけれ"
"ば\n"
"ならないことに注意してください。\n"
"サポートされたパス式についての更なる情報については、`get_and_update_in/2`の\n"
"ドキュメントをチェックしてください。\n"
"\n"
"ネストした構造のキーを更新します。\n"
"\n"
"`key`が関数でないかぎり、与えられた`key`によって構造を\n"
"トラバースするために`Access`プロトコルを使います。\n"
"もしキーが関数なら、`get_and_update_in/3`で規定により\n"
"実行されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> update_in(users, [\"john\", :age], &(&1 + 1))\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"途中のエントリの何れかが`nil`を返す場合、次に\n"
"それにアクセスしようとするときに、エラーを上げます。\n"

#. TRANSLATORS: def Kernel.exit(reason)
#: lib/kernel.ex:178
msgid ""
"Stops the execution of the calling process with the given reason.\n"
"\n"
"Since evaluating this function causes the process to terminate,\n"
"it has no return value.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"When a process reaches its end, by default it exits with\n"
"reason `:normal`. You can also call `exit/1` explicitly if you\n"
"want to terminate a process but not signal any failure:\n"
"\n"
"    exit(:normal)\n"
"\n"
"In case something goes wrong, you can also use `exit/1` with\n"
"a different reason:\n"
"\n"
"    exit(:seems_bad)\n"
"\n"
"If the exit reason is not `:normal`, all the processes linked to the "
"process\n"
"that exited will crash (unless they are trapping exits).\n"
"\n"
"## OTP exits\n"
"\n"
"Exits are used by the OTP to determine if a process exited abnormally\n"
"or not. The following exits are considered \"normal\":\n"
"\n"
"  * `exit(:normal)`\n"
"  * `exit(:shutdown)`\n"
"  * `exit({:shutdown, term})`\n"
"\n"
"Exiting with any other reason is considered abnormal and treated\n"
"as a crash. This means the default supervisor behaviour kicks in,\n"
"error reports are emitted, etc.\n"
"\n"
"This behaviour is relied on in many different places. For example,\n"
"`ExUnit` uses `exit(:shutdown)` when exiting the test process to\n"
"signal linked processes, supervision trees and so on to politely\n"
"shutdown too.\n"
"\n"
"## CLI exits\n"
"\n"
"Building on top of the exit signals mentioned above, if the\n"
"process started by the command line exits with any of the three\n"
"reasons above, its exit is considered normal and the Operating\n"
"System process will exit with status 0.\n"
"\n"
"It is, however, possible to customize the Operating System exit\n"
"signal by invoking:\n"
"\n"
"    exit({:shutdown, integer})\n"
"\n"
"This will cause the OS process to exit with the status given by\n"
"`integer` while signaling all linked OTP processes to politely\n"
"shutdown.\n"
"\n"
"Any other exit reason will cause the OS process to exit with\n"
"status `1` and linked OTP processes to crash.\n"
msgstr ""
"与えられたreasonで呼び出したプロセスの実行を停止します。\n"
"\n"
"この関数を評価するとき、プロセスは終了する結果となるので、\n"
"値を返しません。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"プロセスが終わりに達するとき、デフォルトでreasonが`:normal`で\n"
"exitが呼ばれます。もし失敗のシグナルを出さずにプロセスを\n"
"終了したいなら、明示的に`exit/1`を呼ぶことも出来ます:\n"
"\n"
"    exit(:normal)\n"
"\n"
"何か悪い事が起ったケースでは、異ったreasonで`exit/1`を呼ぶこと\n"
"もできます:\n"
"\n"
"    exit(:seems_bad)\n"
"\n"
"`:normal`以外のreasonなら、exitしたプロセスにリンクされた\n"
"全てのプロセスはクラッシュします(exitをトラップしていない限り)。\n"
"\n"
"## OTPのexit\n"
"\n"
"exitは、OTPによって、プロセスが異常終了したか否かの決定に使われます。\n"
"以下のexitは\"normal\"として扱われます:\n"
"\n"
"  * `exit(:normal)`\n"
"  * `exit(:shutdown)`\n"
"  * `exit({:shutdown, term})`\n"
"\n"
"他のどんなreasonでも異常終了と思われ、クラッシュしたと見做されます。こ\n"
"れはエラーレポートを発行するなどの、デフォルトのスーパーバイザの振舞い\n"
"が効き始めることを意味します。\n"
"\n"
"この振舞いは多くの異る場所で依存されています。例えば、`ExUnit`はテスト\n"
"プロセスが終了する時、リンクされたプロセス、つまり、監督ツリーとその他\n"
"も礼儀正しくシャットダウンさせるときに、`exit(:shutdown)`を使います。\n"
"\n"
"## CLIの exit\n"
"\n"
"上記の終了シグナルの上に作り、もし\n"
"コマンドラインにより開始したプロセスが\n"
"上の3つの何れかのreasonで終了したら、その終了は、正常と\n"
"考え、オペレーティングシステムプロセスはステータス0で終了します。\n"
"\n"
"しかしながら、以下の様に実行することで、オペレーティングシステムのexit\n"
"シグナルをカスタマイズすることも可能です：\n"
"\n"
"    exit({:shutdown, integer})\n"
"\n"
"これは全てのリンクされたOTPプロセスを礼儀正しく終了したうえで、\n"
"OSプロセスを`integer`により与えられたステータスで終了します。\n"
"\n"
"他のreasonのexitは全て、リンクされたOTPプロセスをクラッシュさせ、\n"
"OSプロセスをステータス1で終了します。\n"

#. TRANSLATORS: defmacro Kernel.binding(context \\ nil)
#: lib/kernel.ex:2215
msgid ""
"Returns the binding for the given context as a keyword list.\n"
"\n"
"In the returned result, keys are variable names and values are the\n"
"corresponding variable values.\n"
"\n"
"If the given `context` is `nil` (by default it is), the binding for the\n"
"current context is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> x = 1\n"
"    iex> binding()\n"
"    [x: 1]\n"
"    iex> x = 2\n"
"    iex> binding()\n"
"    [x: 2]\n"
"\n"
"    iex> binding(:foo)\n"
"    []\n"
"    iex> var!(x, :foo) = 1\n"
"    1\n"
"    iex> binding(:foo)\n"
"    [x: 1]\n"
"\n"
msgstr ""
"キーワードリストとして与えられたコンテキストのバインディングを\n"
"返します。\n"
"\n"
"変数名はキーでその変数の値がバリューになります。\n"
"\n"
"`context`が`nil`(デフォルト)なら、現在のコンテキストでの\n"
"バインディングが返されます。\n"
"\n"
"\n"
"## 例\n"
"\n"
"    iex> x = 1\n"
"    iex> binding()\n"
"    [x: 1]\n"
"    iex> x = 2\n"
"    iex> binding()\n"
"    [x: 2]\n"
"\n"
"    iex> binding(:foo)\n"
"    []\n"
"    iex> var!(x, :foo) = 1\n"
"    1\n"
"    iex> binding(:foo)\n"
"    [x: 1]\n"
"\n"

#. TRANSLATORS: def Kernel.bit_size(bitstring)
#: lib/kernel.ex:117
msgid ""
"Returns an integer which is the size in bits of `bitstring`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> bit_size(<<433::16, 3::3>>)\n"
"    19\n"
"\n"
"    iex> bit_size(<<1, 2, 3>>)\n"
"    24\n"
"\n"
msgstr ""
"`bitstring`のビット列の大きさを整数で返します。\n"
"\n"
"ガード中のテストで使うことができます。コンパイラによりインライン化され\n"
"ます。\n"
"\n"
"## 例\n"
"\n"
"    iex> bit_size(<<433::16, 3::3>>)\n"
"    19\n"
"\n"
"    iex> bit_size(<<1, 2, 3>>)\n"
"    24\n"
"\n"

#. TRANSLATORS: def Kernel.abs(number)
#: lib/kernel.ex:40
msgid ""
"Returns an integer or float which is the arithmetical absolute value of "
"`number`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> abs(-3.33)\n"
"    3.33\n"
"\n"
"    iex> abs(-3)\n"
"    3\n"
"\n"
msgstr ""
"`number`の算術的絶対値を整数または小数で返します。\n"
"\n"
"ガード中のテストで使うことができます。コンパイラによりインライン化され\n"
"ます。\n"
"\n"
"## 例\n"
"\n"
"    iex> abs(-3.33)\n"
"    3.33\n"
"\n"
"    iex> abs(-3)\n"
"    3\n"
"\n"

#. TRANSLATORS: def Kernel.node()
#: lib/kernel.ex:533
msgid ""
"Returns an atom representing the name of the local node.\n"
"If the node is not alive, `:nonode@nohost` is returned instead.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"ローカルノードの名前を表現するアトムを返します。\n"
"もしノードが生きていないなら、`:nonode@nohost`が替わりに返されます。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.make_ref()
#: lib/kernel.ex:455
msgid ""
"Returns an almost unique reference.\n"
"\n"
"The returned reference will re-occur after approximately 2^82 calls;\n"
"therefore it is unique enough for practical purposes.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    make_ref() #=> #Reference<0.0.0.135>\n"
"\n"
msgstr ""
"ほとんどユニークなリファレンスを返します。\n"
"\n"
"返されたリファレンスはおよそ2^82回の呼び出しの後、再度発生します;\n"
"従ってそれは実際上は十分にユニークです。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    make_ref() #=> #Reference<0.0.0.135>\n"
"\n"

#. TRANSLATORS: def Kernel.max(first, second)
#: lib/kernel.ex:493
msgid ""
"Returns the biggest of the two given terms according to\n"
"Erlang's term ordering. If the terms compare equal, the\n"
"first one is returned.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> max(1, 2)\n"
"    2\n"
"    iex> max(:a, :b)\n"
"    :b\n"
"\n"
msgstr ""
"与えられた二つのtermのうち、Erlangのtermの順序について、大きいほうを\n"
"返します。termが等しいなら、firstを返します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> max(1, 2)\n"
"    2\n"
"    iex> max(:a, :b)\n"
"    :b\n"
"\n"

#. TRANSLATORS: def Kernel.node(arg)
#: lib/kernel.ex:544
msgid ""
"Returns the node where the given argument is located.\n"
"The argument can be a pid, a reference, or a port.\n"
"If the local node is not alive, `:nonode@nohost` is returned.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"与えられた引数の場所のノードを返します。\n"
"引数はpid、リファレンス、又はポートです。\n"
"ローカルノードが生きていなければ、`nonode@nohost`が返ります。\n"
"\n"
"ガードテストに使えます。\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.!==(left, right)
#: lib/kernel.ex:1113
msgid ""
"Returns `true` if the two items do not match.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 !== 2\n"
"    true\n"
"\n"
"    iex> 1 !== 1.0\n"
"    true\n"
"\n"
msgstr ""
"もし、二つのアイテムが一致しないなら、`true`を返します。\n"
"\n"
"Elixirの全てのアイテムはそれぞれ他と比較加能です。\n"
"\n"
"ガードの中のテストに使えます。\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> 1 !== 2\n"
"    true\n"
"\n"
"    iex> 1 !== 1.0\n"
"    true\n"
"\n"

#. TRANSLATORS: def Kernel.!=(left, right)
#: lib/kernel.ex:1064
msgid ""
"Returns `true` if the two items are not equal.\n"
"\n"
"This operator considers 1 and 1.0 to be equal. For match\n"
"comparison, use `!==` instead.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 != 2\n"
"    true\n"
"\n"
"    iex> 1 != 1.0\n"
"    false\n"
"\n"
msgstr ""
"もし、二つのアイテムが等しくないなら、`true`を返します。\n"
"\n"
"この演算子は1と1.0を等しいと考えます。一致するかどうかの\n"
"比較の為には、`!==`をかわりに使ってください。\n"
"\n"
"Elixirの全てのアイテムはそれぞれ他と比較加能です。\n"
"\n"
"ガードの中のテストに使えます。\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> 1 != 2\n"
"    true\n"
"\n"
"    iex> 1 != 1.0\n"
"    false\n"
"\n"

#. TRANSLATORS: defmacro Kernel.@(expr)
#: lib/kernel.ex:2088
msgid ""
"Reads and writes attributes of the current module.\n"
"\n"
"The canonical example for attributes is annotating that a module\n"
"implements the OTP behaviour called `gen_server`:\n"
"\n"
"    defmodule MyServer do\n"
"      @behaviour :gen_server\n"
"      # ... callbacks ...\n"
"    end\n"
"\n"
"By default Elixir supports all the module attributes supported by Erlang, "
"but\n"
"custom attributes can be used as well:\n"
"\n"
"    defmodule MyServer do\n"
"      @my_data 13\n"
"      IO.inspect @my_data #=> 13\n"
"    end\n"
"\n"
"Unlike Erlang, such attributes are not stored in the module by default "
"since\n"
"it is common in Elixir to use custom attributes to store temporary data "
"that\n"
"will be available at compile-time. Custom attributes may be configured to\n"
"behave closer to Erlang by using `Module.register_attribute/3`.\n"
"\n"
"Finally, notice that attributes can also be read inside functions:\n"
"\n"
"    defmodule MyServer do\n"
"      @my_data 11\n"
"      def first_data, do: @my_data\n"
"      @my_data 13\n"
"      def second_data, do: @my_data\n"
"    end\n"
"\n"
"    MyServer.first_data #=> 11\n"
"    MyServer.second_data #=> 13\n"
"\n"
"It is important to note that reading an attribute takes a snapshot of\n"
"its current value. In other words, the value is read at compilation\n"
"time and not at runtime. Check the `Module` module for other functions\n"
"to manipulate module attributes.\n"
msgstr ""
"現在のモジュールのアトリビュートを読み書きします。\n"
"\n"
"アトリビュートの規範的な例は、モジュールが`gen_server`と呼ばれている\n"
"OTPビヘイビアを実装するという注釈を付けていることです:\n"
"\n"
"    defmodule MyServer do\n"
"      @behaviour :gen_server\n"
"      # ... callbacks ...\n"
"    end\n"
"\n"
"デフォルトでElixirは全てのErlangモジュールアトリビュートをサポートし、\n"
"開発者は、任意のカスタムアトリビュートを追加することもできます:\n"
"\n"
"    defmodule MyServer do\n"
"      @my_data 13\n"
"      IO.inspect @my_data #=> 13\n"
"    end\n"
"\n"
"Erlangとは異なり、一時的なデータを格納するためにそのようなアトリビュー\n"
"トを使うことはElixirでは一般的になった時から、デフォルトではそのような\n"
"アトリビュートはモジュールにには保存されません。開発者は\n"
"`Module.register_attribute/3`を呼ぶことによって、Erlangにより近く振る舞\n"
"うように、アトリビュートを構成することができます。\n"
"\n"
"最後にアトリビュートは関数の内側で読むこともできることに注意してください:\n"
"\n"
"    defmodule MyServer do\n"
"      @my_data 11\n"
"      def first_data, do: @my_data\n"
"      @my_data 13\n"
"      def second_data, do: @my_data\n"
"    end\n"
"\n"
"    MyServer.first_data #=> 11\n"
"    MyServer.second_data #=> 13\n"
"\n"
"アトリビュートを読むことは、現在の値のスナップショットを取ることである\n"
"点に注意することは、重要です。言い替えると、値はコンパイル時に読み、実\n"
"行時ではありません。モジュールアトリビュートを操作する他の関数について\n"
"は、`Module`モジュールをチェックしてください。\n"

#. TRANSLATORS: def Kernel.>(left, right)
#: lib/kernel.ex:986
msgid ""
"Returns `true` if left is more than right.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 > 2\n"
"    false\n"
"\n"
msgstr ""
"もし、leftがrightより大きければ、`true`を返します。\n"
"\n"
"Elixirの全てのアイテムはそれぞれ他と比較加能です。\n"
"\n"
"ガードの中のテストに使えます。\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> 1 > 2\n"
"    false\n"
"\n"

#. TRANSLATORS: def Kernel.>=(left, right)
#: lib/kernel.ex:1022
msgid ""
"Returns `true` if left is more than or equal to right.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 >= 2\n"
"    false\n"
"\n"
msgstr ""
"もし、leftがrightと等しいか、より大きければ、`true`を返します。\n"
"\n"
"Elixirの全てのアイテムはそれぞれ他と比較加能です。\n"
"\n"
"ガードの中のテストに使えます。\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> 1 >= 2\n"
"    false\n"
"\n"

#. TRANSLATORS: def Kernel.<(left, right)
#: lib/kernel.ex:968
msgid ""
"Returns `true` if left is less than right.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 < 2\n"
"    true\n"
"\n"
msgstr ""
"もし、leftがrightより小ければ、`true`を返します。\n"
"\n"
"Elixirの全てのアイテムはそれぞれ他と比較加能です。\n"
"\n"
"ガードの中のテストに使えます。\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> 1 < 2\n"
"    true\n"
"\n"

#. TRANSLATORS: def Kernel.<=(left, right)
#: lib/kernel.ex:1004
msgid ""
"Returns `true` if left is less than or equal to right.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 <= 2\n"
"    true\n"
"\n"
msgstr ""
"もし、leftがrightと等しいか、より小ければ、`true`を返します。\n"
"\n"
"Elixirの全てのアイテムはそれぞれ他と比較加能です。\n"
"\n"
"ガードの中のテストに使えます。\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> 1 <= 2\n"
"    true\n"
"\n"

#. TRANSLATORS: def Kernel.--(left, right)
#: lib/kernel.ex:930
msgid ""
"Removes the first occurrence of an item on the left list\n"
"for each item on the right.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> [1, 2, 3] -- [1, 2]\n"
"    [3]\n"
"\n"
"    iex> [1, 2, 3, 2, 1] -- [1, 2, 2]\n"
"    [3, 1]\n"
"\n"
msgstr ""
"右のそれぞれのアイテムについて左にあるアイテムを取り除きます。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> [1, 2, 3] -- [1, 2]\n"
"    [3]\n"
"\n"
"    iex> [1, 2, 3, 2, 1] -- [1, 2, 2]\n"
"    [3, 1]\n"
"\n"

#. TRANSLATORS: defmacro Kernel.raise(msg)
#: lib/kernel.ex:1295
msgid ""
"Raises an exception.\n"
"\n"
"If the argument `msg` is a binary, it raises a `RuntimeError` exception\n"
"using the given argument as message.\n"
"\n"
"If `msg` is an atom, it just calls `raise/2` with the atom as the first\n"
"argument and `[]` as the second argument.\n"
"\n"
"If `msg` is anything else, raises an `ArgumentError` exception.\n"
"\n"
"## Examples\n"
"\n"
"    iex> raise \"oops\"\n"
"    ** (RuntimeError) oops\n"
"\n"
"    try do\n"
"      1 + :foo\n"
"    rescue\n"
"      x in [ArithmeticError] ->\n"
"        IO.puts \"that was expected\"\n"
"        raise x\n"
"    end\n"
"\n"
msgstr ""
"例外を上げます。\n"
"\n"
"もし引数`msg`がバイナリなら、メッセージとして与えられた\n"
"引数を使い、`RuntimeError`を上げます。\n"
"\n"
"もし`msg`がアトムなら、最初の引数をatom、二つめの\n"
"引数を[]として、`raise/2`を呼びます(`raise(msg, [])`)。\n"
"\n"
"もし`msg`がそれ以外なら、`ArgumentError`例外を上げます。\n"
"\n"
"## 例\n"
"\n"
"    iex> raise \"oops\"\n"
"    ** (RuntimeError) oops\n"
"\n"
"    try do\n"
"      1 + :foo\n"
"    rescue\n"
"      x in [ArithmeticError] ->\n"
"        IO.puts \"that was expected\"\n"
"        raise x\n"
"    end\n"
"\n"

#. TRANSLATORS: defmacro Kernel.raise(exception, attrs)
#: lib/kernel.ex:1358
msgid ""
"Raises an exception.\n"
"\n"
"Calls the `exception/1` function on the given argument (which has to be a\n"
"module name like `ArgumentError` or `RuntimeError`) passing `attrs` as the\n"
"attributes in order to retrieve the exception struct.\n"
"\n"
"Any module that contains a call to the `defexception/1` macro automatically\n"
"implements the `exception/1` callback expected by `raise/2`. See the docs "
"for\n"
"`defexception/1` for more information.\n"
"\n"
"## Examples\n"
"\n"
"    iex> raise(ArgumentError, message: \"Sample\")\n"
"    ** (ArgumentError) Sample\n"
"\n"
msgstr ""
"例外を上げます。\n"
"\n"
"適切な例外構造を取得するために、アトリビュートを渡し、\n"
"(`ArgumentError`や`RuntimeError`とったモジュール名で\n"
"ある必要がある)与えられた引数の`exception/1`を呼び出します。\n"
"\n"
"`defexception/1`により定義された任意のモジュールは、自動的に、\n"
"`raise/2`により期待された`exception(attrs)`コールバックを実装します。\n"
"詳細は`defexception/1`を参照してください。\n"
"\n"
"## 例\n"
"\n"
"    iex> raise(ArgumentError, message: \"Sample\")\n"
"    ** (ArgumentError) Sample\n"
"\n"

#. TRANSLATORS: defmacro Kernel.reraise(exception, attrs, stacktrace)
#: lib/kernel.ex:1440
msgid ""
"Raises an exception preserving a previous stacktrace.\n"
"\n"
"`reraise/3` works like `reraise/2`, except it passes arguments to the\n"
"`exception/1` function like explained in `raise/2`.\n"
"\n"
"## Examples\n"
"\n"
"    try do\n"
"      raise \"oops\"\n"
"    rescue\n"
"      exception ->\n"
"        stacktrace = System.stacktrace\n"
"        reraise WrapperError, [exception: exception], stacktrace\n"
"    end\n"
msgstr ""
"以前のスタックトレースを保ちながら、例外を上げます。\n"
"\n"
"`raise/2`で説明したように引数を`exception/1`へ渡す\n"
"ことを除いては、`reraise/3`は、`raise/2`と似た働きをします。\n"
"\n"
"## 例\n"
"\n"
"    try do\n"
"      raise \"Oops\"\n"
"    rescue\n"
"      exception ->\n"
"        stacktrace = System.stacktrace\n"
"        reraise WrapperError, [exception: exception], stacktrace\n"
"    end\n"

#. TRANSLATORS: defmacro Kernel.reraise(msg, stacktrace)
#: lib/kernel.ex:1381
msgid ""
"Raises an exception preserving a previous stacktrace.\n"
"\n"
"Works like `raise/1` but does not generate a new stacktrace.\n"
"\n"
"Notice that `System.stacktrace/0` returns the stacktrace\n"
"of the last exception. That said, it is common to assign\n"
"the stacktrace as the first expression inside a `rescue`\n"
"clause as any other exception potentially raised (and\n"
"rescued) between the rescue clause and the raise call\n"
"may change the `System.stacktrace/0` value.\n"
"\n"
"## Examples\n"
"\n"
"    try do\n"
"      raise \"oops\"\n"
"    rescue\n"
"      exception ->\n"
"        stacktrace = System.stacktrace\n"
"        if Exception.message(exception) == \"oops\" do\n"
"          reraise exception, stacktrace\n"
"        end\n"
"    end\n"
msgstr ""
"以前のスタックトレースを保ちながら、例外を上げます。\n"
"\n"
"`raise/1`と似た働きをしますが、新しいスタックトレースを生成しません。\n"
"\n"
"`System.stacktrace/0`は、最後の例外のスタックトレースを返すことに、気を付\n"
"けてください。それは、レスキュー節とレイズの間で、潜在的に上げられた(そ\n"
"してレスキューされた)他の例外としての、`rescue`節の最初の式として、スタッ\n"
"クトレースを割り当てることは、一般的で、`System.stacktrace/0`値の\n"
"変更を呼びだすかもしれません。\n"
"\n"
"## 例\n"
"\n"
"    try do\n"
"      raise \"Oops\"\n"
"    rescue\n"
"      exception ->\n"
"        stacktrace = System.stacktrace\n"
"        if Exception.message(exception) == \"Oops\" do\n"
"          reraise exception, stacktrace\n"
"        end\n"
"    end\n"

#. TRANSLATORS: def Kernel.is_boolean(term)
#: lib/kernel.ex:308
msgid ""
"Returns `true` if `term` is either the atom `true` or the atom `false` (i."
"e.,\n"
"a boolean); otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"もし`term`がアトム`true`またはアトム`false`のいずれか(すなわちboolean)\n"
"ならば`true`を返します。さもなければ`false`を返します。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.is_number(term)
#: lib/kernel.ex:378
msgid ""
"Returns `true` if `term` is either an integer or a floating point number;\n"
"otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`が整数か浮動小数点数のいずれかなら`true`を返します。さもなければ\n"
"`false`を返します。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.is_integer(term)
#: lib/kernel.ex:358
msgid ""
"Returns `true` if `term` is an integer; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`が整数なら`true`を返します。さもなければ`false`を返します。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.is_atom(term)
#: lib/kernel.ex:260
msgid ""
"Returns `true` if `term` is an atom; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`がアトムなら`true`を返します。さもなければ`false`を返します。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.is_tuple(term)
#: lib/kernel.ex:419
msgid ""
"Returns `true` if `term` is a tuple; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`がタプルなら`true`を返します。さもなければ`false`を返します。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.is_reference(term)
#: lib/kernel.ex:409
msgid ""
"Returns `true` if `term` is a reference; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`がリファレンスなら`true`を返します。さもなければ`false`を返します。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.is_port(term)
#: lib/kernel.ex:399
msgid ""
"Returns `true` if `term` is a port identifier; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`がポート識別子なら`true`を返します。さもなければ`false`を返します。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.is_pid(term)
#: lib/kernel.ex:389
msgid ""
"Returns `true` if `term` is a pid (process identifier); otherwise returns "
"`false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`がpid(プロセス識別子)なら`true`を返します。さもなければ`false`を\n"
"返します。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.is_map(term)
#: lib/kernel.ex:429
msgid ""
"Returns `true` if `term` is a map; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`がマップなら`true`を返します。さもなければ`false`を返します。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.is_list(term)
#: lib/kernel.ex:368
msgid ""
"Returns `true` if `term` is a list with zero or more elements; otherwise "
"returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`が0個以上の要素をもつリストなら`true`を返します。さもなければ\n"
"`false`を返します。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.is_function(term)
#: lib/kernel.ex:329
msgid ""
"Returns `true` if `term` is a function; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`が関数なら`true`を返します。さもなければ`false`を返します。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.is_function(term, arity)
#: lib/kernel.ex:339
msgid ""
"Returns `true` if `term` is a function that can be applied with `arity` "
"number of arguments;\n"
"otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> is_function(fn(x) -> x * 2 end, 1)\n"
"    true\n"
"    iex> is_function(fn(x) -> x * 2 end, 2)\n"
"    false\n"
"\n"
msgstr ""
"`term`が引数の数が`arity`個で適用可能な関数なら`true`を返します。さもな\n"
"ければ`false`を返します。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> is_function(fn(x) -> x * 2 end, 1)\n"
"    true\n"
"    iex> is_function(fn(x) -> x * 2 end, 2)\n"
"    false\n"
"\n"

#. TRANSLATORS: def Kernel.is_float(term)
#: lib/kernel.ex:319
msgid ""
"Returns `true` if `term` is a floating point number; otherwise returns "
"`false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`が浮動小数点数なら`true`を返します。さもなければ`false`を返します。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.is_bitstring(term)
#: lib/kernel.ex:290
msgid ""
"Returns `true` if `term` is a bitstring (including a binary); otherwise "
"returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> is_bitstring \"foo\"\n"
"    true\n"
"    iex> is_bitstring <<1::3>>\n"
"    true\n"
"\n"
msgstr ""
"`term`がビット列(バイナリを含ふくみます)なら`true`を返します。さもなけ\n"
"れば`false`を返します。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> is_bitstring \"foo\"\n"
"    true\n"
"    iex> is_bitstring <<1::3>>\n"
"    true\n"
"\n"

#. TRANSLATORS: def Kernel.is_binary(term)
#: lib/kernel.ex:270
msgid ""
"Returns `true` if `term` is a binary; otherwise returns `false`.\n"
"\n"
"A binary always contains a complete number of bytes.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> is_binary \"foo\"\n"
"    true\n"
"    iex> is_binary <<1::3>>\n"
"    false\n"
"\n"
msgstr ""
"`term`がバイナリなら`true`を返します。さもなければ`false`を返します。\n"
"\n"
"バイナリは常に完全なバイトの数を含みます。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> is_binary \"foo\"\n"
"    true\n"
"    iex> is_binary <<1::3>>\n"
"    false\n"
"\n"

#. TRANSLATORS: defmacro Kernel.is_nil(term)
#: lib/kernel.ex:2006
msgid ""
"Returns `true` if `term` is `nil`, `false` otherwise.\n"
"\n"
"Allowed in guard clauses.\n"
"\n"
"## Examples\n"
"\n"
"    iex> is_nil(1)\n"
"    false\n"
"\n"
"    iex> is_nil(nil)\n"
"    true\n"
"\n"
msgstr ""
"`term`が`nil`なら`true`を、さもなければ`false`を返します。\n"
"\n"
"ガード節で使えます。\n"
"\n"
"## 例\n"
"\n"
"    iex> is_nil(1)\n"
"    false\n"
"\n"
"    iex> is_nil(nil)\n"
"    true\n"
"\n"

#. TRANSLATORS: def Kernel.macro_exported?(module, macro, arity)
#: lib/kernel.ex:2587
msgid ""
"Returns `true` if `module` is loaded and contains a\n"
"public `macro` with the given `arity`, otherwise `false`.\n"
"\n"
"Note that this function does not load the module in case\n"
"it is not loaded. Check `Code.ensure_loaded/1` for more\n"
"information.\n"
"\n"
"## Examples\n"
"\n"
"    iex> macro_exported?(Kernel, :use, 2)\n"
"    true\n"
"\n"
msgstr ""
"`module`がロードされていて、与えられた`arity`の公開`macro`が\n"
"含まれていると`true`を返し、さもなくば`false`を返します。\n"
"\n"
"この関数はモジュールがロードされていないときに、ロードを\n"
"しないことに注意してください。さらなる情報は`Code.ensure_loaded/1`\n"
"をチェックしてください。\n"
"\n"
"## Examples\n"
"\n"
"    iex> macro_exported?(Kernel, :use, 2)\n"
"    true\n"
"\n"

#. TRANSLATORS: def Kernel.function_exported?(module, function, arity)
#: lib/kernel.ex:2568
msgid ""
"Returns `true` if `module` is loaded and contains a\n"
"public `function` with the given `arity`, otherwise `false`.\n"
"\n"
"Note that this function does not load the module in case\n"
"it is not loaded. Check `Code.ensure_loaded/1` for more\n"
"information.\n"
"\n"
"## Examples\n"
"\n"
"    iex> function_exported?(Enum, :member?, 2)\n"
"    true\n"
"\n"
msgstr ""
"`module`がロードされていて、与えられた`arity`の公開`function`が\n"
"含まれていると`true`を返し、さもなくば`false`を返します。\n"
"\n"
"この関数はモジュールがロードされていないときに、ロードを\n"
"しないことに注意してください。さらなる情報は`Code.ensure_loaded/1`\n"
"をチェックしてください。\n"
"\n"
"## Examples\n"
"\n"
"    iex> function_exported?(Enum, :member?, 2)\n"
"    true\n"
"\n"

#. TRANSLATORS: def Kernel.put_in(data, keys, value)
#: lib/kernel.ex:1675
msgid ""
"Puts a value in a nested structure.\n"
"\n"
"Uses the `Access` protocol to traverse the structures\n"
"according to the given `keys`, unless the `key` is a\n"
"function. If the key is a function, it will be invoked\n"
"as specified in `get_and_update_in/3`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> put_in(users, [\"john\", :age], 28)\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"In case any of entries in the middle returns `nil`,\n"
"an error will be raised when trying to access it next.\n"
msgstr ""
"値をネストした構造にプットします。\n"
"\n"
"`keys`が関数でない限り、与えられた`keys`によって\n"
"構造を横断するために、`Access`プロトコルを使います。\n"
"もしキーが関数なら、`get_and_update_in/3`の仕様により\n"
"実行されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> put_in(users, [\"john\", :age], 28)\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"中間のエントリのいずれかが`nil`を返す場合、次にそれに\n"
"アクセスしようとするとき、エラーが上ります。\n"

#. TRANSLATORS: defmacro Kernel.put_in(path, value)
#: lib/kernel.ex:1777
msgid ""
"Puts a value in a nested structure via the given `path`.\n"
"\n"
"This is similar to `put_in/3`, except the path is extracted via\n"
"a macro rather than passing a list. For example:\n"
"\n"
"    put_in(opts[:foo][:bar], :baz)\n"
"\n"
"Is equivalent to:\n"
"\n"
"    put_in(opts, [:foo, :bar], :baz)\n"
"\n"
"Note that in order for this macro to work, the complete path must always\n"
"be visible by this macro. For more information about the supported path\n"
"expressions, please check `get_and_update_in/2` docs.\n"
"\n"
"## Examples\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> put_in(users[\"john\"][:age], 28)\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> put_in(users[\"john\"].age, 28)\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
msgstr ""
"値をネストした構造に`path`によりプットします。\n"
"\n"
"pathが、リストを渡しているよりはむしろ、マクロによって抽出される\n"
"こと以外は、`put_in/3`に似ています。例えば:\n"
"\n"
"`keys`が関数でない限り、与えられた`keys`によって\n"
"構造を横断するために、`Access`プロトコルを使います。\n"
"もしキーが関数なら、`get_and_update_in/3`の仕様により\n"
"実行されます。\n"
"\n"
"\n"
"中間のエントリのいずれかが`nil`を返す場合、次にそれに\n"
"アクセスしようとするとき、エラーが上ります。\n"
"\n"
"\n"
"    put_in(opts[:foo][:bar], :baz)\n"
"\n"
"は以下と等価です:\n"
"\n"
"    put_in(opts, [:foo, :bar], :baz)\n"
"\n"
"このマクロが機能するために、完全なパスは、常にこのマクロによって可視で\n"
"なければならないことに注意してください。サポートされたパス表現について\n"
"の詳細は、`get_and_update_in/2`ドキュメントをチェックしてください。\n"
"\n"
"## 例\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> put_in(users[\"john\"][:age], 28)\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> put_in(users[\"john\"].age, 28)\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"

#. TRANSLATORS: defmacro Kernel.unless(condition, clauses)
#: lib/kernel.ex:2316
msgid ""
"Provides an `unless` macro.\n"
"\n"
"This macro evaluates and returns the `do` block passed in as the second\n"
"argument unless `clause` evaluates to `true`. Otherwise, it returns the "
"value\n"
"of the `else` block if present or `nil` if not.\n"
"\n"
"See also `if/2`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> unless(Enum.empty?([]), do: \"Hello\")\n"
"    nil\n"
"\n"
"    iex> unless(Enum.empty?([1, 2, 3]), do: \"Hello\")\n"
"    \"Hello\"\n"
"\n"
"    iex> unless Enum.sum([2, 2]) == 5 do\n"
"    ...>   \"Math still works\"\n"
"    ...> else\n"
"    ...>   \"Math is broken\"\n"
"    ...> end\n"
"    \"Math still works\"\n"
"\n"
msgstr ""
"`unless`マクロを提供します。\n"
"\n"
"このマクロは、`clause`が`true`でない限り、2番目の引数として\n"
"渡された`do`ブロックを評価して返します。\n"
"さもなければ、`else`ブロックを評価し、`else`ブロックも\n"
"ない時は`nil`を返します。\n"
"\n"
"`if/2`も参照してください。\n"
"\n"
"## Examples\n"
"\n"
"    iex> unless(Enum.empty?([]), do: \"Hello\")\n"
"    nil\n"
"\n"
"    iex> unless(Enum.empty?([1, 2, 3]), do: \"Hello\")\n"
"    \"Hello\"\n"
"\n"
"    iex> unless Enum.sum([2, 2]) == 5 do\n"
"    ...>   \"Math still works\"\n"
"    ...> else\n"
"    ...>   \"Math is broken\"\n"
"    ...> end\n"
"    \"Math still works\"\n"
"\n"

#. TRANSLATORS: defmacro Kernel.if(condition, clauses)
#: lib/kernel.ex:2256
msgid ""
"Provides an `if` macro.\n"
"\n"
"This macro expects the first argument to be a condition and the second\n"
"argument to be a keyword list.\n"
"\n"
"## One-liner examples\n"
"\n"
"    if(foo, do: bar)\n"
"\n"
"In the example above, `bar` will be returned if `foo` evaluates to\n"
"`true` (i.e., it is neither `false` nor `nil`). Otherwise, `nil` will be\n"
"returned.\n"
"\n"
"An `else` option can be given to specify the opposite:\n"
"\n"
"    if(foo, do: bar, else: baz)\n"
"\n"
"## Blocks examples\n"
"\n"
"It's also possible to pass a block to the `if` macro. The first\n"
"example above would be translated to:\n"
"\n"
"    if foo do\n"
"      bar\n"
"    end\n"
"\n"
"Note that `do/end` become delimiters. The second example would\n"
"translate to:\n"
"\n"
"    if foo do\n"
"      bar\n"
"    else\n"
"      baz\n"
"    end\n"
"\n"
"In order to compare more than two clauses, the `cond/1` macro has to be "
"used.\n"
msgstr ""
"`if`マクロを提供します。\n"
"\n"
"このマクロは最初の引数をコンディションとして、\n"
"残りをキーワード引数として期待します。\n"
"\n"
"## ワンライナーの例\n"
"\n"
"    if(foo, do: bar)\n"
"\n"
"上の例では、`foo`が`true`(即ち、`false`でもなく、`nil`でもないなら)に評\n"
"価されたら、`bar`が返されます。さもなくば、`nil`が返ります。\n"
"\n"
"`else`オプションは正反対を指定させることができます:\n"
"\n"
"    if(foo, do: bar, else: baz)\n"
"\n"
"## ブロックの例\n"
"\n"
"Elixirは`if`マクロにブロックを渡すことも許しています。上の最初の\n"
"例は、以下のように翻訳されます:\n"
"\n"
"    if foo do\n"
"      bar\n"
"    end\n"
"\n"
"`do/end`がブロックのデリミタであることに注意してください。二番目の例は\n"
"次のように翻訳されます:\n"
"\n"
"    if foo do\n"
"      bar\n"
"    else\n"
"      baz\n"
"    end\n"
"\n"
"もし二つ以上の節を比較したいなら、`cond/1`マクロを使うことができます。\n"

#. TRANSLATORS: defmacro Kernel.||(left, right)
#: lib/kernel.ex:2480
msgid ""
"Provides a short-circuit operator that evaluates and returns the second\n"
"expression only if the first one does not evaluate to `true` (i.e., it\n"
"is either `nil` or `false`). Returns the first expression otherwise.\n"
"\n"
"Not allowed in guard clauses.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.empty?([1]) || Enum.empty?([1])\n"
"    false\n"
"\n"
"    iex> List.first([]) || true\n"
"    true\n"
"\n"
"    iex> Enum.empty?([1]) || 1\n"
"    1\n"
"\n"
"    iex> Enum.empty?([]) || throw(:bad)\n"
"    true\n"
"\n"
"Note that, unlike Erlang's `or` operator,\n"
"this operator accepts any expression as the first argument,\n"
"not only booleans.\n"
msgstr ""
"最初の式が`true`(即ち、`nil`でも`false`でもない)に評価されなかったとき\n"
"だけ二番目の式を評価し、返す、ショートサーキット演算子を提供します。\n"
"さもなければ最初の式を返します。\n"
"\n"
"ガードで使えません。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.empty?([1]) || Enum.empty?([1])\n"
"    false\n"
"\n"
"    iex> List.first([]) || true\n"
"    true\n"
"\n"
"    iex> Enum.empty?([1]) || 1\n"
"    1\n"
"\n"
"    iex> Enum.empty?([]) || throw(:bad)\n"
"    true\n"
"\n"
"Erlangの`or`演算子と違って、この演算子は、\n"
"引数としてブーリアンだけでなく任意の式を受け付けることに、注意してくだ\n"
"さい。\n"

#. TRANSLATORS: defmacro Kernel.&&(left, right)
#: lib/kernel.ex:2442
msgid ""
"Provides a short-circuit operator that evaluates and returns\n"
"the second expression only if the first one evaluates to `true`\n"
"(i.e., it is not `nil` nor `false`). Returns the first expression\n"
"otherwise.\n"
"\n"
"Not allowed in guard clauses.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.empty?([]) && Enum.empty?([])\n"
"    true\n"
"\n"
"    iex> List.first([]) && true\n"
"    nil\n"
"\n"
"    iex> Enum.empty?([]) && List.first([1])\n"
"    1\n"
"\n"
"    iex> false && throw(:bad)\n"
"    false\n"
"\n"
"\n"
"Note that, unlike Erlang's `and` operator,\n"
"this operator accepts any expression as the first argument,\n"
"not only booleans.\n"
msgstr ""
"最初の式が`true`(即ち、`nil`でも`false`でもない)に評価されたとき\n"
"だけ二番目の式を評価し、返す、ショートサーキット演算子を提供します。\n"
"さもなければ最初の式を返します。\n"
"\n"
"ガードの中では使えません。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.empty?([]) && Enum.empty?([])\n"
"    true\n"
"\n"
"    iex> List.first([]) && true\n"
"    nil\n"
"\n"
"    iex> Enum.empty?([]) && List.first([1])\n"
"    1\n"
"\n"
"    iex> false && throw(:bad)\n"
"    false\n"
"\n"
"Erlangの`and`演算子と違って、この演算子は、\n"
"引数としてブーリアンだけでなく任意の式を受け付けることに、注意してくだ\n"
"さい。\n"

#. TRANSLATORS: defmacro Kernel.|>(left, right)
#: lib/kernel.ex:2516
msgid ""
"Pipe operator.\n"
"\n"
"This operator introduces the expression on the left-hand side as\n"
"the first argument to the function call on the right-hand side.\n"
"\n"
"## Examples\n"
"\n"
"    iex> [1, [2], 3] |> List.flatten()\n"
"    [1, 2, 3]\n"
"\n"
"The example above is the same as calling `List.flatten([1, [2], 3])`.\n"
"\n"
"The `|>` operator is mostly useful when there is a desire to execute a "
"series\n"
"of operations resembling a pipeline:\n"
"\n"
"    iex> [1, [2], 3] |> List.flatten |> Enum.map(fn x -> x * 2 end)\n"
"    [2, 4, 6]\n"
"\n"
"In the example above, the list `[1, [2], 3]` is passed as the first "
"argument\n"
"to the `List.flatten/1` function, then the flattened list is passed as the\n"
"first argument to the `Enum.map/2` function which doubles each element of "
"the\n"
"list.\n"
"\n"
"In other words, the expression above simply translates to:\n"
"\n"
"    Enum.map(List.flatten([1, [2], 3]), fn x -> x * 2 end)\n"
"\n"
"Beware of operator precedence when using the pipe operator.\n"
"For example, the following expression:\n"
"\n"
"    String.graphemes \"Hello\" |> Enum.reverse\n"
"\n"
"Translates to:\n"
"\n"
"    String.graphemes(\"Hello\" |> Enum.reverse)\n"
"\n"
"which results in an error as the `Enumerable` protocol is not defined\n"
"for binaries. Adding explicit parentheses resolves the ambiguity:\n"
"\n"
"    String.graphemes(\"Hello\") |> Enum.reverse\n"
"\n"
"Or, even better:\n"
"\n"
"    \"Hello\" |> String.graphemes |> Enum.reverse\n"
"\n"
msgstr ""
"パイプオペレータです。\n"
"\n"
"この演算子は右の関数呼び出しの最初の引数として左の式を送ります。\n"
"\n"
"## 例\n"
"\n"
"    iex> [1, [2], 3] |> List.flatten()\n"
"    [1, 2, 3]\n"
"\n"
"上の例は`List.flatten([1, [2], 3])`を呼び出すのと同じです。\n"
"すなわち、`|>`の左側の引数は右側の呼びだし関数の最初の引数として\n"
"送られます。\n"
"\n"
"沢山のオペレーションを実行したいとき、このパターンは非常に使い易いです。\n"
"そしてパイプラインに似ています:\n"
"\n"
"    iex> [1, [2], 3] |> List.flatten |> Enum.map(fn x -> x * 2 end)\n"
"    [2, 4, 6]\n"
"\n"
"上の例は`List.flatten/1`にリストを送り、それから平坦化されたリストを\n"
"得て、リストのそれぞれのエントリを2倍するために`Enum.map/2`へ送ります。\n"
"\n"
"言い替えると、上の式は単に以下のように翻訳できます:\n"
"\n"
"    Enum.map(List.flatten([1, [2], 3]), fn x -> x * 2 end)\n"
"\n"
"パイプオペレータを使用するとき、演算子の優先順位に注意してください。\n"
"例えば、以下の式は:\n"
"\n"
"    String.graphemes \"Hello\" |> Enum.reverse\n"
"\n"
"このように翻訳されます:\n"
"\n"
"    String.graphemes(\"Hello\" |> Enum.reverse)\n"
"\n"
"バイナリに対するEnumerableプロトコルが定義されていないのでエラーに終ります。\n"
"明示的に括弧を加えることで曖昧さを解決します:\n"
"\n"
"    String.graphemes(\"Hello\") |> Enum.reverse\n"
"\n"
"または、もっとよい方法で:\n"
"\n"
"    \"Hello\" |> String.graphemes |> Enum.reverse\n"
"\n"

#. TRANSLATORS: def Kernel.div(left, right)
#: lib/kernel.ex:159
msgid ""
"Performs an integer division.\n"
"\n"
"Raises an `ArithmeticError` exception if one of the arguments is not an\n"
"integer.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> div(5, 2)\n"
"    2\n"
"\n"
msgstr ""
"整数の除算を実行します。\n"
"\n"
"引数の一つが整数でないなら、`ArithmeticError`例外を上げます。\n"
"\n"
"ガードテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> div(5, 2)\n"
"    2\n"
"\n"

#. TRANSLATORS: def Kernel.=~(left, right)
#: lib/kernel.ex:1462
msgid ""
"Matches the term on the left against the regular expression or string on "
"the\n"
"right. Returns `true` if `left` matches `right` (if it's a regular "
"expression)\n"
"or contains `right` (if it's a string).\n"
"\n"
"## Examples\n"
"\n"
"    iex> \"abcd\" =~ ~r/c(d)/\n"
"    true\n"
"\n"
"    iex> \"abcd\" =~ ~r/e/\n"
"    false\n"
"\n"
"    iex> \"abcd\" =~ \"bc\"\n"
"    true\n"
"\n"
"    iex> \"abcd\" =~ \"ad\"\n"
"    false\n"
"\n"
"    iex> \"abcd\" =~ \"\"\n"
"    true\n"
"\n"
msgstr ""
"右辺の正規表現か文字列に対して、左辺をマッチさせます。`left`が、正規表\n"
"現`right`にマッチしたか、文字列`right`を含んでいたら、`true`を返します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> \"abcd\" =~ ~r/c(d)/\n"
"    true\n"
"\n"
"    iex> \"abcd\" =~ ~r/e/\n"
"    false\n"
"\n"
"    iex> \"abcd\" =~ \"bc\"\n"
"    true\n"
"\n"
"    iex> \"abcd\" =~ \"ad\"\n"
"    false\n"
"\n"
"    iex> \"abcd\" =~ \"\"\n"
"    true\n"
"\n"

#. TRANSLATORS: defmacro Kernel.defoverridable(keywords)
#: lib/kernel.ex:3480
msgid ""
"Makes the given functions in the current module overridable.\n"
"\n"
"An overridable function is lazily defined, allowing a developer to override\n"
"it.\n"
"\n"
"## Example\n"
"\n"
"    defmodule DefaultMod do\n"
"      defmacro __using__(_opts) do\n"
"        quote do\n"
"          def test(x, y) do\n"
"            x + y\n"
"          end\n"
"\n"
"          defoverridable [test: 2]\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    defmodule InheritMod do\n"
"      use DefaultMod\n"
"\n"
"      def test(x, y) do\n"
"        x * y + super(x, y)\n"
"      end\n"
"    end\n"
"\n"
"As seen as in the example above, `super` can be used to call the default\n"
"implementation.\n"
"\n"
msgstr ""
"現在のモジュールの与えられた関数をoverridableにします。\n"
"\n"
"overridable関数\n"
"は、開発者がカスタマイズするために、後から定義することを許します。\n"
"\n"
"## 例\n"
"\n"
"    defmodule DefaultMod do\n"
"      defmacro __using__(_opts) do\n"
"        quote do\n"
"          def test(x, y) do\n"
"            x + y\n"
"          end\n"
"\n"
"          defoverridable [test: 2]\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    defmodule InheritMod do\n"
"      use DefaultMod\n"
"\n"
"      def test(x, y) do\n"
"        x * y + super(x, y)\n"
"      end\n"
"    end\n"
"\n"
"上は良くみられる例で、`super`はデオフォルトの実装を呼ぶため使われます。\n"

#. TRANSLATORS: def Kernel.binary_part(binary, start, length)
#: lib/kernel.ex:91
msgid ""
"Extracts the part of the binary starting at `start` with length `length`.\n"
"Binaries are zero-indexed.\n"
"\n"
"If `start` or `length` reference in any way outside the binary, an\n"
"`ArgumentError` exception is raised.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> binary_part(\"foo\", 1, 2)\n"
"    \"oo\"\n"
"\n"
"A negative `length` can be used to extract bytes that come *before* the "
"byte\n"
"at `start`:\n"
"\n"
"    iex> binary_part(\"Hello\", 5, -3)\n"
"    \"llo\"\n"
"\n"
msgstr ""
"`start`から長さ`length`のバイナリの部分を抽出します。\n"
"バイナリは0始まりです。\n"
"\n"
"もし`start`か`length`がバイナリの外部を参照するなら、\n"
"`ArgumentError`例外が上ります。\n"
"\n"
"ガードテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> binary_part(\"foo\", 1, 2)\n"
"    \"oo\"\n"
"\n"
"`start`位置で *初まる* バイトを抽出するために、\n"
"負の`length`を使うことができます。\n"
"\n"
"    iex> binary_part(\"Hello\", 5, -3)\n"
"    \"llo\"\n"
"\n"

#. TRANSLATORS: def Kernel.apply(fun, args)
#: lib/kernel.ex:59
msgid ""
"Invokes the given `fun` with the array of arguments `args`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> apply(fn x -> x * 2 end, [2])\n"
"    4\n"
"\n"
msgstr ""
"引数の配列`args`で与えられた`fun`を起動します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> apply(fn x -> x * 2 end, [2])\n"
"    4\n"
"\n"

#. TRANSLATORS: def Kernel.apply(module, fun, args)
#: lib/kernel.ex:75
msgid ""
"Invokes the given `fun` from `module` with the array of arguments `args`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> apply(Enum, :reverse, [[1, 2, 3]])\n"
"    [3, 2, 1]\n"
"\n"
msgstr ""
"引数の配列`args`で与えられた`module`の`fun`を起動します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> apply(Enum, :reverse, [[1, 2, 3]])\n"
"    [3, 2, 1]\n"
"\n"

#. TRANSLATORS: def Kernel.inspect(arg, opts \\ [])
#: lib/kernel.ex:1497
msgid ""
"Inspects the given argument according to the `Inspect` protocol.\n"
"The second argument is a keyword list with options to control\n"
"inspection.\n"
"\n"
"## Options\n"
"\n"
"`inspect/2` accepts a list of options that are internally\n"
"translated to an `Inspect.Opts` struct. Check the docs for\n"
"`Inspect.Opts` to see the supported options.\n"
"\n"
"## Examples\n"
"\n"
"    iex> inspect(:foo)\n"
"    \":foo\"\n"
"\n"
"    iex> inspect [1, 2, 3, 4, 5], limit: 3\n"
"    \"[1, 2, 3, ...]\"\n"
"\n"
"    iex> inspect(\"olá\" <> <<0>>)\n"
"    \"<<111, 108, 195, 161, 0>>\"\n"
"\n"
"    iex> inspect(\"olá\" <> <<0>>, binaries: :as_strings)\n"
"    \"\\\"olá\\\\0\\\"\"\n"
"\n"
"    iex> inspect(\"olá\", binaries: :as_binaries)\n"
"    \"<<111, 108, 195, 161>>\"\n"
"\n"
"    iex> inspect('bar')\n"
"    \"'bar'\"\n"
"\n"
"    iex> inspect([0|'bar'])\n"
"    \"[0, 98, 97, 114]\"\n"
"\n"
"    iex> inspect(100, base: :octal)\n"
"    \"0o144\"\n"
"\n"
"    iex> inspect(100, base: :hex)\n"
"    \"0x64\"\n"
"\n"
"Note that the `Inspect` protocol does not necessarily return a valid\n"
"representation of an Elixir term. In such cases, the inspected result\n"
"must start with `#`. For example, inspecting a function will return:\n"
"\n"
"    inspect fn a, b -> a + b end\n"
"    #=> #Function<...>\n"
"\n"
msgstr ""
"`Inspect`プロトコルに従って、与えられた引数でインスペクトします。\n"
"2番目の引数はキーワードリストで、インスペクトを制御するオプションです。\n"
"\n"
"## オプション\n"
"\n"
"`inspect/2`は`Inspect.Opts`構造体に内部的に変換されるオプションの\n"
"リストを受け付けます。サポートするオプションについては、\n"
"`Inspect.Opts`のドキュメントをチェックしてください。\n"
"\n"
"## 例\n"
"\n"
"    iex> inspect(:foo)\n"
"    \":foo\"\n"
"\n"
"    iex> inspect [1, 2, 3, 4, 5], limit: 3\n"
"    \"[1, 2, 3, ...]\"\n"
"\n"
"    iex> inspect(\"olá\" <> <<0>>)\n"
"    \"<<111, 108, 195, 161, 0>>\"\n"
"\n"
"    iex> inspect(\"olá\" <> <<0>>, binaries: :as_strings)\n"
"    \"\\\"olá\\\\0\\\"\"\n"
"\n"
"    iex> inspect(\"olá\", binaries: :as_binaries)\n"
"    \"<<111, 108, 195, 161>>\"\n"
"\n"
"    iex> inspect('bar')\n"
"    \"'bar'\"\n"
"\n"
"    iex> inspect([0|'bar'])\n"
"    \"[0, 98, 97, 114]\"\n"
"\n"
"    iex> inspect(100, base: :octal)\n"
"    \"0o144\"\n"
"\n"
"    iex> inspect(100, base: :hex)\n"
"    \"0x64\"\n"
"\n"
"なお、`Inspect`プロトコルは、Elixirタームの有効な表現を返す必要は、\n"
"必ずしもないです。そのような場合、インスペクトされた結果は、`#`から\n"
"始めなければなりません。例えば、関数をインスペクトすると、\n"
"以下のように返されます:\n"
"\n"
"    inspect fn a, b -> a + b end\n"
"    #=> #Function<...>\n"
"\n"

#. TRANSLATORS: def Kernel.put_elem(tuple, index, value)
#: lib/kernel.ex:1151
msgid ""
"Inserts `value` at the given zero-based `index` in `tuple`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> tuple = {:foo, :bar, 3}\n"
"    iex> put_elem(tuple, 0, :baz)\n"
"    {:baz, :bar, 3}\n"
"\n"
msgstr ""
"`tuple`に要素をゼロ始まりの`index`の位置に与えられた`value`で\n"
"挿入します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> tuple = {:foo, :bar, 3}\n"
"    iex> put_elem(tuple, 0, :baz)\n"
"    {:baz, :bar, 3}\n"
"\n"

#. TRANSLATORS: def Kernel.===(left, right)
#: lib/kernel.ex:1088
msgid ""
"Returns `true` if the two items are match.\n"
"\n"
"This operator gives the same semantics as the one existing in\n"
"pattern matching, i.e., `1` and `1.0` are equal, but they do\n"
"not match.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 === 2\n"
"    false\n"
"\n"
"    iex> 1 === 1.0\n"
"    false\n"
"\n"
msgstr ""
"もし、二つのアイテムが一致するなら、`true`を返します。\n"
"\n"
"この演算子はパターンマッチの中に存在しているものと\n"
"同じセマンティクスを与えます。すなわち、`1`と`1.0`は等しいですが、\n"
"それらは一致しません。\n"
"\n"
"Elixirの全てのアイテムはそれぞれ他と比較加能です。\n"
"\n"
"ガードの中のテストに使えます。\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> 1 === 2\n"
"    false\n"
"\n"
"    iex> 1 === 1.0\n"
"    false\n"
"\n"

#. TRANSLATORS: def Kernel.==(left, right)
#: lib/kernel.ex:1040
msgid ""
"Returns `true` if the two items are equal.\n"
"\n"
"This operator considers 1 and 1.0 to be equal. For match\n"
"semantics, use `===` instead.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 == 2\n"
"    false\n"
"\n"
"    iex> 1 == 1.0\n"
"    true\n"
"\n"
msgstr ""
"もし、二つのアイテムが等しいなら、`true`を返します。\n"
"\n"
"この演算子は1と1.0を等しいと考えます。一致するかどうかの\n"
"比較の為には、`===`をかわりに使ってください。\n"
"\n"
"Elixirの全てのアイテムはそれぞれ他と比較加能です。\n"
"\n"
"ガードの中のテストに使えます。\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> 1 == 2\n"
"    false\n"
"\n"
"    iex> 1 == 1.0\n"
"    true\n"
"\n"

#. TRANSLATORS: def Kernel.get_in(data, keys)
#: lib/kernel.ex:1616
msgid ""
"Gets a value from a nested structure.\n"
"\n"
"Uses the `Access` protocol to traverse the structures\n"
"according to the given `keys`, unless the `key` is a\n"
"function.\n"
"\n"
"If a key is a function, the function will be invoked\n"
"passing three arguments, the operation (`:get`), the\n"
"data to be accessed, and a function to be invoked next.\n"
"\n"
"This means `get_in/2` can be extended to provide\n"
"custom lookups. The downside is that functions cannot be\n"
"stored as keys in the accessed data structures.\n"
"\n"
"## Examples\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> get_in(users, [\"john\", :age])\n"
"    27\n"
"\n"
"In case any of entries in the middle returns `nil`, `nil` will be returned\n"
"as per the Access protocol:\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> get_in(users, [\"unknown\", :age])\n"
"    nil\n"
"\n"
"When one of the keys is a function, the function is invoked.\n"
"In the example below, we use a function to get all the maps\n"
"inside a list:\n"
"\n"
"    iex> users = [%{name: \"john\", age: 27}, %{name: \"meg\", age: 23}]\n"
"    iex> all = fn :get, data, next -> Enum.map(data, next) end\n"
"    iex> get_in(users, [all, :age])\n"
"    [27, 23]\n"
"\n"
"If the previous value before invoking the function is `nil`,\n"
"the function *will* receive nil as a value and must handle it\n"
"accordingly.\n"
msgstr ""
"ネストした構造から値を取得します。\n"
"\n"
"`key`が関数でない限り、与えられた`keys`に従って構造を渡り歩くために、\n"
"`Access`プトロコルを使います。\n"
"\n"
"もしキーが関数なら、関数は、オペレーション(`:get`)、アクセスされるデー\n"
"タ、次に実行される関数の、3個の引数を渡されて実行されます。\n"
"\n"
"この`get_in/2`の手段は、カスタムメイドの検索を提供するために拡張可能です。\n"
"不利な面は、関数がアクセスされたデータ構造のキーとして格納されないという\n"
"ことです。\n"
"\n"
"## 例\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> get_in(users, [\"john\", :age])\n"
"    27\n"
"\n"
"中間のエントリのいずれかが`nil`を返す場合、Accessプロトコルを使うたびに\n"
"`nil`を返します:\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> get_in(users, [\"unknown\", :age])\n"
"    nil\n"
"\n"
"キーの一つが関数のとき、関数は実行されます。\n"
"下の例では、リストの中の全てのマップを取得するために、\n"
"関数を使っています:\n"
"\n"
"    iex> users = [%{name: \"john\", age: 27}, %{name: \"meg\", age: 23}]\n"
"    iex> all = fn :get, data, next -> Enum.map(data, next) end\n"
"    iex> get_in(users, [all, :age])\n"
"    [27, 23]\n"
"\n"
"もし関数を実行する以前の値がnilなら、関数は、値としてnilを受け取る\n"
"*でしょう* 。そしてそれに従って取り扱わなければなりません。\n"

#. TRANSLATORS: def Kernel.get_and_update_in(data, keys, fun)
#: lib/kernel.ex:1719
msgid ""
"Gets a value and updates a nested structure.\n"
"\n"
"It expects a tuple to be returned, containing the value\n"
"retrieved and the update one.\n"
"\n"
"Uses the `Access` protocol to traverse the structures\n"
"according to the given `keys`, unless the `key` is a\n"
"function.\n"
"\n"
"If a key is a function, the function will be invoked\n"
"passing three arguments, the operation (`:get_and_update`),\n"
"the data to be accessed, and a function to be invoked next.\n"
"\n"
"This means `get_and_update_in/3` can be extended to provide\n"
"custom lookups. The downside is that functions cannot be stored\n"
"as keys in the accessed data structures.\n"
"\n"
"## Examples\n"
"\n"
"This function is useful when there is a need to retrieve the current\n"
"value (or something calculated in function of the current value) and\n"
"update it at the same time. For example, it could be used to increase\n"
"the age of a user by one and return the previous age in one pass:\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> get_and_update_in(users, [\"john\", :age], &{&1, &1 + 1})\n"
"    {27, %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}}\n"
"\n"
"When one of the keys is a function, the function is invoked.\n"
"In the example below, we use a function to get and increment all\n"
"ages inside a list:\n"
"\n"
"    iex> users = [%{name: \"john\", age: 27}, %{name: \"meg\", age: 23}]\n"
"    iex> all = fn :get_and_update, data, next ->\n"
"    ...>   Enum.map(data, next) |> :lists.unzip\n"
"    ...> end\n"
"    iex> get_and_update_in(users, [all, :age], &{&1, &1 + 1})\n"
"    {[27, 23], [%{name: \"john\", age: 28}, %{name: \"meg\", age: 24}]}\n"
"\n"
"If the previous value before invoking the function is `nil`,\n"
"the function *will* receive `nil` as a value and must handle it\n"
"accordingly (be it by failing or providing a sane default).\n"
msgstr ""
"ネストした構造から値を取得し、更新します。\n"
"\n"
"取得した値と、更新した値を含むタプルを返すことが、期待されます。\n"
"\n"
"`keys`が関数でない限り、与えられた`keys`によって\n"
"構造を渡り歩くために、`Access`プロトコルを使います。\n"
"\n"
"もしキーが関数なら、関数は、オペレーション(`:get_and_update`)、アクセス\n"
"されるデータ、次に実行される関数の、3個の引数を渡されて実行されます。\n"
"\n"
"この`get_and_update_in/3`の手段は、カスタムメイドの検索を提供するために\n"
"拡張可能です。不利な面は、関数がアクセスされたデータ構造のキーとして格\n"
"納されないということです。\n"
"\n"
"## 例\n"
"\n"
"この関数は、現在の値(または現在の値で計算される何か)の取得と、更新を同\n"
"時に行いたい場合に、便利です。例えば、ユーザの前の年齢を取得し、年齢を\n"
"増加することを一度に行うために、使うことができます:\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> get_and_update_in(users, [\"john\", :age], &{&1, &1 + 1})\n"
"    {27, %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}}\n"
"\n"
"キーの一つが関数の時、関数が起動されます。\n"
"下の例では、リスト中の全ての年齢を取得し、増加させるために\n"
"関数を使っています:\n"
"\n"
"    iex> users = [%{name: \"john\", age: 27}, %{name: \"meg\", age: 23}]\n"
"    iex> all = fn :get_and_update, data, next ->\n"
"    ...>   Enum.map(data, next) |> List.unzip() |> List.to_tuple()\n"
"    ...> end\n"
"    iex> get_and_update_in(users, [all, :age], &{&1, &1 + 1})\n"
"    {[27, 23], [%{name: \"john\", age: 28}, %{name: \"meg\", age: 24}]}\n"
"\n"
"もし関数を実行する以前の値がnilなら、関数は、値として`nil`を受け取る\n"
"*でしょう*。そしてそれに従って(失敗するか、デフォルトの正しい値を\n"
"提供することによって)取り扱わなければなりません。\n"

#. TRANSLATORS: defmacro Kernel.get_and_update_in(path, fun)
#: lib/kernel.ex:1851
msgid ""
"Gets a value and updates a nested data structure via the given `path`.\n"
"\n"
"This is similar to `get_and_update_in/3`, except the path is extracted\n"
"via a macro rather than passing a list. For example:\n"
"\n"
"    get_and_update_in(opts[:foo][:bar], &{&1, &1 + 1})\n"
"\n"
"Is equivalent to:\n"
"\n"
"    get_and_update_in(opts, [:foo, :bar], &{&1, &1 + 1})\n"
"\n"
"Note that in order for this macro to work, the complete path must always\n"
"be visible by this macro. See the Paths section below.\n"
"\n"
"## Examples\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> get_and_update_in(users[\"john\"].age, &{&1, &1 + 1})\n"
"    {27, %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}}\n"
"\n"
"## Paths\n"
"\n"
"A path may start with a variable, local or remote call, and must be\n"
"followed by one or more:\n"
"\n"
"  * `foo[bar]` - access a field; in case an intermediate field is not\n"
"    present or returns `nil`, an empty map is used\n"
"\n"
"  * `foo.bar` - access a map/struct field; in case the field is not\n"
"    present, an error is raised\n"
"\n"
"Here are some valid paths:\n"
"\n"
"    users[\"john\"][:age]\n"
"    users[\"john\"].age\n"
"    User.all[\"john\"].age\n"
"    all_users()[\"john\"].age\n"
"\n"
"Here are some invalid ones:\n"
"\n"
"    # Does a remote call after the initial value\n"
"    users[\"john\"].do_something(arg1, arg2)\n"
"\n"
"    # Does not access any field\n"
"    users\n"
"\n"
msgstr ""
"与えられた`path`によってネストしたデータ構造の値を取得、更新します。\n"
"\n"
"pathが、リストを渡しているよりはむしろ、マクロによって抽出される\n"
"こと以外は、`get_and_update_in/3`に似ています。例えば:\n"
"\n"
"    get_and_update_in(opts[:foo][:bar], &{&1, &1 + 1})\n"
"\n"
"は、以下と等しいです:\n"
"\n"
"    get_and_update_in(opts, [:foo, :bar], &{&1, &1 + 1})\n"
"\n"
"このマクロが機能するために、完全なパスが常にこのマクロによって見えてい\n"
"なければならないことに注意してください。以下のパスセクションを参照して\n"
"ください。\n"
"\n"
"## 例\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> get_and_update_in(users[\"john\"].age, &{&1, &1 + 1})\n"
"    {27, %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}}\n"
"\n"
"## パス\n"
"\n"
"パスは変数、ローカルかリモートコールで始まり、以下の一つ以上\n"
"が続かなければなりません:\n"
"\n"
"  * `foo[bar]` - フィールドアクセス; 中間のフィールドが存在しないか、\n"
"                 nilを返す場合、空のマップが使われます\n"
"\n"
"  * `foo.bar` - マップ/構造体フィルドのアクセス; フィールドが存在しない\n"
"                場合、エラーが上ります\n"
"\n"
"これらは正しいパスです:\n"
"\n"
"    users[\"john\"][:age]\n"
"    users[\"john\"].age\n"
"    User.all[\"john\"].age\n"
"    all_users()[\"john\"].age\n"
"\n"
"これらは間違ったパスです:\n"
"\n"
"    # Does a remote call after the initial value\n"
"    users[\"john\"].do_something(arg1, arg2)\n"
"\n"
"    # Does not access any field\n"
"    users\n"
"\n"

#. TRANSLATORS: def Kernel.elem(tuple, index)
#: lib/kernel.ex:1134
msgid ""
"Gets the element at the zero-based `index` in `tuple`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> tuple = {:foo, :bar, 3}\n"
"    iex> elem(tuple, 1)\n"
"    :bar\n"
"\n"
msgstr ""
"`tuple`の0始まりの`index`の場所の要素を取得します。\n"
"\n"
"ガードテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> tuple = {:foo, :bar, 3}\n"
"    iex> elem(tuple, 1)\n"
"    :bar\n"
"\n"

#. TRANSLATORS: defmacro Kernel.sigil_w(term, modifiers)
#: lib/kernel.ex:3819
msgid ""
"Handles the sigil `~w`.\n"
"\n"
"It returns a list of \"words\" split by whitespace. Character unescaping "
"and\n"
"interpolation happens for each word.\n"
"\n"
"## Modifiers\n"
"\n"
"  * `s`: words in the list are strings (default)\n"
"  * `a`: words in the list are atoms\n"
"  * `c`: words in the list are char lists\n"
"\n"
"## Examples\n"
"\n"
"    iex> ~w(foo #{:bar} baz)\n"
"    [\"foo\", \"bar\", \"baz\"]\n"
"\n"
"    iex> ~w(--source test/enum_test.exs)\n"
"    [\"--source\", \"test/enum_test.exs\"]\n"
"\n"
"    iex> ~w(foo bar baz)a\n"
"    [:foo, :bar, :baz]\n"
"\n"
msgstr ""
"sigil ~wをハンドルします。\n"
"\n"
"空白によって区切られた\"words\"のリストを返します。文字は\n"
"各word毎にunescapingされ、変数展開されます。\n"
"\n"
"## モディファイア\n"
"\n"
"  * `s`: 文字列 (デフォルト)\n"
"  * `a`: アトム\n"
"  * `c`: 文字のリスト\n"
"\n"
"## 例\n"
"\n"
"    iex> ~w(foo #{:bar} baz)\n"
"    [\"foo\", \"bar\", \"baz\"]\n"
"\n"
"    iex> ~w(--source test/enum_test.exs)\n"
"    [\"--source\", \"test/enum_test.exs\"]\n"
"\n"
"    iex> ~w(foo bar baz)a\n"
"    [:foo, :bar, :baz]\n"
"\n"

#. TRANSLATORS: defmacro Kernel.sigil_s(term, modifiers)
#: lib/kernel.ex:3696
msgid ""
"Handles the sigil `~s`.\n"
"\n"
"It returns a string as if it was a double quoted string, unescaping "
"characters\n"
"and replacing interpolations.\n"
"\n"
"## Examples\n"
"\n"
"    iex> ~s(foo)\n"
"    \"foo\"\n"
"\n"
"    iex> ~s(f#{:o}o)\n"
"    \"foo\"\n"
"\n"
"    iex> ~s(f\\#{:o}o)\n"
"    \"f\\#{:o}o\"\n"
"\n"
msgstr ""
"sigil ~sをハンドルします。\n"
"\n"
"まるで二重引用苻付きの文字列であるかのように、文字列を\n"
"返します。そして文字のアンエスケープと、内挿の置き換えをします。\n"
"\n"
"## 例\n"
"\n"
"    iex> ~s(foo)\n"
"    \"foo\"\n"
"\n"
"    iex> ~s(f#{:o}o)\n"
"    \"foo\"\n"
"\n"
"    iex> ~s(f\\#{:o}o)\n"
"    \"f\\#{:o}o\"\n"
"\n"

#. TRANSLATORS: defmacro Kernel.sigil_r(term, modifiers)
#: lib/kernel.ex:3770
msgid ""
"Handles the sigil `~r`.\n"
"\n"
"It returns a regular expression pattern, unescaping characters and "
"replacing\n"
"interpolations.\n"
"\n"
"More information on regexes can be found in the `Regex` module.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.match?(~r(foo), \"foo\")\n"
"    true\n"
"\n"
"    iex> Regex.match?(~r/abc/, \"abc\")\n"
"    true\n"
"\n"
msgstr ""
"sigil `~r`をハンドルします。\n"
"\n"
"unescapeし、変数展開をした正規表現を返します。\n"
"\n"
"正規表現についての詳細は`Regex`モジュールを参照してください。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.match?(~r(foo), \"foo\")\n"
"    true\n"
"\n"
"    iex> Regex.match?(~r/abc/, \"abc\")\n"
"    true\n"
"\n"

#. TRANSLATORS: defmacro Kernel.sigil_c(term, modifiers)
#: lib/kernel.ex:3739
msgid ""
"Handles the sigil `~c`.\n"
"\n"
"It returns a char list as if it were a single quoted string, unescaping\n"
"characters and replacing interpolations.\n"
"\n"
"## Examples\n"
"\n"
"    iex> ~c(foo)\n"
"    'foo'\n"
"\n"
"    iex> ~c(f#{:o}o)\n"
"    'foo'\n"
"\n"
"    iex> ~c(f\\#{:o}o)\n"
"    'f\\#{:o}o'\n"
"\n"
msgstr ""
"sigil ~cをハンドルします。\n"
"まるで一重引用苻付きの文字列であるかのように、文字のリストを\n"
"返します。そして文字のアンエスケープと、内挿の置き換えをします。\n"
"\n"
"## 例\n"
"\n"
"    iex> ~c(foo)\n"
"    'foo'\n"
"\n"
"    iex> ~c(f#{:o}o)\n"
"    'foo'\n"
"\n"
"    iex> ~c(f\\#{:o}o)\n"
"    'f\\#{:o}o'\n"
"\n"

#. TRANSLATORS: defmacro Kernel.sigil_W(term, modifiers)
#: lib/kernel.ex:3853
msgid ""
"Handles the sigil `~W`.\n"
"\n"
"It returns a list of \"words\" split by whitespace without escaping nor\n"
"interpreting interpolations.\n"
"\n"
"## Modifiers\n"
"\n"
"  * `s`: words in the list are strings (default)\n"
"  * `a`: words in the list are atoms\n"
"  * `c`: words in the list are char lists\n"
"\n"
"## Examples\n"
"\n"
"    iex> ~W(foo #{bar} baz)\n"
"    [\"foo\", \"\\#{bar}\", \"baz\"]\n"
"\n"
msgstr ""
"sigil ~Wをハンドルします。エスケープも内挿の解釈もすることなく、空白に\n"
"よって区切られた\"words\"のリストを返します。\n"
"\n"
"## モディファイア\n"
"\n"
"  * `s`: 文字列 (デフォルト)\n"
"  * `a`: アトム\n"
"  * `c`: 文字のリスト\n"
"\n"
"## 例\n"
"\n"
"    iex> ~W(foo #{bar} baz)\n"
"    [\"foo\", \"\\#{bar}\", \"baz\"]\n"
"\n"

#. TRANSLATORS: defmacro Kernel.sigil_S(term, modifiers)
#: lib/kernel.ex:3678
msgid ""
"Handles the sigil `~S`.\n"
"\n"
"It simply returns a string without escaping characters and without\n"
"interpolations.\n"
"\n"
"## Examples\n"
"\n"
"    iex> ~S(foo)\n"
"    \"foo\"\n"
"\n"
"    iex> ~S(f#{o}o)\n"
"    \"f\\#{o}o\"\n"
"\n"
msgstr ""
"sigil ~Sをハンドルします。エスケープも内挿の解釈もすることなく、単に文\n"
"字列を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> ~S(foo)\n"
"    \"foo\"\n"
"\n"
"    iex> ~S(f#{o}o)\n"
"    \"f\\#{o}o\"\n"
"\n"

#. TRANSLATORS: defmacro Kernel.sigil_R(term, modifiers)
#: lib/kernel.ex:3799
msgid ""
"Handles the sigil `~R`.\n"
"\n"
"It returns a regular expression pattern without escaping\n"
"nor interpreting interpolations.\n"
"\n"
"More information on regexes can be found in the `Regex` module.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.match?(~R(f#{1,3}o), \"f#o\")\n"
"    true\n"
"\n"
msgstr ""
"sigil ~Rをハンドルします。\n"
"\n"
"エスケープも内挿の解釈もすることなく、Regexパ\n"
"ターンを返します。\n"
"\n"
"正規表現については、`Regex`モジュールを参照してください。\n"
"\n"
"## 例\n"
"\n"
"    iex> Regex.match?(~R(f#{1,3}o), \"f#o\")\n"
"    true\n"
"\n"

#. TRANSLATORS: defmacro Kernel.sigil_C(term, modifiers)
#: lib/kernel.ex:3719
msgid ""
"Handles the sigil `~C`.\n"
"\n"
"It simply returns a char list without escaping characters and without\n"
"interpolations.\n"
"\n"
"## Examples\n"
"\n"
"    iex> ~C(foo)\n"
"    'foo'\n"
"\n"
"    iex> ~C(f#{o}o)\n"
"    'f\\#{o}o'\n"
"\n"
msgstr ""
"sigil ~Cをハンドルします。\n"
"\n"
"エスケープも内挿の解釈もすることなく、単に\n"
"文字のリストを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> ~C(foo)\n"
"    'foo'\n"
"\n"
"    iex> ~C(f#{o}o)\n"
"    'f\\#{o}o'\n"
"\n"

#. TRANSLATORS: defmacro Kernel.defprotocol(name, list)
#: lib/kernel.ex:3294
msgid ""
"Defines a protocol.\n"
"\n"
"A protocol specifies an API that should be defined by its\n"
"implementations.\n"
"\n"
"## Examples\n"
"\n"
"In Elixir, only `false` and `nil` are considered falsy values.\n"
"Everything else evaluates to `true` in `if` clauses. Depending\n"
"on the application, it may be important to specify a `blank?`\n"
"protocol that returns a boolean for other data types that should\n"
"be considered \"blank\". For instance, an empty list or an empty\n"
"binary could be considered blank.\n"
"\n"
"Such protocol could be implemented as follows:\n"
"\n"
"    defprotocol Blank do\n"
"      @doc \"Returns `true` if `data` is considered blank/empty\"\n"
"      def blank?(data)\n"
"    end\n"
"\n"
"Now that the protocol is defined it can be implemented. It needs to be\n"
"implemented for each Elixir type; for example:\n"
"\n"
"    # Integers are never blank\n"
"    defimpl Blank, for: Integer do\n"
"      def blank?(number), do: false\n"
"    end\n"
"\n"
"    # The only blank list is the empty one\n"
"    defimpl Blank, for: List do\n"
"      def blank?([]), do: true\n"
"      def blank?(_),  do: false\n"
"    end\n"
"\n"
"    # The only blank atoms are `false` and `nil`\n"
"    defimpl Blank, for: Atom do\n"
"      def blank?(false), do: true\n"
"      def blank?(nil),   do: true\n"
"      def blank?(_),     do: false\n"
"    end\n"
"\n"
"The implementation of the `Blank` protocol would need to be defined for all\n"
"Elixir types. The available types are:\n"
"\n"
"  * Structs (see below)\n"
"  * `Tuple`\n"
"  * `Atom`\n"
"  * `List`\n"
"  * `BitString`\n"
"  * `Integer`\n"
"  * `Float`\n"
"  * `Function`\n"
"  * `PID`\n"
"  * `Map`\n"
"  * `Port`\n"
"  * `Reference`\n"
"  * `Any` (see below)\n"
"\n"
"## Protocols and Structs\n"
"\n"
"The real benefit of protocols comes when mixed with structs.\n"
"For instance, Elixir ships with many data types implemented as\n"
"structs, like `HashDict` and `HashSet`. We can implement the\n"
"`Blank` protocol for those types as well:\n"
"\n"
"    defimpl Blank, for: [HashDict, HashSet] do\n"
"      def blank?(enum_like), do: Enum.empty?(enum_like)\n"
"    end\n"
"\n"
"When implementing a protocol for a struct, the `:for` option can be omitted "
"if\n"
"the `defimpl` call is inside the module that defines the struct:\n"
"\n"
"    defmodule User do\n"
"      defstruct [:email, :name]\n"
"\n"
"      defimpl Blank do\n"
"        def blank?(%User{}), do: false\n"
"      end\n"
"    end\n"
"\n"
"If a protocol is not found for a given type, it will fallback to\n"
"`Any`.\n"
"\n"
"## Fallback to any\n"
"\n"
"In some cases, it may be convenient to provide a default\n"
"implementation for all types. This can be achieved by\n"
"setting the `@fallback_to_any` attribute to `true` in the protocol\n"
"definition:\n"
"\n"
"    defprotocol Blank do\n"
"      @fallback_to_any true\n"
"      def blank?(data)\n"
"    end\n"
"\n"
"The `Blank` protocol can now be implemented for `Any`:\n"
"\n"
"    defimpl Blank, for: Any do\n"
"      def blank?(_), do: true\n"
"    end\n"
"\n"
"One may wonder why such behaviour (fallback to any) is not the default one.\n"
"\n"
"It is two-fold: first, the majority of protocols cannot\n"
"implement an action in a generic way for all types; in fact,\n"
"providing a default implementation may be harmful, because users\n"
"may rely on the default implementation instead of providing a\n"
"specialized one.\n"
"\n"
"Second, falling back to `Any` adds an extra lookup to all types,\n"
"which is unnecessary overhead unless an implementation for `Any` is\n"
"required.\n"
"\n"
"## Types\n"
"\n"
"Defining a protocol automatically defines a type named `t`, which\n"
"can be used as follows:\n"
"\n"
"    @spec present?(Blank.t) :: boolean\n"
"    def present?(blank) do\n"
"      not Blank.blank?(blank)\n"
"    end\n"
"\n"
"The `@spec` above expresses that all types allowed to implement the\n"
"given protocol are valid argument types for the given function.\n"
"\n"
"## Reflection\n"
"\n"
"Any protocol module contains three extra functions:\n"
"\n"
"  * `__protocol__/1` - returns the protocol name when `:name` is given, and "
"a\n"
"    keyword list with the protocol functions and their arities when\n"
"    `:functions` is given\n"
"\n"
"  * `impl_for/1` - receives a structure and returns the module that\n"
"    implements the protocol for the structure, `nil` otherwise\n"
"\n"
"  * `impl_for!/1` - same as above but raises an error if an implementation "
"is\n"
"    not found\n"
"\n"
"        Enumerable.__protocol__(:functions)\n"
"        #=> [count: 1, member?: 2, reduce: 3]\n"
"\n"
"        Enumerable.impl_for([])\n"
"        #=> Enumerable.List\n"
"\n"
"        Enumerable.impl_for(42)\n"
"        #=> nil\n"
"\n"
"## Consolidation\n"
"\n"
"In order to cope with code loading in development, protocols in\n"
"Elixir provide a slow implementation of protocol dispatching specific\n"
"to development.\n"
"\n"
"In order to speed up dispatching in production environments, where\n"
"all implementations are known up-front, Elixir provides a feature\n"
"called protocol consolidation. For this reason, all protocols are\n"
"compiled with `debug_info` set to `true`, regardless of the option\n"
"set by `elixirc` compiler. The debug info though may be removed\n"
"after consolidation.\n"
"\n"
"For more information on how to apply protocol consolidation to\n"
"a given project, please check the functions in the `Protocol`\n"
"module or the `mix compile.protocols` task.\n"
msgstr ""
"プロトコルを定義します。\n"
"\n"
"プロトコルは、その実装により定義されるべきAPIを、\n"
"指定します。\n"
"\n"
"## 例\n"
"\n"
"Elixirでは、`false`と`nil`だけが偽の値として考慮されます。`if`節の中で\n"
"は、その他全ては`true`に評価します。アプリケーションによっては、\n"
"`空白類?`と思わなければならない他のデータタイプの為にブーリアンを\n"
"返す、`blank?`プロトコルを指定することが重要かもしれません。\n"
"例えば、空のリストや空のバイナリは空白類と考えることができます。\n"
"\n"
"以下のようにこのプロトコルを実装できます:\n"
"\n"
"    defprotocol Blank do\n"
"      @doc \"Returns `true` if data is considered blank/empty\"\n"
"      def blank?(data)\n"
"    end\n"
"\n"
"プロトコルが定義された今、それを実装することができます。\n"
"それぞれのElixirタイプについてプロトコルを実装する必要があります。\n"
"例えば:\n"
"\n"
"    # Integers are never blank\\n\"\n"
"    defimpl Blank, for: Integer do\\n\"\n"
"      def blank?(number), do: false\\n\"\n"
"    end\\n\"\n"
"\n"
"    # The only blank list is the empty one\n"
"    defimpl Blank, for: List do\n"
"      def blank?([]), do: true\n"
"      def blank?(_),  do: false\n"
"    end\n"
"\n"
"    # The only blank atoms are `false` and `nil`\n"
"    defimpl Blank, for: Atom do\n"
"      def blank?(false), do: true\n"
"      def blank?(nil),   do: true\n"
"      def blank?(_),     do: false\n"
"    end\n"
"\n"
"そして、全てのタイプに実装を定義しなければなりません。\n"
"サポートされている有効なタイプは以下のとおりです:\n"
"\n"
"  * Structs (see below)\n"
"  * `Tuple`\n"
"  * `Atom`\n"
"  * `List`\n"
"  * `BitString`\n"
"  * `Integer`\n"
"  * `Float`\n"
"  * `Function`\n"
"  * `PID`\n"
"  * `Map`\n"
"  * `Port`\n"
"  * `Reference`\n"
"  * `Any` (see below)\n"
"\n"
"## Protocols and Structs\n"
"\n"
"プロトコルの本当の利点は構造体との組み合わせた時です。\n"
"例えば、Elixirは`HashDict`や`HashSet`のような構造体として\n"
"多くのデータタイプを提供しています。\n"
"それらのタイプのために`Blank`プロトコルを実装することが\n"
"できます:\n"
"\n"
"    defimpl Blank, for: [HashDict, HashSet] do\n"
"      def blank?(enum_like), do: Enum.empty?(enum_like)\n"
"    end\n"
"\n"
"構造体のためにプロトコルを実装するとき、その構造体を\n"
"定義しているモジュールの内側では、`:for`オプションを\n"
"省略できます。\n"
"\n"
"    defmodule User do\n"
"      defstruct [:email, :name]\n"
"\n"
"      defimpl Blank do\n"
"        def blank?(%User{}), do: false\n"
"      end\n"
"    end\n"
"\n"
"もしプロトコルが与えられたタイプに見付からないなら、`Any`に\n"
"フォールバックします。\n"
"\n"
"## Fallback to any\n"
"\n"
"いくつかの場合、全てのタイプの為のデフォルト実装を提供することが\n"
"便利かもしれません。これはプロトコル定義で、\n"
"`@fallback_to_any`を`true`にセットすることで達成できます:\n"
"\n"
"    defprotocol Blank do\n"
"      @fallback_to_any true\n"
"      def blank?(data)\n"
"    end\n"
"\n"
"今や、このように実装できます:\n"
"\n"
"    defimpl Blank, for: Any do\n"
"      def blank?(_), do: true\n"
"    end\n"
"\n"
"なぜ、デフォルトでそのようなフォールバックがtrueでないのか、\n"
"疑問に思うかもしれません。\n"
"\n"
"二つの理由があります: 第一に、大多数のプロトコルが\n"
"全てのタイプのために一般的な方法でアクションを実装することが\n"
"出来ません。実際、ユーザは専門のものを提供する代りに、デフォルト\n"
"実装に頼るかもしれないので、デフォルト実装を提供することは、有害であるかも\n"
"しれません。\n"
"\n"
"第二に、`Any`へのフォールバックは全てのデータタイプに余分の検索を追加し\n"
"ます。Anyの実装を必要とされない限り、それは不必要なオーバーヘッドです。\n"
"\n"
"## Types\n"
"\n"
"プロトコルを定義すると、自動的に`t`と呼ばれるタイプを定義します。\n"
"それは以下のように使うことができます:\n"
"\n"
"    @spec present?(Blank.t) :: boolean\n"
"    def present?(blank) do\n"
"      not Blank.blank?(blank)\n"
"    end\n"
"\n"
"上の`@spec`は、与えられたプロトコルを実装することを許された全てのタイプ\n"
"が、与えられた関数の有効な引数のタイプであることを、表します。\n"
"\n"
"## Reflection\n"
"\n"
"任意のプトロコルモジュールは3つの特別な関数を含みます:\n"
"\n"
"  * `__protocol__/1` - `:name`が与えられたらプロトコル名を返します。\n"
"    `:functions`が与えられたらプロトコルの関数のキーワードリストを返します\n"
"\n"
"  * `impl_for/1` - 構造体を受け取り、その構造体のプロトコルを実装した\n"
"    モジュールを返します。さもなければ`nil`を返します\n"
"\n"
"  * `impl_for!/1` - 上と同じですが、実装が見付からないときにエラーを上げます\n"
"\n"
"        Enumerable.__protocol__(:functions)\n"
"        #=> [count: 1, member?: 2, reduce: 3]\n"
"\n"
"        Enumerable.impl_for([])\n"
"        #=> Enumerable.List\n"
"\n"
"        Enumerable.impl_for(42)\n"
"        #=> nil\n"
"\n"
"## Consolidation\n"
"\n"
"開発においてコードローディングに対処するために、Elixirのプロトコルは\n"
"開発に特有の遲いプロトコルディスパッチ実装を提供します。\n"
"\n"
"プロダクション環境でディスパッチをスピードアップするために、\n"
"全ての実装は事前に知られているところで、Elixirはプロトコル強化と\n"
"呼ばれている機能を提供します。\n"
"このため、全てのプロトコルは、`elixirc`コンパイラに\n"
"よるオプションの設定に関わりなく、`debug_info`がtrueでコンパイルされます。\n"
"debug infoは強化の後で取り除かれます。\n"
"\n"
"どのようにプロトコル強化をプロジェクトに適用するかについての詳細は、\n"
"`Protocol`モジュールの関数か、`mix compile.protocols`タスクをチェックし\n"
"てください。\n"

#. TRANSLATORS: defmacro Kernel.defmacrop(call, expr \\ nil)
#: lib/kernel.ex:3069
msgid ""
"Defines a private macro with the given name and body.\n"
"\n"
"Private macros are only accessible from the same module in which they are\n"
"defined.\n"
"\n"
"Check `defmacro/2` for more information.\n"
"\n"
msgstr ""
"与えられた名前と内容で、プライベートマクロを定義します。\n"
"\n"
"プライベートマクロはそれが定義された同じモジュールから\n"
"のみアクセス可能です。\n"
"\n"
"詳細は `defmacro/2` をチェックしてください。\n"

#. TRANSLATORS: defmacro Kernel.defp(call, expr \\ nil)
#: lib/kernel.ex:3019
msgid ""
"Defines a private function with the given name and body.\n"
"\n"
"Private functions are only accessible from within the module in which they "
"are\n"
"defined. Trying to access a private function from outside the module it's\n"
"defined in results in an `UndefinedFunctionError` exception.\n"
"\n"
"Check `def/2` for more information.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Foo do\n"
"      def bar do\n"
"        sum(1, 2)\n"
"      end\n"
"\n"
"      defp sum(a, b), do: a + b\n"
"    end\n"
"\n"
"    Foo.bar #=> 3\n"
"    Foo.sum(1, 2) #=> ** (UndefinedFunctionError) undefined function: Foo."
"sum/2\n"
"\n"
msgstr ""
"与えられた名前と本体で、プライベート関数を定義します。\n"
"\n"
"プライベート関数は\n"
"それが定義された同じモジュールからのみアクセス可能です。\n"
"モジュールの外部からアクセスしようとすると、`UndefinedFunctionError`\n"
"例外となります。\n"
"\n"
"詳細は `def/2` をチェックしてください。\n"
"\n"
"## 例\n"
"\n"
"    defmodule Foo do\n"
"      def bar do\n"
"        sum(1, 2)\n"
"      end\n"
"\n"
"      defp sum(a, b), do: a + b\n"
"    end\n"
"\n"
"    Foo.bar #=> 3\n"
"    Foo.sum(1, 2) #=> ** (UndefinedFunctionError) undefined function: Foo.sum/2\n"
"\n"

#. TRANSLATORS: defmacro Kernel.defmodule(alias, list)
#: lib/kernel.ex:2781
msgid ""
"Defines a module given by name with the given contents.\n"
"\n"
"This macro defines a module with the given `alias` as its name and with the\n"
"given contents. It returns a tuple with four elements:\n"
"\n"
"  * `:module`\n"
"  * the module name\n"
"  * the binary contents of the module\n"
"  * the result of evaluating the contents block\n"
"\n"
"## Examples\n"
"\n"
"    iex> defmodule Foo do\n"
"    ...>   def bar, do: :baz\n"
"    ...> end\n"
"    iex> Foo.bar\n"
"    :baz\n"
"\n"
"## Nesting\n"
"\n"
"Nesting a module inside another module affects the name of the nested "
"module:\n"
"\n"
"    defmodule Foo do\n"
"      defmodule Bar do\n"
"      end\n"
"    end\n"
"\n"
"In the example above, two modules - `Foo` and `Foo.Bar` - are created.\n"
"When nesting, Elixir automatically creates an alias to the inner module,\n"
"allowing the second module `Foo.Bar` to be accessed as `Bar` in the same\n"
"lexical scope where it's defined (the `Foo` module).\n"
"\n"
"If the `Foo.Bar` module is moved somewhere else, the references to `Bar` in\n"
"the `Foo` module need to be updated to the fully-qualified name (`Foo.Bar`) "
"or\n"
"an alias has to be explicitly set in the `Foo` module with the help of\n"
"`Kernel.SpecialForms.alias/2`.\n"
"\n"
"    defmodule Foo.Bar do\n"
"      # code\n"
"    end\n"
"\n"
"    defmodule Foo do\n"
"      alias Foo.Bar\n"
"      # code here can refer to `Foo.Bar` as just `Bar`\n"
"    end\n"
"\n"
"## Module names\n"
"\n"
"A module name can be any atom, but Elixir provides a special syntax which "
"is\n"
"usually used for module names. What is called a module name is an\n"
"_uppercase ASCII letter_ followed by any number of _lowercase or\n"
"uppercase ASCII letters_, _numbers_, or _underscores_.\n"
"This identifier is equivilant to an atom prefixed by `Elixir.`. So in the\n"
"`defmodule Foo` example `Foo` is equivalent to `:\"Elixir.Foo\"`\n"
"\n"
"## Dynamic names\n"
"\n"
"Elixir module names can be dynamically generated. This is very\n"
"useful when working with macros. For instance, one could write:\n"
"\n"
"    defmodule String.to_atom(\"Foo#{1}\") do\n"
"      # contents ...\n"
"    end\n"
"\n"
"Elixir will accept any module name as long as the expression passed as the\n"
"first argument to `defmodule/2` evaluates to an atom.\n"
"Note that, when a dynamic name is used, Elixir won't nest the name under "
"the\n"
"current module nor automatically set up an alias.\n"
"\n"
msgstr ""
"与えられた名前とコンテンツのモジュールを定義します。\n"
"\n"
"このマクロは与えられた`alias`を名前として、\n"
"与えられたコンテンツのモジュールを定義します。\n"
"\n"
"以下の4要素タプルを返します。\n"
"\n"
"  * `:module`\n"
"  * モジュール名\n"
"  * モジュールのバイナリコンテンツ\n"
"  * コンテンツブロックの評価結果\n"
"\n"
"## 例\n"
"\n"
"    iex> defmodule Foo do\n"
"    ...>   def bar, do: :baz\n"
"    ...> end\n"
"    iex> Foo.bar\n"
"    :baz\n"
"\n"
"## ネスト\n"
"\n"
"もう一つのモジュールの中にモジュールをネストすることは、その名前に\n"
"影響を及ぼします:\n"
"\n"
"    defmodule Foo do\n"
"      defmodule Bar do\n"
"      end\n"
"    end\n"
"\n"
"上の例で、二つのモジュール`Foo`と`Foo.Bar`が作られます。\n"
"ネストするとき、Elixirは自動的にエイリアスを作ります。\n"
"そして、二つめのモジュール`Foo.Bar`が同じレキシカルスコープの\n"
"中で`Bar`としてアクセスされることを許します。\n"
"\n"
"これは、モジュール`Bar`が他のファイルに移動されるなら、`Bar`への参照は\n"
"更新される必要があること、または、`Kernel.SpecialForms.alias/2`の助けを\n"
"かりて、エイリアスを明示的にセットアップする必要があることを、意味しま\n"
"す。\n"
"\n"
"    defmodule Foo.Bar do\n"
"      # code\n"
"    end\n"
"\n"
"    defmodule Foo do\n"
"      alias Foo.Bar\n"
"      # code here can refer to `Foo.Bar` as just `Bar`\n"
"    end\n"
"\n"
"## モジュール名\n"
"\n"
"任意のatomがモジュール名に出来ますが、利便性のため、モジュール\n"
"名についてElixirは特別なシンタックスを提供しています。\n"
"\n"
"_大文字のASCII文字_ に続く、任意の数の _小文字または大文字のASCII文字_ 、\n"
"_数字_ あるいは _アンダースコア_ を文字ュール名と\n"
"しています。\n"
"このIDは`Elixir.`アトムプレフィックスが付けられたものと同等です。\n"
"つまり、`defmodule Foo`のFooは、`:\"Elixir.Foo\"`と同等です。\n"
"\n"
"## 動的な名前\n"
"\n"
"Elixirモジュール名は、動的に生成することができます。これは\n"
"マクロにとって、非常に便利です。例えば、このように畫けます:\n"
"\n"
"    defmodule String.to_atom(\"Foo#{1}\") do\n"
"      # contents ...\n"
"    end\n"
"\n"
"Elixirはアトムを返す限り、任意のモジュール名を受け入れます。なお、動的\n"
"な名前が使われるとき、Elixirは現在のモジュールの下で、名前のネストもし\n"
"ないし、自動的なエイリアスのセットアップもしません。\n"
"\n"

#. TRANSLATORS: defmacro Kernel.defmacro(call, expr \\ nil)
#: lib/kernel.ex:3046
msgid ""
"Defines a macro with the given name and body.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule MyLogic do\n"
"      defmacro unless(expr, opts) do\n"
"        quote do\n"
"          if !unquote(expr), unquote(opts)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    require MyLogic\n"
"    MyLogic.unless false do\n"
"      IO.puts \"It works\"\n"
"    end\n"
"\n"
msgstr ""
"与えられた名前とコンテンツでマクロを定義します。\n"
"\n"
"## 例\n"
"\n"
"    defmodule MyLogic do\n"
"      defmacro unless(expr, opts) do\n"
"        quote do\n"
"          if !unquote(expr), unquote(opts)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    require MyLogic\n"
"    MyLogic.unless false do\n"
"      IO.puts \"It works\"\n"
"    end\n"
"\n"

#. TRANSLATORS: defmacro Kernel.def(call, expr \\ nil)
#: lib/kernel.ex:2967
msgid ""
"Defines a function with the given name and body.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Foo do\n"
"      def bar, do: :baz\n"
"    end\n"
"\n"
"    Foo.bar #=> :baz\n"
"\n"
"A function that expects arguments can be defined as follows:\n"
"\n"
"    defmodule Foo do\n"
"      def sum(a, b) do\n"
"        a + b\n"
"      end\n"
"    end\n"
"\n"
"In the example above, a `sum/2` function is defined; this function receives\n"
"two arguments and returns their sum.\n"
"\n"
"## Function and variable names\n"
"\n"
"Function and variable names have the following syntax:\n"
"A _lowercase ASCII letter_ or an _underscore_, followed by any number of\n"
"_lowercase or uppercase ASCII letters_, _numbers_, or _underscores_.\n"
"Optionally they can end in either an _exclamation mark_ or a _question "
"mark_.\n"
"\n"
"For variables, any identifier starting with an underscore should indicate "
"an\n"
"unused variable. For example:\n"
"\n"
"    def foo(bar) do\n"
"      []\n"
"    end\n"
"    #=> warning: variable bar is unused\n"
"\n"
"    def foo(_bar) do\n"
"      []\n"
"    end\n"
"    #=> no warning\n"
"\n"
"    def foo(_bar) do\n"
"      _bar\n"
"    end\n"
"    #=> warning: the underscored variable \"_bar\" is used after being set\n"
"\n"
msgstr ""
"与えられた名前と本体で関数を定義します。\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Foo do\n"
"      def bar, do: :baz\n"
"    end\n"
"\n"
"    Foo.bar #=> :baz\n"
"\n"
"以下のように、引数を持つ関数を定義することができます:\n"
"\n"
"    defmodule Foo do\n"
"      def sum(a, b) do\n"
"        a + b\n"
"      end\n"
"    end\n"
"\n"
"上の例では、`sum/2`関数が定義されています。この関数は\n"
"二つの引数とその和を返します。\n"
"\n"
"## Function and variable names\n"
"\n"
"関数と変数名は以下のシンタックスを持っています:\n"
"_小文字のASCII文字_ または _アンダースコア_ に\n"
"任意の数の _小文字または大文字のASCII文字_ 、 _数字_ または\n"
"_アンダースコア_ です。\n"
"オプションで末尾に_感嘆符_ または _疑問符_ をつけることもできます。\n"
"\n"
"変数は、アンダースコアで初まる任意のものは\n"
"利用されない変数として識別されます。例えば: \n"
"\n"
"    def foo(bar) do\n"
"      []\n"
"    end\n"
"    #=> warning: variable bar is unused\n"
"\n"
"    def foo(_bar) do\n"
"      []\n"
"    end\n"
"    #=> no warning\n"
"\n"
"    def foo(_bar) do\n"
"      _bar\n"
"    end\n"
"    #=> warning: the underscored variable \"_bar\" is used after being set\n"
"\n"

#. TRANSLATORS: defmacro Kernel.defdelegate(funs, opts)
#: lib/kernel.ex:3615
msgid ""
"Defines a function that delegates to another module.\n"
"\n"
"Functions defined with `defdelegate/2` are public and can be invoked from\n"
"outside the module they're defined in (like if they were defined using\n"
"`def/2`). When the desire is to delegate as private functions, `import` "
"should\n"
"be used.\n"
"\n"
"Delegation only works with functions; delegating macros is not supported.\n"
"\n"
"## Options\n"
"\n"
"  * `:to` - the expression to delegate to. Any expression\n"
"    is allowed and its results will be evaluated at runtime. Usually\n"
"    evaluates to the name of a module.\n"
"\n"
"  * `:as` - the function to call on the target given in `:to`.\n"
"    This parameter is optional and defaults to the name being\n"
"    delegated (`funs`).\n"
"\n"
"  * `:append_first` - if `true`, when delegated, the first argument\n"
"    passed to the delegated function will be relocated to the end of the\n"
"    arguments when dispatched to the target.\n"
"\n"
"    The motivation behind this is because Elixir normalizes\n"
"    the \"handle\" as the first argument while some Erlang modules\n"
"    expect it as the last argument.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule MyList do\n"
"      defdelegate reverse(list), to: :lists\n"
"      defdelegate other_reverse(list), to: :lists, as: :reverse\n"
"      defdelegate [reverse(list), map(list, callback)], to: :lists, "
"append_first: true\n"
"    end\n"
"\n"
"    MyList.reverse([1, 2, 3])\n"
"    #=> [3, 2, 1]\n"
"\n"
"    MyList.other_reverse([1, 2, 3])\n"
"    #=> [3, 2, 1]\n"
"\n"
"    MyList.map([1, 2, 3], &(&1 * 2))\n"
"    #=> [2, 4, 6]\n"
"\n"
msgstr ""
"与えられた`target`へ移譲する、\n"
"現在のモジュールで与えられた関数を\n"
"定義します。\n"
"`defdelegate/2`で定義された関数は、\n"
"パブリックで、(`def/2`で定義されたように)\n"
"外部から起動することができます。\n"
"もしプライベートとして移譲を定義したいと\n"
"思うなら、importを代りに使うべきです。\n"
"\n"
"移譲は関数でのみ動きます。マクロの移譲はサポートしていません。\n"
"\n"
"## オプション\n"
"\n"
"  * `:to` -  移譲先の式。\n"
"    任意の式が許され、戻値は実行時に計算されます。\n"
"\n"
"  * `:as` -  `:to`で与えられたターゲットを呼ぶ関数です。\n"
"    このパラメタはオプションで、デフォルトは移譲された名前(`funs`)です。\n"
"\n"
"  * `:append_first` -  `true`なら、移譲されたとき、\n"
"    移譲先へ渡す最初の引数は、ターゲットへディスパッチするときに\n"
"    引数の最後に再配置されます。\n"
"\n"
"    この背後の動機は、\n"
"    Elixirは最初の引数として、\n"
"    いくつかのErlangモジュールが最後の\n"
"    引数として期待している\"handle\"を、正規化するからです。\n"
"\n"
"## Examples\n"
"\n"
"    defmodule MyList do\n"
"      defdelegate reverse(list), to: :lists\n"
"      defdelegate other_reverse(list), to: :lists, as: :reverse\n"
"      defdelegate [reverse(list), map(list, callback)], to: :lists, append_first: true\n"
"    end\n"
"\n"
"    MyList.reverse([1, 2, 3])\n"
"    #=> [3, 2, 1]\n"
"\n"
"    MyList.other_reverse([1, 2, 3])\n"
"    #=> [3, 2, 1]\n"
"\n"
"    MyList.map([1, 2, 3], &(&1 * 2))\n"
"    #=> [2, 4, 6]\n"
"\n"

#. TRANSLATORS: defmacro Kernel.destructure(left, right)
#: lib/kernel.ex:2360
msgid ""
"Destructures two lists, assigning each term in the\n"
"right one to the matching term in the left one.\n"
"\n"
"Unlike pattern matching via `=`, if the sizes of the left\n"
"and right lists don't match, destructuring simply stops\n"
"instead of raising an error.\n"
"\n"
"## Examples\n"
"\n"
"    iex> destructure([x, y, z], [1, 2, 3, 4, 5])\n"
"    iex> {x, y, z}\n"
"    {1, 2, 3}\n"
"\n"
"In the example above, even though the right list has more entries than the\n"
"left one, destructuring works fine. If the right list is smaller, the\n"
"remaining items are simply set to `nil`:\n"
"\n"
"    iex> destructure([x, y, z], [1])\n"
"    iex> {x, y, z}\n"
"    {1, nil, nil}\n"
"\n"
"The left-hand side supports any expression you would use\n"
"on the left-hand side of a match:\n"
"\n"
"    x = 1\n"
"    destructure([^x, y, z], [1, 2, 3])\n"
"\n"
"The example above will only work if `x` matches the first value in the "
"right\n"
"list. Otherwise, it will raise a `MatchError` (like the `=` operator would\n"
"do).\n"
msgstr ""
"二つのリストを非構造化することを許し、\n"
"右のそれぞれのtermを左にマッチングするtermに代入します。\n"
"`=`によるパターンマッチングと違って、右と左のリストの大きさが\n"
"一致していなくても、エラーを上げるかわりに\n"
"処理を単に停止します。\n"
"\n"
"## 例\n"
"\n"
"    iex> destructure([x, y, z], [1, 2, 3, 4, 5])\n"
"    iex> {x, y, z}\n"
"    {1, 2, 3}\n"
"\n"
"上の例で、左より右のサイズが大きいにも拘わらず、\n"
"destructureは正しく動くことに注意してください。\n"
"もし右の大きさが小さいなら、残ったアイテムは単に\n"
"`nil`が代入されます:\n"
"\n"
"    iex> destructure([x, y, z], [1])\n"
"    iex> {x, y, z}\n"
"    {1, nil, nil}\n"
"\n"
"左側は、マッチの左辺で使うことができる、\n"
"任意の式をサポートします:\n"
"\n"
"    x = 1\n"
"    destructure([^x, y, z], [1, 2, 3])\n"
"\n"
"上の例は x が右側からの最初の値とマッチする場合のみ\n"
"動作します。さもなければ(`=`オペレータが\n"
"そうするように)`MatchError`を上げます。\n"

#. TRANSLATORS: defmacro Kernel.defimpl(name, opts, do_block \\ [])
#: lib/kernel.ex:3466
msgid ""
"Defines an implementation for the given protocol.\n"
"\n"
"See `defprotocol/2` for more information and examples on protocols.\n"
"\n"
"Inside an implementation, the name of the protocol can be accessed\n"
"via `@protocol` and the current target as `@for`.\n"
msgstr ""
"与えられたプロトコルの実装を定義します。\n"
"\n"
"例は`defprotocol/2`を参照してください。\n"
"\n"
"実装の中で、プロトコルの名前は`@protocol`でアクセスでき、\n"
"現在のターゲットは`@for`でアクセスできます。\n"

#. TRANSLATORS: defmacro Kernel.defexception(fields)
#: lib/kernel.ex:3209
msgid ""
"Defines an exception.\n"
"\n"
"Exceptions are structs backed by a module that implements\n"
"the `Exception` behaviour. The `Exception` behaviour requires\n"
"two functions to be implemented:\n"
"\n"
"  * `exception/1` - receives the arguments given to `raise/2`\n"
"    and returns the exception struct. The default implementation\n"
"    accepts either a set of keyword arguments that is merged into\n"
"    the struct or a string to be used as the exception's message.\n"
"\n"
"  * `message/1` - receives the exception struct and must return its\n"
"    message. Most commonly exceptions have a message field which\n"
"    by default is accessed by this function. However, if an exception\n"
"    does not have a message field, this function must be explicitly\n"
"    implemented.\n"
"\n"
"Since exceptions are structs, the API supported by `defstruct/1`\n"
"is also available in `defexception/1`.\n"
"\n"
"## Raising exceptions\n"
"\n"
"The most common way to raise an exception is via `raise/2`:\n"
"\n"
"    defmodule MyAppError do\n"
"      defexception [:message]\n"
"    end\n"
"\n"
"    value = [:hello]\n"
"\n"
"    raise MyAppError,\n"
"      message: \"did not get what was expected, got: #{inspect value}\"\n"
"\n"
"In many cases it is more convenient to pass the expected value to\n"
"`raise/2` and generate the message in the `exception/1` callback:\n"
"\n"
"    defmodule MyAppError do\n"
"      defexception [:message]\n"
"\n"
"      def exception(value) do\n"
"        msg = \"did not get what was expected, got: #{inspect value}\"\n"
"        %MyAppError{message: msg}\n"
"      end\n"
"    end\n"
"\n"
"    raise MyAppError, value\n"
"\n"
"The example above shows the preferred strategy for customizing\n"
"exception messages.\n"
"\n"
msgstr ""
"例外を定義します。\n"
"\n"
"例外は、`Exception`ビヘイビアを実装するモジュールで支持される、\n"
"構造体です。\n"
"`Exception`ビヘイビアは二つの関数の実装を要求します:\n"
"\n"
"  * `exception/1` -  `raise/2`へ与えられる引数を受けて、\n"
"     例外構造体を返します。デフォルト実装は、構造体に\n"
"     合併される、一組のキーワード引数を受け入れます。\n"
"\n"
"  * `message/1` -  例外構造体を受けて、そのメッセージを\n"
"     返さなければなりません。最も一般的な例外は、\n"
"     この関数によってデフォルトでアクセスされるメッセージ\n"
"     フィールドを持ちます。しかしながら、\n"
"     例外がメッセージフィールドを持っていないなら、\n"
"     この関数は明示的に実装されなければなりません。\n"
"\n"
"例外は構造体なので、`defstruct/1`によりサポートされる\n"
"全てのAPIもまた`defexception/1`で有効です。\n"
"\n"
"## Raising exceptions\n"
"\n"
"例外を上げる最も一般的な方法は、`raise/2`関数によってです:\n"
"\n"
"    defmodule MyAppError do\n"
"      defexception [:message]\n"
"    end\n"
"\n"
"    value = [:hello]\n"
"\n"
"    raise MyAppError,\n"
"      message: \"did not get what was expected, got: #{inspect value}\"\n"
"\n"
"多くの場合、`raise/2`に期待される値を渡し、\n"
"`exception/1`コールバックにおいてメッセージを生成することは、\n"
"より便利です:\n"
"\n"
"    defmodule MyAppError do\n"
"      defexception [:message]\n"
"\n"
"      def exception(value) do\n"
"        msg = \"did not get what was expected, got: #{inspect value}\"\n"
"        %MyAppError{message: msg}\n"
"      end\n"
"    end\n"
"\n"
"    raise MyAppError, value\n"
"\n"
"上の例は、例外メッセージをカスタマイズするための好ましいメカニズムです。\n"

#. TRANSLATORS: defmacro Kernel.defstruct(fields)
#: lib/kernel.ex:3100
msgid ""
"Defines a struct.\n"
"\n"
"A struct is a tagged map that allows developers to provide\n"
"default values for keys, tags to be used in polymorphic\n"
"dispatches and compile time assertions.\n"
"\n"
"The only thing needed to define a struct is a `__struct__/0` function that\n"
"returns a map with the struct fields and their default values. "
"`defstruct/1`\n"
"is a convenience macro which defines such a function (as well as a `t` type\n"
"and deriving conveniences).\n"
"\n"
"When using `defstruct/1`, a struct named like the enclosing module is "
"defined.\n"
"\n"
"For more information about structs, please check `Kernel.SpecialForms.%/2`.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule User do\n"
"      defstruct name: nil, age: nil\n"
"    end\n"
"\n"
"Struct fields are evaluated at compile-time, which allows\n"
"them to be dynamic. In the example below, `10 + 11` is\n"
"evaluated at compile-time and the age field is stored\n"
"with value `21`:\n"
"\n"
"    defmodule User do\n"
"      defstruct name: nil, age: 10 + 11\n"
"    end\n"
"\n"
"The `fields` argument is usually a keyword list with fields as keys and\n"
"default values as corresponding values. `defstruct/1` also supports a list "
"of\n"
"atoms as its argument: in that case, the atoms in the list will be used as\n"
"the struct's fields and they will all default to `nil`.\n"
"\n"
"    defmodule Post do\n"
"      defstruct [:title, :content, :author]\n"
"    end\n"
"\n"
"## Deriving\n"
"\n"
"Although structs are maps, by default structs do not implement\n"
"any of the protocols implemented for maps. For example, attempting\n"
"to use a protocol with the `User` struct leads to an error:\n"
"\n"
"    john = %User{name: \"John\"}\n"
"    MyProtocol.call(john)\n"
"    ** (Protocol.UndefinedError) protocol MyProtocol not implemented for "
"%User{...}\n"
"\n"
"`defstruct/1`, however, allows protocol implementations to be\n"
"*derived*. This can be done by defining a `@derive` attribute as a\n"
"list before invoking `defstruct/1`:\n"
"\n"
"    defmodule User do\n"
"      @derive [MyProtocol]\n"
"      defstruct name: nil, age: 10 + 11\n"
"    end\n"
"\n"
"    MyProtocol.call(john) #=> works\n"
"\n"
"For each protocol in the `@derive` list, Elixir will assert there is an\n"
"implementation of that protocol for any (regardless if fallback to any\n"
"is `true`) and check if the any implementation defines a `__deriving__/3`\n"
"callback. If so, the callback is invoked, otherwise an implementation\n"
"that simply points to the any implementation is automatically derived.\n"
"\n"
"## Types\n"
"\n"
"It is recommended to define types for structs. By convention such type\n"
"is called `t`. To define a struct inside a type, the struct literal syntax\n"
"is used:\n"
"\n"
"    defmodule User do\n"
"      defstruct name: \"John\", age: 25\n"
"      @type t :: %User{name: String.t, age: non_neg_integer}\n"
"    end\n"
"\n"
"It is recommended to only use the struct syntax when defining the struct's\n"
"type. When referring to another struct it's better to use `User.t`instead "
"of\n"
"`%User{}`.\n"
"\n"
"The types of the struct fields that are not included in the struct's type\n"
"default to `term`.\n"
"\n"
"Structs whose internal structure is private to the local module (pattern\n"
"matching them or directly accessing their fields should not be allowed) "
"should\n"
"use the `@opaque` attribute. Structs whose internal structure is public "
"should\n"
"use `@type`. See `Kernel.Typespec` for more information on opaque types.\n"
"\n"
msgstr ""
"構造体を定義します。\n"
"\n"
"構造体はタグ付けされたマップです。それは、開発者に、\n"
"キーにデフォルト値と、ポリモーフィックディスパッチに\n"
"使われるタグ、そしてコンパイル時のアサーションを提供します。\n"
"\n"
"構造体を定義するために、開発者は構造体のフィールドを\n"
"マップで返す、`__struct__/0`という名前の関数を定義する\n"
"ことだけが必要です。このマクロは、その関数の定義に便利で、\n"
"タイプ`t`と派生する便利さを追加します。\n"
"\n"
"`defstruct/1`を使うとき、名前は囲んでいるモジュール名で\n"
"定義されます。\n"
"\n"
"構造体についての詳細は、`Kernel.SpecialForms.%/2`\n"
"をチェックしてください。\n"
"\n"
"## 例\n"
"\n"
"    defmodule User do\n"
"      defstruct name: nil, age: nil\n"
"    end\n"
"\n"
"構造体のフィールドは定義時に評価されます。そしてそれは\n"
"動的であることを許します。下の例では、`10 + 11`はコンパイル時に\n"
"評価され、ageフィールドは値`21`が格納されます:\n"
"\n"
"    defmodule User do\n"
"      defstruct name: nil, age: 10 + 11\n"
"    end\n"
"\n"
"`fields`引数はキーとして使われるフィールドとデフォルト値から\n"
"なるキーワードリストです。`defstruct/1`は引数としてアトムの\n"
"リストもサポートしています: この場合、アトムは構造体のフィールド\n"
"で、全てのデフォルト値は`nil`となります。\n"
"\n"
"    defmodule Post do\n"
"      defstruct [:title, :content, :author]\n"
"    end\n"
"\n"
"## Deriving\n"
"\n"
"構造体はマップですが、デフォルトでは、構造体はマップが\n"
"実装しているプロトコルをなにも実装していません。例えば、\n"
"User構造体でAccessプロトコルを使おうとすると、エラーに\n"
"なります:\n"
"\n"
"    john = %User{name: \"John\"}\n"
"    MyProtocol.call(john)\n"
"    ** (Protocol.UndefinedError) protocol MyProtocol not implemented for %User{...}\n"
"\n"
"しかしながら、`defstruct/1`は *継承* された実装を\n"
"許します。これは、`defstruct/1`が起動される前に\n"
"`@derive`属性をリストすると、それらを複製して\n"
"定義されることによってなされます:\n"
"\n"
"    defmodule User do\n"
"      @derive [MyProtocol]\n"
"      defstruct name: nil, age: 10 + 11\n"
"    end\n"
"\n"
"    MyProtocol.call(john) #=> works\n"
"\n"
"`@derive`に与えられるそれぞれのプロトコル毎に、Elixirは\n"
"それがマップのためのプロトコルであると主張して、\n"
"マップ実装が`__deriving__/3`コールバックを定義しているかどうかを\n"
"チェックします。\n"
"もしそうならコールバックは起動され、さもなければ、単にマップの\n"
"実装が、自動的に引き出されます。\n"
"\n"
"## Types\n"
"\n"
"構造体のタイプを定義することが推奨され、慣例により、このタイプは`t`と呼\n"
"ばれます。構造体のタイプを定義するために、構造体リテラル構文が\n"
"使われます:\n"
"\n"
"    defmodule User do\n"
"      defstruct name: \"john\", age: 25\n"
"      @type t :: %User{name: String.t, age: integer}\n"
"    end\n"
"\n"
"構造体タイプを定義するときに、構造構文を使うことだけが推奨されています。\n"
"他の構造体を参照する時は、`%User{}`ではなく、`User.t`を使ってください。\n"
"タイプを含まない構造体のフィールドはデフォルトの`term`になります。\n"
"\n"
"そのモジュールの外で使われないプライベートな構造体は、\n"
"プライベートタイプ属性`@typep`を使うべきです。\n"
"パターンマッチや、直接フィールドへのアクセスを許さない、ローカル\n"
"モジュールに内部構造がプライベートであるパブリック構造体は、\n"
"`@opaque`属性を使うべきです。\n"
"内部構造がパブリックである構造体は`@type`を使うべきです。\n"
"opaqueタイプについての詳細は、`Kernel.Typespec`を参照してください。\n"

#. TRANSLATORS: def Kernel.struct(struct, kv \\ [])
#: lib/kernel.ex:1557
msgid ""
"Creates and updates structs.\n"
"\n"
"The `struct` argument may be an atom (which defines `defstruct`)\n"
"or a `struct` itself. The second argument is any `Enumerable` that\n"
"emits two-item tuples (key-value pairs) during enumeration.\n"
"\n"
"Keys in the `Enumerable` that don't exist in the struct are automatically\n"
"discarded.\n"
"\n"
"This function is useful for dynamically creating and updating\n"
"structs, as well as for converting maps to structs; in the latter case, "
"just\n"
"inserting the appropriate `:__struct__` field into the map may not be "
"enough\n"
"and `struct/2` should be used instead.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule User do\n"
"      defstruct name: \"john\"\n"
"    end\n"
"\n"
"    struct(User)\n"
"    #=> %User{name: \"john\"}\n"
"\n"
"    opts = [name: \"meg\"]\n"
"    user = struct(User, opts)\n"
"    #=> %User{name: \"meg\"}\n"
"\n"
"    struct(user, unknown: \"value\")\n"
"    #=> %User{name: \"meg\"}\n"
"\n"
"    struct(User, %{name: \"meg\"})\n"
"    #=> %User{name: \"meg\"}\n"
"\n"
msgstr ""
"構造体を作成し、更新します。\n"
"\n"
"struct引数は(`defstruct`で定義された)アトムか、構造体自身です。\n"
"2番目の引数は、列挙のあいだ任意の2アイテムのタプル(キーバリュー)を\n"
"発するEnumerableです。\n"
"\n"
"Enumerableの中のキーの一つが構造体に存在しないなら、それは自動的に\n"
"捨てられます。\n"
"\n"
"この関数は、動的に構造体を作成し更新したり、\n"
"mapと構造体との変換したりに便利です。\n"
"後者の場合、単に`:__struct__`フィールドをmapに\n"
"挿入するだけでは十分ではないかもしれず、`struct/2`を代わりに\n"
"使うべきです。\n"
"\n"
"## 例\n"
"\n"
"    defmodule User do\n"
"      defstruct name: \"john\"\n"
"    end\n"
"\n"
"    struct(User)\n"
"    #=> %User{name: \"john\"}\n"
"\n"
"    opts = [name: \"meg\"]\n"
"    user = struct(User, opts)\n"
"    #=> %User{name: \"meg\"}\n"
"\n"
"    struct(user, unknown: \"value\")\n"
"    #=> %User{name: \"meg\"}\n"
"\n"

#. TRANSLATORS: defmacro Kernel.to_string(arg)
#: lib/kernel.ex:1974
msgid ""
"Converts the argument to a string according to the\n"
"`String.Chars` protocol.\n"
"\n"
"This is the function invoked when there is string interpolation.\n"
"\n"
"## Examples\n"
"\n"
"    iex> to_string(:foo)\n"
"    \"foo\"\n"
"\n"
msgstr ""
"`String.Chars`プロトコルに従って、引数を文字列に変換します。\n"
"\n"
"これは、文字列展開がある時、起動される関数です。\n"
"\n"
"## 例\n"
"\n"
"    iex> to_string(:foo)\n"
"    \"foo\"\n"
"\n"

#. TRANSLATORS: defmacro Kernel.to_char_list(arg)
#: lib/kernel.ex:1993
msgid ""
"Converts the argument to a char list according to the `List.Chars` "
"protocol.\n"
"\n"
"## Examples\n"
"\n"
"    iex> to_char_list(:foo)\n"
"    'foo'\n"
"\n"
msgstr ""
"引数をList.Charsプロトコルに従って、リストに変換します。\n"
"\n"
"## 例\n"
"\n"
"    iex> to_char_list(:foo)\n"
"    'foo'\n"
"\n"

#. TRANSLATORS: def Kernel.rem(left, right)
#: lib/kernel.ex:556
msgid ""
"Computes the remainder of an integer division.\n"
"\n"
"Raises an `ArithmeticError` exception if one of the arguments is not an\n"
"integer.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> rem(5, 2)\n"
"    1\n"
"\n"
msgstr ""
"整数で割った余りを計算します。\n"
"\n"
"引数の一つが整数でないなら、`ArithmeticError`例外を上げます。\n"
"\n"
"ガードテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> rem(5, 2)\n"
"    1\n"
"\n"

#. TRANSLATORS: defmacro Kernel.in(left, right)
#: lib/kernel.ex:2609
msgid ""
"Checks if the element on the left-hand side is a member of the\n"
"collection on the right-hand side.\n"
"\n"
"## Examples\n"
"\n"
"    iex> x = 1\n"
"    iex> x in [1, 2, 3]\n"
"    true\n"
"\n"
"This operator (which is a macro) simply translates to a call to\n"
"`Enum.member?/2`. The example above would translate to:\n"
"\n"
"    Enum.member?([1, 2, 3], x)\n"
"\n"
"## Guards\n"
"\n"
"The `in` operator can be used in guard clauses as long as the\n"
"right-hand side is a range or a list. In such cases, Elixir will expand the\n"
"operator to a valid guard expression. For example:\n"
"\n"
"    when x in [1, 2, 3]\n"
"\n"
"translates to:\n"
"\n"
"    when x === 1 or x === 2 or x === 3\n"
"\n"
"When using ranges:\n"
"\n"
"    when x in 1..3\n"
"\n"
"translates to:\n"
"\n"
"    when x >= 1 and x <= 3\n"
"\n"
msgstr ""
"左辺の要素が、右辺のコレクションのメンバであるかを\n"
"チェックします。\n"
"\n"
"## 例\n"
"\n"
"    iex> x = 1\n"
"    iex> x in [1, 2, 3]\n"
"    true\n"
"\n"
"このオペレータ(マクロ)は、単に上の式を`Enum.member?/2`の\n"
"呼出しに展開します。上の例は、以下に変換されます:\n"
"\n"
"    Enum.member?([1,2,3], x)\n"
"\n"
"## ガード\n"
"\n"
"`in`オペレータは、右辺が範囲(range)かリストであるかぎり、\n"
"ガード節で使うことができます。Elixirはそのオペレータを\n"
"有効なガード式に展開します。例えば:\n"
"\n"
"    when x in [1,2,3]\n"
"\n"
"は以下のように展開します:\n"
"\n"
"    when x === 1 or x === 2 or x === 3\n"
"\n"
"範囲(range)を使うとき:\n"
"\n"
"    when x in 1..3\n"
"\n"
"は以下のように展開します:\n"
"\n"
"    when x >= 1 and x <= 3\n"
"\n"

#. TRANSLATORS: def Kernel.+(value)
#: lib/kernel.ex:841
msgid ""
"Arithmetic unary plus.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> +1\n"
"    1\n"
"\n"
msgstr ""
"算術的単項プラスです。\n"
"\n"
"ガードテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> +1\n"
"    1\n"
"\n"

#. TRANSLATORS: def Kernel.-(value)
#: lib/kernel.ex:857
msgid ""
"Arithmetic unary minus.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> -2\n"
"    -2\n"
"\n"
msgstr ""
"算術的単項マイナスです。\n"
"\n"
"ガードテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> -2\n"
"    -2\n"
"\n"

#. TRANSLATORS: def Kernel.-(left, right)
#: lib/kernel.ex:825
msgid ""
"Arithmetic subtraction.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 - 2\n"
"    -1\n"
"\n"
msgstr ""
"算術的減算です。\n"
"\n"
"ガードテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> 1 - 2\n"
"    -1\n"
"\n"

#. TRANSLATORS: def Kernel.*(left, right)
#: lib/kernel.ex:873
msgid ""
"Arithmetic multiplication.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 * 2\n"
"    2\n"
"\n"
msgstr ""
"算術的乗算です。\n"
"\n"
"ガードテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> 1 * 2\n"
"    2\n"
"\n"

#. TRANSLATORS: def Kernel./(left, right)
#: lib/kernel.ex:889
msgid ""
"Arithmetic division.\n"
"\n"
"The result is always a float. Use `div/2` and `rem/2` if you want\n"
"an integer division or the remainder.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 / 2\n"
"    0.5\n"
"\n"
"    iex> 2 / 1\n"
"    2.0\n"
"\n"
msgstr ""
"算術的除算です。\n"
"\n"
"結果は常に浮動小数点数です。自然数の除算と余りには、\n"
"`div/2`と`rem/2`を使ってください。\n"
"\n"
"ガードテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> 1 / 2\n"
"    0.5\n"
"\n"
"    iex> 2 / 1\n"
"    2.0\n"
"\n"

#. TRANSLATORS: def Kernel.+(left, right)
#: lib/kernel.ex:809
msgid ""
"Arithmetic addition.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 + 2\n"
"    3\n"
"\n"
msgstr ""
"算術的加算です。\n"
"\n"
"ガードテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> 1 + 2\n"
"    3\n"
"\n"

#. TRANSLATORS: def Kernel.++(left, right)
#: lib/kernel.ex:911
msgid ""
"Concatenates two lists.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> [1] ++ [2, 3]\n"
"    [1, 2, 3]\n"
"\n"
"    iex> 'foo' ++ 'bar'\n"
"    'foobar'\n"
"\n"
msgstr ""
"二つのリストを連結します。\n"
"\n"
"ガードテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> [1] ++ [2, 3]\n"
"    [1,2,3]\n"
"\n"
"    iex> 'foo' ++ 'bar'\n"
"    'foobar'\n"
"\n"

#. TRANSLATORS: defmacro Kernel.<>(left, right)
#: lib/kernel.ex:1254
msgid ""
"Concatenates two binaries.\n"
"\n"
"## Examples\n"
"\n"
"    iex> \"foo\" <> \"bar\"\n"
"    \"foobar\"\n"
"\n"
"The `<>` operator can also be used in pattern matching (and guard clauses) "
"as\n"
"long as the first part is a literal binary:\n"
"\n"
"    iex> \"foo\" <> x = \"foobar\"\n"
"    iex> x\n"
"    \"bar\"\n"
"\n"
"`x <> \"bar\" = \"foobar\"` would have resulted in a `CompileError` "
"exception.\n"
"\n"
msgstr ""
"二つのバイナリを連結します。\n"
"\n"
"## 例\n"
"\n"
"    iex> \"foo\" <> \"bar\"\n"
"    \"foobar\"\n"
"\n"
"`<>`演算子は最初の部分がリテラルバイナリである限り、\n"
"ガード節で使うこともできます:\n"
"\n"
"    iex> \"foo\" <> x = \"foobar\"\n"
"    iex> x\n"
"    \"bar\"\n"
"\n"
"`x <> \"bar\" = \"foobar\"`は`CompileError`例外となります。\n"

#. TRANSLATORS: defmacro Kernel.or(left, right)
#: lib/kernel.ex:1170
msgid ""
"Boolean or.\n"
"\n"
"If the first argument is `true`, `true` is returned; otherwise, the second\n"
"argument is returned.\n"
"\n"
"Requires only the first argument to be a boolean since it short-circuits.\n"
"If the first argument is not a boolean, an `ArgumentError` exception is\n"
"raised.\n"
"\n"
"Allowed in guard tests.\n"
"\n"
"## Examples\n"
"\n"
"    iex> true or false\n"
"    true\n"
"    iex> false or 42\n"
"    42\n"
"\n"
msgstr ""
"ブール代数のor です。\n"
"\n"
"最初の引数が`true`なら`true`を返します; さもなくば、二つめの\n"
"引数が返されます。\n"
"\n"
"ショートサーキットなので、booleanであることを最初の引数だけに\n"
"要求します。\n"
"\n"
"もし最初の引数がbooleanでないなら、`ArgumentError`例外が上ります。\n"
"\n"
"ガードテストで使えます。\n"
"\n"
"## 例\n"
"\n"
"    iex> true or false\n"
"    true\n"
"    iex> false or 42\n"
"    42\n"
"\n"

#. TRANSLATORS: def Kernel.not(arg)
#: lib/kernel.ex:950
msgid ""
"Boolean not.\n"
"\n"
"`arg` must be a boolean; if it's not, an `ArgumentError` exception is "
"raised.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> not false\n"
"    true\n"
"\n"
msgstr ""
"ブール代数のnot です。\n"
"\n"
"`arg`はbooleanでなくてはなりません; さもなくば、`ArgumentError`例外が\n"
"上ります。\n"
"\n"
"ガードテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> not false\n"
"    true\n"
"\n"

#. TRANSLATORS: defmacro Kernel.!(arg)
#: lib/kernel.ex:1217
msgid ""
"Boolean not.\n"
"\n"
"Receives any argument (not just booleans) and returns `true` if the "
"argument\n"
"is `false` or `nil`; returns `false` otherwise.\n"
"\n"
"Not allowed in guard clauses.\n"
"\n"
"## Examples\n"
"\n"
"    iex> !Enum.empty?([])\n"
"    false\n"
"\n"
"    iex> !List.first([])\n"
"    true\n"
"\n"
msgstr ""
"ブール代数のnot です。\n"
"\n"
"(booleanでなくとも)任意の引数を受け取って、\n"
"`false`あるいは`nil`以外なら`true`を返します。\n"
"さもなくば`false`を返します。\n"
"\n"
"ガード節での使用は許されません。\n"
"\n"
"## 例\n"
"\n"
"    iex> !Enum.empty?([])\n"
"    false\n"
"\n"
"    iex> !List.first([])\n"
"    true\n"
"\n"

#. TRANSLATORS: defmacro Kernel.and(left, right)
#: lib/kernel.ex:1194
msgid ""
"Boolean and.\n"
"\n"
"If the first argument is `false`, `false` is returned; otherwise, the "
"second\n"
"argument is returned.\n"
"\n"
"Requires only the first argument to be a boolean since it short-circuits. "
"If\n"
"the first argument is not a boolean, an `ArgumentError` exception is "
"raised.\n"
"\n"
"Allowed in guard tests.\n"
"\n"
"## Examples\n"
"\n"
"    iex> true and false\n"
"    false\n"
"    iex> true and \"yay!\"\n"
"    \"yay!\"\n"
"\n"
msgstr ""
"ブール代数のand です。\n"
"\n"
"最初の引数が`false`なら`false`を返します; さもなくば、二つめの\\n\"\n"
"引数が返されます。\n"
"\n"
"ショートサーキットなので、booleanであることを最初の引数だけに\n"
"要求します。\n"
"もし最初の引数がbooleanでないなら、`ArgumentError`例外が上ります。\n"
"\n"
"ガードテストで使えます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> true and false\n"
"    false\n"
"    iex> true and \"yay!\"\n"
"    \"yay!\"\n"
"\n"

#. TRANSLATORS: def Kernel.trunc(number)
#: lib/kernel.ex:773
msgid ""
"Returns the integer part of `number`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> trunc(5.4)\n"
"    5\n"
"    iex> trunc(5.99)\n"
"    5\n"
"\n"
msgstr ""
"`number`の整数部分を返します。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> trunc(5.5)\n"
"    5\n"
"\n"

#. TRANSLATORS: def Kernel.hd(list)
#: lib/kernel.ex:244
msgid ""
"Returns the head of a list; raises `ArgumentError` if the list is empty.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> hd([1, 2, 3, 4])\n"
"    1\n"
"\n"
msgstr ""
"リストの先頭(ヘッド)を返します;\n"
"もしリストが空なら`ArgumentError`を上げます。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> hd([1, 2, 3, 4])\n"
"    1\n"
"\n"

#. TRANSLATORS: def Kernel.throw(term)
#: lib/kernel.ex:748
msgid ""
"A non-local return from a function. Check `Kernel.SpecialForms.try/1` for "
"more information.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"関数から非ローカルに戻ります。\n"
"詳細は`Kernel.SpecialForms.try/1`をチェックしてください。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: defmacro Kernel.match?(pattern, expr)
#: lib/kernel.ex:2024
msgid ""
"A convenience macro that checks if the right side (an expression) matches "
"the\n"
"left side (a pattern).\n"
"\n"
"## Examples\n"
"\n"
"    iex> match?(1, 1)\n"
"    true\n"
"\n"
"    iex> match?(1, 2)\n"
"    false\n"
"\n"
"    iex> match?({1, _}, {1, 2})\n"
"    true\n"
"\n"
"    iex> map = %{a: 1, b: 2}\n"
"    iex> match?(%{a: _}, map)\n"
"    true\n"
"\n"
"    iex> a = 1\n"
"    iex> match?(^a, 1)\n"
"    true\n"
"\n"
"`match?/2` is very useful when filtering of finding a value in an "
"enumerable:\n"
"\n"
"    list = [{:a, 1}, {:b, 2}, {:a, 3}]\n"
"    Enum.filter list, &match?({:a, _}, &1)\n"
"    #=> [{:a, 1}, {:a, 3}]\n"
"\n"
"Guard clauses can also be given to the match:\n"
"\n"
"    list = [{:a, 1}, {:b, 2}, {:a, 3}]\n"
"    Enum.filter list, &match?({:a, x} when x < 2, &1)\n"
"    #=> [{:a, 1}]\n"
"\n"
"However, variables assigned in the match will not be available\n"
"outside of the function call (unlike regular pattern matching with the `=`\n"
"operator):\n"
"\n"
"    iex> match?(_x, 1)\n"
"    true\n"
"    iex> binding()\n"
"    []\n"
"\n"
msgstr ""
"右辺(式)が左辺(パターン)にマッチするかどうかをチェックする、便利なマクロです。\n"
"\n"
"## Examples\n"
"\n"
"    iex> match?(1, 1)\n"
"    true\n"
"\n"
"    iex> match?(1, 2)\n"
"    false\n"
"\n"
"    iex> match?({1, _}, {1, 2})\n"
"    true\n"
"\n"
"    iex> map = %{a: 1, b: 2}\n"
"    iex> match?(%{a: _}, map)\n"
"    true\n"
"\n"
"    iex> a = 1\n"
"    iex> match?(^a, 1)\n"
"    true\n"
"\n"
"enumerableの中の値をフィルタするまたは、見付けるために`match/2`を\n"
"使うこともできます:\n"
"\n"
"    list = [{:a, 1}, {:b, 2}, {:a, 3}]\n"
"    Enum.filter list, &match?({:a, _}, &1)\n"
"    #=> [{:a, 1}, {:a, 3}]\n"
"\n"
"ガード節もまたmatchで与えることができます:\n"
"\n"
"    list = [{:a, 1}, {:b, 2}, {:a, 3}]\n"
"    Enum.filter list, &match?({:a, x} when x < 2, &1)\n"
"    #=> [{:a, 1}]\n"
"\n"
"しかしながら、(`=`オペレータによる通常のパターンマッチとは\n"
"異なり)マッチで代入される変数は、関数呼びだしの\n"
"外側で利用できません:\n"
"\n"
"    iex> match?(_x, 1)\n"
"    true\n"
"    iex> binding()\n"
"    []\n"
"\n"

#~ msgid ""
#~ "`use` is a simple mechanism for using a given module into\n"
#~ "the current context.\n"
#~ "\n"
#~ "## Examples\n"
#~ "\n"
#~ "For example, in order to write tests using the ExUnit framework,\n"
#~ "a developer should use the `ExUnit.Case` module:\n"
#~ "\n"
#~ "    defmodule AssertionTest do\n"
#~ "      use ExUnit.Case, async: true\n"
#~ "\n"
#~ "      test \"always pass\" do\n"
#~ "        assert true\n"
#~ "      end\n"
#~ "    end\n"
#~ "\n"
#~ "By calling `use`, a hook called `__using__` will be invoked in\n"
#~ "`ExUnit.Case` which will then do the proper setup.\n"
#~ "\n"
#~ "Simply put, `use` is simply a translation to:\n"
#~ "\n"
#~ "    defmodule AssertionTest do\n"
#~ "      require ExUnit.Case\n"
#~ "      ExUnit.Case.__using__([async: true])\n"
#~ "\n"
#~ "      test \"always pass\" do\n"
#~ "        assert true\n"
#~ "      end\n"
#~ "    end\n"
#~ "\n"
#~ msgstr ""
#~ "`use`はカレントコンテキストに与えられたモジュールを使うための\n"
#~ "シンプルなメカニズムです。\n"
#~ "\n"
#~ "## 例\n"
#~ "\n"
#~ "例えば、ExUnitフレームワークを使ってテストを書くために、\n"
#~ "開発者は`ExUnit.Case`モジュールをuseしなければなりません。\n"
#~ "\n"
#~ "    defmodule AssertionTest do\n"
#~ "      use ExUnit.Case, async: true\n"
#~ "\n"
#~ "      test \"always pass\" do\n"
#~ "        assert true\n"
#~ "      end\n"
#~ "    end\n"
#~ "\n"
#~ "`use`を呼ぶことにより、`ExUnit.Case`のセットアップをするために\n"
#~ "`__using__`と呼ばれるフックが起動されます。\n"
#~ "\n"
#~ "単に、`use`は以下のように翻訳されます:\n"
#~ "\n"
#~ "    defmodule AssertionTest do\n"
#~ "      require ExUnit.Case\n"
#~ "      ExUnit.Case.__using__([async: true])\n"
#~ "\n"
#~ "      test \"always pass\" do\n"
#~ "        assert true\n"
#~ "      end\n"
#~ "    end\n"
#~ "\n"

#~ msgid ""
#~ "Defines a function with the given name and contents.\n"
#~ "\n"
#~ "## Examples\n"
#~ "\n"
#~ "    defmodule Foo do\n"
#~ "      def bar, do: :baz\n"
#~ "    end\n"
#~ "\n"
#~ "    Foo.bar #=> :baz\n"
#~ "\n"
#~ "A function that expects arguments can be defined as follow:\n"
#~ "\n"
#~ "    defmodule Foo do\n"
#~ "      def sum(a, b) do\n"
#~ "        a + b\n"
#~ "      end\n"
#~ "    end\n"
#~ "\n"
#~ "In the example above, we defined a function `sum` that receives\n"
#~ "two arguments and sums them.\n"
#~ "\n"
#~ msgstr ""
#~ "与えられた名前とコンテンツで関数を定義します。\n"
#~ "\n"
#~ "## 例\n"
#~ "\n"
#~ "    defmodule Foo do\n"
#~ "      def bar, do: :baz\n"
#~ "    end\n"
#~ "\n"
#~ "    Foo.bar #=> :baz\n"
#~ "\n"
#~ "関数は下のように、引数を付けて定義することもできます:\n"
#~ "\n"
#~ "    defmodule Foo do\n"
#~ "      def sum(a, b) do\n"
#~ "        a + b\n"
#~ "      end\n"
#~ "    end\n"
#~ "\n"
#~ "上の例では、二つの引数をとり、それらの和を返す関数`sum`を定義しました。\n"
#~ "\n"

#~ msgid ""
#~ "Returns the size of a map.\n"
#~ "\n"
#~ "This operation happens in constant time.\n"
#~ "\n"
#~ "Allowed in guard tests. Inlined by the compiler.\n"
#~ msgstr ""
#~ "マップのサイズを返します。\n"
#~ "\n"
#~ "このオペレーションは定数時間で実行されます。\n"
#~ "\n"
#~ "ガード中のテストに使うことができます。コンパイラによりインライン化され\n"
#~ "ます。\n"

#~ msgid ""
#~ "Handles the sigil ~r. It returns a Regex pattern.\n"
#~ "\n"
#~ "## Examples\n"
#~ "\n"
#~ "    iex> Regex.match?(~r(foo), \"foo\")\n"
#~ "    true\n"
#~ "\n"
#~ msgstr ""
#~ "sigil ~rをハンドルします。\n"
#~ "Regexパターンを返します。\n"
#~ "\n"
#~ "## 例\n"
#~ "\n"
#~ "    iex> Regex.match?(~r(foo), \"foo\")\n"
#~ "    true\n"
#~ "\n"

#~ msgid ""
#~ "Boolean and. Requires only the first argument to be a\n"
#~ "boolean since it short-circuits.\n"
#~ "\n"
#~ "Allowed in guard tests.\n"
#~ "\n"
#~ "## Examples\n"
#~ "\n"
#~ "    iex> true and false\n"
#~ "    false\n"
#~ "\n"
#~ msgstr ""
#~ "ブール代数のand です。ショートサーキットなので、\n"
#~ "booleanであることを最初の引数だけに要求します。\n"
#~ "\n"
#~ "ガードテストで使えます。\n"
#~ "\n"
#~ "## 例\n"
#~ "\n"
#~ "    iex> true and false\n"
#~ "    false\n"
#~ "\n"
