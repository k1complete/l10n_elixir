msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2015-09-26 18:19+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: def Application.app_dir(app, path)
#: lib/application.ex:328
msgid "Returns the given path inside `app_dir/1`.\n"
msgstr "`app_dir/1`の内側に与えられたパスを追加して返します。\n"

#. TRANSLATORS: def Application.unload(app)
#: lib/application.ex:285
msgid ""
"Unloads the given `app`.\n"
"\n"
"It will also unload all `:included_applications`.\n"
"Note that the function does not purge the application modules.\n"
msgstr ""
"与えられた`app`をアンロードします。\n"
"\n"
"それは`:included_applications`全てをもアンロードします。\n"
"関数はアプリケーションモジュールをパージしないことに\n"
"注意してください。\n"

#. TRANSLATORS: def Application.stop(app)
#: lib/application.ex:261
msgid ""
"Stops the given `app`.\n"
"\n"
"When stopped, the application is still loaded.\n"
msgstr ""
"与えられた`app`を停止します。\n"
"\n"
"停止したとき、アプリケーションはまだロードされたままです。\n"

#. TRANSLATORS: def Application.start(app, type \\ :temporary)
#: lib/application.ex:222
msgid ""
"Starts the given `app`.\n"
"\n"
"If the `app` is not loaded, the application will first be loaded using "
"`load/1`.\n"
"Any included application, defined in the `:included_applications` key of "
"the\n"
"`.app` file will also be loaded, but they won't be started.\n"
"\n"
"Furthermore, all applications listed in the `:applications` key must be "
"explicitly\n"
"started before this application is. If not, `{:error, {:not_started, app}}` "
"is\n"
"returned, where `app` is the name of the missing application.\n"
"\n"
"In case you want to automatically  load **and start** all of `app`'s "
"dependencies,\n"
"see `ensure_all_started/2`.\n"
"\n"
"The `type` argument specifies the type of the application:\n"
"\n"
"  * `:permanent` - if `app` terminates, all other applications and the "
"entire\n"
"    node are also terminated.\n"
"\n"
"  * `:transient` - if `app` terminates with `:normal` reason, it is "
"reported\n"
"    but no other applications are terminated. If a transient application\n"
"    terminates abnormally, all other applications and the entire node are\n"
"    also terminated.\n"
"\n"
"  * `:temporary` - if `app` terminates, it is reported but no other\n"
"    applications are terminated (the default).\n"
"\n"
"Note that it is always possible to stop an application explicitly by "
"calling\n"
"`stop/1`. Regardless of the type of the application, no other applications "
"will\n"
"be affected.\n"
"\n"
"Note also that the `:transient` type is of little practical use, since when "
"a\n"
"supervision tree terminates, the reason is set to `:shutdown`, not `:"
"normal`.\n"
msgstr ""
"与えられた`app`を開始します。\n"
"\n"
"`app`がロードされていないなら、アプリケーションは最初に`load/1`を使って\n"
"ロードされます。`.app`ファイルの`:included_applications`キーで定義され\n"
"た任意の含まれたアプリケーションもまた、ロードされますが、開始はされま\n"
"せん。\n"
"\n"
"更にまた、`:application`キーにリストされた全てのアプリケーションはアプ\n"
"リケーションを開始する前に、明示的に開始されなければなりません。もしそ\n"
"うでないなら、`app`が足りないアプリケーションの名前で`{:error,\n"
"{:not_started, app}}`が返されます。\n"
"\n"
"自動的に`app`に依存する全てのアプリケーションをロードし「開始」したい場合、\n"
"`ensure_all_started/2`を参照してください。\n"
"\n"
"`type`引数はアプリケーションのタイプを指定します:\n"
"\n"
"  * `:permanent` - `app`が終了したら、全ての他のアプリケーションと\n"
"     ノード全体も終了されます。\n"
"\n"
"  * `:transient` - `app`が`:normal` reasonで終了したら、\n"
"    レポートされますが、他のアプリケーションは終了しません。\n"
"    もしtransient(一時的)なアプリケーションが異常終了したら、\n"
"    全ての他のアプリケーションとノード全体も終了されます。\n"
"\n"
"  * `:temporary` - `app`が終了したら、レポートされますが、\n"
"    他のアプリケーションは終了されません(これがデフォルトです)。\n"
"\n"
"`stop/1`を呼ぶことで、明示的にアプリケーションを終了することが常にできる\n"
"ことに、気を付けてください。アプリケーションのタイプに関係なく、\n"
"他のいかなるアプリケーションも影響を受けません。\n"
"\n"
"`:transient`タイプがほとんど実用的でない理由は、監督ツリーが終了すると\n"
"き、reasonが`:normal`ではなく、`:shutdown`にセットされるからからである\n"
"ことに注意してください。\n"

#. TRANSLATORS: def Application.get_env(app, key, default \\ nil)
#: lib/application.ex:123
msgid ""
"Returns the value for `key` in `app`'s environment.\n"
"\n"
"If the configuration parameter does not exist, the function returns the\n"
"`default` value.\n"
msgstr ""
"`app`の環境の中の`key`に対応する値を返します。\n"
"\n"
"もしconfigurationパラメタが存在しない場合、関数は`default`値を\n"
"返します。\n"

#. TRANSLATORS: def Application.fetch_env!(app, key)
#: lib/application.ex:147
msgid ""
"Returns the value for `key` in `app`'s environment.\n"
"\n"
"If the configuration parameter does not exist, raises `ArgumentError`.\n"
msgstr ""
"`app`の環境の`key`に対応する値を返します。\n"
"\n"
"もし指定されたconfigurationパラメータが存在しない場合、\n"
"`ArgumentError`を上げます。\n"

#. TRANSLATORS: def Application.fetch_env(app, key)
#: lib/application.ex:134
msgid ""
"Returns the value for `key` in `app`'s environment in a tuple.\n"
"\n"
"If the configuration parameter does not exist, the function returns `:"
"error`.\n"
msgstr ""
"`app`の環境の`key`に対応する値を返します。\n"
"\n"
"もしconfigurationパラメータが存在しない場合、`:error`を返します。\n"

#. TRANSLATORS: def Application.get_all_env(app)
#: lib/application.ex:115
msgid "Returns all key-value pairs for `app`.\n"
msgstr "`app`の環境リストについて全てのキーバリューの組を返します。\n"

#. TRANSLATORS: def Application.loaded_applications()
#: lib/application.ex:344
msgid ""
"Returns a list with information about the applications which have been "
"loaded.\n"
msgstr "ロードされたアプリケーションについての情報をリストで返します。\n"

#. TRANSLATORS: def Application.started_applications(timeout \\ 5000)
#: lib/application.ex:336
msgid ""
"Returns a list with information about the applications which are currently "
"running.\n"
msgstr "現在動いているアプリケーションについての情報をリストで返します。\n"

#. TRANSLATORS: def Application.put_env(app, key, value, opts \\ [])
#: lib/application.ex:163
msgid ""
"Puts the `value` in `key` for the given `app`.\n"
"\n"
"## Options\n"
"\n"
"  * `:timeout`    - the timeout for the change (defaults to 5000ms)\n"
"  * `:persistent` - persists the given value on application load and "
"reloads\n"
"\n"
"If `put_env/4` is called before the application is loaded, the application\n"
"environment values specified in the `.app` file will override the ones\n"
"previously set.\n"
"\n"
"The persistent option can be set to `true` when there is a need to "
"guarantee\n"
"parameters set with this function will not be overridden by the ones "
"defined\n"
"in the application resource file on load. This means persistent values will\n"
"stick after the application is loaded and also on application reload.\n"
msgstr ""
"与えられた`value`を`key`に与えられた`app`の為にプットします。\n"
"\n"
"## オプション\n"
"\n"
"  * `:timeout`    - 変更の為のタイムアウト (デフォルト 5000ms)\n"
"  * `:persistent` - アプリケーションをロードやリロードでしても値を永続化しま"
"す\n"
"\n"
"もしアプリケーションがロードされる前に`put_env/4`が呼ばれると、\n"
"`.app`ファイルで指定されたアプリケーション環境変数は、以前の値を\n"
"上書きされます。\n"
"\n"
"ロードしているアプリケーションリソースファイルで定義された値により、こ\n"
"の関数によりセットされたパラメタが、オーバライドされないように保証する\n"
"必要があるときに、persistent オプションを`true`にセットできます。これは、\n"
"永続化された値はアプリケーションがロードされ、アプリケーションがリロー\n"
"ドされた後も定着することを意味します。\n"

#. TRANSLATORS: def Application.load(app)
#: lib/application.ex:271
msgid ""
"Loads the given `app`.\n"
"\n"
"In order to be loaded, an `.app` file must be in the load paths.\n"
"All `:included_applications` will also be loaded.\n"
"\n"
"Loading the application does not start it nor load its modules, but\n"
"it does load its environment.\n"
msgstr ""
"与えられた`app`をロードします。\n"
"\n"
"ロードされる為には、`.app`ファイルはロードパス上になければなりません。\n"
"全ての`:included_applications`もロードされます。\n"
"\n"
"ロードするアプリケーションは開始しませんし、モジュールのロードもしませ\n"
"んが、その環境をロードします。\n"

#. TRANSLATORS: def Application.app_dir(app)
#: lib/application.ex:296
msgid ""
"Gets the directory for app.\n"
"\n"
"This information is returned based on the code path. Here is an\n"
"example:\n"
"\n"
"    File.mkdir_p!(\"foo/ebin\")\n"
"    Code.prepend_path(\"foo/ebin\")\n"
"    Application.app_dir(:foo)\n"
"    #=> \"foo\"\n"
"\n"
"Even though the directory is empty and there is no `.app` file\n"
"it is considered the application directory based on the name\n"
"\"foo/ebin\". The name may contain a dash `-` which is considered\n"
"to be the app version and it is removed for the lookup purposes:\n"
"\n"
"    File.mkdir_p!(\"bar-123/ebin\")\n"
"    Code.prepend_path(\"bar-123/ebin\")\n"
"    Application.app_dir(:bar)\n"
"    #=> \"bar-123\"\n"
"\n"
"For more information on code paths, check the `Code` module in\n"
"Elixir and also Erlang's `:code` module.\n"
msgstr ""
"appのディレクトリを取得します。\n"
"\n"
"この関数はコードパスに基いて返されます。以下は例です:\n"
"\n"
"    File.mkdir_p!(\"foo/ebin\")\n"
"    Code.prepend_path(\"foo/ebin\")\n"
"    Application.app_dir(:foo)\n"
"    #=> \"foo\"\n"
"\n"
"ディレクトリが空で、`.app`ファイルが無くても、名前\"foo/ebin\"に\n"
"基いてアプリケーションディレクトリと考えられます。\n"
"名前は、appのバージョンとして考えられ検索目的では取り除かれる、\n"
"ダッシュ`-`を含むかもしれません:\n"
"\n"
"    File.mkdir_p!(\"bar-123/ebin\")\n"
"    Code.prepend_path(\"bar-123/ebin\")\n"
"    Application.app_dir(:bar)\n"
"    #=> \"bar-123\"\n"
"\n"
"コードパスについての詳細は、Elixirの`Code`モジュールと、Erlangの\n"
"`:code`モジュールもチェックしてください。\n"

#. TRANSLATORS: def Application.format_error(reason)
#: lib/application.ex:352
msgid ""
"Formats the error reason returned by `start/2`,\n"
"`ensure_started/2`, `stop/1`, `load/1` and `unload/1`,\n"
"returns a string.\n"
msgstr ""
"`start/2`、`ensure_started/2`、`stop/1`、`load/1`、`unload/1`で\n"
"返された、エラーのreasonをフォーマットし、文字列を返します。\n"

#. TRANSLATORS: def Application.ensure_started(app, type \\ :temporary)
#: lib/application.ex:195
msgid ""
"Ensures the given `app` is started.\n"
"\n"
"Same as `start/2` but returns `:ok` if the application was already\n"
"started. This is useful in scripts and in test setup, where test\n"
"applications need to be explicitly started:\n"
"\n"
"    :ok = Application.ensure_started(:my_test_dep)\n"
"\n"
msgstr ""
"与えられた`app`が開始しているのを確実にします。\n"
"\n"
"`start/2`と同じですが、そのアプリケーションが既に開始していたら、\n"
"`:ok`を返します。これは、スクリプト中やテストのセットアップで\n"
"テストアプリケーションを明示的に開始させる必要がある場合に、\n"
"便利です:\n"
"\n"
"    :ok = Application.ensure_started(:my_test_dep)\n"
"\n"

#. TRANSLATORS: def Application.ensure_all_started(app, type \\ :temporary)
#: lib/application.ex:210
msgid ""
"Ensures the given `app` and its applications are started.\n"
"\n"
"Same as `start/2` but also starts the applications listed under\n"
"`:applications` in the `.app` file in case they were not previously\n"
"started.\n"
msgstr ""
"与えられた`app`とそれが依存しているアプリケーションが開始していることを\n"
"確実にします。\n"
"\n"
"`start/2`と同じですが、`.app`ファイルに`:applications`でリストされている\n"
"アプリケーションも、まだ開始していない場合には、開始します。\n"

#. TRANSLATORS: def Application.delete_env(app, key, opts \\ [])
#: lib/application.ex:185
msgid ""
"Deletes the `key` from the given `app` environment.\n"
"\n"
"See `put_env/4` for a description of the options.\n"
msgstr ""
"与えられた`app`環境から`key`を削除します。\n"
"\n"
"オプションの詳細は`put_env/4`を参照してください。\n"

#. TRANSLATORS: Elixir.Application Summary
#: lib/application.ex:2
msgid ""
"A module for working with applications and defining application callbacks.\n"
"\n"
"In Elixir (actually, in Erlang/OTP), an application is a component\n"
"implementing some specific functionality, that can be started and stopped\n"
"as a unit, and which can be re-used in other systems.\n"
"\n"
"Applications are defined with an application file named `APP.app` where\n"
"`APP` is the application name, usually in `underscore_case`. The "
"application\n"
"file must reside in the same `ebin` directory as the compiled modules of "
"the\n"
"application.\n"
"\n"
"In Elixir, Mix is responsible for compiling your source code and\n"
"generating your application `.app` file. Furthermore, Mix is also\n"
"responsible for configuring, starting and stopping your application\n"
"and its dependencies. For this reason, this documentation will focus\n"
"on the remaining aspects of your application: the application environment\n"
"and the application callback module.\n"
"\n"
"You can learn more about Mix generation of `.app` files by typing\n"
"`mix help compile.app`.\n"
"\n"
"## Application environment\n"
"\n"
"Once an application is started, OTP provides an application environment\n"
"that can be used to configure the application.\n"
"\n"
"Assuming you are inside a Mix project, you can edit the `application`\n"
"function in the `mix.exs` file to the following:\n"
"\n"
"    def application do\n"
"      [env: [hello: :world]]\n"
"    end\n"
"\n"
"In the application function, we can define the default environment values\n"
"for our application. By starting your application with `iex -S mix`, you\n"
"can access the default value:\n"
"\n"
"    Application.get_env(:APP_NAME, :hello)\n"
"    #=> :world\n"
"\n"
"It is also possible to put and delete values from the application value,\n"
"including new values that are not defined in the environment file (although\n"
"this should be avoided).\n"
"\n"
"In the future, we plan to support configuration files which allow\n"
"developers to configure the environment of their dependencies.\n"
"\n"
"Keep in mind that each application is responsible for its environment.\n"
"Do not use the functions in this module for directly accessing or modifying\n"
"the environment of other applications (as it may lead to inconsistent\n"
"data in the application environment).\n"
"\n"
"## Application module callback\n"
"\n"
"Often times, an application defines a supervision tree that must be started\n"
"and stopped when the application starts and stops. For such, we need to\n"
"define an application module callback. The first step is to define the\n"
"module callback in the application definition in the `mix.exs` file:\n"
"\n"
"    def application do\n"
"      [mod: {MyApp, []}]\n"
"    end\n"
"\n"
"Our application now requires the `MyApp` module to provide an application\n"
"callback. This can be done by invoking `use Application` in that module and\n"
"defining a `start/2` callback, for example:\n"
"\n"
"    defmodule MyApp do\n"
"      use Application\n"
"\n"
"      def start(_type, _args) do\n"
"        MyApp.Supervisor.start_link()\n"
"      end\n"
"    end\n"
"\n"
"`start/2` typically returns `{:ok, pid}` or `{:ok, pid, state}` where\n"
"`pid` identifies the supervision tree and `state` is the application state.\n"
"`args` is the second element of the tuple given to the `:mod` option.\n"
"\n"
"The `type` argument passed to `start/2` is usually `:normal` unless in a\n"
"distributed setup where application takeovers and failovers are configured.\n"
"This particular aspect of applications is explained in more detail in the\n"
"OTP documentation:\n"
"\n"
"  * [`:application` module](http://www.erlang.org/doc/man/application.html)\n"
"  * [Applications – OTP Design Principles](http://www.erlang.org/doc/"
"design_principles/applications.html)\n"
"\n"
"A developer may also implement the `stop/1` callback (automatically defined\n"
"by `use Application`) which does any application cleanup. It receives the\n"
"application state and can return any value. Note that shutting down the\n"
"supervisor is automatically handled by the VM.\n"
msgstr ""
"アプリケーションで動き、アプリケーションコールバックを定義するモジュールです。\n"
"\n"
"Elixirでは(実際には、Erlang/OTPでは)、アプリケーションとは、いくつかの\n"
"特定の機能(単位としてスタートやストップができ、他のシステムでも\n"
"再利用できるような)を実装したコンポーネントです。\n"
"\n"
"アプリケーションは、`APP.app`と名付けられたアプリケーションファイルで\n"
"定義されます。`APP`は通常`underscore_case`変換されたアプリケーションの\n"
"名前です。\n"
"アプリケーションファイルは、アプリケーションモジュールの\n"
"バイトコードと同じ`ebin`ディレクトリに置かれなければなりません。\n"
"\n"
"Elixirでは、Mixはソースコードのコンパイルとアプリケーション`.app`ファイ\n"
"ルの生成に責任をもちます。さらにまた、Mixはアプリケーションの依存関係を\n"
"構成し、開始と停止を行う役割を果します。この理由から、このドキュメント\n"
"はあなたのアプリケーションの残りの面に集中します: アプリケーション環境、\n"
"アプリケーションコールバックモジュールです。\n"
"\n"
"Mixで`.app`ファイルを生成することについては、`mix help\n"
"compile.app`とタイプすることで学ぶことができます。\n"
"\n"
"## Application environment\n"
"\n"
"アプリケーションが開始したら、OTPは、アプリケーションを構成するために\n"
"使うことができる、アプリケーション環境を提供します。\n"
"\n"
"Mixプロジェクトにあるならば、`mix.exs`ファイルの中の`application`関数を\n"
"次のように編集することができます:\n"
"\n"
"    def application do\n"
"      [env: [hello: :world]]\n"
"    end\n"
"\n"
"application関数で、アプリケーションのためのデフォルトの環境の値を\n"
"定義できます。\n"
"`iex -S mix`でアプリケーションを開始することによって、そのデフォルト値に\n"
"アクセスできます:\n"
"\n"
"    Application.get_env(:APP_NAME, :hello)\n"
"    #=> {:ok, :hello}\n"
"\n"
"(避けるべきことですが)環境ファイルで定義されない新しい値を含み、アプリ\n"
"ケーションから値をputし、deleteすることも可能です。\n"
"\n"
"将来、我々は、開発者がそれらの依存関係の環境を構成することができる\n"
"構成ファイルをサポートすることを計画しています。\n"
"\n"
"それぞれのアプリケーションがその環境に責任を果すことを心にとめておいて\n"
"ください。(アプリケーション環境で矛盾しているデータに至るかもしれないの\n"
"で)他のアプリケーションの環境への直接アクセスや変更のために、このモジュー\n"
"ルの関数を使わないでください。\n"
"\n"
"## Application module callback\n"
"\n"
"しばしば、アプリケーションは、アプリケーションが開始と停止するときに、\n"
"開始と停止する、スーパビジョンツリーを定義します。\n"
"それで、アプリケーションモジュールコールバックを定義する必要があります。\n"
"最初のステップは`mix.exs`ファイルのapplicationの定義に、モジュール\n"
"コールバックを定義することです:\n"
"\n"
"    def application do\n"
"      [mod: {MyApp, []}]\n"
"    end\n"
"\n"
"今や、私達のアプリケーションは、アプリケーションコールバックを\n"
"提供することを`MyApp`モジュールに要求します。\n"
"これは、そのモジュールで`use Application`を実行することによりなされ、\n"
"`start/2`コールバックを定義します。例えば:\n"
"\n"
"    defmodule MyApp do\n"
"      use Application\n"
"\n"
"      def start(_type, _args) do\n"
"        MyApp.Supervisor.start_link()\n"
"      end\n"
"    end\n"
"\n"
"`start/2`は最も一般的には`{:ok, pid}`か`{:ok, pid, state}`を返します。\n"
"`pid`はスーパビジョンツリーの識別子で、`state`はアプリケーションのステート\n"
"です。\n"
"`args`は`:mod`オプションに与えたタプルの2番目の要素です。\n"
"\n"
"`start/2`へ送る`type`は、アプリケーションのテイクオーバーとフェイルオーバが\n"
"構成される分散セットアップでないかぎり、通常`:normal`です。\n"
"\n"
"アプリケーションのこの特定の側面は、OTPドキュメントでより多く詳細に読む\n"
"ことができます:\n"
"\n"
"  * [`:application` module](http://www.erlang.org/doc/man/application.html)\n"
"  * [Applications – OTP Design Principles](http://www.erlang.org/doc/design_principles/applications.html)\n"
"\n"
"開発者は、`stop/1`コールバック(`use Application`により自動的に定義され\n"
"ています)を、アプリケーションのなんらかのクリーンアップの為に、実装する\n"
"かもしれません。それは、アプリケーションステートを受け取り、任意の値を\n"
"返すことができます。スーパバイザのシャットダウンは、VMにより自動的にハ\n"
"ンドルされることに注意してください。\n"
