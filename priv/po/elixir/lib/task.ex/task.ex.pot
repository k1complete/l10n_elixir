#. TRANSLATORS: def Task.yield(task, timeout \\ 5000)
#: lib/task.ex:347 
msgid ""
"Yields, temporarily, for a task reply.\n"
"\n"
"Returns `{:ok, reply}` if the reply is received.\n"
"\n"
"A timeout, in milliseconds, can be given with default value\n"
"of `5000`. In case of the timeout, this function will return `nil`\n"
"and the monitor will remain active. Therefore `yield/2` can be\n"
"called multiple times on the same task.\n"
"\n"
"In case the task process dies, this function will exit with the\n"
"same reason as the task.\n"
"\n"
"This function assumes the task's monitor is still active or the monitor's\n"
"`:DOWN` message is in the message queue. If it has been demonitored, or the\n"
"message already received, this function wait for the duration of the timeout\n"
"awaiting the message.\n"
msgstr ""
#. TRANSLATORS: def Task.shutdown(task, shutdown \\ 5000)
#: lib/task.ex:379 
msgid ""
"Unlinks and shutdowns the task, and then checks for a reply.\n"
"\n"
"Returns `{:ok, reply}` if the reply is received while shutting down the task,\n"
"otherwise `nil`.\n"
"\n"
"The shutdown method is either a timeout or `:brutal_kill`. In the case\n"
"of a `timeout`, a `:shutdown` exit signal is sent to the task process\n"
"and if it does not exit within the timeout it is killed. With `:brutal_kill`\n"
"the task is killed straight away. In the case that the task exits abnormal,\n"
"or a timeout shutdown kills the task, this function will exit with the same\n"
"reason.\n"
"\n"
"It is not required to call this function when terminating the caller, unless\n"
"exiting with reason `:normal` or the task is trapping exits. If the caller is\n"
"exiting with a reason other than `:normal` and the task is not trapping exits the\n"
"caller's exit signal will stop the task. The caller can exit with reason\n"
"`:shutdown` to shutdown linked processes, such as tasks, that are not trapping\n"
"exits without generating any log messages.\n"
"\n"
"This function assumes the task's monitor is still active or the monitor's\n"
"`:DOWN` message is in the message queue. If it has been demonitored, or the\n"
"message already received, this function will block forever awaiting the message.\n"
msgstr ""
#. TRANSLATORS: def Task.__struct__()
#: lib/task.ex:137 
msgid ""
"The Task struct.\n"
"\n"
"It contains two fields:\n"
"\n"
"  * `:pid` - the process reference of the task process; `nil` if the task does\n"
"    not use a task process.\n"
"\n"
"  * `:ref` - the task monitor reference\n"
"\n"
msgstr ""
#. TRANSLATORS: def Task.start(mod, fun, args)
#: lib/task.ex:180 
msgid ""
"Starts a task.\n"
"\n"
"This is only used when the task is used for side-effects\n"
"(i.e. no interest in its return result) and it should not\n"
"be linked to the current process.\n"
msgstr ""
#. TRANSLATORS: def Task.async(mod, fun, args)
#: lib/task.ex:212 
msgid ""
"Starts a task that can be awaited on.\n"
"\n"
"This function spawns a process that is linked to and monitored\n"
"by the caller process. A `Task` struct is returned containing\n"
"the relevant information.\n"
"\n"
"Read the `Task` module documentation for more info on general\n"
"usage of `async/1` and `async/3`.\n"
"\n"
"## Task's message format\n"
"\n"
"The reply sent by the task will be in the format `{ref, msg}`,\n"
"where `ref` is the monitoring reference held by the task.\n"
msgstr ""
#. TRANSLATORS: def Task.start_link(mod, fun, args)
#: lib/task.ex:160 
msgid ""
"Starts a task as part of a supervision tree.\n"
msgstr ""
#. TRANSLATORS: def Task.find(tasks, msg)
#: lib/task.ex:278 
msgid ""
"Receives a group of tasks and a message and finds\n"
"a task that matches the given message.\n"
"\n"
"This function returns a tuple with the returned value\n"
"in case the message matches a task that exited with\n"
"success alongside the matching task. It raises in case\n"
"the found task failed or `nil` if no task was found.\n"
"\n"
"This function is useful in situations where multiple\n"
"tasks are spawned and their results are collected\n"
"later on. For example, a `GenServer` can spawn tasks,\n"
"store the tasks in a list and later use `Task.find/2`\n"
"to see if incoming messages are from any of the tasks.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule TaskFinder do\n"
"      def run do\n"
"        task1 = Task.async fn -> :timer.sleep(1000); 1 end\n"
"        task2 = Task.async fn -> :timer.sleep(5000); 2 end\n"
"        await [task1, task2]\n"
"      end\n"
"\n"
"      # Be careful, this will receive all messages sent\n"
"      # to this process. It will return the first task\n"
"      # reply and the list of tasks that came second.\n"
"      def await(tasks) do\n"
"        receive do\n"
"          message ->\n"
"            case Task.find(tasks, message) do\n"
"              {reply, task} ->\n"
"                {reply, List.delete(tasks, task)}\n"
"              nil ->\n"
"                await(tasks)\n"
"            end\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    TaskFinder.run\n"
msgstr ""
#. TRANSLATORS: Elixir.Task Summary
#: lib/task.ex:2 
msgid ""
"Conveniences for spawning and awaiting for tasks.\n"
"\n"
"Tasks are processes meant to execute one particular\n"
"action throughout their life-cycle, often with little or no\n"
"communication with other processes. The most common use case\n"
"for tasks is to compute a value asynchronously:\n"
"\n"
"    task = Task.async(fn -> do_some_work() end)\n"
"    res  = do_some_other_work()\n"
"    res + Task.await(task)\n"
"\n"
"Tasks spawned with `async` can be awaited on by its caller\n"
"process (and only its caller) as shown in the example above.\n"
"They are implemented by spawning a process that sends a message\n"
"to the caller once the given computation is performed.\n"
"\n"
"Besides `async/1` and `await/2`, tasks can also be\n"
"started as part of supervision trees and dynamically spawned\n"
"in remote nodes. We will explore all three scenarios next.\n"
"\n"
"## async and await\n"
"\n"
"The most common way to spawn a task is with `Task.async/1`. A new\n"
"process will be created, linked and monitored by the caller. Once\n"
"the task action finishes, a message will be sent to the caller\n"
"with the result.\n"
"\n"
"`Task.await/2` is used to read the message sent by the task.\n"
"`await` will check the monitor setup by the call to `async/1' to\n"
"verify if the process exited for any abnormal reason (or in case\n"
"exits are being trapped by the caller).\n"
"\n"
"There are two important things to consider when using async:\n"
"\n"
"  1. If you are using async tasks, you must await for a reply\n"
"     as they are *always* sent. If you are not expecting a reply,\n"
"     consider using `Task.start_link/1` detailed below\n"
"\n"
"  2. async tasks link the caller and the spawned process. This\n"
"     means that, if the caller crashes, the task will crash\n"
"     too and vice-versa. This is on purpose, if the process\n"
"     meant to receive the result no longer exists, there is\n"
"     no purpose in computing the result until the end. If this\n"
"     is not desired, consider using `Task.start_link/1` as well\n"
"\n"
"`Task.yield/2` is an alternative to `await/2` where the caller will\n"
"temporarily block waiting for a task's result. If the result does not\n"
"arrive within the timeout it can be called again at later moment. This\n"
"allows checking for the result of a task multiple times or to handle\n"
"a timeout. If a reply does not arrive within the desired time, and the\n"
"caller is not going exit, `Task.shutdown/2` can be used to stop the task.\n"
"\n"
"## Supervised tasks\n"
"\n"
"It is also possible to spawn a task inside a supervision tree\n"
"with `start_link/1` and `start_link/3`:\n"
"\n"
"    Task.start_link(fn -> IO.puts \"ok\" end)\n"
"\n"
"Such tasks can be mounted in your supervision tree as:\n"
"\n"
"    import Supervisor.Spec\n"
"\n"
"    children = [\n"
"      worker(Task, [fn -> IO.puts \"ok\" end])\n"
"    ]\n"
"\n"
"Since these tasks are supervised and not directly linked to\n"
"the caller, they cannot be awaited on. Note `start_link/1`,\n"
"unlike `async/1`, returns `{:ok, pid}` (which is\n"
"the result expected by supervision trees).\n"
"\n"
"By default, most supervision strategies will try to restart\n"
"a worker after it exits regardless of reason. If you design the\n"
"task to terminate normally (as in the example with `IO.puts/2` above),\n"
"consider passing `restart: :transient` in the options to `worker/3`.\n"
"\n"
"## Dynamically supervised tasks\n"
"\n"
"The `Task.Supervisor` module allows developers to dynamically\n"
"create multiple supervised tasks.\n"
"\n"
"A short example is:\n"
"\n"
"    {:ok, pid} = Task.Supervisor.start_link()\n"
"    task = Task.Supervisor.async(pid, fn ->\n"
"      # Do something\n"
"    end)\n"
"    Task.await(task)\n"
"\n"
"However, in the majority of cases, you want to add the task supervisor\n"
"to your supervision tree:\n"
"\n"
"    import Supervisor.Spec\n"
"\n"
"    children = [\n"
"      supervisor(Task.Supervisor, [[name: MyApp.TaskSupervisor]])\n"
"    ]\n"
"\n"
"Now you can dynamically start supervised tasks:\n"
"\n"
"    Task.Supervisor.start_child(MyApp.TaskSupervisor, fn ->\n"
"      # Do something\n"
"    end)\n"
"\n"
"Or even use the async/await pattern:\n"
"\n"
"    Task.Supervisor.async(MyApp.TaskSupervisor, fn ->\n"
"      # Do something\n"
"    end) |> Task.await()\n"
"\n"
"Finally, check `Task.Supervisor` for other operations supported by the\n"
"Task supervisor.\n"
"\n"
"## Distributed tasks\n"
"\n"
"Since Elixir provides a Task supervisor, it is easy to use a task\n"
"supervisor to dynamically spawn tasks across nodes:\n"
"\n"
"    # In the remote node\n"
"    Task.Supervisor.start_link(name: MyApp.DistSupervisor)\n"
"\n"
"    # In the client\n"
"    Task.Supervisor.async({MyApp.DistSupervisor, :remote@local},\n"
"                          MyMod, :my_fun, [arg1, arg2, arg3])\n"
"\n"
"Note that, when working with distributed tasks, one should use the `async/4` function\n"
"that expects explicit module, function and arguments, instead of `async/2` that\n"
"works with anonymous functions. That's because anonymous functions expect\n"
"the same module version to exist on all involved nodes. Check the `Agent` module\n"
"documentation for more information on distributed processes as the limitations\n"
"described in the agents documentation apply to the whole ecosystem.\n"
msgstr ""
#. TRANSLATORS: def Task.await(task, timeout \\ 5000)
#: lib/task.ex:244 
msgid ""
"Awaits a task reply.\n"
"\n"
"A timeout, in milliseconds, can be given with default value\n"
"of `5000`. In case the task process dies, this function will\n"
"exit with the same reason as the task.\n"
"\n"
"If the timeout is exceeded, `await` will exit, however,\n"
"the task will continue to run. When the calling process exits, its\n"
"exit signal will close the task if it is not trapping exits.\n"
"\n"
"This function assumes the task's monitor is still active or the monitor's\n"
"`:DOWN` message is in the message queue. If it has been demonitored, or the\n"
"message already received, this function may wait for the duration of the\n"
"timeout awaiting the message.\n"
"\n"
"This function will always demonitor the task and so the task can not be used\n"
"again. To await the task's reply multiple times use `yield/2` instead.\n"
msgstr ""
