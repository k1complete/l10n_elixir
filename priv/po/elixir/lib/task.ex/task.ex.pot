#. TRANSLATORS: def Task.async(mod, fun, args)
#: lib/task.ex:211 
msgid ""
"Starts a task that must be awaited on.\n"
"\n"
"A `Task` struct is returned containing the relevant information.\n"
"Developers must eventually call `Task.await/2` or `Task.yield/2`\n"
"followed by `Task.shutdown/2` on the returned task.\n"
"\n"
"Read the `Task` module documentation for more info on general\n"
"usage of `async/1` and `async/3`.\n"
"\n"
"## Linking\n"
"\n"
"This function spawns a process that is linked to and monitored\n"
"by the caller process. The linking part is important because it\n"
"aborts the task if the parent process dies. It also guarantees\n"
"the code before async/await has the same properties after you\n"
"add the async call. For example, imagine you have this:\n"
"\n"
"    x = heavy_fun()\n"
"    y = some_fun()\n"
"    x + y\n"
"\n"
"Now you want to make the `heavy_fun()` async:\n"
"\n"
"    x = Task.async(&heavy_fun/0)\n"
"    y = some_fun()\n"
"    Task.await(x) + y\n"
"\n"
"As before, if `heavy_fun/0` fails, the whole computation will\n"
"fail, including the parent process. If you don't want the task\n"
"to fail then you must change the `heavy_fun/0` code in the\n"
"same way you would achieve it if you didn't have the async call.\n"
"For example, to either return `{:ok, val} | :error` results or,\n"
"in more extreme cases, by using `try/rescue`. In other words,\n"
"an asynchronous task should be thought of as an extension of a\n"
"process rather than a mechanism to isolate it from all errors.\n"
"\n"
"If you don't want to link the caller to the task, then you\n"
"must use a supervised task with `Task.Supervisor` and call\n"
"`Task.Supervisor.async_nolink/2`.\n"
"\n"
"In any case, avoid any of the following:\n"
"\n"
"  * Setting `:trap_exit` to `true` - trapping exits should be\n"
"    used only in special circumstances as it would make your\n"
"    process immune to not only exits from the task but from\n"
"    any other processes.\n"
"\n"
"    Moreover, even when trapping exists, calling `await` will\n"
"    still exit if the task has terminated without sending its\n"
"    result back.\n"
"\n"
"  * Unlinking the task process started with `async`/`await`.\n"
"    If you unlink the processes and the task does not belong\n"
"    to any supervisor, you may leave dangling tasks in case\n"
"    the parent dies.\n"
"\n"
"## Message format\n"
"\n"
"The reply sent by the task will be in the format `{ref, result}`,\n"
"where `ref` is the monitor reference held by the task struct\n"
"and `result` is the return value of the task function.\n"
msgstr ""
#. TRANSLATORS: def Task.await(task, timeout \\ 5000)
#: lib/task.ex:292 
msgid ""
"Awaits a task reply.\n"
"\n"
"A timeout, in milliseconds, can be given with default value\n"
"of `5000`. In case the task process dies, this function will\n"
"exit with the same reason as the task.\n"
"\n"
"If the timeout is exceeded, `await` will exit; however,\n"
"the task will continue to run. When the calling process exits, its\n"
"exit signal will terminate the task if it is not trapping exits.\n"
"\n"
"This function assumes the task's monitor is still active or the monitor's\n"
"`:DOWN` message is in the message queue. If it has been demonitored, or the\n"
"message already received, this function will wait for the duration of the\n"
"timeout awaiting the message.\n"
"\n"
"This function can only be called once for any given task. If you want\n"
"to be able to check multiple times if a long-running task has finished\n"
"its computation, use `yield/2` instead.\n"
"\n"
"## Compatibility with OTP behaviours\n"
"\n"
"It is not recommended to `await` a long-running task inside an OTP\n"
"behaviour such as `GenServer`. Instead, you should match on the message\n"
"coming from a task inside your `handle_info` callback.\n"
msgstr ""
#. TRANSLATORS: def Task.yield(task, timeout \\ 5000)
#: lib/task.ex:367 
msgid ""
"Temporarily blocks the current process waiting for a task reply.\n"
"\n"
"Returns `{:ok, reply}` if the reply is received, `nil` if\n"
"no reply has arrived, or `{:exit, reason}` if the task has already\n"
"exited. Keep in mind that normally a task failure also causes\n"
"the process owning the task to exit. Therefore this function can\n"
"return `{:exit, reason}` only if\n"
"\n"
"  * the task process exited with the reason `:normal`\n"
"  * it isn't linked to the caller\n"
"  * the caller is trapping exits\n"
"\n"
"A timeout, in milliseconds, can be given with default value\n"
"of `5000`. If the time runs out before a message from\n"
"the task is received, this function will return `nil`\n"
"and the monitor will remain active. Therefore `yield/2` can be\n"
"called multiple times on the same task.\n"
"\n"
"This function assumes the task's monitor is still active or the\n"
"monitor's `:DOWN` message is in the message queue. If it has been\n"
"demonitored or the message already received, this function will wait\n"
"for the duration of the timeout awaiting the message.\n"
msgstr ""
#. TRANSLATORS: def Task.start_link(mod, fun, args)
#: lib/task.ex:162 
msgid ""
"Starts a task as part of a supervision tree.\n"
msgstr ""
#. TRANSLATORS: def Task.async(fun)
#: lib/task.ex:194 
msgid ""
"Starts a task that must be awaited on.\n"
"\n"
"This function spawns a process that is linked to and monitored\n"
"by the caller process. A `Task` struct is returned containing\n"
"the relevant information.\n"
"\n"
"Read the `Task` module documentation for more info on general\n"
"usage of `async/1` and `async/3`.\n"
"\n"
"See also `async/3`.\n"
msgstr ""
#. TRANSLATORS: def Task.yield_many(tasks, timeout \\ 5000)
#: lib/task.ex:413 
msgid ""
"Yields to multiple tasks in the given time interval.\n"
"\n"
"This function receives a list of tasks and waits for their\n"
"replies in the given time interval. It returns a list\n"
"of tuples of two elements, with the task as the first element\n"
"and the yielded result as the second.\n"
"\n"
"Similarly to `yield/2`, each task's result will be\n"
"\n"
"  * `{:ok, term}` if the task has successfully reported its\n"
"    result back in the given time interval\n"
"  * `{:exit, reason}` if the task has died\n"
"  * `nil` if the task keeps running past the timeout\n"
"\n"
"Check `yield/2` for more information.\n"
"\n"
"## Example\n"
"\n"
"`Task.yield_many/2` allows developers to spawn multiple tasks\n"
"and retrieve the results received in a given timeframe.\n"
"If we combine it with `Task.shutdown/2`, it allows us to gather\n"
"those results and cancel the tasks that have not replied in time.\n"
"\n"
"Let's see an example.\n"
"\n"
"    tasks =\n"
"      for i <- 1..10 do\n"
"        Task.async(fn ->\n"
"          :timer.sleep(i * 1000)\n"
"          i\n"
"        end)\n"
"      end\n"
"\n"
"    tasks_with_results = Task.yield_many(tasks, 5000)\n"
"\n"
"    results = Enum.map(tasks_with_results, fn {task, res} ->\n"
"      # Shutdown the tasks that did not reply nor exit\n"
"      res || Task.shutdown(task, :brutal_kill)\n"
"    end)\n"
"\n"
"    # Here we are matching only on {:ok, value} and\n"
"    # ignoring {:exit, _} (crashed tasks) and `nil` (no replies)\n"
"    for {:ok, value} <- results do\n"
"      IO.inspect value\n"
"    end\n"
"\n"
"In the example above, we create tasks that sleep from 1\n"
"up to 10 seconds and return the amount of seconds they slept.\n"
"If you execute the code all at once, you should see 1 up to 5\n"
"printed, as those were the tasks that have replied in the\n"
"given time. All other tasks will have been shut down using\n"
"the `Task.shutdown/2` call.\n"
msgstr ""
#. TRANSLATORS: Elixir.Task Summary
#: lib/task.ex:2 
msgid ""
"Conveniences for spawning and awaiting tasks.\n"
"\n"
"Tasks are processes meant to execute one particular\n"
"action throughout their lifetime, often with little or no\n"
"communication with other processes. The most common use case\n"
"for tasks is to convert sequential code into concurrent code\n"
"by computing a value asynchronously:\n"
"\n"
"    task = Task.async(fn -> do_some_work() end)\n"
"    res  = do_some_other_work()\n"
"    res + Task.await(task)\n"
"\n"
"Tasks spawned with `async` can be awaited on by their caller\n"
"process (and only their caller) as shown in the example above.\n"
"They are implemented by spawning a process that sends a message\n"
"to the caller once the given computation is performed.\n"
"\n"
"Besides `async/1` and `await/2`, tasks can also be\n"
"started as part of a supervision tree and dynamically spawned\n"
"on remote nodes. We will explore all three scenarios next.\n"
"\n"
"## async and await\n"
"\n"
"One of the common uses of tasks is to convert sequential code\n"
"into concurrent code with `Task.async/1` while keeping its semantics.\n"
"When invoked, a new process will be created, linked and monitored\n"
"by the caller. Once the task action finishes, a message will be sent\n"
"to the caller with the result.\n"
"\n"
"`Task.await/2` is used to read the message sent by the task.\n"
"\n"
"There are two important things to consider when using `async`:\n"
"\n"
"  1. If you are using async tasks, you must await a reply\n"
"     as they are *always* sent. If you are not expecting a reply,\n"
"     consider using `Task.start_link/1` detailed below.\n"
"\n"
"  2. async tasks link the caller and the spawned process. This\n"
"     means that, if the caller crashes, the task will crash\n"
"     too and vice-versa. This is on purpose: if the process\n"
"     meant to receive the result no longer exists, there is\n"
"     no purpose in completing the computation.\n"
"\n"
"     If this is not desired, consider starting the task under\n"
"     a `Task.Supervisor` using `async_nolink` or `start_child`.\n"
"\n"
"`Task.yield/2` is an alternative to `await/2` where the caller will\n"
"temporarily block, waiting until the task replies or crashes. If the\n"
"result does not arrive within the timeout, it can be called again at a\n"
"later moment. This allows checking for the result of a task multiple\n"
"times. If a reply does not arrive within the desired time,\n"
"`Task.shutdown/2` can be used to stop the task.\n"
"\n"
"## Supervised tasks\n"
"\n"
"It is also possible to spawn a task under a supervisor\n"
"with `start_link/1` and `start_link/3`:\n"
"\n"
"    Task.start_link(fn -> IO.puts \"ok\" end)\n"
"\n"
"Such tasks can be mounted in your supervision tree as:\n"
"\n"
"    import Supervisor.Spec\n"
"\n"
"    children = [\n"
"      worker(Task, [fn -> IO.puts \"ok\" end])\n"
"    ]\n"
"\n"
"Since these tasks are supervised and not directly linked to\n"
"the caller, they cannot be awaited on. Note `start_link/1`,\n"
"unlike `async/1`, returns `{:ok, pid}` (which is\n"
"the result expected by supervision trees).\n"
"\n"
"By default, most supervision strategies will try to restart\n"
"a worker after it exits regardless of the reason. If you design the\n"
"task to terminate normally (as in the example with `IO.puts/2` above),\n"
"consider passing `restart: :transient` in the options to `worker/3`.\n"
"\n"
"## Dynamically supervised tasks\n"
"\n"
"The `Task.Supervisor` module allows developers to dynamically\n"
"create multiple supervised tasks.\n"
"\n"
"A short example is:\n"
"\n"
"    {:ok, pid} = Task.Supervisor.start_link()\n"
"    task = Task.Supervisor.async(pid, fn ->\n"
"      # Do something\n"
"    end)\n"
"    Task.await(task)\n"
"\n"
"However, in the majority of cases, you want to add the task supervisor\n"
"to your supervision tree:\n"
"\n"
"    import Supervisor.Spec\n"
"\n"
"    children = [\n"
"      supervisor(Task.Supervisor, [[name: MyApp.TaskSupervisor]])\n"
"    ]\n"
"\n"
"Now you can dynamically start supervised tasks:\n"
"\n"
"    Task.Supervisor.start_child(MyApp.TaskSupervisor, fn ->\n"
"      # Do something\n"
"    end)\n"
"\n"
"Or even use the async/await pattern:\n"
"\n"
"    Task.Supervisor.async(MyApp.TaskSupervisor, fn ->\n"
"      # Do something\n"
"    end) |> Task.await()\n"
"\n"
"Finally, check `Task.Supervisor` for other supported operations.\n"
"\n"
"## Distributed tasks\n"
"\n"
"Since Elixir provides a Task supervisor, it is easy to use one\n"
"to dynamically spawn tasks across nodes:\n"
"\n"
"    # On the remote node\n"
"    Task.Supervisor.start_link(name: MyApp.DistSupervisor)\n"
"\n"
"    # On the client\n"
"    Task.Supervisor.async({MyApp.DistSupervisor, :remote@local},\n"
"                          MyMod, :my_fun, [arg1, arg2, arg3])\n"
"\n"
"Note that, when working with distributed tasks, one should use the `async/4` function\n"
"that expects explicit module, function and arguments, instead of `async/2` that\n"
"works with anonymous functions. That's because anonymous functions expect\n"
"the same module version to exist on all involved nodes. Check the `Agent` module\n"
"documentation for more information on distributed processes as the limitations\n"
"described there apply to the whole ecosystem.\n"
msgstr ""
#. TRANSLATORS: def Task.__struct__()
#: lib/task.ex:137 
msgid ""
"The Task struct.\n"
"\n"
"It contains these fields:\n"
"\n"
"  * `:pid` - the PID of the task process; `nil` if the task does\n"
"    not use a task process\n"
"\n"
"  * `:ref` - the task monitor reference\n"
"\n"
"  * `:owner` - the PID of the process that started the task\n"
"\n"
msgstr ""
#. TRANSLATORS: def Task.start(mod, fun, args)
#: lib/task.ex:182 
msgid ""
"Starts a task.\n"
"\n"
"This is only used when the task is used for side-effects\n"
"(i.e. no interest in the returned result) and it should not\n"
"be linked to the current process.\n"
msgstr ""
#. TRANSLATORS: def Task.shutdown(task, shutdown \\ 5000)
#: lib/task.ex:512 
msgid ""
"Unlinks and shuts down the task, and then checks for a reply.\n"
"\n"
"Returns `{:ok, reply}` if the reply is received while shutting down the task,\n"
"`{:exit, reason}` if the task died, otherwise `nil`.\n"
"\n"
"The shutdown method is either a timeout or `:brutal_kill`. In case\n"
"of a `timeout`, a `:shutdown` exit signal is sent to the task process\n"
"and if it does not exit within the timeout, it is killed. With `:brutal_kill`\n"
"the task is killed straight away. In case the task terminates abnormally\n"
"(possibly killed by another process), this function will exit with the same reason.\n"
"\n"
"It is not required to call this function when terminating the caller, unless\n"
"exiting with reason `:normal` or if the task is trapping exits. If the caller is\n"
"exiting with a reason other than `:normal` and the task is not trapping exits, the\n"
"caller's exit signal will stop the task. The caller can exit with reason\n"
"`:shutdown` to shutdown all of its linked processes, including tasks, that\n"
"are not trapping exits without generating any log messages.\n"
"\n"
"This function assumes the task's monitor is still active or the monitor's\n"
"`:DOWN` message is in the message queue. If it has been demonitored, or the\n"
"message already received, this function will block forever awaiting the message.\n"
msgstr ""
