#. TRANSLATORS: def Task.__struct__()
#: lib/task.ex:102 
msgid ""
"The Task struct.\n"
"\n"
"It contains two fields:\n"
"\n"
"  * `:pid` - the process reference of the task process; it may be a pid\n"
"    or a tuple containing the process and node names\n"
"\n"
"  * `:ref` - the task monitor reference\n"
"\n"
msgstr ""
#. TRANSLATORS: def Task.find(tasks, msg)
#: lib/task.ex:227 
msgid ""
"Receives a group of tasks and a message and finds\n"
"a task that matches the given message.\n"
"\n"
"This function returns a tuple with the task and the\n"
"returned value in case the message matches a task that\n"
"exited with success, it raises in case the found task\n"
"failed or `nil` if no task was found.\n"
"\n"
"This function is useful in situations where multiple\n"
"tasks are spawned and their results are collected\n"
"later on. For example, a `GenServer` can spawn tasks,\n"
"store the tasks in a list and later use `Task.find/2`\n"
"to see if incoming messages are from any of the tasks.\n"
msgstr ""
#. TRANSLATORS: def Task.start(mod, fun, args)
#: lib/task.ex:142 
msgid ""
"Starts a task.\n"
"\n"
"This is only used when the task is used for side-effects\n"
"(i.e. no interest in its return result) and it should not\n"
"be linked to the current process.\n"
msgstr ""
#. TRANSLATORS: def Task.async(fun)
#: lib/task.ex:159 
msgid ""
"Starts a task that can be awaited on.\n"
"\n"
"This function spawns a process that is linked to and monitored\n"
"by the caller process. A `Task` struct is returned containing\n"
"the relevant information.\n"
"\n"
"## Task's message format\n"
"\n"
"The reply sent by the task will be in the format `{ref, msg}`,\n"
"where `ref` is the monitoring reference held by the task.\n"
msgstr ""
#. TRANSLATORS: def Task.async(mod, fun, args)
#: lib/task.ex:170 
msgid ""
"Starts a task that can be awaited on.\n"
"\n"
"Similar to `async/1`, but the task is specified by the given\n"
"module, function and arguments.\n"
msgstr ""
#. TRANSLATORS: def Task.start_link(mod, fun, args)
#: lib/task.ex:118 
msgid ""
"Starts a task as part of a supervision tree.\n"
msgstr ""
#. TRANSLATORS: def Task.await(task, timeout \\ 5000)
#: lib/task.ex:194 
msgid ""
"Awaits a task reply.\n"
"\n"
"A timeout, in milliseconds, can be given with default value\n"
"of `5000`. In case the task process dies, this function will\n"
"exit with the same reason as the task.\n"
msgstr ""
#. TRANSLATORS: Elixir.Task Summary
#: lib/task.ex:1 
msgid ""
"Conveniences for spawning and awaiting for tasks.\n"
"\n"
"Tasks are processes meant to execute one particular\n"
"action throughout their life-cycle, often with little or no\n"
"communication with other processes. The most common use case\n"
"for tasks is to compute a value asynchronously:\n"
"\n"
"    task = Task.async(fn -> do_some_work() end)\n"
"    res  = do_some_other_work()\n"
"    res + Task.await(task)\n"
"\n"
"Tasks spawned with `async` can be awaited on by its caller\n"
"process (and only its caller) as shown in the example above.\n"
"They are implemented by spawning a process that sends a message\n"
"to the caller once the given computation is performed.\n"
"\n"
"Besides `async/1` and `await/2`, tasks can also be\n"
"started as part of supervision trees and dynamically spawned\n"
"in remote nodes. We will explore all three scenarios next.\n"
"\n"
"## async and await\n"
"\n"
"The most common way to spawn a task is with `Task.async/1`. A new\n"
"process will be created, linked and monitored by the caller. Once\n"
"the task action finishes, a message will be sent to the caller\n"
"with the result.\n"
"\n"
"`Task.await/2` is used to read the message sent by the task. On\n"
"`await`, Elixir will also setup a monitor to verify if the process\n"
"exited for any abnormal reason (or in case exits are being\n"
"trapped by the caller).\n"
"\n"
"## Supervised tasks\n"
"\n"
"It is also possible to spawn a task inside a supervision tree\n"
"with `start_link/1` and `start_link/3`:\n"
"\n"
"    Task.start_link(fn -> IO.puts \"ok\" end)\n"
"\n"
"Such tasks can be mounted in your supervision tree as:\n"
"\n"
"    import Supervisor.Spec\n"
"\n"
"    children = [\n"
"      worker(Task, [fn -> IO.puts \"ok\" end])\n"
"    ]\n"
"\n"
"Since these tasks are supervised and not directly linked to\n"
"the caller, they cannot be awaited on. Note `start_link/1`,\n"
"unlike `async/1`, returns `{:ok, pid}` (which is\n"
"the result expected by supervision trees).\n"
"\n"
"## Supervision trees\n"
"\n"
"The `Task.Supervisor` module allows developers to start supervisors\n"
"that dynamically supervise tasks:\n"
"\n"
"    {:ok, pid} = Task.Supervisor.start_link()\n"
"    Task.Supervisor.async(pid, MyMod, :my_fun, [arg1, arg2, arg3])\n"
"\n"
"`Task.Supervisor` also makes it possible to spawn tasks in remote nodes as\n"
"long as the supervisor is registered locally or globally:\n"
"\n"
"    # In the remote node\n"
"    Task.Supervisor.start_link(name: :tasks_sup)\n"
"\n"
"    # In the client\n"
"    Task.Supervisor.async({:tasks_sup, :remote@local}, MyMod, :my_fun, [arg1, arg2, arg3])\n"
"\n"
"`Task.Supervisor` is more often started in your supervision tree as:\n"
"\n"
"    import Supervisor.Spec\n"
"\n"
"    children = [\n"
"      supervisor(Task.Supervisor, [[name: :tasks_sup]])\n"
"    ]\n"
"\n"
"Note that, when working with distributed tasks, one should use the `async/3` API,\n"
"that expects explicit module, function and arguments, instead of `async/1` that\n"
"works with anonymous functions. That's because the anonymous function API expects\n"
"the same module version to exist on all involved nodes. Check the `Agent` module\n"
"documentation for more information on distributed processes, as the limitations\n"
"described in the agents documentation apply to the whole ecosystem.\n"
"\n"
"Finally, check `Task.Supervisor` for other operations supported by the Task\n"
"supervisor.\n"
msgstr ""
