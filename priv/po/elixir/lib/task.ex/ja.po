msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2015-09-17 18:34+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: def Task.yield(task, timeout \\ 5000)
#: lib/task.ex:347
msgid ""
"Yields, temporarily, for a task reply.\n"
"\n"
"Returns `{:ok, reply}` if the reply is received.\n"
"\n"
"A timeout, in milliseconds, can be given with default value\n"
"of `5000`. In case of the timeout, this function will return `nil`\n"
"and the monitor will remain active. Therefore `yield/2` can be\n"
"called multiple times on the same task.\n"
"\n"
"In case the task process dies, this function will exit with the\n"
"same reason as the task.\n"
"\n"
"This function assumes the task's monitor is still active or the monitor's\n"
"`:DOWN` message is in the message queue. If it has been demonitored, or the\n"
"message already received, this function wait for the duration of the "
"timeout\n"
"awaiting the message.\n"
msgstr ""
"yield、テンポラリにタスクの応答を待ちます。\n"
"\n"
"replyが受信されたら、`{:ok, reply}` を返します。\n"
"\n"
"ミリ秒のタイムアウトを与えることもでき、デフォルト値は\n"
"`5000`です。タイムアウトの場合、この関数は`nil`を\n"
"返し、モニタはアクティブのままです。したがって`yield/2`は\n"
"同じタスクに複数回呼び出すことができます。\n"
"\n"
"タスクプロセスが死んでいた場合、この関数はタスクと\n"
"同じreason で exit します。\n"
"\n"
"この関数はタスクのモニタがアクティブあるいは、\n"
"`:DOWN`メッセージがメッセージキューにあることを仮定しています。\n"
"もし非モニタされていた、あるいは、メッセージが既に受信されていたら、\n"
"この関数はタイムアウトの期間中メッセージを待つでしょう。\n"

#. TRANSLATORS: def Task.shutdown(task, shutdown \\ 5000)
#: lib/task.ex:379
msgid ""
"Unlinks and shutdowns the task, and then checks for a reply.\n"
"\n"
"Returns `{:ok, reply}` if the reply is received while shutting down the "
"task,\n"
"otherwise `nil`.\n"
"\n"
"The shutdown method is either a timeout or `:brutal_kill`. In the case\n"
"of a `timeout`, a `:shutdown` exit signal is sent to the task process\n"
"and if it does not exit within the timeout it is killed. With `:"
"brutal_kill`\n"
"the task is killed straight away. In the case that the task exits abnormal,\n"
"or a timeout shutdown kills the task, this function will exit with the same\n"
"reason.\n"
"\n"
"It is not required to call this function when terminating the caller, "
"unless\n"
"exiting with reason `:normal` or the task is trapping exits. If the caller "
"is\n"
"exiting with a reason other than `:normal` and the task is not trapping "
"exits the\n"
"caller's exit signal will stop the task. The caller can exit with reason\n"
"`:shutdown` to shutdown linked processes, such as tasks, that are not "
"trapping\n"
"exits without generating any log messages.\n"
"\n"
"This function assumes the task's monitor is still active or the monitor's\n"
"`:DOWN` message is in the message queue. If it has been demonitored, or the\n"
"message already received, this function will block forever awaiting the "
"message.\n"
msgstr ""
"タスクをunlinkしshutdownし、応答をチェックします。\n"
"\n"
"タスクのシャットダウン中にもし応答が受信されたら、`{:ok, reply}`を\n"
"返し、さもなければ`nil`を返します。\n"
"\n"
"shutdownメソッドはタイムアウトか`:brutal_kill`が出来ます。\n"
"`timeout`の場合、`:shutdown` exitシグナルがタスクプロセスに\n"
"送信され、タイムアウトの間にexitしないならkillされます。\n"
"`:brutal_kill`では、タスクは直接killされます。\n"
"タスクが異常終了した場合、あるいはタスクがタイムアウトでkillされた\n"
"場合、この関数は同じ reason で exit します。\n"
"\n"
"reason `:normal`で終了していないかぎり、またはタスクがexitを\n"
"トラップしていないかぎり、呼出し側を終了するときにこの関数を\n"
"呼ぶことは必要ありません。もし呼出し側が`:normal`以外のreasonで\n"
"exitしたり、タスクがexitをトラップしていないなら、呼出し側の\n"
"exitシグナルがタスクを終了させます。呼出し側がreason `:shutdown`\n"
"のexitでリンクされたプロセスをシャットダウンし、タスクもいかなるログ\n"
"メッセージも無しにexitします(トラップされていないなら)。\n"
"\n"
"この関数はタスクのモニタがアクティブあるいは、\n"
"`:DOWN`メッセージがメッセージキューにあることを仮定しています。\n"
"もし非モニタされていた、あるいは、メッセージが既に受信されていたら、\n"
"この関数はタイムアウトの期間中メッセージを待つでしょう。\n"

#. TRANSLATORS: def Task.__struct__()
#: lib/task.ex:137
msgid ""
"The Task struct.\n"
"\n"
"It contains two fields:\n"
"\n"
"  * `:pid` - the process reference of the task process; `nil` if the task "
"does\n"
"    not use a task process.\n"
"\n"
"  * `:ref` - the task monitor reference\n"
"\n"
msgstr ""
"タスク構造体です。\n"
"\n"
"二つのフィールドを含みます:\n"
"\n"
"  * `:pid` - タスクプロセスのリファレンス; タスクが\n"
"             タスクプロセスを使っていないなら`nil`です\n"
"\n"
"  * `:ref` - タスクモニタのリファレンスです\n"
"\n"

#. TRANSLATORS: def Task.start(mod, fun, args)
#: lib/task.ex:180
msgid ""
"Starts a task.\n"
"\n"
"This is only used when the task is used for side-effects\n"
"(i.e. no interest in its return result) and it should not\n"
"be linked to the current process.\n"
msgstr ""
"タスクを開始します。\n"
"\n"
"タスクが副作用(即ち、戻り結果に対する関心がない)のために\n"
"使われるときにのみ使われ、それは現在のプロセスとリンク\n"
"されていてはなりません。\n"

#. TRANSLATORS: def Task.async(mod, fun, args)
#: lib/task.ex:212
msgid ""
"Starts a task that can be awaited on.\n"
"\n"
"This function spawns a process that is linked to and monitored\n"
"by the caller process. A `Task` struct is returned containing\n"
"the relevant information.\n"
"\n"
"Read the `Task` module documentation for more info on general\n"
"usage of `async/1` and `async/3`.\n"
"\n"
"## Task's message format\n"
"\n"
"The reply sent by the task will be in the format `{ref, msg}`,\n"
"where `ref` is the monitoring reference held by the task.\n"
msgstr ""
"待機することができるタスクを開始します。\n"
"\n"
"この関数は、呼び出し側プロセスによりリンクされ、モニタされる、\n"
"プロセスを生成します。関連した情報を含む`Task`構造体が返されます。\n"
"\n"
"`async/1` と `async/3` の一斑的な使いかたについては、\n"
" `Task`モジュールのドキュメントを参照してください。\n"
"\n"
"## Taskのメッセージフォーマット\n"
"\n"
"タスクによって送られる応答は`{ref, msg}`というフォーマットです。\n"
"`ref`はタスクによって保持されるモニタリファレンスです。\n"

#. TRANSLATORS: def Task.start_link(mod, fun, args)
#: lib/task.ex:160
msgid "Starts a task as part of a supervision tree.\n"
msgstr "監督ツリーの一部としてタスクを開始します。\n"

#. TRANSLATORS: def Task.find(tasks, msg)
#: lib/task.ex:278
msgid ""
"Receives a group of tasks and a message and finds\n"
"a task that matches the given message.\n"
"\n"
"This function returns a tuple with the returned value\n"
"in case the message matches a task that exited with\n"
"success alongside the matching task. It raises in case\n"
"the found task failed or `nil` if no task was found.\n"
"\n"
"This function is useful in situations where multiple\n"
"tasks are spawned and their results are collected\n"
"later on. For example, a `GenServer` can spawn tasks,\n"
"store the tasks in a list and later use `Task.find/2`\n"
"to see if incoming messages are from any of the tasks.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule TaskFinder do\n"
"      def run do\n"
"        task1 = Task.async fn -> :timer.sleep(1000); 1 end\n"
"        task2 = Task.async fn -> :timer.sleep(5000); 2 end\n"
"        await [task1, task2]\n"
"      end\n"
"\n"
"      # Be careful, this will receive all messages sent\n"
"      # to this process. It will return the first task\n"
"      # reply and the list of tasks that came second.\n"
"      def await(tasks) do\n"
"        receive do\n"
"          message ->\n"
"            case Task.find(tasks, message) do\n"
"              {reply, task} ->\n"
"                {reply, List.delete(tasks, task)}\n"
"              nil ->\n"
"                await(tasks)\n"
"            end\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    TaskFinder.run\n"
msgstr ""
"一群のタスクとメッセージを受けて、そのメッセージ\n"
"にマッチするタスクを見付けます。\n"
"\n"
"この関数は、\n"
"マッチしたタスクが処理に成功して終了した場合に\n"
"備えて、そのタスクが返した値とタスクのタプルを返します。\n"
"タスクが失敗を見付けたら、例外を上げ、タスクが見付\n"
"からない場合、`nil`を返します。\n"
"\n"
"この関数は複数のタスクを生成し、それらの結果を後で\n"
"集めるときに便利です。例えば、`GenServer`が\n"
"タスクを生成し、リストにタスクを保存しておき、\n"
"後で、そららのタスクからメッセージを受信したとき\n"
"`Task.find/2`を使います。\n"
"\n"
"## Examples\n"
"\n"
"    defmodule TaskFinder do\n"
"      def run do\n"
"        task1 = Task.async fn -> :timer.sleep(1000); 1 end\n"
"        task2 = Task.async fn -> :timer.sleep(5000); 2 end\n"
"        await [task1, task2]\n"
"      end\n"
"\n"
"      # Be careful, this will receive all messages sent\n"
"      # to this process. It will return the first task\n"
"      # reply and the list of tasks that came second.\n"
"      def await(tasks) do\n"
"        receive do\n"
"          message ->\n"
"            case Task.find(tasks, message) do\n"
"              {reply, task} ->\n"
"                {reply, List.delete(tasks, task)}\n"
"              nil ->\n"
"                await(tasks)\n"
"            end\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    TaskFinder.run\n"

#. TRANSLATORS: Elixir.Task Summary
#: lib/task.ex:2
msgid ""
"Conveniences for spawning and awaiting for tasks.\n"
"\n"
"Tasks are processes meant to execute one particular\n"
"action throughout their life-cycle, often with little or no\n"
"communication with other processes. The most common use case\n"
"for tasks is to compute a value asynchronously:\n"
"\n"
"    task = Task.async(fn -> do_some_work() end)\n"
"    res  = do_some_other_work()\n"
"    res + Task.await(task)\n"
"\n"
"Tasks spawned with `async` can be awaited on by its caller\n"
"process (and only its caller) as shown in the example above.\n"
"They are implemented by spawning a process that sends a message\n"
"to the caller once the given computation is performed.\n"
"\n"
"Besides `async/1` and `await/2`, tasks can also be\n"
"started as part of supervision trees and dynamically spawned\n"
"in remote nodes. We will explore all three scenarios next.\n"
"\n"
"## async and await\n"
"\n"
"The most common way to spawn a task is with `Task.async/1`. A new\n"
"process will be created, linked and monitored by the caller. Once\n"
"the task action finishes, a message will be sent to the caller\n"
"with the result.\n"
"\n"
"`Task.await/2` is used to read the message sent by the task.\n"
"`await` will check the monitor setup by the call to `async/1' to\n"
"verify if the process exited for any abnormal reason (or in case\n"
"exits are being trapped by the caller).\n"
"\n"
"There are two important things to consider when using async:\n"
"\n"
"  1. If you are using async tasks, you must await for a reply\n"
"     as they are *always* sent. If you are not expecting a reply,\n"
"     consider using `Task.start_link/1` detailed below\n"
"\n"
"  2. async tasks link the caller and the spawned process. This\n"
"     means that, if the caller crashes, the task will crash\n"
"     too and vice-versa. This is on purpose, if the process\n"
"     meant to receive the result no longer exists, there is\n"
"     no purpose in computing the result until the end. If this\n"
"     is not desired, consider using `Task.start_link/1` as well\n"
"\n"
"`Task.yield/2` is an alternative to `await/2` where the caller will\n"
"temporarily block waiting for a task's result. If the result does not\n"
"arrive within the timeout it can be called again at later moment. This\n"
"allows checking for the result of a task multiple times or to handle\n"
"a timeout. If a reply does not arrive within the desired time, and the\n"
"caller is not going exit, `Task.shutdown/2` can be used to stop the task.\n"
"\n"
"## Supervised tasks\n"
"\n"
"It is also possible to spawn a task inside a supervision tree\n"
"with `start_link/1` and `start_link/3`:\n"
"\n"
"    Task.start_link(fn -> IO.puts \"ok\" end)\n"
"\n"
"Such tasks can be mounted in your supervision tree as:\n"
"\n"
"    import Supervisor.Spec\n"
"\n"
"    children = [\n"
"      worker(Task, [fn -> IO.puts \"ok\" end])\n"
"    ]\n"
"\n"
"Since these tasks are supervised and not directly linked to\n"
"the caller, they cannot be awaited on. Note `start_link/1`,\n"
"unlike `async/1`, returns `{:ok, pid}` (which is\n"
"the result expected by supervision trees).\n"
"\n"
"By default, most supervision strategies will try to restart\n"
"a worker after it exits regardless of reason. If you design the\n"
"task to terminate normally (as in the example with `IO.puts/2` above),\n"
"consider passing `restart: :transient` in the options to `worker/3`.\n"
"\n"
"## Dynamically supervised tasks\n"
"\n"
"The `Task.Supervisor` module allows developers to dynamically\n"
"create multiple supervised tasks.\n"
"\n"
"A short example is:\n"
"\n"
"    {:ok, pid} = Task.Supervisor.start_link()\n"
"    task = Task.Supervisor.async(pid, fn ->\n"
"      # Do something\n"
"    end)\n"
"    Task.await(task)\n"
"\n"
"However, in the majority of cases, you want to add the task supervisor\n"
"to your supervision tree:\n"
"\n"
"    import Supervisor.Spec\n"
"\n"
"    children = [\n"
"      supervisor(Task.Supervisor, [[name: MyApp.TaskSupervisor]])\n"
"    ]\n"
"\n"
"Now you can dynamically start supervised tasks:\n"
"\n"
"    Task.Supervisor.start_child(MyApp.TaskSupervisor, fn ->\n"
"      # Do something\n"
"    end)\n"
"\n"
"Or even use the async/await pattern:\n"
"\n"
"    Task.Supervisor.async(MyApp.TaskSupervisor, fn ->\n"
"      # Do something\n"
"    end) |> Task.await()\n"
"\n"
"Finally, check `Task.Supervisor` for other operations supported by the\n"
"Task supervisor.\n"
"\n"
"## Distributed tasks\n"
"\n"
"Since Elixir provides a Task supervisor, it is easy to use a task\n"
"supervisor to dynamically spawn tasks across nodes:\n"
"\n"
"    # In the remote node\n"
"    Task.Supervisor.start_link(name: MyApp.DistSupervisor)\n"
"\n"
"    # In the client\n"
"    Task.Supervisor.async({MyApp.DistSupervisor, :remote@local},\n"
"                          MyMod, :my_fun, [arg1, arg2, arg3])\n"
"\n"
"Note that, when working with distributed tasks, one should use the `async/4` "
"function\n"
"that expects explicit module, function and arguments, instead of `async/2` "
"that\n"
"works with anonymous functions. That's because anonymous functions expect\n"
"the same module version to exist on all involved nodes. Check the `Agent` "
"module\n"
"documentation for more information on distributed processes as the "
"limitations\n"
"described in the agents documentation apply to the whole ecosystem.\n"
msgstr ""
"タスクの生成と待合せに便利なものです。\n"
"\n"
"タスクはそのライフサイクルを通じて、他の\n"
"プロセスとのコミュニケーションが少ない、あるいは全くない\n"
"一つの特定の行動をするプロセスです。\n"
"タスクの最も一般的なユースケースは、非同期な値の計算です:\n"
"\n"
"    task = Task.async(fn -> do_some_work() end)\n"
"    res  = do_some_other_work()\n"
"    res + Task.await(task)\n"
"\n"
"`async`で生成されたタスクは、上の例で示すように、\n"
"その呼出し側プロセスで(そして呼出し側だけで)待たれます。\n"
"生成されたプロセスは、与えられた計算が実行されたら、\n"
"呼出し側へメッセージを送信するように実装されています。\n"
"\n"
"`async/1`と`await/2`の他に、タスクは、\n"
"supervisionツリーから開始されたり、リモートノードで\n"
"動的に生成されることもあります。\n"
"次に全ての3つのシナリオを調査します。\n"
"\n"
"## async and await\n"
"\n"
"タスクを生成する最も一般的な方法は、`Task.async/1`です。\n"
"新しいプロセスは作成され、呼出し側プロセスにリンクされ、\n"
"モニタされます。\n"
"タスクの活動が終了したら、その結果と一緒に呼出し側へ\n"
"メッセージを送信します。\n"
"\n"
"`Task.await/2`はタスクから送信されたメッセージを読むために\n"
"使われます。\n"
"`await`は、プロセスが異常なreasonで終了したか\n"
"(または、呼出し側でトラップされている場合に備えて)\n"
"`async/1`の呼び出しによりセットアップされたモニタを\n"
"チェックします。\n"
"\n"
"asyncを使うときの重要な考慮点は二つです:\n"
"\n"
"  1. asyncタスクを使うなら、 *常に* 応答が送信されるので、\n"
"     awaitしなければなりません。もし応答が必要としないなら、\n"
"     以下に詳述する `Task.start_link/1` を考慮してください。\n"
"\n"
"  2. asyncタスクは呼出し側と生成されたプロセスにリンクします。\n"
"     これは、もし呼出し側がクラッシュしたらタスクも\n"
"     クラッシュし、逆もまた同じことを意味します。\n"
"     結果を受信するはずのプロセスがもはや存在しないなら、\n"
"     終りまで計算する目的がないです。\n"
"     もしこれが望まれないなら、`Task.start_link/1`を使うことを\n"
"     考慮してください。\n"
"\n"
"`Task.yield/2`は呼出し側がタスクの結果を待つときに一時的に\n"
"ブロックする`await/2`に代るものです。もし結果がタイムアウトの\n"
"なかで到着しないなら、それは後でまた呼ぶことができます。\n"
"これは複数回タスクの結果をチェックすることと、\n"
"タイムアウトをハンドルすることを許します。\n"
"もし望み通りの時間で応答が到着しないなら、そして呼出し側が\n"
"終了していないなら、タスクを終了させるため`Task.shutdown/2`\n"
"を呼ぶことができます。\n"
"\n"
"## Supervised tasks\n"
"\n"
"supervisionツリーの中で、`start_link/1`と`start_link/3`を使って\n"
"タスクを生成することも可能です:\n"
"\n"
"    Task.start_link(fn -> IO.puts \"ok\" end)\n"
"\n"
"そのようなタスクはsupervisionツリーに以下のようにマウントできます:\n"
"\n"
"    import Supervisor.Spec\n"
"\n"
"    children = [\n"
"      worker(Task, [fn -> IO.puts \"ok\" end])\n"
"    ]\n"
"\n"
"これらのタスクがsuperviseされると、呼出し側への直接の\n"
"リンクはされませんので、awaitが出来ません。`async/1`\n"
"と違って、`start_link/1`は\n"
"`{:ok, pid}`(これはsupervisionツリーから期待された結果です)\n"
"を返すことに注意してください。\n"
"\n"
"デフォルトで、殆どのsupervisionストラテジは理由に関わりなく\n"
"終了したらworkerの再起動を試みます。もし\n"
"タスクを正常に終了するように設計するなら(上の\n"
"例での`IO.puts/2`のように)、`worker/3`の\n"
"オプションに`restart: :transient`を渡すことを考慮\n"
"してください。\n"
"\n"
"## Dynamically supervised tasks\n"
"\n"
"`Task.Supervisor`モジュールは開発者に動的に複数の\n"
"superviseされたタスクを作成することを許します。\n"
"\n"
"短かい例:\n"
"\n"
"    {:ok, pid} = Task.Supervisor.start_link()\n"
"    task = Task.Supervisor.async(pid, fn ->\n"
"      # Do something\n"
"    end)\n"
"    Task.await(task)\n"
"\n"
"しかしながら、多くの場合、タスクsupervisorをあなたの\n"
"supervisionツリーに追加したいでしょう:\n"
"\n"
"    import Supervisor.Spec\n"
"\n"
"    children = [\n"
"      supervisor(Task.Supervisor, [[name: MyApp.TaskSupervisor]])\n"
"    ]\n"
"\n"
"いまやsuperviseされたタスクを動的に開始できます:\n"
"\n"
"    Task.Supervisor.start_child(MyApp.TaskSupervisor, fn ->\n"
"      # Do something\n"
"    end)\n"
"\n"
"あるいは、async/awaitパターンを使うこともできます:\n"
"\n"
"    Task.Supervisor.async(MyApp.TaskSupervisor, fn ->\n"
"      # Do something\n"
"    end) |> Task.await()\n"
"\n"
"最後に、タスクsupervisorのサポートする他のオペレーションを\n"
"`Task.Supervisor`でチェックしてください。\n"
"\n"
"## Distributed tasks\n"
"\n"
"Elixirがタスクsupervisorを提供したときから、\n"
"ノードを越えてタスクを動的に生成することが\n"
"タスクsupervisorで使い易くなりました:\n"
"\n"
"    # In the remote node\n"
"    Task.Supervisor.start_link(name: MyApp.DistSupervisor)\n"
"\n"
"    # In the client\n"
"    Task.Supervisor.async({MyApp.DistSupervisor, :remote@local},\n"
"                          MyMod, :my_fun, [arg1, arg2, arg3])\n"
"\n"
"分散タスクで動作しているとき、明確なモジュール、関数と引数(\n"
"無名関数で動く`async/2`の代わりに)を期待する`async/4`を使わなければ\n"
"なりません。\n"
"それは無名関数が全ての関連あるノードで同じモジュールバージョンが\n"
"存在することを期待するからです。\n"
"詳細は`Agent`モジュールドキュメントを参照してください。\n"
"エージェントドキュメントで記述されている分散処理についての\n"
"制限は、エコシステム全体に適用されます。\n"

#. TRANSLATORS: def Task.await(task, timeout \\ 5000)
#: lib/task.ex:244
msgid ""
"Awaits a task reply.\n"
"\n"
"A timeout, in milliseconds, can be given with default value\n"
"of `5000`. In case the task process dies, this function will\n"
"exit with the same reason as the task.\n"
"\n"
"If the timeout is exceeded, `await` will exit, however,\n"
"the task will continue to run. When the calling process exits, its\n"
"exit signal will close the task if it is not trapping exits.\n"
"\n"
"This function assumes the task's monitor is still active or the monitor's\n"
"`:DOWN` message is in the message queue. If it has been demonitored, or the\n"
"message already received, this function may wait for the duration of the\n"
"timeout awaiting the message.\n"
"\n"
"This function will always demonitor the task and so the task can not be "
"used\n"
"again. To await the task's reply multiple times use `yield/2` instead.\n"
msgstr ""
"タスクの応答を待ちます。\n"
"\n"
"ミリ秒でのtimeoutを与えることができます。デフォルト値`5000`です。\n"
"タスクプロセスが死んだ場合、この関数はタスクと同じreasonで\n"
"exitします。\n"
"\n"
"タイムアウトに到達したら、`await`はexitしますが、\n"
"タスクは動きつづけます。呼出し側プロセスが終了したとき、\n"
"そのexit シグナルがexitをトラップしていない限り、\n"
"タスクに複製されます。\n"
"\n"
"この関数はタスクのモニタがまだ動作中である、あるいは\n"
"モニタの`:DOWN`メッセージがメッセージキューにあると仮定しています。\n"
"もし非モニタされた、あるいはメッセージが既に受信されたら、\n"
"この関数はtimeoutの期間中、メッセージを待ちつづけます。\n"
"\n"
"この関数は常にタスクを非モニタするので、そのタスクは\n"
"二度と使うことができません。タスクの応答を複数回待つためには、\n"
"`yield/2`を代わりに使ってください。\n"

#~ msgid ""
#~ "Receives a group of tasks and a message and finds\n"
#~ "a task that matches the given message.\n"
#~ "\n"
#~ "This function returns a tuple with the task and the\n"
#~ "returned value in case the message matches a task that\n"
#~ "exited with success, it raises in case the found task\n"
#~ "failed or `nil` if no task was found.\n"
#~ "\n"
#~ "This function is useful in situations where multiple\n"
#~ "tasks are spawned and their results are collected\n"
#~ "later on. For example, a `GenServer` can spawn tasks,\n"
#~ "store the tasks in a list and later use `Task.find/2`\n"
#~ "to see if incoming messages are from any of the tasks.\n"
#~ msgstr ""
#~ "タスクとメッセージのグループを受け取り、\n"
#~ "与えられたメッセージにマッチするタスクを見付けます。\n"
#~ "\n"
#~ "この関数は、タスク付のタプルを返し、返された値は成功して終了したタスク\n"
#~ "にマッチするメッセージです。タスクが見付けられない時、タスクが失敗ある\n"
#~ "いは`nil`を返した時はエラーを上げます。\n"
#~ "\n"
#~ "この関数は、複数のタスクが生成され、それらの結果をあとで集めるというシ\n"
#~ "チュエーションで、便利です。例えば、`GenServer`はタスクを生成することが\n"
#~ "でき、タスクをリストに格納して、後で他のタスクからのメッセージが来とき\n"
#~ "に、`Task.find/2`を使い、タスクを参照することが出来ます。\n"

#~ msgid ""
#~ "Starts a task that can be awaited on.\n"
#~ "\n"
#~ "Similar to `async/1`, but the task is specified by the given\n"
#~ "module, function and arguments.\n"
#~ msgstr ""
#~ "待機することができるタスクを開始します。\n"
#~ "\n"
#~ "`async/1`と似ていますが、タスクは与えられたモジュール、関数\n"
#~ "および引数により指定されます。\n"

#~ msgid ""
#~ "Awaits a task reply.\n"
#~ "\n"
#~ "A timeout, in milliseconds, can be given with default value\n"
#~ "of `5000`. In case the task process dies, this function will\n"
#~ "exit with the same reason as the task.\n"
#~ msgstr ""
#~ "タスクの応答を待ちます。\n"
#~ "\n"
#~ "タイムアウト(ミリ秒)を与えることができ、デフォルト値は`5000`です。\n"
#~ "タスクプロセスが死んだ場合、この関数は、\n"
#~ "そのタスクと同じreasonでexitします。\n"

#~ msgid ""
#~ "Conveniences for spawning and awaiting for tasks.\n"
#~ "\n"
#~ "Tasks are processes meant to execute one particular\n"
#~ "action throughout their life-cycle, often with little or no\n"
#~ "communication with other processes. The most common use case\n"
#~ "for tasks is to compute a value asynchronously:\n"
#~ "\n"
#~ "    task = Task.async(fn -> do_some_work() end)\n"
#~ "    res  = do_some_other_work()\n"
#~ "    res + Task.await(task)\n"
#~ "\n"
#~ "Tasks spawned with `async` can be awaited on by its caller\n"
#~ "process (and only its caller) as shown in the example above.\n"
#~ "They are implemented by spawning a process that sends a message\n"
#~ "to the caller once the given computation is performed.\n"
#~ "\n"
#~ "Besides `async/1` and `await/2`, tasks can also be\n"
#~ "started as part of supervision trees and dynamically spawned\n"
#~ "in remote nodes. We will explore all three scenarios next.\n"
#~ "\n"
#~ "## async and await\n"
#~ "\n"
#~ "The most common way to spawn a task is with `Task.async/1`. A new\n"
#~ "process will be created, linked and monitored by the caller. Once\n"
#~ "the task action finishes, a message will be sent to the caller\n"
#~ "with the result.\n"
#~ "\n"
#~ "`Task.await/2` is used to read the message sent by the task. On\n"
#~ "`await`, Elixir will also setup a monitor to verify if the process\n"
#~ "exited for any abnormal reason (or in case exits are being\n"
#~ "trapped by the caller).\n"
#~ "\n"
#~ "## Supervised tasks\n"
#~ "\n"
#~ "It is also possible to spawn a task inside a supervision tree\n"
#~ "with `start_link/1` and `start_link/3`:\n"
#~ "\n"
#~ "    Task.start_link(fn -> IO.puts \"ok\" end)\n"
#~ "\n"
#~ "Such tasks can be mounted in your supervision tree as:\n"
#~ "\n"
#~ "    import Supervisor.Spec\n"
#~ "\n"
#~ "    children = [\n"
#~ "      worker(Task, [fn -> IO.puts \"ok\" end])\n"
#~ "    ]\n"
#~ "\n"
#~ "Since these tasks are supervised and not directly linked to\n"
#~ "the caller, they cannot be awaited on. Note `start_link/1`,\n"
#~ "unlike `async/1`, returns `{:ok, pid}` (which is\n"
#~ "the result expected by supervision trees).\n"
#~ "\n"
#~ "## Supervision trees\n"
#~ "\n"
#~ "The `Task.Supervisor` module allows developers to start supervisors\n"
#~ "that dynamically supervise tasks:\n"
#~ "\n"
#~ "    {:ok, pid} = Task.Supervisor.start_link()\n"
#~ "    Task.Supervisor.async(pid, MyMod, :my_fun, [arg1, arg2, arg3])\n"
#~ "\n"
#~ "`Task.Supervisor` also makes it possible to spawn tasks in remote nodes "
#~ "as\n"
#~ "long as the supervisor is registered locally or globally:\n"
#~ "\n"
#~ "    # In the remote node\n"
#~ "    Task.Supervisor.start_link(name: :tasks_sup)\n"
#~ "\n"
#~ "    # In the client\n"
#~ "    Task.Supervisor.async({:tasks_sup, :remote@local}, MyMod, :my_fun, "
#~ "[arg1, arg2, arg3])\n"
#~ "\n"
#~ "`Task.Supervisor` is more often started in your supervision tree as:\n"
#~ "\n"
#~ "    import Supervisor.Spec\n"
#~ "\n"
#~ "    children = [\n"
#~ "      supervisor(Task.Supervisor, [[name: :tasks_sup]])\n"
#~ "    ]\n"
#~ "\n"
#~ "Note that, when working with distributed tasks, one should use the "
#~ "`async/3` API,\n"
#~ "that expects explicit module, function and arguments, instead of "
#~ "`async/1` that\n"
#~ "works with anonymous functions. That's because the anonymous function API "
#~ "expects\n"
#~ "the same module version to exist on all involved nodes. Check the `Agent` "
#~ "module\n"
#~ "documentation for more information on distributed processes, as the "
#~ "limitations\n"
#~ "described in the agents documentation apply to the whole ecosystem.\n"
#~ "\n"
#~ "Finally, check `Task.Supervisor` for other operations supported by the "
#~ "Task\n"
#~ "supervisor.\n"
#~ msgstr ""
#~ "タスクの生成と、待ち受けに便利なものです。\n"
#~ "\n"
#~ "タスクは、そのライフサイクルを通して、一つの特定の活動を実行するはずの\n"
#~ "プロセスです。そのプロセスは、しばしば、少しだけ、または全く他のプロセ\n"
#~ "スとコミュニケーションをとりません。\n"
#~ "タスクのための最も一般的なユースケースは、\n"
#~ "非同期的に値を計算することです:\n"
#~ "\n"
#~ "    task = Task.async(fn -> do_some_work() end)\n"
#~ "    res  = do_some_other_work()\n"
#~ "    res + Task.await(task)\n"
#~ "\n"
#~ "`async`により生み出されたタスクは、上の例で見られるように、\n"
#~ "呼び出しプロセス(そしてその呼び出し側だけに)により待たれます。\n"
#~ "一度与えられた計算が実行されるなら、呼び出し側に\n"
#~ "メッセージを送信するプロセスを生み出すことによって、それらは\n"
#~ "実装されます。\n"
#~ "\n"
#~ "`async/1`と`await/2`の他に、タスクはスーパビジョンツリー\n"
#~ "の一部として開始したり、リモートノードで動的に生み出すことも\n"
#~ "出来ます。次に、全3つのシナリオを調査します。\n"
#~ "\n"
#~ "## async and await\n"
#~ "\n"
#~ "タスクを生む最も一般的な方法は`Task.async/1`です。新しい\n"
#~ "プロセスが作成され、呼び出し側によりリンクされ、モニタされます。\n"
#~ "一度タスクのアクションが終了したら、結果として呼び出し側に\n"
#~ "メッセージが送信されます。\n"
#~ "\n"
#~ "`Task.await/2`はタスクにより送信されたメッセージを読み出すために使われ\n"
#~ "ます。`await`で、Elixirは、プロセスが異常な理由でexitしているかどうか\n"
#~ "(または、呼び出し側によりトラップされるexitしているかどうか)、検証する\n"
#~ "ためのモニタをセットアップします。\n"
#~ "\n"
#~ "## Supervised tasks\n"
#~ "\n"
#~ "`start_link/2`と`start_link/3`でスーパビジョンツリーの内でタスクを\n"
#~ "生み出すこともできます:\n"
#~ "\n"
#~ "    Task.start_link(fn -> IO.puts \"ok\" end)\n"
#~ "\n"
#~ "そのようなタスクは以下のようにして、スーパビジョンツリーに\n"
#~ "取り付けることもできます:\n"
#~ "\n"
#~ "    import Supervisor.Spec\n"
#~ "\n"
#~ "    children = [\n"
#~ "      worker(Task, [fn -> IO.puts \"ok\" end])\n"
#~ "    ]\n"
#~ "\n"
#~ "これらのタスクはスーパバイズされ、直接呼び出し側にリンクされて\n"
#~ "いないので、awaitで待つことが出来ません。\n"
#~ "`start_link/1`(`async/1`と違って)は、`{:ok, pid}`\n"
#~ "(スーバビジョンツリーにより期待される結果です)を返すことに\n"
#~ "注意してください。\n"
#~ "\n"
#~ "## Supervision trees\n"
#~ "\n"
#~ "`Task.Supervisor`モジュールは、開発者に、\n"
#~ "動的にタスクをスーパバイズするスーパバイザを開始することを許します:\n"
#~ "\n"
#~ "    {:ok, pid} = Task.Supervisor.start_link()\n"
#~ "    Task.Supervisor.async(pid, MyMod, :my_fun, [arg1, arg2, arg3])\n"
#~ "\n"
#~ "スーパバイザがローカルまたは、グローバルに登録される限り、\n"
#~ "`Task.Supervisor`もまた、リモートノードでタスクを生むことを可能にします:\n"
#~ "\n"
#~ "    # In the remote node\n"
#~ "    Task.Supervisor.start_link(name: :tasks_sup)\n"
#~ "\n"
#~ "    # In the client\n"
#~ "    Task.Supervisor.async({:tasks_sup, :remote@local}, MyMod, :my_fun, "
#~ "[arg1, arg2, arg3])\n"
#~ "\n"
#~ "`Task.Supervisor`は、スーバビジョンツリーでよりしばしば開始されます:\n"
#~ "\n"
#~ "    import Supervisor.Spec\n"
#~ "\n"
#~ "    children = [\n"
#~ "      supervisor(Task.Supervisor, [[name: :tasks_sup]])\n"
#~ "    ]\n"
#~ "\n"
#~ "なお、分散されたタスクで動くとき、無名関数を動かす`async/1`のかわりに、\n"
#~ "モジュール、関数、引数を明示的に期待する、`async/3`APIを使うべきです。\n"
#~ "これは、無名関数APIは全ての起動されたノードで同じモジュールバージョンが\n"
#~ "存在することを期待するためです。\n"
#~ "全エコシステムに適用される、エージェントドキュメントで記述される制限として"
#~ "の、\n"
#~ "分散プロセスの詳細は、`Agent`モジュールドキュメントをチェックしてくださ"
#~ "い。\n"
#~ "\n"
#~ "最後に、他のタスクスーパバイザによりサポートされるオペレーションについて\n"
#~ "の詳細は、 `Task.Supervisor` をチェックしてください。\n"
