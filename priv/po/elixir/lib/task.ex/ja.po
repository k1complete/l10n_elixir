msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2015-05-20 21:55+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: def Task.__struct__()
#: lib/task.ex:102
msgid ""
"The Task struct.\n"
"\n"
"It contains two fields:\n"
"\n"
"  * `:pid` - the process reference of the task process; it may be a pid\n"
"    or a tuple containing the process and node names\n"
"\n"
"  * `:ref` - the task monitor reference\n"
"\n"
msgstr ""
"タスク構造体です。\n"
"\n"
"二つのフィールドを含みます:\n"
"\n"
"  * `:pid` - タスクプロセスのリファレンス; pidかプロセスとノード名を\n"
"             含んだタプルです。\n"
"\n"
"  * `:ref` - タスクモニタのリファレンスです\n"
"\n"

#. TRANSLATORS: def Task.find(tasks, msg)
#: lib/task.ex:227
msgid ""
"Receives a group of tasks and a message and finds\n"
"a task that matches the given message.\n"
"\n"
"This function returns a tuple with the task and the\n"
"returned value in case the message matches a task that\n"
"exited with success, it raises in case the found task\n"
"failed or `nil` if no task was found.\n"
"\n"
"This function is useful in situations where multiple\n"
"tasks are spawned and their results are collected\n"
"later on. For example, a `GenServer` can spawn tasks,\n"
"store the tasks in a list and later use `Task.find/2`\n"
"to see if incoming messages are from any of the tasks.\n"
msgstr ""
"タスクとメッセージのグループを受け取り、\n"
"与えられたメッセージにマッチするタスクを見付けます。\n"
"\n"
"この関数は、タスク付のタプルを返し、返された値は成功して終了したタスク\n"
"にマッチするメッセージです。タスクが見付けられない時、タスクが失敗ある\n"
"いは`nil`を返した時はエラーを上げます。\n"
"\n"
"この関数は、複数のタスクが生成され、それらの結果をあとで集めるというシ\n"
"チュエーションで、便利です。例えば、`GenServer`はタスクを生成することが\n"
"でき、タスクをリストに格納して、後で他のタスクからのメッセージが来とき\n"
"に、`Task.find/2`を使い、タスクを参照することが出来ます。\n"

#. TRANSLATORS: def Task.start(mod, fun, args)
#: lib/task.ex:142
msgid ""
"Starts a task.\n"
"\n"
"This is only used when the task is used for side-effects\n"
"(i.e. no interest in its return result) and it should not\n"
"be linked to the current process.\n"
msgstr ""
"タスクを開始します。\n"
"\n"
"タスクが副作用(即ち、戻り結果に対する関心がない)のために\n"
"使われるときにのみ使われ、それは現在のプロセスとリンク\n"
"されていてはなりません。\n"

#. TRANSLATORS: def Task.async(fun)
#: lib/task.ex:159
msgid ""
"Starts a task that can be awaited on.\n"
"\n"
"This function spawns a process that is linked to and monitored\n"
"by the caller process. A `Task` struct is returned containing\n"
"the relevant information.\n"
"\n"
"## Task's message format\n"
"\n"
"The reply sent by the task will be in the format `{ref, msg}`,\n"
"where `ref` is the monitoring reference held by the task.\n"
msgstr ""
"待機することができるタスクを開始します。\n"
"\n"
"この関数は、呼び出し側プロセスによりリンクされ、モニタされる、\n"
"プロセスを生成します。関連した情報を含む`Task`構造体が返されます。\n"
"\n"
"## Taskのメッセージフォーマット\n"
"\n"
"タスクによって送られる応答は`{ref, msg}`というフォーマットです。\n"
"`ref`はタスクによって保持されるモニタリファレンスです。\n"

#. TRANSLATORS: def Task.async(mod, fun, args)
#: lib/task.ex:170
msgid ""
"Starts a task that can be awaited on.\n"
"\n"
"Similar to `async/1`, but the task is specified by the given\n"
"module, function and arguments.\n"
msgstr ""
"待機することができるタスクを開始します。\n"
"\n"
"`async/1`と似ていますが、タスクは与えられたモジュール、関数\n"
"および引数により指定されます。\n"

#. TRANSLATORS: def Task.start_link(mod, fun, args)
#: lib/task.ex:118
msgid "Starts a task as part of a supervision tree.\n"
msgstr "監督ツリーの一部としてタスクを開始します。\n"

#. TRANSLATORS: def Task.await(task, timeout \\ 5000)
#: lib/task.ex:194
msgid ""
"Awaits a task reply.\n"
"\n"
"A timeout, in milliseconds, can be given with default value\n"
"of `5000`. In case the task process dies, this function will\n"
"exit with the same reason as the task.\n"
msgstr ""
"タスクの応答を待ちます。\n"
"\n"
"タイムアウト(ミリ秒)を与えることができ、デフォルト値は`5000`です。\n"
"タスクプロセスが死んだ場合、この関数は、\n"
"そのタスクと同じreasonでexitします。\n"

#. TRANSLATORS: Elixir.Task Summary
#: lib/task.ex:1
msgid ""
"Conveniences for spawning and awaiting for tasks.\n"
"\n"
"Tasks are processes meant to execute one particular\n"
"action throughout their life-cycle, often with little or no\n"
"communication with other processes. The most common use case\n"
"for tasks is to compute a value asynchronously:\n"
"\n"
"    task = Task.async(fn -> do_some_work() end)\n"
"    res  = do_some_other_work()\n"
"    res + Task.await(task)\n"
"\n"
"Tasks spawned with `async` can be awaited on by its caller\n"
"process (and only its caller) as shown in the example above.\n"
"They are implemented by spawning a process that sends a message\n"
"to the caller once the given computation is performed.\n"
"\n"
"Besides `async/1` and `await/2`, tasks can also be\n"
"started as part of supervision trees and dynamically spawned\n"
"in remote nodes. We will explore all three scenarios next.\n"
"\n"
"## async and await\n"
"\n"
"The most common way to spawn a task is with `Task.async/1`. A new\n"
"process will be created, linked and monitored by the caller. Once\n"
"the task action finishes, a message will be sent to the caller\n"
"with the result.\n"
"\n"
"`Task.await/2` is used to read the message sent by the task. On\n"
"`await`, Elixir will also setup a monitor to verify if the process\n"
"exited for any abnormal reason (or in case exits are being\n"
"trapped by the caller).\n"
"\n"
"## Supervised tasks\n"
"\n"
"It is also possible to spawn a task inside a supervision tree\n"
"with `start_link/1` and `start_link/3`:\n"
"\n"
"    Task.start_link(fn -> IO.puts \"ok\" end)\n"
"\n"
"Such tasks can be mounted in your supervision tree as:\n"
"\n"
"    import Supervisor.Spec\n"
"\n"
"    children = [\n"
"      worker(Task, [fn -> IO.puts \"ok\" end])\n"
"    ]\n"
"\n"
"Since these tasks are supervised and not directly linked to\n"
"the caller, they cannot be awaited on. Note `start_link/1`,\n"
"unlike `async/1`, returns `{:ok, pid}` (which is\n"
"the result expected by supervision trees).\n"
"\n"
"## Supervision trees\n"
"\n"
"The `Task.Supervisor` module allows developers to start supervisors\n"
"that dynamically supervise tasks:\n"
"\n"
"    {:ok, pid} = Task.Supervisor.start_link()\n"
"    Task.Supervisor.async(pid, MyMod, :my_fun, [arg1, arg2, arg3])\n"
"\n"
"`Task.Supervisor` also makes it possible to spawn tasks in remote nodes as\n"
"long as the supervisor is registered locally or globally:\n"
"\n"
"    # In the remote node\n"
"    Task.Supervisor.start_link(name: :tasks_sup)\n"
"\n"
"    # In the client\n"
"    Task.Supervisor.async({:tasks_sup, :remote@local}, MyMod, :my_fun, "
"[arg1, arg2, arg3])\n"
"\n"
"`Task.Supervisor` is more often started in your supervision tree as:\n"
"\n"
"    import Supervisor.Spec\n"
"\n"
"    children = [\n"
"      supervisor(Task.Supervisor, [[name: :tasks_sup]])\n"
"    ]\n"
"\n"
"Note that, when working with distributed tasks, one should use the `async/3` "
"API,\n"
"that expects explicit module, function and arguments, instead of `async/1` "
"that\n"
"works with anonymous functions. That's because the anonymous function API "
"expects\n"
"the same module version to exist on all involved nodes. Check the `Agent` "
"module\n"
"documentation for more information on distributed processes, as the "
"limitations\n"
"described in the agents documentation apply to the whole ecosystem.\n"
"\n"
"Finally, check `Task.Supervisor` for other operations supported by the Task\n"
"supervisor.\n"
msgstr ""
"タスクの生成と、待ち受けに便利なものです。\n"
"\n"
"タスクは、そのライフサイクルを通して、一つの特定の活動を実行するはずの\n"
"プロセスです。そのプロセスは、しばしば、少しだけ、または全く他のプロセ\n"
"スとコミュニケーションをとりません。\n"
"タスクのための最も一般的なユースケースは、\n"
"非同期的に値を計算することです:\n"
"\n"
"    task = Task.async(fn -> do_some_work() end)\n"
"    res  = do_some_other_work()\n"
"    res + Task.await(task)\n"
"\n"
"`async`により生み出されたタスクは、上の例で見られるように、\n"
"呼び出しプロセス(そしてその呼び出し側だけに)により待たれます。\n"
"一度与えられた計算が実行されるなら、呼び出し側に\n"
"メッセージを送信するプロセスを生み出すことによって、それらは\n"
"実装されます。\n"
"\n"
"`async/1`と`await/2`の他に、タスクはスーパビジョンツリー\n"
"の一部として開始したり、リモートノードで動的に生み出すことも\n"
"出来ます。次に、全3つのシナリオを調査します。\n"
"\n"
"## async and await\n"
"\n"
"タスクを生む最も一般的な方法は`Task.async/1`です。新しい\n"
"プロセスが作成され、呼び出し側によりリンクされ、モニタされます。\n"
"一度タスクのアクションが終了したら、結果として呼び出し側に\n"
"メッセージが送信されます。\n"
"\n"
"`Task.await/2`はタスクにより送信されたメッセージを読み出すために使われ\n"
"ます。`await`で、Elixirは、プロセスが異常な理由でexitしているかどうか\n"
"(または、呼び出し側によりトラップされるexitしているかどうか)、検証する\n"
"ためのモニタをセットアップします。\n"
"\n"
"## Supervised tasks\n"
"\n"
"`start_link/2`と`start_link/3`でスーパビジョンツリーの内でタスクを\n"
"生み出すこともできます:\n"
"\n"
"    Task.start_link(fn -> IO.puts \"ok\" end)\n"
"\n"
"そのようなタスクは以下のようにして、スーパビジョンツリーに\n"
"取り付けることもできます:\n"
"\n"
"    import Supervisor.Spec\n"
"\n"
"    children = [\n"
"      worker(Task, [fn -> IO.puts \"ok\" end])\n"
"    ]\n"
"\n"
"これらのタスクはスーパバイズされ、直接呼び出し側にリンクされて\n"
"いないので、awaitで待つことが出来ません。\n"
"`start_link/1`(`async/1`と違って)は、`{:ok, pid}`\n"
"(スーバビジョンツリーにより期待される結果です)を返すことに\n"
"注意してください。\n"
"\n"
"## Supervision trees\n"
"\n"
"`Task.Supervisor`モジュールは、開発者に、\n"
"動的にタスクをスーパバイズするスーパバイザを開始することを許します:\n"
"\n"
"    {:ok, pid} = Task.Supervisor.start_link()\n"
"    Task.Supervisor.async(pid, MyMod, :my_fun, [arg1, arg2, arg3])\n"
"\n"
"スーパバイザがローカルまたは、グローバルに登録される限り、\n"
"`Task.Supervisor`もまた、リモートノードでタスクを生むことを可能にします:\n"
"\n"
"    # In the remote node\n"
"    Task.Supervisor.start_link(name: :tasks_sup)\n"
"\n"
"    # In the client\n"
"    Task.Supervisor.async({:tasks_sup, :remote@local}, MyMod, :my_fun, "
"[arg1, arg2, arg3])\n"
"\n"
"`Task.Supervisor`は、スーバビジョンツリーでよりしばしば開始されます:\n"
"\n"
"    import Supervisor.Spec\n"
"\n"
"    children = [\n"
"      supervisor(Task.Supervisor, [[name: :tasks_sup]])\n"
"    ]\n"
"\n"
"なお、分散されたタスクで動くとき、無名関数を動かす`async/1`のかわりに、\n"
"モジュール、関数、引数を明示的に期待する、`async/3`APIを使うべきです。\n"
"これは、無名関数APIは全ての起動されたノードで同じモジュールバージョンが\n"
"存在することを期待するためです。\n"
"全エコシステムに適用される、エージェントドキュメントで記述される制限として"
"の、\n"
"分散プロセスの詳細は、`Agent`モジュールドキュメントをチェックしてください。\n"
"\n"
"最後に、他のタスクスーパバイザによりサポートされるオペレーションについて\n"
"の詳細は、 `Task.Supervisor` をチェックしてください。\n"
