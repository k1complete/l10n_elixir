msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2016-02-21 09:19+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: def Task.async(fun)
#: lib/task.ex:196
msgid ""
"Starts a task that can be awaited on.\n"
"\n"
"This function spawns a process that is linked to and monitored\n"
"by the caller process. A `Task` struct is returned containing\n"
"the relevant information.\n"
"\n"
"Read the `Task` module documentation for more info on general\n"
"usage of `async/1` and `async/3`.\n"
"\n"
"## Task's message format\n"
"\n"
"The reply sent by the task will be in the format `{ref, msg}`,\n"
"where `ref` is the monitoring reference held by the task.\n"
msgstr ""
"待機することができるタスクを開始します。\n"
"\n"
"この関数は、呼び出し側プロセスによりリンクされ、モニタされる、\n"
"プロセスを生成します。関連した情報を含む`Task`構造体が返されます。\n"
"\n"
"`async/1` と `async/3` の一斑的な使いかたについては、\n"
" `Task`モジュールのドキュメントを参照してください。\n"
"\n"
"## Taskのメッセージフォーマット\n"
"\n"
"タスクによって送られる応答は`{ref, msg}`というフォーマットです。\n"
"`ref`はタスクによって保持されるモニタリファレンスです。\n"

#. TRANSLATORS: def Task.start_link(mod, fun, args)
#: lib/task.ex:164
msgid "Starts a task as part of a supervision tree.\n"
msgstr "監督ツリーの一部としてタスクを開始します。\n"

#. TRANSLATORS: def Task.shutdown(task, shutdown \\ 5000)
#: lib/task.ex:495
msgid ""
"Unlinks and shutdowns the task, and then checks for a reply.\n"
"\n"
"Returns `{:ok, reply}` if the reply is received while shutting down the "
"task,\n"
"`{:exit, reason}` if the task exited abornormally, otherwise `nil`.\n"
"\n"
"The shutdown method is either a timeout or `:brutal_kill`. In case\n"
"of a `timeout`, a `:shutdown` exit signal is sent to the task process\n"
"and if it does not exit within the timeout it is killed. With `:"
"brutal_kill`\n"
"the task is killed straight away. In case the task exits abnormally, or a \n"
"timeout shutdown kills the task, this function will exit with the same "
"reason.\n"
"\n"
"It is not required to call this function when terminating the caller, "
"unless\n"
"exiting with reason `:normal` or the task is trapping exits. If the caller "
"is\n"
"exiting with a reason other than `:normal` and the task is not trapping "
"exits the\n"
"caller's exit signal will stop the task. The caller can exit with reason\n"
"`:shutdown` to shutdown linked processes, such as tasks, that are not "
"trapping\n"
"exits without generating any log messages.\n"
"\n"
"This function assumes the task's monitor is still active or the monitor's\n"
"`:DOWN` message is in the message queue. If it has been demonitored, or the\n"
"message already received, this function will block forever awaiting the "
"message.\n"
msgstr ""
"タスクをunlinkしshutdownし、応答をチェックします。\n"
"\n"
"タスクのシャットダウン中にもし応答が受信されたら、`{:ok,\n"
"reply}`を返し、タスクが異常終了したら`{:exit, reason}`を返し、\n"
"さもなければ`nil`を返します。\n"
"\n"
"shutdownメソッドはタイムアウトか`:brutal_kill`が出来ます。\n"
"`timeout`の場合、`:shutdown` exitシグナルがタスクプロセスに送\n"
"信され、タイムアウトの間にexitしないならkillされます。\n"
"`:brutal_kill`では、タスクは直接killされます。タスクが異常終\n"
"了した場合、あるいはタスクがタイムアウトでkillされた場合、こ\n"
"の関数は同じ reason で exit します。\n"
"\n"
"reason `:normal`で終了していないかぎり、またはタスクがexitを\n"
"トラップしていないかぎり、呼出し側を終了するときにこの関数を\n"
"呼ぶことは必要ありません。もし呼出し側が`:normal`以外の\n"
"reasonでexitしたり、タスクがexitをトラップしていないなら、呼\n"
"出し側のexitシグナルがタスクを終了させます。呼出し側がreason\n"
"`:shutdown`のexitでリンクされたプロセスをシャットダウンし、タ\n"
"スクもいかなるログメッセージも無しにexitします(トラップされて\n"
"いないなら)。\n"
"\n"
"この関数はタスクのモニタがアクティブあるいは、`:DOWN`メッセー\n"
"ジがメッセージキューにあることを仮定しています。もし非モニタ\n"
"されていた、あるいは、メッセージが既に受信されていたら、この\n"
"関数はタイムアウトの期間中メッセージを待つでしょう。\n"

#. TRANSLATORS: def Task.yield_many(tasks, timeout \\ 5000)
#: lib/task.ex:402
msgid ""
"Yields to multiple tasks in the given time interval.\n"
"\n"
"This function receives a list of tasks and await for their\n"
"replies at once in the given time interval. It returns a list\n"
"of tuples of two elements, with tasks as the first element and\n"
"the `yield` result as the second.\n"
"\n"
"Similar to `yield/2`, if the task replied in the given interval,\n"
"it will return `{:ok, term}`, `{:exit, reason}`if it crashed or\n"
"`nil` if it timed out. Check `yield/2` for more information.\n"
"\n"
"## Example\n"
"\n"
"`Task.yield_many/2` allows developers to spawn multiple tasks\n"
"and retrieve the results received in a given timeframe.\n"
"If we combine it with `Task.shutdown/2`, it allows us to gather\n"
"those results and cancel the tasks that have not replied in time.\n"
"Let's see an example.\n"
"\n"
"    tasks =\n"
"      for i <- 1..10 do\n"
"        Task.async(fn ->\n"
"          :timer.sleep(i * 1000)\n"
"          i\n"
"        end)\n"
"      end\n"
"\n"
"    tasks_with_results = Task.yield_many(tasks, 5000)\n"
"\n"
"    results = Enum.map(tasks_with_results, fn {task, res} ->\n"
"      # Shutdown the tasks that did not reply nor exit\n"
"      res || Task.shutdown(task, :brutal_kill)\n"
"    end)\n"
"\n"
"    # Here we are matching only on {:ok, value} and\n"
"    # ignoring {:exit, _} (crashed tasks) and `nil` (no replies)\n"
"    for {:ok, value} <- results do\n"
"      IO.inspect value\n"
"    end\n"
"\n"
"In the example above, we create tasks that sleep from 1\n"
"up to 10 seconds and return the amount of seconds they slept.\n"
"If you execute the code all at once, you should see 1 up to 5\n"
"printed, as those were the tasks that have replied in the\n"
"given time. All other tasks will have been shutdown, according\n"
"to the `Task.shutdown/2` call.\n"
msgstr ""
"与えられた時間の間、複数のタスクを待ちます。\n"
"\n"
"この関数はタスクのリストを受取り、それらの与えられた時間の間、\n"
"応答を待ちます。最初の要素としてタスク、二つめの\n"
"要素として`yield`の結果からなる、2要素のタプルのリストを返します。\n"
"\n"
"`yield/2`と似て、タスクが与えられた時間の間に応答したら、\n"
"`{:ok, term}`を返し、クラッシュしたら`{:exit, reason}`を返し、\n"
"タイムアウトしたら`nil`を返します。詳細は`yield/2`をチェック\n"
"知てください。\n"
"\n"
"## Example\n"
"\n"
"`Task.yield_many/2`は開発者に複数のタスクを生成し、与えられた\n"
"時間フレームの間に受信した結果を取りにいくことを許します。\n"
"もし`Task.shutdown/2`と組合せたら、それらの結果を集めて\n"
"時間内に答えなかったタスクをキャンセルすることを許します。\n"
"例を見てみましょう。\n"
"\n"
"    tasks =\n"
"      for i <- 1..10 do\n"
"        Task.async(fn ->\n"
"          :timer.sleep(i * 1000)\n"
"          i\n"
"        end)\n"
"      end\n"
"\n"
"    tasks_with_results = Task.yield_many(tasks, 5000)\n"
"\n"
"    results = Enum.map(tasks_with_results, fn {task, res} ->\n"
"      # Shutdown the tasks that did not reply nor exit\n"
"      res || Task.shutdown(task, :brutal_kill)\n"
"    end)\n"
"\n"
"    # Here we are matching only on {:ok, value} and\n"
"    # ignoring {:exit, _} (crashed tasks) and `nil` (no replies)\n"
"    for {:ok, value} <- results do\n"
"      IO.inspect value\n"
"    end\n"
"\n"
"上の例では、1秒から10秒スリープして、その後スリープした秒数を\n"
"返すタスクを作成しています。\n"
"もし上のコード全てを一度実行すると、与えられた時間内に\n"
"応答できるタスクがそれらなので、1から5が表示されるのを\n"
"見るでしょう。他の全てのタスクは`Task.shutdown/2`の呼出しに\n"
"よってshutdownされます。\n"

#. TRANSLATORS: Elixir.Task Summary
#: lib/task.ex:2
msgid ""
"Conveniences for spawning and awaiting tasks.\n"
"\n"
"Tasks are processes meant to execute one particular\n"
"action throughout their life-cycle, often with little or no\n"
"communication with other processes. The most common use case\n"
"for tasks is to convert sequential code into concurrent code\n"
"by computing a value asynchronously:\n"
"\n"
"    task = Task.async(fn -> do_some_work() end)\n"
"    res  = do_some_other_work()\n"
"    res + Task.await(task)\n"
"\n"
"Tasks spawned with `async` can be waited on by their caller\n"
"process (and only their caller) as shown in the example above.\n"
"They are implemented by spawning a process that sends a message\n"
"to the caller once the given computation is performed.\n"
"\n"
"Besides `async/1` and `await/2`, tasks can also be\n"
"started as part of supervision tree and dynamically spawned\n"
"in remote nodes. We will explore all three scenarios next.\n"
"\n"
"## async and await\n"
"\n"
"One of the common use of tasks is to convert sequential code\n"
"into concurrent code with `Task.async/1` while keeping its semantics.\n"
"When invoked, a new process will be created, linked and monitored\n"
"by the caller. Once the task action finishes, a message will be sent\n"
"to the caller with the result.\n"
"\n"
"`Task.await/2` is used to read the message sent by the task.\n"
"`await` will check the monitor setup by the call to `async/1` to\n"
"verify if the process exited for any abnormal reason (or in case\n"
"exits are being trapped by the caller).\n"
"\n"
"There are two important things to consider when using async:\n"
"\n"
"  1. If you are using async tasks, you must await a reply\n"
"     as they are *always* sent. If you are not expecting a reply,\n"
"     consider using `Task.start_link/1` detailed below\n"
"\n"
"  2. async tasks link the caller and the spawned process. This\n"
"     means that, if the caller crashes, the task will crash\n"
"     too and vice-versa. This is on purpose, if the process\n"
"     meant to receive the result no longer exists, there is\n"
"     no purpose in completing computation of the result. If this\n"
"     is not desired, consider using `Task.start_link/1` as well\n"
"\n"
"`Task.yield/2` is an alternative to `await/2` where the caller will\n"
"temporarily block, waiting until the task replies or crashes. If the\n"
"result does not arrive within the timeout it can be called again at a\n"
"later moment. This allows checking for the result of a task multiple\n"
"times or to handle a timeout. If a reply does not arrive within the\n"
"desired time, `Task.shutdown/2` can be used to stop the task.\n"
"\n"
"## Supervised tasks\n"
"\n"
"It is also possible to spawn a task inside a supervision tree\n"
"with `start_link/1` and `start_link/3`:\n"
"\n"
"    Task.start_link(fn -> IO.puts \"ok\" end)\n"
"\n"
"Such tasks can be mounted in your supervision tree as:\n"
"\n"
"    import Supervisor.Spec\n"
"\n"
"    children = [\n"
"      worker(Task, [fn -> IO.puts \"ok\" end])\n"
"    ]\n"
"\n"
"Since these tasks are supervised and not directly linked to\n"
"the caller, they cannot be waited on. Note `start_link/1`,\n"
"unlike `async/1`, returns `{:ok, pid}` (which is\n"
"the result expected by supervision trees).\n"
"\n"
"By default, most supervision strategies will try to restart\n"
"a worker after it exits regardless of reason. If you design the\n"
"task to terminate normally (as in the example with `IO.puts/2` above),\n"
"consider passing `restart: :transient` in the options to `worker/3`.\n"
"\n"
"## Dynamically supervised tasks\n"
"\n"
"The `Task.Supervisor` module allows developers to dynamically\n"
"create multiple supervised tasks.\n"
"\n"
"A short example is:\n"
"\n"
"    {:ok, pid} = Task.Supervisor.start_link()\n"
"    task = Task.Supervisor.async(pid, fn ->\n"
"      # Do something\n"
"    end)\n"
"    Task.await(task)\n"
"\n"
"However, in the majority of cases, you want to add the task supervisor\n"
"to your supervision tree:\n"
"\n"
"    import Supervisor.Spec\n"
"\n"
"    children = [\n"
"      supervisor(Task.Supervisor, [[name: MyApp.TaskSupervisor]])\n"
"    ]\n"
"\n"
"Now you can dynamically start supervised tasks:\n"
"\n"
"    Task.Supervisor.start_child(MyApp.TaskSupervisor, fn ->\n"
"      # Do something\n"
"    end)\n"
"\n"
"Or even use the async/await pattern:\n"
"\n"
"    Task.Supervisor.async(MyApp.TaskSupervisor, fn ->\n"
"      # Do something\n"
"    end) |> Task.await()\n"
"\n"
"Finally, check `Task.Supervisor` for other operations supported by the\n"
"Task supervisor.\n"
"\n"
"## Distributed tasks\n"
"\n"
"Since Elixir provides a Task supervisor, it is easy to use a task\n"
"supervisor to dynamically spawn tasks across nodes:\n"
"\n"
"    # In the remote node\n"
"    Task.Supervisor.start_link(name: MyApp.DistSupervisor)\n"
"\n"
"    # In the client\n"
"    Task.Supervisor.async({MyApp.DistSupervisor, :remote@local},\n"
"                          MyMod, :my_fun, [arg1, arg2, arg3])\n"
"\n"
"Note that, when working with distributed tasks, one should use the `async/4` "
"function\n"
"that expects explicit module, function and arguments, instead of `async/2` "
"that\n"
"works with anonymous functions. That's because anonymous functions expect\n"
"the same module version to exist on all involved nodes. Check the `Agent` "
"module\n"
"documentation for more information on distributed processes as the "
"limitations\n"
"described in the agents documentation apply to the whole ecosystem.\n"
msgstr ""
"タスクの生成と待合せに便利なものです。\n"
"\n"
"タスクはそのライフサイクルを通じて、他のプロセスとのコミュニ\n"
"ケーションが少ない、あるいは全くない一つの特定の行動をするプ\n"
"ロセスです。タスクの最も一般的なユースケースは、非同期な値の\n"
"計算のシーケンシャルなコードをコンカレントなコードへの変換:\n"
"\n"
"    task = Task.async(fn -> do_some_work() end)\n"
"    res  = do_some_other_work()\n"
"    res + Task.await(task)\n"
"\n"
"`async`で生成されたタスクは、上の例で示すように、その呼出し側\n"
"プロセスで(そして呼出し側だけで)待たれます。生成されたプロセ\n"
"スは、与えられた計算が実行されたら、呼出し側へメッセージを送\n"
"信するように実装されています。\n"
"\n"
"`async/1`と`await/2`の他に、タスクは、supervisionツリーから開\n"
"始されたり、リモートノードで動的に生成されることもあります。\n"
"次に全ての3つのシナリオを調査します。\n"
"\n"
"## async and await\n"
"\n"
"一般的なタスクの使いかた一つは、`Task.async/1`でセマンティク\n"
"スを保ったまま、シーケンシャルなコードをコンカレントなコード\n"
"へ変換することです。\n"
"\n"
"起動されると、新しいプロセスが作成され、呼出し側プロセスにリ\n"
"ンクされ、モニタされます。タスクの活動が終了したら、その結果\n"
"と一緒に呼出し側へメッセージを送信します。\n"
"\n"
"`Task.await/2`はタスクから送信されたメッセージを読むために使\n"
"われます。`await`は、プロセスが異常なreasonで終了したか(また\n"
"は、呼出し側でトラップされている場合に備えて) `async/1`の呼び\n"
"出しによりセットアップされたモニタをチェックします。\n"
"\n"
"asyncを使うときの重要な考慮点は二つです:\n"
"\n"
"  1. asyncタスクを使うなら、 *常に* 応答が送信されるので、\n"
"     awaitしなければなりません。もし応答を必要としないなら、\n"
"     以下に詳述する `Task.start_link/1` を考慮してください。\n"
"\n"
"  2. asyncタスクは呼出し側と生成されたプロセスにリンクします。\n"
"     これは、もし呼出し側がクラッシュしたらタスクもクラッシュ\n"
"     し、逆もまた同じことを意味します。結果を受信するはずのプ\n"
"     ロセスがもはや存在しないなら、終りまで計算する目的がない\n"
"     です。もしこれが望まれないなら、`Task.start_link/1`を使\n"
"     うことを考慮してください。\n"
"\n"
"`Task.yield/2`は呼出し側がタスクが応答するかクラッシュするま\n"
"で一時的にブロックする`await/2`にかわるものです。もし結果がタ\n"
"イムアウトのなかで到着しないなら、それは後でまた呼ぶことがで\n"
"きます。これは複数回タスクの結果をチェックすることと、タイム\n"
"アウトをハンドルすることを許します。もし望み通りの時間で応答\n"
"が到着しないなら、タスクを終了させるため`Task.shutdown/2`を呼\n"
"ぶことができます。\n"
"\n"
"## Supervised tasks\n"
"\n"
"supervisionツリーの中で、`start_link/1`と`start_link/3`を使っ\n"
"てタスクを生成することも可能です:\n"
"\n"
"    Task.start_link(fn -> IO.puts \"ok\" end)\n"
"\n"
"そのようなタスクはsupervisionツリーに以下のようにマウントでき\n"
"ます:\n"
"\n"
"    import Supervisor.Spec\n"
"\n"
"    children = [\n"
"      worker(Task, [fn -> IO.puts \"ok\" end])\n"
"    ]\n"
"\n"
"これらのタスクがsuperviseされると、呼出し側への直接のリンクは\n"
"されませんので、awaitが出来ません。`async/1`と違って、\n"
"`start_link/1`は`{:ok, pid}`(これはsupervisionツリーから期待\n"
"された結果です)を返すことに注意してください。\n"
"\n"
"デフォルトで、殆どのsupervisionストラテジは理由に関わりなく終\n"
"了したらworkerの再起動を試みます。もしタスクを正常に終了する\n"
"ように設計するなら(上の例での`IO.puts/2`のように)、\n"
"`worker/3`のオプションに`restart: :transient`を渡すことを考慮\n"
"してください。\n"
"\n"
"## Dynamically supervised tasks\n"
"\n"
"`Task.Supervisor`モジュールは開発者に動的に複数のsuperviseさ\n"
"れたタスクを作成することを許します。\n"
"\n"
"短かい例は:\n"
"\n"
"    {:ok, pid} = Task.Supervisor.start_link()\n"
"    task = Task.Supervisor.async(pid, fn ->\n"
"      # Do something\n"
"    end)\n"
"    Task.await(task)\n"
"\n"
"しかしながら、多くの場合、タスクsupervisorをあなたの\n"
"supervisionツリーに追加したいでしょう:\n"
"\n"
"    import Supervisor.Spec\n"
"\n"
"    children = [\n"
"      supervisor(Task.Supervisor, [[name: MyApp.TaskSupervisor]])\n"
"    ]\n"
"\n"
"いまやsuperviseされたタスクを動的に開始できます:\n"
"\n"
"    Task.Supervisor.start_child(MyApp.TaskSupervisor, fn ->\n"
"      # Do something\n"
"    end)\n"
"\n"
"あるいは、async/awaitパターンを使うこともできます:\n"
"\n"
"    Task.Supervisor.async(MyApp.TaskSupervisor, fn ->\n"
"      # Do something\n"
"    end) |> Task.await()\n"
"\n"
"最後に、タスクsupervisorによりサポートされる他のオペレーションを\n"
"`Task.Supervisor`でチェックしてください。\n"
"\n"
"## Distributed tasks\n"
"\n"
"Elixirがタスクsupervisorを提供したときから、ノードを越えてタ\n"
"スクを動的に生成することがタスクsupervisorで使い易くなりまし\n"
"た:\n"
"\n"
"    # In the remote node\n"
"    Task.Supervisor.start_link(name: MyApp.DistSupervisor)\n"
"\n"
"    # In the client\n"
"    Task.Supervisor.async({MyApp.DistSupervisor, :remote@local},\n"
"                          MyMod, :my_fun, [arg1, arg2, arg3])\n"
"\n"
"分散タスクで動作しているとき、明確なモジュール、関数と引数(無\n"
"名関数で動く`async/2`の代わりに)を期待する`async/4`を使わなけ\n"
"ればなりません。それは無名関数が全ての関連あるノードで同じモ\n"
"ジュールバージョンが存在することを期待するからです。詳細は\n"
"`Agent`モジュールドキュメントを参照してください。エージェント\n"
"ドキュメントで記述されている分散処理についての制限は、エコシ\n"
"ステム全体に適用されます。\n"

#. TRANSLATORS: def Task.await(task, timeout \\ 5000)
#: lib/task.ex:292
msgid ""
"Awaits a task reply.\n"
"\n"
"A timeout, in milliseconds, can be given with default value\n"
"of `5000`. In case the task process dies, this function will\n"
"exit with the same reason as the task.\n"
"\n"
"If the timeout is exceeded, `await` will exit, however,\n"
"the task will continue to run. When the calling process exits, its\n"
"exit signal will terminate the task if it is not trapping exits.\n"
"\n"
"This function assumes the task's monitor is still active or the monitor's\n"
"`:DOWN` message is in the message queue. If it has been demonitored, or the\n"
"message already received, this function may wait for the duration of the\n"
"timeout awaiting the message.\n"
"\n"
"This function will always exit and demonitor if the task crashes or if\n"
"it times out, so the task can not be used again. To explicitly handle\n"
"the timeout or the crash, use `yield/2` instead.\n"
msgstr ""
"タスクの応答を待ちます。\n"
"\n"
"ミリ秒でのtimeoutを与えることができます。デフォルト値`5000`で\n"
"す。タスクプロセスが死んだ場合、この関数はタスクと同じreason\n"
"でexitします。\n"
"\n"
"タイムアウトに到達したら、`await`はexitしますが、タスクは動き\n"
"つづけます。呼出し側プロセスが終了したとき、そのexit シグナル\n"
"がexitをトラップしていない限り、タスクを終了させます。\n"
"\n"
"この関数はタスクのモニタがまだ動作中である、あるいはモニタの\n"
"`:DOWN`メッセージがメッセージキューにあると仮定しています。も\n"
"し非モニタされた、あるいはメッセージが既に受信されたら、この\n"
"関数はtimeoutの期間中、メッセージを待ちつづけます。\n"
"\n"
"この関数は常にタスクを非モニタするので、そのタスクは二度と使\n"
"うことができません。タスクの応答を複数回待つためには、\n"
"`yield/2`を代わりに使ってください。\n"

#. TRANSLATORS: def Task.async(mod, fun, args)
#: lib/task.ex:216
msgid ""
"Starts a task that must be awaited on.\n"
"\n"
"A `Task` struct is returned containing the relevant information.\n"
"Developers must eventually call `Task.await/2` or `Task.yield/2`\n"
"followed by `Task.shutdown/2` on the returned task.\n"
"\n"
"Read the `Task` module documentation for more info on general\n"
"usage of `async/1` and `async/3`.\n"
"\n"
"## Linking\n"
"\n"
"This function spawns a process that is linked to and monitored\n"
"by the caller process. The linking part is important because it\n"
"aborts the task if the parent process dies. It also guarantees\n"
"the code before async/await has the same properties after you\n"
"add the async call. For example, imagine you have this:\n"
"\n"
"    x = heavy_fun()\n"
"    y = some_fun()\n"
"    x + y\n"
"\n"
"Now you want to make the `heavy_fun()` async:\n"
"\n"
"    x = Task.async(&heavy_fun/0)\n"
"    y = some_fun()\n"
"    Task.await(x) + y\n"
"\n"
"As before, if `heavy_fun/0` fails, the whole computation will\n"
"fail, including the parent process. If you don't want the task\n"
"to fail then you must change the `heavy_fun/0` code in the\n"
"same way you would if you didn't have the async call. For\n"
"example to either return `{:ok, val} | :error` results or,\n"
"in more extreme cases, by using `try/rescue`. In other words,\n"
"an asynchronous task should be considered an extension of a\n"
"process rather than a mechanism to isolate it from all errors.\n"
"\n"
"If you don't want to link the caller to the task, then you\n"
"must use a supervised task with `Task.Supervisor` and call\n"
"`Task.Supervisor.async_nolink/2`.\n"
"\n"
"In any case, avoid any of the following:\n"
"\n"
"  * Setting `:trap_exit` to true - trapping exists should be\n"
"    used only in special circumstances as it would make your\n"
"    process immune to not only exits from the task but from\n"
"    any other processes.\n"
"\n"
"  * Unlinking the task process started with `async`/`await`.\n"
"    If you unlink the processes and the task does not belong\n"
"    to any supervisor, you may leave dangling tasks in case\n"
"    the parent dies.\n"
"\n"
"## Message format\n"
"\n"
"The reply sent by the task will be in the format `{ref, msg}`,\n"
"where `ref` is the monitoring reference held by the task.\n"
msgstr ""
"awaitしなければならないタスクを開始します。\n"
"\n"
"`Task`構造体が関連した情報を含んで返されます。開発者は返され\n"
"たタスクに関して、最終的に`Task.shutdown/2`が続く\n"
"`Task.await/2`か`Task.yield/2`を呼び出さなければなりません。\n"
"\n"
"`async/1`と`async/3`の一班的な使いかたの詳細は、`Task`モジュー\n"
"ルドキュメントを読んでください。\n"
"\n"
"## Linking\n"
"\n"
"この関数は呼出し側プロセスにより、リンクされモニタされた\n"
"プロセスを生成します。リンク部分は親プロセスが死んだなら\n"
"タスクはアボートするため重要です。非同期呼出しを加えたあと\n"
"async/awaitには同じ属性を持つ前にコードはそれを保証します。\n"
"例えば、これを想像してみてください:\n"
"This function spawns a process that is linked to and monitored\n"
"by the caller process. The linking part is important because it\n"
"aborts the task if the parent process dies. It also guarantees\n"
"the code before async/await has the same properties after you\n"
"add the async call. For example, imagine you have this:\n"
"\n"
"    x = heavy_fun()\n"
"    y = some_fun()\n"
"    x + y\n"
"\n"
"今、`heavy_fun()`をasyncしようとしたとします:\n"
"Now you want to make the `heavy_fun()` async:\n"
"\n"
"    x = Task.async(&heavy_fun/0)\n"
"    y = some_fun()\n"
"    Task.await(x) + y\n"
"\n"
"前述のように、もし`heavy_fun/0`が失敗したら、親プロセスを含む\n"
"計算全体が失敗します。もしタスクが失敗することを望まないなら、\n"
"非同期呼出しをしない場合にする方法と同じように`heavy_fun/0`を\n"
"修正しなければなりません。例えば、`{:ok, val} | :error`か、もっ\n"
"と極端な場合は`try/rescue`を使って結果を返すことです。\n"
"言い替えると、非同期タスクは、全てのエラーから分離する\n"
"メカニズムというよりも、むしろ、プロセスの延長として考える\n"
"べきものです。\n"
"\n"
"もし呼出し側とタスクをリンクしたくないなら、スーパバイズされ\n"
"たタスク`Task.Supervisor`を使わなければならず、\n"
"`Task.Supervisor.async_nolink/2`を呼ぶべきです。\n"
"\n"
"何れにしても、以下のどのケースも避けてください:\n"
"\n"
"  * `:trap_exit` を true にセットすること - exitをトラップす\n"
"    ることは、そのタスクからのexitだけでなく、他の全てのプロ\n"
"    セスからも影響がない、特殊な状況だけで使うべきです。\n"
"\n"
"  * `async`/`await`で開始したタスクプロセスのリンクの解除。も\n"
"    しプロセスをアンリンクし、タスクがどのスーパバイザも所有\n"
"    していないなら、親が死んだ場合でもタスクが残ってしまうか\n"
"    もしれません。\n"
"\n"
"## Message format\n"
"\n"
"タスクから送信された応答は`{ref, msg}`のフォーマットです。\n"
"`ref`はタスクに保持されたモニタリファレンスです。\n"

#. TRANSLATORS: def Task.__struct__()
#: lib/task.ex:139
msgid ""
"The Task struct.\n"
"\n"
"It contains these fields:\n"
"\n"
"  * `:pid` - the process reference of the task process; `nil` if the task "
"does\n"
"    not use a task process.\n"
"\n"
"  * `:ref` - the task monitor reference\n"
"\n"
"  * `:owner` - the PID of the process that started the task\n"
"\n"
msgstr ""
"タスク構造体です。\n"
"\n"
"3つのフィールドを含みます:\n"
"\n"
"  * `:pid` - タスクプロセスのリファレンス; タスクがタスクプロセスを使っ\n"
"    ていないなら`nil`です\n"
"\n"
"  * `:ref` - タスクモニタのリファレンスです\n"
"\n"
"  * `:owner` - タスクを開始したプロセスのPIDです\n"
"\n"

#. TRANSLATORS: def Task.yield(task, timeout \\ 5000)
#: lib/task.ex:361
msgid ""
"Yields for a task reply in the given time interval.\n"
"\n"
"Returns `{:ok, reply}` if the reply is received, `{:exit, reason}`\n"
"if the task exited or `nil` if no reply arrived.\n"
"\n"
"A timeout, in milliseconds, can be given with default value\n"
"of `5000`. In case of the timeout, this function will return `nil`\n"
"and the monitor will remain active. Therefore `yield/2` can be\n"
"called multiple times on the same task.\n"
"\n"
"In case the task process dies, this function will exit with the\n"
"same reason as the task.\n"
"\n"
"This function assumes the task's monitor is still active or the\n"
"monitor's `:DOWN` message is in the message queue. If it has been\n"
"demonitored, or the message already received, this function waits\n"
"for the duration of the timeout awaiting the message.\n"
msgstr ""
"yield、テンポラリにタスクの応答を待ちます。\n"
"\n"
"replyが受信されたら`{:ok, reply}` 、タスクが終了したら\n"
"`{:exit, reason}`、replyが到着しなかったら`nil`を返します。\n"
"\n"
"ミリ秒のタイムアウトを与えることもでき、デフォルト値は\n"
"`5000`です。タイムアウトの場合、この関数は`nil`を返し、モニタ\n"
"はアクティブのままです。したがって`yield/2`は同じタスクに\n"
"対して複数回呼び出すことができます。\n"
"\n"
"タスクプロセスが死んでいた場合、この関数はタスクと同じreason\n"
"で exit します。\n"
"\n"
"この関数はタスクのモニタがアクティブあるいは、`:DOWN`メッセー\n"
"ジがメッセージキューにあることを仮定しています。もし非モニタ\n"
"されていた、あるいは、メッセージが既に受信されていたら、この\n"
"関数はタイムアウトの期間中メッセージを待つでしょう。\n"

#. TRANSLATORS: def Task.start(mod, fun, args)
#: lib/task.ex:184
msgid ""
"Starts a task.\n"
"\n"
"This is only used when the task is used for side-effects\n"
"(i.e. no interest in the returned result) and it should not\n"
"be linked to the current process.\n"
msgstr ""
"タスクを開始します。\n"
"\n"
"タスクが副作用(即ち、戻り結果に対する関心がない)のために\n"
"使われるときにのみ使われ、それは現在のプロセスとリンク\n"
"されていてはなりません。\n"

#~ msgid ""
#~ "Receives a group of tasks and a message and finds\n"
#~ "a task that matches the given message.\n"
#~ "\n"
#~ "This function returns a tuple with the returned value\n"
#~ "in case the message matches a task that exited with\n"
#~ "success alongside the matching task. It returns `nil`\n"
#~ "if no task was found. It exits if the task has failed.\n"
#~ "\n"
#~ "This function is useful in situations where multiple\n"
#~ "tasks are spawned and their results are collected\n"
#~ "later on. For example, a `GenServer` can spawn tasks,\n"
#~ "store the tasks in a list and later use `Task.find/2`\n"
#~ "to see if incoming messages are from any of the tasks.\n"
#~ msgstr ""
#~ "タスクとメッセージのグループを受け取り、与えられたメッセージ\n"
#~ "にマッチするタスクを見付けます。\n"
#~ "\n"
#~ "この関数は、タスク付のタプルを返し、返された値は成功して終了\n"
#~ "したタスクにマッチするメッセージです。タスクが見付けられない\n"
#~ "時は、`nil`を返します。タスクが失敗したときは、exitします。\n"
#~ "\n"
#~ "この関数は、複数のタスクが生成され、それらの結果をあとで集め\n"
#~ "るというシチュエーションで、便利です。例えば、`GenServer`はタ\n"
#~ "スクを生成することができ、タスクをリストに格納して、他のタス\n"
#~ "クからのメッセージが来たかどうかを知るために、後で\n"
#~ "`Task.find/2`を使うことが出来ます。\n"

#~ msgid ""
#~ "Receives a group of tasks and a message and finds\n"
#~ "a task that matches the given message.\n"
#~ "\n"
#~ "This function returns a tuple with the returned value\n"
#~ "in case the message matches a task that exited with\n"
#~ "success alongside the matching task. It raises in case\n"
#~ "the found task failed or `nil` if no task was found.\n"
#~ "\n"
#~ "This function is useful in situations where multiple\n"
#~ "tasks are spawned and their results are collected\n"
#~ "later on. For example, a `GenServer` can spawn tasks,\n"
#~ "store the tasks in a list and later use `Task.find/2`\n"
#~ "to see if incoming messages are from any of the tasks.\n"
#~ "\n"
#~ "## Examples\n"
#~ "\n"
#~ "    defmodule TaskFinder do\n"
#~ "      def run do\n"
#~ "        task1 = Task.async fn -> :timer.sleep(1000); 1 end\n"
#~ "        task2 = Task.async fn -> :timer.sleep(5000); 2 end\n"
#~ "        await [task1, task2]\n"
#~ "      end\n"
#~ "\n"
#~ "      # Be careful, this will receive all messages sent\n"
#~ "      # to this process. It will return the first task\n"
#~ "      # reply and the list of tasks that came second.\n"
#~ "      def await(tasks) do\n"
#~ "        receive do\n"
#~ "          message ->\n"
#~ "            case Task.find(tasks, message) do\n"
#~ "              {reply, task} ->\n"
#~ "                {reply, List.delete(tasks, task)}\n"
#~ "              nil ->\n"
#~ "                await(tasks)\n"
#~ "            end\n"
#~ "        end\n"
#~ "      end\n"
#~ "    end\n"
#~ "\n"
#~ "    TaskFinder.run\n"
#~ msgstr ""
#~ "一群のタスクとメッセージを受けて、そのメッセージ\n"
#~ "にマッチするタスクを見付けます。\n"
#~ "\n"
#~ "この関数は、\n"
#~ "マッチしたタスクが処理に成功して終了した場合に\n"
#~ "備えて、そのタスクが返した値とタスクのタプルを返します。\n"
#~ "タスクが失敗を見付けたら、例外を上げ、タスクが見付\n"
#~ "からない場合、`nil`を返します。\n"
#~ "\n"
#~ "この関数は複数のタスクを生成し、それらの結果を後で\n"
#~ "集めるときに便利です。例えば、`GenServer`が\n"
#~ "タスクを生成し、リストにタスクを保存しておき、\n"
#~ "後で、そららのタスクからメッセージを受信したとき\n"
#~ "`Task.find/2`を使います。\n"
#~ "\n"
#~ "## Examples\n"
#~ "\n"
#~ "    defmodule TaskFinder do\n"
#~ "      def run do\n"
#~ "        task1 = Task.async fn -> :timer.sleep(1000); 1 end\n"
#~ "        task2 = Task.async fn -> :timer.sleep(5000); 2 end\n"
#~ "        await [task1, task2]\n"
#~ "      end\n"
#~ "\n"
#~ "      # Be careful, this will receive all messages sent\n"
#~ "      # to this process. It will return the first task\n"
#~ "      # reply and the list of tasks that came second.\n"
#~ "      def await(tasks) do\n"
#~ "        receive do\n"
#~ "          message ->\n"
#~ "            case Task.find(tasks, message) do\n"
#~ "              {reply, task} ->\n"
#~ "                {reply, List.delete(tasks, task)}\n"
#~ "              nil ->\n"
#~ "                await(tasks)\n"
#~ "            end\n"
#~ "        end\n"
#~ "      end\n"
#~ "    end\n"
#~ "\n"
#~ "    TaskFinder.run\n"

#~ msgid ""
#~ "Starts a task that can be awaited on.\n"
#~ "\n"
#~ "Similar to `async/1`, but the task is specified by the given\n"
#~ "module, function and arguments.\n"
#~ msgstr ""
#~ "待機することができるタスクを開始します。\n"
#~ "\n"
#~ "`async/1`と似ていますが、タスクは与えられたモジュール、関数\n"
#~ "および引数により指定されます。\n"

#~ msgid ""
#~ "Awaits a task reply.\n"
#~ "\n"
#~ "A timeout, in milliseconds, can be given with default value\n"
#~ "of `5000`. In case the task process dies, this function will\n"
#~ "exit with the same reason as the task.\n"
#~ msgstr ""
#~ "タスクの応答を待ちます。\n"
#~ "\n"
#~ "タイムアウト(ミリ秒)を与えることができ、デフォルト値は`5000`です。\n"
#~ "タスクプロセスが死んだ場合、この関数は、\n"
#~ "そのタスクと同じreasonでexitします。\n"

#~ msgid ""
#~ "Conveniences for spawning and awaiting for tasks.\n"
#~ "\n"
#~ "Tasks are processes meant to execute one particular\n"
#~ "action throughout their life-cycle, often with little or no\n"
#~ "communication with other processes. The most common use case\n"
#~ "for tasks is to compute a value asynchronously:\n"
#~ "\n"
#~ "    task = Task.async(fn -> do_some_work() end)\n"
#~ "    res  = do_some_other_work()\n"
#~ "    res + Task.await(task)\n"
#~ "\n"
#~ "Tasks spawned with `async` can be awaited on by its caller\n"
#~ "process (and only its caller) as shown in the example above.\n"
#~ "They are implemented by spawning a process that sends a message\n"
#~ "to the caller once the given computation is performed.\n"
#~ "\n"
#~ "Besides `async/1` and `await/2`, tasks can also be\n"
#~ "started as part of supervision trees and dynamically spawned\n"
#~ "in remote nodes. We will explore all three scenarios next.\n"
#~ "\n"
#~ "## async and await\n"
#~ "\n"
#~ "The most common way to spawn a task is with `Task.async/1`. A new\n"
#~ "process will be created, linked and monitored by the caller. Once\n"
#~ "the task action finishes, a message will be sent to the caller\n"
#~ "with the result.\n"
#~ "\n"
#~ "`Task.await/2` is used to read the message sent by the task. On\n"
#~ "`await`, Elixir will also setup a monitor to verify if the process\n"
#~ "exited for any abnormal reason (or in case exits are being\n"
#~ "trapped by the caller).\n"
#~ "\n"
#~ "## Supervised tasks\n"
#~ "\n"
#~ "It is also possible to spawn a task inside a supervision tree\n"
#~ "with `start_link/1` and `start_link/3`:\n"
#~ "\n"
#~ "    Task.start_link(fn -> IO.puts \"ok\" end)\n"
#~ "\n"
#~ "Such tasks can be mounted in your supervision tree as:\n"
#~ "\n"
#~ "    import Supervisor.Spec\n"
#~ "\n"
#~ "    children = [\n"
#~ "      worker(Task, [fn -> IO.puts \"ok\" end])\n"
#~ "    ]\n"
#~ "\n"
#~ "Since these tasks are supervised and not directly linked to\n"
#~ "the caller, they cannot be awaited on. Note `start_link/1`,\n"
#~ "unlike `async/1`, returns `{:ok, pid}` (which is\n"
#~ "the result expected by supervision trees).\n"
#~ "\n"
#~ "## Supervision trees\n"
#~ "\n"
#~ "The `Task.Supervisor` module allows developers to start supervisors\n"
#~ "that dynamically supervise tasks:\n"
#~ "\n"
#~ "    {:ok, pid} = Task.Supervisor.start_link()\n"
#~ "    Task.Supervisor.async(pid, MyMod, :my_fun, [arg1, arg2, arg3])\n"
#~ "\n"
#~ "`Task.Supervisor` also makes it possible to spawn tasks in remote nodes "
#~ "as\n"
#~ "long as the supervisor is registered locally or globally:\n"
#~ "\n"
#~ "    # In the remote node\n"
#~ "    Task.Supervisor.start_link(name: :tasks_sup)\n"
#~ "\n"
#~ "    # In the client\n"
#~ "    Task.Supervisor.async({:tasks_sup, :remote@local}, MyMod, :my_fun, "
#~ "[arg1, arg2, arg3])\n"
#~ "\n"
#~ "`Task.Supervisor` is more often started in your supervision tree as:\n"
#~ "\n"
#~ "    import Supervisor.Spec\n"
#~ "\n"
#~ "    children = [\n"
#~ "      supervisor(Task.Supervisor, [[name: :tasks_sup]])\n"
#~ "    ]\n"
#~ "\n"
#~ "Note that, when working with distributed tasks, one should use the "
#~ "`async/3` API,\n"
#~ "that expects explicit module, function and arguments, instead of "
#~ "`async/1` that\n"
#~ "works with anonymous functions. That's because the anonymous function API "
#~ "expects\n"
#~ "the same module version to exist on all involved nodes. Check the `Agent` "
#~ "module\n"
#~ "documentation for more information on distributed processes, as the "
#~ "limitations\n"
#~ "described in the agents documentation apply to the whole ecosystem.\n"
#~ "\n"
#~ "Finally, check `Task.Supervisor` for other operations supported by the "
#~ "Task\n"
#~ "supervisor.\n"
#~ msgstr ""
#~ "タスクの生成と、待ち受けに便利なものです。\n"
#~ "\n"
#~ "タスクは、そのライフサイクルを通して、一つの特定の活動を実行するはずの\n"
#~ "プロセスです。そのプロセスは、しばしば、少しだけ、または全く他のプロセ\n"
#~ "スとコミュニケーションをとりません。\n"
#~ "タスクのための最も一般的なユースケースは、\n"
#~ "非同期的に値を計算することです:\n"
#~ "\n"
#~ "    task = Task.async(fn -> do_some_work() end)\n"
#~ "    res  = do_some_other_work()\n"
#~ "    res + Task.await(task)\n"
#~ "\n"
#~ "`async`により生み出されたタスクは、上の例で見られるように、\n"
#~ "呼び出しプロセス(そしてその呼び出し側だけに)により待たれます。\n"
#~ "一度与えられた計算が実行されるなら、呼び出し側に\n"
#~ "メッセージを送信するプロセスを生み出すことによって、それらは\n"
#~ "実装されます。\n"
#~ "\n"
#~ "`async/1`と`await/2`の他に、タスクはスーパビジョンツリー\n"
#~ "の一部として開始したり、リモートノードで動的に生み出すことも\n"
#~ "出来ます。次に、全3つのシナリオを調査します。\n"
#~ "\n"
#~ "## async and await\n"
#~ "\n"
#~ "タスクを生む最も一般的な方法は`Task.async/1`です。新しい\n"
#~ "プロセスが作成され、呼び出し側によりリンクされ、モニタされます。\n"
#~ "一度タスクのアクションが終了したら、結果として呼び出し側に\n"
#~ "メッセージが送信されます。\n"
#~ "\n"
#~ "`Task.await/2`はタスクにより送信されたメッセージを読み出すために使われ\n"
#~ "ます。`await`で、Elixirは、プロセスが異常な理由でexitしているかどうか\n"
#~ "(または、呼び出し側によりトラップされるexitしているかどうか)、検証する\n"
#~ "ためのモニタをセットアップします。\n"
#~ "\n"
#~ "## Supervised tasks\n"
#~ "\n"
#~ "`start_link/2`と`start_link/3`でスーパビジョンツリーの内でタスクを\n"
#~ "生み出すこともできます:\n"
#~ "\n"
#~ "    Task.start_link(fn -> IO.puts \"ok\" end)\n"
#~ "\n"
#~ "そのようなタスクは以下のようにして、スーパビジョンツリーに\n"
#~ "取り付けることもできます:\n"
#~ "\n"
#~ "    import Supervisor.Spec\n"
#~ "\n"
#~ "    children = [\n"
#~ "      worker(Task, [fn -> IO.puts \"ok\" end])\n"
#~ "    ]\n"
#~ "\n"
#~ "これらのタスクはスーパバイズされ、直接呼び出し側にリンクされて\n"
#~ "いないので、awaitで待つことが出来ません。\n"
#~ "`start_link/1`(`async/1`と違って)は、`{:ok, pid}`\n"
#~ "(スーバビジョンツリーにより期待される結果です)を返すことに\n"
#~ "注意してください。\n"
#~ "\n"
#~ "## Supervision trees\n"
#~ "\n"
#~ "`Task.Supervisor`モジュールは、開発者に、\n"
#~ "動的にタスクをスーパバイズするスーパバイザを開始することを許します:\n"
#~ "\n"
#~ "    {:ok, pid} = Task.Supervisor.start_link()\n"
#~ "    Task.Supervisor.async(pid, MyMod, :my_fun, [arg1, arg2, arg3])\n"
#~ "\n"
#~ "スーパバイザがローカルまたは、グローバルに登録される限り、\n"
#~ "`Task.Supervisor`もまた、リモートノードでタスクを生むことを可能にします:\n"
#~ "\n"
#~ "    # In the remote node\n"
#~ "    Task.Supervisor.start_link(name: :tasks_sup)\n"
#~ "\n"
#~ "    # In the client\n"
#~ "    Task.Supervisor.async({:tasks_sup, :remote@local}, MyMod, :my_fun, "
#~ "[arg1, arg2, arg3])\n"
#~ "\n"
#~ "`Task.Supervisor`は、スーバビジョンツリーでよりしばしば開始されます:\n"
#~ "\n"
#~ "    import Supervisor.Spec\n"
#~ "\n"
#~ "    children = [\n"
#~ "      supervisor(Task.Supervisor, [[name: :tasks_sup]])\n"
#~ "    ]\n"
#~ "\n"
#~ "なお、分散されたタスクで動くとき、無名関数を動かす`async/1`のかわりに、\n"
#~ "モジュール、関数、引数を明示的に期待する、`async/3`APIを使うべきです。\n"
#~ "これは、無名関数APIは全ての起動されたノードで同じモジュールバージョンが\n"
#~ "存在することを期待するためです。\n"
#~ "全エコシステムに適用される、エージェントドキュメントで記述される制限として"
#~ "の、\n"
#~ "分散プロセスの詳細は、`Agent`モジュールドキュメントをチェックしてくださ"
#~ "い。\n"
#~ "\n"
#~ "最後に、他のタスクスーパバイザによりサポートされるオペレーションについて\n"
#~ "の詳細は、 `Task.Supervisor` をチェックしてください。\n"
