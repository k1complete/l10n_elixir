msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2015-09-16 22:53+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: def OptionParser.parse_head(argv, opts \\ [])
#: lib/option_parser.ex:116
msgid ""
"Similar to `parse/2` but only parses the head of `argv`;\n"
"as soon as it finds a non-switch, it stops parsing.\n"
"\n"
"See `parse/2` for more information.\n"
"\n"
"## Example\n"
"\n"
"    iex> OptionParser.parse_head([\"--source\", \"lib\", \"test/enum_test.exs"
"\", \"--verbose\"])\n"
"    {[source: \"lib\"], [\"test/enum_test.exs\", \"--verbose\"], []}\n"
"\n"
"    iex> OptionParser.parse_head([\"--verbose\", \"--source\", \"lib\", "
"\"test/enum_test.exs\", \"--unlock\"])\n"
"    {[verbose: true, source: \"lib\"], [\"test/enum_test.exs\", \"--unlock"
"\"], []}\n"
"\n"
msgstr ""
"`paprser/2`と似ていますが、`argv`の先頭までパースし、\n"
"スイッチでないものを見付けたら、パースを停止します。\n"
"\n"
"より詳細は`parse/2`をみてください。\n"
"\n"
"## 例\n"
"\n"
"    iex> OptionParser.parse_head([\"--source\", \"lib\", \"test/enum_test.exs"
"\", \"--verbose\"])\n"
"    {[source: \"lib\"], [\"test/enum_test.exs\", \"--verbose\"], []}\n"
"\n"
"    iex> OptionParser.parse_head([\"--verbose\", \"--source\", \"lib\", "
"\"test/enum_test.exs\", \"--unlock\"])\n"
"    {[verbose: true, source: \"lib\"], [\"test/enum_test.exs\", \"--unlock"
"\"], []}\n"
"\n"

#. TRANSLATORS: Elixir.OptionParser Summary
#: lib/option_parser.ex:2
msgid "This module contains functions to parse command line arguments.\n"
msgstr "このモジュールはコマンドライン引数をパースするための関数を含みます。\n"

#. TRANSLATORS: def OptionParser.split(string)
#: lib/option_parser.ex:267
msgid ""
"Splits a string into argv chunks.\n"
"\n"
"## Examples\n"
"\n"
"    iex> OptionParser.split(\"foo bar\")\n"
"    [\"foo\", \"bar\"]\n"
"\n"
"    iex> OptionParser.split(\"foo \\\"bar baz\\\"\")\n"
"    [\"foo\", \"bar baz\"]\n"
msgstr ""
"文字列を引数の塊に分割します。\n"
"\n"
"## 例\n"
"\n"
"    iex> OptionParser.split(\"foo bar\")\n"
"    [\"foo\", \"bar\"]\n"
"\n"
"    iex> OptionParser.split(\"foo \\\"bar baz\\\"\")\n"
"    [\"foo\", \"bar baz\"]\n"

#. TRANSLATORS: def OptionParser.to_argv(enum)
#: lib/option_parser.ex:237
msgid ""
"Receives a key-value enumerable and convert it to argv.\n"
"\n"
"Keys must be atoms. Keys with nil value are discarded,\n"
"boolean values are converted to `--key` or `--no-key`\n"
"and all other values are converted using `to_string/1`.\n"
"\n"
"## Examples\n"
"\n"
"    iex>  OptionParser.to_argv([foo_bar: \"baz\"])\n"
"    [\"--foo-bar\", \"baz\"]\n"
"\n"
"    iex>  OptionParser.to_argv([bool: true, bool: false, discarded: nil])\n"
"    [\"--bool\", \"--no-bool\"]\n"
"\n"
msgstr ""
"キーバリュー enumerableを受け取り、argvに変換します。\n"
"\n"
"キーはアトムでなくてはなりません。値がnilとなるキーは\n"
"捨てられ、値が真偽値となるキーは`--key`あるいは`--no-key`に\n"
"変換され、他の全ての値は`to_string/1`を用いて変換されます。\n"
"\n"
"## 例\n"
"\n"
"    iex>  OptionParser.to_argv([foo_bar: \"baz\"])\n"
"    [\"--foo-bar\", \"baz\"]\n"
"\n"
"    iex>  OptionParser.to_argv([bool: true, bool: false, discarded: nil])\n"
"    [\"--bool\", \"--no-bool\"]\n"
"\n"

#. TRANSLATORS: def OptionParser.next(argv, opts \\ [])
#: lib/option_parser.ex:169
msgid ""
"Low-level function that parses one option.\n"
"\n"
"It accepts the same options as `parse/2` and `parse_head/2`\n"
"as both functions are built on top of next. This function\n"
"may return:\n"
"\n"
"  * `{:ok, key, value, rest}` - the option `key` with `value` was\n"
"    successfully parsed\n"
"\n"
"  * `{:invalid, key, value, rest}` - the option `key` is invalid with "
"`value`\n"
"    (returned when the switch type does not match the one given via the\n"
"    command line)\n"
"\n"
"  * `{:undefined, key, value, rest}` - the option `key` is undefined\n"
"    (returned on strict cases and the switch is unknown)\n"
"\n"
"  * `{:error, rest}` - there are no switches at the top of the given argv\n"
msgstr ""
"一つのオプションをパースする低レベル関数です。\n"
"\n"
"nextの上で構築される`parse/2`や`parse_head/2`といった関数と\n"
"同じオプションを受け付けます。この関数は以下を返します:\n"
"\n"
"  * `{:ok, key, value, rest}` - `value`付きのオプション`key`はパースに\n"
"    成功しました\n"
"\n"
"  * `{:invalid, key, value, rest}` - `value`付きのオプション`key`は無効です\n"
"    (スイッチタイプがコマンドラインにより渡されたものにマッチしないときに\n"
"     返ります)\n"
"\n"
"  * `{:undefined, key, value, rest}` - オプション`key`は未定義です\n"
"    (大文字小文字の違いやスイッチが不明のときに返ります)\n"
"\n"
"  * `{:error, rest}` - 与えられたargvにスイッチがありません\n"

#. TRANSLATORS: def OptionParser.parse(argv, opts \\ [])
#: lib/option_parser.ex:11
msgid ""
"Parses `argv` into a keywords list.\n"
"\n"
"It returns the parsed values, remaining arguments and the\n"
"invalid options.\n"
"\n"
"## Examples\n"
"\n"
"    iex> OptionParser.parse([\"--debug\"])\n"
"    {[debug: true], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--source\", \"lib\"])\n"
"    {[source: \"lib\"], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--source-path\", \"lib\", \"test/enum_test.exs"
"\", \"--verbose\"])\n"
"    {[source_path: \"lib\", verbose: true], [\"test/enum_test.exs\"], []}\n"
"\n"
"By default, Elixir will try to automatically parse switches.\n"
"Switches without an argument, like `--debug` will automatically\n"
"be set to `true`. Switches followed by a value will be assigned\n"
"to the value, always as strings.\n"
"\n"
"Note Elixir also converts the switches to underscore atoms, as\n"
"`--source-path` becomes `:source_path`, to better suit Elixir\n"
"conventions. This means that option names on the command line cannot "
"contain\n"
"underscores; such options will be reported as `:undefined` (in strict mode)\n"
"or `:invalid` (in basic mode).\n"
"\n"
"## Switches\n"
"\n"
"Many times though, it is better to explicitly list the available\n"
"switches and their formats. The switches can be specified via two\n"
"different options:\n"
"\n"
"  * `:strict` - the switches are strict. Any switch that does not\n"
"    exist in the switch list is treated as an error.\n"
"\n"
"  * `:switches` - defines some switches. Switches that does not\n"
"    exist in the switch list are still attempted to be parsed.\n"
"\n"
"Note only `:strict` or `:switches` may be given at once.\n"
"\n"
"For each switch, the following types are supported:\n"
"\n"
"  * `:boolean` - marks the given switch as a boolean. Boolean switches\n"
"    never consume the following value unless it is `true` or\n"
"    `false`.\n"
"  * `:integer` - parses the switch as an integer.\n"
"  * `:float`   - parses the switch as a float.\n"
"  * `:string`  - returns the switch as a string.\n"
"\n"
"If a switch can't be parsed or is not specified in the strict case,\n"
"the option is returned in the invalid options list (third element\n"
"of the returned tuple).\n"
"\n"
"The following extra \"types\" are supported:\n"
"\n"
"  * `:keep` - keeps duplicated items in the list instead of overriding\n"
"\n"
"Examples:\n"
"\n"
"    iex> OptionParser.parse([\"--unlock\", \"path/to/file\"], strict: "
"[unlock: :boolean])\n"
"    {[unlock: true], [\"path/to/file\"], []}\n"
"\n"
"    iex> OptionParser.parse([\"--unlock\", \"--limit\", \"0\", \"path/to/file"
"\"],\n"
"    ...>                    strict: [unlock: :boolean, limit: :integer])\n"
"    {[unlock: true, limit: 0], [\"path/to/file\"], []}\n"
"\n"
"    iex> OptionParser.parse([\"--limit\", \"3\"], strict: [limit: :"
"integer])\n"
"    {[limit: 3], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--limit\", \"xyz\"], strict: [limit: :"
"integer])\n"
"    {[], [], [{\"--limit\", \"xyz\"}]}\n"
"\n"
"    iex> OptionParser.parse([\"--unknown\", \"xyz\"], strict: [])\n"
"    {[], [\"xyz\"], [{\"--unknown\", nil}]}\n"
"\n"
"    iex> OptionParser.parse([\"--limit\", \"3\", \"--unknown\", \"xyz\"],\n"
"    ...>                    switches: [limit: :integer])\n"
"    {[limit: 3, unknown: \"xyz\"], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--unlock\", \"path/to/file\", \"--unlock\", "
"\"path/to/another/file\"], strict: [unlock: :keep])\n"
"    {[unlock: \"path/to/file\", unlock: \"path/to/another/file\"], [], []}\n"
"\n"
"## Negation switches\n"
"\n"
"In case a switch is declared as boolean, it may be passed as `--no-SWITCH`\n"
"which will set the option to `false`:\n"
"\n"
"    iex> OptionParser.parse([\"--no-op\", \"path/to/file\"], switches: [op: :"
"boolean])\n"
"    {[op: false], [\"path/to/file\"], []}\n"
"\n"
"## Aliases\n"
"\n"
"A set of aliases can be given as options too:\n"
"\n"
"    iex> OptionParser.parse([\"-d\"], aliases: [d: :debug])\n"
"    {[debug: true], [], []}\n"
"\n"
msgstr ""
"`argv`をキーワードリストにパースします。\n"
"\n"
"それはパースされた値、残りの引数、無効なオプションを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> OptionParser.parse([\"--debug\"])\n"
"    {[debug: true], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--source\", \"lib\"])\n"
"    {[source: \"lib\"], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--source-path\", \"lib\", \"test/enum_test.exs\", \"--verbose\"])\n"
"    {[source_path: \"lib\", verbose: true], [\"test/enum_test.exs\"], []}\n"
"\n"
"デフォルトで、Elixirは自動的にスイッチをパースしようとします。\n"
"`--debug`のような引数なしのスイッチは、自動的にtrueにセットされます。\n"
"値が後ろに続くスイッチは、その値が常に文字列としてセットされます。\n"
"\n"
"Elixirもまた、Elixirの慣習により合うようにするため、\n"
"`--source-path`を`:source_path`として、\n"
"スイッチをアンダースコアアトムに変換することに、\n"
"注意してください。\n"
"これはコマンドラインのオプション名はアンダースコアを含むことができない\n"
"ことを意味します; そのようなオプションは(厳格なモードでは)\n"
"`:undefined`として、あるいは、(ベーシックモードでは)`:invalid`\n"
"として報告されます。\n"
"\n"
"## Switches\n"
"\n"
"しばしば、有効なスイッチとそのフォーマットのリストを明確にすることは\n"
"よりよいです。スイッチは二つの異るオプションで指定できます:\n"
"\n"
"  * `:strict` - スイッチは厳格です。\n"
"    スイッチリストに存在していない全てのスイッチは、エラーとして\n"
"    扱われます。\n"
"\n"
"  * `:switches` - いくつかのスイッチを定義します。\n"
"    スイッチリストに存在していないスイッチは、パースされるために\n"
"    まだ試みられます。\n"
"\n"
"`:strict`または`:switches`は一度だけ与えられる\n"
"かもしれないことに、注意してください。\n"
"\n"
"それぞれのスイッチのために、以下のタイプがサポートされています:\n"
"\n"
"  * `:boolean` - 与えられたスイッチをブーリアンとしてマークします。\n"
"                 ブーリアンスイッチは決して`true`か`false`以外の\n"
"                 値を消費しません。\n"
"  * `:integer` - 整数としてスイッチをパースします。\n"
"  * `:float`   - 浮動小数点数としてスイッチをパースします。\n"
"  * `:string`  - 文字列としてスイッチをパースします。\n"
"\n"
"スイッチがパースできないか、厳格なモードで指定されていないかなら、オプ\n"
"ションは無効なオプションリスト(戻りタプルの三番目の要素)の中に返ります。\n"
"\n"
"以下の特別な\"type\"がサポートされています:\n"
"\n"
"  * `:keep` - 上書きするかわりに、重複したアイテムを保持します\n"
"\n"
"Examples:\n"
"\n"
"    iex> OptionParser.parse([\"--unlock\", \"path/to/file\"], strict: [unlock: :boolean])\n"
"    {[unlock: true], [\"path/to/file\"], []}\n"
"\n"
"    iex> OptionParser.parse([\"--unlock\", \"--limit\", \"0\", \"path/to/file\"],\n"
"    ...>                    strict: [unlock: :boolean, limit: :integer])\n"
"    {[unlock: true, limit: 0], [\"path/to/file\"], []}\n"
"\n"
"    iex> OptionParser.parse([\"--limit\", \"3\"], strict: [limit: :integer])\n"
"    {[limit: 3], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--limit\", \"xyz\"], strict: [limit: :integer])\n"
"    {[], [], [{\"--limit\", \"xyz\"}]}\n"
"\n"
"    iex> OptionParser.parse([\"--unknown\", \"xyz\"], strict: [])\n"
"    {[], [\"xyz\"], [{\"--unknown\", nil}]}\n"
"\n"
"    iex> OptionParser.parse([\"--limit\", \"3\", \"--unknown\", \"xyz\"],\n"
"    ...>                    switches: [limit: :integer])\n"
"    {[limit: 3, unknown: \"xyz\"], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--unlock\", \"path/to/file\", \"--unlock\", \"path/to/another/file\"], strict: [unlock: :keep])\n"
"    {[unlock: \"path/to/file\", unlock: \"path/to/another/file\"], [], []}\n"
"\n"
"## Negation switches\n"
"\n"
"ブーリアンとして宣言されたスイッチで、`--no-SWITH`として渡されたら、\n"
"そのオプションはfalseとセットされます:\n"
"\n"
"    iex> OptionParser.parse([\"--no-op\", \"path/to/file\"], switches: [op: :boolean])\n"
"    {[op: false], [\"path/to/file\"], []}\n"
"\n"
"## Aliases\n"
"\n"
"一組のアイリアスをオプションに与えることもできます:\n"
"\n"
"    iex> OptionParser.parse([\"-d\"], aliases: [d: :debug])\n"
"    {[debug: true], [], []}\n"
"\n"
