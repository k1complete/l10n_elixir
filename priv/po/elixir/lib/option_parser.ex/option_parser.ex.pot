#. TRANSLATORS: def OptionParser.next(argv, opts \\ [])
#: lib/option_parser.ex:173 
msgid ""
"Low-level function that parses one option.\n"
"\n"
"It accepts the same options as `parse/2` and `parse_head/2`\n"
"as both functions are built on top of next. This function\n"
"may return:\n"
"\n"
"  * `{:ok, key, value, rest}` - the option `key` with `value` was\n"
"    successfully parsed\n"
"\n"
"  * `{:invalid, key, value, rest}` - the option `key` is invalid with `value`\n"
"    (returned when the switch type does not match the one given via the\n"
"    command line)\n"
"\n"
"  * `{:undefined, key, value, rest}` - the option `key` is undefined\n"
"    (returned in strict mode when the switch is unknown)\n"
"\n"
"  * `{:error, rest}` - there are no switches at the top of the given argv\n"
msgstr ""
#. TRANSLATORS: def OptionParser.parse_head(argv, opts \\ [])
#: lib/option_parser.ex:120 
msgid ""
"Similar to `parse/2` but only parses the head of `argv`;\n"
"as soon as it finds a non-switch, it stops parsing.\n"
"\n"
"See `parse/2` for more information.\n"
"\n"
"## Example\n"
"\n"
"    iex> OptionParser.parse_head([\"--source\", \"lib\", \"test/enum_test.exs\", \"--verbose\"])\n"
"    {[source: \"lib\"], [\"test/enum_test.exs\", \"--verbose\"], []}\n"
"\n"
"    iex> OptionParser.parse_head([\"--verbose\", \"--source\", \"lib\", \"test/enum_test.exs\", \"--unlock\"])\n"
"    {[verbose: true, source: \"lib\"], [\"test/enum_test.exs\", \"--unlock\"], []}\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.OptionParser Summary
#: lib/option_parser.ex:2 
msgid ""
"This module contains functions to parse command line options.\n"
msgstr ""
#. TRANSLATORS: def OptionParser.to_argv(enum)
#: lib/option_parser.ex:241 
msgid ""
"Receives a key-value enumerable and converts it to argv.\n"
"\n"
"Keys must be atoms. Keys with nil value are discarded,\n"
"boolean values are converted to `--key` or `--no-key`\n"
"and all other values are converted using `to_string/1`.\n"
"\n"
"## Examples\n"
"\n"
"    iex>  OptionParser.to_argv([foo_bar: \"baz\"])\n"
"    [\"--foo-bar\", \"baz\"]\n"
"\n"
"    iex>  OptionParser.to_argv([bool: true, bool: false, discarded: nil])\n"
"    [\"--bool\", \"--no-bool\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def OptionParser.split(string)
#: lib/option_parser.ex:271 
msgid ""
"Splits a string into argv chunks.\n"
"\n"
"## Examples\n"
"\n"
"    iex> OptionParser.split(\"foo bar\")\n"
"    [\"foo\", \"bar\"]\n"
"\n"
"    iex> OptionParser.split(\"foo \\\"bar baz\\\"\")\n"
"    [\"foo\", \"bar baz\"]\n"
msgstr ""
#. TRANSLATORS: def OptionParser.parse(argv, opts \\ [])
#: lib/option_parser.ex:11 
msgid ""
"Parses `argv` into a keywords list.\n"
"\n"
"It returns a three-element tuple as follows:\n"
"\n"
"   1. parsed switches,\n"
"   2. remaining arguments,\n"
"   3. invalid options.\n"
"\n"
"## Examples\n"
"\n"
"    iex> OptionParser.parse([\"--debug\"])\n"
"    {[debug: true], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--source\", \"lib\"])\n"
"    {[source: \"lib\"], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--source-path\", \"lib\", \"test/enum_test.exs\", \"--verbose\"])\n"
"    {[source_path: \"lib\", verbose: true], [\"test/enum_test.exs\"], []}\n"
"\n"
"By default, Elixir will try to automatically parse all switches.\n"
"Switches followed by a value will be assigned the value, as a string.\n"
"Switches without an argument, like `--debug` will automatically\n"
"be set to `true`.\n"
"\n"
"Note: Elixir also converts the switches to underscore atoms, so\n"
"`--source-path` becomes `:source_path`, to better suit Elixir\n"
"conventions. This means that option names on the command line cannot contain\n"
"underscores; such options will be put in the invalid options list.\n"
"\n"
"## Switch Definitions\n"
"\n"
"Often it is better to explicitly list the known\n"
"switches and their formats. The switches can be specified via two\n"
"alternative options:\n"
"\n"
"  * `:switches` - defines some switches. An attempt is still made to parse\n"
"    switches that do not appear in the list.\n"
"\n"
"  * `:strict` - the switches are strict. Any switch that is not specified\n"
"    in the list is returned in the invalid options list.\n"
"\n"
"Note that you should only supply the `:switches` or `:strict` option. If you\n"
"supply both, an error will be raised.\n"
"\n"
"For each switch, the following types are supported:\n"
"\n"
"  * `:boolean` - marks the given switch as a boolean. Boolean switches\n"
"    never consume the following value unless it is `true` or\n"
"    `false`.\n"
"  * `:integer` - parses the switch as an integer.\n"
"  * `:float`   - parses the switch as a float.\n"
"  * `:string`  - returns the switch as a string.\n"
"\n"
"If a switch can't be parsed, it is returned in the invalid options list.\n"
"\n"
"The following extra \"types\" are supported:\n"
"\n"
"  * `:keep` - keeps duplicated items in the list instead of overriding them.\n"
"\n"
"Note: if you want to use `:keep` with a non-string type, use a list, e.g.\n"
"`[foo: [:integer, :keep]]`.\n"
"\n"
"Examples:\n"
"\n"
"    iex> OptionParser.parse([\"--unlock\", \"path/to/file\"], strict: [unlock: :boolean])\n"
"    {[unlock: true], [\"path/to/file\"], []}\n"
"\n"
"    iex> OptionParser.parse([\"--unlock\", \"--limit\", \"0\", \"path/to/file\"],\n"
"    ...>                    strict: [unlock: :boolean, limit: :integer])\n"
"    {[unlock: true, limit: 0], [\"path/to/file\"], []}\n"
"\n"
"    iex> OptionParser.parse([\"--limit\", \"3\"], strict: [limit: :integer])\n"
"    {[limit: 3], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--limit\", \"xyz\"], strict: [limit: :integer])\n"
"    {[], [], [{\"--limit\", \"xyz\"}]}\n"
"\n"
"    iex> OptionParser.parse([\"--unknown\", \"xyz\"], strict: [])\n"
"    {[], [\"xyz\"], [{\"--unknown\", nil}]}\n"
"\n"
"    iex> OptionParser.parse([\"--limit\", \"3\", \"--unknown\", \"xyz\"],\n"
"    ...>                    switches: [limit: :integer])\n"
"    {[limit: 3, unknown: \"xyz\"], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--unlock\", \"path/to/file\", \"--unlock\", \"path/to/another/file\"], strict: [unlock: :keep])\n"
"    {[unlock: \"path/to/file\", unlock: \"path/to/another/file\"], [], []}\n"
"\n"
"## Negation switches\n"
"\n"
"In case a switch is declared as boolean, it may be passed as `--no-SWITCH`\n"
"which will set the option to `false`:\n"
"\n"
"    iex> OptionParser.parse([\"--no-op\", \"path/to/file\"], switches: [op: :boolean])\n"
"    {[op: false], [\"path/to/file\"], []}\n"
"\n"
"## Aliases\n"
"\n"
"A set of aliases can be given as options too:\n"
"\n"
"    iex> OptionParser.parse([\"-d\"], aliases: [d: :debug])\n"
"    {[debug: true], [], []}\n"
"\n"
msgstr ""
