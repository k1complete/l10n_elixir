msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2015-12-22 22:55+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: def Map.new()
#: lib/map.ex:53
msgid ""
"Returns a new empty map.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.new\n"
"    %{}\n"
"\n"
msgstr ""
"新しい空のマップを返します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.new\n"
"    %{}\n"
"\n"

#. TRANSLATORS: Elixir.Map Summary
#: lib/map.ex:2
msgid ""
"A set of functions for working with maps.\n"
"\n"
"Maps are key-value stores where keys can be any value and\n"
"are compared using the match operator (`===`). Maps can be\n"
"created with the `%{}` special form defined in the\n"
"`Kernel.SpecialForms` module.\n"
msgstr ""
"マップで動作する一群の関数です。\n"
"\n"
"マップは、キーをマッチオペレータ(`===`)で比較する、\n"
"キーバリューストアです。マップは、\n"
"`Kernel.SpecilForms`で定義された`%{}`スペシャルフォームで、\n"
"作成することができます\n"

#. TRANSLATORS: def Map.fetch(map, key)
#: lib/map.ex:117
msgid ""
"Fetches the value for a specific `key` and returns it in a tuple.\n"
"\n"
"If the `key` does not exist, returns `:error`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.fetch(%{a: 1}, :a)\n"
"    {:ok, 1}\n"
"    iex> Map.fetch(%{a: 1}, :b)\n"
"    :error\n"
"\n"
msgstr ""
"指定された`key`を値を取得し、タプルで返します。\n"
"\n"
"`key`が無い場合、`:error`を返します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.fetch(%{a: 1}, :a)\n"
"    {:ok, 1}\n"
"    iex> Map.fetch(%{a: 1}, :b)\n"
"    :error\n"
"\n"

#. TRANSLATORS: def Map.update!(map, key, fun)
#: lib/map.ex:456
msgid ""
"Updates the `key` with the given function.\n"
"\n"
"If the `key` does not exist, raises `KeyError`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.update!(%{a: 1}, :a, &(&1 * 2))\n"
"    %{a: 2}\n"
"\n"
"    iex> Map.update!(%{a: 1}, :b, &(&1 * 2))\n"
"    ** (KeyError) key :b not found\n"
"\n"
msgstr ""
"与えられた関数で`key`を更新します。\n"
"\n"
"もし`key`が存在しないなら、`KeyError`が上ります。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.update!(%{a: 1}, :a, &(&1 * 2))\n"
"    %{a: 2}\n"
"\n"
"    iex> Map.update!(%{a: 1}, :b, &(&1 * 2))\n"
"    ** (KeyError) key :b not found\n"
"\n"

#. TRANSLATORS: def Map.fetch!(map, key)
#: lib/map.ex:133
msgid ""
"Fetches the value for specific `key`.\n"
"\n"
"If `key` does not exist, a `KeyError` is raised.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.fetch!(%{a: 1}, :a)\n"
"    1\n"
"    iex> Map.fetch!(%{a: 1}, :b)\n"
"    ** (KeyError) key :b not found in: %{a: 1}\n"
"\n"
msgstr ""
"指定された`key`の値を取得します。\n"
"\n"
"もし`key`が存在しないなら、`KeyError`が上ります。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.fetch!(%{a: 1}, :a)\n"
"    1\n"
"    iex> Map.fetch!(%{a: 1}, :b)\n"
"    ** (KeyError) key :b not found in: %{a: 1}\n"
"\n"

#. TRANSLATORS: def Map.merge(map1, map2, callback)
#: lib/map.ex:324
msgid ""
"Merges two maps into one.\n"
"\n"
"All keys in `map2` will be added to `map1`. The given function will\n"
"be invoked with the key, value1 and value2 to solve conflicts.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.merge(%{a: 1, b: 2}, %{a: 3, d: 4}, fn _k, v1, v2 ->\n"
"    ...>   v1 + v2\n"
"    ...> end)\n"
"    %{a: 4, b: 2, d: 4}\n"
"\n"
msgstr ""
"二つのmapを一つにマージします。\n"
"\n"
"`map2`の全てのkeyが`map`に追加されます。\n"
"与えられた関数が、key, value1とvalue2を伴ってコンフリクトを解決するために\n"
"起動されます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.merge(%{a: 1, b: 2}, %{a: 3, d: 4}, fn _k, v1, v2 ->\n"
"    ...>   v1 + v2\n"
"    ...> end)\n"
"    %{a: 4, b: 2, d: 4}\n"
"\n"

#. TRANSLATORS: def Map.to_list(map)
#: lib/map.ex:39
msgid ""
"Converts the map to a list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.to_list(%{a: 1})\n"
"    [a: 1]\n"
"    iex> Map.to_list(%{1 => 2})\n"
"    [{1, 2}]\n"
"\n"
msgstr ""
"マップをリストに変換します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.to_list(%{a: 1})\n"
"    [a: 1]\n"
"    iex> Map.to_list(%{1 => 2})\n"
"    [{1, 2}]\n"
"\n"

#. TRANSLATORS: def Map.split(map, keys)
#: lib/map.ex:430
msgid ""
"Takes all entries corresponding to the given keys and extracts them into a\n"
"separate map.\n"
"\n"
"Returns a tuple with the new map and the old map with removed keys.\n"
"\n"
"Keys for which there are no entires in the map are ignored.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.split(%{a: 1, b: 2, c: 3}, [:a, :c, :e])\n"
"    {%{a: 1, c: 3}, %{b: 2}}\n"
"\n"
msgstr ""
"与えられたキーに対応する全てのエントリを取り出し、それらを\n"
"別のmapに抽出します。\n"
"\n"
"新しいmapと古いmapからキーを削除されたものの2要素のタプルを\n"
"返します。\n"
"\n"
"mapにエントリが存在しないキーは無視されます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.split(%{a: 1, b: 2, c: 3}, [:a, :c, :e])\n"
"    {%{a: 1, c: 3}, %{b: 2}}\n"
"\n"

#. TRANSLATORS: def Map.new(enumerable, transform)
#: lib/map.ex:83
msgid ""
"Creates a map from an enumerable via the transformation function.\n"
"\n"
"Duplicated entries are removed; the latest one prevails.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.new([:a, :b], fn x -> {x, x} end)\n"
"    %{a: :a, b: :b}\n"
"\n"
msgstr ""
"enumerableから変換関数を通じてmapを作成します。\n"
"\n"
"重複したエントリは削除されます; 最後のものが優先されます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.new([:a, :b], fn x -> {x, x} end)\n"
"    %{a: :a, b: :b}\n"
"\n"

#. TRANSLATORS: def Map.put_new_lazy(map, key, fun)
#: lib/map.ex:174
msgid ""
"Evaluates `fun` and puts the result under `key`\n"
"in map unless `key` is already present.\n"
"\n"
"This is useful if the value is very expensive to calculate or\n"
"generally difficult to setup and teardown again.\n"
"\n"
"## Examples\n"
"\n"
"    iex> map = %{a: 1}\n"
"    iex> fun = fn ->\n"
"    ...>   # some expensive operation here\n"
"    ...>   3\n"
"    ...> end\n"
"    iex> Map.put_new_lazy(map, :a, fun)\n"
"    %{a: 1}\n"
"    iex> Map.put_new_lazy(map, :b, fun)\n"
"    %{a: 1, b: 3}\n"
"\n"
msgstr ""
"`key`がmapに既に無いかぎり、`fun`を評価し、その結果を\n"
"`key`の値としてmapにputします。\n"
"\n"
"これは値の計算に非常にコストがかかるとか、setupや\n"
"teardownを再び行うのが困難な場合に一般に便利です。\n"
"\n"
"## Examples\n"
"\n"
"    iex> map = %{a: 1}\n"
"    iex> fun = fn ->\n"
"    ...>   # some expensive operation here\n"
"    ...>   3\n"
"    ...> end\n"
"    iex> Map.put_new_lazy(map, :a, fun)\n"
"    %{a: 1}\n"
"    iex> Map.put_new_lazy(map, :b, fun)\n"
"    %{a: 1, b: 3}\n"
"\n"

#. TRANSLATORS: def Map.update(map, key, initial, fun)
#: lib/map.ex:345
msgid ""
"Updates the `key` in `map` with the given function.\n"
"\n"
"If the `key` does not exist, inserts the given `initial` value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.update(%{a: 1}, :a, 13, &(&1 * 2))\n"
"    %{a: 2}\n"
"    iex> Map.update(%{a: 1}, :b, 11, &(&1 * 2))\n"
"    %{a: 1, b: 11}\n"
"\n"
msgstr ""
"与えられた関数で`map`の`key`を更新します。\n"
"\n"
"もし`key`が存在しないなら、与えられた`initial`値が挿入されます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.update(%{a: 1}, :a, 13, &(&1 * 2))\n"
"    %{a: 2}\n"
"    iex> Map.update(%{a: 1}, :b, 11, &(&1 * 2))\n"
"    %{a: 1, b: 11}\n"
"\n"

#. TRANSLATORS: def Map.pop(map, key, default \\ nil)
#: lib/map.ex:368
msgid ""
"Returns and removes all values associated with `key` in the `map`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.pop(%{a: 1}, :a)\n"
"    {1, %{}}\n"
"    iex> Map.pop(%{a: 1}, :b)\n"
"    {nil, %{a: 1}}\n"
"    iex> Map.pop(%{a: 1}, :b, 3)\n"
"    {3, %{a: 1}}\n"
"\n"
msgstr ""
"`map`の中の`key`に関連付けられた全ての値を削除し、削除した\n"
"値と、更新後のmapを返します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.pop(%{a: 1}, :a)\n"
"    {1, %{}}\n"
"    iex> Map.pop(%{a: 1}, :b)\n"
"    {nil, %{a: 1}}\n"
"    iex> Map.pop(%{a: 1}, :b, 3)\n"
"    {3, %{a: 1}}\n"
"\n"

#. TRANSLATORS: def Map.pop_lazy(map, key, fun)
#: lib/map.ex:389
msgid ""
"Lazily returns and removes all values associated with `key` in the `map`.\n"
"\n"
"This is useful if the default value is very expensive to calculate or\n"
"generally difficult to setup and teardown again.\n"
"\n"
"## Examples\n"
"\n"
"    iex> map = %{a: 1}\n"
"    iex> fun = fn ->\n"
"    ...>   # some expensive operation here\n"
"    ...>   13\n"
"    ...> end\n"
"    iex> Map.pop_lazy(map, :a, fun)\n"
"    {1, %{}}\n"
"    iex> Map.pop_lazy(map, :b, fun)\n"
"    {13, %{a: 1}}\n"
"\n"
msgstr ""
"`map`中の`key`に関連付けられた全ての値を削除して\n"
"返します。ただし、`key`が存在しない時はfunを評価した結果を返します。\n"
"\n"
"これはデフォルト値の計算に非常にコストがかかったり、\n"
"一般的に再びsetupやteardownを行うのが困難だったりする場合に\n"
"便利です。\n"
"\n"
"## Examples\n"
"\n"
"    iex> map = %{a: 1}\n"
"    iex> fun = fn ->\n"
"    ...>   # some expensive operation here\n"
"    ...>   13\n"
"    ...> end\n"
"    iex> Map.pop_lazy(map, :a, fun)\n"
"    {1, %{}}\n"
"    iex> Map.pop_lazy(map, :b, fun)\n"
"    {13, %{a: 1}}\n"
"\n"

#. TRANSLATORS: def Map.values(map)
#: lib/map.ex:27
msgid ""
"Returns all values from the map.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.values(%{a: 1, b: 2})\n"
"    [1, 2]\n"
"\n"
msgstr ""
"mapから全ての値を返します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.values(%{a: 1, b: 2})\n"
"    [1, 2]\n"
"\n"

#. TRANSLATORS: def Map.equal?(map1, map2)
#: lib/map.ex:584
msgid ""
"Checks if two maps are equal.\n"
"\n"
"Two maps are considered to be equal if they contain\n"
"the same keys and those keys contain the same values.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.equal?(%{a: 1, b: 2}, %{b: 2, a: 1})\n"
"    true\n"
"    iex> Map.equal?(%{a: 1, b: 2}, %{b: 1, a: 2})\n"
"    false\n"
"\n"
msgstr ""
"二つのマップが等しいかをチェックします。\n"
"\n"
"二つのマップは、それらが同じキーを持っていて、\n"
"それらのキーが同じ値を持っている場合、等しいと\n"
"考えられます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.equal?(%{a: 1, b: 2}, %{b: 2, a: 1})\n"
"    true\n"
"    iex> Map.equal?(%{a: 1, b: 2}, %{b: 1, a: 2})\n"
"    false\n"
"\n"

#. TRANSLATORS: def Map.put(map, key, val)
#: lib/map.ex:278
msgid ""
"Puts the given `value` under `key`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.put(%{a: 1}, :b, 2)\n"
"    %{a: 1, b: 2}\n"
"    iex> Map.put(%{a: 1, b: 2}, :a, 3)\n"
"    %{a: 3, b: 2}\n"
"\n"
msgstr ""
"`key`に与えられた`value`をプットします。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.put(%{a: 1}, :b, 2)\n"
"    %{a: 1, b: 2}\n"
"    iex> Map.put(%{a: 1, b: 2}, :a, 3)\n"
"    %{a: 3, b: 2}\n"
"\n"

#. TRANSLATORS: def Map.take(map, keys)
#: lib/map.ex:202
msgid ""
"Takes all entries corresponding to the given keys and\n"
"returns them in a new map.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.take(%{a: 1, b: 2, c: 3}, [:a, :c, :e])\n"
"    %{a: 1, c: 3}\n"
"\n"
msgstr ""
"与えられたkeysを全て含む新しいmapを返します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.take(%{a: 1, b: 2, c: 3}, [:a, :c, :e])\n"
"    %{a: 1, c: 3}\n"
"\n"

#. TRANSLATORS: def Map.get_lazy(map, key, fun)
#: lib/map.ex:249
msgid ""
"Gets the value for a specific `key`.\n"
"\n"
"If `key` does not exist, lazily evaluates `fun` and returns its result.\n"
"\n"
"This is useful if the default value is very expensive to calculate or\n"
"generally difficult to setup and teardown again.\n"
"\n"
"## Examples\n"
"\n"
"    iex> map = %{a: 1}\n"
"    iex> fun = fn ->\n"
"    ...>   # some expensive operation here\n"
"    ...>   13\n"
"    ...> end\n"
"    iex> Map.get_lazy(map, :a, fun)\n"
"    1\n"
"    iex> Map.get_lazy(map, :b, fun)\n"
"    13\n"
"\n"
msgstr ""
"指定された`key`の値を取得します。\n"
"\n"
"`key`が存在しない場合、`fun`が遅延評価され、\n"
"その結果が返ります。\n"
"\n"
"これはデフォルト値の計算に非常にコストがかかったり、\n"
"一般的に再びsetupやteardownを行うのが困難だったりする場合に\n"
"便利です。\n"
"\n"
"## Examples\n"
"\n"
"    iex> map = %{a: 1}\n"
"    iex> fun = fn ->\n"
"    ...>   # some expensive operation here\n"
"    ...>   13\n"
"    ...> end\n"
"    iex> Map.get_lazy(map, :a, fun)\n"
"    1\n"
"    iex> Map.get_lazy(map, :b, fun)\n"
"    13\n"
"\n"

#. TRANSLATORS: def Map.new(enumerable)
#: lib/map.ex:65
msgid ""
"Creates a map from an enumerable.\n"
"\n"
"Duplicated keys are removed; the latest one prevails.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.new([{:b, 1}, {:a, 2}])\n"
"    %{a: 2, b: 1}\n"
"    iex> Map.new([a: 1, a: 2, a: 3])\n"
"    %{a: 3}\n"
"\n"
msgstr ""
"enumerableからマップを作成します。\n"
"\n"
"重複したkeyは削除され、最後のものが勝ちます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.new([{:b, 1}, {:a, 2}])\n"
"    %{a: 2, b: 1}\n"
"    iex> Map.new([a: 1, a: 2, a: 3])\n"
"    %{a: 3}\n"
"\n"

#. TRANSLATORS: def Map.put_new(map, key, value)
#: lib/map.ex:154
msgid ""
"Puts the given `value` under `key` unless the entry `key`\n"
"already exists.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.put_new(%{a: 1}, :b, 2)\n"
"    %{b: 2, a: 1}\n"
"    iex> Map.put_new(%{a: 1, b: 2}, :a, 3)\n"
"    %{a: 1, b: 2}\n"
"\n"
msgstr ""
"`key`が既に存在していない限り、`key`の下で与えられ\n"
"た`value`をputします。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.put_new(%{a: 1}, :b, 2)\n"
"    %{b: 2, a: 1}\n"
"    iex> Map.put_new(%{a: 1, b: 2}, :a, 3)\n"
"    %{a: 1, b: 2}\n"
"\n"

#. TRANSLATORS: def Map.delete(map, key)
#: lib/map.ex:294
msgid ""
"Deletes the entries in the map for a specific `key`.\n"
"\n"
"If the `key` does not exist, returns the map unchanged.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.delete(%{a: 1, b: 2}, :a)\n"
"    %{b: 2}\n"
"    iex> Map.delete(%{b: 2}, :a)\n"
"    %{b: 2}\n"
"\n"
msgstr ""
"指定された`key`をマップのエントリから削除します。\n"
"\n"
"もし`key`が存在しない場合、変更されないマップが返ります。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.delete(%{a: 1, b: 2}, :a)\n"
"    %{b: 2}\n"
"    iex> Map.delete(%{b: 2}, :a)\n"
"    %{b: 2}\n"
"\n"

#. TRANSLATORS: def Map.from_struct(struct)
#: lib/map.ex:556
msgid ""
"Converts a struct to map.\n"
"\n"
"It accepts the struct module or a struct itself and\n"
"simply removes the `__struct__` field from the struct.\n"
"\n"
"## Example\n"
"\n"
"    defmodule User do\n"
"      defstruct [:name]\n"
"    end\n"
"\n"
"    Map.from_struct(User)\n"
"    #=> %{name: nil}\n"
"\n"
"    Map.from_struct(%User{name: \"john\"})\n"
"    #=> %{name: \"john\"}\n"
"\n"
msgstr ""
"構造体をマップに変換します。\n"
"\n"
"構造体モジュールか構造体自身を受け付け、\n"
"単に、構造体から`__struct__`フィールドを取り除きます。\n"
"\n"
"## 例\n"
"\n"
"    defmodule User do\n"
"      defstruct [:name]\n"
"    end\n"
"\n"
"    Map.from_struct(User)\n"
"    #=> %{name: nil}\n"
"\n"
"    Map.from_struct(%User{name: \"john\"})\n"
"    #=> %{name: \"john\"}\n"
"\n"

#. TRANSLATORS: def Map.keys(map)
#: lib/map.ex:15
msgid ""
"Returns all keys from the map.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.keys(%{a: 1, b: 2})\n"
"    [:a, :b]\n"
"\n"
msgstr ""
"マップから全てのkeyを返します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.keys(%{a: 1, b: 2})\n"
"    [:a, :b]\n"
"\n"

#. TRANSLATORS: def Map.merge(map1, map2)
#: lib/map.ex:310
msgid ""
"Merges two maps into one.\n"
"\n"
"All keys in `map2` will be added to `map1`, overriding any existing one.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.merge(%{a: 1, b: 2}, %{a: 3, d: 4})\n"
"    %{a: 3, b: 2, d: 4}\n"
"\n"
msgstr ""
"二つのマップを一つにマージします。\n"
"\n"
"`map2`の全てのキーが`map1`に追加され、既存のものは上書きされます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.merge(%{a: 1, b: 2}, %{a: 3, d: 4})\n"
"    %{a: 3, b: 2, d: 4}\n"
"\n"

#. TRANSLATORS: def Map.drop(map, keys)
#: lib/map.ex:416
msgid ""
"Drops the given keys from the map.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.drop(%{a: 1, b: 2, c: 3}, [:b, :d])\n"
"    %{a: 1, c: 3}\n"
"\n"
msgstr ""
"与えられたkeysをマップから削除します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.drop(%{a: 1, b: 2, c: 3}, [:b, :d])\n"
"    %{a: 1, c: 3}\n"
"\n"

#. TRANSLATORS: def Map.get_and_update(map, key, fun)
#: lib/map.ex:482
msgid ""
"Gets the value from `key` and updates it, all in one pass.\n"
"\n"
"This `fun` argument receives the value of `key` (or `nil` if `key`\n"
"is not present) and must return a two-elements tuple: the \"get\" value "
"(the\n"
"retrieved value, which can be operated on before being returned) and the "
"new\n"
"value to be stored under `key`.\n"
"\n"
"The returned value is a tuple with the \"get\" value returned by `fun` and "
"a\n"
"new map with the updated value under `key`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.get_and_update(%{a: 1}, :a, fn current_value ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    {1, %{a: \"new value!\"}}\n"
"\n"
"    iex> Map.get_and_update(%{a: 1}, :b, fn current_value ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    {nil, %{b: \"new value!\", a: 1}}\n"
"\n"
msgstr ""
"`key`から値を取得し更新し、それらを一度のパスで行います。\n"
"\n"
"この`fun`引数は、`key`の値(あるいは`key`が存在しない場合は`nil`)を\n"
"受取り、2要素のタプルを返さなくてはなりません: (取り出した値はリ\n"
"ターンする前に操作されるかもしれません)\"get\" した値と、\n"
"`key`にストアされる新しい値です。\n"
"\n"
"戻値は、`fun`により返された\"get\"した値と`key`の値が更新された\n"
"新しいマップです。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.get_and_update(%{a: 1}, :a, fn current_value ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    {1, %{a: \"new value!\"}}\n"
"\n"
"    iex> Map.get_and_update(%{a: 1}, :b, fn current_value ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    {nil, %{b: \"new value!\", a: 1}}\n"
"\n"

#. TRANSLATORS: def Map.has_key?(map, key)
#: lib/map.ex:103
msgid ""
"Returns whether a given `key` exists in the given `map`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.has_key?(%{a: 1}, :a)\n"
"    true\n"
"    iex> Map.has_key?(%{a: 1}, :b)\n"
"    false\n"
"\n"
msgstr ""
"与えられた`map`に与えられた`key`が存在するかを返します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.has_key?(%{a: 1}, :a)\n"
"    true\n"
"    iex> Map.has_key?(%{a: 1}, :b)\n"
"    false\n"
"\n"

#. TRANSLATORS: def Map.get_and_update!(map, key, fun)
#: lib/map.ex:519
msgid ""
"Gets the value from `key` and updates it. Raises if there is no `key`.\n"
"\n"
"This `fun` argument receives the value of `key` and must return a\n"
"two-elements tuple: the \"get\" value (the retrieved value, which can be\n"
"operated on before being returned) and the new value to be stored under\n"
"`key`.\n"
"\n"
"The returned value is a tuple with the \"get\" value returned by `fun` and "
"a\n"
"new map with the updated value under `key`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.get_and_update!(%{a: 1}, :a, fn(current_value) ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    {1, %{a: \"new value!\"}}\n"
"\n"
"    iex> Map.get_and_update!(%{a: 1}, :b, fn current_value ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    ** (KeyError) key :b not found\n"
"\n"
msgstr ""
"`key`から値を取得し、更新します。`key`がなければ例外を上げます。\n"
"\n"
"この`fun`引数は、`key`の値(あるいは`key`が存在しない場合は`nil`)を\n"
"受取り、2要素のタプルを返さなくてはなりません: (取り出した値はリ\n"
"ターンする前に操作されるかもしれません)\"get\" した値と、\n"
"`key`にストアされる新しい値です。\n"
"\n"
"戻値は、`fun`により返された\"get\"した値と`key`の値が更新された\n"
"新しいマップです。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.get_and_update!(%{a: 1}, :a, fn(current_value) ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    {1, %{a: \"new value!\"}}\n"
"\n"
"    iex> Map.get_and_update!(%{a: 1}, :b, fn current_value ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    ** (KeyError) key :b not found\n"
"\n"

#. TRANSLATORS: def Map.get(map, key, default \\ nil)
#: lib/map.ex:222
msgid ""
"Gets the value for a specific `key`.\n"
"\n"
"If `key` does not exist, return the default value\n"
"(`nil` if no default value).\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.get(%{}, :a)\n"
"    nil\n"
"    iex> Map.get(%{a: 1}, :a)\n"
"    1\n"
"    iex> Map.get(%{a: 1}, :b)\n"
"    nil\n"
"    iex> Map.get(%{a: 1}, :b, 3)\n"
"    3\n"
"\n"
msgstr ""
"指定された`key`の値を取得します。\n"
"\n"
"`key`が存在しないなら、デフォルト値\n"
"(デフォルト値が無いなら`nil`)を返します\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.get(%{}, :a)\n"
"    nil\n"
"    iex> Map.get(%{a: 1}, :a)\n"
"    1\n"
"    iex> Map.get(%{a: 1}, :b)\n"
"    nil\n"
"    iex> Map.get(%{a: 1}, :b, 3)\n"
"    3\n"
"\n"

#~ msgid "Updates the value in the map with the given function.\n"
#~ msgstr "mapの値を与えられた関数で更新します。\n"

#~ msgid "Returns a new empty map.\n"
#~ msgstr "新しい空のマップを返します。\n"

#~ msgid ""
#~ "Gets a value and updates a map only if the key exists in one operation.\n"
#~ msgstr ""
#~ "一度のオペレーションで存在するkeyの値の取得と\n"
#~ "更新を行います。\n"

#~ msgid "Gets a value and updates a map in one operation.\n"
#~ msgstr "一度のオペレーションで値の取得と更新を行います。\n"
