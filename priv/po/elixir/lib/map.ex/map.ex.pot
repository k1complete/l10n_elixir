#. TRANSLATORS: def Map.split(map, keys)
#: lib/map.ex:431 
msgid ""
"Takes all entries corresponding to the given keys and extracts them into a\n"
"separate map.\n"
"\n"
"Returns a tuple with the new map and the old map with removed keys.\n"
"\n"
"Keys for which there are no entries in the map are ignored.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.split(%{a: 1, b: 2, c: 3}, [:a, :c, :e])\n"
"    {%{a: 1, c: 3}, %{b: 2}}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.fetch(map, key)
#: lib/map.ex:117 
msgid ""
"Fetches the value for a specific `key` and returns it in a tuple.\n"
"\n"
"If the `key` does not exist, returns `:error`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.fetch(%{a: 1}, :a)\n"
"    {:ok, 1}\n"
"    iex> Map.fetch(%{a: 1}, :b)\n"
"    :error\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.merge(map1, map2, callback)
#: lib/map.ex:325 
msgid ""
"Merges two maps into one.\n"
"\n"
"All keys in `map2` will be added to `map1`. The given function will\n"
"be invoked with the key, value1 and value2 to solve conflicts.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.merge(%{a: 1, b: 2}, %{a: 3, d: 4}, fn _k, v1, v2 ->\n"
"    ...>   v1 + v2\n"
"    ...> end)\n"
"    %{a: 4, b: 2, d: 4}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.update!(map, key, fun)
#: lib/map.ex:457 
msgid ""
"Updates the `key` with the given function.\n"
"\n"
"If the `key` does not exist, raises `KeyError`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.update!(%{a: 1}, :a, &(&1 * 2))\n"
"    %{a: 2}\n"
"\n"
"    iex> Map.update!(%{a: 1}, :b, &(&1 * 2))\n"
"    ** (KeyError) key :b not found\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.fetch!(map, key)
#: lib/map.ex:133 
msgid ""
"Fetches the value for specific `key`.\n"
"\n"
"If `key` does not exist, a `KeyError` is raised.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.fetch!(%{a: 1}, :a)\n"
"    1\n"
"    iex> Map.fetch!(%{a: 1}, :b)\n"
"    ** (KeyError) key :b not found in: %{a: 1}\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.Map Summary
#: lib/map.ex:2 
msgid ""
"A set of functions for working with maps.\n"
"\n"
"Maps are key-value stores where keys can be any value and\n"
"are compared using the match operator (`===`). Maps can be\n"
"created with the `%{}` special form defined in the\n"
"`Kernel.SpecialForms` module.\n"
msgstr ""
#. TRANSLATORS: def Map.to_list(map)
#: lib/map.ex:39 
msgid ""
"Converts the map to a list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.to_list(%{a: 1})\n"
"    [a: 1]\n"
"    iex> Map.to_list(%{1 => 2})\n"
"    [{1, 2}]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.new(enumerable, transform)
#: lib/map.ex:83 
msgid ""
"Creates a map from an enumerable via the transformation function.\n"
"\n"
"Duplicated entries are removed; the latest one prevails.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.new([:a, :b], fn x -> {x, x} end)\n"
"    %{a: :a, b: :b}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.new()
#: lib/map.ex:53 
msgid ""
"Returns a new empty map.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.new\n"
"    %{}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.put_new_lazy(map, key, fun)
#: lib/map.ex:174 
msgid ""
"Evaluates `fun` and puts the result under `key`\n"
"in map unless `key` is already present.\n"
"\n"
"This is useful if the value is very expensive to calculate or\n"
"generally difficult to setup and teardown again.\n"
"\n"
"## Examples\n"
"\n"
"    iex> map = %{a: 1}\n"
"    iex> fun = fn ->\n"
"    ...>   # some expensive operation here\n"
"    ...>   3\n"
"    ...> end\n"
"    iex> Map.put_new_lazy(map, :a, fun)\n"
"    %{a: 1}\n"
"    iex> Map.put_new_lazy(map, :b, fun)\n"
"    %{a: 1, b: 3}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.update(map, key, initial, fun)
#: lib/map.ex:346 
msgid ""
"Updates the `key` in `map` with the given function.\n"
"\n"
"If the `key` does not exist, inserts the given `initial` value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.update(%{a: 1}, :a, 13, &(&1 * 2))\n"
"    %{a: 2}\n"
"    iex> Map.update(%{a: 1}, :b, 11, &(&1 * 2))\n"
"    %{a: 1, b: 11}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.pop(map, key, default \\ nil)
#: lib/map.ex:369 
msgid ""
"Returns and removes all values associated with `key` in the `map`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.pop(%{a: 1}, :a)\n"
"    {1, %{}}\n"
"    iex> Map.pop(%{a: 1}, :b)\n"
"    {nil, %{a: 1}}\n"
"    iex> Map.pop(%{a: 1}, :b, 3)\n"
"    {3, %{a: 1}}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.pop_lazy(map, key, fun)
#: lib/map.ex:390 
msgid ""
"Lazily returns and removes all values associated with `key` in the `map`.\n"
"\n"
"This is useful if the default value is very expensive to calculate or\n"
"generally difficult to setup and teardown again.\n"
"\n"
"## Examples\n"
"\n"
"    iex> map = %{a: 1}\n"
"    iex> fun = fn ->\n"
"    ...>   # some expensive operation here\n"
"    ...>   13\n"
"    ...> end\n"
"    iex> Map.pop_lazy(map, :a, fun)\n"
"    {1, %{}}\n"
"    iex> Map.pop_lazy(map, :b, fun)\n"
"    {13, %{a: 1}}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.values(map)
#: lib/map.ex:27 
msgid ""
"Returns all values from the map.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.values(%{a: 1, b: 2})\n"
"    [1, 2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.equal?(map1, map2)
#: lib/map.ex:596 
msgid ""
"Checks if two maps are equal.\n"
"\n"
"Two maps are considered to be equal if they contain\n"
"the same keys and those keys contain the same values.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.equal?(%{a: 1, b: 2}, %{b: 2, a: 1})\n"
"    true\n"
"    iex> Map.equal?(%{a: 1, b: 2}, %{b: 1, a: 2})\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.put(map, key, val)
#: lib/map.ex:279 
msgid ""
"Puts the given `value` under `key`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.put(%{a: 1}, :b, 2)\n"
"    %{a: 1, b: 2}\n"
"    iex> Map.put(%{a: 1, b: 2}, :a, 3)\n"
"    %{a: 3, b: 2}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.take(map, keys)
#: lib/map.ex:202 
msgid ""
"Takes all entries corresponding to the given keys and\n"
"returns them in a new map.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.take(%{a: 1, b: 2, c: 3}, [:a, :c, :e])\n"
"    %{a: 1, c: 3}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.get_and_update(map, key, fun)
#: lib/map.ex:483 
msgid ""
"Gets the value from `key` and updates it, all in one pass.\n"
"\n"
"This `fun` argument receives the value of `key` (or `nil` if `key`\n"
"is not present) and must return a two-elements tuple: the \"get\" value (the\n"
"retrieved value, which can be operated on before being returned) and the new\n"
"value to be stored under `key`.\n"
"\n"
"The returned value may be a tuple with the \"get\" value returned by\n"
"`fun` and a new map with the updated value under `key`. The function\n"
"may also return `:pop`, implying the current value shall be removed\n"
"from the map and returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.get_and_update(%{a: 1}, :a, fn current_value ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    {1, %{a: \"new value!\"}}\n"
"\n"
"    iex> Map.get_and_update(%{a: 1}, :b, fn current_value ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    {nil, %{b: \"new value!\", a: 1}}\n"
"\n"
"    iex> Map.get_and_update(%{a: 1}, :a, fn _ -> :pop end)\n"
"    {1, %{}}\n"
"\n"
"    iex> Map.get_and_update(%{a: 1}, :b, fn _ -> :pop end)\n"
"    {nil, %{a: 1}}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.get_lazy(map, key, fun)
#: lib/map.ex:250 
msgid ""
"Gets the value for a specific `key`.\n"
"\n"
"If `key` does not exist, lazily evaluates `fun` and returns its result.\n"
"\n"
"This is useful if the default value is very expensive to calculate or\n"
"generally difficult to setup and teardown again.\n"
"\n"
"## Examples\n"
"\n"
"    iex> map = %{a: 1}\n"
"    iex> fun = fn ->\n"
"    ...>   # some expensive operation here\n"
"    ...>   13\n"
"    ...> end\n"
"    iex> Map.get_lazy(map, :a, fun)\n"
"    1\n"
"    iex> Map.get_lazy(map, :b, fun)\n"
"    13\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.new(enumerable)
#: lib/map.ex:65 
msgid ""
"Creates a map from an enumerable.\n"
"\n"
"Duplicated keys are removed; the latest one prevails.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.new([{:b, 1}, {:a, 2}])\n"
"    %{a: 2, b: 1}\n"
"    iex> Map.new([a: 1, a: 2, a: 3])\n"
"    %{a: 3}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.put_new(map, key, value)
#: lib/map.ex:154 
msgid ""
"Puts the given `value` under `key` unless the entry `key`\n"
"already exists.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.put_new(%{a: 1}, :b, 2)\n"
"    %{b: 2, a: 1}\n"
"    iex> Map.put_new(%{a: 1, b: 2}, :a, 3)\n"
"    %{a: 1, b: 2}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.delete(map, key)
#: lib/map.ex:295 
msgid ""
"Deletes the entries in the map for a specific `key`.\n"
"\n"
"If the `key` does not exist, returns the map unchanged.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.delete(%{a: 1, b: 2}, :a)\n"
"    %{b: 2}\n"
"    iex> Map.delete(%{b: 2}, :a)\n"
"    %{b: 2}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.keys(map)
#: lib/map.ex:15 
msgid ""
"Returns all keys from the map.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.keys(%{a: 1, b: 2})\n"
"    [:a, :b]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.from_struct(struct)
#: lib/map.ex:568 
msgid ""
"Converts a struct to map.\n"
"\n"
"It accepts the struct module or a struct itself and\n"
"simply removes the `__struct__` field from the struct.\n"
"\n"
"## Example\n"
"\n"
"    defmodule User do\n"
"      defstruct [:name]\n"
"    end\n"
"\n"
"    Map.from_struct(User)\n"
"    #=> %{name: nil}\n"
"\n"
"    Map.from_struct(%User{name: \"john\"})\n"
"    #=> %{name: \"john\"}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.merge(map1, map2)
#: lib/map.ex:311 
msgid ""
"Merges two maps into one.\n"
"\n"
"All keys in `map2` will be added to `map1`, overriding any existing one.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.merge(%{a: 1, b: 2}, %{a: 3, d: 4})\n"
"    %{a: 3, b: 2, d: 4}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.drop(map, keys)
#: lib/map.ex:417 
msgid ""
"Drops the given keys from the map.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.drop(%{a: 1, b: 2, c: 3}, [:b, :d])\n"
"    %{a: 1, c: 3}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.has_key?(map, key)
#: lib/map.ex:103 
msgid ""
"Returns whether a given `key` exists in the given `map`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.has_key?(%{a: 1}, :a)\n"
"    true\n"
"    iex> Map.has_key?(%{a: 1}, :b)\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.get_and_update!(map, key, fun)
#: lib/map.ex:531 
msgid ""
"Gets the value from `key` and updates it. Raises if there is no `key`.\n"
"\n"
"This `fun` argument receives the value of `key` and must return a\n"
"two-elements tuple: the \"get\" value (the retrieved value, which can be\n"
"operated on before being returned) and the new value to be stored under\n"
"`key`.\n"
"\n"
"The returned value is a tuple with the \"get\" value returned by `fun` and a\n"
"new map with the updated value under `key`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.get_and_update!(%{a: 1}, :a, fn(current_value) ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    {1, %{a: \"new value!\"}}\n"
"\n"
"    iex> Map.get_and_update!(%{a: 1}, :b, fn current_value ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    ** (KeyError) key :b not found\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.get(map, key, default \\ nil)
#: lib/map.ex:223 
msgid ""
"Gets the value for a specific `key`.\n"
"\n"
"If `key` does not exist, return the default value\n"
"(`nil` if no default value).\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.get(%{}, :a)\n"
"    nil\n"
"    iex> Map.get(%{a: 1}, :a)\n"
"    1\n"
"    iex> Map.get(%{a: 1}, :b)\n"
"    nil\n"
"    iex> Map.get(%{a: 1}, :b, 3)\n"
"    3\n"
"\n"
msgstr ""
