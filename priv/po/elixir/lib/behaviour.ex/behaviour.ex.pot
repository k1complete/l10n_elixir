#. TRANSLATORS: Elixir.Behaviour Summary
#: lib/behaviour.ex:1 
msgid ""
"Utilities for defining behaviour interfaces.\n"
"\n"
"Behaviours can be referenced by other modules\n"
"to ensure they implement required callbacks.\n"
"\n"
"For example, you can specify the `URI.Parser`\n"
"behaviour as follows:\n"
"\n"
"    defmodule URI.Parser do\n"
"      use Behaviour\n"
"\n"
"      @doc \"Parses the given URL\"\n"
"      defcallback parse(uri_info :: URI.t) :: URI.t\n"
"\n"
"      @doc \"Defines a default port\"\n"
"      defcallback default_port() :: integer\n"
"    end\n"
"\n"
"And then a module may use it as:\n"
"\n"
"    defmodule URI.HTTP do\n"
"      @behaviour URI.Parser\n"
"      def default_port(), do: 80\n"
"      def parse(info), do: info\n"
"    end\n"
"\n"
"If the behaviour changes or `URI.HTTP` does\n"
"not implement one of the callbacks, a warning\n"
"will be raised.\n"
"\n"
"## Implementation\n"
"\n"
"Since Erlang R15, behaviours must be defined via\n"
"`@callback` attributes. `defcallback` is a simple\n"
"mechanism that defines the `@callback` attribute\n"
"according to the given type specification. `defcallback` allows\n"
"documentation to be created for the callback and defines\n"
"a custom function signature.\n"
"\n"
"The callbacks and their documentation can be retrieved\n"
"via the `__behaviour__` callback function.\n"
msgstr ""
#. TRANSLATORS: defmacro Behaviour.defmacrocallback(spec)
#: lib/behaviour.ex:56 
msgid ""
"Defines a macro callback according to the given type specification.\n"
msgstr ""
#. TRANSLATORS: defmacro Behaviour.defcallback(spec)
#: lib/behaviour.ex:49 
msgid ""
"Defines a function callback according to the given type specification.\n"
msgstr ""
