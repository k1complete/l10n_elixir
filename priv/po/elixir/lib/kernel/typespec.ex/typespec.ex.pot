#. TRANSLATORS: def Kernel.Typespec.beam_types(module)
#: lib/kernel/typespec.ex:385 
msgid ""
"Returns all types available from the module's beam code.\n"
"\n"
"The result is returned as a list of tuples where the first\n"
"element is the type (`:typep`, `:type` and `:opaque`).\n"
"\n"
"The module must have a corresponding beam file which can be\n"
"located by the runtime system.\n"
msgstr ""
#. TRANSLATORS: def Kernel.Typespec.beam_specs(module)
#: lib/kernel/typespec.ex:413 
msgid ""
"Returns all specs available from the module's beam code.\n"
"\n"
"The result is returned as a list of tuples where the first\n"
"element is spec name and arity and the second is the spec.\n"
"\n"
"The module must have a corresponding beam file which can be\n"
"located by the runtime system.\n"
msgstr ""
#. TRANSLATORS: def Kernel.Typespec.beam_callbacks(module)
#: lib/kernel/typespec.ex:427 
msgid ""
"Returns all callbacks available from the module's beam code.\n"
"\n"
"The result is returned as a list of tuples where the first\n"
"element is spec name and arity and the second is the spec.\n"
"\n"
"The module must have a corresponding beam file\n"
"which can be located by the runtime system.\n"
msgstr ""
#. TRANSLATORS: def Kernel.Typespec.defines_type?(module, name, arity)
#: lib/kernel/typespec.ex:277 
msgid ""
"Returns `true` if the current module defines a given type\n"
"(private, opaque or not). This function is only available\n"
"for modules being compiled.\n"
msgstr ""
#. TRANSLATORS: def Kernel.Typespec.defines_spec?(module, name, arity)
#: lib/kernel/typespec.ex:290 
msgid ""
"Returns `true` if the current module defines a given spec.\n"
"This function is only available for modules being compiled.\n"
msgstr ""
#. TRANSLATORS: def Kernel.Typespec.defines_callback?(module, name, arity)
#: lib/kernel/typespec.ex:301 
msgid ""
"Returns `true` if the current module defines a callback.\n"
"This function is only available for modules being compiled.\n"
msgstr ""
#. TRANSLATORS: Elixir.Kernel.Typespec Summary
#: lib/kernel/typespec.ex:2 
msgid ""
"Provides macros and functions for working with typespecs.\n"
"\n"
"Elixir comes with a notation for declaring types and specifications. Elixir is\n"
"dynamically typed, as such typespecs are never used by the compiler to\n"
"optimize or modify code. Still, using typespecs is useful as documentation and\n"
"tools such as [Dialyzer](http://www.erlang.org/doc/man/dialyzer.html) can\n"
"analyze the code with typespecs to find bugs.\n"
"\n"
"The attributes `@type`, `@opaque`, `@typep`, `@spec`, `@callback` and\n"
"`@macrocallback` available in modules are handled by the equivalent macros\n"
"defined by this module. See sub-sections \"Defining a type\" and \"Defining a\n"
"specification\" below.\n"
"\n"
"## Types and their syntax\n"
"\n"
"The type syntax provided by Elixir is fairly similar to the one in\n"
"[Erlang](http://www.erlang.org/doc/reference_manual/typespec.html).\n"
"\n"
"Most of the built-in types provided in Erlang (for example, `pid()`) are\n"
"expressed the same way: `pid()` or simply `pid`. Parameterized types are also\n"
"supported (`list(integer)`) and so are remote types (`Enum.t`).\n"
"\n"
"Integers and atom literals are allowed as types (ex. `1`, `:atom` or\n"
"`false`). All other types are built of unions of predefined types. Certain\n"
"shorthands are allowed, such as `[...]`, `<<>>` and `{...}`.\n"
"\n"
"### Basic types\n"
"\n"
"    type :: any()                   # the top type, the set of all terms\n"
"          | none()                  # the bottom type, contains no terms\n"
"          | pid()\n"
"          | port()\n"
"          | reference()\n"
"          | tuple()\n"
"          | atom()\n"
"          | integer()\n"
"          | non_neg_integer()       # 0, 1, 2, 3, ...\n"
"          | pos_integer()           # 1, 2, 3, ...\n"
"          | neg_integer()           # ..., -3, -2, -1\n"
"          | float()\n"
"          | map()\n"
"          | struct()\n"
"          | list(type)\n"
"          | nonempty_list(type)\n"
"          | improper_list(type1, type2)\n"
"          | maybe_improper_list(type1, type2)\n"
"          | Literals                # Described in section \"Literals\"\n"
"          | Builtin                 # Described in section \"Builtin-types\"\n"
"          | Remotes                 # Described in section \"Remotes\"\n"
"\n"
"### Literals\n"
"\n"
"The following literals are also supported in typespecs:\n"
"\n"
"    type :: :atom                         ## Atoms\n"
"          | 1                             ## Integers\n"
"          | 1..10                         ## Integers from 1 to 10\n"
"          | 1.0                           ## Floats\n"
"\n"
"          | <<>>                          ## Bitstrings\n"
"          | <<_ :: size>>                 # size is 0 or a positive integer\n"
"          | <<_ :: _ * unit>>             # unit is an integer from 1 to 256\n"
"          | <<_ :: size * unit>>\n"
"\n"
"          | [type]                        ## Lists\n"
"          | []                            # empty list\n"
"          | [...]                         # shorthand for nonempty_list(any())\n"
"          | [type, ...]                   # shorthand for nonempty_list(type)\n"
"          | [key: type]                   # keyword lists\n"
"\n"
"          | (... -> type)                 ## Functions\n"
"          | (... -> type)                 # any arity, returns type\n"
"          | (() -> type)                  # 0-arity, returns type\n"
"          | (type1, type2 -> type)        # 2-arity, returns type\n"
"\n"
"          | %{}                           ## Maps\n"
"          | %{key: type}                  # map with key :key with value of type\n"
"          | %{type1 => type2}             # map with keys of type1 with values of type2\n"
"          | %SomeStruct{}\n"
"          | %SomeStruct{key: type}\n"
"\n"
"          | {}                            ## Tuples\n"
"          | {:ok, type}                   # two element tuple with an atom and any type\n"
"\n"
"### Built-in types\n"
"\n"
"Those types are also provided by Elixir as shortcuts on top of the\n"
"basic and literal types.\n"
"\n"
"Built-in type           | Defined as\n"
":---------------------- | :---------\n"
"`term()`                | `any()`\n"
"`binary()`              | `<< _ :: _ * 8 >>`\n"
"`bitstring()`           | `<< _ :: _ * 1 >>`\n"
"`boolean()`             | `false` \\| `true`\n"
"`byte()`                | `0..255`\n"
"`char()`                | `0..0x10ffff`\n"
"`number()`              | `integer()` \\| `float()`\n"
"`char_list()`           | `[char()]`\n"
"`list()`                | `[any()]`\n"
"`maybe_improper_list()` | `maybe_improper_list(any(), any())`\n"
"`nonempty_list()`       | `nonempty_list(any())`\n"
"`iodata()`              | `iolist()` \\| `binary()`\n"
"`iolist()`              | `maybe_improper_list(byte()` \\| `binary()` \\| `iolist(), binary()` \\| `[])`\n"
"`module()`              | `atom()` \\| `tuple()`\n"
"`arity()`               | `0..255`\n"
"`mfa()`                 | `{atom(), atom(), arity()}`\n"
"`node()`                | `atom()`\n"
"`timeout()`             | `:infinity` \\| `non_neg_integer()`\n"
"`no_return()`           | `none()`\n"
"`fun()`                 | `(... -> any)`\n"
"`struct()`              | `%{__struct__: atom()}`\n"
"\n"
"### Remote types\n"
"\n"
"Any module is also able to define their own type and the modules in\n"
"Elixir are no exception. For example, a string is `String.t`, a\n"
"range is `Range.t`, any enumerable can be `Enum.t` and so on.\n"
"\n"
"## Defining a type\n"
"\n"
"    @type type_name :: type\n"
"    @typep type_name :: type\n"
"    @opaque type_name :: type\n"
"\n"
"A type defined with `@typep` is private. An opaque type, defined with\n"
"`@opaque` is a type where the internal structure of the type will not be\n"
"visible, but the type is still public.\n"
"\n"
"Types can be parameterized by defining variables as parameters, these variables\n"
"can then be used to define the type.\n"
"\n"
"    @type dict(key, value) :: [{key, value}]\n"
"\n"
"## Defining a specification\n"
"\n"
"    @spec function_name(type1, type2) :: return_type\n"
"    @callback function_name(type1, type2) :: return_type\n"
"    @macrocallback macro_name(type1, type2) :: Macro.t\n"
"\n"
"Callbacks are used to define the callbacks functions of behaviours (see\n"
"`Behaviour`).\n"
"\n"
"Guards can be used to restrict type variables given as arguments to the\n"
"function.\n"
"\n"
"    @spec function(arg) :: [arg] when arg: atom\n"
"\n"
"Type variables with no restriction can also be defined.\n"
"\n"
"    @spec function(arg) :: [arg] when arg: var\n"
"\n"
"Specifications can be overloaded just like ordinary functions.\n"
"\n"
"    @spec function(integer) :: atom\n"
"    @spec function(atom)    :: integer\n"
"\n"
"## Notes\n"
"\n"
"Elixir discourages the use of type `string` as it might be confused with\n"
"binaries which are referred to as \"strings\" in Elixir (as opposed to character\n"
"lists). In order to use the type that is called `string` in Erlang, one has to\n"
"use the `char_list` type which is a synonym for `string`. If you use `string`,\n"
"you'll get a warning from the compiler.\n"
"\n"
"If you want to refer to the \"string\" type (the one operated on by functions in\n"
"the `String` module), use `String.t` type instead.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.Typespec.deftypep(type)
#: lib/kernel/typespec.ex:202 
msgid ""
"Defines a private type.\n"
"This macro is responsible for handling the attribute `@typep`.\n"
"\n"
"## Examples\n"
"\n"
"    @typep my_type :: atom\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.Typespec.defmacrocallback(spec)
#: lib/kernel/typespec.ex:248 
msgid ""
"Defines a macro callback.\n"
"This macro is responsible for handling the attribute `@macrocallback`.\n"
"\n"
"## Examples\n"
"\n"
"    @macrocallback add(number, number) :: Macro.t\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.Typespec.defcallback(spec)
#: lib/kernel/typespec.ex:232 
msgid ""
"Defines a callback.\n"
"This macro is responsible for handling the attribute `@callback`.\n"
"\n"
"## Examples\n"
"\n"
"    @callback add(number, number) :: number\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.Typespec.define_type(kind, expr, doc \\ nil, env)
#: lib/kernel/typespec.ex:263 
msgid ""
"Defines a `type`, `typep` or `opaque` by receiving a typespec expression.\n"
msgstr ""
#. TRANSLATORS: def Kernel.Typespec.define_spec(kind, expr, env)
#: lib/kernel/typespec.ex:270 
msgid ""
"Defines a `spec` by receiving a typespec expression.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.Typespec.defopaque(type)
#: lib/kernel/typespec.ex:187 
msgid ""
"Defines an opaque type.\n"
"This macro is responsible for handling the attribute `@opaque`.\n"
"\n"
"## Examples\n"
"\n"
"    @opaque my_type :: atom\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.Typespec.deftype(type)
#: lib/kernel/typespec.ex:172 
msgid ""
"Defines a type.\n"
"This macro is responsible for handling the attribute `@type`.\n"
"\n"
"## Examples\n"
"\n"
"    @type my_type :: atom\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.Typespec.defspec(spec)
#: lib/kernel/typespec.ex:217 
msgid ""
"Defines a spec.\n"
"This macro is responsible for handling the attribute `@spec`.\n"
"\n"
"## Examples\n"
"\n"
"    @spec add(number, number) :: number\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.Typespec.spec_to_ast(name, spec)
#: lib/kernel/typespec.ex:312 
msgid ""
"Converts a spec clause back to Elixir AST.\n"
msgstr ""
#. TRANSLATORS: def Kernel.Typespec.type_to_ast(type)
#: lib/kernel/typespec.ex:360 
msgid ""
"Converts a type clause back to Elixir AST.\n"
msgstr ""
