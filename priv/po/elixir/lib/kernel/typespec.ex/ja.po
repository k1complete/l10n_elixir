msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2015-12-14 21:31+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: def Kernel.Typespec.beam_types(module)
#: lib/kernel/typespec.ex:217
msgid ""
"Returns all types available from the module's beam code.\n"
"\n"
"The result is returned as a list of tuples where the first\n"
"element is the type (`:typep`, `:type` and `:opaque`).\n"
"\n"
"The module must have a corresponding beam file which can be\n"
"located by the runtime system.\n"
msgstr ""
"モジュールのbeamコードから全ての有効なタイプを返します。\n"
"\n"
"返された結果は、最初の要素がタイプ(`:typep`, `:type`, `:opaque`)となる\n"
"タプルのリストです。\n"
"\n"
"モジュールは実行時システムによって配置された対応するbeamファイルを\n"
"持っていなければなりません。\n"

#. TRANSLATORS: def Kernel.Typespec.spec_to_ast(name, spec)
#: lib/kernel/typespec.ex:144
msgid "Converts a spec clause back to Elixir AST.\n"
msgstr "spec節をElixir ASTへコンバートします。\n"

#. TRANSLATORS: def Kernel.Typespec.defines_spec?(module, name, arity)
#: lib/kernel/typespec.ex:122
msgid ""
"Returns `true` if the current module defines a given spec.\n"
"This function is only available for modules being compiled.\n"
msgstr ""
"現在のモジュールが所定のspecを定義していれば、`true`を返します。\n"
"この関数はコンパイルしているモジュールにのみ有効です。\n"

#. TRANSLATORS: def Kernel.Typespec.define_spec(kind, expr, env)
#: lib/kernel/typespec.ex:102
msgid "Defines a `spec` by receiving a typespec expression.\n"
msgstr "typespec式を受け取り、`spec`を定義します。\n"

#. TRANSLATORS: defmacro Kernel.Typespec.defspec(spec)
#: lib/kernel/typespec.ex:49
msgid ""
"Defines a spec.\n"
"This macro is responsible for handling the attribute `@spec`.\n"
"\n"
"## Examples\n"
"\n"
"    @spec add(number, number) :: number\n"
"\n"
msgstr ""
"specを定義します。\n"
"このマクロは属性`@spec`をハンドルする役割りを果します。\n"
"\n"
"## 例\n"
"\n"
"    @spec add(number, number) :: number\n"
"\n"

#. TRANSLATORS: defmacro Kernel.Typespec.deftypep(type)
#: lib/kernel/typespec.ex:34
msgid ""
"Defines a private type.\n"
"This macro is responsible for handling the attribute `@typep`.\n"
"\n"
"## Examples\n"
"\n"
"    @typep my_type :: atom\n"
"\n"
msgstr ""
"プライベートタイプを定義します。\n"
"このマクロは属性`@typep`をハンドルする役割りを果します。\n"
"\n"
"## 例\n"
"\n"
"    @typep my_type :: atom\n"
"\n"

#. TRANSLATORS: defmacro Kernel.Typespec.defmacrocallback(spec)
#: lib/kernel/typespec.ex:80
msgid ""
"Defines a macro callback.\n"
"This macro is responsible for handling the attribute `@macrocallback`.\n"
"\n"
"## Examples\n"
"\n"
"    @macrocallback add(number, number) :: Macro.t\n"
"\n"
msgstr ""
"マクロコールバックを定義します。\n"
"このマクロは`@macrocallback`属性をハンドルする役割りを果します。\n"
"\n"
"## 例\n"
"\n"
"    @macrocallback add(number, number) :: Macro.t\n"
"\n"

#. TRANSLATORS: def Kernel.Typespec.defines_callback?(module, name, arity)
#: lib/kernel/typespec.ex:133
msgid ""
"Returns `true` if the current module defines a callback.\n"
"This function is only available for modules being compiled.\n"
msgstr ""
"現在のモジュールがコールバックを定義していれば、`true`を返します。\n"
"この関数はコンパイルしているモジュールにのみ有効です。\n"

#. TRANSLATORS: def Kernel.Typespec.type_to_ast(type)
#: lib/kernel/typespec.ex:192
msgid "Converts a type clause back to Elixir AST.\n"
msgstr "タイプ節をElixir ASTへ変換します。\n"

#. TRANSLATORS: def Kernel.Typespec.beam_callbacks(module)
#: lib/kernel/typespec.ex:259
msgid ""
"Returns all callbacks available from the module's beam code.\n"
"\n"
"The result is returned as a list of tuples where the first\n"
"element is spec name and arity and the second is the spec.\n"
"\n"
"The module must have a corresponding beam file\n"
"which can be located by the runtime system.\n"
msgstr ""
"モジュールのbeamコードから全ての有効なコールバックを返します。\n"
"\n"
"返された結果は最初の要素がspec nameとarityで次の要素がspecとなるタプ\n"
"ルのリストです。\n"
"\n"
"モジュールは実行時システムによって配置された対応するbeamファイルを\n"
"持っていなければなりません。\n"

#. TRANSLATORS: def Kernel.Typespec.define_type(kind, expr, doc \\ nil, env)
#: lib/kernel/typespec.ex:95
msgid ""
"Defines a `type`, `typep` or `opaque` by receiving a typespec expression.\n"
msgstr "typespec式を受け取り、`type`、 `typep`または`opaque`を定義します。\n"

#. TRANSLATORS: def Kernel.Typespec.beam_specs(module)
#: lib/kernel/typespec.ex:245
msgid ""
"Returns all specs available from the module's beam code.\n"
"\n"
"The result is returned as a list of tuples where the first\n"
"element is spec name and arity and the second is the spec.\n"
"\n"
"The module must have a corresponding beam file which can be\n"
"located by the runtime system.\n"
msgstr ""
"モジュールのbeamコードから全ての有効なspecを返します。\n"
"\n"
"返された結果は、最初の要素がspecの名前とアリティで次の要素がspec\n"
"となる、タプルのリストです。\n"
"\n"
"モジュールは実行時システムによって配置された対応するbeamファイルを\n"
"持っていなければなりません。\n"

#. TRANSLATORS: defmacro Kernel.Typespec.defcallback(spec)
#: lib/kernel/typespec.ex:64
msgid ""
"Defines a callback.\n"
"This macro is responsible for handling the attribute `@callback`.\n"
"\n"
"## Examples\n"
"\n"
"    @callback add(number, number) :: number\n"
"\n"
msgstr ""
"コールバックを定義します。\n"
"このマクロは`@callback`属性をハンドルする役割りを果します。\n"
"\n"
"## 例\n"
"\n"
"    @callback add(number, number) :: number\n"
"\n"

#. TRANSLATORS: defmacro Kernel.Typespec.defopaque(type)
#: lib/kernel/typespec.ex:19
msgid ""
"Defines an opaque type.\n"
"This macro is responsible for handling the attribute `@opaque`.\n"
"\n"
"## Examples\n"
"\n"
"    @opaque my_type :: atom\n"
"\n"
msgstr ""
"不透明(opaque)なタイプを定義します。\n"
"このマクロは`@opaque`属性をハンドルする役割りを果します。\n"
"\n"
"## 例\n"
"\n"
"    @opaque my_type :: atom\n"
"\n"

#. TRANSLATORS: def Kernel.Typespec.defines_type?(module, name, arity)
#: lib/kernel/typespec.ex:109
msgid ""
"Returns `true` if the current module defines a given type\n"
"(private, opaque or not). This function is only available\n"
"for modules being compiled.\n"
msgstr ""
"現在のモジュールが所定のタイプ(private, opaqueかどうか)\n"
"を定義していれば、`true`を返します。\n"
"この関数はコンパイルしているモジュールにのみ有効です。\n"

#. TRANSLATORS: defmacro Kernel.Typespec.deftype(type)
#: lib/kernel/typespec.ex:4
msgid ""
"Defines a type.\n"
"This macro is responsible for handling the attribute `@type`.\n"
"\n"
"## Examples\n"
"\n"
"    @type my_type :: atom\n"
"\n"
msgstr ""
"タイプを定義します。\n"
"このマクロは属性`@type`をハンドルする役割りを果します。\n"
"\n"
"## 例\n"
"\n"
"    @type my_type :: atom\n"
"\n"

#~ msgid ""
#~ "Provides macros and functions for working with typespecs.\n"
#~ "\n"
#~ "Elixir comes with a notation for declaring types and specifications. "
#~ "Elixir is\n"
#~ "dynamically typed, and as such, typespecs are never used by the compiler "
#~ "to\n"
#~ "optimize or modify code. Still, using typespecs is useful as "
#~ "documentation and\n"
#~ "tools such as [Dialyzer](http://www.erlang.org/doc/man/dialyzer.html) "
#~ "can\n"
#~ "analyze code with typespecs to find bugs.\n"
#~ "\n"
#~ "The attributes `@type`, `@opaque`, `@typep`, `@spec`, `@callback` and\n"
#~ "`@macrocallback` available in modules are handled by the equivalent "
#~ "macros\n"
#~ "defined by this module. See sub-sections \"Defining a type\" and "
#~ "\"Defining a\n"
#~ "specification\" below.\n"
#~ "\n"
#~ "## Types and their syntax\n"
#~ "\n"
#~ "The type syntax provided by Elixir is fairly similar to [the one in\n"
#~ "Erlang](http://www.erlang.org/doc/reference_manual/typespec.html).\n"
#~ "\n"
#~ "Most of the built-in types provided in Erlang (for example, `pid()`) are\n"
#~ "expressed the same way: `pid()` or simply `pid`. Parameterized types are "
#~ "also\n"
#~ "supported (`list(integer)`) and so are remote types (`Enum.t`).\n"
#~ "\n"
#~ "Integers and atom literals are allowed as types (ex. `1`, `:atom` or\n"
#~ "`false`). All other types are built of unions of predefined types. "
#~ "Certain\n"
#~ "shorthands are allowed, such as `[...]`, `<<>>` and `{...}`.\n"
#~ "\n"
#~ "### Basic types\n"
#~ "\n"
#~ "    type :: any()                   # the top type, the set of all terms\n"
#~ "          | none()                  # the bottom type, contains no terms\n"
#~ "          | pid()\n"
#~ "          | port()\n"
#~ "          | reference()\n"
#~ "          | tuple()\n"
#~ "          | atom()\n"
#~ "          | integer()\n"
#~ "          | non_neg_integer()       # 0, 1, 2, 3, ...\n"
#~ "          | pos_integer()           # 1, 2, 3, ...\n"
#~ "          | neg_integer()           # ..., -3, -2, -1\n"
#~ "          | float()\n"
#~ "          | map()\n"
#~ "          | struct()\n"
#~ "          | list(type)\n"
#~ "          | nonempty_list(type)\n"
#~ "          | improper_list(type1, type2)\n"
#~ "          | maybe_improper_list(type1, type2)\n"
#~ "          | Literals                # Described in section \"Literals\"\n"
#~ "          | Builtin                 # Described in section \"Builtin-types"
#~ "\"\n"
#~ "          | Remotes                 # Described in section \"Remotes\"\n"
#~ "\n"
#~ "### Literals\n"
#~ "\n"
#~ "The following literals are also supported in typespecs:\n"
#~ "\n"
#~ "    type :: :atom                         ## Atoms\n"
#~ "          | 1                             ## Integers\n"
#~ "          | 1..10                         ## Integers from 1 to 10\n"
#~ "          | 1.0                           ## Floats\n"
#~ "\n"
#~ "          | <<>>                          ## Bitstrings\n"
#~ "          | <<_::size>>                 # size is 0 or a positive "
#~ "integer\n"
#~ "          | <<_::_ * unit>>             # unit is an integer from 1 to "
#~ "256\n"
#~ "          | <<_::size * unit>>\n"
#~ "\n"
#~ "          | [type]                        ## Lists\n"
#~ "          | []                            # empty list\n"
#~ "          | [...]                         # shorthand for "
#~ "nonempty_list(any())\n"
#~ "          | [type, ...]                   # shorthand for "
#~ "nonempty_list(type)\n"
#~ "          | [key: type]                   # keyword lists\n"
#~ "\n"
#~ "          | (... -> type)                 ## Functions\n"
#~ "          | (... -> type)                 # any arity, returns type\n"
#~ "          | (() -> type)                  # 0-arity, returns type\n"
#~ "          | (type1, type2 -> type)        # 2-arity, returns type\n"
#~ "\n"
#~ "          | %{}                           ## Maps\n"
#~ "          | %{key: type}                  # map with key :key with value "
#~ "of type\n"
#~ "          | %{type1 => type2}             # map with keys of type1 with "
#~ "values of type2\n"
#~ "          | %SomeStruct{}\n"
#~ "          | %SomeStruct{key: type}\n"
#~ "\n"
#~ "          | {}                            ## Tuples\n"
#~ "          | {:ok, type}                   # two element tuple with an "
#~ "atom and any type\n"
#~ "\n"
#~ "### Built-in types\n"
#~ "\n"
#~ "These types are also provided by Elixir as shortcuts on top of the\n"
#~ "basic and literal types.\n"
#~ "\n"
#~ "Built-in type           | Defined as\n"
#~ ":---------------------- | :---------\n"
#~ "`term()`                | `any()`\n"
#~ "`binary()`              | `<<_::_ * 8>>`\n"
#~ "`bitstring()`           | `<<_::_ * 1>>`\n"
#~ "`boolean()`             | `false` \\| `true`\n"
#~ "`byte()`                | `0..255`\n"
#~ "`char()`                | `0..0x10ffff`\n"
#~ "`number()`              | `integer()` \\| `float()`\n"
#~ "`char_list()`           | `[char()]`\n"
#~ "`list()`                | `[any()]`\n"
#~ "`maybe_improper_list()` | `maybe_improper_list(any(), any())`\n"
#~ "`nonempty_list()`       | `nonempty_list(any())`\n"
#~ "`iodata()`              | `iolist()` \\| `binary()`\n"
#~ "`iolist()`              | `maybe_improper_list(byte()` \\| `binary()` \\| "
#~ "`iolist(), binary()` \\| `[])`\n"
#~ "`module()`              | `atom()` \\| `tuple()`\n"
#~ "`arity()`               | `0..255`\n"
#~ "`mfa()`                 | `{atom(), atom(), arity()}`\n"
#~ "`node()`                | `atom()`\n"
#~ "`timeout()`             | `:infinity` \\| `non_neg_integer()`\n"
#~ "`no_return()`           | `none()`\n"
#~ "`fun()`                 | `(... -> any)`\n"
#~ "`struct()`              | `%{__struct__: atom()}`\n"
#~ "`as_boolean(t)`         | `t`\n"
#~ "\n"
#~ "### Remote types\n"
#~ "\n"
#~ "Any module is also able to define its own type and the modules in\n"
#~ "Elixir are no exception. For example, a string is `String.t`, a\n"
#~ "range is `Range.t`, any enumerable can be `Enum.t` and so on.\n"
#~ "\n"
#~ "## Defining a type\n"
#~ "\n"
#~ "    @type type_name :: type\n"
#~ "    @typep type_name :: type\n"
#~ "    @opaque type_name :: type\n"
#~ "\n"
#~ "A type defined with `@typep` is private. An opaque type, defined with\n"
#~ "`@opaque` is a type where the internal structure of the type will not be\n"
#~ "visible, but the type is still public.\n"
#~ "\n"
#~ "Types can be parameterized by defining variables as parameters, these "
#~ "variables\n"
#~ "can then be used to define the type.\n"
#~ "\n"
#~ "    @type dict(key, value) :: [{key, value}]\n"
#~ "\n"
#~ "## Defining a specification\n"
#~ "\n"
#~ "    @spec function_name(type1, type2) :: return_type\n"
#~ "    @callback function_name(type1, type2) :: return_type\n"
#~ "    @macrocallback macro_name(type1, type2) :: Macro.t\n"
#~ "\n"
#~ "Callbacks are used to define the callbacks functions of behaviours (see\n"
#~ "`Behaviour`).\n"
#~ "\n"
#~ "Guards can be used to restrict type variables given as arguments to the\n"
#~ "function.\n"
#~ "\n"
#~ "    @spec function(arg) :: [arg] when arg: atom\n"
#~ "\n"
#~ "Type variables with no restriction can also be defined.\n"
#~ "\n"
#~ "    @spec function(arg) :: [arg] when arg: var\n"
#~ "\n"
#~ "Specifications can be overloaded just like ordinary functions.\n"
#~ "\n"
#~ "    @spec function(integer) :: atom\n"
#~ "    @spec function(atom)    :: integer\n"
#~ "\n"
#~ "## Notes\n"
#~ "\n"
#~ "Elixir discourages the use of type `string` as it might be confused with\n"
#~ "binaries which are referred to as \"strings\" in Elixir (as opposed to "
#~ "character\n"
#~ "lists). In order to use the type that is called `string` in Erlang, one "
#~ "has to\n"
#~ "use the `char_list` type which is a synonym for `string`. If you use "
#~ "`string`,\n"
#~ "you'll get a warning from the compiler.\n"
#~ "\n"
#~ "If you want to refer to the \"string\" type (the one operated on by "
#~ "functions in\n"
#~ "the `String` module), use `String.t` type instead.\n"
#~ msgstr ""
#~ "typespecで働くマクロと関数を提供します。\n"
#~ "\n"
#~ "Elixirにはタイプと仕様を宣言するための記法があります。\n"
#~ "Elixirは動的な型付けされ、そして、typesepcは、最適化や\n"
#~ "コードの修正するためにコンパイラによって、決して使われません。\n"
#~ "しかし、typespecを使うことは、ドキュメントとツールとして便利です。\n"
#~ "[Dialyzer](http://www.erlang.org/doc/man/dialyzer.html)のようなツール"
#~ "は、\n"
#~ "コードをtypespecでバグを見付けるために、解析することができます。\n"
#~ "\n"
#~ "このモジュールにより定義された同等のマクロにより、\n"
#~ "モジュールで有効な属性`@type`、 `@opaque`、 `@typep`、 \n"
#~ "`@spec`、`@callback`と`@macrocallback`がハンドルされます。\n"
#~ "以下のサブセクション \"Defining a type\" と \"Defining a specification\" "
#~ "を\n"
#~ "参照してください。\n"
#~ "\n"
#~ "## Types and their syntax\n"
#~ "\n"
#~ "Elixirにより提供されたタイプ構文は、かなり\n"
#~ "[Erlangのそれら](http://www.erlang.org/doc/reference_manual/typespec."
#~ "html)\n"
#~ "に類似しています。\n"
#~ "\n"
#~ "Erlangで提供されるほとんどのビルトインタイプ(例えば、`pid()`)は、同じ方\n"
#~ "法で表現されます: `pid()`または、単に`pid`。パラメタ化されたタイプもま\n"
#~ "たサポートされ(`list(integer)`)、リモートタイプもサポートされます\n"
#~ "(`Enum.t`)。\n"
#~ "\n"
#~ "整数とアトムリテラルはタイプとして許されます(例, `1`、`:atom`または"
#~ "`false`)。\n"
#~ "他の全てのタイプは、あらかじめ定義されたタイプの結合から構築されます。\n"
#~ "`[...]`、`<<...>>`、`{...}`のような、特定の速記法が許されます。\n"
#~ "\n"
#~ "### Basic types\n"
#~ "\n"
#~ "    type :: any()                   # the top type, the set of all terms\n"
#~ "          | none()                  # the bottom type, contains no terms\n"
#~ "          | pid()\n"
#~ "          | port()\n"
#~ "          | reference()\n"
#~ "          | tuple()\n"
#~ "          | atom()\n"
#~ "          | integer()\n"
#~ "          | non_neg_integer()       # 0, 1, 2, 3, ...\n"
#~ "          | pos_integer()           # 1, 2, 3, ...\n"
#~ "          | neg_integer()           # ..., -3, -2, -1\n"
#~ "          | float()\n"
#~ "          | map()\n"
#~ "          | struct()\n"
#~ "          | list(type)\n"
#~ "          | nonempty_list(type)\n"
#~ "          | improper_list(type1, type2)\n"
#~ "          | maybe_improper_list(type1, type2)\n"
#~ "          | Literals                # Described in section \"Literals\"\n"
#~ "          | Builtin                 # Described in section \"Builtin-types"
#~ "\"\n"
#~ "          | Remotes                 # Described in section \"Remotes\"\n"
#~ "\n"
#~ "### Literals\n"
#~ "\n"
#~ "以下のリテラルがtypespecでサポートされています:\n"
#~ "\n"
#~ "    type :: :atom                         ## Atoms\n"
#~ "          | 1                             ## Integers\n"
#~ "          | 1..10                         ## Integers from 1 to 10\n"
#~ "          | 1.0                           ## Floats\n"
#~ "\n"
#~ "          | <<>>                          ## Bitstrings\n"
#~ "          | <<_::size>>                 # size is 0 or a positive "
#~ "integer\n"
#~ "          | <<_::_ * unit>>             # unit is an integer from 1 to "
#~ "256\n"
#~ "          | <<_::size * unit>>\n"
#~ "\n"
#~ "          | [type]                        ## Lists\n"
#~ "          | []                            # empty list\n"
#~ "          | [...]                         # shorthand for "
#~ "nonempty_list(any())\n"
#~ "          | [type, ...]                   # shorthand for "
#~ "nonempty_list(type)\n"
#~ "          | [key: type]                   # keyword lists\n"
#~ "\n"
#~ "          | (... -> type)                 ## Functions\n"
#~ "          | (... -> type)                 # any arity, returns type\n"
#~ "          | (() -> type)                  # 0-arity, returns type\n"
#~ "          | (type1, type2 -> type)        # 2-arity, returns type\n"
#~ "\n"
#~ "          | %{}                           ## Maps\n"
#~ "          | %{key: type}                  # map with key :key with value "
#~ "of type\n"
#~ "          | %{type1 => type2}             # map with keys of type1 with "
#~ "values of type2\n"
#~ "          | %SomeStruct{}\n"
#~ "          | %SomeStruct{key: type}\n"
#~ "\n"
#~ "          | {}                            ## Tuples\n"
#~ "          | {:ok, type}                   # two element tuple with an "
#~ "atom and any type\n"
#~ "\n"
#~ "### Built-in types\n"
#~ "\n"
#~ "着本的なタイプとリテラルの上に定義されたいくつかのタイプも\n"
#~ "ショートカットとしてElixirにより提供されています。\n"
#~ "\n"
#~ "Built-in type           | Defined as\n"
#~ ":---------------------- | :---------\n"
#~ "`term()`                | `any()`\n"
#~ "`binary()`              | `<< _::_ * 8 >>`\n"
#~ "`bitstring()`           | `<< _::_ * 1 >>`\n"
#~ "`boolean()`             | `false` \\| `true`\n"
#~ "`byte()`                | `0..255`\n"
#~ "`char()`                | `0..0x10ffff`\n"
#~ "`number()`              | `integer()` \\| `float()`\n"
#~ "`char_list()`           | `[char()]`\n"
#~ "`list()`                | `[any()]`\n"
#~ "`maybe_improper_list()` | `maybe_improper_list(any(), any())`\n"
#~ "`nonempty_list()`       | `nonempty_list(any())`\n"
#~ "`iodata()`              | `iolist()` \\| `binary()`\n"
#~ "`iolist()`              | `maybe_improper_list(byte()` \\| `binary()` \\| "
#~ "`iolist(), binary()` \\| `[])`\n"
#~ "`module()`              | `atom()` \\| `tuple()`\n"
#~ "`arity()`               | `0..255`\n"
#~ "`mfa()`                 | `{atom(), atom(), arity()}`\n"
#~ "`node()`                | `atom()`\n"
#~ "`timeout()`             | `:infinity` \\| `non_neg_integer()`\n"
#~ "`no_return()`           | `none()`\n"
#~ "`fun()`                 | `(... -> any)`\n"
#~ "`struct()`              | `%{__struct__: atom()}`\n"
#~ "`as_boolean(t)`         | `t`\n"
#~ "\n"
#~ "### Remote types\n"
#~ "\n"
#~ "任意のモジュールはそれ自身のタイプの定義が可能で、\n"
#~ "Elixirのモジュールも例外ではありません。例えば、文字列は\n"
#~ "`String.t`、rangeは`Range.t`、任意のenumerableは`Enum.t`など。\n"
#~ "\n"
#~ "## Defining a type\n"
#~ "\n"
#~ "    @type type_name :: type\n"
#~ "    @typep type_name :: type\n"
#~ "    @opaque type_name :: type\n"
#~ "\n"
#~ "`@typep`により定義されたタイプはプライベートです。\n"
#~ "`@opaque`によって定義された不透明なタイプは、タイプの内部構造が\n"
#~ "不可視なタイプで、そのタイプはまだパブリックです。\n"
#~ "\n"
#~ "タイプはパラメタとして変数を定義することによってパラメタ化でき、\n"
#~ "それらの変数はタイプを定義するために使うことができます。\n"
#~ "\n"
#~ "    @type dict(key, value) :: [{key, value}]\n"
#~ "\n"
#~ "## Defining a specification\n"
#~ "\n"
#~ "    @spec function_name(type1, type2) :: return_type\n"
#~ "    @callback function_name(type1, type2) :: return_type\n"
#~ "    @macrocallback macro_name(type1, type2) :: Macro.t\n"
#~ "\n"
#~ "callbackはビヘイビアのコールバック関数を定義するために使います\n"
#~ "(`Behaviour`参照)。\n"
#~ "\n"
#~ "ガードは関数の引数として与えられた変数のタイプを制限するために使います。\n"
#~ "\n"
#~ "    @spec function(arg) :: [arg] when arg: atom\n"
#~ "\n"
#~ "規制のないタイプ変数も定義することができます。\n"
#~ "\n"
#~ "    @spec function(arg) :: [arg] when arg: var\n"
#~ "\n"
#~ "仕様は通常の関数のようにオーバロードできます。\n"
#~ "\n"
#~ "    @spec function(integer) :: atom\n"
#~ "    @spec function(atom)    :: integer\n"
#~ "\n"
#~ "## Notes\n"
#~ "\n"
#~ "Elixirは、Elixirで\"strings\"とバイナリ(文字リストとは対照的に)\n"
#~ "と混同されるかもしれないので、タイプ`string`の使用を阻みます。\n"
#~ "Erlangの`string`と呼ばれるタイプを使うために、人は、\n"
#~ "`string`のシノニムである`char_list`タイプを使わなければなりません。\n"
#~ "もし`string`を使うなら、コンパイラから警告されます。\n"
#~ "\n"
#~ "(`String`モジュールの関数によって操作される)\"string\"タイプ\n"
#~ "を参照したいなら、かわりに`String.t`を使ってください。\n"

#~ msgid ""
#~ "Returns all type docs available from the module's beam code.\n"
#~ "\n"
#~ "The result is returned as a list of tuples where the first element is the "
#~ "pair of type\n"
#~ "name and arity and the second element is the documentation.\n"
#~ "\n"
#~ "The module must have a corresponding beam file which can be\n"
#~ "located by the runtime system.\n"
#~ msgstr ""
#~ "モジュールのbeamコードから全ての有効なタイプドキュメントを返します。\n"
#~ "\n"
#~ "返された結果は、最初の要素がタイプの名前とアリティで次の要素がドキュメ\n"
#~ "ントとなる、タプルのリストです。\n"
#~ "\n"
#~ "モジュールは実行時システムによって配置された対応するbeamファイルを\n"
#~ "持っていなければなりません。\n"
