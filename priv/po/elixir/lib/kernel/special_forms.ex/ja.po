msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2015-09-16 18:48+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.alias(module, opts)
#: lib/kernel/special_forms.ex:465
msgid ""
"`alias` is used to setup aliases, often useful with modules names.\n"
"\n"
"## Examples\n"
"\n"
"`alias` can be used to setup an alias for any module:\n"
"\n"
"    defmodule Math do\n"
"      alias MyKeyword, as: Keyword\n"
"    end\n"
"\n"
"In the example above, we have set up `MyKeyword` to be aliased\n"
"as `Keyword`. So now, any reference to `Keyword` will be\n"
"automatically replaced by `MyKeyword`.\n"
"\n"
"In case one wants to access the original `Keyword`, it can be done\n"
"by accessing `Elixir`:\n"
"\n"
"    Keyword.values   #=> uses MyKeyword.values\n"
"    Elixir.Keyword.values #=> uses Keyword.values\n"
"\n"
"Notice that calling `alias` without the `as:` option automatically\n"
"sets an alias based on the last part of the module. For example:\n"
"\n"
"    alias Foo.Bar.Baz\n"
"\n"
"Is the same as:\n"
"\n"
"    alias Foo.Bar.Baz, as: Baz\n"
"\n"
"## Lexical scope\n"
"\n"
"`import`, `require` and `alias` are called directives and all\n"
"have lexical scope. This means you can set up aliases inside\n"
"specific functions and it won't affect the overall scope.\n"
"\n"
"## Warnings\n"
"\n"
"If you alias a module and you don't use the alias, Elixir is\n"
"going to issue a warning implying the alias is not being used.\n"
"\n"
"In case the alias is generated automatically by a macro,\n"
"Elixir won't emit any warnings though, since the alias\n"
"was not explicitly defined.\n"
"\n"
"Both warning behaviours could be changed by explicitly\n"
"setting the `:warn` option to `true` or `false`.\n"
msgstr ""
"`alias`は別名をセットアップするのに使われ、しばしばモジュール名で役に立ちます。\n"
"\n"
"## 例\n"
"\n"
"`alias`は任意のモジュールの別名をセットアップするのに使うことができます:\n"
"\n"
"    defmodule Math do\n"
"      alias MyKeyword, as: Keyword\n"
"    end\n"
"\n"
"上の例で、`MyKeyword`の別名として`Keyword`をセットアップしました。だか\n"
"ら今や、`Keyword`へのどんな参照も`MyKeyword`に自動的に置き換えられます。\n"
"\n"
"オリジナルの`Keyword`へアクセスしたい場合は、`Elixir`を付けることで\n"
"可能になります:\n"
"\n"
"    Keyword.values   #=> uses MyKeyword.values\n"
"    Elixir.Keyword.values #=> uses Keyword.values\n"
"\n"
"`as:`オプションなしで`alias`を呼び出すと自動的にモジュールの最後の\n"
"パートを元に別名をセットアップすることに気を付けてください。例えば:\n"
"\n"
"    alias Foo.Bar.Baz\n"
"\n"
"これは以下と同じです:\n"
"\n"
"    alias Foo.Bar.Baz, as: Baz\n"
"\n"
"## レキシカルスコープ\n"
"\n"
"`import`, `require`そして`alias`はディレクトリと呼ばれていて\n"
"レキシカルスコープを持ちます。これは、特定の関数の中に別名を\n"
"セットアップ出来ること、そしてそれが全体のスコープに影響を及ぼさないことを\n"
"意味します。\n"
"\n"
"## 警告\n"
"\n"
"もしモジュールの別名を設定したのにその別名を使わない場合、Elixirは別名\n"
"が使われていないことを意味する警告を発するように思えます。\n"
"\n"
"別名はマクロによって自動的に生成されることに備えて、Elixirは別名が明示\n"
"的に定義されなかった時からいかなる警告も発しないようです。\n"
"\n"
"両方の警告の振舞は`:warn`オプションを`true`または`false`に明示的に設定する\n"
"ことで変更できるようになるかもしれません。\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.::(left, right)
#: lib/kernel/special_forms.ex:710
msgid ""
"Used by types and bitstrings to specify types.\n"
"\n"
"This operator is used in two distinct occasions in Elixir.\n"
"It is used in typespecs to specify the type of a variable,\n"
"function or of a type itself:\n"
"\n"
"    @type number :: integer | float\n"
"    @spec add(number, number) :: number\n"
"\n"
"It may also be used in bit strings to specify the type\n"
"of a given bit segment:\n"
"\n"
"    <<int::integer-little, rest::bits>> = bits\n"
"\n"
"Read the documentation for `Kernel.Typespec` and\n"
"`<<>>/1` for more information on typespecs and\n"
"bitstrings respectively.\n"
msgstr ""
"タイプとbitstringのタイプ指定で使われます。\n"
"\n"
"Elixirでは、このオペレータは二つの異った場合で使われます。\n"
"typespecで変数、関数のタイプまたはタイプ自身の仕様を\n"
"指定する時に使われます:\n"
"\n"
"    @type number :: integer | float\n"
"    @spec add(number, number) :: number\n"
"\n"
"bitstringでは与えられたbitセグメントのタイプを\n"
"指定するのに使われます:\n"
"\n"
"    <<int::integer-little, rest::bits>> = bits\n"
"\n"
"それぞれtypespecとbitstringの詳細は、\n"
"`Kernel.Typespec`と`<<>>/1`のドキュメントを参照してください。\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.__MODULE__()
#: lib/kernel/special_forms.ex:650
msgid ""
"Returns the current module name as an atom or `nil` otherwise.\n"
"\n"
"Although the module can be accessed in the `__ENV__`, this macro\n"
"is a convenient shortcut.\n"
msgstr ""
"現在のモジュール名をアトムとして返します。さもなくば`nil`を返します。\n"
"\n"
"`__ENV__`の中でモジュールはアクセスできますが、このマクロは\n"
"便利なショートカットです。\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.__ENV__()
#: lib/kernel/special_forms.ex:642
msgid ""
"Returns the current environment information as a `Macro.Env` struct.\n"
"\n"
"In the environment you can access the current filename,\n"
"line numbers, set up aliases, the current function and others.\n"
msgstr ""
"`Macro.Env`構造体として現在の環境情報を返します。\n"
"\n"
"環境では現在のファイル名、行番号、セットアップされた別名、\n"
"および現在の関数などにアクセスできます。\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.__DIR__()
#: lib/kernel/special_forms.ex:658
msgid ""
"Returns the current directory as a binary.\n"
"\n"
"Although the directory can be accessed as `Path.dirname(__ENV__.file)`,\n"
"this macro is a convenient shortcut.\n"
msgstr ""
"バイナリとして現在のディレクトリを返します。\n"
"\n"
"そのディレクトリには`Path.dirname(__ENV__.file)`としてもアクセスできま\n"
"すが、このマクロは便利なショートカットです。\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.__CALLER__()
#: lib/kernel/special_forms.ex:666
msgid ""
"Returns the current calling environment as a `Macro.Env` struct.\n"
"\n"
"In the environment you can access the filename, line numbers,\n"
"set up aliases, the function and others.\n"
msgstr ""
"`Macro.Env`構造体として現在の呼び出し側の環境を返します。\n"
"\n"
"環境では現在のファイル名、行番号、セットアップされた別名、\n"
"および現在の関数などにアクセスできます。\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.unquote_splicing(expr)
#: lib/kernel/special_forms.ex:1212
msgid ""
"Unquotes the given list expanding its arguments. Similar\n"
"to unquote.\n"
"\n"
"## Examples\n"
"\n"
"    values = [2, 3, 4]\n"
"    quote do: sum(1, unquote_splicing(values), 5)\n"
"    #=> {:sum, [], [1, 2, 3, 4, 5]}\n"
"\n"
msgstr ""
"与えられたリストをその引数に拡張してunquoteします。\n"
"unquoteと似ています。\n"
"\n"
"## 例\n"
"\n"
"    values = [2, 3, 4]\n"
"    quote do: sum(1, unquote_splicing(values), 5)\n"
"    #=> {:sum, [], [1, 2, 3, 4, 5]}\n"
"\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.unquote(expr)
#: lib/kernel/special_forms.ex:1187
msgid ""
"Unquotes the given expression from inside a macro.\n"
"\n"
"## Examples\n"
"\n"
"Imagine the situation you have a variable `value` and\n"
"you want to inject it inside some quote. The first attempt\n"
"would be:\n"
"\n"
"    value = 13\n"
"    quote do: sum(1, value, 3)\n"
"\n"
"Which would then return:\n"
"\n"
"    {:sum, [], [1, {:value, [], quoted}, 3]}\n"
"\n"
"Which is not the expected result. For this, we use unquote:\n"
"\n"
"    value = 13\n"
"    quote do: sum(1, unquote(value), 3)\n"
"    #=> {:sum, [], [1, 13, 3]}\n"
"\n"
msgstr ""
"マクロの内側で与えられた式をunquoteします。\n"
"\n"
"## 例\n"
"\n"
"変数`value`を持っていて、それをいくつかのquoteの内側に\n"
"注入したいとします。最初の試みは以下のようになるでしょう:\n"
"\n"
"    value = 13\n"
"    quote do: sum(1, value, 3)\n"
"\n"
"それは以下を返します。\n"
"\n"
"    {:sum, [], [1, {:value, [], quoted}, 3]}\n"
"\n"
"それは期待した結果ではないです。このためにunquoteを使って以下の\n"
"します:\n"
"\n"
"    value = 13\n"
"    quote do: sum(1, unquote(value), 3)\n"
"    #=> {:sum, [], [1, 13, 3]}\n"
"\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.require(module, opts)
#: lib/kernel/special_forms.ex:515
msgid ""
"Requires a given module to be compiled and loaded.\n"
"\n"
"## Examples\n"
"\n"
"Notice that usually modules should not be required before usage,\n"
"the only exception is if you want to use the macros from a module.\n"
"In such cases, you need to explicitly require them.\n"
"\n"
"Let's suppose you created your own `if` implementation in the module\n"
"`MyMacros`. If you want to invoke it, you need to first explicitly\n"
"require the `MyMacros`:\n"
"\n"
"    defmodule Math do\n"
"      require MyMacros\n"
"      MyMacros.if do_something, it_works\n"
"    end\n"
"\n"
"An attempt to call a macro that was not loaded will raise an error.\n"
"\n"
"## Alias shortcut\n"
"\n"
"`require` also accepts `as:` as an option so it automatically sets\n"
"up an alias. Please check `alias` for more information.\n"
"\n"
msgstr ""
"コンパイルされてロードされた、与えられたモジュールを\n"
"requireします。\n"
"\n"
"## 例\n"
"\n"
"通常、モジュールが使用の前にrequireされてなくてもよいことに気を付けてく\n"
"ださい。モジュールからマクロを使いたい場合が唯一の例外です。\n"
"そんな場合は、requireを明示的に使う必要があります。\n"
"\n"
"モジュール`MyMacros`の中で独自の`if`の実装を作ったとします。\n"
"もしそれを実行したいなら、最初に明示的に`MyMacros`をrequireする\n"
"必要があります:\n"
"\n"
"    defmodule Math do\n"
"      require MyMacros\n"
"      MyMacros.if do_something, it_works\n"
"    end\n"
"\n"
"ロードされなかったマクロを呼び出す試みは、エラーを上げます。\n"
"\n"
"## Alias ショートカット\n"
"\n"
"`require`は、エイリアスを自動的にセットアップするオプションとして、\n"
"`as:`も受け付けます。詳細は、`alias`をチェックしてください。\n"
"\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.=(left, right)
#: lib/kernel/special_forms.ex:705
msgid "Matches the value on the right against the pattern on the left.\n"
msgstr "右辺の値に対して左辺のパターンをマッチします。\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.case(condition, clauses)
#: lib/kernel/special_forms.ex:1424
msgid ""
"Matches the given expression against the given clauses.\n"
"\n"
"## Examples\n"
"\n"
"    case thing do\n"
"      {:selector, i, value} when is_integer(i) ->\n"
"        value\n"
"      value ->\n"
"        value\n"
"    end\n"
"\n"
"In the example above, we match `thing` against each clause \"head\"\n"
"and execute the clause \"body\" corresponding to the first clause\n"
"that matches. If no clause matches, an error is raised.\n"
"\n"
"## Variables handling\n"
"\n"
"Notice that variables bound in a clause \"head\" do not leak to the\n"
"outer context:\n"
"\n"
"    case data do\n"
"      {:ok, value} -> value\n"
"      :error -> nil\n"
"    end\n"
"\n"
"    value #=> unbound variable value\n"
"\n"
"However, variables explicitly bound in the clause \"body\" are\n"
"accessible from the outer context:\n"
"\n"
"    value = 7\n"
"\n"
"    case lucky? do\n"
"      false -> value = 13\n"
"      true  -> true\n"
"    end\n"
"\n"
"    value #=> 7 or 13\n"
"\n"
"In the example above, value is going to be `7` or `13` depending on\n"
"the value of `lucky?`. In case `value` has no previous value before\n"
"case, clauses that do not explicitly bind a value have the variable\n"
"bound to `nil`.\n"
msgstr ""
"与えられた節に対して、与えられた式をマッチさせます。\n"
"\n"
"## 例\n"
"\n"
"    case thing do\n"
"      {:selector, i, value} when is_integer(i) ->\n"
"        value\n"
"      value ->\n"
"        value\n"
"    end\n"
"\n"
"上の例では、それぞれの\"head\"と`thing`を比べて、\n"
"マッチした最初の節の\"body\"を実行します。\n"
"もしマッチする節が無いと、エラーが上ります。\n"
"\n"
"## 変数の取り扱い(ハンドリング)\n"
"\n"
"節の\"head\"で束縛された変数は、外部のコンテキストには漏れないことに注意\n"
"してください:\n"
"\n"
"    case data do\n"
"      {:ok, value} -> value\n"
"      :error -> nil\n"
"    end\n"
"\n"
"    value #=> unbound variable value\n"
"\n"
"しかしながら、節の\"body\"で明示的に束縛された変数は、\n"
"外部のコンテキストからアクセスできます:\n"
"\n"
"    value = 7\n"
"\n"
"    case lucky? do\n"
"      false -> value = 13\n"
"      true  -> true\n"
"    end\n"
"\n"
"    value #=> 7 or 13\n"
"\n"
"上の例で、`lucky?`の値に依存して、valueは`7`か`13`になります。\n"
"`value`がcaseの前で以前の値を持っていない場合、明示的に束縛されない\n"
"変数の値は、`nil`に束縛されます。\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.__aliases__(args)
#: lib/kernel/special_forms.ex:1387
msgid ""
"Internal special form to hold aliases information.\n"
"\n"
"It is usually compiled to an atom:\n"
"\n"
"    iex> quote do: Foo.Bar\n"
"    {:__aliases__, [alias: false], [:Foo, :Bar]}\n"
"\n"
"Elixir represents `Foo.Bar` as `__aliases__` so calls can be\n"
"unambiguously identified by the operator `:.`. For example:\n"
"\n"
"    iex> quote do: Foo.bar\n"
"    {{:., [], [{:__aliases__, [alias: false], [:Foo]}, :bar]}, [], []}\n"
"\n"
"Whenever an expression iterator sees a `:.` as the tuple key,\n"
"it can be sure that it represents a call and the second argument\n"
"in the list is an atom.\n"
"\n"
"On the other hand, aliases holds some properties:\n"
"\n"
"  1. The head element of aliases can be any term that must expand to\n"
"     an atom at compilation time.\n"
"\n"
"  2. The tail elements of aliases are guaranteed to always be atoms.\n"
"\n"
"  3. When the head element of aliases is the atom `:Elixir`, no expansion "
"happen.\n"
"\n"
msgstr ""
"エイリアス情報を保持する内部のスペシャルフォームです。\n"
"\n"
"通常、アトムにコンパイルされます:\n"
"\n"
"    iex> quote do: Foo.Bar\n"
"    {:__aliases__, [alias: false], [:Foo, :Bar]}\n"
"\n"
"呼び出しが`:.`オペレータによって明確に識別されることができるので、\n"
"Eilxirは`Foo.Bar`を`__aliases__`として表現します。\n"
"例えば:\n"
"\n"
"    iex> quote do: Foo.bar\n"
"    {{:., [], [{:__aliases__, [alias: false], [:Foo]}, :bar]}, [], []}\n"
"\n"
"タプルのキーとして式の反復演算子が`:.`を見付けるときは何時でも、\n"
"それが呼び出しを表現し、リストの2番目の引数は、アトムです。\n"
"\n"
"他方で、aliasはいくつかのプロパティを保持します:\n"
"\n"
"  1. aliasのheadの要素は任意のtermで、コンパイル時にアトムに展開されなけれ"
"ば\n"
"     なりません\n"
"\n"
"  2. aliasのtailの要素は常にアトムであることが保証されます。\n"
"\n"
"  3. aliasのheadの要素がアトム`:Elixir`であるとき、展開は起きません。\n"
"\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.__block__(args)
#: lib/kernel/special_forms.ex:1305
msgid ""
"Internal special form for block expressions.\n"
"\n"
"This is the special form used whenever we have a block\n"
"of expressions in Elixir. This special form is private\n"
"and should not be invoked directly:\n"
"\n"
"    iex> quote do: (1; 2; 3)\n"
"    {:__block__, [], [1, 2, 3]}\n"
"\n"
msgstr ""
"ブロック式のための内部のスペシャルフォームです。これは、Elixirで式のブ\n"
"ロックが表れる時は、いつでも使われるスペシャルフォームです。このスペシャ\n"
"ルフォームはプライベートであり、直接起動するべきではありません:\n"
"\n"
"    iex> quote do: (1; 2; 3)\n"
"    {:__block__, [], [1, 2, 3]}\n"
"\n"

#. TRANSLATORS: Elixir.Kernel.SpecialForms Summary
#: lib/kernel/special_forms.ex:2
msgid ""
"In this module we define Elixir special forms. Special forms\n"
"cannot be overridden by the developer and are the basic\n"
"building blocks of Elixir code.\n"
"\n"
"Some of those forms are lexical (like `alias`, `case`, etc).\n"
"The macros `{}` and `<<>>` are also special forms used to define\n"
"tuple and binary data structures respectively.\n"
"\n"
"This module also documents Elixir's pseudo variables (`__ENV__`,\n"
"`__MODULE__`, `__DIR__` and `__CALLER__`). Pseudo variables return\n"
"information about Elixir's compilation environment and can only\n"
"be read, never assigned to.\n"
"\n"
"Finally, it also documents 2 special forms, `__block__` and\n"
"`__aliases__`, which are not intended to be called directly by the\n"
"developer but they appear in quoted contents since they are essential\n"
"in Elixir's constructs.\n"
msgstr ""
"このモジュールで、Elixirのスペシャルフォームを定義します。\n"
"スペシャルフォームは開発者によってオーバライド出来ず、\n"
"Elixirコードの基本的なビルディングブロックです。\n"
"\n"
"それらのフォームの幾つかは、レキシカル( `alias` 、 `case` など)です。\n"
"マクロ `{}` と `<<>>` もまた、タプルとバイナリデータ構造を表現するために\n"
"使われる、スペシャルフォームです。\n"
"\n"
"このモジュールはElixirの仮想変数(`__ENV__`、`__MODULE__`、`__DIR__`そして\n"
"`__CALLER__`)についてドキュメント化しています。\n"
"仮想変数はElixirのコンパイル環境についての情報を返し、\n"
"リードオンリーで、代入は決してできません。\n"
"\n"
"最後に、2つのスペシャルフォーム`__block__`と`__aliases__`についても\n"
"ドキュメント化しています。それらは、開発者から直接呼ばれることを\n"
"目的としていませんが、Elixirの構成概念にとって本質的な、\n"
"quoteされたコンテンツで表れます。\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.import(module, opts)
#: lib/kernel/special_forms.ex:543
msgid ""
"Imports function and macros from other modules.\n"
"\n"
"`import` allows one to easily access functions or macros from\n"
"others modules without using the qualified name.\n"
"\n"
"## Examples\n"
"\n"
"If you are using several functions from a given module, you can\n"
"import those functions and reference them as local functions,\n"
"for example:\n"
"\n"
"    iex> import List\n"
"    iex> flatten([1, [2], 3])\n"
"    [1, 2, 3]\n"
"\n"
"## Selector\n"
"\n"
"By default, Elixir imports functions and macros from the given\n"
"module, except the ones starting with underscore (which are\n"
"usually callbacks):\n"
"\n"
"    import List\n"
"\n"
"A developer can filter to import only macros or functions via\n"
"the only option:\n"
"\n"
"    import List, only: :functions\n"
"    import List, only: :macros\n"
"\n"
"Alternatively, Elixir allows a developer to pass pairs of\n"
"name/arities to `:only` or `:except` as a fine grained control\n"
"on what to import (or not):\n"
"\n"
"    import List, only: [flatten: 1]\n"
"    import String, except: [split: 2]\n"
"\n"
"Notice that calling `except` for a previously declared `import`\n"
"simply filters the previously imported elements. For example:\n"
"\n"
"    import List, only: [flatten: 1, keyfind: 4]\n"
"    import List, except: [flatten: 1]\n"
"\n"
"After the two import calls above, only `List.keyfind/4` will be\n"
"imported.\n"
"\n"
"## Underscore functions\n"
"\n"
"By default functions starting with `_` are not imported. If you really want\n"
"to import a function starting with `_` you must explicitly include it in "
"the\n"
"`:only` selector.\n"
"\n"
"    import File.Stream, only: [__build__: 3]\n"
"\n"
"## Lexical scope\n"
"\n"
"It is important to notice that `import` is lexical. This means you\n"
"can import specific macros inside specific functions:\n"
"\n"
"    defmodule Math do\n"
"      def some_function do\n"
"        # 1) Disable `if/2` from Kernel\n"
"        import Kernel, except: [if: 2]\n"
"\n"
"        # 2) Require the new `if` macro from MyMacros\n"
"        import MyMacros\n"
"\n"
"        # 3) Use the new macro\n"
"        if do_something, it_works\n"
"      end\n"
"    end\n"
"\n"
"In the example above, we imported macros from `MyMacros`,\n"
"replacing the original `if/2` implementation by our own\n"
"within that specific function. All other functions in that\n"
"module will still be able to use the original one.\n"
"\n"
"## Warnings\n"
"\n"
"If you import a module and you don't use any of the imported\n"
"functions or macros from this module, Elixir is going to issue\n"
"a warning implying the import is not being used.\n"
"\n"
"In case the import is generated automatically by a macro,\n"
"Elixir won't emit any warnings though, since the import\n"
"was not explicitly defined.\n"
"\n"
"Both warning behaviours could be changed by explicitly\n"
"setting the `:warn` option to `true` or `false`.\n"
"\n"
"## Ambiguous function/macro names\n"
"\n"
"If two modules `A` and `B` are imported and they both contain\n"
"a `foo` function with an arity of `1`, an error is only emitted\n"
"if an ambiguous call to `foo/1` is actually made; that is, the\n"
"errors are emitted lazily, not eagerly.\n"
msgstr ""
"関数とマクロを他のモジュールからインポートします。\n"
"\n"
"`import`は修飾された名前を使うことなく他のモジュールから\n"
"関数やマクロに容易にアクセスすることを許します。\n"
"\n"
"## 例\n"
"\n"
"もし与えられたモジュールから、いくつかの関数を使っているなら、\n"
"それらの関数をimportしてローカル関数としてそれらを参照することが\n"
"できます。例えば:\n"
"\n"
"    iex> import List\n"
"    iex> flatten([1, [2], 3])\n"
"    [1,2,3]\n"
"\n"
"## セレクタ\n"
"\n"
"デフォルトでは、Elixirは与えられたモジュールから、下線で始まるもの(それ\n"
"は通常コールバックです)以外の関数とマクロをインポートします:\n"
"\n"
"    import List\n"
"\n"
"開発者はマクロだけ、あるいは関数だけをインポートするために、\n"
"onlyオプションにより、フィルタすることが出来ます:\n"
"\n"
"    import List, only: :functions\n"
"    import List, only: :macros\n"
"\n"
"あるいは、Elixirは開発者に、何をインポートするか(また、何をしないか)の\n"
"きめ細かい制御として、`:only`あるいは`:except`に名前/アリティのペアを\n"
"渡すことを許しています:\n"
"\n"
"    import List, only: [flatten: 1]\n"
"    import String, except: [split: 2]\n"
"\n"
"以前に宣言された`import`のために`except`を呼ぶことは、単に以前にインポー\n"
"トされた要素をフィルタすることに、注意してください。例えば:\n"
"\n"
"    import List, only: [flatten: 1, keyfind: 3]\n"
"    import List, except: [flatten: 1]\n"
"\n"
"上の二つのimportの呼び出しの後で、`List.keyfind/3`だけがインポート\n"
"されます。\n"
"\n"
"## アンダースコア関数\n"
"\n"
"デフォルトで`_`で始まる関数はimportされません。もし\n"
"`_`で始まる関数を本当にimportしたいのなら、明示的に\n"
"`:only`セレクタで含ませなければなりません。\n"
"\n"
"    import File.Stream, only: [__build__: 3]\n"
"\n"
"## レキシカルスコープ\n"
"\n"
"`import`がレキシカルであることに注意することは重要です。\n"
"これは特定の関数の中で特定のマクロをインポートできることを\n"
"意味します:\n"
"\n"
"    defmodule Math do\n"
"      def some_function do\n"
"        # 1) Disable `if/2` from Kernel\n"
"        import Kernel, except: [if: 2]\n"
"\n"
"        # 2) Require the new `if` macro from MyMacros\n"
"        import MyMacros\n"
"\n"
"        # 3) Use the new macro\n"
"        if do_something, it_works\n"
"      end\n"
"    end\n"
"\n"
"上の例では、`MyMacros`からマクロをインポートし、\n"
"特定の関数の範囲内で、オリジナルの`if/2`実装を取り替えました。\n"
"そのモジュールの他の全ての関数は、まだオリジナルのものを\n"
"使うことができます。\n"
"\n"
"## 警告\n"
"\n"
"もしモジュールをインポートし、そのモジュールから\n"
"インポートされた関数やマクロを全く使わなかったら、Elixirは\n"
"インポートが使われていないことを意味する警告を発するでしょう。\n"
"\n"
"インポートがマクロによって自動的に生成された場合に備えて、\n"
"Elixirは明示的にimportが定義されない時は、いかなる警告も\n"
"発しません。\n"
"\n"
"両方の警告の振る舞いは`:warn`オプションを`true`か`false`に\n"
"明示的に設定することで変更できます。\n"
"\n"
"## 曖昧な関数/マクロ名\n"
"\n"
"もし、二つのモジュール`A`と`B`がインポートされ、それら両方が\n"
"アリティ1の`foo`関数を含んでいたら、\n"
"曖昧な`foo/1`への呼び出しが実際に起きたとき、エラーが発生します;\n"
"つまり、エラーはeagerではなく、lazyで発行されます。\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.try(args)
#: lib/kernel/special_forms.ex:1491
msgid ""
"Evaluates the given expressions and handle any error, exit\n"
"or throw that may have happened.\n"
"\n"
"## Examples\n"
"\n"
"    try do\n"
"      do_something_that_may_fail(some_arg)\n"
"    rescue\n"
"      ArgumentError ->\n"
"        IO.puts \"Invalid argument given\"\n"
"    catch\n"
"      value ->\n"
"        IO.puts \"caught #{value}\"\n"
"    else\n"
"      value ->\n"
"        IO.puts \"Success! The result was #{value}\"\n"
"    after\n"
"      IO.puts \"This is printed regardless if it failed or succeed\"\n"
"    end\n"
"\n"
"The rescue clause is used to handle exceptions, while the catch\n"
"clause can be used to catch thrown values. The else clause can\n"
"be used to control flow based on the result of the expression.\n"
"Catch, rescue and else clauses work based on pattern matching.\n"
"\n"
"Note that calls inside `try` are not tail recursive since the VM\n"
"needs to keep the stacktrace in case an exception happens.\n"
"\n"
"## Rescue clauses\n"
"\n"
"Besides relying on pattern matching, rescue clauses provides some\n"
"conveniences around exceptions that allows one to rescue an\n"
"exception by its name. All the following formats are valid rescue\n"
"expressions:\n"
"\n"
"    try do\n"
"      UndefinedModule.undefined_function\n"
"    rescue\n"
"      UndefinedFunctionError -> nil\n"
"    end\n"
"\n"
"    try do\n"
"      UndefinedModule.undefined_function\n"
"    rescue\n"
"      [UndefinedFunctionError] -> nil\n"
"    end\n"
"\n"
"    # rescue and bind to x\n"
"    try do\n"
"      UndefinedModule.undefined_function\n"
"    rescue\n"
"      x in [UndefinedFunctionError] -> nil\n"
"    end\n"
"\n"
"    # rescue all and bind to x\n"
"    try do\n"
"      UndefinedModule.undefined_function\n"
"    rescue\n"
"      x -> nil\n"
"    end\n"
"\n"
"## Erlang errors\n"
"\n"
"Erlang errors are transformed into Elixir ones during rescue:\n"
"\n"
"    try do\n"
"      :erlang.error(:badarg)\n"
"    rescue\n"
"      ArgumentError -> :ok\n"
"    end\n"
"\n"
"The most common Erlang errors will be transformed into their\n"
"Elixir counter-part. Those which are not will be transformed\n"
"into `ErlangError`:\n"
"\n"
"    try do\n"
"      :erlang.error(:unknown)\n"
"    rescue\n"
"      ErlangError -> :ok\n"
"    end\n"
"\n"
"In fact, ErlangError can be used to rescue any error that is\n"
"not an Elixir error proper. For example, it can be used to rescue\n"
"the earlier `:badarg` error too, prior to transformation:\n"
"\n"
"    try do\n"
"      :erlang.error(:badarg)\n"
"    rescue\n"
"      ErlangError -> :ok\n"
"    end\n"
"\n"
"## Catching throws and exits\n"
"\n"
"The catch clause can be used to catch throws values and exits.\n"
"\n"
"    try do\n"
"      exit(:shutdown)\n"
"    catch\n"
"      :exit, :shutdown -> IO.puts \"Exited with shutdown reason\"\n"
"    end\n"
"\n"
"    try do\n"
"      throw(:sample)\n"
"    catch\n"
"      :throw, :sample ->\n"
"        IO.puts \"sample thrown\"\n"
"    end\n"
"\n"
"catch values also support `:error`, as in Erlang, although it is\n"
"commonly avoided in favor of raise/rescue control mechanisms.\n"
"\n"
"## Else clauses\n"
"\n"
"Else clauses allow the result of the expression to be pattern\n"
"matched on:\n"
"\n"
"    x = 2\n"
"    try do\n"
"      1 / x\n"
"    rescue\n"
"      ArithmeticError ->\n"
"        :infinity\n"
"    else\n"
"      y when y < 1 and y > -1 ->\n"
"        :small\n"
"      _ ->\n"
"        :large\n"
"    end\n"
"\n"
"If an else clause is not present the result of the expression will\n"
"be return, if no exceptions are raised:\n"
"\n"
"    x = 1\n"
"    ^x =\n"
"      try do\n"
"        1 / x\n"
"      rescue\n"
"        ArithmeticError ->\n"
"          :infinity\n"
"      end\n"
"\n"
"However when an else clause is present but the result of the expression\n"
"does not match any of the patterns an exception will be raised. This\n"
"exception will not be caught by a catch or rescue in the same try:\n"
"\n"
"    x = 1\n"
"    try do\n"
"      try do\n"
"        1 / x\n"
"      rescue\n"
"        # The TryClauseError can not be rescued here:\n"
"        TryClauseError ->\n"
"          :error_a\n"
"      else\n"
"        0 ->\n"
"          :small\n"
"      end\n"
"    rescue\n"
"      # The TryClauseError is rescued here:\n"
"      TryClauseError ->\n"
"        :error_b\n"
"    end\n"
"\n"
"Similarly an exception inside an else clause is not caught or rescued\n"
"inside the same try:\n"
"\n"
"    try do\n"
"      try do\n"
"        nil\n"
"      catch\n"
"        # The exit(1) call below can not be caught here:\n"
"        :exit, _ ->\n"
"          :exit_a\n"
"      else\n"
"        _ ->\n"
"          exit(1)\n"
"      end\n"
"    catch\n"
"      # The exit is caught here:\n"
"      :exit, _ ->\n"
"        :exit_b\n"
"    end\n"
"\n"
"This means the VM no longer needs to keep the stacktrace once inside\n"
"an else clause and so tail recursion is possible when using a `try`\n"
"with a tail call as the final call inside an else clause. The same\n"
"is `true` for `rescue` and `catch` clauses.\n"
"\n"
"## Variable handling\n"
"\n"
"Since an expression inside `try` may not have been evaluated\n"
"due to an exception, any variable created inside `try` cannot\n"
"be accessed externally. For instance:\n"
"\n"
"    try do\n"
"      x = 1\n"
"      do_something_that_may_fail(same_arg)\n"
"      :ok\n"
"    catch\n"
"      _, _ -> :failed\n"
"    end\n"
"\n"
"    x #=> unbound variable `x`\n"
"\n"
"In the example above, `x` cannot be accessed since it was defined\n"
"inside the `try` clause. A common practice to address this issue\n"
"is to return the variables defined inside `try`:\n"
"\n"
"    x =\n"
"      try do\n"
"        x = 1\n"
"        do_something_that_may_fail(same_arg)\n"
"        x\n"
"      catch\n"
"        _, _ -> :failed\n"
"      end\n"
"\n"
msgstr ""
"与えられた式を評価し、発生した任意のerror, exit, throwを\n"
"ハンドルします。\n"
"\n"
"## 例\n"
"\n"
"    try do\n"
"      do_something_that_may_fail(some_arg)\n"
"    rescue\n"
"      ArgumentError ->\n"
"        IO.puts \"Invalid argument given\"\n"
"    catch\n"
"      value ->\n"
"        IO.puts \"caught #{value}\"\n"
"    else\n"
"      value ->\n"
"        IO.puts \"Success! The result was #{value}\"\n"
"    after\n"
"      IO.puts \"This is printed regardless if it failed or succeed\"\n"
"    end\n"
"\n"
"rescue節は例外をハンドルするために使われ、catch節は\n"
"投げられた値を捕捉するために使われます。\n"
"else節は式の結果に基いたフロー制御の為に使われます。\n"
"catch, rescue, else節はパターンマッチングに基いて動きます。\n"
"\n"
"`try`の内側の呼び出しは、例外が発生したときに備えて、\n"
"VMがスタックトレースを保持する必要があるため、末尾再帰では\n"
"ないことに、気を付けてください。\n"
"\n"
"## Rescue 節\n"
"\n"
"パターンマッチングに頼る他に、rescue節は\n"
"その名前によって例外をrescueすることを許す、\n"
"例外まわりでいくつかの利便性を提供します。\n"
"下のフォーマットは全て、有効なrescue式です:\n"
"\n"
"    try do\n"
"      UndefinedModule.undefined_function\n"
"    rescue\n"
"      UndefinedFunctionError -> nil\n"
"    end\n"
"\n"
"    try do\n"
"      UndefinedModule.undefined_function\n"
"    rescue\n"
"      [UndefinedFunctionError] -> nil\n"
"    end\n"
"\n"
"    # rescue and bind to x\n"
"    try do\n"
"      UndefinedModule.undefined_function\n"
"    rescue\n"
"      x in [UndefinedFunctionError] -> nil\n"
"    end\n"
"\n"
"    # rescue all and bind to x\n"
"    try do\n"
"      UndefinedModule.undefined_function\n"
"    rescue\n"
"      x -> nil\n"
"    end\n"
"\n"
"## Erlang エラー\n"
"\n"
"Erlangエラーはrescueされる間に、Elixirのフォーマットに変換されます:\n"
"\n"
"    try do\n"
"      :erlang.error(:badarg)\n"
"    rescue\n"
"      ArgumentError -> :ok\n"
"    end\n"
"\n"
"ほとんどの共通的なErlangエラーはElixirの対応するエラーに変換されます。\n"
"それ以外のエラーは`ErlangError`に変換されます:\n"
"\n"
"    try do\n"
"      :erlang.error(:unknown)\n"
"    rescue\n"
"      ErlangError -> :ok\n"
"    end\n"
"\n"
"事実、ErlangErrorは本来のElixirエラーではない、全てのエラーを\n"
"rescueするために使うことができます。例えば、\n"
"変換する前のエラーである`:badarg`エラーをrescueするために\n"
"使うことができます:\n"
"\n"
"    try do\n"
"      :erlang.error(:badarg)\n"
"    rescue\n"
"      ErlangError -> :ok\n"
"    end\n"
"\n"
"## Catching throws and exits\n"
"\n"
"catch節はthrowされた値とexitを捕捉するために使うことができます。\n"
"\n"
"    try do\n"
"      exit(:shutdown)\n"
"    catch\n"
"      :exit, :shutdown -> IO.puts \"Exited with shutdown reason\"\n"
"    end\n"
"\n"
"    try do\n"
"      throw(:sample)\n"
"    catch\n"
"      :throw, :sample ->\n"
"        IO.puts \"sample thrown\"\n"
"    end\n"
"\n"
"捕捉する値は、raise/rescue制御メカニズムを支持して、一般には避けられま\n"
"すが、Erlangでの場合のように`:error`もサポートします。\n"
"\n"
"## Else 節\n"
"\n"
"else 節は式の結果をパターンマッチすることを許します:\n"
"\n"
"    x = 2\n"
"    try do\n"
"      1 / x\n"
"    rescue\n"
"      ArithmeticError ->\n"
"        :infinity\n"
"    else\n"
"      y when y < 1 and y > -1 ->\n"
"        :small\n"
"      _ ->\n"
"        :large\n"
"    end\n"
"\n"
"もしelse節が無いなら、例外が上らなければ、式の結果は返されます:\n"
"\n"
"    x = 1\n"
"    ^x =\n"
"      try do\n"
"        1 / x\n"
"      rescue\n"
"        ArithmeticError ->\n"
"          :infinity\n"
"      end\n"
"\n"
"しかしながら、else節があり、式の結果がどのパターンにもマッチしない場合、\n"
"例外が上ります。\n"
"この例外は、同じtryのcatchやrescueによって捕捉されません:\n"
"\n"
"    x = 1\n"
"    try do\n"
"      try do\n"
"        1 / x\n"
"      rescue\n"
"        # The TryClauseError can not be rescued here:\n"
"        TryClauseError ->\n"
"          :error_a\n"
"      else\n"
"        0 ->\n"
"          :small\n"
"      end\n"
"    rescue\n"
"      # The TryClauseError is rescued here:\n"
"      TryClauseError ->\n"
"        :error_b\n"
"    end\n"
"\n"
"同様に、else節の内側での例外は、同じtryの中でcatchもrescueも\n"
"されません:\n"
"\n"
"    try do\n"
"      try do\n"
"        nil\n"
"      catch\n"
"        # The exit(1) call below can not be caught here:\n"
"        :exit, _ ->\n"
"          :exit_a\n"
"      else\n"
"        _ ->\n"
"          exit(1)\n"
"      end\n"
"    catch\n"
"      # The exit is caught here:\n"
"      :exit, _ ->\n"
"        :exit_b\n"
"    end\n"
"\n"
"これは、else節の内側でVMが最早スタックトレースを保持する必要がないこと\n"
"と、そして、`try`では、else節での最後の呼び出しとなるので、そこで呼び出\n"
"すと、末尾再帰が可能であること、を意味します。\n"
"同じことが`rescue`と`catch`節でも言えます。\n"
"\n"
"## 変数のハンドリング\n"
"\n"
"`try`の内側の式が例外のため評価されなかったかもしれないので、\n"
"`try`の内側で作成された全ての変数は外部からアクセスできません。\n"
"例えば:\n"
"\n"
"    try do\n"
"      x = 1\n"
"      do_something_that_may_fail(same_arg)\n"
"      :ok\n"
"    catch\n"
"      _, _ -> :failed\n"
"    end\n"
"\n"
"    x #=> unbound variable `x`\n"
"\n"
"上の例で、`x`は`try`節の内側で定義されたので、アクセスできません。\n"
"この問題に対処する共通の方法は、`try`の内側で定義された変数を\n"
"返すことです:\n"
"\n"
"    x =\n"
"      try do\n"
"        x = 1\n"
"        do_something_that_may_fail(same_arg)\n"
"        x\n"
"      catch\n"
"        _, _ -> :failed\n"
"      end\n"
"\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.cond(clauses)
#: lib/kernel/special_forms.ex:1471
msgid ""
"Evaluates the expression corresponding to the first clause that\n"
"evaluates to truth value.\n"
"\n"
"Raises an error if all conditions evaluate to `nil` or `false`.\n"
"\n"
"## Examples\n"
"\n"
"    cond do\n"
"      1 + 1 == 1 ->\n"
"        \"This will never match\"\n"
"      2 * 2 != 4 ->\n"
"        \"Nor this\"\n"
"      true ->\n"
"        \"This will\"\n"
"    end\n"
"\n"
msgstr ""
"式の真理値がtrueに一致する最初の節の式を実行します。\n"
"\n"
"もし全ての条件が`nil`または`false`なら、エラーを上げます。\n"
"\n"
"## 例\n"
"\n"
"    cond do\n"
"      1 + 1 == 1 ->\n"
"        \"This will never match\"\n"
"      2 * 2 != 4 ->\n"
"        \"Nor this\"\n"
"      true ->\n"
"        \"This will\"\n"
"    end\n"
"\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.quote(opts, block)
#: lib/kernel/special_forms.ex:731
msgid ""
"Gets the representation of any expression.\n"
"\n"
"## Examples\n"
"\n"
"    quote do: sum(1, 2, 3)\n"
"    #=> {:sum, [], [1, 2, 3]}\n"
"\n"
"## Explanation\n"
"\n"
"Any Elixir code can be represented using Elixir data structures.\n"
"The building block of Elixir macros is a tuple with three elements,\n"
"for example:\n"
"\n"
"    {:sum, [], [1, 2, 3]}\n"
"\n"
"The tuple above represents a function call to `sum` passing 1, 2 and\n"
"3 as arguments. The tuple elements are:\n"
"\n"
"  * The first element of the tuple is always an atom or\n"
"    another tuple in the same representation.\n"
"\n"
"  * The second element of the tuple represents metadata.\n"
"\n"
"  * The third element of the tuple are the arguments for the\n"
"    function call. The third argument may be an atom, which is\n"
"    usually a variable (or a local call).\n"
"\n"
"## Options\n"
"\n"
"  * `:unquote` - when `false`, disables unquoting. Useful when you have a "
"quote\n"
"    inside another quote and want to control what quote is able to unquote.\n"
"\n"
"  * `:location` - when set to `:keep`, keeps the current line and file from\n"
"    quote. Read the Stacktrace information section below for more\n"
"    information.\n"
"\n"
"  * `:context` - sets the resolution context.\n"
"\n"
"  * `:bind_quoted` - passes a binding to the macro. Whenever a binding is\n"
"    given, `unquote` is automatically disabled.\n"
"\n"
"## Quote literals\n"
"\n"
"Besides the tuple described above, Elixir has a few literals that\n"
"when quoted return themselves. They are:\n"
"\n"
"    :sum         #=> Atoms\n"
"    1            #=> Integers\n"
"    2.0          #=> Floats\n"
"    [1, 2]       #=> Lists\n"
"    \"strings\"    #=> Strings\n"
"    {key, value} #=> Tuples with two elements\n"
"\n"
"## Quote and macros\n"
"\n"
"`quote` is commonly used with macros for code generation. As an exercise,\n"
"let's define a macro that multiplies a number by itself (squared). Note\n"
"there is no reason to define such as a macro (and it would actually be\n"
"seen as a bad practice), but it is simple enough that it allows us to focus\n"
"on the important aspects of quotes and macros:\n"
"\n"
"    defmodule Math do\n"
"      defmacro squared(x) do\n"
"        quote do\n"
"          unquote(x) * unquote(x)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"We can invoke it as:\n"
"\n"
"    import Math\n"
"    IO.puts \"Got #{squared(5)}\"\n"
"\n"
"At first, there is nothing in this example that actually reveals it is a\n"
"macro. But what is happening is that, at compilation time, `squared(5)`\n"
"becomes `5 * 5`. The argument `5` is duplicated in the produced code, we\n"
"can see this behaviour in practice though because our macro actually has\n"
"a bug:\n"
"\n"
"    import Math\n"
"    my_number = fn ->\n"
"      IO.puts \"Returning 5\"\n"
"      5\n"
"    end\n"
"    IO.puts \"Got #{squared(my_number.())}\"\n"
"\n"
"The example above will print:\n"
"\n"
"    Returning 5\n"
"    Returning 5\n"
"    25\n"
"\n"
"Notice how \"Returning 5\" was printed twice, instead of just once. This is\n"
"because a macro receives an expression and not a value (which is what we\n"
"would expect in a regular function). This means that:\n"
"\n"
"    squared(my_number.())\n"
"\n"
"Actually expands to:\n"
"\n"
"    my_number.() * my_number.()\n"
"\n"
"Which invokes the function twice, explaining why we get the printed value\n"
"twice! In the majority of the cases, this is actually unexpected behaviour,\n"
"and that's why one of the first things you need to keep in mind when it\n"
"comes to macros is to **not unquote the same value more than once**.\n"
"\n"
"Let's fix our macro:\n"
"\n"
"    defmodule Math do\n"
"      defmacro squared(x) do\n"
"        quote do\n"
"          x = unquote(x)\n"
"          x * x\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"Now invoking `square(my_number.())` as before will print the value just\n"
"once.\n"
"\n"
"In fact, this pattern is so common that most of the times you will want\n"
"to use the `bind_quoted` option with `quote`:\n"
"\n"
"    defmodule Math do\n"
"      defmacro squared(x) do\n"
"        quote bind_quoted: [x: x] do\n"
"          x * x\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"`:bind_quoted` will translate to the same code as the example above.\n"
"`:bind_quoted` can be used in many cases and is seen as good practice,\n"
"not only because it helps us from running into common mistakes but also\n"
"because it allows us to leverage other tools exposed by macros, such as\n"
"unquote fragments discussed in some sections below.\n"
"\n"
"Before we finish this brief introduction, you will notice that, even though\n"
"we defined a variable `x` inside our quote:\n"
"\n"
"    quote do\n"
"      x = unquote(x)\n"
"      x * x\n"
"    end\n"
"\n"
"When we call:\n"
"\n"
"    import Math\n"
"    squared(5)\n"
"    x #=> ** (RuntimeError) undefined function or variable: x\n"
"\n"
"We can see that `x` did not leak to the user context. This happens\n"
"because Elixir macros are hygienic, a topic we will discuss at length\n"
"in the next sections as well.\n"
"\n"
"## Hygiene in variables\n"
"\n"
"Consider the following example:\n"
"\n"
"    defmodule Hygiene do\n"
"      defmacro no_interference do\n"
"        quote do: a = 1\n"
"      end\n"
"    end\n"
"\n"
"    require Hygiene\n"
"\n"
"    a = 10\n"
"    Hygiene.no_interference\n"
"    a #=> 10\n"
"\n"
"In the example above, `a` returns 10 even if the macro\n"
"is apparently setting it to 1 because variables defined\n"
"in the macro does not affect the context the macro is executed in.\n"
"If you want to set or get a variable in the caller's context, you\n"
"can do it with the help of the `var!` macro:\n"
"\n"
"    defmodule NoHygiene do\n"
"      defmacro interference do\n"
"        quote do: var!(a) = 1\n"
"      end\n"
"    end\n"
"\n"
"    require NoHygiene\n"
"\n"
"    a = 10\n"
"    NoHygiene.interference\n"
"    a #=> 1\n"
"\n"
"Note that you cannot even access variables defined in the same\n"
"module unless you explicitly give it a context:\n"
"\n"
"    defmodule Hygiene do\n"
"      defmacro write do\n"
"        quote do\n"
"          a = 1\n"
"        end\n"
"      end\n"
"\n"
"      defmacro read do\n"
"        quote do\n"
"          a\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    Hygiene.write\n"
"    Hygiene.read\n"
"    #=> ** (RuntimeError) undefined function or variable: a\n"
"\n"
"For such, you can explicitly pass the current module scope as\n"
"argument:\n"
"\n"
"    defmodule ContextHygiene do\n"
"      defmacro write do\n"
"        quote do\n"
"          var!(a, ContextHygiene) = 1\n"
"        end\n"
"      end\n"
"\n"
"      defmacro read do\n"
"        quote do\n"
"          var!(a, ContextHygiene)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    ContextHygiene.write\n"
"    ContextHygiene.read\n"
"    #=> 1\n"
"\n"
"## Hygiene in aliases\n"
"\n"
"Aliases inside quote are hygienic by default.\n"
"Consider the following example:\n"
"\n"
"    defmodule Hygiene do\n"
"      alias HashDict, as: D\n"
"\n"
"      defmacro no_interference do\n"
"        quote do: D.new\n"
"      end\n"
"    end\n"
"\n"
"    require Hygiene\n"
"    Hygiene.no_interference #=> #HashDict<[]>\n"
"\n"
"Notice that, even though the alias `D` is not available\n"
"in the context the macro is expanded, the code above works\n"
"because `D` still expands to `HashDict`.\n"
"\n"
"Similarly, even if we defined an alias with the same name\n"
"before invoking a macro, it won't affect the macro's result:\n"
"\n"
"    defmodule Hygiene do\n"
"      alias HashDict, as: D\n"
"\n"
"      defmacro no_interference do\n"
"        quote do: D.new\n"
"      end\n"
"    end\n"
"\n"
"    require Hygiene\n"
"    alias SomethingElse, as: D\n"
"    Hygiene.no_interference #=> #HashDict<[]>\n"
"\n"
"In some cases, you want to access an alias or a module defined\n"
"in the caller. For such, you can use the `alias!` macro:\n"
"\n"
"    defmodule Hygiene do\n"
"      # This will expand to Elixir.Nested.hello\n"
"      defmacro no_interference do\n"
"        quote do: Nested.hello\n"
"      end\n"
"\n"
"      # This will expand to Nested.hello for\n"
"      # whatever is Nested in the caller\n"
"      defmacro interference do\n"
"        quote do: alias!(Nested).hello\n"
"      end\n"
"    end\n"
"\n"
"    defmodule Parent do\n"
"      defmodule Nested do\n"
"        def hello, do: \"world\"\n"
"      end\n"
"\n"
"      require Hygiene\n"
"      Hygiene.no_interference\n"
"      #=> ** (UndefinedFunctionError) ...\n"
"\n"
"      Hygiene.interference\n"
"      #=> \"world\"\n"
"    end\n"
"\n"
"## Hygiene in imports\n"
"\n"
"Similar to aliases, imports in Elixir are hygienic. Consider the\n"
"following code:\n"
"\n"
"    defmodule Hygiene do\n"
"      defmacrop get_size do\n"
"        quote do\n"
"          size(\"hello\")\n"
"        end\n"
"      end\n"
"\n"
"      def return_size do\n"
"        import Kernel, except: [size: 1]\n"
"        get_size\n"
"      end\n"
"    end\n"
"\n"
"    Hygiene.return_size #=> 5\n"
"\n"
"Notice how `return_size` returns 5 even though the `size/1`\n"
"function is not imported. In fact, even if `return_size` imported\n"
"a function from another module, it wouldn't affect the function\n"
"result:\n"
"\n"
"    def return_size do\n"
"      import Dict, only: [size: 1]\n"
"      get_size\n"
"    end\n"
"\n"
"Calling this new `return_size` will still return 5 as result.\n"
"\n"
"Elixir is smart enough to delay the resolution to the latest\n"
"moment possible. So, if you call `size(\"hello\")` inside quote,\n"
"but no `size/1` function is available, it is then expanded in\n"
"the caller:\n"
"\n"
"    defmodule Lazy do\n"
"      defmacrop get_size do\n"
"        import Kernel, except: [size: 1]\n"
"\n"
"        quote do\n"
"          size([a: 1, b: 2])\n"
"        end\n"
"      end\n"
"\n"
"      def return_size do\n"
"        import Kernel, except: [size: 1]\n"
"        import Dict, only: [size: 1]\n"
"        get_size\n"
"      end\n"
"    end\n"
"\n"
"    Lazy.return_size #=> 2\n"
"\n"
"## Stacktrace information\n"
"\n"
"When defining functions via macros, developers have the option of\n"
"choosing if runtime errors will be reported from the caller or from\n"
"inside the quote. Let's see an example:\n"
"\n"
"    # adder.ex\n"
"    defmodule Adder do\n"
"      @doc \"Defines a function that adds two numbers\"\n"
"      defmacro defadd do\n"
"        quote location: :keep do\n"
"          def add(a, b), do: a + b\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    # sample.ex\n"
"    defmodule Sample do\n"
"      import Adder\n"
"      defadd\n"
"    end\n"
"\n"
"When using `location: :keep` and invalid arguments are given to\n"
"`Sample.add/2`, the stacktrace information will point to the file\n"
"and line inside the quote. Without `location: :keep`, the error is\n"
"reported to where `defadd` was invoked. Note `location: :keep` affects\n"
"only definitions inside the quote.\n"
"\n"
"## Binding and unquote fragments\n"
"\n"
"Elixir quote/unquote mechanisms provides a functionality called\n"
"unquote fragments. Unquote fragments provide an easy way to generate\n"
"functions on the fly. Consider this example:\n"
"\n"
"    kv = [foo: 1, bar: 2]\n"
"    Enum.each kv, fn {k, v} ->\n"
"      def unquote(k)(), do: unquote(v)\n"
"    end\n"
"\n"
"In the example above, we have generated the functions `foo/0` and\n"
"`bar/0` dynamically. Now, imagine that, we want to convert this\n"
"functionality into a macro:\n"
"\n"
"    defmacro defkv(kv) do\n"
"      Enum.map kv, fn {k, v} ->\n"
"        quote do\n"
"          def unquote(k)(), do: unquote(v)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"We can invoke this macro as:\n"
"\n"
"    defkv [foo: 1, bar: 2]\n"
"\n"
"However, we can't invoke it as follows:\n"
"\n"
"    kv = [foo: 1, bar: 2]\n"
"    defkv kv\n"
"\n"
"This is because the macro is expecting its arguments to be a\n"
"keyword list at **compilation** time. Since in the example above\n"
"we are passing the representation of the variable `kv`, our\n"
"code fails.\n"
"\n"
"This is actually a common pitfall when developing macros. We are\n"
"assuming a particular shape in the macro. We can work around it\n"
"by unquoting the variable inside the quoted expression:\n"
"\n"
"    defmacro defkv(kv) do\n"
"      quote do\n"
"        Enum.each unquote(kv), fn {k, v} ->\n"
"          def unquote(k)(), do: unquote(v)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"If you try to run our new macro, you will notice it won't\n"
"even compile, complaining that the variables `k` and `v`\n"
"do not exist. This is because of the ambiguity: `unquote(k)`\n"
"can either be an unquote fragment, as previously, or a regular\n"
"unquote as in `unquote(kv)`.\n"
"\n"
"One solution to this problem is to disable unquoting in the\n"
"macro, however, doing that would make it impossible to inject the\n"
"`kv` representation into the tree. That's when the `:bind_quoted`\n"
"option comes to the rescue (again!). By using `:bind_quoted`, we\n"
"can automatically disable unquoting while still injecting the\n"
"desired variables into the tree:\n"
"\n"
"    defmacro defkv(kv) do\n"
"      quote bind_quoted: [kv: kv] do\n"
"        Enum.each kv, fn {k, v} ->\n"
"          def unquote(k)(), do: unquote(v)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"In fact, the `:bind_quoted` option is recommended every time\n"
"one desires to inject a value into the quote.\n"
msgstr ""
"任意の式の表現を取得します。\n"
"\n"
"## 例\n"
"\n"
"    quote do: sum(1, 2, 3)\n"
"    #=> {:sum, [], [1, 2, 3]}\n"
"\n"
"## 説明\n"
"\n"
"任意のElixirコードはElixirデータ構造を使って表現することができます。\n"
"Elixirマクロの素材は、3要素のタプルで、例えば:\n"
"\n"
"    {:sum, [], [1, 2, 3]}\n"
"\n"
"上のタプルは、`sum`を、引数として1, 2, 3を渡して関数呼び出していることを\n"
"表現しています。タプルの要素は以下の通りです:\n"
"\n"
"  * タプルの最初の要素は、通常アトムまたは、同様の表現の\n"
"    他のタプルです。\n"
"\n"
"  * タプルの2番目の要素は、メタデータを表現します。\n"
"\n"
"  * タプルの3番目の要素は、関数呼び出しの引数です。\n"
"    3番目の引数はアトムの場合があります。それは\n"
"    通常変数(またはローカル呼び出し)です。\n"
"\n"
"## オプション\n"
"\n"
"  * `:unquote` - falseの時、unquoteが無効になります。\n"
"    quoteの内側に他のquoteがあり、どのquoteをunquoteするかを\n"
"    制御したい時、便利です。\n"
"\n"
"  * `:location` -  `:keep`にセットする時、quoteされた\n"
"    現在の行とファイルを保存します。詳細は、\n"
"    スタックトレース情報セクションを\n"
"    参照してください。\n"
"\n"
"  * `:context` -  解決コンテキストをセットします。\n"
"\n"
"  * `:bind_quoted` - マクロにバインディングを渡します。\n"
"    バインディングが与えられたときはいつでも、`unquote`は自動的に\n"
"    無効になります。\n"
"\n"
"## リテラルのquote\n"
"\n"
"上で説明したタプルの他に、Elixirはquoteされたときそれ自身を返す、\n"
"少しのリテラルを持ちます。それは、以下の通りです:\n"
"\n"
"    :sum         #=> Atoms\n"
"    1            #=> Integers\n"
"    2.0          #=> Floats\n"
"    [1, 2]       #=> Lists\n"
"    \"strings\"    #=> Strings\n"
"    {key, value} #=> Tuples with two elements\n"
"\n"
"## quoteとマクロ\n"
"\n"
"`quote`はコード生成のためのマクロで一般的に用いられます。\n"
"演習として、数をそれ自身で乗算(二乗)するマクロを定義してみましょう。\n"
"そのようなマクロを定義する理由はない(そして、それは実は\n"
"悪い実践とみなされます)ことに気を付けてください。\n"
"しかし、quoteとマクロの重要な面に集中するのに、十分に単純です:\n"
"\n"
"    defmodule Math do\n"
"      defmacro squared(x) do\n"
"        quote do\n"
"          unquote(x) * unquote(x)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"それを以下のように起動できます:\n"
"\n"
"    import Math\n"
"    IO.puts \"Got #{squared(5)}\"\n"
"\n"
"最初は、それがマクロであることを実際に明かにすることは、この例には何も\n"
"ありません。しかし、起こっていることは、コンパイル時で、`squared(5)`が\n"
"`5 * 5`になったということです。引数`5`は生成されたコードで\n"
"複製される、私達のマクロには実際にはバグがありますが、\n"
"この振る舞いを見ることができます:\n"
"\n"
"    import Math\n"
"    my_number = fn ->\n"
"      IO.puts \"Returning 5\"\n"
"      5\n"
"    end\n"
"    IO.puts \"Got #{squared(my_number.())}\"\n"
"\n"
"上の例は以下のように表示されます:\n"
"\n"
"    Returning 5\n"
"    Returning 5\n"
"    25\n"
"\n"
"\"Returning 5\"が一度ではなく、どのようにして2度表示されたことに、\n"
"注意してください。\n"
"これは、マクロが値(通常の関数では値ですが)ではなく、式を受け取るためです。\n"
"この意味は:\n"
"\n"
"    squared(my_number.())\n"
"\n"
"実際には以下のように展開されます:\n"
"\n"
"    my_number.() * my_number.()\n"
"\n"
"なぜ2回値が表示されたについて説明して、2回関数を実行します! 大部分のケー\n"
"スで、これは実際に想定外の振る舞いで、マクロに関して、心にとめていく必\n"
"要がある最初のものの一つが、**同じ値を何度もunquoteしない**ことです。\n"
"\n"
"私達のマクロを修正しましょう:\n"
"\n"
"    defmodule Math do\n"
"      defmacro squared(x) do\n"
"        quote do\n"
"          x = unquote(x)\n"
"          x * x\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"今や前と同じように`square(my_number.())`を起動しても一度だけ\n"
"値が表示されます。\n"
"\n"
"実際、このパターンは一般的で、ほとんどの時に、\n"
"`quote`で`bind_quote`オプションを使いたくなるでしょう:\n"
"\n"
"    defmodule Math do\n"
"      defmacro squared(x) do\n"
"        quote bind_quoted: [x: x] do\n"
"          x * x\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"`:bind_quoted`は上の例では同じコードに翻訳します。`:bind_quoted`は多く\n"
"のケースで使え、良い実践と見做されています。それが一般的な間違いにぶつ\n"
"かることから私達を助けるからだけでなく、下のいくつかのセクションで論じ\n"
"られるunquoteフラグメントの様な、マクロによって公開される他のツールを導\n"
"入するのを許すからです。\n"
"\n"
"この短かい導入を終える前に、例えquoteの内側で変数`x`を定義すると、\n"
"以下のことに気付くでしょう:\n"
"\n"
"    quote do\n"
"      x = unquote(x)\n"
"      x * x\n"
"    end\n"
"\n"
"呼び出したとき:\n"
"\n"
"    import Math\n"
"    squared(5)\n"
"    x #=> ** (RuntimeError) undefined function or variable: x\n"
"\n"
"`x`はユーザコンテキストに漏れないことが分ります。これは\n"
"Elixirマクロは健全(hygienic)だからです。これは次のセクションで\n"
"同様に詳細に論ずるトピックです。\n"
"\n"
"## 変数の健全性(Hygiene in variables)\n"
"\n"
"以下の例を考えてください:\n"
"\n"
"    defmodule Hygiene do\n"
"      defmacro no_interference do\n"
"        quote do: a = 1\n"
"      end\n"
"    end\n"
"\n"
"    require Hygiene\n"
"\n"
"    a = 10\n"
"    Hygiene.no_interference\n"
"    a #=> 10\n"
"\n"
"上の例で、`a`は10を返します。\n"
"マクロが明かにそれを1に設定していますが、マクロの\n"
"中で定義された変数は、マクロを実行しているコンテキストに影響を\n"
"及ぼしません。\n"
"もし呼び出し側コンテキストで変数を設定あるいは取得したいなら、\n"
"`var!`マクロの助けを借りて、それをすることができます:\n"
"\n"
"    defmodule NoHygiene do\n"
"      defmacro interference do\n"
"        quote do: var!(a) = 1\n"
"      end\n"
"    end\n"
"\n"
"    require NoHygiene\n"
"\n"
"    a = 10\n"
"    NoHygiene.interference\n"
"    a #=> 1\n"
"\n"
"明示的にコンテキストを与えない限り、同じモジュールで定義された\n"
"変数へアクセスすることさえ出来無いことに、\n"
"注意してください:\n"
"\n"
"    defmodule Hygiene do\n"
"      defmacro write do\n"
"        quote do\n"
"          a = 1\n"
"        end\n"
"      end\n"
"\n"
"      defmacro read do\n"
"        quote do\n"
"          a\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    Hygiene.write\n"
"    Hygiene.read\n"
"    #=> ** (RuntimeError) undefined function or variable: a\n"
"\n"
"そのために、引数として現在のモジュールのスコープを明示的に渡す\n"
"ことが出来ます:\n"
"\n"
"    defmodule ContextHygiene do\n"
"      defmacro write do\n"
"        quote do\n"
"          var!(a, ContextHygiene) = 1\n"
"        end\n"
"      end\n"
"\n"
"      defmacro read do\n"
"        quote do\n"
"          var!(a, ContextHygiene)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    ContextHygiene.write\n"
"    ContextHygiene.read\n"
"    #=> 1\n"
"\n"
"## エイリアスの健全性(Hygiene in aliases)\n"
"\n"
"quoteの内側のエイリアスはデフォルトで健全です。\n"
"下の例を考えてください:\n"
"\n"
"    defmodule Hygiene do\n"
"      alias HashDict, as: D\n"
"\n"
"      defmacro no_interference do\n"
"        quote do: D.new\n"
"      end\n"
"    end\n"
"\n"
"    require Hygiene\n"
"    Hygiene.no_interference #=> #HashDict<[]>\n"
"\n"
"例えエイリアス`D`がコンテキストで無効でも、マクロが展開され、`D`がまだ\n"
"`HashDict`に展開されるので、上のコードは動くことに、注意してください。\n"
"\n"
"同様に、マクロを起動する前に、例え同じ名前でエイリアスを定義しても、そ\n"
"れはマクロの結果に影響を及ぼしません:\n"
"\n"
"    defmodule Hygiene do\n"
"      alias HashDict, as: D\n"
"\n"
"      defmacro no_interference do\n"
"        quote do: D.new\n"
"      end\n"
"    end\n"
"\n"
"    require Hygiene\n"
"    alias SomethingElse, as: D\n"
"    Hygiene.no_interference #=> #HashDict<[]>\n"
"\n"
"場合によっては、呼び出し側で、定義されたエイリアスまたはモジュールへ、\n"
"アクセスしたいこともあるでしょう。そのために、`alias!`マクロを使うことが\n"
"できます:\n"
"\n"
"    defmodule Hygiene do\n"
"      # This will expand to Elixir.Nested.hello\n"
"      defmacro no_interference do\n"
"        quote do: Nested.hello\n"
"      end\n"
"\n"
"      # This will expand to Nested.hello for\n"
"      # whatever is Nested in the caller\n"
"      defmacro interference do\n"
"        quote do: alias!(Nested).hello\n"
"      end\n"
"    end\n"
"\n"
"    defmodule Parent do\n"
"      defmodule Nested do\n"
"        def hello, do: \"world\"\n"
"      end\n"
"\n"
"      require Hygiene\n"
"      Hygiene.no_interference\n"
"      #=> ** (UndefinedFunctionError) ...\n"
"\n"
"      Hygiene.interference\n"
"      #=> \"world\"\n"
"    end\n"
"\n"
"## importの健全性(Hygiene in imports)\n"
"\n"
"エイリアスと同様に、Elixirのimportは健全です。以下のコードを\n"
"考えてください:\n"
"\n"
"    defmodule Hygiene do\n"
"      defmacrop get_size do\n"
"        quote do\n"
"          size(\"hello\")\n"
"        end\n"
"      end\n"
"\n"
"      def return_size do\n"
"        import Kernel, except: [size: 1]\n"
"        get_size\n"
"      end\n"
"    end\n"
"\n"
"    Hygiene.return_size #=> 5\n"
"\n"
"たとえ`size/1`関数がインポートされていないとしても、\n"
"`return_size`がどのように5を返したか注意してください。\n"
"実際、`return_size`が他のモジュールから関数をインポートしたと\n"
"しても、関数の結果には影響を及ぼしません:\n"
"\n"
"    def return_size do\n"
"      import Dict, only: [size: 1]\n"
"      get_size\n"
"    end\n"
"\n"
"この新しい`return_size`の呼び出しは、結果としてまだ5を返します。\n"
"\n"
"Elixirは、\n"
"可能な限り最新の瞬間まで解決を遅らせるため、十分スマートです。\n"
"それで、もしquoteの内部で`size(\"hello\")`を呼び出したら、\n"
"`size/1`関数が有効でないが、呼び出し側で展開されます:\n"
"\n"
"    defmodule Lazy do\n"
"      defmacrop get_size do\n"
"        import Kernel, except: [size: 1]\n"
"\n"
"        quote do\n"
"          size([a: 1, b: 2])\n"
"        end\n"
"      end\n"
"\n"
"      def return_size do\n"
"        import Kernel, except: [size: 1]\n"
"        import Dict, only: [size: 1]\n"
"        get_size\n"
"      end\n"
"    end\n"
"\n"
"    Lazy.return_size #=> 2\n"
"\n"
"## スタックトレース情報\n"
"\n"
"マクロによって関数を定義するとき、開発者は、\n"
"実行時エラーを呼び出し側からレポートされるか、\n"
"quoteの内部からレポートされるかを、選択するオプションを持っています。\n"
"例をみましょう:\n"
"\n"
"    # adder.ex\n"
"    defmodule Adder do\n"
"      @doc \"Defines a function that adds two numbers\"\n"
"      defmacro defadd do\n"
"        quote location: :keep do\n"
"          def add(a, b), do: a + b\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    # sample.ex\n"
"    defmodule Sample do\n"
"      import Adder\n"
"      defadd\n"
"    end\n"
"\n"
"`location: :keep`を使い、無効な引数が`Sample.add/2`に与えられた時、ス\n"
"タックトレース情報が、quoteの内部のファイルと行を示します。`location:\n"
":keep`なしでは、エラーは`defadd`が起動された場所でレポートされます。\n"
"`location: keep`は、quoteの内側の定義にのみ影響を及ぼすことに、注意して\n"
"ください。\n"
"\n"
"## Binding and unquote fragments\n"
"\n"
"Eliirのquote/unquoteメカニズムはunquoteフラグメントと呼ばれる機能を\n"
"提供します。\n"
"unquoteフラグメントは、自動的にその場で関数を生み出す簡単な\n"
"方法を提供します。この例を考えてください:\n"
"\n"
"    kv = [foo: 1, bar: 2]\n"
"    Enum.each kv, fn {k, v} ->\n"
"      def unquote(k)(), do: unquote(v)\n"
"    end\n"
"\n"
"上の例では、動的に関数`foo/0`と`bar/2`を生成しました。\n"
"今、この機能をマクロに変換したいと、想像してください:\n"
"\n"
"    defmacro defkv(kv) do\n"
"      Enum.map kv, fn {k, v} ->\n"
"        quote do\n"
"          def unquote(k)(), do: unquote(v)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"このマクロを以下のように起動できます:\n"
"\n"
"    defkv [foo: 1, bar: 2]\n"
"\n"
"しかしながら、以下のようには起動できません:\n"
"\n"
"    kv = [foo: 1, bar: 2]\n"
"    defkv kv\n"
"\n"
"これはマクロが **コンパイル時** に、引数がキーワードリストであることを\n"
"想定しているからです。上の例で、変数`kv`の表現を渡しているので、\n"
"コードは失敗します。\n"
"\n"
"マクロを開発するとき、これは実は一般的な落とし穴です。私達は、はマクロ\n"
"で特定の形を想定します。quoteされた式の中で、変数をunquoteすることで、\n"
"ワークアラウンドが出来ます:\n"
"\n"
"    defmacro defkv(kv) do\n"
"      quote do\n"
"        Enum.each unquote(kv), fn {k, v} ->\n"
"          def unquote(k)(), do: unquote(v)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"もし私達の新しいマクロを実行しようとするなら、\n"
"変数`k`と`v`が存在しないと不平をいわれ、コンパイルさえできない\n"
"ことに、気が付くでしょう。\n"
"これは、曖昧さのためです:\n"
"`unquote(k)`は、前のようにunquoteフラグメントでもあり、あるいは、\n"
"`unquote(kv)`のように標準のunquoteでもありえます。\n"
"\n"
"この問題の一つの解決法は、マクロでのunquoteを無効にすることで、\n"
"しかしながら、これは、ツリーの中へ`kv`表現の注入することを不可能にします。\n"
"これは、`:bind_quote`オプションが救出してくれます(再び!)。\n"
"`:bind_quoted`を使うことにより、ツリーに望み通りの変数を\n"
"注入する間、自動的にunquoteを無効にすることが出来ます:\n"
"\n"
"    defmacro defkv(kv) do\n"
"      quote bind_quoted: [kv: kv] do\n"
"        Enum.each kv, fn {k, v} ->\n"
"          def unquote(k)(), do: unquote(v)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"実際のところ、quoteに値を注入することを望むたびに、`:bind_quoted`オプショ\n"
"ンは推奨されます。\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms..(left, right)
#: lib/kernel/special_forms.ex:366
msgid ""
"Defines a remote call or an alias.\n"
"\n"
"The dot (`.`) in Elixir can be used for remote calls:\n"
"\n"
"    iex> String.downcase(\"FOO\")\n"
"    \"foo\"\n"
"\n"
"In this example above, we have used `.` to invoke `downcase` in the\n"
"`String` alias, passing \"FOO\" as argument. We can also use the dot\n"
"for creating aliases:\n"
"\n"
"    iex> Hello.World\n"
"    Hello.World\n"
"\n"
"This time, we have joined two aliases, defining the final alias\n"
"`Hello.World`.\n"
"\n"
"## Syntax\n"
"\n"
"The right side of `.` may be a word starting in upcase, which represents\n"
"an alias, a word starting with lowercase or underscore, any valid language\n"
"operator or any name wrapped in single- or double-quotes. Those are all "
"valid\n"
"examples:\n"
"\n"
"    iex> Kernel.Sample\n"
"    Kernel.Sample\n"
"\n"
"    iex> Kernel.length([1, 2, 3])\n"
"    3\n"
"\n"
"    iex> Kernel.+(1, 2)\n"
"    3\n"
"\n"
"    iex> Kernel.\"length\"([1, 2, 3])\n"
"    3\n"
"\n"
"    iex> Kernel.'+'(1, 2)\n"
"    3\n"
"\n"
"Note that `Kernel.\"HELLO\"` will be treated as a remote call and not an "
"alias.\n"
"This choice was done so every time single- or double-quotes are used, we "
"have\n"
"a remote call regardless of the quote contents. This decision is also "
"reflected\n"
"in the quoted expressions discussed below.\n"
"\n"
"## Quoted expression\n"
"\n"
"When `.` is used, the quoted expression may take two distinct\n"
"forms. When the right side starts with a lowercase letter (or\n"
"underscore):\n"
"\n"
"    iex> quote do: String.downcase(\"FOO\")\n"
"    {{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], "
"[\"FOO\"]}\n"
"\n"
"Notice we have an inner tuple, containing the atom `:.` representing\n"
"the dot as first element:\n"
"\n"
"    {:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}\n"
"\n"
"This tuple follows the general quoted expression structure in Elixir,\n"
"with the name as first argument, some keyword list as metadata as second,\n"
"and the number of arguments as third. In this case, the arguments is the\n"
"alias `String` and the atom `:downcase`. The second argument is **always**\n"
"an atom:\n"
"\n"
"    iex> quote do: String.\"downcase\"(\"FOO\")\n"
"    {{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], "
"[\"FOO\"]}\n"
"\n"
"The tuple containing `:.` is wrapped in another tuple, which actually\n"
"represents the function call, and has `\"FOO\"` as argument.\n"
"\n"
"When the right side is an alias (i.e. starts with uppercase), we get "
"instead:\n"
"\n"
"    iex> quote do: Hello.World\n"
"    {:__aliases__, [alias: false], [:Hello, :World]}\n"
"\n"
"We got into more details about aliases in the `__aliases__` special form\n"
"documentation.\n"
"\n"
"## Unquoting\n"
"\n"
"We can also use unquote to generate a remote call in a quoted expression:\n"
"\n"
"    iex> x = :downcase\n"
"    iex> quote do: String.unquote(x)(\"FOO\")\n"
"    {{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], "
"[\"FOO\"]}\n"
"\n"
"Similar to `Kernel.\"HELLO\"`, `unquote(x)` will always generate a remote "
"call,\n"
"independent of the value of `x`. To generate an alias via the quoted "
"expression,\n"
"one needs to rely on `Module.concat/2`:\n"
"\n"
"    iex> x = Sample\n"
"    iex> quote do: Module.concat(String, unquote(x))\n"
"    {{:., [], [{:__aliases__, [alias: false], [:Module]}, :concat]}, [],\n"
"     [{:__aliases__, [alias: false], [:String]}, Sample]}\n"
"\n"
msgstr ""
"リモート呼び出しかエイリアスを定義します。\n"
"\n"
"Elixirでのドット(`.`)は、リモート呼び出しに使われます:\n"
"\n"
"    iex> String.downcase(\"FOO\")\n"
"    \"foo\"\n"
"\n"
"上の例では、`.`を`String`エイリアスの`downcase`を引数として\"FOO\"を渡し、\n"
"起動するために使いました。ドットをエイリアスを作るためにも使うことが\n"
"できます:\n"
"\n"
"    iex> Hello.World\n"
"    Hello.World\n"
"\n"
"この時は、二つのエイリアスを結合し、最終的にエイリアス`Hello.World`を\n"
"定義しました。\n"
"\n"
"## 文法\n"
"\n"
"`.`の右側は以下の、エイリアス表現としての大文字で初まる単語、小文字か\n"
"下線で初まる単語、任意の有効な言語演算子あるいは、任意の単一、二重引用\n"
"符で囲まれた名前のいずれかです。\n"
"全ての有効な例です:\n"
"\n"
"    iex> Kernel.Sample\n"
"    Kernel.Sample\n"
"\n"
"    iex> Kernel.length([1, 2, 3])\n"
"    3\n"
"\n"
"    iex> Kernel.+(1, 2)\n"
"    3\n"
"\n"
"    iex> Kernel.\"length\"([1, 2, 3])\n"
"    3\n"
"\n"
"    iex> Kernel.'+'(1, 2)\n"
"    3\n"
"\n"
"`Kernel.\"HELLO\"`は、エイリアスではなく、リモート呼び出しとして扱われる\n"
"ことに、注意してください。この選択はされたので、単一または二重引用符が\n"
"使われたときは何時でも、引用された内容に関係なく、リモート呼び出しをし\n"
"ます。この決定は、以下に議論される、quoteされた式についても\n"
"反映されます。\n"
"\n"
"## quoteされた式\n"
"\n"
"`.`が使われた時、quoteされた式は二つの異ったフォームをとるかもしれませ\n"
"ん。右辺が小文字(または下線)で開始したとき:\n"
"\n"
"    iex> quote do: String.downcase(\"FOO\")\n"
"    {{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], [\"FOO\"]}\n"
"\n"
"最初の要素としてドットの表現であるアトム`:.`を含む内部のタプルを持つこ\n"
"とに、注意してください:\n"
"\n"
"    {:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}\n"
"\n"
"このタプルは、\n"
"Elixirの一般的なquoteされた式の構造である、\n"
"最初の引数として名前、2番目として、メタデータ\n"
"としてのいくつかのキーワードリスト、3番目として、いくつかの引数、\n"
"に従います。\n"
"この場合、引数はエイリアス`String`とアトム`:downcase`です。\n"
"2番目の引数は **常に** アトムです:\n"
"\n"
"    iex> quote do: String.\"downcase\"(\"FOO\")\n"
"    {{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], [\"FOO\"]}\n"
"\n"
"他のタプルにラップされた`:.`を含むタプルは、実際に\n"
"関数呼びだしを意味し、引数`\"FOO\"`を持ちます。\n"
"\n"
"右辺がエイリアスの時(即ち、大文字で初まる時)、そのかわりに以下を得ます:\n"
"\n"
"    iex> quote do: Hello.World\n"
"    {:__aliases__, [alias: false], [:Hello, :World]}\n"
"\n"
"aliasについての詳細は、`__alias__`スペシャルフォームのドキュメントで\n"
"得られます。\n"
"\n"
"## Unquoting\n"
"\n"
"quoteされた式で、リモート呼び出しを生成するために、unquoteを使うこともできます:\n"
"\n"
"    iex> x = :downcase\n"
"    iex> quote do: String.unquote(x)(\"FOO\")\n"
"    {{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], [\"FOO\"]}\n"
"\n"
"`Kernel.\"HELLO\"`と同様に、`unquote(x)`は、`x`の値に拘わらず、\n"
"常にリモート呼び出しを生成します。quoteされた式でエイリアスを生成するために、\n"
"`Module.concat/2`に頼る必要があります:\n"
"\n"
"    iex> x = Sample\n"
"    iex> quote do: Module.concat(String, unquote(x))\n"
"    {{:., [], [{:__aliases__, [alias: false], [:Module]}, :concat]}, [],\n"
"     [{:__aliases__, [alias: false], [:String]}, Sample]}\n"
"\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.<<>>(args)
#: lib/kernel/special_forms.ex:167
msgid ""
"Defines a new bitstring.\n"
"\n"
"## Examples\n"
"\n"
"    iex> << 1, 2, 3 >>\n"
"    << 1, 2, 3 >>\n"
"\n"
"## Types\n"
"\n"
"A bitstring is made of many segments and each segment has a\n"
"type. There are 9 types used in bitstrings:\n"
"\n"
"- `integer`\n"
"- `float`\n"
"- `bits` (alias for bitstring)\n"
"- `bitstring`\n"
"- `binary`\n"
"- `bytes` (alias for binary)\n"
"- `utf8`\n"
"- `utf16`\n"
"- `utf32`\n"
"\n"
"When no type is specified, the default is `integer`:\n"
"\n"
"    iex> <<1, 2, 3>>\n"
"    <<1, 2, 3>>\n"
"\n"
"Elixir also accepts by default the segment to be a literal\n"
"string or a literal char list, which are by expanded to integers:\n"
"\n"
"    iex> <<0, \"foo\">>\n"
"    <<0, 102, 111, 111>>\n"
"\n"
"Variables or any other type need to be explicitly tagged:\n"
"\n"
"    iex> rest = \"oo\"\n"
"    iex> <<102, rest>>\n"
"    ** (ArgumentError) argument error\n"
"\n"
"We can solve this by explicitly tagging it as a binary:\n"
"\n"
"    iex> rest = \"oo\"\n"
"    iex> <<102, rest :: binary>>\n"
"    \"foo\"\n"
"\n"
"The utf8, utf16, and utf32 types are for unicode codepoints. They\n"
"can also be applied to literal strings and char lists:\n"
"\n"
"    iex> <<\"foo\" :: utf16>>\n"
"    <<0, 102, 0, 111, 0, 111>>\n"
"    iex> <<\"foo\" :: utf32>>\n"
"    <<0, 0, 0, 102, 0, 0, 0, 111, 0, 0, 0, 111>>\n"
"\n"
"## Options\n"
"\n"
"Many options can be given by using `-` as separator. Order is\n"
"arbitrary, so the following are all equivalent:\n"
"\n"
"    <<102 :: integer-native, rest :: binary>>\n"
"    <<102 :: native-integer, rest :: binary>>\n"
"    <<102 :: unsigned-big-integer, rest :: binary>>\n"
"    <<102 :: unsigned-big-integer-size(8), rest :: binary>>\n"
"    <<102 :: unsigned-big-integer-8, rest :: binary>>\n"
"    <<102 :: 8-integer-big-unsigned, rest :: binary>>\n"
"    <<102, rest :: binary>>\n"
"\n"
"### Unit and Size\n"
"\n"
"The length of the match is equal to the `unit` (a number of bits) times the\n"
"`size` (the number of repeated segnments of length `unit`).\n"
"\n"
"Type      | Default Unit\n"
"--------- | ------------\n"
"`integer` | 1 bit\n"
"`float`   | 1 bit\n"
"`binary`  | 8 bits\n"
"\n"
"Sizes for types are a bit more nuanced. The default size for integers is 8.\n"
"\n"
"For floats, it is 64. For floats, `size * unit` must result in 32 or 64,\n"
"corresponding to [IEEE 754](https://en.wikipedia.org/wiki/"
"IEEE_floating_point)\n"
"binary32 and binary64, respectively.\n"
"\n"
"For binaries, the default is the size of the binary. Only the last binary in "
"a\n"
"match can use the default size. All others must have their size specified\n"
"explicitly, even if the match is unambiguous. For example:\n"
"\n"
"    iex> <<name::binary-size(5), \" the \", species::binary>> = <<\"Frank "
"the Walrus\">>\n"
"    \"Frank the Walrus\"\n"
"    iex> {name, species}\n"
"    {\"Frank\", \"Walrus\"}\n"
"\n"
"Failing to specify the size for the non-last causes compilation to fail:\n"
"\n"
"    <<name::binary, \" the \", species::binary>> = <<\"Frank the Walrus\">>\n"
"    ** (CompileError): a binary field without size is only allowed at the "
"end of a binary pattern\n"
"\n"
"#### Shortcut Syntax\n"
"\n"
"Size and unit can also be specified using a syntax shortcut\n"
"when passing integer values:\n"
"\n"
"    iex> x = 1\n"
"    iex> << x :: 8 >> == << x :: size(8) >>\n"
"    true\n"
"    iex> << x :: 8 * 4 >> == << x :: size(8)-unit(4) >>\n"
"    true\n"
"\n"
"This syntax reflects the fact the effective size is given by\n"
"multiplying the size by the unit.\n"
"\n"
"### Modifiers\n"
"\n"
"Some types have associated modifiers to clear up ambiguity in byte\n"
"representation.\n"
"\n"
"Modifier             | Relevant Type(s)\n"
"-------------------- | ----------------\n"
"`signed`             | `integer`\n"
"`unsigned` (default) | `integer`\n"
"`little`             | `integer`, `utf16`, `utf32`\n"
"`big` (default)      | `integer`, `utf16`, `utf32`\n"
"`native`             | `integer`, `utf16`, `utf32`\n"
"\n"
"### Sign\n"
"\n"
"Integers can be `signed` or `unsigned`, defaulting to `unsigned`.\n"
"\n"
"    iex> <<int::integer>> =  <<-100>>\n"
"    <<156>>\n"
"    iex> int\n"
"    156\n"
"    iex> <<int::integer-signed>> =  <<-100>>\n"
"    <<156>>\n"
"    iex> int\n"
"    -100\n"
"\n"
"`signed` and `unsigned` are only used for matching binaries (see below) and\n"
"are only used for integers.\n"
"\n"
"    iex> <<-100 :: signed, _rest :: binary>> = <<-100, \"foo\">>\n"
"    <<156, 102, 111, 111>>\n"
"\n"
"### Endianness\n"
"\n"
"Elixir has three options for endianness: `big`, `little`, and `native`.\n"
"The default is `big`:\n"
"\n"
"    iex> <<number::little-integer-size(16)>> = <<0, 1>>\n"
"    <<0, 1>>\n"
"    iex> number\n"
"    256\n"
"    iex> <<number::big-integer-size(16)>> = <<0, 1>>\n"
"    <<0, 1>>\n"
"    iex> number\n"
"    1\n"
"\n"
"`native` is determined by the VM at startup and will depend on the\n"
"host operating system.\n"
"\n"
"## Binary/Bitstring Matching\n"
"\n"
"Binary matching is a powerful feature in Elixir that is useful for "
"extracting\n"
"information from binaries as well as pattern matching.\n"
"\n"
"Binary matching can be used by itself to extract information from binaries:\n"
"\n"
"    iex> <<\"Hello, \", place::binary>> = \"Hello, World\"\n"
"    \"Hello, World\"\n"
"    iex> place\n"
"    \"World\"\n"
"\n"
"Or as a part of function definitions to pattern match:\n"
"\n"
"    defmodule ImageTyper\n"
"      @png_signature <<137::size(8), 80::size(8), 78::size(8), 71::size(8),\n"
"                    13::size(8), 10::size(8), 26::size(8), 10::size(8)>>\n"
"      @jpg_signature <<255::size(8), 216::size(8)>>\n"
"\n"
"      def type(<<@png_signature, rest::binary>>), do: :png\n"
"      def type(<<@jpg_signature, rest::binary>>), do: :jpg\n"
"      def type(_), do :unknown\n"
"    end\n"
"\n"
"### Performance & Optimizations\n"
"\n"
"The Erlang compiler can provide a number of optimizations on binary "
"creation\n"
"and matching. To see optimization output, set the `bin_opt_info` compiler\n"
"option:\n"
"\n"
"    ERL_COMPILER_OPTIONS=bin_opt_info mix compile\n"
"\n"
"To learn more about specific optimizations and performance considerations,\n"
"check out\n"
"[Erlang's Efficiency Guide on handling binaries](http://www.erlang.org/doc/"
"efficiency_guide/binaryhandling.html).\n"
msgstr ""
"新しいbitstringを定義します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> << 1, 2, 3 >>\n"
"    << 1, 2, 3 >>\n"
"\n"
"## Types\n"
"\n"
"bitstringは多くのセグメントで出来ています。それぞれのセグメントは\n"
"タイプを持っています。bitstringでは9個のタイプが使われます:\n"
"\n"
"- `integer`\n"
"- `float`\n"
"- `bits` (alias for bitstring)\n"
"- `bitstring`\n"
"- `binary`\n"
"- `bytes` (alias for binary)\n"
"- `utf8`\n"
"- `utf16`\n"
"- `utf32`\n"
"\n"
"タイプが指定されないと、デフォルトは`integer`です:\n"
"\n"
"    iex> <<1, 2, 3>>\n"
"    <<1, 2, 3>>\n"
"\n"
"Elixirはリテラル文字列あるいはリテラル文字のリストのセグメントも\n"
"デフォルトで受け付け、整数に展開されます:\n"
"\n"
"    iex> <<0, \"foo\">>\n"
"    <<0, 102, 111, 111>>\n"
"\n"
"変数または他のタイプは明示的にタグが必要です:\n"
"\n"
"    iex> rest = \"oo\"\n"
"    iex> <<102, rest>>\n"
"    ** (ArgumentError) argument error\n"
"\n"
"これは、binaryとして明示的にタグ付することで解決できます:\n"
"\n"
"    iex> rest = \"oo\"\n"
"    iex> <<102, rest :: binary>>\n"
"    \"foo\"\n"
"\n"
"utf8, utf16, utf32タイプはunicodeコードポイントです。\n"
"それらはリテラルの文字列と文字リストにも適用できます:\n"
"\n"
"    iex> <<\"foo\" :: utf16>>\n"
"    <<0, 102, 0, 111, 0, 111>>\n"
"    iex> <<\"foo\" :: utf32>>\n"
"    <<0, 0, 0, 102, 0, 0, 0, 111, 0, 0, 0, 111>>\n"
"\n"
"## Options\n"
"\n"
"多くのオプションを`-`で区切って与えることができます。\n"
"順序は任意ですので、以下は全て同等です:\n"
"\n"
"    <<102 :: integer-native, rest :: binary>>\n"
"    <<102 :: native-integer, rest :: binary>>\n"
"    <<102 :: unsigned-big-integer, rest :: binary>>\n"
"    <<102 :: unsigned-big-integer-size(8), rest :: binary>>\n"
"    <<102 :: unsigned-big-integer-8, rest :: binary>>\n"
"    <<102 :: 8-integer-big-unsigned, rest :: binary>>\n"
"    <<102, rest :: binary>>\n"
"\n"
"### Unit and Size\n"
"\n"
"マッチの流さは、`unit`(bitの数) × `size`(`unit`の長さのセグメント\n"
"の繰り返しの数)に等しいです。\n"
"\n"
"Type      | Default Unit\n"
"--------- | ------------\n"
"`integer` | 1 bit\n"
"`float`   | 1 bit\n"
"`binary`  | 8 bits\n"
"\n"
"タイプのサイズはもう少し微妙です。integerのための\n"
"デフォルトのサイズは8です。\n"
"\n"
"floatは64です。floatでは、`size * unit`は 32 か 64で、それぞれ\n"
"[IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point)の\n"
"binary32かbinary64に一致していなければなりません。\n"
"\n"
"binaryではデフォルトはバイナリのサイズです。\n"
"マッチの最後のbinaryはデフォルトのサイズを使うことができます。\n"
"他の全ては明示的に指定されたサイズでなければならず、\n"
"曖昧とならないようにしなければなりません。例えば:\n"
"\n"
"    iex> <<name::binary-size(5), \" the \", species::binary>> = <<\"Frank the Walrus\">>\n"
"    \"Frank the Walrus\"\n"
"    iex> {name, species}\n"
"    {\"Frank\", \"Walrus\"}\n"
"\n"
"最後でないものにサイズをしていしないことはコンパイルの失敗の原因になります:\n"
"\n"
"    <<name::binary, \" the \", species::binary>> = <<\"Frank the Walrus\">>\n"
"    ** (CompileError): a binary field without size is only allowed at the end of a binary pattern\n"
"\n"
"#### Shortcut Syntax\n"
"\n"
"サイズとユニットは整数を渡して、\n"
"シンタックスショートカットを使って指定することができます:\n"
"\n"
"    iex> x = 1\n"
"    iex> << x :: 8 >> == << x :: size(8) >>\n"
"    true\n"
"    iex> << x :: 8 * 4 >> == << x :: size(8)-unit(4) >>\n"
"    true\n"
"\n"
"これはサイズがユニットの乗算によって得られるという事実を\n"
"反映しています。\n"
"\n"
"### Modifiers\n"
"\n"
"いくつかのタイプはバイト表現の曖昧さをクリアに\n"
"するため関連した修飾子をもってます。\n"
"\n"
"Modifier             | Relevant Type(s)\n"
"-------------------- | ----------------\n"
"`signed`             | `integer`\n"
"`unsigned` (default) | `integer`\n"
"`little`             | `integer`, `utf16`, `utf32`\n"
"`big` (default)      | `integer`, `utf16`, `utf32`\n"
"`native`             | `integer`, `utf16`, `utf32`\n"
"\n"
"### Sign\n"
"\n"
"integerは`signed`または`unsigned`です。デフォルトは\n"
"`unsigned`です。\n"
"\n"
"    iex> <<int::integer>> =  <<-100>>\n"
"    <<156>>\n"
"    iex> int\n"
"    156\n"
"    iex> <<int::integer-signed>> =  <<-100>>\n"
"    <<156>>\n"
"    iex> int\n"
"    -100\n"
"\n"
"`signed`と`unsigned`はバイナリのマッチング(以下参照)とintegerのとき\n"
"だけ使われます。\n"
"\n"
"    iex> <<-100 :: signed, _rest :: binary>> = <<-100, \"foo\">>\n"
"    <<156, 102, 111, 111>>\n"
"\n"
"### Endianness\n"
"\n"
"Elixirはエンディアンに三つのオプションを持っています: `bit`, `little`と\n"
"`native`です。デフォルトは`bit`です:\n"
"\n"
"    iex> <<number::little-integer-size(16)>> = <<0, 1>>\n"
"    <<0, 1>>\n"
"    iex> number\n"
"    256\n"
"    iex> <<number::big-integer-size(16)>> = <<0, 1>>\n"
"    <<0, 1>>\n"
"    iex> number\n"
"    1\n"
"\n"
"`native`は開始時に、ホストオペレーティングシステムに\n"
"依存してVMにより決定されます。\n"
"\n"
"## Binary/Bitstring Matching\n"
"\n"
"バイナリマッチングは、\n"
"パターンマッチングと同じようにバイナリから情報を抽出する\n"
"Elixirの強力な機能です。\n"
"\n"
"バイナリマッチングはバイナリから情報を抽出ためにそれ自身を\n"
"使うこともできます:\n"
"\n"
"    iex> <<\"Hello, \", place::binary>> = \"Hello, World\"\n"
"    \"Hello, World\"\n"
"    iex> place\n"
"    \"World\"\n"
"\n"
"あるいは、パターンマッチの関数定義の一部分としても\n"
"使うことができます:\n"
"\n"
"    defmodule ImageTyper\n"
"      @png_signature <<137::size(8), 80::size(8), 78::size(8), 71::size(8),\n"
"                    13::size(8), 10::size(8), 26::size(8), 10::size(8)>>\n"
"      @jpg_signature <<255::size(8), 216::size(8)>>\n"
"\n"
"      def type(<<@png_signature, rest::binary>>), do: :png\n"
"      def type(<<@jpg_signature, rest::binary>>), do: :jpg\n"
"      def type(_), do :unknown\n"
"    end\n"
"\n"
"### Performance & Optimizations\n"
"\n"
"Erlangコンパイラはバイナリの作成とマッチングに多くの最適化を\n"
"提供しています。最適化出力は、`bin_opt_info`コンパイラ\n"
"オプションで見ることができます:\n"
"\n"
"    ERL_COMPILER_OPTIONS=bin_opt_info mix compile\n"
"\n"
"歳迪化の指定とパフォーマンスの考慮点については、\n"
"[Erlang's Efficiency Guide on handling binaries](http://www.erlang.org/doc/efficiency_guide/binaryhandling.html)\n"
"を参照してください。\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.fn(clauses)
#: lib/kernel/special_forms.ex:1293
msgid ""
"Defines an anonymous function.\n"
"\n"
"## Examples\n"
"\n"
"    iex> add = fn a, b -> a + b end\n"
"    iex> add.(1, 2)\n"
"    3\n"
"\n"
msgstr ""
"無名関数を定義します。\n"
"\n"
"## 例\n"
"\n"
"    iex> add = fn a, b -> a + b end\n"
"    iex> add.(1, 2)\n"
"    3\n"
"\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.{}(args)
#: lib/kernel/special_forms.ex:22
msgid ""
"Creates a tuple.\n"
"\n"
"Only two item tuples are considered literals in Elixir.\n"
"Therefore all other tuples are represented in the AST\n"
"as a call to the special form `:{}`.\n"
"\n"
"Conveniences for manipulating tuples can be found in the\n"
"`Tuple` module. Some functions for working with tuples are\n"
"also available in `Kernel`, namely `Kernel.elem/2`,\n"
"`Kernel.put_elem/3` and `Kernel.tuple_size/1`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> {1, 2, 3}\n"
"    {1, 2, 3}\n"
"\n"
"    iex> quote do: {1, 2, 3}\n"
"    {:{}, [], [1, 2, 3]}\n"
"\n"
msgstr ""
"タプルを作成します。\n"
"\n"
"2要素のタプルのみがElixirのリテラルと考えれれます。\n"
"従って、他の全てのタプルはスペシャルフォーム`:{}`への\n"
"呼び出しとしてASTにおいて表現されます。\n"
"\n"
"タプルを操作するための利器は`Tuple`モジュールで見付けることができます。\n"
"タプルで働くいくつかの関数は`Kernel`(すなわち、`Kernel.elem/2`、\n"
"`Kernel.put_elem/3`、`Kernel.tuple_size/1`)でも利用できます。\n"
"\n"
"## 例\n"
"\n"
"    iex> {1, 2, 3}\n"
"    {1, 2, 3}\n"
"\n"
"    iex> quote do: {1, 2, 3}\n"
"    {:{}, [], [1, 2, 3]}\n"
"\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.%(struct, map)
#: lib/kernel/special_forms.ex:105
msgid ""
"Creates a struct.\n"
"\n"
"A struct is a tagged map that allows developers to provide\n"
"default values for keys, tags to be used in polymorphic\n"
"dispatches and compile time assertions.\n"
"\n"
"To define a struct, you just need to implement the `__struct__/0`\n"
"function in a module:\n"
"\n"
"    defmodule User do\n"
"      def __struct__ do\n"
"        %{name: \"john\", age: 27}\n"
"      end\n"
"    end\n"
"\n"
"In practice though, structs are usually defined with the\n"
"`Kernel.defstruct/1` macro:\n"
"\n"
"    defmodule User do\n"
"      defstruct name: \"john\", age: 27\n"
"    end\n"
"\n"
"Now a struct can be created as follows:\n"
"\n"
"    %User{}\n"
"\n"
"Underneath a struct is just a map with a `__struct__` field\n"
"pointing to the `User` module:\n"
"\n"
"    %User{} == %{__struct__: User, name: \"john\", age: 27}\n"
"\n"
"A struct also validates that the given keys are part of the defined\n"
"struct. The example below will fail because there is no key\n"
"`:full_name` in the `User` struct:\n"
"\n"
"    %User{full_name: \"john doe\"}\n"
"\n"
"Note that a struct specifies a minimum set of keys required\n"
"for operations. Other keys can be added to structs via the\n"
"regular map operations:\n"
"\n"
"    user = %User{}\n"
"    Map.put(user, :a_non_struct_key, :value)\n"
"\n"
"An update operation specific for structs is also available:\n"
"\n"
"    %User{user | age: 28}\n"
"\n"
"The syntax above will guarantee the given keys are valid at\n"
"compilation time and it will guarantee at runtime the given\n"
"argument is a struct, failing with `BadStructError` otherwise.\n"
"\n"
"Although structs are maps, by default structs do not implement\n"
"any of the protocols implemented for maps. Check\n"
"`Kernel.defprotocol/2` for more information on how structs\n"
"can be used with protocols for polymorphic dispatch. Also\n"
"see `Kernel.struct/2` for examples on how to create and update\n"
"structs dynamically.\n"
msgstr ""
"構造体を作成します。\n"
"\n"
"構造体は、開発者にキーのデフォルト値を提供し、\n"
"ポリモーフィックにディスパッチされ、コンパイル時に\n"
"アサーションされる、タグづけされたマップです。\n"
"\n"
"構造体を定義するために、モジュールで関数`__struct__/0`を実装する必要が\n"
"あります:\n"
"\n"
"    defmodule User do\n"
"      def __struct__ do\n"
"        %{name: \"john\", age: 27}\n"
"      end\n"
"    end\n"
"\n"
"しかし実践的には、構造体は通常`Kernel.defstruct/1`マクロで定義されます:\n"
"\n"
"    defmodule User do\n"
"      defstruct name: \"john\", age: 27\n"
"    end\n"
"\n"
"今や、構造体は以下のように作成することができます:\n"
"\n"
"    %User{}\n"
"\n"
"構造体の下には、`__struct__`フィールドが`User`モジュールを示しているマップ\n"
"があります:\n"
"\n"
"    %User{} == %{__struct__: User, name: \"john\", age: 27}\n"
"\n"
"構造体は、所定のキーが定義済の構造体の一部であることの確認もします。\n"
"下の例は、`User`構造体には`:full_name`キーがないので、\n"
"失敗します:\n"
"\n"
"    %User{full_name: \"john doe\"}\n"
"\n"
"構造体は、操作のために必要とされるキーの最小限のセットを指定することに、\n"
"注意してください。他のキーは標準のマップ操作により追加できます:\n"
"\n"
"    user = %User{}\n"
"    Map.put(user, :a_non_struct_key, :value)\n"
"\n"
"構造体に特有の更新操作も利用できます:\n"
"\n"
"    %User{user | age: 28}\n"
"\n"
"上の構文は、与えられたキーがコンパイル時に有効であることを保証し、\n"
"実行時に与えられた引数が構造体であることを保証します。\n"
"さもなくば、`BadStructError`で失敗します。\n"
"\n"
"構造体はマップですが、デフォルトで構造体はマップのために実装されるべき、\n"
"いかなるプロトコルも実装していません。ポリモーフィックなディスパッチの\n"
"ために、プロトコルがどのように使われるかの詳細は、\n"
"`Kernel.defprotocol/2`をチェックしてください。どのように構造体を動的に\n"
"作成して更新するかの例については、`Kernel.struct/2`も参照してください。\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.%{}(args)
#: lib/kernel/special_forms.ex:45
msgid ""
"Creates a map.\n"
"\n"
"Maps are key-value stores where keys are compared\n"
"using the match operator (`===`). Maps can be created with\n"
"the `%{}` special form where keys are associated via `=>`:\n"
"\n"
"    %{1 => 2}\n"
"\n"
"Maps also support the keyword notation, as other special forms,\n"
"as long as they are at the end of the argument list:\n"
"\n"
"    %{hello: :world, with: :keywords}\n"
"    %{:hello => :world, with: :keywords}\n"
"\n"
"If a map has duplicated keys, the last key will always have\n"
"higher precedence:\n"
"\n"
"    iex> %{a: :b, a: :c}\n"
"    %{a: :c}\n"
"\n"
"Conveniences for manipulating maps can be found in the\n"
"`Map` module.\n"
"\n"
"## Access syntax\n"
"\n"
"Besides the access functions available in the `Map` module,\n"
"like `Map.get/3` and `Map.fetch/2`, a map can be accessed using the\n"
"`.` operator:\n"
"\n"
"    iex> map = %{a: :b}\n"
"    iex> map.a\n"
"    :b\n"
"\n"
"Note that the `.` operator expects the field to exist in the map.\n"
"If not, an `ArgumentError` is raised.\n"
"\n"
"## Update syntax\n"
"\n"
"Maps also support an update syntax:\n"
"\n"
"    iex> map = %{:a => :b}\n"
"    iex> %{map | :a => :c}\n"
"    %{:a => :c}\n"
"\n"
"Notice the update syntax requires the given keys to exist.\n"
"Trying to update a key that does not exist will raise an `ArgumentError`.\n"
"\n"
"## AST representation\n"
"\n"
"Regardless if `=>` or the keywords syntax is used, Maps are\n"
"always represented internally as a list of two-items tuples\n"
"for simplicity:\n"
"\n"
"    iex> quote do: %{:a => :b, c: :d}\n"
"    {:%{}, [], [{:a, :b}, {:c, :d}]}\n"
"\n"
msgstr ""
"マップを作成します。\n"
"\n"
"マップは、キーをマッチオペレータ(`===`)で比較する、\n"
"キーバリューストアです。マップは、キーを`=>`で関連付けた\n"
"`%{}`スペシャルフォームで、作成することができます:\n"
"\n"
"    %{1 => 2}\n"
"\n"
"引数リストの終わりにいる限り、マップは、他のスペシャルフォーム\n"
"として、キーワード記法もサポートします:\n"
"\n"
"    %{hello: :world, with: :keywords}\n"
"    %{:hello => :world, with: :keywords}\n"
"\n"
"もしマップが重複したキーをもったら、最後のキーが常に高い優先度を持ちま\n"
"す:\n"
"\n"
"    iex> %{a: :b, a: :c}\n"
"    %{a: :c}\n"
"\n"
"マップ操作のための便利さは`Map`モジュールで見付けることができます。\n"
"\n"
"## アクセス構文\n"
"\n"
"`Map.get/3`や`Map.fetch/2`のような、`Map`モジュールで有効なアクセス関数\n"
"の他に、マップは`.`オペレータを使ってアクセスすることが出来ます:\n"
"\n"
"    iex> map = %{a: :b}\n"
"    iex> map.a\n"
"    :b\n"
"\n"
"なお、`.`オペレータはマップの中にフィールドが存在することを期待してます。\n"
"もしないなら、`ArgumentError`が上ります。\n"
"\n"
"## 更新構文\n"
"\n"
"マップは更新構文もサポートします:\n"
"\n"
"    iex> map = %{:a => :b}\n"
"    iex> %{map | :a => :c}\n"
"    %{:a => :c}\n"
"\n"
"更新構文は、与えられたキーが存在することを要求することに、\n"
"注意してください。\n"
"存在しないキーを更新しようとすると、`ArgumentError`が上ります。\n"
"\n"
"## AST表現\n"
"\n"
"`=>`またはキーワード構文が使われたかを気にせずに、マップは、\n"
"常に内部的には単純さの為に2要素のタプルのリストとして表現されます:\n"
"\n"
"    iex> quote do: %{:a => :b, c: :d}\n"
"    {:%{}, [], [{:a, :b}, {:c, :d}]}\n"
"\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.for(args)
#: lib/kernel/special_forms.ex:1225
msgid ""
"Comprehensions allow you to quickly build a data structure from\n"
"an enumerable or a bitstring.\n"
"\n"
"Let's start with an example:\n"
"\n"
"    iex> for n <- [1, 2, 3, 4], do: n * 2\n"
"    [2, 4, 6, 8]\n"
"\n"
"A comprehension accepts many generators and filters. Enumerable\n"
"generators are defined using `<-`:\n"
"\n"
"    # A list generator:\n"
"    iex> for n <- [1, 2, 3, 4], do: n * 2\n"
"    [2, 4, 6, 8]\n"
"\n"
"    # A comprehension with two generators\n"
"    iex> for x <- [1, 2], y <- [2, 3], do: x*y\n"
"    [2, 3, 4, 6]\n"
"\n"
"Filters can also be given:\n"
"\n"
"    # A comprehension with a generator and a filter\n"
"    iex> for n <- [1, 2, 3, 4, 5, 6], rem(n, 2) == 0, do: n\n"
"    [2, 4, 6]\n"
"\n"
"Note generators can also be used to filter as it removes any value\n"
"that doesn't match the left side of `<-`:\n"
"\n"
"    iex> for {:user, name} <- [user: \"john\", admin: \"john\", user: \"meg"
"\"] do\n"
"    ...>   String.upcase(name)\n"
"    ...> end\n"
"    [\"JOHN\", \"MEG\"]\n"
"\n"
"Bitstring generators are also supported and are very useful when you\n"
"need to organize bitstring streams:\n"
"\n"
"    iex> pixels = <<213, 45, 132, 64, 76, 32, 76, 0, 0, 234, 32, 15>>\n"
"    iex> for <<r::8, g::8, b::8 <- pixels >>, do: {r, g, b}\n"
"    [{213, 45, 132}, {64, 76, 32}, {76, 0, 0}, {234, 32, 15}]\n"
"\n"
"Variable assignments inside the comprehension, be it in generators,\n"
"filters or inside the block, are not reflected outside of the\n"
"comprehension.\n"
"\n"
"## Into\n"
"\n"
"In the examples above, the result returned by the comprehension was\n"
"always a list. The returned result can be configured by passing an\n"
"`:into` option, that accepts any structure as long as it implements\n"
"the `Collectable` protocol.\n"
"\n"
"For example, we can use bitstring generators with the `:into` option\n"
"to easily remove all spaces in a string:\n"
"\n"
"    iex> for <<c <- \" hello world \">>, c != ?\\s, into: \"\", do: <<c>>\n"
"    \"helloworld\"\n"
"\n"
"The `IO` module provides streams, that are both `Enumerable` and\n"
"`Collectable`, here is an upcase echo server using comprehensions:\n"
"\n"
"    for line <- IO.stream(:stdio, :line), into: IO.stream(:stdio, :line) do\n"
"      String.upcase(line)\n"
"    end\n"
"\n"
msgstr ""
"内包はenumerableやbitstringから素早くデータ構造を構築することができます。\n"
"\n"
"例から始めてみましょう:\n"
"\n"
"    iex> for n <- [1, 2, 3, 4], do: n * 2\n"
"    [2, 4, 6, 8]\n"
"\n"
"内包は多くのジェネレータとフィルタを受け付けます。enumerableジェネレー\n"
"タは`<-`を使って定義されています:\n"
"\n"
"    # リストジェネレータ:\n"
"    iex> for n <- [1, 2, 3, 4], do: n * 2\n"
"    [2, 4, 6, 8]\n"
"\n"
"    # 二つのジェネレータを持つ内包\n"
"    iex> for x <- [1, 2], y <- [2, 3], do: x*y\n"
"    [2, 3, 4, 6]\n"
"\n"
"フィルタを与えることもできます:\n"
"\n"
"    # ジェネレータとフィルタを持つ内包\n"
"    iex> for n <- [1, 2, 3, 4, 5, 6], rem(n, 2) == 0, do: n\n"
"    [2, 4, 6]\n"
"\n"
"ジェネレータは、`<-`の左辺にマッチしない値を全て削除するので、\n"
"フィルタとして使われることもあることに、\n"
"注意してください:\n"
"\n"
"    iex> for {:user, name} <- [user: \"john\", admin: \"john\", user: \"meg\"] do\n"
"    ...>   String.upcase(name)\n"
"    ...> end\n"
"    [\"JOHN\", \"MEG\"]\n"
"\n"
"bitstringジェネレータもまたサポートされていて、bitstringストリーム\n"
"を組織する必要があるときに非常に便利です:\n"
"\n"
"    iex> pixels = <<213, 45, 132, 64, 76, 32, 76, 0, 0, 234, 32, 15>>\n"
"    iex> for <<r::8, g::8, b::8 <- pixels >>, do: {r, g, b}\n"
"    [{213, 45, 132}, {64, 76, 32}, {76, 0, 0}, {234, 32, 15}]\n"
"\n"
"内包の内側での変数代入は、ジェネレータ、フィルタ、またはブロックの内側\n"
"で使えますが、内包の外側には反映されません。\n"
"\n"
"## Into\n"
"\n"
"上の例では、内包により返された結果は通常リストでした。戻り値は\n"
"`:into`オプションを渡すことによって構成することができます。\n"
"`:into`オプションは、`Collectable`プロトコルを実装するかぎり、\n"
"任意の構造を受け付けます。\n"
"\n"
"例えば、文字列から全ての空白を簡単に削除するために、\n"
"`:into`オプション付きのbitstringジェネレータを使うことができます:\n"
"\n"
"    iex> for <<c <- \" hello world \">>, c != ?\\s, into: \"\", do: <<c>>\n"
"    \"helloworld\"\n"
"\n"
"`IO`モジュールは、`Enumerable`と`Collectable`の両方である、\n"
"ストリームを提供します。以下は、内包を使った大文字化エコーサーバです:\n"
"\n"
"    for line <- IO.stream(:stdio, :line), into: IO.stream(:stdio, :line) do\n"
"      String.upcase(line)\n"
"    end\n"
"\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.&(expr)
#: lib/kernel/special_forms.ex:1318
msgid ""
"Captures or creates an anonymous function.\n"
"\n"
"## Capture\n"
"\n"
"The capture operator is most commonly used to capture a\n"
"function with given name and arity from a module:\n"
"\n"
"    iex> fun = &Kernel.is_atom/1\n"
"    iex> fun.(:atom)\n"
"    true\n"
"    iex> fun.(\"string\")\n"
"    false\n"
"\n"
"In the example above, we captured `Kernel.is_atom/1` as an\n"
"anonymous function and then invoked it.\n"
"\n"
"The capture operator can also be used to capture local functions,\n"
"including private ones, and imported functions by omitting the\n"
"module name:\n"
"\n"
"    &local_function/1\n"
"\n"
"## Anonymous functions\n"
"\n"
"The capture operator can also be used to partially apply\n"
"functions, where `&1`, `&2` and so on can be used as value\n"
"placeholders. For example:\n"
"\n"
"    iex> double = &(&1 * 2)\n"
"    iex> double.(2)\n"
"    4\n"
"\n"
"In other words, `&(&1 * 2)` is equivalent to `fn x -> x * 2 end`.\n"
"Another example using a local function:\n"
"\n"
"    iex> fun = &is_atom(&1)\n"
"    iex> fun.(:atom)\n"
"    true\n"
"\n"
"The `&` operator can be used with more complex expressions:\n"
"\n"
"    iex> fun = &(&1 + &2 + &3)\n"
"    iex> fun.(1, 2, 3)\n"
"    6\n"
"\n"
"As well as with lists and tuples:\n"
"\n"
"    iex> fun = &{&1, &2}\n"
"    iex> fun.(1, 2)\n"
"    {1, 2}\n"
"\n"
"    iex> fun = &[&1|&2]\n"
"    iex> fun.(1, 2)\n"
"    [1|2]\n"
"\n"
"The only restrictions when creating anonymous functions is that at\n"
"least one placeholder must be present, i.e. it must contain at least\n"
"`&1`:\n"
"\n"
"    # No placeholder fails to compile\n"
"    &var\n"
"\n"
"    # Block expressions are also not supported\n"
"    &(foo(&1, &2); &3 + &4)\n"
"\n"
msgstr ""
"無名関数を捕捉あるいは作成します。\n"
"\n"
"## 捕捉\n"
"\n"
"捕捉オペレータは、モジュールから与えられた名前とアリティで\n"
"関数を捕捉するために、最もよく使われます:\n"
"\n"
"    iex> fun = &Kernel.is_atom/1\n"
"    iex> fun.(:atom)\n"
"    true\n"
"    iex> fun.(\"string\")\n"
"    false\n"
"\n"
"上の例で、無名関数として`Kernel.is_atom/1`を捕捉し、それから\n"
"それを起動しました。\n"
"\n"
"捕捉オペレータはプライベート関数を含むローカル関数を捕捉するために\n"
"使うこともでき、モジュール名を省略することによって関数を\n"
"インポートできます:\n"
"\n"
"    &local_function/1\n"
"\n"
"## 無名関数\n"
"\n"
"捕捉オペレータは、部分的に関数を適用するために使うこともでき、\n"
"値のプレースホルダとして`&1`, `&2`などを使うことができます。\n"
"例えば:\n"
"\n"
"    iex> double = &(&1 * 2)\n"
"    iex> double.(2)\n"
"    4\n"
"\n"
"言い替えると、`&(&1 * 2)`は、`fn x -> x * 2 end`に等しいです。\n"
"もう一つ、ローカル関数を使った例です:\n"
"\n"
"    iex> fun = &is_atom(&1)\n"
"    iex> fun.(:atom)\n"
"    true\n"
"\n"
"`&`オペレータはもっと複雑な式で使うことができます:\n"
"\n"
"    iex> fun = &(&1 + &2 + &3)\n"
"    iex> fun.(1, 2, 3)\n"
"    6\n"
"\n"
"リストとタプルと同じように使えます:\n"
"\n"
"    iex> fun = &{&1, &2}\n"
"    iex> fun.(1, 2)\n"
"    {1, 2}\n"
"\n"
"    iex> fun = &[&1|&2]\n"
"    iex> fun.(1, 2)\n"
"    [1|2]\n"
"\n"
"無名関数を作成するときの唯一の制限は、少なくとも一つのプレースホルダが\n"
"なければならないことです。即ち、最低`&1`を含まなければなりません:\n"
"\n"
"    # プレースホルダがないのでコンパイルに失敗します\n"
"    &var\n"
"\n"
"    # ブロック式もサポートされていません\n"
"    &(foo(&1, &2); &3 + &4)\n"
"\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.receive(args)
#: lib/kernel/special_forms.ex:1712
msgid ""
"Checks if there is a message matching the given clauses\n"
"in the current process mailbox.\n"
"\n"
"In case there is no such message, the current process hangs\n"
"until a message arrives or waits until a given timeout value.\n"
"\n"
"## Examples\n"
"\n"
"    receive do\n"
"      {:selector, i, value} when is_integer(i) ->\n"
"        value\n"
"      value when is_atom(value) ->\n"
"        value\n"
"      _ ->\n"
"        IO.puts :stderr, \"Unexpected message received\"\n"
"    end\n"
"\n"
"An optional after clause can be given in case the message was not\n"
"received after the specified period of time:\n"
"\n"
"    receive do\n"
"      {:selector, i, value} when is_integer(i) ->\n"
"        value\n"
"      value when is_atom(value) ->\n"
"        value\n"
"      _ ->\n"
"        IO.puts :stderr, \"Unexpected message received\"\n"
"    after\n"
"      5000 ->\n"
"        IO.puts :stderr, \"No message in 5 seconds\"\n"
"    end\n"
"\n"
"The `after` clause can be specified even if there are no match clauses.\n"
"There are two special cases for the timeout value given to `after`\n"
"\n"
"  * `:infinity` - the process should wait indefinitely for a matching\n"
"    message, this is the same as not using a timeout\n"
"\n"
"  * 0 - if there is no matching message in the mailbox, the timeout\n"
"    will occur immediately\n"
"\n"
"## Variables handling\n"
"\n"
"The `receive` special form handles variables exactly as the `case`\n"
"special macro. For more information, check the docs for `case/2`.\n"
msgstr ""
"現在のプロセスのメールボックスに、\n"
"与えられた節にマッチするメッセージがあるかどうかを\n"
"チェックします。\n"
"\n"
"そんなメッセージがない場合、現在のプロセスは、メッセージが到着するまで\n"
"ハングするか、与えられたタイムアウト値まで待ちます。\n"
"\n"
"## 例\n"
"\n"
"    receive do\n"
"      {:selector, i, value} when is_integer(i) ->\n"
"        value\n"
"      value when is_atom(value) ->\n"
"        value\n"
"      _ ->\n"
"        IO.puts :stderr, \"Unexpected message received\"\n"
"    end\n"
"\n"
"オプションのafter節は、指定された期間にメッセージを受信\n"
"しなかった時の為に与えることができます:\n"
"\n"
"    receive do\n"
"      {:selector, i, value} when is_integer(i) ->\n"
"        value\n"
"      value when is_atom(value) ->\n"
"        value\n"
"      _ ->\n"
"        IO.puts :stderr, \"Unexpected message received\"\n"
"    after\n"
"      5000 ->\n"
"        IO.puts :stderr, \"No message in 5 seconds\"\n"
"    end\n"
"\n"
"`after`節はマッチ節がなくても指定することができます。\n"
"`after`へ与えるタイムアウト値として、二つの特別な場合があります\n"
"\n"
"  * `:infinity` - プロセスは無期限にマッチするメッセージを\n"
"     待ちます。タイムアウトを使わないことと同じです\n"
"\n"
"  * 0 - メールボックスにマッチするメッセージがないなら、\n"
"    直ちにタイムアウトします。\n"
"\n"
"## 変数ハンドリング\n"
"\n"
"`receive`スペシャルフォームは`case`スペシャルマクロと全く同じように使い\n"
"ます。詳細は、`case/2`のドキュメントをチェックしてください。\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.^(var)
#: lib/kernel/special_forms.ex:674
msgid ""
"Accesses an already bound variable in match clauses.\n"
"\n"
"## Examples\n"
"\n"
"Elixir allows variables to be rebound via static single assignment:\n"
"\n"
"    iex> x = 1\n"
"    iex> x = x + 1\n"
"    iex> x\n"
"    2\n"
"\n"
"However, in some situations, it is useful to match against an existing\n"
"value, instead of rebinding. This can be done with the `^` special form:\n"
"\n"
"    iex> x = 1\n"
"    iex> ^x = List.first([1])\n"
"    iex> ^x = List.first([2])\n"
"    ** (MatchError) no match of right hand side value: 2\n"
"\n"
"Note that `^` always refers to the value of x prior to the match. The\n"
"following example will match:\n"
"\n"
"    iex> x = 0\n"
"    iex> {x, ^x} = {1, 0}\n"
"    iex> x\n"
"    1\n"
"\n"
msgstr ""
"マッチ節で既に束縛された変数へアクセスします。\n"
"\n"
"## 例\n"
"\n"
"Elixirは、静的な単一代入によって、変数の再束縛を許します:\n"
"\n"
"    iex> x = 1\n"
"    iex> x = 2\n"
"    iex> x\n"
"    2\n"
"\n"
"しかしながら、いくつかのシチュエーションでは、再束縛するかわりに、\n"
"既存の値に対してマッチすることが便利です。これは`^`スペシャルフォームで\n"
"できます:\n"
"\n"
"    iex> x = 1\n"
"    iex> ^x = List.first([1])\n"
"    iex> ^x = List.first([2])\n"
"    ** (MatchError) no match of right hand side value: 2\n"
"\n"
"`^`が常にマッチの前にxの値を参照することに、注意してください。\n"
"下の例のようにマッチします:\n"
"\n"
"    iex> x = 0\n"
"    iex> {x, ^x} = {1, 0}\n"
"    iex> x\n"
"    1\n"
"\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.super(args)
#: lib/kernel/special_forms.ex:1417
msgid ""
"Calls the overriden function when overriding it with `Kernel."
"defoverridable/1`.\n"
"\n"
"See `Kernel.defoverridable/1` for more information and documentation.\n"
msgstr ""
"`Kernel.defoverridable/1`でオーバライドしたときに、\n"
"オーバライドされた関数を呼び出します。\n"
"\n"
"詳細とトキュメントは`Kernel.defoverridable`を参照してください。\n"

#~ msgid ""
#~ "Defines a new bitstring.\n"
#~ "\n"
#~ "## Examples\n"
#~ "\n"
#~ "    iex> << 1, 2, 3 >>\n"
#~ "    << 1, 2, 3 >>\n"
#~ "\n"
#~ "## Bitstring types\n"
#~ "\n"
#~ "A bitstring is made of many segments. Each segment has a\n"
#~ "type, which defaults to integer:\n"
#~ "\n"
#~ "    iex> <<1, 2, 3>>\n"
#~ "    <<1, 2, 3>>\n"
#~ "\n"
#~ "Elixir also accepts by default the segment to be a literal\n"
#~ "string or a literal char list, which are by expanded to integers:\n"
#~ "\n"
#~ "    iex> <<0, \"foo\">>\n"
#~ "    <<0, 102, 111, 111>>\n"
#~ "\n"
#~ "Any other type needs to be explicitly tagged. For example,\n"
#~ "in order to store a float type in the binary, one has to do:\n"
#~ "\n"
#~ "    iex> <<3.14 :: float>>\n"
#~ "    <<64, 9, 30, 184, 81, 235, 133, 31>>\n"
#~ "\n"
#~ "This also means that variables need to be explicitly tagged,\n"
#~ "otherwise Elixir defaults to integer:\n"
#~ "\n"
#~ "    iex> rest = \"oo\"\n"
#~ "    iex> <<102, rest>>\n"
#~ "    ** (ArgumentError) argument error\n"
#~ "\n"
#~ "We can solve this by explicitly tagging it as a binary:\n"
#~ "\n"
#~ "    <<102, rest :: binary>>\n"
#~ "\n"
#~ "The type can be integer, float, bitstring/bits, binary/bytes,\n"
#~ "utf8, utf16 or utf32, e.g.:\n"
#~ "\n"
#~ "    <<102 :: float, rest :: binary>>\n"
#~ "\n"
#~ "An integer can be any arbitrary precision integer. A float is an\n"
#~ "IEEE 754 binary32 or binary64 floating point number. A bitstring\n"
#~ "is an arbitrary series of bits. A binary is a special case of\n"
#~ "bitstring that has a total size divisible by 8.\n"
#~ "\n"
#~ "The utf8, utf16, and utf32 types are for unicode codepoints. They\n"
#~ "can also be applied to literal strings and char lists:\n"
#~ "\n"
#~ "    iex> <<\"foo\" :: utf16>>\n"
#~ "    <<0,102,0,111,0,111>>\n"
#~ "\n"
#~ "The bits type is an alias for bitstring. The bytes type is an\n"
#~ "alias for binary.\n"
#~ "\n"
#~ "The signedness can also be given as signed or unsigned. The\n"
#~ "signedness only matters for matching and relevant only for\n"
#~ "integers. If unspecified, it defaults to unsigned. Example:\n"
#~ "\n"
#~ "    iex> <<-100 :: signed, _rest :: binary>> = <<-100, \"foo\">>\n"
#~ "    <<156,102,111,111>>\n"
#~ "\n"
#~ "This match would have failed if we did not specify that the\n"
#~ "value -100 is signed. If we're matching into a variable instead\n"
#~ "of a value, the signedness won't be checked; rather, the number\n"
#~ "will simply be interpreted as having the given (or implied)\n"
#~ "signedness, e.g.:\n"
#~ "\n"
#~ "    iex> <<val, _rest :: binary>> = <<-100, \"foo\">>\n"
#~ "    iex> val\n"
#~ "    156\n"
#~ "\n"
#~ "Here, `val` is interpreted as unsigned.\n"
#~ "\n"
#~ "The endianness of a segment can be big, little or native (the\n"
#~ "latter meaning it will be resolved at VM load time).\n"
#~ "\n"
#~ "Many options can be given by using `-` as separator, order is\n"
#~ "arbitrary. The following are all the same:\n"
#~ "\n"
#~ "    <<102 :: integer-native, rest :: binary>>\n"
#~ "    <<102 :: native-integer, rest :: binary>>  \n"
#~ "    <<102 :: unsigned-big-integer, rest :: binary>>\n"
#~ "    <<102 :: unsigned-big-integer-size(8), rest :: binary>>\n"
#~ "    <<102 :: unsigned-big-integer-8, rest :: binary>>\n"
#~ "    <<102 :: 8-integer-big-unsigned, rest :: binary>>\n"
#~ "    <<102, rest :: binary>>\n"
#~ "\n"
#~ "And so on.\n"
#~ "\n"
#~ "Endianness only makes sense for integers and some UTF code\n"
#~ "point types (utf16 and utf32).\n"
#~ "\n"
#~ "Finally, we can also specify size and unit for each segment. The\n"
#~ "unit is multiplied by the size to give the effective size of\n"
#~ "the segment in bits. The default unit for integers, floats,\n"
#~ "and bitstrings is 1. For binaries, it is 8.\n"
#~ "\n"
#~ "Since integers are default, the default unit is 1. The example below\n"
#~ "matches because the string \"foo\" takes 24 bits and we match it\n"
#~ "against a segment of 24 bits, 8 of which are taken by the integer\n"
#~ "102 and the remaining 16 bits are specified on the rest.\n"
#~ "\n"
#~ "    iex> <<102, _rest :: size(16)>> = \"foo\"\n"
#~ "    \"foo\"\n"
#~ "\n"
#~ "We can also match by specifying size and unit explicitly:\n"
#~ "\n"
#~ "    iex> <<102, _rest :: size(2)-unit(8)>> = \"foo\"\n"
#~ "    \"foo\"\n"
#~ "\n"
#~ "However, if we expect a size of 32, it won't match:\n"
#~ "\n"
#~ "    iex> <<102, _rest :: size(32)>> = \"foo\"\n"
#~ "    ** (MatchError) no match of right hand side value: \"foo\"\n"
#~ "\n"
#~ "Size and unit are not applicable to utf8, utf16, and utf32.\n"
#~ "\n"
#~ "The default size for integers is 8. For floats, it is 64. For\n"
#~ "binaries, it is the size of the binary. Only the last binary\n"
#~ "in a binary match can use the default size (all others must\n"
#~ "have their size specified explicitly).\n"
#~ "\n"
#~ "    iex> <<3.14 :: float>>\n"
#~ "    <<64, 9, 30, 184, 81, 235, 133, 31>>\n"
#~ "    iex> <<3.14 :: float-32>>\n"
#~ "    <<64, 72, 245, 195>>\n"
#~ "\n"
#~ "Size and unit can also be specified using a syntax shortcut\n"
#~ "when passing integer values:\n"
#~ "\n"
#~ "    << x :: 8 >> == << x :: size(8) >>\n"
#~ "    << x :: 8 * 4 >> == << x :: size(8)-unit(4) >>\n"
#~ "    << x :: _ * 4 >> == << x :: unit(4) >>\n"
#~ "\n"
#~ "This syntax reflects the fact the effective size is given by\n"
#~ "multiplying the size by the unit.\n"
#~ "\n"
#~ "For floats, `size * unit` must result in 32 or 64, corresponding\n"
#~ "to binary32 and binary64, respectively.\n"
#~ msgstr ""
#~ "新しいbitstringを定義します。\n"
#~ "\n"
#~ "## 例\n"
#~ "\n"
#~ "    iex> << 1, 2, 3 >>\n"
#~ "    << 1, 2, 3 >>\n"
#~ "\n"
#~ "## Bitstringタイプ\n"
#~ "\n"
#~ "bitstringは多くのセグメントで出来ています。それぞれのセグメントは\n"
#~ "デフォルトは整数のタイプを持っています:\n"
#~ "\n"
#~ "    iex> <<1, 2, 3>>\n"
#~ "    <<1, 2, 3>>\n"
#~ "\n"
#~ "Elixirはリテラル文字列あるいはリテラル文字のリストのセグメントも\n"
#~ "デフォルトで受け付け、整数に展開されます:\n"
#~ "\n"
#~ "    iex> <<0, \"foo\">>\n"
#~ "    <<0, 102, 111, 111>>\n"
#~ "\n"
#~ "他の任意のタイプは明示的にタグづけされる必要があります。例えば、\n"
#~ "バイナリでfloatタイプをストアするために、下のようにします:\n"
#~ "\n"
#~ "    iex> <<3.14 :: float>>\n"
#~ "    <<64, 9, 30, 184, 81, 235, 133, 31>>\n"
#~ "\n"
#~ "これは、変数は明示的にタグづけされる必要があることも意味します。\n"
#~ "さもないと、Elixirはデフォルトの整数として扱おうとします:\n"
#~ "\n"
#~ "    iex> rest = \"oo\"\n"
#~ "    iex> <<102, rest>>\n"
#~ "    ** (ArgumentError) argument error\n"
#~ "\n"
#~ "明示的にバイナリとタグづけすることによって、この問題を解決できます:\n"
#~ "\n"
#~ "    <<102, rest :: binary>>\n"
#~ "\n"
#~ "タイプはinteger, float, bitstring/bits, binary/types, utf8, utf16, \n"
#~ "utf32が可能です。例えば:\n"
#~ "\n"
#~ "    <<102 :: float, rest :: binary>>\n"
#~ "\n"
#~ "integerは任意の精度の整数が可能です。floatはIEEE754 binary32か\n"
#~ "binary64浮動小数点数です。bitstringは任意のbit列です。binaryは\n"
#~ "bitstringの特別な場合で合計の大きさが8の倍数です。\n"
#~ "\n"
#~ "utf8, utf16, utf32タイプはunicodeコードポイントです。\n"
#~ "それらはリテラルの文字列と文字リストにも適用できます:\n"
#~ "\n"
#~ "    iex> <<\"foo\" :: utf16>>\n"
#~ "    <<0,102,0,111,0,111>>\n"
#~ "\n"
#~ "bitsタイプはbitstringの別名です。bytesタイプはbinaryの\n"
#~ "別名です。\n"
#~ "符号の有無はsignedかunsignedとして与えることも出来ます。\n"
#~ "符号の有無は、整数の為だけにあって、マッチングに重要なだけです。\n"
#~ "もし指定されなければ、デフォルトはunsignedです。例は:\n"
#~ "\n"
#~ "    iex> <<-100 :: signed, _rest :: binary>> = <<-100, \"foo\">>\n"
#~ "    <<156,102,111,111>>\n"
#~ "\n"
#~ "もし値-100がsignedと指定しなかったら、このマッチは失敗したでしょう。\n"
#~ "もし値の代りに変数にマッチングさせたら、符号の有無はチェックされません;\n"
#~ "むしろ、与えられた(または意味される)符号の有無を持つとして、\n"
#~ "単に解釈されます。例えば:\n"
#~ "\n"
#~ "    iex> <<val, _rest :: binary>> = <<-100, \"foo\">>\n"
#~ "    iex> val\n"
#~ "    156\n"
#~ "\n"
#~ "ここで、`val`はunsignedとして解釈されています。\n"
#~ "\n"
#~ "セグメントのエンディアンはbig、little, native(その意味は\n"
#~ "VMのロード時に解決されます)が可能です。\n"
#~ "\n"
#~ "セパレータとして`-`を使うことにより、多くのオプションを指定すること\n"
#~ "ができます。以下は全て同じです:\n"
#~ "\n"
#~ "    <<102 :: integer-native, rest :: binary>>\n"
#~ "    <<102 :: native-integer, rest :: binary>>\n"
#~ "    <<102 :: unsigned-big-integer, rest :: binary>>\n"
#~ "    <<102 :: unsigned-big-integer-size(8), rest :: binary>>\n"
#~ "    <<102 :: unsigned-big-integer-8, rest :: binary>>\n"
#~ "    <<102 :: 8-integer-big-unsigned, rest :: binary>>\n"
#~ "    <<102, rest :: binary>>\n"
#~ "\n"
#~ "そしてその他。\n"
#~ "\n"
#~ "エンディアンはintegerといくつかのUTFコードポイントタイプ\n"
#~ "(utf16とutf32)でのみ意味をなすだけです。\n"
#~ "\n"
#~ "最後に、それぞれのセグメントにsizeとunitを指定することもできます。\n"
#~ "unitはbitでセグメントの実質的なサイズを与えるために、\n"
#~ "sizeによって掛け算されます。\n"
#~ "デフォルトunitは、integer, float, bitstringでは1です。binaryでは8です。\n"
#~ "\n"
#~ "integerがデフォルトなので、デフォルトunitは1です。\n"
#~ "下の例では、文字列\"foo\"が24ビットをとります。その24ビットのセグメント\n"
#~ "に対して、整数102により8ビットと、のこり16bitは_restにより指定さ\n"
#~ "れているので、マッチします。\n"
#~ "\n"
#~ "    iex> <<102, _rest :: size(16)>> = \"foo\"\n"
#~ "    \"foo\"\n"
#~ "\n"
#~ "sizeとunitを明示的に指定することによってマッチさせることもできます:\n"
#~ "\n"
#~ "    iex> <<102, _rest :: size(2)-unit(8)>> = \"foo\"\n"
#~ "    \"foo\"\n"
#~ "\n"
#~ "しかしながら、この例でsizeを32にすると、マッチしません:\n"
#~ "\n"
#~ "    iex> <<102, _rest :: size(32)>> = \"foo\"\n"
#~ "    ** (MatchError) no match of right hand side value: \"foo\"\n"
#~ "\n"
#~ "sizeとunitはutf8, utf16, utf32には適用されません。\n"
#~ "\n"
#~ "integerのデフォルトのsizeは8です。floatは64です。binaryはbinaryの大きさ\n"
#~ "です。最後のbinaryのマッチにだけは、デフォルトsizeを使うことができます\n"
#~ "(他の全てはsizeを明示的に指定されていなければなりません)。\n"
#~ "\n"
#~ "    iex> <<3.14 :: float>>\n"
#~ "    <<64, 9, 30, 184, 81, 235, 133, 31>>\n"
#~ "    iex> <<3.14 :: float-32>>\n"
#~ "    <<64, 72, 245, 195>>\n"
#~ "\n"
#~ "\n"
#~ "sizeとunitは、構文上のショートカットを使って指定することも\n"
#~ "できます:\n"
#~ "\n"
#~ "    << x :: 8 >> == << x :: size(8) >>\n"
#~ "    << x :: 8 * 4 >> == << x :: size(8)-unit(4) >>\n"
#~ "    << x :: _ * 4 >> == << x :: unit(4) >>\n"
#~ "\n"
#~ "実際の大きさがsizeとunitの掛け算によって与えられるという事実を、\n"
#~ "この構文は反映しています。\n"
#~ "\n"
#~ "floatでは、`size * unit`は、binary32とbinary64にそれぞれ一致する、\n"
#~ "32か64でなければなりません。\n"
