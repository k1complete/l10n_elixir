#. TRANSLATORS: defmacro Kernel.SpecialForms.alias(module, opts)
#: lib/kernel/special_forms.ex:465 
msgid ""
"`alias` is used to setup aliases, often useful with modules names.\n"
"\n"
"## Examples\n"
"\n"
"`alias` can be used to setup an alias for any module:\n"
"\n"
"    defmodule Math do\n"
"      alias MyKeyword, as: Keyword\n"
"    end\n"
"\n"
"In the example above, we have set up `MyKeyword` to be aliased\n"
"as `Keyword`. So now, any reference to `Keyword` will be\n"
"automatically replaced by `MyKeyword`.\n"
"\n"
"In case one wants to access the original `Keyword`, it can be done\n"
"by accessing `Elixir`:\n"
"\n"
"    Keyword.values   #=> uses MyKeyword.values\n"
"    Elixir.Keyword.values #=> uses Keyword.values\n"
"\n"
"Notice that calling `alias` without the `as:` option automatically\n"
"sets an alias based on the last part of the module. For example:\n"
"\n"
"    alias Foo.Bar.Baz\n"
"\n"
"Is the same as:\n"
"\n"
"    alias Foo.Bar.Baz, as: Baz\n"
"\n"
"## Lexical scope\n"
"\n"
"`import`, `require` and `alias` are called directives and all\n"
"have lexical scope. This means you can set up aliases inside\n"
"specific functions and it won't affect the overall scope.\n"
"\n"
"## Warnings\n"
"\n"
"If you alias a module and you don't use the alias, Elixir is\n"
"going to issue a warning implying the alias is not being used.\n"
"\n"
"In case the alias is generated automatically by a macro,\n"
"Elixir won't emit any warnings though, since the alias\n"
"was not explicitly defined.\n"
"\n"
"Both warning behaviours could be changed by explicitly\n"
"setting the `:warn` option to `true` or `false`.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.::(left, right)
#: lib/kernel/special_forms.ex:710 
msgid ""
"Used by types and bitstrings to specify types.\n"
"\n"
"This operator is used in two distinct occasions in Elixir.\n"
"It is used in typespecs to specify the type of a variable,\n"
"function or of a type itself:\n"
"\n"
"    @type number :: integer | float\n"
"    @spec add(number, number) :: number\n"
"\n"
"It may also be used in bit strings to specify the type\n"
"of a given bit segment:\n"
"\n"
"    <<int::integer-little, rest::bits>> = bits\n"
"\n"
"Read the documentation for `Kernel.Typespec` and\n"
"`<<>>/1` for more information on typespecs and\n"
"bitstrings respectively.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.__MODULE__()
#: lib/kernel/special_forms.ex:650 
msgid ""
"Returns the current module name as an atom or `nil` otherwise.\n"
"\n"
"Although the module can be accessed in the `__ENV__`, this macro\n"
"is a convenient shortcut.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.__ENV__()
#: lib/kernel/special_forms.ex:642 
msgid ""
"Returns the current environment information as a `Macro.Env` struct.\n"
"\n"
"In the environment you can access the current filename,\n"
"line numbers, set up aliases, the current function and others.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.__DIR__()
#: lib/kernel/special_forms.ex:658 
msgid ""
"Returns the current directory as a binary.\n"
"\n"
"Although the directory can be accessed as `Path.dirname(__ENV__.file)`,\n"
"this macro is a convenient shortcut.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.__CALLER__()
#: lib/kernel/special_forms.ex:666 
msgid ""
"Returns the current calling environment as a `Macro.Env` struct.\n"
"\n"
"In the environment you can access the filename, line numbers,\n"
"set up aliases, the function and others.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.unquote_splicing(expr)
#: lib/kernel/special_forms.ex:1212 
msgid ""
"Unquotes the given list expanding its arguments. Similar\n"
"to unquote.\n"
"\n"
"## Examples\n"
"\n"
"    values = [2, 3, 4]\n"
"    quote do: sum(1, unquote_splicing(values), 5)\n"
"    #=> {:sum, [], [1, 2, 3, 4, 5]}\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.unquote(expr)
#: lib/kernel/special_forms.ex:1187 
msgid ""
"Unquotes the given expression from inside a macro.\n"
"\n"
"## Examples\n"
"\n"
"Imagine the situation you have a variable `value` and\n"
"you want to inject it inside some quote. The first attempt\n"
"would be:\n"
"\n"
"    value = 13\n"
"    quote do: sum(1, value, 3)\n"
"\n"
"Which would then return:\n"
"\n"
"    {:sum, [], [1, {:value, [], quoted}, 3]}\n"
"\n"
"Which is not the expected result. For this, we use unquote:\n"
"\n"
"    value = 13\n"
"    quote do: sum(1, unquote(value), 3)\n"
"    #=> {:sum, [], [1, 13, 3]}\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.require(module, opts)
#: lib/kernel/special_forms.ex:515 
msgid ""
"Requires a given module to be compiled and loaded.\n"
"\n"
"## Examples\n"
"\n"
"Notice that usually modules should not be required before usage,\n"
"the only exception is if you want to use the macros from a module.\n"
"In such cases, you need to explicitly require them.\n"
"\n"
"Let's suppose you created your own `if` implementation in the module\n"
"`MyMacros`. If you want to invoke it, you need to first explicitly\n"
"require the `MyMacros`:\n"
"\n"
"    defmodule Math do\n"
"      require MyMacros\n"
"      MyMacros.if do_something, it_works\n"
"    end\n"
"\n"
"An attempt to call a macro that was not loaded will raise an error.\n"
"\n"
"## Alias shortcut\n"
"\n"
"`require` also accepts `as:` as an option so it automatically sets\n"
"up an alias. Please check `alias` for more information.\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.<<>>(args)
#: lib/kernel/special_forms.ex:167 
msgid ""
"Defines a new bitstring.\n"
"\n"
"## Examples\n"
"\n"
"    iex> << 1, 2, 3 >>\n"
"    << 1, 2, 3 >>\n"
"\n"
"## Types\n"
"\n"
"A bitstring is made of many segments and each segment has a\n"
"type. There are 9 types used in bitstrings:\n"
"\n"
"- `integer`\n"
"- `float`\n"
"- `bits` (alias for bitstring)\n"
"- `bitstring`\n"
"- `binary`\n"
"- `bytes` (alias for binary)\n"
"- `utf8`\n"
"- `utf16`\n"
"- `utf32`\n"
"\n"
"When no type is specified, the default is `integer`:\n"
"\n"
"    iex> <<1, 2, 3>>\n"
"    <<1, 2, 3>>\n"
"\n"
"Elixir also accepts by default the segment to be a literal\n"
"string or a literal char list, which are by expanded to integers:\n"
"\n"
"    iex> <<0, \"foo\">>\n"
"    <<0, 102, 111, 111>>\n"
"\n"
"Variables or any other type need to be explicitly tagged:\n"
"\n"
"    iex> rest = \"oo\"\n"
"    iex> <<102, rest>>\n"
"    ** (ArgumentError) argument error\n"
"\n"
"We can solve this by explicitly tagging it as a binary:\n"
"\n"
"    iex> rest = \"oo\"\n"
"    iex> <<102, rest :: binary>>\n"
"    \"foo\"\n"
"\n"
"The utf8, utf16, and utf32 types are for unicode codepoints. They\n"
"can also be applied to literal strings and char lists:\n"
"\n"
"    iex> <<\"foo\" :: utf16>>\n"
"    <<0, 102, 0, 111, 0, 111>>\n"
"    iex> <<\"foo\" :: utf32>>\n"
"    <<0, 0, 0, 102, 0, 0, 0, 111, 0, 0, 0, 111>>\n"
"\n"
"## Options\n"
"\n"
"Many options can be given by using `-` as separator. Order is\n"
"arbitrary, so the following are all equivalent:\n"
"\n"
"    <<102 :: integer-native, rest :: binary>>\n"
"    <<102 :: native-integer, rest :: binary>>\n"
"    <<102 :: unsigned-big-integer, rest :: binary>>\n"
"    <<102 :: unsigned-big-integer-size(8), rest :: binary>>\n"
"    <<102 :: unsigned-big-integer-8, rest :: binary>>\n"
"    <<102 :: 8-integer-big-unsigned, rest :: binary>>\n"
"    <<102, rest :: binary>>\n"
"\n"
"### Unit and Size\n"
"\n"
"The length of the match is equal to the `unit` (a number of bits) times the\n"
"`size` (the number of repeated segnments of length `unit`).\n"
"\n"
"Type      | Default Unit\n"
"--------- | ------------\n"
"`integer` | 1 bit\n"
"`float`   | 1 bit\n"
"`binary`  | 8 bits\n"
"\n"
"Sizes for types are a bit more nuanced. The default size for integers is 8.\n"
"\n"
"For floats, it is 64. For floats, `size * unit` must result in 32 or 64,\n"
"corresponding to [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point)\n"
"binary32 and binary64, respectively.\n"
"\n"
"For binaries, the default is the size of the binary. Only the last binary in a\n"
"match can use the default size. All others must have their size specified\n"
"explicitly, even if the match is unambiguous. For example:\n"
"\n"
"    iex> <<name::binary-size(5), \" the \", species::binary>> = <<\"Frank the Walrus\">>\n"
"    \"Frank the Walrus\"\n"
"    iex> {name, species}\n"
"    {\"Frank\", \"Walrus\"}\n"
"\n"
"Failing to specify the size for the non-last causes compilation to fail:\n"
"\n"
"    <<name::binary, \" the \", species::binary>> = <<\"Frank the Walrus\">>\n"
"    ** (CompileError): a binary field without size is only allowed at the end of a binary pattern\n"
"\n"
"#### Shortcut Syntax\n"
"\n"
"Size and unit can also be specified using a syntax shortcut\n"
"when passing integer values:\n"
"\n"
"    iex> x = 1\n"
"    iex> << x :: 8 >> == << x :: size(8) >>\n"
"    true\n"
"    iex> << x :: 8 * 4 >> == << x :: size(8)-unit(4) >>\n"
"    true\n"
"\n"
"This syntax reflects the fact the effective size is given by\n"
"multiplying the size by the unit.\n"
"\n"
"### Modifiers\n"
"\n"
"Some types have associated modifiers to clear up ambiguity in byte\n"
"representation.\n"
"\n"
"Modifier             | Relevant Type(s)\n"
"-------------------- | ----------------\n"
"`signed`             | `integer`\n"
"`unsigned` (default) | `integer`\n"
"`little`             | `integer`, `utf16`, `utf32`\n"
"`big` (default)      | `integer`, `utf16`, `utf32`\n"
"`native`             | `integer`, `utf16`, `utf32`\n"
"\n"
"### Sign\n"
"\n"
"Integers can be `signed` or `unsigned`, defaulting to `unsigned`.\n"
"\n"
"    iex> <<int::integer>> =  <<-100>>\n"
"    <<156>>\n"
"    iex> int\n"
"    156\n"
"    iex> <<int::integer-signed>> =  <<-100>>\n"
"    <<156>>\n"
"    iex> int\n"
"    -100\n"
"\n"
"`signed` and `unsigned` are only used for matching binaries (see below) and\n"
"are only used for integers.\n"
"\n"
"    iex> <<-100 :: signed, _rest :: binary>> = <<-100, \"foo\">>\n"
"    <<156, 102, 111, 111>>\n"
"\n"
"### Endianness\n"
"\n"
"Elixir has three options for endianness: `big`, `little`, and `native`.\n"
"The default is `big`:\n"
"\n"
"    iex> <<number::little-integer-size(16)>> = <<0, 1>>\n"
"    <<0, 1>>\n"
"    iex> number\n"
"    256\n"
"    iex> <<number::big-integer-size(16)>> = <<0, 1>>\n"
"    <<0, 1>>\n"
"    iex> number\n"
"    1\n"
"\n"
"`native` is determined by the VM at startup and will depend on the\n"
"host operating system.\n"
"\n"
"## Binary/Bitstring Matching\n"
"\n"
"Binary matching is a powerful feature in Elixir that is useful for extracting\n"
"information from binaries as well as pattern matching.\n"
"\n"
"Binary matching can be used by itself to extract information from binaries:\n"
"\n"
"    iex> <<\"Hello, \", place::binary>> = \"Hello, World\"\n"
"    \"Hello, World\"\n"
"    iex> place\n"
"    \"World\"\n"
"\n"
"Or as a part of function definitions to pattern match:\n"
"\n"
"    defmodule ImageTyper\n"
"      @png_signature <<137::size(8), 80::size(8), 78::size(8), 71::size(8),\n"
"                    13::size(8), 10::size(8), 26::size(8), 10::size(8)>>\n"
"      @jpg_signature <<255::size(8), 216::size(8)>>\n"
"\n"
"      def type(<<@png_signature, rest::binary>>), do: :png\n"
"      def type(<<@jpg_signature, rest::binary>>), do: :jpg\n"
"      def type(_), do :unknown\n"
"    end\n"
"\n"
"### Performance & Optimizations\n"
"\n"
"The Erlang compiler can provide a number of optimizations on binary creation\n"
"and matching. To see optimization output, set the `bin_opt_info` compiler\n"
"option:\n"
"\n"
"    ERL_COMPILER_OPTIONS=bin_opt_info mix compile\n"
"\n"
"To learn more about specific optimizations and performance considerations,\n"
"check out\n"
"[Erlang's Efficiency Guide on handling binaries](http://www.erlang.org/doc/efficiency_guide/binaryhandling.html).\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.=(left, right)
#: lib/kernel/special_forms.ex:705 
msgid ""
"Matches the value on the right against the pattern on the left.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.case(condition, clauses)
#: lib/kernel/special_forms.ex:1424 
msgid ""
"Matches the given expression against the given clauses.\n"
"\n"
"## Examples\n"
"\n"
"    case thing do\n"
"      {:selector, i, value} when is_integer(i) ->\n"
"        value\n"
"      value ->\n"
"        value\n"
"    end\n"
"\n"
"In the example above, we match `thing` against each clause \"head\"\n"
"and execute the clause \"body\" corresponding to the first clause\n"
"that matches. If no clause matches, an error is raised.\n"
"\n"
"## Variables handling\n"
"\n"
"Notice that variables bound in a clause \"head\" do not leak to the\n"
"outer context:\n"
"\n"
"    case data do\n"
"      {:ok, value} -> value\n"
"      :error -> nil\n"
"    end\n"
"\n"
"    value #=> unbound variable value\n"
"\n"
"However, variables explicitly bound in the clause \"body\" are\n"
"accessible from the outer context:\n"
"\n"
"    value = 7\n"
"\n"
"    case lucky? do\n"
"      false -> value = 13\n"
"      true  -> true\n"
"    end\n"
"\n"
"    value #=> 7 or 13\n"
"\n"
"In the example above, value is going to be `7` or `13` depending on\n"
"the value of `lucky?`. In case `value` has no previous value before\n"
"case, clauses that do not explicitly bind a value have the variable\n"
"bound to `nil`.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.__aliases__(args)
#: lib/kernel/special_forms.ex:1387 
msgid ""
"Internal special form to hold aliases information.\n"
"\n"
"It is usually compiled to an atom:\n"
"\n"
"    iex> quote do: Foo.Bar\n"
"    {:__aliases__, [alias: false], [:Foo, :Bar]}\n"
"\n"
"Elixir represents `Foo.Bar` as `__aliases__` so calls can be\n"
"unambiguously identified by the operator `:.`. For example:\n"
"\n"
"    iex> quote do: Foo.bar\n"
"    {{:., [], [{:__aliases__, [alias: false], [:Foo]}, :bar]}, [], []}\n"
"\n"
"Whenever an expression iterator sees a `:.` as the tuple key,\n"
"it can be sure that it represents a call and the second argument\n"
"in the list is an atom.\n"
"\n"
"On the other hand, aliases holds some properties:\n"
"\n"
"  1. The head element of aliases can be any term that must expand to\n"
"     an atom at compilation time.\n"
"\n"
"  2. The tail elements of aliases are guaranteed to always be atoms.\n"
"\n"
"  3. When the head element of aliases is the atom `:Elixir`, no expansion happen.\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.__block__(args)
#: lib/kernel/special_forms.ex:1305 
msgid ""
"Internal special form for block expressions.\n"
"\n"
"This is the special form used whenever we have a block\n"
"of expressions in Elixir. This special form is private\n"
"and should not be invoked directly:\n"
"\n"
"    iex> quote do: (1; 2; 3)\n"
"    {:__block__, [], [1, 2, 3]}\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.Kernel.SpecialForms Summary
#: lib/kernel/special_forms.ex:2 
msgid ""
"In this module we define Elixir special forms. Special forms\n"
"cannot be overridden by the developer and are the basic\n"
"building blocks of Elixir code.\n"
"\n"
"Some of those forms are lexical (like `alias`, `case`, etc).\n"
"The macros `{}` and `<<>>` are also special forms used to define\n"
"tuple and binary data structures respectively.\n"
"\n"
"This module also documents Elixir's pseudo variables (`__ENV__`,\n"
"`__MODULE__`, `__DIR__` and `__CALLER__`). Pseudo variables return\n"
"information about Elixir's compilation environment and can only\n"
"be read, never assigned to.\n"
"\n"
"Finally, it also documents 2 special forms, `__block__` and\n"
"`__aliases__`, which are not intended to be called directly by the\n"
"developer but they appear in quoted contents since they are essential\n"
"in Elixir's constructs.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.import(module, opts)
#: lib/kernel/special_forms.ex:543 
msgid ""
"Imports function and macros from other modules.\n"
"\n"
"`import` allows one to easily access functions or macros from\n"
"others modules without using the qualified name.\n"
"\n"
"## Examples\n"
"\n"
"If you are using several functions from a given module, you can\n"
"import those functions and reference them as local functions,\n"
"for example:\n"
"\n"
"    iex> import List\n"
"    iex> flatten([1, [2], 3])\n"
"    [1, 2, 3]\n"
"\n"
"## Selector\n"
"\n"
"By default, Elixir imports functions and macros from the given\n"
"module, except the ones starting with underscore (which are\n"
"usually callbacks):\n"
"\n"
"    import List\n"
"\n"
"A developer can filter to import only macros or functions via\n"
"the only option:\n"
"\n"
"    import List, only: :functions\n"
"    import List, only: :macros\n"
"\n"
"Alternatively, Elixir allows a developer to pass pairs of\n"
"name/arities to `:only` or `:except` as a fine grained control\n"
"on what to import (or not):\n"
"\n"
"    import List, only: [flatten: 1]\n"
"    import String, except: [split: 2]\n"
"\n"
"Notice that calling `except` for a previously declared `import`\n"
"simply filters the previously imported elements. For example:\n"
"\n"
"    import List, only: [flatten: 1, keyfind: 4]\n"
"    import List, except: [flatten: 1]\n"
"\n"
"After the two import calls above, only `List.keyfind/4` will be\n"
"imported.\n"
"\n"
"## Underscore functions\n"
"\n"
"By default functions starting with `_` are not imported. If you really want\n"
"to import a function starting with `_` you must explicitly include it in the\n"
"`:only` selector.\n"
"\n"
"    import File.Stream, only: [__build__: 3]\n"
"\n"
"## Lexical scope\n"
"\n"
"It is important to notice that `import` is lexical. This means you\n"
"can import specific macros inside specific functions:\n"
"\n"
"    defmodule Math do\n"
"      def some_function do\n"
"        # 1) Disable `if/2` from Kernel\n"
"        import Kernel, except: [if: 2]\n"
"\n"
"        # 2) Require the new `if` macro from MyMacros\n"
"        import MyMacros\n"
"\n"
"        # 3) Use the new macro\n"
"        if do_something, it_works\n"
"      end\n"
"    end\n"
"\n"
"In the example above, we imported macros from `MyMacros`,\n"
"replacing the original `if/2` implementation by our own\n"
"within that specific function. All other functions in that\n"
"module will still be able to use the original one.\n"
"\n"
"## Warnings\n"
"\n"
"If you import a module and you don't use any of the imported\n"
"functions or macros from this module, Elixir is going to issue\n"
"a warning implying the import is not being used.\n"
"\n"
"In case the import is generated automatically by a macro,\n"
"Elixir won't emit any warnings though, since the import\n"
"was not explicitly defined.\n"
"\n"
"Both warning behaviours could be changed by explicitly\n"
"setting the `:warn` option to `true` or `false`.\n"
"\n"
"## Ambiguous function/macro names\n"
"\n"
"If two modules `A` and `B` are imported and they both contain\n"
"a `foo` function with an arity of `1`, an error is only emitted\n"
"if an ambiguous call to `foo/1` is actually made; that is, the\n"
"errors are emitted lazily, not eagerly.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.try(args)
#: lib/kernel/special_forms.ex:1491 
msgid ""
"Evaluates the given expressions and handle any error, exit\n"
"or throw that may have happened.\n"
"\n"
"## Examples\n"
"\n"
"    try do\n"
"      do_something_that_may_fail(some_arg)\n"
"    rescue\n"
"      ArgumentError ->\n"
"        IO.puts \"Invalid argument given\"\n"
"    catch\n"
"      value ->\n"
"        IO.puts \"caught #{value}\"\n"
"    else\n"
"      value ->\n"
"        IO.puts \"Success! The result was #{value}\"\n"
"    after\n"
"      IO.puts \"This is printed regardless if it failed or succeed\"\n"
"    end\n"
"\n"
"The rescue clause is used to handle exceptions, while the catch\n"
"clause can be used to catch thrown values. The else clause can\n"
"be used to control flow based on the result of the expression.\n"
"Catch, rescue and else clauses work based on pattern matching.\n"
"\n"
"Note that calls inside `try` are not tail recursive since the VM\n"
"needs to keep the stacktrace in case an exception happens.\n"
"\n"
"## Rescue clauses\n"
"\n"
"Besides relying on pattern matching, rescue clauses provides some\n"
"conveniences around exceptions that allows one to rescue an\n"
"exception by its name. All the following formats are valid rescue\n"
"expressions:\n"
"\n"
"    try do\n"
"      UndefinedModule.undefined_function\n"
"    rescue\n"
"      UndefinedFunctionError -> nil\n"
"    end\n"
"\n"
"    try do\n"
"      UndefinedModule.undefined_function\n"
"    rescue\n"
"      [UndefinedFunctionError] -> nil\n"
"    end\n"
"\n"
"    # rescue and bind to x\n"
"    try do\n"
"      UndefinedModule.undefined_function\n"
"    rescue\n"
"      x in [UndefinedFunctionError] -> nil\n"
"    end\n"
"\n"
"    # rescue all and bind to x\n"
"    try do\n"
"      UndefinedModule.undefined_function\n"
"    rescue\n"
"      x -> nil\n"
"    end\n"
"\n"
"## Erlang errors\n"
"\n"
"Erlang errors are transformed into Elixir ones during rescue:\n"
"\n"
"    try do\n"
"      :erlang.error(:badarg)\n"
"    rescue\n"
"      ArgumentError -> :ok\n"
"    end\n"
"\n"
"The most common Erlang errors will be transformed into their\n"
"Elixir counter-part. Those which are not will be transformed\n"
"into `ErlangError`:\n"
"\n"
"    try do\n"
"      :erlang.error(:unknown)\n"
"    rescue\n"
"      ErlangError -> :ok\n"
"    end\n"
"\n"
"In fact, ErlangError can be used to rescue any error that is\n"
"not an Elixir error proper. For example, it can be used to rescue\n"
"the earlier `:badarg` error too, prior to transformation:\n"
"\n"
"    try do\n"
"      :erlang.error(:badarg)\n"
"    rescue\n"
"      ErlangError -> :ok\n"
"    end\n"
"\n"
"## Catching throws and exits\n"
"\n"
"The catch clause can be used to catch throws values and exits.\n"
"\n"
"    try do\n"
"      exit(:shutdown)\n"
"    catch\n"
"      :exit, :shutdown -> IO.puts \"Exited with shutdown reason\"\n"
"    end\n"
"\n"
"    try do\n"
"      throw(:sample)\n"
"    catch\n"
"      :throw, :sample ->\n"
"        IO.puts \"sample thrown\"\n"
"    end\n"
"\n"
"catch values also support `:error`, as in Erlang, although it is\n"
"commonly avoided in favor of raise/rescue control mechanisms.\n"
"\n"
"## Else clauses\n"
"\n"
"Else clauses allow the result of the expression to be pattern\n"
"matched on:\n"
"\n"
"    x = 2\n"
"    try do\n"
"      1 / x\n"
"    rescue\n"
"      ArithmeticError ->\n"
"        :infinity\n"
"    else\n"
"      y when y < 1 and y > -1 ->\n"
"        :small\n"
"      _ ->\n"
"        :large\n"
"    end\n"
"\n"
"If an else clause is not present the result of the expression will\n"
"be return, if no exceptions are raised:\n"
"\n"
"    x = 1\n"
"    ^x =\n"
"      try do\n"
"        1 / x\n"
"      rescue\n"
"        ArithmeticError ->\n"
"          :infinity\n"
"      end\n"
"\n"
"However when an else clause is present but the result of the expression\n"
"does not match any of the patterns an exception will be raised. This\n"
"exception will not be caught by a catch or rescue in the same try:\n"
"\n"
"    x = 1\n"
"    try do\n"
"      try do\n"
"        1 / x\n"
"      rescue\n"
"        # The TryClauseError can not be rescued here:\n"
"        TryClauseError ->\n"
"          :error_a\n"
"      else\n"
"        0 ->\n"
"          :small\n"
"      end\n"
"    rescue\n"
"      # The TryClauseError is rescued here:\n"
"      TryClauseError ->\n"
"        :error_b\n"
"    end\n"
"\n"
"Similarly an exception inside an else clause is not caught or rescued\n"
"inside the same try:\n"
"\n"
"    try do\n"
"      try do\n"
"        nil\n"
"      catch\n"
"        # The exit(1) call below can not be caught here:\n"
"        :exit, _ ->\n"
"          :exit_a\n"
"      else\n"
"        _ ->\n"
"          exit(1)\n"
"      end\n"
"    catch\n"
"      # The exit is caught here:\n"
"      :exit, _ ->\n"
"        :exit_b\n"
"    end\n"
"\n"
"This means the VM no longer needs to keep the stacktrace once inside\n"
"an else clause and so tail recursion is possible when using a `try`\n"
"with a tail call as the final call inside an else clause. The same\n"
"is `true` for `rescue` and `catch` clauses.\n"
"\n"
"## Variable handling\n"
"\n"
"Since an expression inside `try` may not have been evaluated\n"
"due to an exception, any variable created inside `try` cannot\n"
"be accessed externally. For instance:\n"
"\n"
"    try do\n"
"      x = 1\n"
"      do_something_that_may_fail(same_arg)\n"
"      :ok\n"
"    catch\n"
"      _, _ -> :failed\n"
"    end\n"
"\n"
"    x #=> unbound variable `x`\n"
"\n"
"In the example above, `x` cannot be accessed since it was defined\n"
"inside the `try` clause. A common practice to address this issue\n"
"is to return the variables defined inside `try`:\n"
"\n"
"    x =\n"
"      try do\n"
"        x = 1\n"
"        do_something_that_may_fail(same_arg)\n"
"        x\n"
"      catch\n"
"        _, _ -> :failed\n"
"      end\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.cond(clauses)
#: lib/kernel/special_forms.ex:1471 
msgid ""
"Evaluates the expression corresponding to the first clause that\n"
"evaluates to truth value.\n"
"\n"
"Raises an error if all conditions evaluate to `nil` or `false`.\n"
"\n"
"## Examples\n"
"\n"
"    cond do\n"
"      1 + 1 == 1 ->\n"
"        \"This will never match\"\n"
"      2 * 2 != 4 ->\n"
"        \"Nor this\"\n"
"      true ->\n"
"        \"This will\"\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms..(left, right)
#: lib/kernel/special_forms.ex:366 
msgid ""
"Defines a remote call or an alias.\n"
"\n"
"The dot (`.`) in Elixir can be used for remote calls:\n"
"\n"
"    iex> String.downcase(\"FOO\")\n"
"    \"foo\"\n"
"\n"
"In this example above, we have used `.` to invoke `downcase` in the\n"
"`String` alias, passing \"FOO\" as argument. We can also use the dot\n"
"for creating aliases:\n"
"\n"
"    iex> Hello.World\n"
"    Hello.World\n"
"\n"
"This time, we have joined two aliases, defining the final alias\n"
"`Hello.World`.\n"
"\n"
"## Syntax\n"
"\n"
"The right side of `.` may be a word starting in upcase, which represents\n"
"an alias, a word starting with lowercase or underscore, any valid language\n"
"operator or any name wrapped in single- or double-quotes. Those are all valid\n"
"examples:\n"
"\n"
"    iex> Kernel.Sample\n"
"    Kernel.Sample\n"
"\n"
"    iex> Kernel.length([1, 2, 3])\n"
"    3\n"
"\n"
"    iex> Kernel.+(1, 2)\n"
"    3\n"
"\n"
"    iex> Kernel.\"length\"([1, 2, 3])\n"
"    3\n"
"\n"
"    iex> Kernel.'+'(1, 2)\n"
"    3\n"
"\n"
"Note that `Kernel.\"HELLO\"` will be treated as a remote call and not an alias.\n"
"This choice was done so every time single- or double-quotes are used, we have\n"
"a remote call regardless of the quote contents. This decision is also reflected\n"
"in the quoted expressions discussed below.\n"
"\n"
"## Quoted expression\n"
"\n"
"When `.` is used, the quoted expression may take two distinct\n"
"forms. When the right side starts with a lowercase letter (or\n"
"underscore):\n"
"\n"
"    iex> quote do: String.downcase(\"FOO\")\n"
"    {{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], [\"FOO\"]}\n"
"\n"
"Notice we have an inner tuple, containing the atom `:.` representing\n"
"the dot as first element:\n"
"\n"
"    {:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}\n"
"\n"
"This tuple follows the general quoted expression structure in Elixir,\n"
"with the name as first argument, some keyword list as metadata as second,\n"
"and the number of arguments as third. In this case, the arguments is the\n"
"alias `String` and the atom `:downcase`. The second argument is **always**\n"
"an atom:\n"
"\n"
"    iex> quote do: String.\"downcase\"(\"FOO\")\n"
"    {{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], [\"FOO\"]}\n"
"\n"
"The tuple containing `:.` is wrapped in another tuple, which actually\n"
"represents the function call, and has `\"FOO\"` as argument.\n"
"\n"
"When the right side is an alias (i.e. starts with uppercase), we get instead:\n"
"\n"
"    iex> quote do: Hello.World\n"
"    {:__aliases__, [alias: false], [:Hello, :World]}\n"
"\n"
"We got into more details about aliases in the `__aliases__` special form\n"
"documentation.\n"
"\n"
"## Unquoting\n"
"\n"
"We can also use unquote to generate a remote call in a quoted expression:\n"
"\n"
"    iex> x = :downcase\n"
"    iex> quote do: String.unquote(x)(\"FOO\")\n"
"    {{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], [\"FOO\"]}\n"
"\n"
"Similar to `Kernel.\"HELLO\"`, `unquote(x)` will always generate a remote call,\n"
"independent of the value of `x`. To generate an alias via the quoted expression,\n"
"one needs to rely on `Module.concat/2`:\n"
"\n"
"    iex> x = Sample\n"
"    iex> quote do: Module.concat(String, unquote(x))\n"
"    {{:., [], [{:__aliases__, [alias: false], [:Module]}, :concat]}, [],\n"
"     [{:__aliases__, [alias: false], [:String]}, Sample]}\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.quote(opts, block)
#: lib/kernel/special_forms.ex:731 
msgid ""
"Gets the representation of any expression.\n"
"\n"
"## Examples\n"
"\n"
"    quote do: sum(1, 2, 3)\n"
"    #=> {:sum, [], [1, 2, 3]}\n"
"\n"
"## Explanation\n"
"\n"
"Any Elixir code can be represented using Elixir data structures.\n"
"The building block of Elixir macros is a tuple with three elements,\n"
"for example:\n"
"\n"
"    {:sum, [], [1, 2, 3]}\n"
"\n"
"The tuple above represents a function call to `sum` passing 1, 2 and\n"
"3 as arguments. The tuple elements are:\n"
"\n"
"  * The first element of the tuple is always an atom or\n"
"    another tuple in the same representation.\n"
"\n"
"  * The second element of the tuple represents metadata.\n"
"\n"
"  * The third element of the tuple are the arguments for the\n"
"    function call. The third argument may be an atom, which is\n"
"    usually a variable (or a local call).\n"
"\n"
"## Options\n"
"\n"
"  * `:unquote` - when `false`, disables unquoting. Useful when you have a quote\n"
"    inside another quote and want to control what quote is able to unquote.\n"
"\n"
"  * `:location` - when set to `:keep`, keeps the current line and file from\n"
"    quote. Read the Stacktrace information section below for more\n"
"    information.\n"
"\n"
"  * `:context` - sets the resolution context.\n"
"\n"
"  * `:bind_quoted` - passes a binding to the macro. Whenever a binding is\n"
"    given, `unquote` is automatically disabled.\n"
"\n"
"## Quote literals\n"
"\n"
"Besides the tuple described above, Elixir has a few literals that\n"
"when quoted return themselves. They are:\n"
"\n"
"    :sum         #=> Atoms\n"
"    1            #=> Integers\n"
"    2.0          #=> Floats\n"
"    [1, 2]       #=> Lists\n"
"    \"strings\"    #=> Strings\n"
"    {key, value} #=> Tuples with two elements\n"
"\n"
"## Quote and macros\n"
"\n"
"`quote` is commonly used with macros for code generation. As an exercise,\n"
"let's define a macro that multiplies a number by itself (squared). Note\n"
"there is no reason to define such as a macro (and it would actually be\n"
"seen as a bad practice), but it is simple enough that it allows us to focus\n"
"on the important aspects of quotes and macros:\n"
"\n"
"    defmodule Math do\n"
"      defmacro squared(x) do\n"
"        quote do\n"
"          unquote(x) * unquote(x)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"We can invoke it as:\n"
"\n"
"    import Math\n"
"    IO.puts \"Got #{squared(5)}\"\n"
"\n"
"At first, there is nothing in this example that actually reveals it is a\n"
"macro. But what is happening is that, at compilation time, `squared(5)`\n"
"becomes `5 * 5`. The argument `5` is duplicated in the produced code, we\n"
"can see this behaviour in practice though because our macro actually has\n"
"a bug:\n"
"\n"
"    import Math\n"
"    my_number = fn ->\n"
"      IO.puts \"Returning 5\"\n"
"      5\n"
"    end\n"
"    IO.puts \"Got #{squared(my_number.())}\"\n"
"\n"
"The example above will print:\n"
"\n"
"    Returning 5\n"
"    Returning 5\n"
"    25\n"
"\n"
"Notice how \"Returning 5\" was printed twice, instead of just once. This is\n"
"because a macro receives an expression and not a value (which is what we\n"
"would expect in a regular function). This means that:\n"
"\n"
"    squared(my_number.())\n"
"\n"
"Actually expands to:\n"
"\n"
"    my_number.() * my_number.()\n"
"\n"
"Which invokes the function twice, explaining why we get the printed value\n"
"twice! In the majority of the cases, this is actually unexpected behaviour,\n"
"and that's why one of the first things you need to keep in mind when it\n"
"comes to macros is to **not unquote the same value more than once**.\n"
"\n"
"Let's fix our macro:\n"
"\n"
"    defmodule Math do\n"
"      defmacro squared(x) do\n"
"        quote do\n"
"          x = unquote(x)\n"
"          x * x\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"Now invoking `square(my_number.())` as before will print the value just\n"
"once.\n"
"\n"
"In fact, this pattern is so common that most of the times you will want\n"
"to use the `bind_quoted` option with `quote`:\n"
"\n"
"    defmodule Math do\n"
"      defmacro squared(x) do\n"
"        quote bind_quoted: [x: x] do\n"
"          x * x\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"`:bind_quoted` will translate to the same code as the example above.\n"
"`:bind_quoted` can be used in many cases and is seen as good practice,\n"
"not only because it helps us from running into common mistakes but also\n"
"because it allows us to leverage other tools exposed by macros, such as\n"
"unquote fragments discussed in some sections below.\n"
"\n"
"Before we finish this brief introduction, you will notice that, even though\n"
"we defined a variable `x` inside our quote:\n"
"\n"
"    quote do\n"
"      x = unquote(x)\n"
"      x * x\n"
"    end\n"
"\n"
"When we call:\n"
"\n"
"    import Math\n"
"    squared(5)\n"
"    x #=> ** (RuntimeError) undefined function or variable: x\n"
"\n"
"We can see that `x` did not leak to the user context. This happens\n"
"because Elixir macros are hygienic, a topic we will discuss at length\n"
"in the next sections as well.\n"
"\n"
"## Hygiene in variables\n"
"\n"
"Consider the following example:\n"
"\n"
"    defmodule Hygiene do\n"
"      defmacro no_interference do\n"
"        quote do: a = 1\n"
"      end\n"
"    end\n"
"\n"
"    require Hygiene\n"
"\n"
"    a = 10\n"
"    Hygiene.no_interference\n"
"    a #=> 10\n"
"\n"
"In the example above, `a` returns 10 even if the macro\n"
"is apparently setting it to 1 because variables defined\n"
"in the macro does not affect the context the macro is executed in.\n"
"If you want to set or get a variable in the caller's context, you\n"
"can do it with the help of the `var!` macro:\n"
"\n"
"    defmodule NoHygiene do\n"
"      defmacro interference do\n"
"        quote do: var!(a) = 1\n"
"      end\n"
"    end\n"
"\n"
"    require NoHygiene\n"
"\n"
"    a = 10\n"
"    NoHygiene.interference\n"
"    a #=> 1\n"
"\n"
"Note that you cannot even access variables defined in the same\n"
"module unless you explicitly give it a context:\n"
"\n"
"    defmodule Hygiene do\n"
"      defmacro write do\n"
"        quote do\n"
"          a = 1\n"
"        end\n"
"      end\n"
"\n"
"      defmacro read do\n"
"        quote do\n"
"          a\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    Hygiene.write\n"
"    Hygiene.read\n"
"    #=> ** (RuntimeError) undefined function or variable: a\n"
"\n"
"For such, you can explicitly pass the current module scope as\n"
"argument:\n"
"\n"
"    defmodule ContextHygiene do\n"
"      defmacro write do\n"
"        quote do\n"
"          var!(a, ContextHygiene) = 1\n"
"        end\n"
"      end\n"
"\n"
"      defmacro read do\n"
"        quote do\n"
"          var!(a, ContextHygiene)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    ContextHygiene.write\n"
"    ContextHygiene.read\n"
"    #=> 1\n"
"\n"
"## Hygiene in aliases\n"
"\n"
"Aliases inside quote are hygienic by default.\n"
"Consider the following example:\n"
"\n"
"    defmodule Hygiene do\n"
"      alias HashDict, as: D\n"
"\n"
"      defmacro no_interference do\n"
"        quote do: D.new\n"
"      end\n"
"    end\n"
"\n"
"    require Hygiene\n"
"    Hygiene.no_interference #=> #HashDict<[]>\n"
"\n"
"Notice that, even though the alias `D` is not available\n"
"in the context the macro is expanded, the code above works\n"
"because `D` still expands to `HashDict`.\n"
"\n"
"Similarly, even if we defined an alias with the same name\n"
"before invoking a macro, it won't affect the macro's result:\n"
"\n"
"    defmodule Hygiene do\n"
"      alias HashDict, as: D\n"
"\n"
"      defmacro no_interference do\n"
"        quote do: D.new\n"
"      end\n"
"    end\n"
"\n"
"    require Hygiene\n"
"    alias SomethingElse, as: D\n"
"    Hygiene.no_interference #=> #HashDict<[]>\n"
"\n"
"In some cases, you want to access an alias or a module defined\n"
"in the caller. For such, you can use the `alias!` macro:\n"
"\n"
"    defmodule Hygiene do\n"
"      # This will expand to Elixir.Nested.hello\n"
"      defmacro no_interference do\n"
"        quote do: Nested.hello\n"
"      end\n"
"\n"
"      # This will expand to Nested.hello for\n"
"      # whatever is Nested in the caller\n"
"      defmacro interference do\n"
"        quote do: alias!(Nested).hello\n"
"      end\n"
"    end\n"
"\n"
"    defmodule Parent do\n"
"      defmodule Nested do\n"
"        def hello, do: \"world\"\n"
"      end\n"
"\n"
"      require Hygiene\n"
"      Hygiene.no_interference\n"
"      #=> ** (UndefinedFunctionError) ...\n"
"\n"
"      Hygiene.interference\n"
"      #=> \"world\"\n"
"    end\n"
"\n"
"## Hygiene in imports\n"
"\n"
"Similar to aliases, imports in Elixir are hygienic. Consider the\n"
"following code:\n"
"\n"
"    defmodule Hygiene do\n"
"      defmacrop get_size do\n"
"        quote do\n"
"          size(\"hello\")\n"
"        end\n"
"      end\n"
"\n"
"      def return_size do\n"
"        import Kernel, except: [size: 1]\n"
"        get_size\n"
"      end\n"
"    end\n"
"\n"
"    Hygiene.return_size #=> 5\n"
"\n"
"Notice how `return_size` returns 5 even though the `size/1`\n"
"function is not imported. In fact, even if `return_size` imported\n"
"a function from another module, it wouldn't affect the function\n"
"result:\n"
"\n"
"    def return_size do\n"
"      import Dict, only: [size: 1]\n"
"      get_size\n"
"    end\n"
"\n"
"Calling this new `return_size` will still return 5 as result.\n"
"\n"
"Elixir is smart enough to delay the resolution to the latest\n"
"moment possible. So, if you call `size(\"hello\")` inside quote,\n"
"but no `size/1` function is available, it is then expanded in\n"
"the caller:\n"
"\n"
"    defmodule Lazy do\n"
"      defmacrop get_size do\n"
"        import Kernel, except: [size: 1]\n"
"\n"
"        quote do\n"
"          size([a: 1, b: 2])\n"
"        end\n"
"      end\n"
"\n"
"      def return_size do\n"
"        import Kernel, except: [size: 1]\n"
"        import Dict, only: [size: 1]\n"
"        get_size\n"
"      end\n"
"    end\n"
"\n"
"    Lazy.return_size #=> 2\n"
"\n"
"## Stacktrace information\n"
"\n"
"When defining functions via macros, developers have the option of\n"
"choosing if runtime errors will be reported from the caller or from\n"
"inside the quote. Let's see an example:\n"
"\n"
"    # adder.ex\n"
"    defmodule Adder do\n"
"      @doc \"Defines a function that adds two numbers\"\n"
"      defmacro defadd do\n"
"        quote location: :keep do\n"
"          def add(a, b), do: a + b\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    # sample.ex\n"
"    defmodule Sample do\n"
"      import Adder\n"
"      defadd\n"
"    end\n"
"\n"
"When using `location: :keep` and invalid arguments are given to\n"
"`Sample.add/2`, the stacktrace information will point to the file\n"
"and line inside the quote. Without `location: :keep`, the error is\n"
"reported to where `defadd` was invoked. Note `location: :keep` affects\n"
"only definitions inside the quote.\n"
"\n"
"## Binding and unquote fragments\n"
"\n"
"Elixir quote/unquote mechanisms provides a functionality called\n"
"unquote fragments. Unquote fragments provide an easy way to generate\n"
"functions on the fly. Consider this example:\n"
"\n"
"    kv = [foo: 1, bar: 2]\n"
"    Enum.each kv, fn {k, v} ->\n"
"      def unquote(k)(), do: unquote(v)\n"
"    end\n"
"\n"
"In the example above, we have generated the functions `foo/0` and\n"
"`bar/0` dynamically. Now, imagine that, we want to convert this\n"
"functionality into a macro:\n"
"\n"
"    defmacro defkv(kv) do\n"
"      Enum.map kv, fn {k, v} ->\n"
"        quote do\n"
"          def unquote(k)(), do: unquote(v)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"We can invoke this macro as:\n"
"\n"
"    defkv [foo: 1, bar: 2]\n"
"\n"
"However, we can't invoke it as follows:\n"
"\n"
"    kv = [foo: 1, bar: 2]\n"
"    defkv kv\n"
"\n"
"This is because the macro is expecting its arguments to be a\n"
"keyword list at **compilation** time. Since in the example above\n"
"we are passing the representation of the variable `kv`, our\n"
"code fails.\n"
"\n"
"This is actually a common pitfall when developing macros. We are\n"
"assuming a particular shape in the macro. We can work around it\n"
"by unquoting the variable inside the quoted expression:\n"
"\n"
"    defmacro defkv(kv) do\n"
"      quote do\n"
"        Enum.each unquote(kv), fn {k, v} ->\n"
"          def unquote(k)(), do: unquote(v)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"If you try to run our new macro, you will notice it won't\n"
"even compile, complaining that the variables `k` and `v`\n"
"do not exist. This is because of the ambiguity: `unquote(k)`\n"
"can either be an unquote fragment, as previously, or a regular\n"
"unquote as in `unquote(kv)`.\n"
"\n"
"One solution to this problem is to disable unquoting in the\n"
"macro, however, doing that would make it impossible to inject the\n"
"`kv` representation into the tree. That's when the `:bind_quoted`\n"
"option comes to the rescue (again!). By using `:bind_quoted`, we\n"
"can automatically disable unquoting while still injecting the\n"
"desired variables into the tree:\n"
"\n"
"    defmacro defkv(kv) do\n"
"      quote bind_quoted: [kv: kv] do\n"
"        Enum.each kv, fn {k, v} ->\n"
"          def unquote(k)(), do: unquote(v)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"In fact, the `:bind_quoted` option is recommended every time\n"
"one desires to inject a value into the quote.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.fn(clauses)
#: lib/kernel/special_forms.ex:1293 
msgid ""
"Defines an anonymous function.\n"
"\n"
"## Examples\n"
"\n"
"    iex> add = fn a, b -> a + b end\n"
"    iex> add.(1, 2)\n"
"    3\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.{}(args)
#: lib/kernel/special_forms.ex:22 
msgid ""
"Creates a tuple.\n"
"\n"
"Only two item tuples are considered literals in Elixir.\n"
"Therefore all other tuples are represented in the AST\n"
"as a call to the special form `:{}`.\n"
"\n"
"Conveniences for manipulating tuples can be found in the\n"
"`Tuple` module. Some functions for working with tuples are\n"
"also available in `Kernel`, namely `Kernel.elem/2`,\n"
"`Kernel.put_elem/3` and `Kernel.tuple_size/1`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> {1, 2, 3}\n"
"    {1, 2, 3}\n"
"\n"
"    iex> quote do: {1, 2, 3}\n"
"    {:{}, [], [1, 2, 3]}\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.%(struct, map)
#: lib/kernel/special_forms.ex:105 
msgid ""
"Creates a struct.\n"
"\n"
"A struct is a tagged map that allows developers to provide\n"
"default values for keys, tags to be used in polymorphic\n"
"dispatches and compile time assertions.\n"
"\n"
"To define a struct, you just need to implement the `__struct__/0`\n"
"function in a module:\n"
"\n"
"    defmodule User do\n"
"      def __struct__ do\n"
"        %{name: \"john\", age: 27}\n"
"      end\n"
"    end\n"
"\n"
"In practice though, structs are usually defined with the\n"
"`Kernel.defstruct/1` macro:\n"
"\n"
"    defmodule User do\n"
"      defstruct name: \"john\", age: 27\n"
"    end\n"
"\n"
"Now a struct can be created as follows:\n"
"\n"
"    %User{}\n"
"\n"
"Underneath a struct is just a map with a `__struct__` field\n"
"pointing to the `User` module:\n"
"\n"
"    %User{} == %{__struct__: User, name: \"john\", age: 27}\n"
"\n"
"A struct also validates that the given keys are part of the defined\n"
"struct. The example below will fail because there is no key\n"
"`:full_name` in the `User` struct:\n"
"\n"
"    %User{full_name: \"john doe\"}\n"
"\n"
"Note that a struct specifies a minimum set of keys required\n"
"for operations. Other keys can be added to structs via the\n"
"regular map operations:\n"
"\n"
"    user = %User{}\n"
"    Map.put(user, :a_non_struct_key, :value)\n"
"\n"
"An update operation specific for structs is also available:\n"
"\n"
"    %User{user | age: 28}\n"
"\n"
"The syntax above will guarantee the given keys are valid at\n"
"compilation time and it will guarantee at runtime the given\n"
"argument is a struct, failing with `BadStructError` otherwise.\n"
"\n"
"Although structs are maps, by default structs do not implement\n"
"any of the protocols implemented for maps. Check\n"
"`Kernel.defprotocol/2` for more information on how structs\n"
"can be used with protocols for polymorphic dispatch. Also\n"
"see `Kernel.struct/2` for examples on how to create and update\n"
"structs dynamically.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.for(args)
#: lib/kernel/special_forms.ex:1225 
msgid ""
"Comprehensions allow you to quickly build a data structure from\n"
"an enumerable or a bitstring.\n"
"\n"
"Let's start with an example:\n"
"\n"
"    iex> for n <- [1, 2, 3, 4], do: n * 2\n"
"    [2, 4, 6, 8]\n"
"\n"
"A comprehension accepts many generators and filters. Enumerable\n"
"generators are defined using `<-`:\n"
"\n"
"    # A list generator:\n"
"    iex> for n <- [1, 2, 3, 4], do: n * 2\n"
"    [2, 4, 6, 8]\n"
"\n"
"    # A comprehension with two generators\n"
"    iex> for x <- [1, 2], y <- [2, 3], do: x*y\n"
"    [2, 3, 4, 6]\n"
"\n"
"Filters can also be given:\n"
"\n"
"    # A comprehension with a generator and a filter\n"
"    iex> for n <- [1, 2, 3, 4, 5, 6], rem(n, 2) == 0, do: n\n"
"    [2, 4, 6]\n"
"\n"
"Note generators can also be used to filter as it removes any value\n"
"that doesn't match the left side of `<-`:\n"
"\n"
"    iex> for {:user, name} <- [user: \"john\", admin: \"john\", user: \"meg\"] do\n"
"    ...>   String.upcase(name)\n"
"    ...> end\n"
"    [\"JOHN\", \"MEG\"]\n"
"\n"
"Bitstring generators are also supported and are very useful when you\n"
"need to organize bitstring streams:\n"
"\n"
"    iex> pixels = <<213, 45, 132, 64, 76, 32, 76, 0, 0, 234, 32, 15>>\n"
"    iex> for <<r::8, g::8, b::8 <- pixels >>, do: {r, g, b}\n"
"    [{213, 45, 132}, {64, 76, 32}, {76, 0, 0}, {234, 32, 15}]\n"
"\n"
"Variable assignments inside the comprehension, be it in generators,\n"
"filters or inside the block, are not reflected outside of the\n"
"comprehension.\n"
"\n"
"## Into\n"
"\n"
"In the examples above, the result returned by the comprehension was\n"
"always a list. The returned result can be configured by passing an\n"
"`:into` option, that accepts any structure as long as it implements\n"
"the `Collectable` protocol.\n"
"\n"
"For example, we can use bitstring generators with the `:into` option\n"
"to easily remove all spaces in a string:\n"
"\n"
"    iex> for <<c <- \" hello world \">>, c != ?\\s, into: \"\", do: <<c>>\n"
"    \"helloworld\"\n"
"\n"
"The `IO` module provides streams, that are both `Enumerable` and\n"
"`Collectable`, here is an upcase echo server using comprehensions:\n"
"\n"
"    for line <- IO.stream(:stdio, :line), into: IO.stream(:stdio, :line) do\n"
"      String.upcase(line)\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.%{}(args)
#: lib/kernel/special_forms.ex:45 
msgid ""
"Creates a map.\n"
"\n"
"Maps are key-value stores where keys are compared\n"
"using the match operator (`===`). Maps can be created with\n"
"the `%{}` special form where keys are associated via `=>`:\n"
"\n"
"    %{1 => 2}\n"
"\n"
"Maps also support the keyword notation, as other special forms,\n"
"as long as they are at the end of the argument list:\n"
"\n"
"    %{hello: :world, with: :keywords}\n"
"    %{:hello => :world, with: :keywords}\n"
"\n"
"If a map has duplicated keys, the last key will always have\n"
"higher precedence:\n"
"\n"
"    iex> %{a: :b, a: :c}\n"
"    %{a: :c}\n"
"\n"
"Conveniences for manipulating maps can be found in the\n"
"`Map` module.\n"
"\n"
"## Access syntax\n"
"\n"
"Besides the access functions available in the `Map` module,\n"
"like `Map.get/3` and `Map.fetch/2`, a map can be accessed using the\n"
"`.` operator:\n"
"\n"
"    iex> map = %{a: :b}\n"
"    iex> map.a\n"
"    :b\n"
"\n"
"Note that the `.` operator expects the field to exist in the map.\n"
"If not, an `ArgumentError` is raised.\n"
"\n"
"## Update syntax\n"
"\n"
"Maps also support an update syntax:\n"
"\n"
"    iex> map = %{:a => :b}\n"
"    iex> %{map | :a => :c}\n"
"    %{:a => :c}\n"
"\n"
"Notice the update syntax requires the given keys to exist.\n"
"Trying to update a key that does not exist will raise an `ArgumentError`.\n"
"\n"
"## AST representation\n"
"\n"
"Regardless if `=>` or the keywords syntax is used, Maps are\n"
"always represented internally as a list of two-items tuples\n"
"for simplicity:\n"
"\n"
"    iex> quote do: %{:a => :b, c: :d}\n"
"    {:%{}, [], [{:a, :b}, {:c, :d}]}\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.receive(args)
#: lib/kernel/special_forms.ex:1712 
msgid ""
"Checks if there is a message matching the given clauses\n"
"in the current process mailbox.\n"
"\n"
"In case there is no such message, the current process hangs\n"
"until a message arrives or waits until a given timeout value.\n"
"\n"
"## Examples\n"
"\n"
"    receive do\n"
"      {:selector, i, value} when is_integer(i) ->\n"
"        value\n"
"      value when is_atom(value) ->\n"
"        value\n"
"      _ ->\n"
"        IO.puts :stderr, \"Unexpected message received\"\n"
"    end\n"
"\n"
"An optional after clause can be given in case the message was not\n"
"received after the specified period of time:\n"
"\n"
"    receive do\n"
"      {:selector, i, value} when is_integer(i) ->\n"
"        value\n"
"      value when is_atom(value) ->\n"
"        value\n"
"      _ ->\n"
"        IO.puts :stderr, \"Unexpected message received\"\n"
"    after\n"
"      5000 ->\n"
"        IO.puts :stderr, \"No message in 5 seconds\"\n"
"    end\n"
"\n"
"The `after` clause can be specified even if there are no match clauses.\n"
"There are two special cases for the timeout value given to `after`\n"
"\n"
"  * `:infinity` - the process should wait indefinitely for a matching\n"
"    message, this is the same as not using a timeout\n"
"\n"
"  * 0 - if there is no matching message in the mailbox, the timeout\n"
"    will occur immediately\n"
"\n"
"## Variables handling\n"
"\n"
"The `receive` special form handles variables exactly as the `case`\n"
"special macro. For more information, check the docs for `case/2`.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.&(expr)
#: lib/kernel/special_forms.ex:1318 
msgid ""
"Captures or creates an anonymous function.\n"
"\n"
"## Capture\n"
"\n"
"The capture operator is most commonly used to capture a\n"
"function with given name and arity from a module:\n"
"\n"
"    iex> fun = &Kernel.is_atom/1\n"
"    iex> fun.(:atom)\n"
"    true\n"
"    iex> fun.(\"string\")\n"
"    false\n"
"\n"
"In the example above, we captured `Kernel.is_atom/1` as an\n"
"anonymous function and then invoked it.\n"
"\n"
"The capture operator can also be used to capture local functions,\n"
"including private ones, and imported functions by omitting the\n"
"module name:\n"
"\n"
"    &local_function/1\n"
"\n"
"## Anonymous functions\n"
"\n"
"The capture operator can also be used to partially apply\n"
"functions, where `&1`, `&2` and so on can be used as value\n"
"placeholders. For example:\n"
"\n"
"    iex> double = &(&1 * 2)\n"
"    iex> double.(2)\n"
"    4\n"
"\n"
"In other words, `&(&1 * 2)` is equivalent to `fn x -> x * 2 end`.\n"
"Another example using a local function:\n"
"\n"
"    iex> fun = &is_atom(&1)\n"
"    iex> fun.(:atom)\n"
"    true\n"
"\n"
"The `&` operator can be used with more complex expressions:\n"
"\n"
"    iex> fun = &(&1 + &2 + &3)\n"
"    iex> fun.(1, 2, 3)\n"
"    6\n"
"\n"
"As well as with lists and tuples:\n"
"\n"
"    iex> fun = &{&1, &2}\n"
"    iex> fun.(1, 2)\n"
"    {1, 2}\n"
"\n"
"    iex> fun = &[&1|&2]\n"
"    iex> fun.(1, 2)\n"
"    [1|2]\n"
"\n"
"The only restrictions when creating anonymous functions is that at\n"
"least one placeholder must be present, i.e. it must contain at least\n"
"`&1`:\n"
"\n"
"    # No placeholder fails to compile\n"
"    &var\n"
"\n"
"    # Block expressions are also not supported\n"
"    &(foo(&1, &2); &3 + &4)\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.^(var)
#: lib/kernel/special_forms.ex:674 
msgid ""
"Accesses an already bound variable in match clauses.\n"
"\n"
"## Examples\n"
"\n"
"Elixir allows variables to be rebound via static single assignment:\n"
"\n"
"    iex> x = 1\n"
"    iex> x = x + 1\n"
"    iex> x\n"
"    2\n"
"\n"
"However, in some situations, it is useful to match against an existing\n"
"value, instead of rebinding. This can be done with the `^` special form:\n"
"\n"
"    iex> x = 1\n"
"    iex> ^x = List.first([1])\n"
"    iex> ^x = List.first([2])\n"
"    ** (MatchError) no match of right hand side value: 2\n"
"\n"
"Note that `^` always refers to the value of x prior to the match. The\n"
"following example will match:\n"
"\n"
"    iex> x = 0\n"
"    iex> {x, ^x} = {1, 0}\n"
"    iex> x\n"
"    1\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.super(args)
#: lib/kernel/special_forms.ex:1417 
msgid ""
"Calls the overriden function when overriding it with `Kernel.defoverridable/1`.\n"
"\n"
"See `Kernel.defoverridable/1` for more information and documentation.\n"
msgstr ""
