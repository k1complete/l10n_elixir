#. TRANSLATORS: def Agent.update(agent, fun, timeout \\ 5000)
#: lib/agent.ex:248 
msgid ""
"Updates the agent state.\n"
"\n"
"The function `fun` is sent to the `agent` which invokes the function\n"
"passing the agent state. The function must return the new state.\n"
"\n"
"A timeout can also be specified (it has a default value of 5000).\n"
"This function always returns `:ok`.\n"
msgstr ""
#. TRANSLATORS: def Agent.update(agent, module, fun, args, timeout \\ 5000)
#: lib/agent.ex:260 
msgid ""
"Updates the agent state.\n"
"\n"
"Same as `update/3` but a module, function and args are expected\n"
"instead of an anonymous function. The state is added as first\n"
"argument to the given list of args.\n"
msgstr ""
#. TRANSLATORS: def Enum.take_while(collection, fun)
#: lib/enum.ex:1777 
msgid ""
"Takes the items at the beginning of `collection` while `fun` returns `true`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.take_while([1, 2, 3], fn(x) -> x < 3 end)\n"
"    [1, 2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.take(collection, count)
#: lib/enum.ex:1721 
msgid ""
"Takes the first `count` items from the collection.\n"
"\n"
"`count` must be an integer. If a negative `count` is given, the last `count` values will\n"
"be taken. For such, the collection is fully enumerated keeping up\n"
"to `2 * count` elements in memory. Once the end of the collection is\n"
"reached, the last `count` elements are returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.take([1, 2, 3], 2)\n"
"    [1,2]\n"
"\n"
"    iex> Enum.take([1, 2, 3], 10)\n"
"    [1,2,3]\n"
"\n"
"    iex> Enum.take([1, 2, 3], 0)\n"
"    []\n"
"\n"
"    iex> Enum.take([1, 2, 3], -1)\n"
"    [3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.group_by(collection, dict \\ %{}, fun)
#: lib/enum.ex:1242 
msgid ""
"Splits `collection` into groups based on `fun`.\n"
"\n"
"The result is a dict (by default a map) where each key is\n"
"a group and each value is a list of elements from `collection`\n"
"for which `fun` returned that group. Ordering is not necessarily\n"
"preserved.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.group_by(~w{ant buffalo cat dingo}, &String.length/1)\n"
"    %{3 => [\"cat\", \"ant\"], 7 => [\"buffalo\"], 5 => [\"dingo\"]}\n"
"\n"
msgstr ""
#. TRANSLATORS: def File.touch(path, time \\ :calendar.local_time())
#: lib/file.ex:320 
msgid ""
"Updates modification time (mtime) and access time (atime) of\n"
"the given file. File is created if it doesnâ€™t exist.\n"
msgstr ""
#. TRANSLATORS: def Application.unload(app)
#: lib/application.ex:279 
msgid ""
"Unloads the given `app`.\n"
"\n"
"It will also unload all `:included_applications`.\n"
"Note that the function does not purge the application modules.\n"
msgstr ""
#. TRANSLATORS: def Dict.update(dict, key, initial, fun)
#: lib/dict.ex:559 
msgid ""
"Update a value in `dict` by calling `fun` on the value to get a new value. If\n"
"`key` is not present in `dict` then `initial` will be stored as the first\n"
"value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.update(dict, :c, 3, fn(val) -> -val end)\n"
"    iex> Dict.get(dict, :c)\n"
"    3\n"
"\n"
msgstr ""
#. TRANSLATORS: def GenEvent.ack_notify(manager, event)
#: lib/gen_event.ex:425 
msgid ""
"Sends a ack event notification to the event `manager`.\n"
"\n"
"In other words, this function only returns `:ok` as soon as the\n"
"event manager starts processing this event, but it does not wait\n"
"for event handlers to process the sent event.\n"
"\n"
"See `notify/2` for more info. Note this function is specific\n"
"to Elixir's GenEvent and does not work with Erlang ones.\n"
msgstr ""
#. TRANSLATORS: def IO.write(device \\ :erlang.group_leader(), item)
#: lib/io.ex:150 
msgid ""
"Writes the given argument to the given device.\n"
"\n"
"By default the device is the standard output.\n"
"It returns `:ok` if it succeeds.\n"
"\n"
"## Examples\n"
"\n"
"    IO.write \"sample\"\n"
"    #=> \"sample\"\n"
"\n"
"    IO.write :stderr, \"error\"\n"
"    #=> \"error\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def IO.binwrite(device \\ :erlang.group_leader(), item)
#: lib/io.ex:164 
msgid ""
"Writes the given argument to the given device\n"
"as a binary, no unicode conversion happens.\n"
"\n"
"Check `write/2` for more information.\n"
"\n"
"Note: do not use this function on IO devices in unicode mode\n"
"as it will return the wrong result.\n"
msgstr ""
#. TRANSLATORS: def File.write_stat(path, stat, opts \\ [])
#: lib/file.ex:297 
msgid ""
"Writes the given `File.Stat` back to the filesystem at the given\n"
"path. Returns `:ok` or `{:error, reason}`.\n"
msgstr ""
#. TRANSLATORS: def IO.puts(device \\ :erlang.group_leader(), item)
#: lib/io.ex:174 
msgid ""
"Writes the argument to the device, similar to `write/2`,\n"
"but adds a newline at the end. The argument is expected\n"
"to be a chardata.\n"
msgstr ""
#. TRANSLATORS: def File.write(path, content, modes \\ [])
#: lib/file.ex:628 
msgid ""
"Writes `content` to the file `path`.\n"
"\n"
"The file is created if it does not exist. If it exists, the previous\n"
"contents are overwritten. Returns `:ok` if successful, or `{:error, reason}`\n"
"if an error occurs.\n"
"\n"
"**Warning:** Every time this function is invoked, a file descriptor is opened\n"
"and a new process is spawned to write to the file. For this reason, if you are\n"
"doing multiple writes in a loop, opening the file via `File.open/2` and using\n"
"the functions in `IO` to write to the file will yield much better performance\n"
"then calling this function multiple times.\n"
"\n"
"Typical error reasons are:\n"
"\n"
"  * `:enoent`  - a component of the file name does not exist\n"
"  * `:enotdir` - a component of the file name is not a directory;\n"
"                 on some platforms, enoent is returned instead\n"
"  * `:enospc`  - there is a no space left on the device\n"
"  * `:eacces`  - missing permission for writing the file or searching one of\n"
"                 the parent directories\n"
"  * `:eisdir`  - the named file is a directory\n"
"\n"
"Check `File.open/2` for other available options.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.|>(left, right)
#: lib/kernel.ex:2372 
msgid ""
"`|>` is the pipe operator.\n"
"\n"
"This operator introduces the expression on the left as\n"
"the first argument to the function call on the right.\n"
"\n"
"## Examples\n"
"\n"
"    iex> [1, [2], 3] |> List.flatten()\n"
"    [1, 2, 3]\n"
"\n"
"The example above is the same as calling `List.flatten([1, [2], 3])`,\n"
"i.e. the argument on the left side of `|>` is introduced as the first\n"
"argument of the function call on the right side.\n"
"\n"
"This pattern is mostly useful when there is a desire to execute\n"
"a bunch of operations, resembling a pipeline:\n"
"\n"
"    iex> [1, [2], 3] |> List.flatten |> Enum.map(fn x -> x * 2 end)\n"
"    [2, 4, 6]\n"
"\n"
"The example above will pass the list to `List.flatten/1`, then get\n"
"the flattened list and pass to `Enum.map/2`, which will multiply\n"
"each entry in the list per two.\n"
"\n"
"In other words, the expression above simply translates to:\n"
"\n"
"    Enum.map(List.flatten([1, [2], 3]), fn x -> x * 2 end)\n"
"\n"
"Beware of operator precedence when using the pipe operator.\n"
"For example, the following expression:\n"
"\n"
"    String.graphemes \"Hello\" |> Enum.reverse\n"
"\n"
"Translates to:\n"
"\n"
"    String.graphemes(\"Hello\" |> Enum.reverse)\n"
"\n"
"Which will result in an error as Enumerable protocol is not defined\n"
"for binaries. Adding explicit parenthesis resolves the ambiguity:\n"
"\n"
"    String.graphemes(\"Hello\") |> Enum.reverse\n"
"\n"
"Or, even better:\n"
"\n"
"    \"Hello\" |> String.graphemes |> Enum.reverse\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.use(module, opts \\ [])
#: lib/kernel.ex:3259 
msgid ""
"`use` is a simple mechanism for using a given module into\n"
"the current context.\n"
"\n"
"## Examples\n"
"\n"
"For example, in order to write tests using the ExUnit framework,\n"
"a developer should use the `ExUnit.Case` module:\n"
"\n"
"    defmodule AssertionTest do\n"
"      use ExUnit.Case, async: true\n"
"\n"
"      test \"always pass\" do\n"
"        assert true\n"
"      end\n"
"    end\n"
"\n"
"By calling `use`, a hook called `__using__` will be invoked in\n"
"`ExUnit.Case` which will then do the proper setup.\n"
"\n"
"Simply put, `use` is simply a translation to:\n"
"\n"
"    defmodule AssertionTest do\n"
"      require ExUnit.Case\n"
"      ExUnit.Case.__using__([async: true])\n"
"\n"
"      test \"always pass\" do\n"
"        assert true\n"
"      end\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.alias(module, opts)
#: lib/kernel/special_forms.ex:451 
msgid ""
"`alias` is used to setup aliases, often useful with modules names.\n"
"\n"
"## Examples\n"
"\n"
"`alias` can be used to setup an alias for any module:\n"
"\n"
"    defmodule Math do\n"
"      alias MyKeyword, as: Keyword\n"
"    end\n"
"\n"
"In the example above, we have set up `MyKeyword` to be aliased\n"
"as `Keyword`. So now, any reference to `Keyword` will be\n"
"automatically replaced by `MyKeyword`.\n"
"\n"
"In case one wants to access the original `Keyword`, it can be done\n"
"by accessing `Elixir`:\n"
"\n"
"    Keyword.values   #=> uses MyKeyword.values\n"
"    Elixir.Keyword.values #=> uses Keyword.values\n"
"\n"
"Notice that calling `alias` without the `as:` option automatically\n"
"sets an alias based on the last part of the module. For example:\n"
"\n"
"    alias Foo.Bar.Baz\n"
"\n"
"Is the same as:\n"
"\n"
"    alias Foo.Bar.Baz, as: Baz\n"
"\n"
"## Lexical scope\n"
"\n"
"`import`, `require` and `alias` are called directives and all\n"
"have lexical scope. This means you can set up aliases inside\n"
"specific functions and it won't affect the overall scope.\n"
"\n"
"## Warnings\n"
"\n"
"If you alias a module and you don't use the alias, Elixir is\n"
"going to issue a warning implying the alias is not being used.\n"
"\n"
"In case the alias is generated automatically by a macro,\n"
"Elixir won't emit any warnings though, since the alias\n"
"was not explicitly defined.\n"
"\n"
"Both warning behaviours could be changed by explicitly\n"
"setting the `:warn` option to true or false.\n"
msgstr ""
#. TRANSLATORS: Elixir.Kernel Summary
#: lib/kernel.ex:8 
msgid ""
"`Kernel` provides the default macros and functions\n"
"Elixir imports into your environment. These macros and functions\n"
"can be skipped or cherry-picked via the `import` macro. For\n"
"instance, if you want to tell Elixir not to import the `if`\n"
"macro, you can do:\n"
"\n"
"    import Kernel, except: [if: 2]\n"
"\n"
"Elixir also has special forms that are always imported and\n"
"cannot be skipped. These are described in `Kernel.SpecialForms`.\n"
"\n"
"Some of the functions described in this module are inlined by\n"
"the Elixir compiler into their Erlang counterparts in the `:erlang`\n"
"module. Those functions are called BIFs (builtin internal functions)\n"
"in Erlang-land and they exhibit interesting properties, as some of\n"
"them are allowed in guards and others are used for compiler\n"
"optimizations.\n"
"\n"
"Most of the inlined functions can be seen in effect when capturing\n"
"the function:\n"
"\n"
"    iex> &Kernel.is_atom/1\n"
"    &:erlang.is_atom/1\n"
"\n"
"Those functions will be explicitly marked in their docs as\n"
"\"inlined by the compiler\".\n"
msgstr ""
#. TRANSLATORS: def Keyword.update!(keywords, key, fun)
#: lib/keyword.ex:422 
msgid ""
"Updates the `key` with the given function. \n"
"\n"
"If the `key` does not exist, raises `KeyError`.\n"
"\n"
"If there are duplicated keys, they are all removed and only the first one\n"
"is updated.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.update!([a: 1], :a, &(&1 * 2))\n"
"    [a: 2]\n"
"\n"
"    iex> Keyword.update!([a: 1], :b, &(&1 * 2))\n"
"    ** (KeyError) key :b not found in: [a: 1]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.update(list1, key, initial, fun)
#: lib/keyword.ex:456 
msgid ""
"Updates the `key` with the given function. \n"
"\n"
"If the `key` does not exist, inserts the given `initial` value.\n"
"\n"
"If there are duplicated keys, they are all removed and only the first one\n"
"is updated.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.update([a: 1], :a, 13, &(&1 * 2))\n"
"    [a: 2]\n"
"\n"
"    iex> Keyword.update([a: 1], :b, 11, &(&1 * 2))\n"
"    [a: 1, b: 11]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Dict.update!(dict, key, fun)
#: lib/dict.ex:541 
msgid ""
"Update a value in `dict` by calling `fun` on the value to get a new\n"
"value. An exception is generated if `key` is not present in the dict.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.update!(dict, :a, fn(val) -> -val end)\n"
"    iex> Dict.get(dict, :a)\n"
"    -1\n"
"\n"
msgstr ""
#. TRANSLATORS: def File.ls!(path \\ ".")
#: lib/file.ex:1092 
msgid ""
"The same as `ls/1` but raises `File.Error`\n"
"in case of an error.\n"
msgstr ""
#. TRANSLATORS: def File.cwd!()
#: lib/file.ex:1023 
msgid ""
"The same as `cwd/0`, but raises an exception if it fails.\n"
msgstr ""
#. TRANSLATORS: def File.cp_r!(source, destination, callback \\ fn _, _ -> true end)
#: lib/file.ex:509 
msgid ""
"The same as `cp_r/3`, but raises `File.CopyError` if it fails.\n"
"Returns the list of copied files otherwise.\n"
msgstr ""
#. TRANSLATORS: def File.cp!(source, destination, callback \\ fn _, _ -> true end)
#: lib/file.ex:438 
msgid ""
"The same as `cp/3`, but raises `File.CopyError` if it fails.\n"
"Returns the list of copied files otherwise.\n"
msgstr ""
#. TRANSLATORS: def File.copy!(source, destination, bytes_count \\ :infinity)
#: lib/file.ex:392 
msgid ""
"The same as `copy/3` but raises an `File.CopyError` if it fails.\n"
"Returns the `bytes_copied` otherwise.\n"
msgstr ""
#. TRANSLATORS: def File.cd!(path)
#: lib/file.ex:1045 
msgid ""
"The same as `cd/1`, but raises an exception if it fails.\n"
msgstr ""
#. TRANSLATORS: def IO.ANSI.underline()
#: lib/io/ansi.ex:57 
msgid ""
"Underline: Single"
msgstr ""
#. TRANSLATORS: def IO.ANSI.no_underline()
#: lib/io/ansi.ex:92 
msgid ""
"Underline: None"
msgstr ""
#. TRANSLATORS: def IO.ANSI.Docs.default_options()
#: lib/io/ansi/docs.ex:24 
msgid ""
"The default options used by this module.\n"
"\n"
"The supported values are:\n"
"\n"
"  * `:enabled`           - toggles coloring on and off (true)\n"
"  * `:doc_bold`          - bold text (bright)\n"
"  * `:doc_code`          - code blocks (cyan, bright)\n"
"  * `:doc_headings`      - h1 and h2 headings (yellow, bright)\n"
"  * `:doc_inline_code`   - inline code (cyan)\n"
"  * `:doc_table_heading` - style for table headings\n"
"  * `:doc_title`         - top level heading (reverse, yellow, bright)\n"
"  * `:doc_underline`     - underlined text (underline)\n"
"  * `:width`             - the width to format the text (80)\n"
"\n"
"Values for the color settings are strings with\n"
"comma-separated ANSI values.\n"
msgstr ""
#. TRANSLATORS: def Inspect.Algebra.format(d, w)
#: lib/inspect/algebra.ex:486 
msgid ""
"The formatting function.\n"
"\n"
"Takes the maximum width and a document to print as its arguments\n"
"and returns an IO data representation of the best layout for the\n"
"document to fit in the given width.\n"
msgstr ""
#. TRANSLATORS: def Node.start(name, type \\ :longnames, tick_time \\ 15000)
#: lib/node.ex:21 
msgid ""
"Turns a non-distributed node into a distributed node.\n"
"\n"
"This functionality starts the `:net_kernel` and other\n"
"related processes.\n"
msgstr ""
#. TRANSLATORS: def Node.stop()
#: lib/node.ex:34 
msgid ""
"Turns a distributed node into a non-distributed node.\n"
"\n"
"For other nodes in the network, this is the same as the node going down.\n"
"Only possible when the node was started with `Node.start/3`, otherwise\n"
"returns `{:error, :not_allowed}`. Returns `{:error, :not_found}` if the\n"
"local node is not alive.\n"
msgstr ""
#. TRANSLATORS: def Node.ping(node)
#: lib/node.ex:119 
msgid ""
"Tries to set up a connection to node.\n"
"\n"
"Returns `:pang` if it fails, or `:pong` if it is successful.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Node.ping(:unknown_node)\n"
"    :pang\n"
"\n"
msgstr ""
#. TRANSLATORS: def File.rm(path)
#: lib/file.ex:670 
msgid ""
"Tries to delete the file `path`.\n"
"\n"
"Returns `:ok` if successful, or `{:error, reason}` if an error occurs.\n"
"Note the file is deleted even if in read-only mode.\n"
"\n"
"Typical error reasons are:\n"
"\n"
"  * `:enoent`  - the file does not exist\n"
"  * `:eacces`  - missing permission for the file or one of its parents\n"
"  * `:eperm`   - the file is a directory and user is not super-user\n"
"  * `:enotdir` - a component of the file name is not a directory;\n"
"                 on some platforms, enoent is returned instead\n"
"  * `:einval`  - filename had an improper type, such as tuple\n"
"\n"
"## Examples\n"
"\n"
"    File.rm('file.txt')\n"
"    #=> :ok\n"
"\n"
"    File.rm('tmp_dir/')\n"
"    #=> {:error, :eperm}\n"
"\n"
msgstr ""
#. TRANSLATORS: def File.rmdir(path)
#: lib/file.ex:727 
msgid ""
"Tries to delete the dir at `path`.\n"
"Returns `:ok` if successful, or `{:error, reason}` if an error occurs.\n"
"\n"
"## Examples\n"
"\n"
"    File.rmdir('tmp_dir')\n"
"    #=> :ok\n"
"\n"
"    File.rmdir('file.txt')\n"
"    #=> {:error, :enotdir}\n"
"\n"
msgstr ""
#. TRANSLATORS: def File.mkdir(path)
#: lib/file.ex:143 
msgid ""
"Tries to create the directory `path`. Missing parent directories are not created.\n"
"Returns `:ok` if successful, or `{:error, reason}` if an error occurs.\n"
"\n"
"Typical error reasons are:\n"
"\n"
"  * `:eacces`  - missing search or write permissions for the parent\n"
"     directories of `path`\n"
"  * `:eexist`  - there is already a file or directory named `path`\n"
"  * `:enoent`  - a component of `path` does not exist\n"
"  * `:enospc`  - there is a no space left on the device\n"
"  * `:enotdir` - a component of `path` is not a directory;\n"
"     on some platforms, `:enoent` is returned instead\n"
msgstr ""
#. TRANSLATORS: def File.mkdir_p(path)
#: lib/file.ex:172 
msgid ""
"Tries to create the directory `path`. Missing parent directories are created.\n"
"Returns `:ok` if successful, or `{:error, reason}` if an error occurs.\n"
"\n"
"Typical error reasons are:\n"
"\n"
"  * `:eacces`  - missing search or write permissions for the parent\n"
"                 directories of `path`\n"
"  * `:enospc`  - there is a no space left on the device\n"
"  * `:enotdir` - a component of `path` is not a directory\n"
msgstr ""
#. TRANSLATORS: def Keyword.take(keywords, keys)
#: lib/keyword.ex:519 
msgid ""
"Takes all entries corresponding to the given keys and returns them in a new\n"
"keyword list.\n"
"\n"
"Duplicated keys are preserved in the new keyword list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> d = [a: 1, b: 2, c: 3, d: 4]\n"
"    iex> Keyword.take(d, [:a, :c, :e])\n"
"    [a: 1, c: 3]\n"
"\n"
"    iex> d = [a: 1, b: 2, c: 3, d: 4, a: 5]\n"
"    iex> Keyword.take(d, [:a, :c, :e])\n"
"    [a: 1, c: 3, a: 5]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.split(keywords, keys)
#: lib/keyword.ex:489 
msgid ""
"Takes all entries corresponding to the given keys and extracts them into a\n"
"separate keyword list. \n"
"\n"
"Returns a tuple with the new list and the old list with removed keys.\n"
"\n"
"Keys for which there are no entires in the keyword list are ignored.\n"
"\n"
"Entries with duplicated keys end up in the same keyword list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> d = [a: 1, b: 2, c: 3, d: 4]\n"
"    iex> Keyword.split(d, [:a, :c, :e])\n"
"    {[a: 1, c: 3], [b: 2, d: 4]}\n"
"\n"
"    iex> d = [a: 1, b: 2, c: 3, d: 4, a: 5]\n"
"    iex> Keyword.split(d, [:a, :c, :e])\n"
"    {[a: 1, c: 3, a: 5], [b: 2, d: 4]}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Path.wildcard(glob, opts \\ [])
#: lib/path.ex:588 
msgid ""
"Traverses paths according to the given `glob` expression.\n"
"\n"
"The wildcard looks like an ordinary path, except that certain\n"
"\"wildcard characters\" are interpreted in a special way. The\n"
"following characters are special:\n"
"\n"
"  * `?` - matches one character\n"
"\n"
"  * `*` - matches any number of characters up to the end of the filename, the\n"
"    next dot, or the next slash\n"
"\n"
"  * `**` - two adjacent `*`'s used as a single pattern will match all\n"
"    files and zero or more directories and subdirectories\n"
"\n"
"  * `[char1,char2,...]` - matches any of the characters listed; two\n"
"    characters separated by a hyphen will match a range of characters\n"
"\n"
"  * `{item1,item2,...}` - matches one of the alternatives\n"
"\n"
"Other characters represent themselves. Only paths that have\n"
"exactly the same character in the same position will match. Note\n"
"that matching is case-sensitive; i.e. \"a\" will not match \"A\".\n"
"\n"
"By default, the patterns `*` and `?` do not match files starting\n"
"with a dot `.` unless `match_dot: true` is given.\n"
"\n"
"## Examples\n"
"\n"
"Imagine you have a directory called `projects` with three Elixir projects\n"
"inside of it: `elixir`, `ex_doc` and `dynamo`. You can find all `.beam` files\n"
"inside the `ebin` directory of each project as follows:\n"
"\n"
"    Path.wildcard(\"projects/*/ebin/**/*.beam\")\n"
"\n"
"If you want to search for both `.beam` and `.app` files, you could do:\n"
"\n"
"    Path.wildcard(\"projects/*/ebin/**/*.{beam,app}\")\n"
"\n"
msgstr ""
#. TRANSLATORS: def Process.monitor(item)
#: lib/process.ex:206 
msgid ""
"The calling process starts monitoring the item given.\n"
"It returns the monitor reference.\n"
"\n"
"See http://www.erlang.org/doc/man/erlang.html#monitor-2 for more info.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Process.exit(pid, reason)
#: lib/process.ex:100 
msgid ""
"Sends an exit signal with the given reason to the pid.\n"
"\n"
"The following behaviour applies if reason is any term except `:normal` or `:kill`:\n"
"\n"
"  1. If pid is not trapping exits, pid will exit with the given reason.\n"
"\n"
"  2. If pid is trapping exits, the exit signal is transformed into a message\n"
"     `{:EXIT, from, reason}` and delivered to the message queue of pid.\n"
"\n"
"  3. If reason is the atom `:normal`, pid will not exit. If it is trapping\n"
"     exits, the exit signal is transformed into a message `{:EXIT, from,\n"
"     :normal}` and delivered to its message queue.\n"
"\n"
"  4. If reason is the atom `:kill`, that is if `exit(pid, :kill)` is called,\n"
"     an untrappable exit signal is sent to pid which will unconditionally\n"
"     exit with exit reason `:killed`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    Process.exit(pid, :kill)\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.zip(left, right)
#: lib/stream.ex:819 
msgid ""
"Zips two collections together, lazily.\n"
"\n"
"The zipping finishes as soon as any enumerable completes.\n"
"\n"
"## Examples\n"
"\n"
"    iex> concat = Stream.concat(1..3, 4..6)\n"
"    iex> cycle  = Stream.cycle([:a, :b, :c])\n"
"    iex> Stream.zip(concat, cycle) |> Enum.to_list\n"
"    [{1,:a},{2,:b},{3,:c},{4,:a},{5,:b},{6,:c}]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.zip(coll1, coll2)
#: lib/enum.ex:1846 
msgid ""
"Zips corresponding elements from two collections into one list\n"
"of tuples.\n"
"\n"
"The zipping finishes as soon as any enumerable completes.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.zip([1, 2, 3], [:a, :b, :c])\n"
"    [{1,:a},{2,:b},{3,:c}]\n"
"\n"
"    iex> Enum.zip([1,2,3,4,5], [:a, :b, :c])\n"
"    [{1,:a},{2,:b},{3,:c}]\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.zip(list_of_lists)
#: lib/list.ex:322 
msgid ""
"Zips corresponding elements from each list in `list_of_lists`.\n"
"\n"
"The zipping finishes as soon as any list terminates.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.zip([[1, 2], [3, 4], [5, 6]])\n"
"    [{1, 3, 5}, {2, 4, 6}]\n"
"\n"
"    iex> List.zip([[1, 2], [3], [5, 6]])\n"
"    [{1, 3, 5}]\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.wrap(list)
#: lib/list.ex:295 
msgid ""
"Wraps the argument in a list.\n"
"If the argument is already a list, returns the list.\n"
"If the argument is `nil`, returns an empty list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.wrap(\"hello\")\n"
"    [\"hello\"]\n"
"\n"
"    iex> List.wrap([1, 2, 3])\n"
"    [1,2,3]\n"
"\n"
"    iex> List.wrap(nil)\n"
"    []\n"
"\n"
msgstr ""
#. TRANSLATORS: def System.tmp_dir()
#: lib/system.ex:173 
msgid ""
"Writable temporary directory.\n"
"\n"
"Returns a writable temporary directory.\n"
"Searches for directories in the following order:\n"
"\n"
"  1. the directory named by the TMPDIR environment variable\n"
"  2. the directory named by the TEMP environment variable\n"
"  3. the directory named by the TMP environment variable\n"
"  4. `C:\\TMP` on Windows or `/tmp` on Unix\n"
"  5. as a last resort, the current working directory\n"
"\n"
"Returns `nil` if none of the above are writable.\n"
msgstr ""
#. TRANSLATORS: def System.tmp_dir!()
#: lib/system.ex:187 
msgid ""
"Writable temporary directory, exception on error.\n"
"\n"
"Same as `tmp_dir/0` but raises `RuntimeError`\n"
"instead of returning `nil` if no temp dir is set.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.var!(var, context \\ nil)
#: lib/kernel.ex:2528 
msgid ""
"When used inside quoting, marks that the variable should\n"
"not be hygienized. The argument can be either a variable\n"
"unquoted or in standard tuple form `{name, meta, context}`.\n"
"\n"
"Check `Kernel.SpecialForms.quote/2` for more information.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.alias!(alias)
#: lib/kernel.ex:2558 
msgid ""
"When used inside quoting, marks that the alias should not\n"
"be hygienezed. This means the alias will be expanded when\n"
"the macro is expanded.\n"
"\n"
"Check `Kernel.SpecialForms.quote/2` for more information.\n"
msgstr ""
#. TRANSLATORS: def Macro.validate(expr)
#: lib/macro.ex:317 
msgid ""
"Validates the given expressions are valid quoted expressions.\n"
"\n"
"Check the `type:Macro.t` for the specification of a valid\n"
"quoted expression.\n"
msgstr ""
#. TRANSLATORS: def Stream.transform(enum, acc, reducer)
#: lib/stream.ex:638 
msgid ""
"Transforms an existing stream.\n"
"\n"
"It expects an accumulator and a function that receives each stream item\n"
"and an accumulator, and must return a tuple containing a new stream\n"
"(often a list) with the new accumulator or a tuple with `:halt` as first\n"
"element and the accumulator as second.\n"
"\n"
"Note: this function is similar to `Enum.flat_map_reduce/3` except the\n"
"latter returns both the flat list and accumulator, while this one returns\n"
"only the stream.\n"
"\n"
"## Examples\n"
"\n"
"`Stream.transform/3` is useful as it can be used as the basis to implement\n"
"many of the functions defined in this module. For example, we can implement\n"
"`Stream.take(enum, n)` as follows:\n"
"\n"
"    iex> enum = 1..100\n"
"    iex> n = 3\n"
"    iex> stream = Stream.transform(enum, 0, fn i, acc ->\n"
"    ...>   if acc < n, do: {[i], acc + 1}, else: {:halt, acc}\n"
"    ...> end)\n"
"    iex> Enum.to_list(stream)\n"
"    [1,2,3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def System.get_env()
#: lib/system.ex:254 
msgid ""
"System environment variables.\n"
"\n"
"Returns a list of all environment variables. Each variable is given as a\n"
"`{name, value}` tuple where both `name` and `value` are strings.\n"
msgstr ""
#. TRANSLATORS: def GenEvent.notify(manager, event)
#: lib/gen_event.ex:376 
msgid ""
"Sends an event notification to the event `manager`.\n"
"\n"
"The event manager will call `handle_event/2` for each\n"
"installed event handler.\n"
"\n"
"`notify` is asynchronous and will return immediately after the\n"
"notification is sent. `notify` will not fail even if the specified\n"
"event manager does not exist, unless it is specified as an atom.\n"
msgstr ""
#. TRANSLATORS: def GenServer.cast(server, request)
#: lib/gen_server.ex:378 
msgid ""
"Sends an asynchronous request to the `server`.\n"
"\n"
"This function returns `:ok` immediately, regardless of\n"
"whether the destination node or server does exists, unless\n"
"the server is specified as an atom.\n"
"\n"
"`handle_cast/2` will be called on the server to handle\n"
"the request. In case the server is a node which is not\n"
"yet connected to the caller one, the call is going to\n"
"block until a connection happens. This is different than\n"
"the behaviour in OTP's `:gen_server` where the message\n"
"would be sent by another process, which could cause\n"
"messages to arrive out of order.\n"
msgstr ""
#. TRANSLATORS: def Inspect.Algebra.surround(left, doc, right)
#: lib/inspect/algebra.ex:410 
msgid ""
"Surrounds a document with characters.\n"
"\n"
"Puts the document between left and right enclosing and nesting it.\n"
"The document is marked as a group, to show the maximum as possible\n"
"concisely together.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.surround \"[\", Inspect.Algebra.glue(\"a\", \"b\"), \"]\"\n"
"    iex> Inspect.Algebra.format(doc, 3)\n"
"    [\"[\", \"a\", \"\\n \", \"b\", \"]\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.chunk(enum, n, step, pad \\ nil)
#: lib/stream.ex:157 
msgid ""
"Streams the enumerable in chunks, containing `n` items each, where\n"
"each new chunk starts `step` elements into the enumerable.\n"
"\n"
"`step` is optional and, if not passed, defaults to `n`, i.e.\n"
"chunks do not overlap. If the final chunk does not have `n`\n"
"elements to fill the chunk, elements are taken as necessary\n"
"from `pad` if it was passed. If `pad` is passed and does not\n"
"have enough elements to fill the chunk, then the chunk is\n"
"returned anyway with less than `n` elements. If `pad` is not\n"
"passed at all or is `nil`, then the partial chunk is discarded\n"
"from the result.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.chunk([1, 2, 3, 4, 5, 6], 2) |> Enum.to_list\n"
"    [[1, 2], [3, 4], [5, 6]]\n"
"\n"
"    iex> Stream.chunk([1, 2, 3, 4, 5, 6], 3, 2) |> Enum.to_list\n"
"    [[1, 2, 3], [3, 4, 5]]\n"
"\n"
"    iex> Stream.chunk([1, 2, 3, 4, 5, 6], 3, 2, [7]) |> Enum.to_list\n"
"    [[1, 2, 3], [3, 4, 5], [5, 6, 7]]\n"
"\n"
"    iex> Stream.chunk([1, 2, 3, 4, 5, 6], 3, 3, []) |> Enum.to_list\n"
"    [[1, 2, 3], [4, 5, 6]]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Supervisor.Default.init(args)
#: lib/supervisor/default.ex:10 
msgid ""
"Supevisor callback that simply returns the given args.\n"
"\n"
"This is the supervisor used by `Supervisor.start_link/2`.\n"
msgstr ""
#. TRANSLATORS: def Process.put(key, value)
#: lib/process.ex:62 
msgid ""
"Stores the given key-value in the process dictionary.\n"
msgstr ""
#. TRANSLATORS: def Dict.put(dict, key, val)
#: lib/dict.ex:415 
msgid ""
"Stores the given `value` under `key` in `dict`.\n"
"If `dict` already has `key`, the stored value is replaced by the new one.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.put(dict, :a, 3)\n"
"    iex> Dict.get(dict, :a)\n"
"    3\n"
"\n"
msgstr ""
#. TRANSLATORS: def Application.stop(app)
#: lib/application.ex:254 
msgid ""
"Stops the given `app`.\n"
"\n"
"When stopped, the application is still loaded.\n"
msgstr ""
#. TRANSLATORS: def Kernel.exit(reason)
#: lib/kernel.ex:238 
msgid ""
"Stops the execution of the calling process with the given reason.\n"
"\n"
"Since evaluating this function causes the process to terminate,\n"
"it has no return value.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"When a process reaches its end, by default it exits with\n"
"reason `:normal`. You can also call it explicitly if you\n"
"want to terminate a process but not signal any failure:\n"
"\n"
"    exit(:normal)\n"
"\n"
"In case something goes wrong, you can also use `exit/1` with\n"
"a different reason:\n"
"\n"
"    exit(:seems_bad)\n"
"\n"
"If the reason is not `:normal`, all linked process to the\n"
"exited process will crash (unless they are trapping exits).\n"
"\n"
"## OTP exits\n"
"\n"
"Exits are used by OTP to determine if a process exited abnormally\n"
"or not. The following exits are considered \"normal\":\n"
"\n"
"  * `exit(:normal)`\n"
"  * `exit(:shutdown)`\n"
"  * `exit({:shutdown, term})`\n"
"\n"
"Exiting with any other reason is considered abnormal and treated\n"
"as a crash. This means the default supervisor behaviour kicks in,\n"
"error reports are emitted, etc.\n"
"\n"
"This behaviour is relied on in many different places. For example,\n"
"`ExUnit` uses `exit(:shutdown)` when exiting the test process to\n"
"signal linked processes, supervision trees and so on to politely\n"
"shutdown too.\n"
"\n"
"## CLI exits\n"
"\n"
"Building on top of the exit signals mentioned above, if the\n"
"process started by the command line exits with any of the three\n"
"reasons above, its exit is considered normal and the Operating\n"
"System process will exit with status 0.\n"
"\n"
"It is, however, possible to customize the Operating System exit\n"
"signal by invoking:\n"
"\n"
"    exit({:shutdown, integer})\n"
"\n"
"This will cause the OS process to exit with the status given by\n"
"`integer` while signaling all linked OTP processes to politely\n"
"shutdown.\n"
"\n"
"Any other exit reason will cause the OS process to exit with\n"
"status `1` and linked OTP processes to crash.\n"
msgstr ""
#. TRANSLATORS: def Agent.stop(agent, timeout \\ 5000)
#: lib/agent.ex:296 
msgid ""
"Stops the agent.\n"
"\n"
"Returns `:ok` if the agent is stopped within the given `timeout`.\n"
msgstr ""
#. TRANSLATORS: def StringIO.close(pid)
#: lib/string_io.ex:88 
msgid ""
"Stops the IO device and returns remaining buffers.\n"
"\n"
"## Examples\n"
"\n"
"    iex> {:ok, pid} = StringIO.open(\"in\")\n"
"    iex> IO.write(pid, \"out\")\n"
"    iex> StringIO.close(pid)\n"
"    {:ok, {\"in\", \"out\"}}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Application.start(app, type \\ :temporary)
#: lib/application.ex:244 
msgid ""
"Starts the given `app`.\n"
"\n"
"If the `app` is not loaded, the application will first be loaded using `load/1`.\n"
"Any included application, defined in the `:included_applications` key of the\n"
"`.app` file will also be loaded, but they won't be started.\n"
"\n"
"Furthermore, all applications listed in the `:applications` key must be explicitly\n"
"started before this application is. If not, `{:error, {:not_started, app}}` is\n"
"returned, where `app` is the name of the missing application.\n"
"\n"
"In case you want to automatically  load **and start** all of `app`'s dependencies,\n"
"see `ensure_all_started/2`.\n"
"\n"
"The `type` argument specifies the type of the application:\n"
"\n"
"  * `:permanent` - if `app` terminates, all other applications and the entire\n"
"    node are also terminated.\n"
"\n"
"  * `:transient` - if `app` terminates with `:normal` reason, it is reported\n"
"    but no other applications are terminated. If a transient application\n"
"    terminates abnormally, all other applications and the entire node are\n"
"    also terminated.\n"
"\n"
"  * `:temporary` - if `app` terminates, it is reported but no other\n"
"    applications are terminated (the default).\n"
"\n"
"Note that it is always possible to stop an application explicitly by calling\n"
"`stop/1`. Regardless of the type of the application, no other applications will\n"
"be affected.\n"
"\n"
"Note also that the `:transient` type is of little practical use, since when a\n"
"supervision tree terminates, the reason is set to `:shutdown`, not `:normal`.\n"
msgstr ""
#. TRANSLATORS: def GenEvent.start(options \\ [])
#: lib/gen_event.ex:262 
msgid ""
"Starts an event manager process without links (outside of a supervision tree).\n"
"\n"
"See `start_link/1` for more information.\n"
msgstr ""
#. TRANSLATORS: def Agent.start(module, fun, args, options \\ [])
#: lib/agent.ex:181 
msgid ""
"Starts an agent with the given module function and arguments.\n"
"\n"
"Similar to `start/2` but a module, function and args are expected\n"
"instead of an anonymous function.\n"
msgstr ""
#. TRANSLATORS: def Agent.start(fun, options \\ [])
#: lib/agent.ex:170 
msgid ""
"Starts an agent process without links (outside of a supervision tree).\n"
"\n"
"See `start_link/2` for more information.\n"
msgstr ""
#. TRANSLATORS: def Agent.start_link(module, fun, args, options \\ [])
#: lib/agent.ex:160 
msgid ""
"Starts an agent linked to the current process with the given module\n"
"function and arguments.\n"
"\n"
"Same as `start_link/2` but a module, function and args are expected\n"
"instead of an anonymous function.\n"
msgstr ""
#. TRANSLATORS: def Agent.start_link(fun, options \\ [])
#: lib/agent.ex:148 
msgid ""
"Starts an agent linked to the current process with the given function.\n"
"\n"
"This is often used to start the agent as part of a supervision tree.\n"
"\n"
"Once the agent is spawned, the given function is invoked and its return\n"
"value is used as the agent state. Note that `start_link` does not return\n"
"until the given function has returned.\n"
"\n"
"## Options\n"
"\n"
"The `:name` option is used for registration as described in the module\n"
"documentation.\n"
"\n"
"If the `:timeout` option is present, the agent is allowed to spend at most\n"
"the given number of milliseconds on initialization or it will be terminated\n"
"and the start function will return `{:error, :timeout}`.\n"
"\n"
"If the `:debug` option is present, the corresponding function in the\n"
"[`:sys` module](http://www.erlang.org/doc/man/sys.html) will be invoked.\n"
"\n"
"If the `:spawn_opt` option is present, its value will be passed as options\n"
"to the underlying process as in `Process.spawn/4`.\n"
"\n"
"## Return values\n"
"\n"
"If the server is successfully created and initialized, the function returns\n"
"`{:ok, pid}`, where `pid` is the pid of the server. If there already exists\n"
"an agent with the specified name, the function returns\n"
"`{:error, {:already_started, pid}}` with the pid of that process.\n"
"\n"
"If the given function callback fails with `reason`, the function returns\n"
"`{:error, reason}`.\n"
msgstr ""
#. TRANSLATORS: def Application.app_dir(app, path)
#: lib/application.ex:319 
msgid ""
"Returns the given path inside `app_dir/1`.\n"
msgstr ""
#. TRANSLATORS: def OptionParser.split(string)
#: lib/option_parser.ex:276 
msgid ""
"Splits a string into argv chunks.\n"
"\n"
"## Examples\n"
"\n"
"    iex> OptionParser.split(\"foo bar\")\n"
"    [\"foo\", \"bar\"]\n"
"\n"
"    iex> OptionParser.split(\"foo \\\"bar baz\\\"\")\n"
"    [\"foo\", \"bar baz\"]\n"
msgstr ""
#. TRANSLATORS: def Enum.split_while(collection, fun)
#: lib/enum.ex:1680 
msgid ""
"Splits `collection` in two while `fun` returns `true`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.split_while([1, 2, 3, 4], fn(x) -> x < 3 end)\n"
"    {[1, 2], [3, 4]}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.chunk_by(coll, fun)
#: lib/enum.ex:362 
msgid ""
"Splits `coll` on every element for which `fun` returns a new value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.chunk_by([1, 2, 2, 3, 4, 4, 6, 7, 7], &(rem(&1, 2) == 1))\n"
"    [[1], [2, 2], [3], [4, 4, 6], [7, 7]]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.spawn_monitor(module, fun, args)
#: lib/kernel.ex:695 
msgid ""
"Spawns the given module and function passing the given args,\n"
"monitors it and returns its pid and monitoring reference.\n"
"\n"
"Check the modules `Process` and `Node` for other functions\n"
"to handle processes, including spawning functions in nodes.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    spawn_monitor(SomeModule, :function, [1, 2, 3])\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.spawn_link(module, fun, args)
#: lib/kernel.ex:656 
msgid ""
"Spawns the given module and function passing the given args,\n"
"links it to the current process and returns its pid.\n"
"\n"
"Check the modules `Process` and `Node` for other functions\n"
"to handle processes, including spawning functions in nodes.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    spawn_link(SomeModule, :function, [1, 2, 3])\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.spawn(module, fun, args)
#: lib/kernel.ex:614 
msgid ""
"Spawns the given module and function passing the given args\n"
"and returns its pid.\n"
"\n"
"Check the modules `Process` and `Node` for other functions\n"
"to handle processes, including spawning functions in nodes.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    spawn(SomeModule, :function, [1, 2, 3])\n"
"\n"
msgstr ""
#. TRANSLATORS: def Process.spawn(mod, fun, args, opts)
#: lib/process.ex:193 
msgid ""
"Spawns the given module and function passing the given args\n"
"according to the given options.\n"
"\n"
"The result depends on the given options. In particular,\n"
"if `:monitor` is given as an option, it will return a tuple\n"
"containing the pid and the monitoring reference, otherwise\n"
"just the spawned process pid.\n"
"\n"
"It also accepts extra options, for the list of available options\n"
"check http://www.erlang.org/doc/man/erlang.html#spawn_opt-4\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Kernel.spawn_monitor(fun)
#: lib/kernel.ex:676 
msgid ""
"Spawns the given function, monitors it and returns its pid\n"
"and monitoring reference.\n"
"\n"
"Check the modules `Process` and `Node` for other functions\n"
"to handle processes, including spawning functions in nodes.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    current = Kernel.self\n"
"    spawn_monitor(fn -> send current, {Kernel.self, 1 + 2} end)\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.spawn_link(fun)
#: lib/kernel.ex:637 
msgid ""
"Spawns the given function, links it to the current process and returns its pid.\n"
"\n"
"Check the modules `Process` and `Node` for other functions\n"
"to handle processes, including spawning functions in nodes.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    current = Kernel.self\n"
"    child   = spawn_link(fn -> send current, {Kernel.self, 1 + 2} end)\n"
"\n"
"    receive do\n"
"      {^child, 3} -> IO.puts \"Received 3 back\"\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.spawn(fun)
#: lib/kernel.ex:595 
msgid ""
"Spawns the given function and returns its pid.\n"
"\n"
"Check the modules `Process` and `Node` for other functions\n"
"to handle processes, including spawning functions in nodes.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    current = Kernel.self\n"
"    child   = spawn(fn -> send current, {Kernel.self, 1 + 2} end)\n"
"\n"
"    receive do\n"
"      {^child, 3} -> IO.puts \"Received 3 back\"\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def Task.start(mod, fun, args)
#: lib/task.ex:142 
msgid ""
"Starts a task.\n"
"\n"
"This is only used when the task is used for side-effects\n"
"(i.e. no interest in its return result) and it should not\n"
"be linked to the current process.\n"
msgstr ""
#. TRANSLATORS: def Task.async(fun)
#: lib/task.ex:159 
msgid ""
"Starts a task that can be awaited on.\n"
"\n"
"This function spawns a process that is linked to and monitored\n"
"by the caller process. A `Task` struct is returned containing\n"
"the relevant information.\n"
"\n"
"## Task's message format\n"
"\n"
"The reply sent by the task will be in the format `{ref, msg}`,\n"
"where `ref` is the monitoring reference held by the task.\n"
msgstr ""
#. TRANSLATORS: def Task.Supervisor.async(supervisor, module, fun, args)
#: lib/task/supervisor.ex:66 
msgid ""
"Starts a task that can be awaited on.\n"
"\n"
"The `supervisor` must be a reference as defined in `Task.Supervisor`.\n"
"For more information on tasks, check the `Task` module.\n"
msgstr ""
#. TRANSLATORS: def Task.async(mod, fun, args)
#: lib/task.ex:170 
msgid ""
"Starts a task that can be awaited on.\n"
"\n"
"Similar to `async/1`, but the task is specified by the given\n"
"module, function and arguments.\n"
msgstr ""
#. TRANSLATORS: def Enum.sort_by(collection, mapper, sorter \\ :erlang.make_fun(:erlang, :"=<", 2))
#: lib/enum.ex:1613 
msgid ""
"Sorts the mapped results of the `collection` according to the `sorter` function.\n"
"\n"
"This function maps each element of the collection using the `mapper`\n"
"function.  The collection is then sorted by the mapped elements using the\n"
"`sorter` function, which defaults to `<=/2`\n"
"\n"
"`sort_by/3` differs from `sort/2` in that it only calculates the comparison\n"
"value for each element in the collection once instead of once for each\n"
"element in each comparison.  If the same function is being called on both\n"
"element, it's also more compact to use `sort_by/3`.\n"
"\n"
"This technique is also known as a\n"
"[Schwartzian Transform](https://en.wikipedia.org/wiki/Schwartzian_transform),\n"
"or the Lisp decorate-sort-undecorate idiom as the `mapper` is decorating the\n"
"original `collection`, then `sorter` is sorting the decorations, and finally\n"
"the `collection` is being undecorated so only the original elements remain,\n"
"but now in sorted order.\n"
"\n"
"## Examples\n"
"\n"
"Using the default `sorter` of `<=/2`:\n"
"\n"
"    iex> Enum.sort_by [\"some\", \"kind\", \"of\", \"monster\"], &byte_size/1\n"
"    [\"of\", \"some\", \"kind\", \"monster\"]\n"
"\n"
"Using a custom `sorter` to override the order:\n"
"\n"
"    iex> Enum.sort_by [\"some\", \"kind\", \"of\", \"monster\"], &byte_size/1, &>=/2\n"
"    [\"monster\", \"some\", \"kind\", \"of\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.sort(collection, fun)
#: lib/enum.ex:1572 
msgid ""
"Sorts the collection by the given function.\n"
"\n"
"This function uses the merge sort algorithm. The given function\n"
"must return false if the first argument is less than right one.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.sort([1, 2, 3], &(&1 > &2))\n"
"    [3, 2, 1]\n"
"\n"
"The sorting algorithm will be stable as long as the given function\n"
"returns true for values considered equal:\n"
"\n"
"    iex> Enum.sort [\"some\", \"kind\", \"of\", \"monster\"], &(byte_size(&1) <= byte_size(&2))\n"
"    [\"of\", \"some\", \"kind\", \"monster\"]\n"
"\n"
"If the function does not return true, the sorting is not stable and\n"
"the order of equal terms may be shuffled:\n"
"\n"
"    iex> Enum.sort [\"some\", \"kind\", \"of\", \"monster\"], &(byte_size(&1) < byte_size(&2))\n"
"    [\"of\", \"kind\", \"some\", \"monster\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.sort(collection)
#: lib/enum.ex:1539 
msgid ""
"Sorts the collection according to Elixir's term ordering.\n"
"\n"
"Uses the merge sort algorithm.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.sort([3, 2, 1])\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.find_value(collection, ifnone \\ nil, fun)
#: lib/enum.ex:732 
msgid ""
"Similar to `find/3`, but returns the value of the function\n"
"invocation instead of the element itself.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.find_value([2, 4, 6], fn(x) -> rem(x, 2) == 1 end)\n"
"    nil\n"
"\n"
"    iex> Enum.find_value([2, 3, 4], fn(x) -> rem(x, 2) == 1 end)\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.find_index(collection, fun)
#: lib/enum.ex:759 
msgid ""
"Similar to `find/3`, but returns the index (zero-based)\n"
"of the element instead of the element itself.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.find_index([2, 4, 6], fn(x) -> rem(x, 2) == 1 end)\n"
"    nil\n"
"\n"
"    iex> Enum.find_index([2, 3, 4], fn(x) -> rem(x, 2) == 1 end)\n"
"    1\n"
"\n"
msgstr ""
#. TRANSLATORS: def File.open(path, modes, function)
#: lib/file.ex:952 
msgid ""
"Similar to `open/2` but expects a function as last argument.\n"
"\n"
"The file is opened, given to the function as argument and\n"
"automatically closed after the function returns, regardless\n"
"if there was an error when executing the function.\n"
"\n"
"It returns `{:ok, function_result}` in case of success,\n"
"`{:error, reason}` otherwise.\n"
"\n"
"This function expects the file to be closed with success,\n"
"which is usually the case unless the `:delayed_write` option\n"
"is given. For this reason, we do not recommend passing\n"
"`:delayed_write` to this function.\n"
"\n"
"## Examples\n"
"\n"
"    File.open(\"file.txt\", [:read, :write], fn(file) ->\n"
"      IO.read(file, :line)\n"
"    end)\n"
"\n"
msgstr ""
#. TRANSLATORS: def OptionParser.parse_head(argv, opts \\ [])
#: lib/option_parser.ex:129 
msgid ""
"Similar to `parse/2` but only parses the head of `argv`;\n"
"as soon as it finds a non-switch, it stops parsing.\n"
"\n"
"See `parse/2` for more information.\n"
"\n"
"## Example\n"
"\n"
"    iex> OptionParser.parse_head([\"--source\", \"lib\", \"test/enum_test.exs\", \"--verbose\"])\n"
"    {[source: \"lib\"], [\"test/enum_test.exs\", \"--verbose\"], []}\n"
"\n"
"    iex> OptionParser.parse_head([\"--verbose\", \"--source\", \"lib\", \"test/enum_test.exs\", \"--unlock\"])\n"
"    {[verbose: true, source: \"lib\"], [\"test/enum_test.exs\", \"--unlock\"], []}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.chunk(enum, n)
#: lib/stream.ex:125 
msgid ""
"Shortcut to `chunk(enum, n, n)`.\n"
msgstr ""
#. TRANSLATORS: def Enum.chunk(coll, n)
#: lib/enum.ex:307 
msgid ""
"Shortcut to `chunk(coll, n, n)`.\n"
msgstr ""
#. TRANSLATORS: def File.cd(path)
#: lib/file.ex:1037 
msgid ""
"Sets the current working directory.\n"
"\n"
"Returns `:ok` if successful, `{:error, reason}` otherwise.\n"
msgstr ""
#. TRANSLATORS: def GenServer.start(module, args, options \\ [])
#: lib/gen_server.ex:314 
msgid ""
"Starts a `GenServer` process without links (outside of a supervision tree).\n"
"\n"
"See `start_link/3` for more information.\n"
msgstr ""
#. TRANSLATORS: def Task.start_link(mod, fun, args)
#: lib/task.ex:118 
msgid ""
"Starts a task as part of a supervision tree.\n"
msgstr ""
#. TRANSLATORS: def Task.Supervisor.start_child(supervisor, module, fun, args)
#: lib/task/supervisor.ex:110 
msgid ""
"Starts a task as child of the given `supervisor`.\n"
"\n"
"Similar to `start_child/2` except the task is specified\n"
"by the given `module`, `fun` and `args`.\n"
msgstr ""
#. TRANSLATORS: def Task.Supervisor.start_child(supervisor, fun)
#: lib/task/supervisor.ex:99 
msgid ""
"Starts a task as child of the given `supervisor`.\n"
"\n"
"Note that the spawned process is not linked to the caller, but\n"
"only to the supervisor. This command is useful in case the\n"
"task needs to perform side-effects (like I/O) and does not need\n"
"to report back to the caller.\n"
msgstr ""
#. TRANSLATORS: def Supervisor.start_link(children, options)
#: lib/supervisor.ex:204 
msgid ""
"Starts a supervisor with the given children.\n"
"\n"
"A strategy is required to be given as an option. Furthermore,\n"
"the `:max_restarts` and `:max_seconds` value can be configured\n"
"as described in `Supervisor.Spec.supervise/2` docs.\n"
"\n"
"The options can also be used to register a supervisor name.\n"
"the supported values are described under the `Name Registration`\n"
"section in the `GenServer` module docs.\n"
"\n"
"If the supervisor and its child processes are successfully created\n"
"(i.e. if the start function of all child processes returns `{:ok, child}`,\n"
"`{:ok, child, info}`, or `:ignore`) the function returns\n"
"`{:ok, pid}`, where `pid` is the pid of the supervisor. If there\n"
"already exists a process with the specified name, the function returns\n"
"`{:error, {:already_started, pid}}`, where pid is the pid of that\n"
"process.\n"
"\n"
"If any of the child process start functions fail or return an error tuple or\n"
"an erroneous value, the supervisor will first terminate all already\n"
"started child processes with reason `:shutdown` and then terminate\n"
"itself and return `{:error, {:shutdown, reason}}`.\n"
"\n"
"Note that the `Supervisor` is linked to the parent process\n"
"and will exit not only on crashes but also if the parent process\n"
"exits with `:normal` reason.\n"
msgstr ""
#. TRANSLATORS: def Supervisor.start_link(module, arg, options \\ [])
#: lib/supervisor.ex:230 
msgid ""
"Starts a supervisor module with the given `arg`.\n"
"\n"
"To start the supervisor, the `init/1` callback will be invoked\n"
"in the given module. The `init/1` callback must return a\n"
"supervision specification which can be created with the help\n"
"of `Supervisor.Spec` module.\n"
"\n"
"If the `init/1` callback returns `:ignore`, this function returns\n"
"`:ignore` as well and the supervisor terminates with reason `:normal`.\n"
"If it fails or returns an incorrect value, this function returns\n"
"`{:error, term}` where `term` is a term with information about the\n"
"error, and the supervisor terminates with reason `term`.\n"
"\n"
"The `:name` option can also be given in order to register a supervisor\n"
"name, the supported values are described under the `Name Registration`\n"
"section in the `GenServer` module docs.\n"
"\n"
"Other failure conditions are specified in `start_link/2` docs.\n"
msgstr ""
#. TRANSLATORS: def Task.Supervisor.start_link(opts \\ [])
#: lib/task/supervisor.ex:40 
msgid ""
"Starts a new supervisor.\n"
"\n"
"The supported options are:\n"
"\n"
"* `:name` - used to register a supervisor name, the supported values are\n"
"  described under the `Name Registration` section in the `GenServer` module\n"
"  docs;\n"
"\n"
"* `:restart` - the restart strategy, may be `:temporary` (the default),\n"
"  `:transient` or `:permanent`. Check `Supervisor.Spec` for more info.\n"
"  Defaults to temporary as most tasks can't be effectively restarted after\n"
"  a crash;\n"
"\n"
"* `:shutdown` - `:brutal_kill` if the tasks must be killed directly on shutdown\n"
"  or an integer indicating the timeout value, defaults to 5000 milliseconds;\n"
"\n"
"* `:max_restarts` and `:max_seconds` - as specified in `Supervisor.Spec.supervise/2`;\n"
"\n"
msgstr ""
#. TRANSLATORS: def GenServer.start_link(module, args, options \\ [])
#: lib/gen_server.ex:304 
msgid ""
"Starts a `GenServer` process linked to the current process.\n"
"\n"
"This is often used to start the `GenServer` as part of a supervision tree.\n"
"\n"
"Once the server is started, it calls the `init/1` function in the given `module`\n"
"passing the given `args` to initialize it. To ensure a synchronized start-up\n"
"procedure, this function does not return until `init/1` has returned.\n"
"\n"
"Note that a `GenServer` started with `start_link/3` is linked to the\n"
"parent process and will exit in case of crashes. The GenServer will also\n"
"exit due to the `:normal` reasons in case it is configured to trap exits\n"
"in the `init/1` callback.\n"
"\n"
"## Options\n"
"\n"
"The `:name` option is used for name registration as described in the module\n"
"documentation. If the option `:timeout` option is present, the server is\n"
"allowed to spend the given milliseconds initializing or it will be\n"
"terminated and the start function will return `{:error, :timeout}`.\n"
"\n"
"If the `:debug` option is present, the corresponding function in the\n"
"[`:sys` module](http://www.erlang.org/doc/man/sys.html) will be invoked.\n"
"\n"
"If the `:spawn_opt` option is present, its value will be passed as options\n"
"to the underlying process as in `Process.spawn/4`.\n"
"\n"
"## Return values\n"
"\n"
"If the server is successfully created and initialized, the function returns\n"
"`{:ok, pid}`, where pid is the pid of the server. If there already exists a\n"
"process with the specified server name, the function returns\n"
"`{:error, {:already_started, pid}}` with the pid of that process.\n"
"\n"
"If the `init/1` callback fails with `reason`, the function returns\n"
"`{:error, reason}`. Otherwise, if it returns `{:stop, reason}`\n"
"or `:ignore`, the process is terminated and the function returns\n"
"`{:error, reason}` or `:ignore`, respectively.\n"
msgstr ""
#. TRANSLATORS: def Node.set_cookie(node \\ Node.self(), cookie)
#: lib/node.ex:247 
msgid ""
"Sets the magic cookie of `node` to the atom `cookie`.\n"
"\n"
"The default node is `Node.self`, the local node. If `node` is the local node,\n"
"the function also sets the cookie of all other unknown nodes to `cookie`.\n"
"\n"
"This function will raise `FunctionClauseError` if the given `node` is not alive.\n"
msgstr ""
#. TRANSLATORS: def Process.group_leader(pid, leader)
#: lib/process.ex:315 
msgid ""
"Sets the group leader of `pid` to `leader`. Typically, this is used when a processes\n"
"started from a certain shell should have a group leader other than `:init`.\n"
msgstr ""
#. TRANSLATORS: def IO.ANSI.primary_font()
#: lib/io/ansi.ex:78 
msgid ""
"Sets primary (default) font"
msgstr ""
#. TRANSLATORS: def GenEvent.sync_notify(manager, event)
#: lib/gen_event.ex:410 
msgid ""
"Sends a sync event notification to the event `manager`.\n"
"\n"
"In other words, this function only returns `:ok` after the event manager\n"
"invokes the `handle_event/2` on each installed event handler.\n"
"\n"
"See `notify/2` for more info.\n"
msgstr ""
#. TRANSLATORS: def IO.ANSI.yellow()
#: lib/io/ansi.ex:102 
msgid ""
"Sets foreground color to yellow"
msgstr ""
#. TRANSLATORS: def IO.ANSI.white()
#: lib/io/ansi.ex:102 
msgid ""
"Sets foreground color to white"
msgstr ""
#. TRANSLATORS: def IO.ANSI.red()
#: lib/io/ansi.ex:102 
msgid ""
"Sets foreground color to red"
msgstr ""
#. TRANSLATORS: def IO.ANSI.magenta()
#: lib/io/ansi.ex:102 
msgid ""
"Sets foreground color to magenta"
msgstr ""
#. TRANSLATORS: def IO.ANSI.green()
#: lib/io/ansi.ex:102 
msgid ""
"Sets foreground color to green"
msgstr ""
#. TRANSLATORS: def IO.ANSI.cyan()
#: lib/io/ansi.ex:102 
msgid ""
"Sets foreground color to cyan"
msgstr ""
#. TRANSLATORS: def IO.ANSI.blue()
#: lib/io/ansi.ex:102 
msgid ""
"Sets foreground color to blue"
msgstr ""
#. TRANSLATORS: def IO.ANSI.black()
#: lib/io/ansi.ex:102 
msgid ""
"Sets foreground color to black"
msgstr ""
#. TRANSLATORS: def String.chunk(string, trait)
#: lib/string.ex:860 
msgid ""
"Splits the string into chunks of characters that share a common trait.\n"
"\n"
"The trait can be one of two options:\n"
"\n"
"  * `:valid` â€“ the string is split into chunks of valid and invalid character\n"
"    sequences\n"
"\n"
"  * `:printable` â€“ the string is split into chunks of printable and\n"
"    non-printable character sequences\n"
"\n"
"Returns a list of binaries each of which contains only one kind of\n"
"characters.\n"
"\n"
"If the given string is empty, an empty list is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.chunk(<<?a, ?b, ?c, 0>>, :valid)\n"
"    [\"abc\\0\"]\n"
"\n"
"    iex> String.chunk(<<?a, ?b, ?c, 0, 0x0ffff::utf8>>, :valid)\n"
"    [\"abc\\0\", <<0x0ffff::utf8>>]\n"
"\n"
"    iex> String.chunk(<<?a, ?b, ?c, 0, 0x0ffff::utf8>>, :printable)\n"
"    [\"abc\", <<0, 0x0ffff::utf8>>]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Code.compiler_options(opts)
#: lib/code.ex:361 
msgid ""
"Sets compilation options.\n"
"\n"
"These options are global since they are stored by Elixir's Code Server.\n"
"\n"
"Available options are:\n"
"\n"
"  * `:docs` - when `true`, retain documentation in the compiled module,\n"
"    `true` by default\n"
"\n"
"  * `:debug_info` - when `true`, retain debug information in the compiled\n"
"    module; this allows a developer to reconstruct the original source\n"
"    code, `false` by default\n"
"\n"
"  * `:ignore_module_conflict` - when `true`, override modules that were\n"
"    already defined without raising errors, `false` by default\n"
"\n"
"  * `:warnings_as_errors` - cause compilation to fail when warnings are\n"
"    generated\n"
"\n"
msgstr ""
#. TRANSLATORS: def Code.available_compiler_options()
#: lib/code.ex:336 
msgid ""
"Returns a list with the available compiler options.\n"
"\n"
"See `Code.compiler_options/1` for more info.\n"
msgstr ""
#. TRANSLATORS: def IO.ANSI.home()
#: lib/io/ansi.ex:130 
msgid ""
"Send cursor home"
msgstr ""
#. TRANSLATORS: def Path.split(path)
#: lib/path.ex:510 
msgid ""
"Splits the path into a list at the path separator.\n"
"\n"
"If an empty string is given, returns an empty list.\n"
"\n"
"On Windows, path is split on both \"\\\" and \"/\" separators\n"
"and the driver letter, if there is one, is always returned\n"
"in lowercase.\n"
"\n"
"## Examples\n"
"\n"
"     iex> Path.split(\"\")\n"
"     []\n"
"\n"
"     iex> Path.split(\"foo\")\n"
"     [\"foo\"]\n"
"\n"
"     iex> Path.split(\"/foo/bar\")\n"
"     [\"/\", \"foo\", \"bar\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Port.list()
#: lib/port.ex:83 
msgid ""
"See http://www.erlang.org/doc/man/erlang.html#ports-0.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Port.info(port, item)
#: lib/port.ex:74 
msgid ""
"See http://www.erlang.org/doc/man/erlang.html#port_info-2.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Port.info(port)
#: lib/port.ex:65 
msgid ""
"See http://www.erlang.org/doc/man/erlang.html#port_info-1.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Port.control(port, operation, data)
#: lib/port.ex:47 
msgid ""
"See http://www.erlang.org/doc/man/erlang.html#port_control-3.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Port.connect(port, pid)
#: lib/port.ex:38 
msgid ""
"See http://www.erlang.org/doc/man/erlang.html#port_connect-2.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Port.command(port, data, options \\ [])
#: lib/port.ex:29 
msgid ""
"See http://www.erlang.org/doc/man/erlang.html#port_command-2.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Port.close(port)
#: lib/port.ex:20 
msgid ""
"See http://www.erlang.org/doc/man/erlang.html#port_close-1.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Port.call(port, operation, data)
#: lib/port.ex:56 
msgid ""
"See http://www.erlang.org/doc/man/erlang.html#port_call-3.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def File.rmdir!(path)
#: lib/file.ex:735 
msgid ""
"Same as `rmdir/1`, but raises an exception in case of failure. Otherwise `:ok`.\n"
msgstr ""
#. TRANSLATORS: def File.rm_rf!(path)
#: lib/file.ex:838 
msgid ""
"Same as `rm_rf/1` but raises `File.Error` in case of failures,\n"
"otherwise the list of files or directories removed.\n"
msgstr ""
#. TRANSLATORS: def File.rm!(path)
#: lib/file.ex:704 
msgid ""
"Same as `rm/1`, but raises an exception in case of failure. Otherwise `:ok`.\n"
msgstr ""
#. TRANSLATORS: def File.open!(path, modes, function)
#: lib/file.ex:985 
msgid ""
"Same as `open/3` but raises an error if file could not be opened.\n"
"\n"
"Returns the function result otherwise.\n"
msgstr ""
#. TRANSLATORS: def File.open!(path, modes \\ [])
#: lib/file.ex:970 
msgid ""
"Same as `open/2` but raises an error if file could not be opened.\n"
"\n"
"Returns the `io_device` otherwise.\n"
msgstr ""
#. TRANSLATORS: def File.mkdir_p!(path)
#: lib/file.ex:204 
msgid ""
"Same as `mkdir_p/1`, but raises an exception in case of failure. Otherwise `:ok`.\n"
msgstr ""
#. TRANSLATORS: def File.mkdir!(path)
#: lib/file.ex:151 
msgid ""
"Same as `mkdir/1`, but raises an exception in case of failure. Otherwise `:ok`.\n"
msgstr ""
#. TRANSLATORS: def File.chown!(path, uid)
#: lib/file.ex:1204 
msgid ""
"Same as `chown/2`, but raises an exception in case of failure. Otherwise `:ok`.\n"
msgstr ""
#. TRANSLATORS: def File.chmod!(path, mode)
#: lib/file.ex:1158 
msgid ""
"Same as `chmod/2`, but raises an exception in case of failure. Otherwise `:ok`.\n"
msgstr ""
#. TRANSLATORS: def File.chgrp!(path, gid)
#: lib/file.ex:1181 
msgid ""
"Same as `chgrp/2`, but raises an exception in case of failure. Otherwise `:ok`.\n"
msgstr ""
#. TRANSLATORS: def Float.round(number, precision \\ 0)
#: lib/float.ex:188 
msgid ""
"Rounds a floating point value to an arbitrary number of fractional digits\n"
"(between 0 and 15).\n"
"\n"
"This function only accepts floats and returns floats. Use `Kernel.round/1`\n"
"if you want a function that accepts both floats and integers and always\n"
"returns an integer.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Float.round(5.5674, 3)\n"
"    5.567\n"
"\n"
"    iex> Float.round(5.5675, 3)\n"
"    5.568\n"
"\n"
"    iex> Float.round(-5.5674, 3)\n"
"    -5.567\n"
"\n"
"    iex> Float.round(-5.5675, 3)\n"
"    -5.568\n"
"\n"
msgstr ""
#. TRANSLATORS: def Float.floor(number, precision \\ 0)
#: lib/float.ex:126 
msgid ""
"Rounds a float to the largest integer less than or equal to `num`.\n"
"\n"
"Floor also accepts a precision to round a floating point value down\n"
"to an arbitrary number of fractional digits (between 0 and 15).\n"
"\n"
"This function always returns floats. One may use `Kernel.trunc/1` to\n"
"truncate the result to an integer afterwards.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Float.floor(34.25)\n"
"    34.0\n"
"\n"
"    iex> Float.floor(-56.5)\n"
"    -57.0\n"
"\n"
"    iex> Float.floor(34.253, 2)\n"
"    34.25\n"
"\n"
msgstr ""
#. TRANSLATORS: def Float.ceil(number, precision \\ 0)
#: lib/float.ex:156 
msgid ""
"Rounds a float to the largest integer greater than or equal to `num`.\n"
"\n"
"Ceil also accepts a precision to round a floating point value down to\n"
"an arbitrary number of fractional digits (between 0 and 15).\n"
"\n"
"This function always returns floats. One may use `Kernel.trunc/1` to\n"
"truncate the result to an integer afterwards.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Float.ceil(34.25)\n"
"    35.0\n"
"\n"
"    iex> Float.ceil(-56.5)\n"
"    -56.0\n"
"\n"
"    iex> Float.ceil(34.253, 2)\n"
"    34.26\n"
"\n"
msgstr ""
#. TRANSLATORS: def Dict.has_key?(dict, key)
#: lib/dict.ex:345 
msgid ""
"Returns whether the given `key` exists in the given `dict`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> Dict.has_key?(dict, :a)\n"
"    true\n"
"    iex> Dict.has_key?(dict, :b)\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Port.open(name, settings)
#: lib/port.ex:11 
msgid ""
"See http://www.erlang.org/doc/man/erlang.html#open_port-2.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Regex.split(regex, string, options \\ [])
#: lib/regex.ex:369 
msgid ""
"Splits the given target into the number of parts specified.\n"
"\n"
"## Options\n"
"\n"
"  * `:parts` - when specified, splits the string into the given number of\n"
"    parts. If not specified, `:parts` defaults to `:infinity`, which will\n"
"    split the string into the maximum number of parts possible based on the\n"
"    given pattern.\n"
"\n"
"  * `:trim` - when true, remove blank strings from the result.\n"
"\n"
"  * `:on` - specifies which captures and order to split the string\n"
"    on. Check the moduledoc for `Regex` to see the possible capture\n"
"    values. Defaults to `:first` which means captures inside the\n"
"    Regex does not affect the split result.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.split(~r/-/, \"a-b-c\")\n"
"    [\"a\",\"b\",\"c\"]\n"
"\n"
"    iex> Regex.split(~r/-/, \"a-b-c\", [parts: 2])\n"
"    [\"a\",\"b-c\"]\n"
"\n"
"    iex> Regex.split(~r/-/, \"abc\")\n"
"    [\"abc\"]\n"
"\n"
"    iex> Regex.split(~r//, \"abc\")\n"
"    [\"a\", \"b\", \"c\", \"\"]\n"
"\n"
"    iex> Regex.split(~r/a(?<second>b)c/, \"abc\")\n"
"    [\"\", \"\"]\n"
"\n"
"    iex> Regex.split(~r/a(?<second>b)c/, \"abc\", on: [:second])\n"
"    [\"a\", \"c\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.split(collection, count)
#: lib/enum.ex:1649 
msgid ""
"Splits the enumerable into two collections, leaving `count`\n"
"elements in the first one. If `count` is a negative number,\n"
"it starts counting from the back to the beginning of the\n"
"collection.\n"
"\n"
"Be aware that a negative `count` implies the collection\n"
"will be enumerated twice: once to calculate the position, and\n"
"a second time to do the actual splitting.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.split([1, 2, 3], 2)\n"
"    {[1,2], [3]}\n"
"\n"
"    iex> Enum.split([1, 2, 3], 10)\n"
"    {[1,2,3], []}\n"
"\n"
"    iex> Enum.split([1, 2, 3], 0)\n"
"    {[], [1,2,3]}\n"
"\n"
"    iex> Enum.split([1, 2, 3], -1)\n"
"    {[1,2], [3]}\n"
"\n"
"    iex> Enum.split([1, 2, 3], -5)\n"
"    {[], [1,2,3]}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Process.flag(flag, value)
#: lib/process.ex:337 
msgid ""
"Sets certain flags for the process which calls this function.\n"
"Returns the old value of the flag.\n"
"\n"
"See http://www.erlang.org/doc/man/erlang.html#process_flag-2 for more info.\n"
msgstr ""
#. TRANSLATORS: def Process.flag(pid, flag, value)
#: lib/process.ex:349 
msgid ""
"Sets certain flags for the process `pid`, in the same manner as `flag/2`.\n"
"Returns the old value of the flag. The allowed values for `flag` are\n"
"only a subset of those allowed in `flag/2`, namely: `save_calls`.\n"
"\n"
"See http://www.erlang.org/doc/man/erlang.html#process_flag-3 for more info.\n"
msgstr ""
#. TRANSLATORS: def IO.ANSI.yellow_background()
#: lib/io/ansi.ex:105 
msgid ""
"Sets background color to yellow"
msgstr ""
#. TRANSLATORS: def IO.ANSI.white_background()
#: lib/io/ansi.ex:105 
msgid ""
"Sets background color to white"
msgstr ""
#. TRANSLATORS: def IO.ANSI.red_background()
#: lib/io/ansi.ex:105 
msgid ""
"Sets background color to red"
msgstr ""
#. TRANSLATORS: def IO.ANSI.magenta_background()
#: lib/io/ansi.ex:105 
msgid ""
"Sets background color to magenta"
msgstr ""
#. TRANSLATORS: def IO.ANSI.green_background()
#: lib/io/ansi.ex:105 
msgid ""
"Sets background color to green"
msgstr ""
#. TRANSLATORS: def IO.ANSI.cyan_background()
#: lib/io/ansi.ex:105 
msgid ""
"Sets background color to cyan"
msgstr ""
#. TRANSLATORS: def IO.ANSI.blue_background()
#: lib/io/ansi.ex:105 
msgid ""
"Sets background color to blue"
msgstr ""
#. TRANSLATORS: def IO.ANSI.black_background()
#: lib/io/ansi.ex:105 
msgid ""
"Sets background color to black"
msgstr ""
#. TRANSLATORS: def Kernel.macro_exported?(module, macro, arity)
#: lib/kernel.ex:2399 
msgid ""
"Returns true if the `module` is loaded and contains a\n"
"public `macro` with the given `arity`, otherwise false.\n"
"\n"
"Notice that this function does not load the module in case\n"
"it is not loaded. Check `Code.ensure_loaded/1` for more\n"
"information.\n"
msgstr ""
#. TRANSLATORS: def Kernel.function_exported?(module, function, arity)
#: lib/kernel.ex:2386 
msgid ""
"Returns true if the `module` is loaded and contains a\n"
"public `function` with the given `arity`, otherwise false.\n"
"\n"
"Notice that this function does not load the module in case\n"
"it is not loaded. Check `Code.ensure_loaded/1` for more\n"
"information.\n"
msgstr ""
#. TRANSLATORS: def Kernel.Typespec.beam_callbacks(module)
#: lib/kernel/typespec.ex:469 
msgid ""
"Returns all callbacks available from the module's beam code.\n"
"\n"
"The result is returned as a list of tuples where the first\n"
"element is spec name and arity and the second is the spec.\n"
"\n"
"The module must have a corresponding beam file\n"
"which can be located by the runtime system.\n"
msgstr ""
#. TRANSLATORS: def Module.definitions_in(module, kind)
#: lib/module.ex:672 
msgid ""
"Returns all functions defined in `module`, according\n"
"to its kind.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Example do\n"
"      def version, do: 1\n"
"      Module.definitions_in __MODULE__, :def  #=> [{:version,0}]\n"
"      Module.definitions_in __MODULE__, :defp #=> []\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def Process.get(key, default \\ nil)
#: lib/process.ex:41 
msgid ""
"Returns the value for the given `key`.\n"
msgstr ""
#. TRANSLATORS: def Application.get_env(app, key, default \\ nil)
#: lib/application.ex:129 
msgid ""
"Returns the value for `key` in `app`'s environment.\n"
"\n"
"If the specified application is not loaded, or the configuration parameter\n"
"does not exist, the function returns the `default` value.\n"
msgstr ""
#. TRANSLATORS: def Application.fetch_env(app, key)
#: lib/application.ex:143 
msgid ""
"Returns the value for `key` in `app`'s environment in a tuple.\n"
"\n"
"If the specified application is not loaded, or the configuration parameter\n"
"does not exist, the function returns `:error`.\n"
msgstr ""
#. TRANSLATORS: def Dict.get(dict, key, default \\ nil)
#: lib/dict.ex:364 
msgid ""
"Returns the value associated with `key` in `dict`. If `dict` does not\n"
"contain `key`, returns `default` (or `nil` if not provided).\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> Dict.get(dict, :a)\n"
"    1\n"
"    iex> Dict.get(dict, :b)\n"
"    nil\n"
"    iex> Dict.get(dict, :b, 3)\n"
"    3\n"
msgstr ""
#. TRANSLATORS: def Dict.fetch!(dict, key)
#: lib/dict.ex:398 
msgid ""
"Returns the value associated with `key` in `dict`. If `dict` does not\n"
"contain `key`, it raises `KeyError`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> Dict.fetch!(dict, :a)\n"
"    1\n"
"\n"
msgstr ""
#. TRANSLATORS: def Dict.pop(dict, key, default \\ nil)
#: lib/dict.ex:524 
msgid ""
"Returns the value associated with `key` in `dict` as\n"
"well as the `dict` without `key`.\n"
"\n"
"If `key` is not present in `dict`, then the `dict` will\n"
"be returned unmodified.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> {v, dict} = Dict.pop dict, :a\n"
"    iex> {v, Enum.sort(dict)}\n"
"    {1,[]}\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> {v, dict} = Dict.pop dict, :b\n"
"    iex> {v, Enum.sort(dict)}\n"
"    {nil,[a: 1]}\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> {v, dict} = Dict.pop dict, :b, 3\n"
"    iex> {v, Enum.sort(dict)}\n"
"    {3,[a: 1]}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.min(collection)
#: lib/enum.ex:1144 
msgid ""
"Returns the minimum value.\n"
"Raises `EmptyError` if the collection is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.min([1, 2, 3])\n"
"    1\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.min_by(collection, fun)
#: lib/enum.ex:1159 
msgid ""
"Returns the minimum value as calculated by the given function.\n"
"Raises `EmptyError` if the collection is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.min_by([\"a\", \"aa\", \"aaa\"], fn(x) -> String.length(x) end)\n"
"    \"a\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.max(collection)
#: lib/enum.ex:1058 
msgid ""
"Returns the maximum value.\n"
"Raises `EmptyError` if the collection is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.max([1, 2, 3])\n"
"    3\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.max_by(collection, fun)
#: lib/enum.ex:1073 
msgid ""
"Returns the maximum value as calculated by the given function.\n"
"Raises `EmptyError` if the collection is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.max_by([\"a\", \"aa\", \"aaa\"], fn(x) -> String.length(x) end)\n"
"    \"aaa\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Node.get_cookie()
#: lib/node.ex:256 
msgid ""
"Returns the magic cookie of the local node.\n"
"\n"
"Returns the cookie if the node is alive, otherwise `:nocookie`.\n"
msgstr ""
#. TRANSLATORS: def Kernel.length(list)
#: lib/kernel.ex:419 
msgid ""
"Returns the length of `list`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> length([1, 2, 3, 4, 5, 6, 7, 8, 9])\n"
"    9\n"
"\n"
msgstr ""
#. TRANSLATORS: def Regex.re_pattern(regex)
#: lib/regex.ex:244 
msgid ""
"Returns the underlying `re_pattern` in the regular expression.\n"
msgstr ""
#. TRANSLATORS: def Enum.sum(collection)
#: lib/enum.ex:1198 
msgid ""
"Returns the sum of all values.\n"
"\n"
"Raises `ArithmeticError` if collection contains a non-numeric value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.sum([1, 2, 3])\n"
"    6\n"
"\n"
msgstr ""
#. TRANSLATORS: def IO.iodata_length(item)
#: lib/io.ex:389 
msgid ""
"Returns the size of an iodata.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> IO.iodata_length([1, 2|<<3, 4>>])\n"
"    4\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.tuple_size(tuple)
#: lib/kernel.ex:743 
msgid ""
"Returns the size of a tuple.\n"
"\n"
"This operation happens in constant time.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Kernel.map_size(map)
#: lib/kernel.ex:449 
msgid ""
"Returns the size of a map.\n"
"\n"
"This operation happens in constant time.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Regex.source(regex)
#: lib/regex.ex:258 
msgid ""
"Returns the regex source as a binary.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.source(~r(foo))\n"
"    \"foo\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Regex.opts(regex)
#: lib/regex.ex:272 
msgid ""
"Returns the regex options as a string.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.opts(~r(foo)m)\n"
"    \"m\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Process.whereis(name)
#: lib/process.ex:298 
msgid ""
"Returns the pid or port identifier with the registered name.\n"
"Returns `nil` if the name is not registered.\n"
"\n"
"See http://www.erlang.org/doc/man/erlang.html#whereis-1 for more info.\n"
msgstr ""
#. TRANSLATORS: def Process.group_leader()
#: lib/process.ex:306 
msgid ""
"Returns the pid of the group leader for the process which evaluates the function.\n"
msgstr ""
#. TRANSLATORS: def Kernel.self()
#: lib/kernel.ex:572 
msgid ""
"Returns the pid (process identifier) of the calling process.\n"
"\n"
"Allowed in guard clauses. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Node.spawn(node, fun)
#: lib/node.ex:161 
msgid ""
"Returns the pid of a new process started by the application of `fun`\n"
"on `node`. If `node` does not exist, a useless pid is returned.\n"
"\n"
"Check http://www.erlang.org/doc/man/erlang.html#spawn-2 for\n"
"the list of available options.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Node.spawn(node, fun, opts)
#: lib/node.ex:176 
msgid ""
"Returns the pid of a new process started by the application of `fun`\n"
"on `node`.\n"
"\n"
"If `node` does not exist, a useless pid is returned. Check\n"
"http://www.erlang.org/doc/man/erlang.html#spawn_opt-3 for the list of\n"
"available options.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Node.spawn(node, module, fun, args, opts)
#: lib/node.ex:206 
msgid ""
"Returns the pid of a new process started by the application of\n"
"`module.function(args)` on `node`.\n"
"\n"
"If `node` does not exist, a useless pid is returned. Check\n"
"http://www.erlang.org/doc/man/erlang.html#spawn_opt-5 for the list of\n"
"available options.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Node.spawn(node, module, fun, args)
#: lib/node.ex:191 
msgid ""
"Returns the pid of a new process started by the application of\n"
"`module.function(args)` on `node`.\n"
"\n"
"If `node` does not exist, a useless pid is returned. Check\n"
"http://www.erlang.org/doc/man/erlang.html#spawn-4 for the list of\n"
"available options.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Node.spawn_link(node, fun)
#: lib/node.ex:220 
msgid ""
"Returns the pid of a new linked process started by the application of `fun` on `node`.\n"
"\n"
"A link is created between the calling process and the new process, atomically.\n"
"If `node` does not exist, a useless pid is returned (and due to the link, an exit\n"
"signal with exit reason `:noconnection` will be received).\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Node.spawn_link(node, module, fun, args)
#: lib/node.ex:235 
msgid ""
"Returns the pid of a new linked process started by the application of\n"
"`module.function(args)` on `node`.\n"
"\n"
"A link is created between the calling process and the new process, atomically.\n"
"If `node` does not exist, a useless pid is returned (and due to the link, an exit\n"
"signal with exit reason `:noconnection` will be received).\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Path.type(name)
#: lib/path.ex:189 
msgid ""
"Returns the path type.\n"
"\n"
"## Unix examples\n"
"\n"
"    Path.type(\"/\")                #=> :absolute\n"
"    Path.type(\"/usr/local/bin\")   #=> :absolute\n"
"    Path.type(\"usr/local/bin\")    #=> :relative\n"
"    Path.type(\"../usr/local/bin\") #=> :relative\n"
"    Path.type(\"~/file\")           #=> :relative\n"
"\n"
"## Windows examples\n"
"\n"
"    Path.type(\"D:/usr/local/bin\") #=> :absolute\n"
"    Path.type(\"usr/local/bin\")    #=> :relative\n"
"    Path.type(\"D:bar.ex\")         #=> :volumerelative\n"
"    Path.type(\"/bar/foo.ex\")      #=> :volumerelative\n"
"\n"
msgstr ""
#. TRANSLATORS: def String.length(string)
#: lib/string.ex:978 
msgid ""
"Returns the number of unicode graphemes in an utf8 string.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.length(\"elixir\")\n"
"    6\n"
"\n"
"    iex> String.length(\"Õ¥Õ¸Õ£Õ¬Õ«\")\n"
"    5\n"
"\n"
msgstr ""
#. TRANSLATORS: def Set.size(set)
#: lib/set.ex:251 
msgid ""
"Returns the number of elements in `set`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Set.size(Enum.into([1, 2, 3], set_impl.new))\n"
"    3\n"
"\n"
msgstr ""
#. TRANSLATORS: def Dict.size(dict)
#: lib/dict.ex:328 
msgid ""
"Returns the number of elements in `dict`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> Dict.size(dict)\n"
"    2\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.byte_size(binary)
#: lib/kernel.ex:154 
msgid ""
"Returns the number of bytes needed to contain `bitstring`.\n"
"\n"
"That is, if the number of bits in `bitstring` is not divisible by 8,\n"
"the resulting number of bytes will be rounded up. This operation\n"
"happens in constant time.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> byte_size(<<433::16, 3::3>>)\n"
"    3\n"
"\n"
"    iex> byte_size(<<1, 2, 3>>)\n"
"    3\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.node(arg)
#: lib/kernel.ex:508 
msgid ""
"Returns the node where the given argument is located.\n"
"The argument can be a pid, a reference, or a port.\n"
"If the local node is not alive, `nonode@nohost` is returned.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def String.next_grapheme(string)
#: lib/string.ex:918 
msgid ""
"Returns the next grapheme in a String.\n"
"\n"
"The result is a tuple with the grapheme and the\n"
"remaining of the string or `nil` in case\n"
"the String reached its end.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.next_grapheme(\"olÃ¡\")\n"
"    {\"o\", \"lÃ¡\"}\n"
"\n"
msgstr ""
#. TRANSLATORS: def String.next_codepoint(string)
#: lib/string.ex:768 
msgid ""
"Returns the next codepoint in a String.\n"
"\n"
"The result is a tuple with the codepoint and the\n"
"remaining of the string or `nil` in case\n"
"the string reached its end.\n"
"\n"
"As with other functions in the String module, this\n"
"function does not check for the validity of the codepoint.\n"
"That said, if an invalid codepoint is found, it will\n"
"be returned by this function.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.next_codepoint(\"olÃ¡\")\n"
"    {\"o\", \"lÃ¡\"}\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.to_float(char_list)
#: lib/list.ex:484 
msgid ""
"Returns the float whose text representation is `char_list`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.to_float('2.2017764e+0')\n"
"    2.2017764\n"
"\n"
msgstr ""
#. TRANSLATORS: def String.last(string)
#: lib/string.ex:955 
msgid ""
"Returns the last grapheme from an utf8 string,\n"
"`nil` if the string is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.last(\"elixir\")\n"
"    \"r\"\n"
"\n"
"    iex> String.last(\"Õ¥Õ¸Õ£Õ¬Õ«\")\n"
"    \"Õ«\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.last(list1)
#: lib/list.ex:155 
msgid ""
"Returns the last element in `list` or `nil` if `list` is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.last([])\n"
"    nil\n"
"\n"
"    iex> List.last([1])\n"
"    1\n"
"\n"
"    iex> List.last([1, 2, 3])\n"
"    3\n"
"\n"
msgstr ""
#. TRANSLATORS: def Path.basename(path)
#: lib/path.ex:335 
msgid ""
"Returns the last component of the path or the path\n"
"itself if it does not contain any directory separators.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.basename(\"foo\")\n"
"    \"foo\"\n"
"\n"
"    iex> Path.basename(\"foo/bar\")\n"
"    \"bar\"\n"
"\n"
"    iex> Path.basename(\"/\")\n"
"    \"\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Path.basename(path, extension)
#: lib/path.ex:357 
msgid ""
"Returns the last component of `path` with the `extension`\n"
"stripped. This function should be used to remove a specific\n"
"extension which may, or may not, be there.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.basename(\"~/foo/bar.ex\", \".ex\")\n"
"    \"bar\"\n"
"\n"
"    iex> Path.basename(\"~/foo/bar.exs\", \".ex\")\n"
"    \"bar.exs\"\n"
"\n"
"    iex> Path.basename(\"~/foo/bar.old.ex\", \".ex\")\n"
"    \"bar.old\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.hd(list)
#: lib/kernel.ex:248 
msgid ""
"Returns the head of a list, raises `badarg` if the list is empty.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def String.at(string, position)
#: lib/string.ex:1012 
msgid ""
"Returns the grapheme in the `position` of the given utf8 `string`.\n"
"If `position` is greater than `string` length, then it returns `nil`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.at(\"elixir\", 0)\n"
"    \"e\"\n"
"\n"
"    iex> String.at(\"elixir\", 1)\n"
"    \"l\"\n"
"\n"
"    iex> String.at(\"elixir\", 10)\n"
"    nil\n"
"\n"
"    iex> String.at(\"elixir\", -1)\n"
"    \"r\"\n"
"\n"
"    iex> String.at(\"elixir\", -10)\n"
"    nil\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.find(collection, ifnone \\ nil, fun)
#: lib/enum.ex:706 
msgid ""
"Returns the first item for which `fun` returns a truthy value. If no such\n"
"item is found, returns `ifnone`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.find([2, 4, 6], fn(x) -> rem(x, 2) == 1 end)\n"
"    nil\n"
"\n"
"    iex> Enum.find([2, 4, 6], 0, fn(x) -> rem(x, 2) == 1 end)\n"
"    0\n"
"\n"
"    iex> Enum.find([2, 3, 4], fn(x) -> rem(x, 2) == 1 end)\n"
"    3\n"
"\n"
msgstr ""
#. TRANSLATORS: def Regex.named_captures(regex, string, options \\ [])
#: lib/regex.ex:233 
msgid ""
"Returns the given captures as a map or `nil` if no captures are\n"
"found. The option `:return` can be set to `:index` to get indexes\n"
"back.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.named_captures(~r/c(?<foo>d)/, \"abcd\")\n"
"    %{\"foo\" => \"d\"}\n"
"\n"
"    iex> Regex.named_captures(~r/a(?<foo>b)c(?<bar>d)/, \"abcd\")\n"
"    %{\"bar\" => \"d\", \"foo\" => \"b\"}\n"
"\n"
"    iex> Regex.named_captures(~r/a(?<foo>b)c(?<bar>d)/, \"efgh\")\n"
"    nil\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.Chars.BitString.to_char_list(thing)
#: lib/list/chars.ex:23 
msgid ""
"Returns the given binary converted to a char list.\n"
msgstr ""
#. TRANSLATORS: def Path.relative_to(path, from)
#: lib/path.ex:288 
msgid ""
"Returns the given `path` relative to the given `from` path.\n"
"In other words, it tries to strip the `from` prefix from `path`.\n"
"\n"
"This function does not query the file system, so it assumes\n"
"no symlinks in between the paths.\n"
"\n"
"In case a direct relative path cannot be found, it returns\n"
"the original path.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.relative_to(\"/usr/local/foo\", \"/usr/local\")\n"
"    \"foo\"\n"
"\n"
"    iex> Path.relative_to(\"/usr/local/foo\", \"/\")\n"
"    \"usr/local/foo\"\n"
"\n"
"    iex> Path.relative_to(\"/usr/local/foo\", \"/etc\")\n"
"    \"/usr/local/foo\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Range.Iterator.next(first, range)
#: lib/range.ex:55 
msgid ""
"Returns the function that calculates the next item.\n"
msgstr ""
#. TRANSLATORS: def Keyword.pop_first(keywords, key, default \\ nil)
#: lib/keyword.ex:597 
msgid ""
"Returns the first value associated with `key` in the keyword\n"
"list as well as the keyword list without that particular occurrence\n"
"of `key`.\n"
"\n"
"Duplicated keys are not removed.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.pop_first [a: 1], :a\n"
"    {1,[]}\n"
"\n"
"    iex> Keyword.pop_first [a: 1], :b\n"
"    {nil,[a: 1]}\n"
"\n"
"    iex> Keyword.pop_first [a: 1], :b, 3\n"
"    {3,[a: 1]}\n"
"\n"
"    iex> Keyword.pop_first [a: 1], :b, 3\n"
"    {3,[a: 1]}\n"
"\n"
"    iex> Keyword.pop_first [a: 1, a: 2], :a\n"
"    {1,[a: 2]}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.pop(keywords, key, default \\ nil)
#: lib/keyword.ex:568 
msgid ""
"Returns the first value associated with `key` in the keyword\n"
"list as well as the keyword list without `key`.\n"
"\n"
"All duplicated keys are removed. See `pop_first/3` for\n"
"removing only the first entry.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.pop [a: 1], :a\n"
"    {1,[]}\n"
"\n"
"    iex> Keyword.pop [a: 1], :b\n"
"    {nil,[a: 1]}\n"
"\n"
"    iex> Keyword.pop [a: 1], :b, 3\n"
"    {3,[a: 1]}\n"
"\n"
"    iex> Keyword.pop [a: 1], :b, 3\n"
"    {3,[a: 1]}\n"
"\n"
"    iex> Keyword.pop [a: 1, a: 2], :a\n"
"    {1,[]}\n"
"\n"
msgstr ""
#. TRANSLATORS: def String.first(string)
#: lib/string.ex:934 
msgid ""
"Returns the first grapheme from an utf8 string,\n"
"nil if the string is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.first(\"elixir\")\n"
"    \"e\"\n"
"\n"
"    iex> String.first(\"Õ¥Õ¸Õ£Õ¬Õ«\")\n"
"    \"Õ¥\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.first(list1)
#: lib/list.ex:136 
msgid ""
"Returns the first element in `list` or `nil` if `list` is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.first([])\n"
"    nil\n"
"\n"
"    iex> List.first([1])\n"
"    1\n"
"\n"
"    iex> List.first([1, 2, 3])\n"
"    1\n"
"\n"
msgstr ""
#. TRANSLATORS: def Path.extname(path)
#: lib/path.ex:390 
msgid ""
"Returns the extension of the last component of `path`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.extname(\"foo.erl\")\n"
"    \".erl\"\n"
"\n"
"    iex> Path.extname(\"~/foo/bar\")\n"
"    \"\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Code.get_docs(module, kind)
#: lib/code.ex:506 
msgid ""
"Returns the docs for the given module.\n"
"\n"
"When given a module name, it finds its BEAM code and reads the docs from it.\n"
"\n"
"When given a path to a .beam file, it will load the docs directly from that\n"
"file.\n"
"\n"
"The return value depends on the `kind` value:\n"
"\n"
"  * `:docs` - list of all docstrings attached to functions and macros\n"
"    using the `@doc` attribute\n"
"\n"
"  * `:moduledoc` - tuple `{<line>, <doc>}` where `line` is the line on\n"
"    which module definition starts and `doc` is the string\n"
"    attached to the module using the `@moduledoc` attribute\n"
"\n"
"  * `:all` - a keyword list with both `:docs` and `:moduledoc`\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.__MODULE__()
#: lib/kernel/special_forms.ex:586 
msgid ""
"Returns the current module name as an atom or `nil` otherwise.\n"
"\n"
"Although the module can be accessed in the `__ENV__`, this macro\n"
"is a convenient shortcut.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.__ENV__()
#: lib/kernel/special_forms.ex:578 
msgid ""
"Returns the current environment information as a `Macro.Env` struct.\n"
"\n"
"In the environment you can access the current filename,\n"
"line numbers, set up aliases, the current function and others.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.__DIR__()
#: lib/kernel/special_forms.ex:594 
msgid ""
"Returns the current directory as a binary.\n"
"\n"
"Although the directory can be accessed as `Path.dirname(__ENV__.file)`,\n"
"this macro is a convenient shortcut.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.__CALLER__()
#: lib/kernel/special_forms.ex:602 
msgid ""
"Returns the current calling environment as a `Macro.Env` struct.\n"
"\n"
"In the environment you can access the filename, line numbers,\n"
"set up aliases, the function and others.\n"
msgstr ""
#. TRANSLATORS: def Enum.count(collection, fun)
#: lib/enum.ex:455 
msgid ""
"Returns the count of items in the collection for which\n"
"`fun` returns `true`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.count([1, 2, 3, 4, 5], fn(x) -> rem(x, 2) == 0 end)\n"
"    2\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.count(collection)
#: lib/enum.ex:429 
msgid ""
"Returns the collection's size.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.count([1, 2, 3])\n"
"    3\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.with_index(collection)
#: lib/enum.ex:1865 
msgid ""
"Returns the collection with each element wrapped in a tuple\n"
"alongside its index.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.with_index [1,2,3]\n"
"    [{1,0},{2,1},{3,2}]\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.binding(context \\ nil)
#: lib/kernel.ex:2100 
msgid ""
"Returns the binding for the given context as a keyword list.\n"
"\n"
"The variable name is the key and the variable value is the value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> x = 1\n"
"    iex> binding()\n"
"    [x: 1]\n"
"    iex> x = 2\n"
"    iex> binding()\n"
"    [x: 2]\n"
"\n"
"    iex> binding(:foo)\n"
"    []\n"
"    iex> var!(x, :foo) = 1\n"
"    1\n"
"    iex> binding(:foo)\n"
"    [x: 1]\n"
"\n"
msgstr ""
#. TRANSLATORS: def File.ls(path \\ ".")
#: lib/file.ex:1080 
msgid ""
"Returns list of files in the given directory.\n"
"\n"
"It returns `{:ok, [files]}` in case of success,\n"
"`{:error, reason}` otherwise.\n"
msgstr ""
#. TRANSLATORS: def Kernel.bit_size(bitstring)
#: lib/kernel.ex:131 
msgid ""
"Returns an integer which is the size in bits of `bitstring`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> bit_size(<<433::16, 3::3>>)\n"
"    19\n"
"\n"
"    iex> bit_size(<<1, 2, 3>>)\n"
"    24\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.abs(number)
#: lib/kernel.ex:55 
msgid ""
"Returns an integer or float which is the arithmetical absolute value of `number`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> abs(-3.33)\n"
"    3.33\n"
"\n"
"    iex> abs(-3)\n"
"    3\n"
"\n"
msgstr ""
#. TRANSLATORS: def Path.rootname(path, extension)
#: lib/path.ex:425 
msgid ""
"Returns the `path` with the `extension` stripped. This function should be used to\n"
"remove a specific extension which might, or might not, be there.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.rootname(\"/foo/bar.erl\", \".erl\")\n"
"    \"/foo/bar\"\n"
"\n"
"    iex> Path.rootname(\"/foo/bar.erl\", \".ex\")\n"
"    \"/foo/bar.erl\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Path.rootname(path)
#: lib/path.ex:407 
msgid ""
"Returns the `path` with the `extension` stripped.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.rootname(\"/foo/bar\")\n"
"    \"/foo/bar\"\n"
"\n"
"    iex> Path.rootname(\"/foo/bar.ex\")\n"
"    \"/foo/bar\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Process.info(pid)
#: lib/process.ex:361 
msgid ""
"Returns information about the process identified by `pid` or `nil` if the process\n"
"is not alive.\n"
"Use this only for debugging information.\n"
"\n"
"See http://www.erlang.org/doc/man/erlang.html#process_info-1 for more info.\n"
msgstr ""
#. TRANSLATORS: def Process.info(pid, spec)
#: lib/process.ex:372 
msgid ""
"Returns information about the process identified by `pid`\n"
"or `nil` if the process is not alive.\n"
"\n"
"See http://www.erlang.org/doc/man/erlang.html#process_info-2 for more info.\n"
msgstr ""
#. TRANSLATORS: def Enum.reject(collection, fun)
#: lib/enum.ex:1315 
msgid ""
"Returns elements of collection for which `fun` returns `false`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reject([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    [1, 3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def File.stat(path, opts \\ [])
#: lib/file.ex:269 
msgid ""
"Returns information about the `path`. If it exists, it\n"
"returns a `{:ok, info}` tuple, where info is a\n"
"`File.Stat` struct. Returns `{:error, reason}` with\n"
"the same reasons as `read/1` if a failure occurs.\n"
"\n"
"## Options\n"
"\n"
"The accepted options are:\n"
"\n"
"  * `:time` - configures how the file timestamps are returned\n"
"\n"
"The values for `:time` can be:\n"
"\n"
"  * `:local` - returns a `{date, time}` tuple using the machine time\n"
"  * `:universal` - returns a `{date, time}` tuple in UTC\n"
"  * `:posix` - returns the time as integer seconds since epoch\n"
"\n"
msgstr ""
#. TRANSLATORS: def String.codepoints(string)
#: lib/string.ex:746 
msgid ""
"Returns all codepoints in the string.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.codepoints(\"olÃ¡\")\n"
"    [\"o\", \"l\", \"Ã¡\"]\n"
"\n"
"    iex> String.codepoints(\"Ð¾Ð¿Ñ‚Ð¸Ð¼Ð¸ Ð·Ð°Ñ†Ð¸Ð¸\")\n"
"    [\"Ð¾\",\"Ð¿\",\"Ñ‚\",\"Ð¸\",\"Ð¼\",\"Ð¸\",\" \",\"Ð·\",\"Ð°\",\"Ñ†\",\"Ð¸\",\"Ð¸\"]\n"
"\n"
"    iex> String.codepoints(\"á¼…á¼ªá¿¼\")\n"
"    [\"á¼…\",\"á¼ª\",\"á¿¼\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def StringIO.contents(pid)
#: lib/string_io.ex:54 
msgid ""
"Returns current buffers.\n"
"\n"
"## Examples\n"
"\n"
"    iex> {:ok, pid} = StringIO.open(\"in\")\n"
"    iex> IO.write(pid, \"out\")\n"
"    iex> StringIO.contents(pid)\n"
"    {\"in\", \"out\"}\n"
"\n"
msgstr ""
#. TRANSLATORS: def File.read!(path)
#: lib/file.ex:239 
msgid ""
"Returns binary with the contents of the given filename or raises\n"
"`File.Error` if an error occurs.\n"
msgstr ""
#. TRANSLATORS: def Task.Supervisor.children(supervisor)
#: lib/task/supervisor.ex:86 
msgid ""
"Returns all children pids.\n"
msgstr ""
#. TRANSLATORS: Elixir.URI Summary
#: lib/uri.ex:1 
msgid ""
"Utilities for working with and creating URIs.\n"
msgstr ""
#. TRANSLATORS: Elixir.Code Summary
#: lib/code.ex:1 
msgid ""
"Utilities for managing code compilation, code evaluation and code loading.\n"
"\n"
"This module complements [Erlang's code module](http://www.erlang.org/doc/man/code.html)\n"
"to add behaviour which is specific to Elixir.\n"
msgstr ""
#. TRANSLATORS: Elixir.Behaviour Summary
#: lib/behaviour.ex:1 
msgid ""
"Utilities for defining behaviour interfaces.\n"
"\n"
"Behaviours can be referenced by other modules\n"
"to ensure they implement required callbacks.\n"
"\n"
"For example, you can specify the `URI.Parser`\n"
"behaviour as follows:\n"
"\n"
"    defmodule URI.Parser do\n"
"      use Behaviour\n"
"\n"
"      @doc \"Parses the given URL\"\n"
"      defcallback parse(uri_info :: URI.t) :: URI.t\n"
"\n"
"      @doc \"Defines a default port\"\n"
"      defcallback default_port() :: integer\n"
"    end\n"
"\n"
"And then a module may use it as:\n"
"\n"
"    defmodule URI.HTTP do\n"
"      @behaviour URI.Parser\n"
"      def default_port(), do: 80\n"
"      def parse(info), do: info\n"
"    end\n"
"\n"
"If the behaviour changes or `URI.HTTP` does\n"
"not implement one of the callbacks, a warning\n"
"will be raised.\n"
"\n"
"## Implementation\n"
"\n"
"Since Erlang R15, behaviours must be defined via\n"
"`@callback` attributes. `defcallback` is a simple\n"
"mechanism that defines the `@callback` attribute\n"
"according to the given type specification. `defcallback` allows\n"
"documentation to be created for the callback and defines\n"
"a custom function signature.\n"
"\n"
"The callbacks and their documentation can be retrieved\n"
"via the `__behaviour__` callback function.\n"
msgstr ""
#. TRANSLATORS: def System.user_home()
#: lib/system.ex:127 
msgid ""
"User home directory.\n"
"\n"
"Returns the user home directory (platform independent).\n"
"Returns `nil` if no user home is set.\n"
msgstr ""
#. TRANSLATORS: def System.user_home!()
#: lib/system.ex:140 
msgid ""
"User home directory, exception on error.\n"
"\n"
"Same as `user_home/0` but raises `RuntimeError`\n"
"instead of returning `nil` if no user home is set.\n"
msgstr ""
#. TRANSLATORS: Elixir.Set Summary
#: lib/set.ex:1 
msgid ""
"This module specifies the Set API expected to be\n"
"implemented by different representations.\n"
"\n"
"It also provides functions that redirect to the\n"
"underlying Set, allowing a developer to work with\n"
"different Set implementations using one API.\n"
"\n"
"To create a new set, use the `new` functions defined\n"
"by each set type:\n"
"\n"
"    HashSet.new  #=> creates an empty HashSet\n"
"\n"
"In the examples below, `set_impl` means a specific\n"
"`Set` implementation, for example `HashSet`.\n"
"\n"
"## Protocols\n"
"\n"
"Sets are required to implement both `Enumerable` and `Collectable`\n"
"protocols.\n"
"\n"
"## Match\n"
"\n"
"Sets are required to implement all operations using the match (`===`)\n"
"operator.\n"
msgstr ""
#. TRANSLATORS: Elixir.Dict Summary
#: lib/dict.ex:1 
msgid ""
"This module specifies the Dict API expected to be\n"
"implemented by different dictionaries. It also provides\n"
"functions that redirect to the underlying Dict, allowing\n"
"a developer to work with different Dict implementations\n"
"using one API.\n"
"\n"
"To create a new dict, use the `new` functions defined\n"
"by each dict type:\n"
"\n"
"    HashDict.new  #=> creates an empty HashDict\n"
"\n"
"In the examples below, `dict_impl` means a specific\n"
"`Dict` implementation, for example `HashDict` or `Map`.\n"
"\n"
"## Protocols\n"
"\n"
"Besides implementing the functions in this module, all\n"
"dictionaries are required to implement the `Access`\n"
"protocol:\n"
"\n"
"    iex> dict = dict_impl.new\n"
"    iex> dict = Dict.put(dict, :hello, :world)\n"
"    iex> dict[:hello]\n"
"    :world\n"
"\n"
"As well as the `Enumerable` and `Collectable` protocols.\n"
"\n"
"## Match\n"
"\n"
"Dictionaries are required to implement all operations\n"
"using the match (`===`) operator.\n"
"\n"
"## Default implementation\n"
"\n"
"Default implementations for some functions in the `Dict` module\n"
"are provided via `use Dict`.\n"
"\n"
"For example:\n"
"\n"
"    defmodule MyDict do\n"
"      use Dict\n"
"\n"
"      # implement required functions (see below)\n"
"      # override default implementations if optimization\n"
"      # is needed\n"
"    end\n"
"\n"
"The client module must contain the following functions:\n"
"\n"
"  * `delete/2`\n"
"  * `fetch/2`\n"
"  * `put/3`\n"
"  * `reduce/3`\n"
"  * `size/1`\n"
"\n"
"All functions, except `reduce/3`, are required by the Dict behaviour.\n"
"`reduce/3` must be implemented as per the Enumerable protocol.\n"
"\n"
"Based on these functions, `Dict` generates default implementations\n"
"for the following functions:\n"
"\n"
"  * `drop/2`\n"
"  * `equal?/2`\n"
"  * `fetch!/2`\n"
"  * `get/2`\n"
"  * `get/3`\n"
"  * `has_key?/2`\n"
"  * `keys/1`\n"
"  * `merge/2`\n"
"  * `merge/3`\n"
"  * `pop/2`\n"
"  * `pop/3`\n"
"  * `put_new/3`\n"
"  * `split/2`\n"
"  * `take/2`\n"
"  * `to_list/1`\n"
"  * `update/4`\n"
"  * `update!/3`\n"
"  * `values/1`\n"
"\n"
"All of these functions are defined as overridable, so you can provide\n"
"your own implementation if needed.\n"
"\n"
"Note you can also test your custom module via `Dict`'s doctests:\n"
"\n"
"    defmodule MyDict do\n"
"      # ...\n"
"    end\n"
"\n"
"    defmodule MyTests do\n"
"      use ExUnit.Case\n"
"      doctest Dict\n"
"      defp dict_impl, do: MyDict\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.Module Summary
#: lib/module.ex:1 
msgid ""
"This module provides many functions to deal with modules during\n"
"compilation time. It allows a developer to dynamically attach\n"
"documentation, add, delete and register attributes and so forth.\n"
"\n"
"After a module is compiled, using many of the functions in\n"
"this module will raise errors, since it is out of their scope\n"
"to inspect runtime data. Most of the runtime data can be inspected\n"
"via the `__info__(attr)` function attached to each compiled module.\n"
"\n"
"## Module attributes\n"
"\n"
"Each module can be decorated with one or more attributes. The following ones\n"
"are currently defined by Elixir:\n"
"\n"
"  * `@after_compile`\n"
"\n"
"    A hook that will be invoked right after the current module is compiled.\n"
"\n"
"    Accepts a module or a tuple `{<module>, <function atom>}`. The function\n"
"    must take two arguments: the module environment and its bytecode.\n"
"    When just a module is provided, the function is assumed to be\n"
"    `__after_compile__/2`.\n"
"\n"
"    ### Example\n"
"\n"
"        defmodule M do\n"
"          @after_compile __MODULE__\n"
"\n"
"          def __after_compile__(env, _bytecode) do\n"
"            IO.inspect env\n"
"          end\n"
"        end\n"
"\n"
"  * `@before_compile`\n"
"\n"
"    A hook that will be invoked before the module is compiled.\n"
"\n"
"    Accepts a module or a tuple `{<module>, <function/macro atom>}`. The\n"
"    function/macro must take one argument: the module environment. If it's a\n"
"    macro, its returned value will be injected at the end of the module definition\n"
"    before the compilation starts.\n"
"\n"
"    When just a module is provided, the function/macro is assumed to be\n"
"    `__before_compile__/1`.\n"
"\n"
"    Note: unlike `@after_compile`, the callback function/macro must\n"
"    be placed in a separate module (because when the callback is invoked,\n"
"    the current module does not yet exist).\n"
"\n"
"    ### Example\n"
"\n"
"        defmodule A do\n"
"          defmacro __before_compile__(_env) do\n"
"            quote do\n"
"              def hello, do: \"world\"\n"
"            end\n"
"          end\n"
"        end\n"
"\n"
"        defmodule B do\n"
"          @before_compile A\n"
"        end\n"
"\n"
"  * `@behaviour`   (notice the British spelling)\n"
"\n"
"    Specify an OTP or user-defined behaviour.\n"
"\n"
"    ### Example\n"
"\n"
"        defmodule M do\n"
"          @behaviour gen_event\n"
"\n"
"          # ...\n"
"        end\n"
"\n"
"  * `@compile`\n"
"\n"
"    Define options for module compilation that are passed to the Erlang\n"
"    compiler.\n"
"\n"
"    Accepts an atom, a tuple, or a list of atoms and tuples.\n"
"\n"
"    See http://www.erlang.org/doc/man/compile.html for the list of supported\n"
"    options.\n"
"\n"
"    Several uses of `@compile` will accumulate instead of overriding\n"
"    previous ones.\n"
"\n"
"    ### Example\n"
"\n"
"          defmodule M do\n"
"            @compile {:inline, myfun: 1}\n"
"\n"
"            def myfun(arg) do\n"
"              to_string(arg)\n"
"            end\n"
"          end\n"
"\n"
"  * `@doc`\n"
"\n"
"    Provide documentation for the function or macro that follows the\n"
"    attribute.\n"
"\n"
"    Accepts a string (often a heredoc) or `false` where `@doc false` will\n"
"    make the function/macro invisible to the documentation extraction tools\n"
"    like ExDoc.\n"
"\n"
"    Can be invoked more than once.\n"
"\n"
"    ### Example\n"
"\n"
"          defmodule M do\n"
"            @doc \"Hello world\"\n"
"            def hello do\n"
"              \"world\"\n"
"            end\n"
"\n"
"            @doc \"\"\"\n"
"            Sum.\n"
"            \"\"\"\n"
"            def sum(a, b) do\n"
"              a + b\n"
"            end\n"
"          end\n"
"\n"
"  * `@file`\n"
"\n"
"    Change the filename used in stacktraces for the function or macro that\n"
"    follows the attribute.\n"
"\n"
"    Accepts a string. Can be used more than once.\n"
"\n"
"    ### Example\n"
"\n"
"          defmodule M do\n"
"            @doc \"Hello world\"\n"
"            @file \"hello.ex\"\n"
"            def hello do\n"
"              \"world\"\n"
"            end\n"
"          end\n"
"\n"
"  * `@moduledoc`\n"
"\n"
"    Provide documentation for the current module.\n"
"\n"
"    Accepts a string (which is often a heredoc) or `false` where\n"
"    `@moduledoc false` will make the module invisible to the\n"
"    documentation extraction tools like ExDoc.\n"
"\n"
"    ### Example\n"
"\n"
"          defmodule M do\n"
"            @moduledoc \"\"\"\n"
"            A very useful module\n"
"            \"\"\"\n"
"          end\n"
"\n"
"\n"
"  * `@on_definition`\n"
"\n"
"    A hook that will be invoked when each function or macro in the current\n"
"    module is defined. Useful when annotating functions.\n"
"\n"
"    Accepts a module or a tuple `{<module>, <function atom>}`. The function\n"
"    must take 6 arguments:\n"
"\n"
"      - the module environment\n"
"      - kind: `:def`, `:defp`, `:defmacro`, or `:defmacrop`\n"
"      - function/macro name\n"
"      - list of expanded arguments\n"
"      - list of expanded guards\n"
"      - expanded function body\n"
"\n"
"    Note the hook receives the expanded arguments and it is invoked before\n"
"    the function is stored in the module. So `Module.defines?/2` will return\n"
"    false for the first clause of every function.\n"
"\n"
"    If the function/macro being defined has multiple clauses, the hook will\n"
"    be called for each clause.\n"
"\n"
"    Unlike other hooks, `@on_definition` will only invoke functions\n"
"    and never macros. This is because the hook is invoked inside the context\n"
"    of the function (and nested function definitions are not allowed in\n"
"    Elixir).\n"
"\n"
"    When just a module is provided, the function is assumed to be\n"
"    `__on_definition__/6`.\n"
"\n"
"    ### Example\n"
"\n"
"          defmodule H do\n"
"            def on_def(_env, kind, name, args, guards, body) do\n"
"              IO.puts \"Defining #{kind} named #{name} with args:\"\n"
"              IO.inspect args\n"
"              IO.puts \"and guards\"\n"
"              IO.inspect guards\n"
"              IO.puts \"and body\"\n"
"              IO.puts Macro.to_string(body)\n"
"            end\n"
"          end\n"
"\n"
"          defmodule M do\n"
"            @on_definition {H, :on_def}\n"
"\n"
"            def hello(arg) when is_binary(arg) or is_list(arg) do\n"
"              \"Hello\" <> to_string(arg)\n"
"            end\n"
"\n"
"            def hello(_) do\n"
"              :ok\n"
"            end\n"
"          end\n"
"\n"
"  * `@on_load`\n"
"\n"
"    A hook that will be invoked whenever the module is loaded.\n"
"\n"
"    Accepts a function atom of a function in the current module. The function\n"
"    must have arity 0 (no arguments) and has to return `:ok`, otherwise the\n"
"    loading of the module will be aborted.\n"
"\n"
"    ### Example\n"
"\n"
"          defmodule M do\n"
"            @on_load :load_check\n"
"\n"
"            def load_check do\n"
"              if some_condition() do\n"
"                :ok\n"
"              else\n"
"                nil\n"
"              end\n"
"            end\n"
"\n"
"            def some_condition do\n"
"              false\n"
"            end\n"
"          end\n"
"\n"
"  * `@vsn`\n"
"\n"
"    Specify the module version. Accepts any valid Elixir value.\n"
"\n"
"    ### Example\n"
"\n"
"          defmodule M do\n"
"            @vsn \"1.0\"\n"
"          end\n"
"\n"
"  * `@external_resource`\n"
"\n"
"    Specify an external resource to the current module.\n"
"\n"
"    Many times a module embeds information from an external file. This\n"
"    attribute allows the module to annotate which external resources\n"
"    have been used.\n"
"\n"
"    Tools like Mix may use this information to ensure the module is\n"
"    recompiled in case any of the external resources change.\n"
"\n"
"The following attributes are part of typespecs and are also reserved by\n"
"Elixir (see `Kernel.Typespec` for more information about typespecs):\n"
"\n"
"  * `@type`        - defines a type to be used in `@spec`\n"
"  * `@typep`       - defines a private type to be used in `@spec`\n"
"  * `@opaque`      - defines an opaque type to be used in `@spec`\n"
"  * `@spec`        - provides a specification for a function\n"
"  * `@callback`    - provides a specification for the behaviour callback\n"
"\n"
"In addition to the built-in attributes outlined above, custom attributes may\n"
"also be added. A custom attribute is any valid identifier prefixed with an\n"
"`@` and followed by a valid Elixir value:\n"
"\n"
"      defmodule M do\n"
"        @custom_attr [some: \"stuff\"]\n"
"      end\n"
"\n"
"For more advanced options available when defining custom attributes, see\n"
"`register_attribute/3`.\n"
"\n"
"## Runtime information about a module\n"
"\n"
"It is possible to query a module at runtime to find out which functions and\n"
"macros it defines, extract its docstrings, etc. See `__info__/1`.\n"
msgstr ""
#. TRANSLATORS: Elixir.Bitwise Summary
#: lib/bitwise.ex:1 
msgid ""
"This module provides macros and operators for bitwise operators.\n"
"These macros can be used in guards.\n"
"\n"
"The easiest way to use is to simply import them into\n"
"your module:\n"
"\n"
"    iex> use Bitwise\n"
"    iex> bnot 1\n"
"    -2\n"
"    iex> 1 &&& 1\n"
"    1\n"
"\n"
"You can select to include only or skip operators by passing options:\n"
"\n"
"    iex> use Bitwise, only_operators: true\n"
"    iex> 1 &&& 1\n"
"    1\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.Base Summary
#: lib/base.ex:1 
msgid ""
"This module provides data encoding and decoding functions\n"
"according to [RFC 4648](http://tools.ietf.org/html/rfc4648).\n"
"\n"
"This document defines the commonly used base 16, base 32, and base\n"
"64 encoding schemes.\n"
"\n"
"## Base 16 alphabet\n"
"\n"
"    | Value | Encoding | Value | Encoding | Value | Encoding | Value | Encoding |\n"
"    |------:|---------:|------:|---------:|------:|---------:|------:|---------:|\n"
"    |      0|         0|      4|         4|      8|         8|     12|         C|\n"
"    |      1|         1|      5|         5|      9|         9|     13|         D|\n"
"    |      2|         2|      6|         6|     10|         A|     14|         E|\n"
"    |      3|         3|      7|         7|     11|         B|     15|         F|\n"
"\n"
"## Base 32 alphabet\n"
"\n"
"    | Value | Encoding | Value | Encoding | Value | Encoding | Value | Encoding |\n"
"    |------:|---------:|------:|---------:|------:|---------:|------:|---------:|\n"
"    |      0|         A|      9|         J|     18|         S|     27|         3|\n"
"    |      1|         B|     10|         K|     19|         T|     28|         4|\n"
"    |      2|         C|     11|         L|     20|         U|     29|         5|\n"
"    |      3|         D|     12|         M|     21|         V|     30|         6|\n"
"    |      4|         E|     13|         N|     22|         W|     31|         7|\n"
"    |      5|         F|     14|         O|     23|         X|       |          |\n"
"    |      6|         G|     15|         P|     24|         Y|  (pad)|         =|\n"
"    |      7|         H|     16|         Q|     25|         Z|       |          |\n"
"    |      8|         I|     17|         R|     26|         2|       |          |\n"
"\n"
"\n"
"## Base 32 (extended hex) alphabet\n"
"\n"
"    | Value | Encoding | Value | Encoding | Value | Encoding | Value | Encoding |\n"
"    |------:|---------:|------:|---------:|------:|---------:|------:|---------:|\n"
"    |      0|         0|      9|         9|     18|         I|     27|         R|\n"
"    |      1|         1|     10|         A|     19|         J|     28|         S|\n"
"    |      2|         2|     11|         B|     20|         K|     29|         T|\n"
"    |      3|         3|     12|         C|     21|         L|     30|         U|\n"
"    |      4|         4|     13|         D|     22|         M|     31|         V|\n"
"    |      5|         5|     14|         E|     23|         N|       |          |\n"
"    |      6|         6|     15|         F|     24|         O|  (pad)|         =|\n"
"    |      7|         7|     16|         G|     25|         P|       |          |\n"
"    |      8|         8|     17|         H|     26|         Q|       |          |\n"
"\n"
"## Base 64 alphabet\n"
"\n"
"    | Value | Encoding | Value | Encoding | Value | Encoding | Value | Encoding |\n"
"    |------:|---------:|------:|---------:|------:|---------:|------:|---------:|\n"
"    |      0|         A|     17|         R|     34|         i|     51|         z|\n"
"    |      1|         B|     18|         S|     35|         j|     52|         0|\n"
"    |      2|         C|     19|         T|     36|         k|     53|         1|\n"
"    |      3|         D|     20|         U|     37|         l|     54|         2|\n"
"    |      4|         E|     21|         V|     38|         m|     55|         3|\n"
"    |      5|         F|     22|         W|     39|         n|     56|         4|\n"
"    |      6|         G|     23|         X|     40|         o|     57|         5|\n"
"    |      7|         H|     24|         Y|     41|         p|     58|         6|\n"
"    |      8|         I|     25|         Z|     42|         q|     59|         7|\n"
"    |      9|         J|     26|         a|     43|         r|     60|         8|\n"
"    |     10|         K|     27|         b|     44|         s|     61|         9|\n"
"    |     11|         L|     28|         c|     45|         t|     62|         +|\n"
"    |     12|         M|     29|         d|     46|         u|     63|         /|\n"
"    |     13|         N|     30|         e|     47|         v|       |          |\n"
"    |     14|         O|     31|         f|     48|         w|  (pad)|         =|\n"
"    |     15|         P|     32|         g|     49|         x|       |          |\n"
"    |     16|         Q|     33|         h|     50|         y|       |          |\n"
"\n"
"## Base 64 (URL and filename safe) alphabet\n"
"\n"
"    | Value | Encoding | Value | Encoding | Value | Encoding | Value | Encoding |\n"
"    |------:|---------:|------:|---------:|------:|---------:|------:|---------:|\n"
"    |      0|         A|     17|         R|     34|         i|     51|         z|\n"
"    |      1|         B|     18|         S|     35|         j|     52|         0|\n"
"    |      2|         C|     19|         T|     36|         k|     53|         1|\n"
"    |      3|         D|     20|         U|     37|         l|     54|         2|\n"
"    |      4|         E|     21|         V|     38|         m|     55|         3|\n"
"    |      5|         F|     22|         W|     39|         n|     56|         4|\n"
"    |      6|         G|     23|         X|     40|         o|     57|         5|\n"
"    |      7|         H|     24|         Y|     41|         p|     58|         6|\n"
"    |      8|         I|     25|         Z|     42|         q|     59|         7|\n"
"    |      9|         J|     26|         a|     43|         r|     60|         8|\n"
"    |     10|         K|     27|         b|     44|         s|     61|         9|\n"
"    |     11|         L|     28|         c|     45|         t|     62|         -|\n"
"    |     12|         M|     29|         d|     46|         u|     63|         _|\n"
"    |     13|         N|     30|         e|     47|         v|       |          |\n"
"    |     14|         O|     31|         f|     48|         w|  (pad)|         =|\n"
"    |     15|         P|     32|         g|     49|         x|       |          |\n"
"    |     16|         Q|     33|         h|     50|         y|       |          |\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.Path Summary
#: lib/path.ex:1 
msgid ""
"This module provides conveniences for manipulating or\n"
"retrieving file system paths.\n"
"\n"
"The functions in this module may receive a char data as\n"
"argument (i.e. a string or a list of characters / string)\n"
"and will always return a string (encoded in UTF-8).\n"
"\n"
"The majority of the functions in this module do not\n"
"interact with the file system, except for a few functions\n"
"that require it (like `wildcard/1` and `expand/1`).\n"
msgstr ""
#. TRANSLATORS: Elixir.StringIO Summary
#: lib/string_io.ex:1 
msgid ""
"This module provides an IO device that wraps a string.\n"
"\n"
"## Examples\n"
"\n"
"    iex> {:ok, pid} = StringIO.open(\"foo\")\n"
"    iex> IO.read(pid, 2)\n"
"    \"fo\"\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.OptionParser Summary
#: lib/option_parser.ex:1 
msgid ""
"This module contains functions to parse command line arguments.\n"
msgstr ""
#. TRANSLATORS: Elixir.File Summary
#: lib/file.ex:1 
msgid ""
"This module contains functions to manipulate files.\n"
"\n"
"Some of those functions are low-level, allowing the user\n"
"to interact with the file or IO devices, like `open/2`,\n"
"`copy/3` and others. This module also provides higher\n"
"level functions that work with filenames and have their naming\n"
"based on UNIX variants. For example, one can copy a file\n"
"via `cp/3` and remove files and directories recursively\n"
"via `rm_rf/1`\n"
"\n"
"## Encoding\n"
"\n"
"In order to write and read files, one must use the functions\n"
"in the `IO` module. By default, a file is opened in binary mode\n"
"which requires the functions `IO.binread/2` and `IO.binwrite/2`\n"
"to interact with the file. A developer may pass `:utf8` as an\n"
"option when opening the file, then the slower `IO.read/2` and\n"
"`IO.write/2` functions must be used as they are responsible for\n"
"doing the proper conversions and data guarantees.\n"
"\n"
"Note that filenames when given as char lists in Elixir are\n"
"always treated as UTF-8. In particular, we expect that the\n"
"shell and the operating system are configured to use UTF8\n"
"encoding. Binary filenames are considering raw and passed\n"
"to the OS as is.\n"
"\n"
"## API\n"
"\n"
"Most of the functions in this module return `:ok` or\n"
"`{:ok, result}` in case of success, `{:error, reason}`\n"
"otherwise. Those function are also followed by a variant\n"
"that ends with `!` which returns the result (without the\n"
"`{:ok, result}` tuple) in case of success or raises an\n"
"exception in case it fails. For example:\n"
"\n"
"    File.read(\"hello.txt\")\n"
"    #=> {:ok, \"World\"}\n"
"\n"
"    File.read(\"invalid.txt\")\n"
"    #=> {:error, :enoent}\n"
"\n"
"    File.read!(\"hello.txt\")\n"
"    #=> \"World\"\n"
"\n"
"    File.read!(\"invalid.txt\")\n"
"    #=> raises File.Error\n"
"\n"
"In general, a developer should use the former in case they want\n"
"to react if the file does not exist. The latter should be used\n"
"when the developer expects their software to fail in case the\n"
"file cannot be read (i.e. it is literally an exception).\n"
"\n"
"## Processes and raw files\n"
"\n"
"Every time a file is opened, Elixir spawns a new process. Writing\n"
"to a file is equivalent to sending messages to that process that\n"
"writes to the file descriptor.\n"
"\n"
"This means files can be passed between nodes and message passing\n"
"guarantees they can write to the same file in a network.\n"
"\n"
"However, you may not always want to pay the price for this abstraction.\n"
"In such cases, a file can be opened in `:raw` mode. The options `:read_ahead`\n"
"and `:delayed_write` are also useful when operating large files or\n"
"working with files in tight loops.\n"
"\n"
"Check http://www.erlang.org/doc/man/file.html#open-2 for more information\n"
"about such options and other performance considerations.\n"
msgstr ""
#. TRANSLATORS: def Kernel.CLI.main(argv)
#: lib/kernel/cli.ex:11 
msgid ""
"This is the API invoked by Elixir boot process.\n"
msgstr ""
#. TRANSLATORS: def Supervisor.terminate_child(supervisor, pid_or_child_id)
#: lib/supervisor.ex:295 
msgid ""
"Terminates the given pid or child id.\n"
"\n"
"If the supervisor is not a `simple_one_for_one`, the child id is expected\n"
"and the process, if there is one, is terminated; the child specification is\n"
"kept unless the child is temporary.\n"
"\n"
"In case of a `simple_one_for_one` supervisor, a pid is expected. If the child\n"
"specification identifier is given instead of a `pid`, the function will\n"
"return `{:error, :simple_one_for_one}`.\n"
"\n"
"A non-temporary child process may later be restarted by the supervisor. The child\n"
"process can also be restarted explicitly by calling `restart_child/2`. Use\n"
"`delete_child/2` to remove the child specification.\n"
"\n"
"If successful, the function returns `:ok`. If there is no child specification or\n"
"pid, the function returns `{:error, :not_found}`.\n"
msgstr ""
#. TRANSLATORS: Elixir.Inspect Summary
#: lib/inspect.ex:4 
msgid ""
"The `Inspect` protocol is responsible for converting any Elixir\n"
"data structure into an algebra document. This document is then\n"
"formatted, either in pretty printing format or a regular one.\n"
"\n"
"The `inspect/2` function receives the entity to be inspected\n"
"followed by the inspecting options, represented by the struct\n"
"`Inspect.Opts`.\n"
"\n"
"Inspection is done using the functions available in `Inspect.Algebra`.\n"
"\n"
"## Examples\n"
"\n"
"Many times, inspecting a structure can be implemented in function\n"
"of existing entities. For example, here is `HashSet`'s `inspect`\n"
"implementation:\n"
"\n"
"    defimpl Inspect, for: HashSet do\n"
"      import Inspect.Algebra\n"
"\n"
"      def inspect(dict, opts) do\n"
"        concat [\"#HashSet<\", to_doc(HashSet.to_list(dict), opts), \">\"]\n"
"      end\n"
"    end\n"
"\n"
"The `concat` function comes from `Inspect.Algebra` and it\n"
"concatenates algebra documents together. In the example above,\n"
"it is concatenating the string `\"HashSet<\"` (all strings are\n"
"valid algebra documents that keep their formatting when pretty\n"
"printed), the document returned by `Inspect.Algebra.to_doc/2` and the\n"
"other string `\">\"`.\n"
"\n"
"Since regular strings are valid entities in an algebra document,\n"
"an implementation of inspect may simply return a string,\n"
"although that will devoid it of any pretty-printing.\n"
"\n"
"## Error handling\n"
"\n"
"In case there is an error while your structure is being inspected,\n"
"Elixir will automatically fall back to a raw representation.\n"
"\n"
"You can however access the underlying error by invoking the Inspect\n"
"implementation directly. For example, to test Inspect.HashSet above,\n"
"you can invoke it as:\n"
"\n"
"    Inspect.HashSet.inspect(HashSet.new, Inspect.Opts.new)\n"
"\n"
msgstr ""
#. TRANSLATORS: def Task.__struct__()
#: lib/task.ex:102 
msgid ""
"The Task struct.\n"
"\n"
"It contains two fields:\n"
"\n"
"  * `:pid` - the process reference of the task process; it may be a pid\n"
"    or a tuple containing the process and node names\n"
"\n"
"  * `:ref` - the task monitor reference\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.System Summary
#: lib/system.ex:1 
msgid ""
"The System module provides access to variables used or\n"
"maintained by the VM and to functions that interact directly\n"
"with the VM or the host system.\n"
msgstr ""
#. TRANSLATORS: Elixir.String.Chars Summary
#: lib/string/chars.ex:3 
msgid ""
"The String.Chars protocol is responsible for\n"
"converting a structure to a Binary (only if applicable).\n"
"The only function required to be implemented is\n"
"`to_string` which does the conversion.\n"
"\n"
"The `to_string` function automatically imported\n"
"by Kernel invokes this protocol. String\n"
"interpolation also invokes to_string in its\n"
"arguments. For example, `\"foo#{bar}\"` is the same\n"
"as `\"foo\" <> to_string(bar)`.\n"
msgstr ""
#. TRANSLATORS: Elixir.List.Chars Summary
#: lib/list/chars.ex:1 
msgid ""
"The List.Chars protocol is responsible for\n"
"converting a structure to a list (only if applicable).\n"
"The only function required to be implemented is\n"
"`to_char_list` which does the conversion.\n"
"\n"
"The `to_char_list` function automatically imported\n"
"by Kernel invokes this protocol.\n"
msgstr ""
#. TRANSLATORS: Elixir.Access Summary
#: lib/access.ex:1 
msgid ""
"The Access protocol is used by `foo[bar]` and also\n"
"empowers the nested update functions in Kernel.\n"
"\n"
"For instance, `foo[bar]` translates `Access.get(foo, bar)`.\n"
"`Kernel.get_in/2`, `Kernel.put_in/3`, `Kernel.update_in/3` and\n"
"`Kernel.get_and_update_in/3` are also all powered by the Access\n"
"protocol.\n"
"\n"
"This protocol is implemented by default for keywords, maps\n"
"and dictionary like types:\n"
"\n"
"    iex> keywords = [a: 1, b: 2]\n"
"    iex> keywords[:a]\n"
"    1\n"
"\n"
"    iex> map = %{a: 1, b: 2}\n"
"    iex> map[:a]\n"
"    1\n"
"\n"
"    iex> star_ratings = %{1.0 => \"â˜…\", 1.5 => \"â˜…â˜†\", 2.0 => \"â˜…â˜…\"}\n"
"    iex> star_ratings[1.5]\n"
"    \"â˜…â˜†\"\n"
"\n"
"The key comparison must be implemented using the `===` operator.\n"
msgstr ""
#. TRANSLATORS: def GenEvent.stop(manager)
#: lib/gen_event.ex:510 
msgid ""
"Terminates the event `manager`.\n"
"\n"
"Before terminating, the event manager will call `terminate(:stop, ...)`\n"
"for each installed event handler.\n"
msgstr ""
#. TRANSLATORS: def GenEvent.start_link(options \\ [])
#: lib/gen_event.ex:252 
msgid ""
"Starts an event manager linked to the current process.\n"
"\n"
"This is often used to start the `GenEvent` as part of a supervision tree.\n"
"\n"
"It accepts the `:name` option which is described under the `Name Registration`\n"
"section in the `GenServer` module docs.\n"
"\n"
"If the event manager is successfully created and initialized, the function\n"
"returns `{:ok, pid}`, where pid is the pid of the server. If there already\n"
"exists a process with the specified server name, the function returns\n"
"`{:error, {:already_started, pid}}` with the pid of that process.\n"
"\n"
"Note that a `GenEvent` started with `start_link/1` is linked to the\n"
"parent process and will exit not only on crashes but also if the parent\n"
"process exits with `:normal` reason.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.update_in(path, fun)
#: lib/kernel.ex:1729 
msgid ""
"Updates a nested structure via the given `path`.\n"
"\n"
"This is similar to `update_in/3`, except the path is extracted via\n"
"a macro rather than passing a list. For example:\n"
"\n"
"    update_in(opts[:foo][:bar], &(&1 + 1))\n"
"\n"
"Is equivalent to:\n"
"\n"
"    update_in(opts, [:foo, :bar], &(&1 + 1))\n"
"\n"
"Note that in order for this macro to work, the complete path must always\n"
"be visible by this macro. For more information about the supported path\n"
"expressions, please check `get_and_update_in/2` docs.\n"
"\n"
"## Examples\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> update_in(users[\"john\"][:age], &(&1 + 1))\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> update_in(users[\"john\"].age, &(&1 + 1))\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.update_in(data, keys, fun)
#: lib/kernel.ex:1607 
msgid ""
"Updates a key in a nested structure.\n"
"\n"
"Uses the `Access` protocol to traverse the structures\n"
"according to the given `keys`, unless the `key` is a\n"
"function. If the key is a function, it will be invoked\n"
"as specified in `get_and_update_in/3`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> update_in(users, [\"john\", :age], &(&1 + 1))\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"In case any of entries in the middle returns `nil`,\n"
"an error will be raised when trying to access it next.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.unquote_splicing(expr)
#: lib/kernel/special_forms.ex:1127 
msgid ""
"Unquotes the given list expanding its arguments. Similar\n"
"to unquote.\n"
"\n"
"## Examples\n"
"\n"
"    values = [2, 3, 4]\n"
"    quote do: sum(1, unquote_splicing(values), 5)\n"
"    #=> {:sum, [], [1, 2, 3, 4, 5]}\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.unquote(expr)
#: lib/kernel/special_forms.ex:1114 
msgid ""
"Unquotes the given expression from inside a macro.\n"
"\n"
"## Examples\n"
"\n"
"Imagine the situation you have a variable `value` and\n"
"you want to inject it inside some quote. The first attempt\n"
"would be:\n"
"\n"
"    value = 13\n"
"    quote do: sum(1, value, 3)\n"
"\n"
"Which would then return:\n"
"\n"
"    {:sum, [], [1, {:value, [], quoted}, 3]}\n"
"\n"
"Which is not the expected result. For this, we use unquote:\n"
"\n"
"    value = 13\n"
"    quote do: sum(1, unquote(value), 3)\n"
"    #=> {:sum, [], [1, 13, 3]}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Macro.unescape_tokens(tokens, map)
#: lib/macro.ex:438 
msgid ""
"Unescape the given tokens according to the given map.\n"
"\n"
"Check `unescape_tokens/1` and `unescape_string/2` for more information.\n"
msgstr ""
#. TRANSLATORS: def Macro.unescape_tokens(tokens)
#: lib/macro.ex:428 
msgid ""
"Unescape the given tokens according to the default map.\n"
"\n"
"Check `unescape_string/1` and `unescape_string/2` for more\n"
"information about unescaping.\n"
"\n"
"Only tokens that are binaries are unescaped, all others are\n"
"ignored. This function is useful when implementing your own\n"
"sigils. Check the implementation of `Kernel.sigil_s/2`\n"
"for examples.\n"
msgstr ""
#. TRANSLATORS: def Macro.unescape_string(chars)
#: lib/macro.ex:368 
msgid ""
"Unescape the given chars.\n"
"\n"
"This is the unescaping behaviour used by default in Elixir\n"
"single- and double-quoted strings. Check `unescape_string/2`\n"
"for information on how to customize the escaping map.\n"
"\n"
"In this setup, Elixir will escape the following: `\\0`, `\\a`, `\\b`,\n"
"`\\d`, `\\e`, `\\f`, `\\n`, `\\r`, `\\s`, `\\t` and `\\v`. Hexadecimals\n"
"are also supported via `\\xNN` and `\\x{NN...}` syntax.\n"
"\n"
"This function is commonly used on sigil implementations\n"
"(like `~r`, `~s` and others) which receive a raw, unescaped\n"
"string.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Macro.unescape_string(\"example\\\\n\")\n"
"    \"example\\n\"\n"
"\n"
"In the example above, we pass a string with `\\n` escaped\n"
"and return a version with it unescaped.\n"
msgstr ""
#. TRANSLATORS: def Macro.unescape_string(chars, map)
#: lib/macro.ex:412 
msgid ""
"Unescape the given chars according to the map given.\n"
"\n"
"Check `unescape_string/1` if you want to use the same map\n"
"as Elixir single- and double-quoted strings.\n"
"\n"
"## Map\n"
"\n"
"The map must be a function. The function receives an integer\n"
"representing the codepoint of the character it wants to unescape.\n"
"Here is the default mapping function implemented by Elixir:\n"
"\n"
"    def unescape_map(?0), do: ?0\n"
"    def unescape_map(?a), do: ?\\a\n"
"    def unescape_map(?b), do: ?\\b\n"
"    def unescape_map(?d), do: ?\\d\n"
"    def unescape_map(?e), do: ?\\e\n"
"    def unescape_map(?f), do: ?\\f\n"
"    def unescape_map(?n), do: ?\\n\n"
"    def unescape_map(?r), do: ?\\r\n"
"    def unescape_map(?s), do: ?\\s\n"
"    def unescape_map(?t), do: ?\\t\n"
"    def unescape_map(?v), do: ?\\v\n"
"    def unescape_map(?x), do: true\n"
"    def unescape_map(e),  do: e\n"
"\n"
"If the `unescape_map` function returns `false`. The char is\n"
"not escaped and `\\` is kept in the char list.\n"
"\n"
"Hexadecimals will be escaped if the map function returns `true`\n"
"for `?x`.\n"
"\n"
"## Examples\n"
"\n"
"Using the `unescape_map` function defined above is easy:\n"
"\n"
"    Macro.unescape_string \"example\\\\n\", &unescape_map(&1)\n"
"\n"
msgstr ""
#. TRANSLATORS: def Task.Supervisor.terminate_child(supervisor, pid)
#: lib/task/supervisor.ex:78 
msgid ""
"Terminates the child with the given `pid`.\n"
msgstr ""
#. TRANSLATORS: def URI.query_decoder(q)
#: lib/uri.ex:116 
msgid ""
"Returns an iterator function over the query string that decodes\n"
"the query string in steps.\n"
"\n"
"## Examples\n"
"\n"
"    iex> URI.query_decoder(\"foo=1&bar=2\") |> Enum.map &(&1)\n"
"    [{\"foo\", \"1\"}, {\"bar\", \"2\"}]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Dict.split(dict, keys)
#: lib/dict.ex:589 
msgid ""
"Returns a tuple of two dicts, where the first dict contains only\n"
"entries from `dict` with keys in `keys`, and the second dict\n"
"contains only entries from `dict` with keys not in `keys`.\n"
"\n"
"All non-member keys are ignored.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2, c: 3, d: 4], dict_impl.new)\n"
"    iex> {dict1, dict2} = Dict.split(dict, [:a, :c, :e])\n"
"    iex> {Dict.to_list(dict1) |> Enum.sort, Dict.to_list(dict2) |> Enum.sort}\n"
"    {[a: 1, c: 3], [b: 2, d: 4]}\n"
"\n"
"    iex> dict = Enum.into([], dict_impl.new)\n"
"    iex> {dict1, dict2} = Dict.split(dict, [:a, :c])\n"
"    iex> {Dict.to_list(dict1), Dict.to_list(dict2)}\n"
"    {[], []}\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> {dict1, dict2} = Dict.split(dict, [:a, :b, :c])\n"
"    iex> {Dict.to_list(dict1) |> Enum.sort, Dict.to_list(dict2)}\n"
"    {[a: 1, b: 2], []}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Dict.drop(dict, keys)
#: lib/dict.ex:611 
msgid ""
"Returns a new dict where the given `keys` are removed from `dict`.\n"
"All non-member keys are ignored.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.drop(dict, [:a, :c, :d])\n"
"    iex> Dict.to_list(dict)\n"
"    [b: 2]\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.drop(dict, [:c, :d])\n"
"    iex> Dict.to_list(dict) |> Enum.sort\n"
"    [a: 1, b: 2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def String.to_integer(string, base)
#: lib/string.ex:1414 
msgid ""
"Returns an integer whose text representation is `string` in base `base`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.to_integer(\"3FF\", 16)\n"
"    1023\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.to_integer(char_list)
#: lib/list.ex:500 
msgid ""
"Returns an integer whose text representation is `char_list`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.to_integer('123')\n"
"    123\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.to_integer(char_list, base)
#: lib/list.ex:516 
msgid ""
"Returns an integer whose text representation is `char_list` in base `base`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.to_integer('3FF', 16)\n"
"    1023\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.trunc(number)
#: lib/kernel.ex:731 
msgid ""
"Returns an integer by truncating the given number.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> trunc(5.5)\n"
"    5\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.round(number)
#: lib/kernel.ex:542 
msgid ""
"Returns an integer by rounding the given number.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> round(5.5)\n"
"    6\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.values(keywords)
#: lib/keyword.ex:217 
msgid ""
"Returns all values from the keyword list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.values([a: 1, b: 2])\n"
"    [1,2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.new()
#: lib/keyword.ex:51 
msgid ""
"Returns an empty keyword list, i.e. an empty list.\n"
msgstr ""
#. TRANSLATORS: def Kernel.node()
#: lib/kernel.ex:496 
msgid ""
"Returns an atom representing the name of the local node.\n"
"If the node is not alive, `:nonode@nohost` is returned instead.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Kernel.make_ref()
#: lib/kernel.ex:437 
msgid ""
"Returns an almost unique reference.\n"
"\n"
"The returned reference will re-occur after approximately 2^82 calls;\n"
"therefore it is unique enough for practical purposes.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    make_ref() #=> #Reference<0.0.0.135>\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.Typespec.beam_types(module)
#: lib/kernel/typespec.ex:427 
msgid ""
"Returns all types available from the module's beam code.\n"
"\n"
"The result is returned as a list of tuples where the first\n"
"element is the type (`:typep`, `:type` and `:opaque`).\n"
"\n"
"The module must have a corresponding beam file which can be\n"
"located by the runtime system.\n"
msgstr ""
#. TRANSLATORS: def Kernel.Typespec.beam_typedocs(module)
#: lib/kernel/typespec.ex:407 
msgid ""
"Returns all type docs available from the module's beam code.\n"
"\n"
"The result is returned as a list of tuples where the first element is the pair of type\n"
"name and arity and the second element is the documentation.\n"
"\n"
"The module must have a corresponding beam file which can be\n"
"located by the runtime system.\n"
msgstr ""
#. TRANSLATORS: def Kernel.Typespec.beam_specs(module)
#: lib/kernel/typespec.ex:455 
msgid ""
"Returns all specs available from the module's beam code.\n"
"\n"
"The result is returned as a list of tuples where the first\n"
"element is spec name and arity and the second is the spec.\n"
"\n"
"The module must have a corresponding beam file which can be\n"
"located by the runtime system.\n"
msgstr ""
#. TRANSLATORS: def Macro.Env.stacktrace(env)
#: lib/macro/env.ex:121 
msgid ""
"Returns the environment stacktrace.\n"
msgstr ""
#. TRANSLATORS: def Path.dirname(path)
#: lib/path.ex:373 
msgid ""
"Returns the directory component of `path`.\n"
"\n"
"## Examples\n"
"\n"
"    Path.dirname(\"/foo/bar.ex\")\n"
"    #=> \"/foo\"\n"
"    Path.dirname(\"/foo/bar/baz.ex\")\n"
"    #=> \"/foo/bar\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def URI.default_port(scheme)
#: lib/uri.ex:27 
msgid ""
"Returns the default port for a given scheme.\n"
"\n"
"If the scheme is unknown to URI, returns `nil`.\n"
"Any scheme may be registered via `default_port/2`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> URI.default_port(\"ftp\")\n"
"    21\n"
"\n"
"    iex> URI.default_port(\"ponzi\")\n"
"    nil\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.LexicalTracker.remotes(arg)
#: lib/kernel/lexical_tracker.ex:20 
msgid ""
"Returns all remotes linked to in this lexical scope.\n"
msgstr ""
#. TRANSLATORS: def Module.LocalsTracker.reachable(ref)
#: lib/module/locals_tracker.ex:67 
msgid ""
"Returns all locals that are reachable.\n"
"\n"
"By default, all public functions are reachable.\n"
"A private function is only reachable if it has\n"
"a public function that it invokes directly.\n"
msgstr ""
#. TRANSLATORS: def Process.get_keys(value)
#: lib/process.ex:54 
msgid ""
"Returns all keys that have the given `value`.\n"
msgstr ""
#. TRANSLATORS: def Keyword.keys(keywords)
#: lib/keyword.ex:203 
msgid ""
"Returns all keys from the keyword list. \n"
"\n"
"Duplicated keys appear duplicated in the final list of keys.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.keys([a: 1, b: 2])\n"
"    [:a,:b]\n"
"\n"
"    iex> Keyword.keys([a: 1, b: 2, a: 3])\n"
"    [:a,:b,:a]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Process.get()
#: lib/process.ex:32 
msgid ""
"Returns all key-values in the dictionary.\n"
msgstr ""
#. TRANSLATORS: def Application.get_all_env(app)
#: lib/application.ex:118 
msgid ""
"Returns all key-value pairs for `app`.\n"
msgstr ""
#. TRANSLATORS: def Module.LocalsTracker.imports_with_dispatch(ref, arg2)
#: lib/module/locals_tracker.ex:54 
msgid ""
"Returns all imported modules that had the given\n"
"`{name, arity}` invoked.\n"
msgstr ""
#. TRANSLATORS: def Node.self()
#: lib/node.ex:44 
msgid ""
"Returns the current node.\n"
"\n"
"It returns the same as the built-in `node()`.\n"
msgstr ""
#. TRANSLATORS: def Stream.repeatedly(generator_fun)
#: lib/stream.ex:969 
msgid ""
"Returns a stream generated by calling `generator_fun` repeatedly.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.repeatedly(&:random.uniform/0) |> Enum.take(3)\n"
"    [0.4435846174457203, 0.7230402056221108, 0.94581636451987]\n"
"\n"
msgstr ""
#. TRANSLATORS: def String.slice(string, start, len)
#: lib/string.ex:1073 
msgid ""
"Returns a substring starting at the offset given by the first, and\n"
"a length given by the second.\n"
"\n"
"If the offset is greater than string length, then it returns `\"\"`.\n"
"\n"
"Remember this function works with unicode codepoints and consider\n"
"the slices to represent codepoints offsets. If you want to split\n"
"on raw bytes, check `Kernel.binary_part/3` instead.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.slice(\"elixir\", 1, 3)\n"
"    \"lix\"\n"
"\n"
"    iex> String.slice(\"elixir\", 1, 10)\n"
"    \"lixir\"\n"
"\n"
"    iex> String.slice(\"elixir\", 10, 3)\n"
"    \"\"\n"
"\n"
"    iex> String.slice(\"elixir\", -4, 4)\n"
"    \"ixir\"\n"
"\n"
"    iex> String.slice(\"elixir\", -10, 3)\n"
"    \"\"\n"
"\n"
"    iex> String.slice(\"a\", 0, 1500)\n"
"    \"a\"\n"
"\n"
"    iex> String.slice(\"a\", 1, 1500)\n"
"    \"\"\n"
"\n"
"    iex> String.slice(\"a\", 2, 1500)\n"
"    \"\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def String.slice(string, range)
#: lib/string.ex:1151 
msgid ""
"Returns a substring from the offset given by the start of the\n"
"range to the offset given by the end of the range.\n"
"\n"
"If the start of the range is not a valid offset for the given\n"
"string or if the range is in reverse order, returns `\"\"`.\n"
"\n"
"If the start or end of the range are negative, the whole string\n"
"is traversed first in order to convert the negative indexes into\n"
"positive ones.\n"
"\n"
"Remember this function works with unicode codepoints and consider\n"
"the slices to represent codepoints offsets. If you want to split\n"
"on raw bytes, check `Kernel.binary_part/3` instead.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.slice(\"elixir\", 1..3)\n"
"    \"lix\"\n"
"\n"
"    iex> String.slice(\"elixir\", 1..10)\n"
"    \"lixir\"\n"
"\n"
"    iex> String.slice(\"elixir\", 10..3)\n"
"    \"\"\n"
"\n"
"    iex> String.slice(\"elixir\", -4..-1)\n"
"    \"ixir\"\n"
"\n"
"    iex> String.slice(\"elixir\", 2..-1)\n"
"    \"ixir\"\n"
"\n"
"    iex> String.slice(\"elixir\", -4..6)\n"
"    \"ixir\"\n"
"\n"
"    iex> String.slice(\"elixir\", -1..-4)\n"
"    \"\"\n"
"\n"
"    iex> String.slice(\"elixir\", -10..-7)\n"
"    \"\"\n"
"\n"
"    iex> String.slice(\"a\", 0..1500)\n"
"    \"a\"\n"
"\n"
"    iex> String.slice(\"a\", 1..1500)\n"
"    \"\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.slice(coll, start, count)
#: lib/enum.ex:1447 
msgid ""
"Returns a subset list of the given collection. Drops elements\n"
"until element position `start`, then takes `count` elements.\n"
"\n"
"If the count is greater than collection length, it returns as\n"
"much as possible. If zero, then it returns `[]`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.slice(1..100, 5, 10)\n"
"    [6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n"
"\n"
"    iex> Enum.slice(1..10, 5, 100)\n"
"    [6, 7, 8, 9, 10]\n"
"\n"
"    iex> Enum.slice(1..10, 5, 0)\n"
"    []\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.slice(coll, arg2)
#: lib/enum.ex:1506 
msgid ""
"Returns a subset list of the given collection. Drops elements\n"
"until element position `range.first`, then takes elements until element\n"
"position `range.last` (inclusive).\n"
"\n"
"Positions are calculated by adding the number of items in the collection to\n"
"negative positions (so position -3 in a collection with count 5 becomes\n"
"position 2).\n"
"\n"
"The first position (after adding count to negative positions) must be smaller\n"
"or equal to the last position.\n"
"\n"
"If the start of the range is not a valid offset for the given\n"
"collection or if the range is in reverse order, returns `[]`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.slice(1..100, 5..10)\n"
"    [6, 7, 8, 9, 10, 11]\n"
"\n"
"    iex> Enum.slice(1..10, 5..20)\n"
"    [6, 7, 8, 9, 10]\n"
"\n"
"    iex> Enum.slice(1..10, 11..20)\n"
"    []\n"
"\n"
"    iex> Enum.slice(1..10, 6..5)\n"
"    []\n"
"\n"
msgstr ""
#. TRANSLATORS: def String.rstrip(string, char)
#: lib/string.ex:472 
msgid ""
"Returns a string where trailing `char` have been removed.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.rstrip(\"   abc _\", ?_)\n"
"    \"   abc \"\n"
"\n"
msgstr ""
#. TRANSLATORS: def String.rstrip(binary)
#: lib/string.ex:459 
msgid ""
"Returns a string where trailing Unicode whitespace\n"
"has been removed.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.rstrip(\"   abc  \")\n"
"    \"   abc\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def String.strip(string, char)
#: lib/string.ex:561 
msgid ""
"Returns a string where leading/trailing `char` have been\n"
"removed.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.strip(\"a  abc  a\", ?a)\n"
"    \"  abc  \"\n"
"\n"
msgstr ""
#. TRANSLATORS: def String.strip(string)
#: lib/string.ex:545 
msgid ""
"Returns a string where leading/trailing Unicode whitespace\n"
"has been removed.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.strip(\"   abc  \")\n"
"    \"abc\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def String.lstrip(other, char)
#: lib/string.ex:525 
msgid ""
"Returns a string where leading `char` have been removed.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.lstrip(\"_  abc  _\", ?_)\n"
"    \"  abc  _\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def String.lstrip(binary)
#: lib/string.ex:511 
msgid ""
"Returns a string where leading Unicode whitespace\n"
"has been removed.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.lstrip(\"   abc  \")\n"
"    \"abc  \"\n"
"\n"
msgstr ""
#. TRANSLATORS: def GenEvent.stream(manager, options \\ [])
#: lib/gen_event.ex:295 
msgid ""
"Returns a stream that consumes events from the `manager`.\n"
"\n"
"The stream is a `GenEvent` struct that implements the `Enumerable`\n"
"protocol. Consumption of events only begins when enumeration starts.\n"
"\n"
"Note streaming is specific to Elixir's GenEvent and does not work\n"
"with Erlang ones.\n"
"\n"
"## Options\n"
"\n"
"  * `:timeout` - raises if no event arrives in X milliseconds\n"
"    (defaults to `:infinity`)\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel...(first, last)
#: lib/kernel.ex:2251 
msgid ""
"Returns a range with the specified start and end.\n"
"Includes both ends.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 0 in 1..3\n"
"    false\n"
"\n"
"    iex> 1 in 1..3\n"
"    true\n"
"\n"
"    iex> 2 in 1..3\n"
"    true\n"
"\n"
"    iex> 3 in 1..3\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: def Set.difference(set1, set2)
#: lib/set.ex:92 
msgid ""
"Returns a set that is `set1` without the members of `set2`.\n"
"\n"
"Notice this function is polymorphic as it calculates the difference\n"
"for of any type. Each set implementation also provides a `difference`\n"
"function, but they can only work with sets of the same type.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Set.difference(Enum.into([1,2], set_impl.new), Enum.into([2,3,4], set_impl.new)) |> Enum.sort\n"
"    [1]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Set.intersection(set1, set2)
#: lib/set.ex:194 
msgid ""
"Returns a set containing only members in common between `set1` and `set2`.\n"
"\n"
"Notice this function is polymorphic as it calculates the intersection of\n"
"any type. Each set implementation also provides a `intersection` function,\n"
"but they can only work with sets of the same type.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Set.intersection(Enum.into([1,2], set_impl.new), Enum.into([2,3,4], set_impl.new)) |> Enum.sort\n"
"    [2]\n"
"\n"
"    iex> Set.intersection(Enum.into([1,2], set_impl.new), Enum.into([3,4], set_impl.new)) |> Enum.sort\n"
"    []\n"
"\n"
msgstr ""
#. TRANSLATORS: def Dict.take(dict, keys)
#: lib/dict.ex:632 
msgid ""
"Returns a new dict where only the keys in `keys` from `dict` are included.\n"
"\n"
"All non-member keys are ignored.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.take(dict, [:a, :c, :d])\n"
"    iex> Dict.to_list(dict)\n"
"    [a: 1]\n"
"    iex> dict = Dict.take(dict, [:c, :d])\n"
"    iex> Dict.to_list(dict)\n"
"    []\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.map(collection, fun)
#: lib/enum.ex:976 
msgid ""
"Returns a new collection, where each item is the result\n"
"of invoking `fun` on each corresponding item of `collection`.\n"
"\n"
"For dicts, the function expects a key-value tuple.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.map([1, 2, 3], fn(x) -> x * 2 end)\n"
"    [2, 4, 6]\n"
"\n"
"    iex> Enum.map([a: 1, b: 2], fn({k, v}) -> {k, -v} end)\n"
"    [a: -1, b: -2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.flat_map(collection, fun)
#: lib/enum.ex:791 
msgid ""
"Returns a new collection appending the result of invoking `fun`\n"
"on each corresponding item of `collection`.\n"
"\n"
"The given function should return an enumerable.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.flat_map([:a, :b, :c], fn(x) -> [x, x] end)\n"
"    [:a, :a, :b, :b, :c, :c]\n"
"\n"
"    iex> Enum.flat_map([{1,3}, {4,6}], fn({x,y}) -> x..y end)\n"
"    [1, 2, 3, 4, 5, 6]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enumerable.count(collection)
#: lib/enum.ex:140 
msgid ""
"Retrieves the collection's size.\n"
"\n"
"It should return `{:ok, size}`.\n"
"\n"
"If `{:error, __MODULE__}` is returned a default algorithm using `reduce` and\n"
"the match (`===`) operator is used. This algorithm runs in linear time.\n"
"\n"
"Please force use of the default algorithm unless you can implement an\n"
"algorithm that is significantly faster.\n"
msgstr ""
#. TRANSLATORS: def Set.union(set1, set2)
#: lib/set.ex:311 
msgid ""
"Returns a set containing all members of `set1` and `set2`.\n"
"\n"
"Notice this function is polymorphic as it calculates the union of\n"
"any type. Each set implementation also provides a `union` function,\n"
"but they can only work with sets of the same type.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Set.union(Enum.into([1,2], set_impl.new), Enum.into([2,3,4], set_impl.new)) |> Enum.sort\n"
"    [1,2,3,4]\n"
"\n"
msgstr ""
#. TRANSLATORS: def String.rjust(subject, len, pad \\ 32)
#: lib/string.ex:583 
msgid ""
"Returns a new string of length `len` with `subject` right justified and\n"
"padded with `padding`. If `padding` is not present, it defaults to\n"
"whitespace. When `len` is less than the length of `subject`, `subject` is\n"
"returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.rjust(\"abc\", 5)\n"
"    \"  abc\"\n"
"\n"
"    iex> String.rjust(\"abc\", 5, ?-)\n"
"    \"--abc\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def String.ljust(subject, len, pad \\ 32)
#: lib/string.ex:604 
msgid ""
"Returns a new string of length `len` with `subject` left justified and padded\n"
"with `padding`. If `padding` is not present, it defaults to whitespace. When\n"
"`len` is less than the length of `subject`, `subject` is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.ljust(\"abc\", 5)\n"
"    \"abc  \"\n"
"\n"
"    iex> String.ljust(\"abc\", 5, ?-)\n"
"    \"abc--\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.new()
#: lib/map.ex:23 
msgid ""
"Returns a new empty map.\n"
msgstr ""
#. TRANSLATORS: def String.replace(subject, pattern, replacement, options \\ [])
#: lib/string.ex:665 
msgid ""
"Returns a new binary based on `subject` by replacing the parts\n"
"matching `pattern` by `replacement`. By default, it replaces\n"
"all entries, except if the `global` option is set to `false`.\n"
"\n"
"A `pattern` may be a string or a regex.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.replace(\"a,b,c\", \",\", \"-\")\n"
"    \"a-b-c\"\n"
"\n"
"    iex> String.replace(\"a,b,c\", \",\", \"-\", global: false)\n"
"    \"a-b,c\"\n"
"\n"
"The pattern can also be a regex. In those cases, one can give `\\N`\n"
"in the `replacement` string to access a specific capture in the regex:\n"
"\n"
"    iex> String.replace(\"a,b,c\", ~r/,(.)/, \",\\\\1\\\\1\")\n"
"    \"a,bb,cc\"\n"
"\n"
"Notice we had to escape the escape character `\\`. By giving `&`,\n"
"one can inject the whole matched pattern in the replacement string.\n"
"\n"
"When strings are used as a pattern, a developer can also use the\n"
"replaced part inside the `replacement` via the `:insert_replaced` option:\n"
"\n"
"    iex> String.replace(\"a,b,c\", \"b\", \"[]\", insert_replaced: 1)\n"
"    \"a,[b],c\"\n"
"\n"
"    iex> String.replace(\"a,b,c\", \",\", \"[]\", insert_replaced: 2)\n"
"    \"a[],b[],c\"\n"
"\n"
"    iex> String.replace(\"a,b,c\", \",\", \"[]\", insert_replaced: [1, 1])\n"
"    \"a[,,]b[,,]c\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Supervisor.which_children(supervisor)
#: lib/supervisor.ex:372 
msgid ""
"Returns a list with information about all children.\n"
"\n"
"Note that calling this function when supervising a large number of children\n"
"under low memory conditions can cause an out of memory exception.\n"
"\n"
"This function returns a list of tuples containing:\n"
"\n"
"  * `id` - as defined in the child specification or `:undefined` in the case\n"
"    of a `simple_one_for_one` supervisor\n"
"\n"
"  * `child` - the pid of the corresponding child process, the atom\n"
"    `:restarting` if the process is about to be restarted, or `:undefined` if\n"
"    there is no such process\n"
"\n"
"  * `type` - `:worker` or `:supervisor` as defined in the child specification\n"
"\n"
"  * `modules` â€“ as defined in the child specification\n"
msgstr ""
#. TRANSLATORS: def Supervisor.count_children(supervisor)
#: lib/supervisor.ex:396 
msgid ""
"Returns a map containing count values for the supervisor.\n"
"\n"
"The map contains the following keys:\n"
"\n"
"  * `:specs` - the total count of children, dead or alive\n"
"\n"
"  * `:active` - the count of all actively running child processes managed by\n"
"    this supervisor\n"
"\n"
"  * `:supervisors` - the count of all supervisors whether or not the child\n"
"    process is still alive\n"
"\n"
"  * `:workers` - the count of all workers, whether or not the child process\n"
"    is still alive\n"
"\n"
msgstr ""
#. TRANSLATORS: def Inspect.Algebra.group(d)
#: lib/inspect/algebra.ex:344 
msgid ""
"Returns a group containing the specified document.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.group(\n"
"    ...>   Inspect.Algebra.concat(\n"
"    ...>     Inspect.Algebra.group(\n"
"    ...>       Inspect.Algebra.concat(\n"
"    ...>         \"Hello,\",\n"
"    ...>         Inspect.Algebra.concat(\n"
"    ...>           Inspect.Algebra.break,\n"
"    ...>           \"A\"\n"
"    ...>         )\n"
"    ...>       )\n"
"    ...>     ),\n"
"    ...>     Inspect.Algebra.concat(\n"
"    ...>       Inspect.Algebra.break,\n"
"    ...>       \"B\"\n"
"    ...>     )\n"
"    ...> ))\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"Hello,\", \" \", \"A\", \" \", \"B\"]\n"
"    iex> Inspect.Algebra.format(doc, 6)\n"
"    [\"Hello,\", \"\\n\", \"A\", \" \", \"B\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.update_at(list, index, fun)
#: lib/list.ex:406 
msgid ""
"Returns a list with an updated value at the specified `index`.\n"
"Negative indices indicate an offset from the end of the list.\n"
"If `index` is out of bounds, the original `list` is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.update_at([1, 2, 3], 0, &(&1 + 10))\n"
"    [11, 2, 3]\n"
"\n"
"    iex> List.update_at([1, 2, 3], 10, &(&1 + 10))\n"
"    [1, 2, 3]\n"
"\n"
"    iex> List.update_at([1, 2, 3], -1, &(&1 + 10))\n"
"    [1, 2, 13]\n"
"\n"
"    iex> List.update_at([1, 2, 3], -10, &(&1 + 10))\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.replace_at(list, index, value)
#: lib/list.ex:377 
msgid ""
"Returns a list with a replaced value at the specified `index`.\n"
"Negative indices indicate an offset from the end of the list.\n"
"If `index` is out of bounds, the original `list` is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.replace_at([1, 2, 3], 0, 0)\n"
"    [0, 2, 3]\n"
"\n"
"    iex> List.replace_at([1, 2, 3], 10, 0)\n"
"    [1, 2, 3]\n"
"\n"
"    iex> List.replace_at([1, 2, 3], -1, 0)\n"
"    [1, 2, 0]\n"
"\n"
"    iex> List.replace_at([1, 2, 3], -10, 0)\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.insert_at(list, index, value)
#: lib/list.ex:348 
msgid ""
"Returns a list with `value` inserted at the specified `index`.\n"
"Note that `index` is capped at the list length. Negative indices\n"
"indicate an offset from the end of the list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.insert_at([1, 2, 3, 4], 2, 0)\n"
"    [1, 2, 0, 3, 4]\n"
"\n"
"    iex> List.insert_at([1, 2, 3], 10, 0)\n"
"    [1, 2, 3, 0]\n"
"\n"
"    iex> List.insert_at([1, 2, 3], -1, 0)\n"
"    [1, 2, 3, 0]\n"
"\n"
"    iex> List.insert_at([1, 2, 3], -10, 0)\n"
"    [0, 1, 2, 3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Collectable.into(collectable)
#: lib/collectable.ex:46 
msgid ""
"Returns a function that collects values alongside\n"
"the initial accumulation value.\n"
"\n"
"The returned function receives a collectable and injects a given\n"
"value into it for every `{:cont, term}` instruction.\n"
"\n"
"`:done` is passed when no further values will be injected, useful\n"
"for closing resources and normalizing values. A collectable must\n"
"be returned on `:done`.\n"
"\n"
"If injection is suddenly interrupted, `:halt` is passed and it can\n"
"return any value, as it won't be used.\n"
msgstr ""
#. TRANSLATORS: def Float.to_char_list(float, options)
#: lib/float.ex:232 
msgid ""
"Returns a list which corresponds to the text representation\n"
"of `float`.\n"
"\n"
"## Options\n"
"\n"
"  * `:decimals`   â€” number of decimal points to show\n"
"  * `:scientific` â€” number of decimal points to show, in scientific format\n"
"  * `:compact`    â€” when true, use the most compact representation (ignored\n"
"                    with the `scientific` option)\n"
"\n"
"## Examples\n"
"\n"
"    iex> Float.to_char_list 7.1, [decimals: 2, compact: true]\n"
"    '7.1'\n"
"\n"
msgstr ""
#. TRANSLATORS: def Process.list()
#: lib/process.ex:236 
msgid ""
"Returns a list of process identifiers corresponding to all the\n"
"processes currently existing on the local node.\n"
"\n"
"Note that a process that is exiting, exists but is not alive, i.e.,\n"
"`alive?/1` will return `false` for a process that is exiting,\n"
"but its process identifier will be part of the result returned.\n"
"\n"
"See http://www.erlang.org/doc/man/erlang.html#processes-0 for more info.\n"
msgstr ""
#. TRANSLATORS: def Node.list(args)
#: lib/node.ex:79 
msgid ""
"Returns a list of nodes according to argument given.\n"
"\n"
"The result returned when the argument is a list, is the list of nodes\n"
"satisfying the disjunction(s) of the list elements.\n"
"\n"
"See http://www.erlang.org/doc/man/erlang.html#nodes-1 for more info.\n"
msgstr ""
#. TRANSLATORS: def Process.registered()
#: lib/process.ex:323 
msgid ""
"Returns a list of names which have been registered using `register/2`.\n"
msgstr ""
#. TRANSLATORS: def Regex.names(regex)
#: lib/regex.ex:286 
msgid ""
"Returns a list of names in the regex.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.names(~r/(?<foo>bar)/)\n"
"    [\"foo\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Dict.to_list(dict)
#: lib/dict.ex:689 
msgid ""
"Returns a list of key-value pairs stored in `dict`.\n"
"No particular order is enforced.\n"
msgstr ""
#. TRANSLATORS: def Enum.shuffle(collection)
#: lib/enum.ex:1419 
msgid ""
"Returns a list of collection elements shuffled.\n"
"\n"
"Notice that you need to explicitly call `:random.seed/1` and\n"
"set a seed value for the random algorithm. Otherwise, the\n"
"default seed will be set which will always return the same\n"
"result. For example, one could do the following to set a seed\n"
"dynamically:\n"
"\n"
"    :random.seed(:os.timestamp)\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.shuffle([1, 2, 3])\n"
"    [3, 2, 1]\n"
"    iex> Enum.shuffle([1, 2, 3])\n"
"    [3, 1, 2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Node.list()
#: lib/node.ex:65 
msgid ""
"Returns a list of all visible nodes in the system, excluding\n"
"the local node.\n"
"\n"
"Same as `list(:visible)`.\n"
msgstr ""
#. TRANSLATORS: def Dict.values(dict)
#: lib/dict.ex:313 
msgid ""
"Returns a list of all values in `dict`.\n"
"The values are not guaranteed to be in any order.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> Enum.sort(Dict.values(dict))\n"
"    [1,2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Dict.keys(dict)
#: lib/dict.ex:297 
msgid ""
"Returns a list of all keys in `dict`.\n"
"The keys are not guaranteed to be in any order.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> Enum.sort(Dict.keys(dict))\n"
"    [:a,:b]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.chunk(coll, n, step, pad \\ nil)
#: lib/enum.ex:338 
msgid ""
"Returns a collection of lists containing `n` items each, where\n"
"each new chunk starts `step` elements into the collection.\n"
"\n"
"`step` is optional and, if not passed, defaults to `n`, i.e.\n"
"chunks do not overlap. If the final chunk does not have `n`\n"
"elements to fill the chunk, elements are taken as necessary\n"
"from `pad` if it was passed. If `pad` is passed and does not\n"
"have enough elements to fill the chunk, then the chunk is\n"
"returned anyway with less than `n` elements. If `pad` is not\n"
"passed at all or is `nil`, then the partial chunk is discarded\n"
"from the result.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4, 5, 6], 2)\n"
"    [[1, 2], [3, 4], [5, 6]]\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4, 5, 6], 3, 2)\n"
"    [[1, 2, 3], [3, 4, 5]]\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4, 5, 6], 3, 2, [7])\n"
"    [[1, 2, 3], [3, 4, 5], [5, 6, 7]]\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4, 5, 6], 3, 3, [])\n"
"    [[1, 2, 3], [4, 5, 6]]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Inspect.Algebra.empty()
#: lib/inspect/algebra.ex:228 
msgid ""
"Returns a document entity used to represent nothingness.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Inspect.Algebra.empty\n"
"    :doc_nil\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.take_every(collection, nth)
#: lib/enum.ex:1758 
msgid ""
"Returns a collection of every `nth` item in the collection,\n"
"starting with the first element.\n"
"\n"
"The second argument specifying every `nth` item must be a non-negative integer.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.take_every(1..10, 2)\n"
"    [1, 3, 5, 7, 9]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Integer.to_char_list(number)
#: lib/integer.ex:121 
msgid ""
"Returns a char list which corresponds to the text representation of the given integer.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Integer.to_char_list(7)\n"
"    '7'\n"
"\n"
msgstr ""
#. TRANSLATORS: def Float.to_char_list(number)
#: lib/float.ex:210 
msgid ""
"Returns a char list which corresponds to the text representation of the given float.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Float.to_char_list(7.0)\n"
"    '7.00000000000000000000e+00'\n"
"\n"
msgstr ""
#. TRANSLATORS: def Integer.to_char_list(number, base)
#: lib/integer.ex:138 
msgid ""
"Returns a char list which corresponds to the text representation of the\n"
"given integer in the given base.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Integer.to_char_list(1023, 16)\n"
"    '3FF'\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.is_nil(term)
#: lib/kernel.ex:1894 
msgid ""
"Returns `true` if `term` is nil; otherwise returns `false`.\n"
"\n"
"Allowed in guard clauses.\n"
"\n"
"## Examples\n"
"\n"
"    iex> is_nil(1)\n"
"    false\n"
"\n"
"    iex> is_nil(nil)\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.is_boolean(term)
#: lib/kernel.ex:291 
msgid ""
"Returns `true` if `term` is either the atom `true` or the atom `false` (i.e. a boolean);\n"
"otherwise returns false.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Kernel.is_number(term)
#: lib/kernel.ex:353 
msgid ""
"Returns `true` if `term` is either an integer or a floating point number;\n"
"otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Kernel.is_integer(term)
#: lib/kernel.ex:332 
msgid ""
"Returns `true` if `term` is an integer; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Kernel.is_atom(term)
#: lib/kernel.ex:258 
msgid ""
"Returns `true` if `term` is an atom; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Kernel.is_tuple(term)
#: lib/kernel.ex:393 
msgid ""
"Returns `true` if `term` is a tuple; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Kernel.is_reference(term)
#: lib/kernel.ex:383 
msgid ""
"Returns `true` if `term` is a reference; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Kernel.is_port(term)
#: lib/kernel.ex:373 
msgid ""
"Returns `true` if `term` is a port identifier; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Kernel.is_pid(term)
#: lib/kernel.ex:363 
msgid ""
"Returns `true` if `term` is a pid (process identifier); otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Kernel.is_map(term)
#: lib/kernel.ex:403 
msgid ""
"Returns `true` if `term` is a map; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Kernel.is_list(term)
#: lib/kernel.ex:342 
msgid ""
"Returns `true` if `term` is a list with zero or more elements; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Kernel.is_function(term)
#: lib/kernel.ex:311 
msgid ""
"Returns `true` if `term` is a function; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Kernel.is_function(term, arity)
#: lib/kernel.ex:322 
msgid ""
"Returns `true` if `term` is a function that can be applied with `arity` number of arguments;\n"
"otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Kernel.is_float(term)
#: lib/kernel.ex:301 
msgid ""
"Returns `true` if `term` is a floating point number; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Kernel.is_bitstring(term)
#: lib/kernel.ex:280 
msgid ""
"Returns `true` if `term` is a bitstring (including a binary); otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Kernel.is_binary(term)
#: lib/kernel.ex:270 
msgid ""
"Returns `true` if `term` is a binary; otherwise returns `false`.\n"
"\n"
"A binary always contains a complete number of bytes.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Regex.match?(regex, string)
#: lib/regex.ex:158 
msgid ""
"Returns a boolean indicating whether there was a match or not.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.match?(~r/foo/, \"foo\")\n"
"    true\n"
"\n"
"    iex> Regex.match?(~r/foo/, \"bar\")\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Integer.to_string(some_integer)
#: lib/integer.ex:88 
msgid ""
"Returns a binary which corresponds to the text representation\n"
"of `some_integer`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Integer.to_string(123)\n"
"    \"123\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Integer.to_string(some_integer, base)
#: lib/integer.ex:105 
msgid ""
"Returns a binary which corresponds to the text representation\n"
"of `some_integer` in base `base`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Integer.to_string(100, 16)\n"
"    \"64\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Float.to_string(some_float)
#: lib/float.ex:249 
msgid ""
"Returns a binary which corresponds to the text representation\n"
"of `some_float`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Float.to_string(7.0)\n"
"    \"7.00000000000000000000e+00\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Float.to_string(float, options)
#: lib/float.ex:271 
msgid ""
"Returns a binary which corresponds to the text representation\n"
"of `float`.\n"
"\n"
"## Options\n"
"\n"
"  * `:decimals`   â€” number of decimal points to show\n"
"  * `:scientific` â€” number of decimal points to show, in scientific format\n"
"  * `:compact`    â€” when true, use the most compact representation (ignored\n"
"                    with the `scientific` option)\n"
"\n"
"## Examples\n"
"\n"
"    iex> Float.to_string 7.1, [decimals: 2, compact: true]\n"
"    \"7.1\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def String.duplicate(subject, n)
#: lib/string.ex:726 
msgid ""
"Returns a binary `subject` duplicated `n` times.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.duplicate(\"abc\", 0)\n"
"    \"\"\n"
"\n"
"    iex> String.duplicate(\"abc\", 1)\n"
"    \"abc\"\n"
"\n"
"    iex> String.duplicate(\"abc\", 2)\n"
"    \"abcabc\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Dict.fetch(dict, key)
#: lib/dict.ex:382 
msgid ""
"Returns `{:ok, value}` associated with `key` in `dict`.\n"
"If `dict` does not contain `key`, returns `:error`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> Dict.fetch(dict, :a)\n"
"    {:ok, 1}\n"
"    iex> Dict.fetch(dict, :b)\n"
"    :error\n"
"\n"
msgstr ""
#. TRANSLATORS: def IO.ANSI.font_9()
#: lib/io/ansi.ex:82 
msgid ""
"Sets alternative font 9"
msgstr ""
#. TRANSLATORS: def IO.ANSI.font_8()
#: lib/io/ansi.ex:82 
msgid ""
"Sets alternative font 8"
msgstr ""
#. TRANSLATORS: def IO.ANSI.font_7()
#: lib/io/ansi.ex:82 
msgid ""
"Sets alternative font 7"
msgstr ""
#. TRANSLATORS: def IO.ANSI.font_6()
#: lib/io/ansi.ex:82 
msgid ""
"Sets alternative font 6"
msgstr ""
#. TRANSLATORS: def IO.ANSI.font_5()
#: lib/io/ansi.ex:82 
msgid ""
"Sets alternative font 5"
msgstr ""
#. TRANSLATORS: def IO.ANSI.font_4()
#: lib/io/ansi.ex:82 
msgid ""
"Sets alternative font 4"
msgstr ""
#. TRANSLATORS: def IO.ANSI.font_3()
#: lib/io/ansi.ex:82 
msgid ""
"Sets alternative font 3"
msgstr ""
#. TRANSLATORS: def IO.ANSI.font_2()
#: lib/io/ansi.ex:82 
msgid ""
"Sets alternative font 2"
msgstr ""
#. TRANSLATORS: def IO.ANSI.font_1()
#: lib/io/ansi.ex:82 
msgid ""
"Sets alternative font 1"
msgstr ""
#. TRANSLATORS: def Module.split(module)
#: lib/module.ex:853 
msgid ""
"Split the given module name into binary parts.\n"
"\n"
"## Examples\n"
"\n"
"    Module.split Very.Long.Module.Name.And.Even.Longer\n"
"    #=> [\"Very\", \"Long\", \"Module\", \"Name\", \"And\", \"Even\", \"Longer\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Regex.run(regex, string, options \\ [])
#: lib/regex.ex:202 
msgid ""
"Runs the regular expression against the given string until the first match.\n"
"It returns a list with all captures or `nil` if no match occurred.\n"
"\n"
"## Options\n"
"\n"
"  * `:return`  - set to `:index` to return indexes. Defaults to `:binary`.\n"
"  * `:capture` - what to capture in the result. Check the moduledoc for `Regex`\n"
"                 to see the possible capture values.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.run(~r/c(d)/, \"abcd\")\n"
"    [\"cd\", \"d\"]\n"
"\n"
"    iex> Regex.run(~r/e/, \"abcd\")\n"
"    nil\n"
"\n"
"    iex> Regex.run(~r/c(d)/, \"abcd\", return: :index)\n"
"    [{2,2},{3,1}]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.run(stream)
#: lib/stream.ex:454 
msgid ""
"Runs the given stream.\n"
"\n"
"This is useful when a stream needs to be run, for side effects,\n"
"and there is no interest in its return result.\n"
"\n"
"## Examples\n"
"\n"
"Open up a file, replace all `#` by `%` and stream to another file\n"
"without loading the whole file in memory:\n"
"\n"
"    stream = File.stream!(\"code\")\n"
"    |> Stream.map(&String.replace(&1, \"#\", \"%\"))\n"
"    |> Stream.into(File.stream!(\"new\"))\n"
"    |> Stream.run\n"
"\n"
"No computation will be done until we call one of the Enum functions\n"
"or `Stream.run/1`.\n"
msgstr ""
#. TRANSLATORS: def Kernel.CLI.run(fun, halt \\ true)
#: lib/kernel/cli.ex:36 
msgid ""
"Runs the given function by catching any failure\n"
"and printing them to stdout. `at_exit` hooks are\n"
"also invoked before exiting.\n"
"\n"
"This function is used by Elixir's CLI and also\n"
"by escripts generated by Elixir.\n"
msgstr ""
#. TRANSLATORS: def String.split_at(string, offset)
#: lib/string.ex:366 
msgid ""
"Splits a string into two at the specified offset. When the offset given is\n"
"negative, location is counted from the end of the string.\n"
"\n"
"The offset is capped to the length of the string.\n"
"\n"
"Returns a tuple with two elements.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.split_at \"sweetelixir\", 5\n"
"    {\"sweet\", \"elixir\"}\n"
"\n"
"    iex> String.split_at \"sweetelixir\", -6\n"
"    {\"sweet\", \"elixir\"}\n"
"\n"
"    iex> String.split_at \"abc\", 0\n"
"    {\"\", \"abc\"}\n"
"\n"
"    iex> String.split_at \"abc\", 1000\n"
"    {\"abc\", \"\"}\n"
"\n"
"    iex> String.split_at \"abc\", -1000\n"
"    {\"\", \"abc\"}\n"
"\n"
msgstr ""
#. TRANSLATORS: def String.graphemes(string)
#: lib/string.ex:901 
msgid ""
"Returns unicode graphemes in the string as per Extended Grapheme\n"
"Cluster algorithm outlined in the [Unicode Standard Annex #29,\n"
"Unicode Text Segmentation](http://www.unicode.org/reports/tr29/).\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.graphemes(\"ÅƒaÃ¯ve\")\n"
"    [\"Åƒ\", \"a\", \"Ã¯\", \"v\", \"e\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def System.put_env(dict)
#: lib/system.ex:306 
msgid ""
"Set multiple environment variables.\n"
"\n"
"Sets a new value for each environment variable corresponding\n"
"to each key in `dict`.\n"
msgstr ""
#. TRANSLATORS: def System.put_env(varname, value)
#: lib/system.ex:294 
msgid ""
"Set an environment variable value.\n"
"\n"
"Sets a new `value` for the environment variable `varname`.\n"
msgstr ""
#. TRANSLATORS: def String.reverse(string)
#: lib/string.ex:700 
msgid ""
"Reverses the given string. Works on graphemes.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.reverse(\"abcd\")\n"
"    \"dcba\"\n"
"\n"
"    iex> String.reverse(\"hello world\")\n"
"    \"dlrow olleh\"\n"
"\n"
"    iex> String.reverse(\"hello âˆ‚og\")\n"
"    \"goâˆ‚ olleh\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.reverse(collection)
#: lib/enum.ex:1333 
msgid ""
"Reverses the collection.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reverse([1, 2, 3])\n"
"    [3, 2, 1]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.reverse(collection, tail)
#: lib/enum.ex:1353 
msgid ""
"Reverses the collection and appends the tail.\n"
"This is an optimization for\n"
"`Enum.concat(Enum.reverse(collection), tail)`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reverse([1, 2, 3], [4, 5, 6])\n"
"    [3, 2, 1, 4, 5, 6]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Process.send(dest, msg, options)
#: lib/process.ex:127 
msgid ""
"Sends a message to the given process.\n"
"\n"
"If the option `:noconnect` is used and sending the message would require an\n"
"auto-connection to another node the message is not sent and `:noconnect` is\n"
"returned.\n"
"\n"
"If the option `:nosuspend` is used and sending the message would cause the\n"
"sender to be suspended the message is not sent and `:nosuspend` is returned.\n"
"\n"
"Otherwise the message is sent and `:ok` is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Process.send({:name, :node_does_not_exist}, :hi, [:noconnect])\n"
"    :noconnect\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.send(dest, msg)
#: lib/kernel.ex:562 
msgid ""
"Sends a message to the given `dest` and returns the message.\n"
"\n"
"`dest` may be a remote or local pid, a (local) port, a locally\n"
"registered name, or a tuple `{registered_name, node}` for a registered\n"
"name at another node.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> send self(), :hello\n"
"    :hello\n"
"\n"
msgstr ""
#. TRANSLATORS: def Process.send_after(dest, msg, time)
#: lib/process.ex:149 
msgid ""
"Sends `msg` to `dest` after `time` milliseconds.\n"
"\n"
"If `dest` is a pid, it must be the pid of a local process, dead or alive.\n"
"If `dest` is an atom, it must be the name of a registered process\n"
"which is looked up at the time of delivery. No error is given if the name does\n"
"not refer to a process.\n"
"\n"
"This function returns a timer reference, which can be read or canceled with\n"
"`:erlang.read_timer/1`, `:erlang.start_timer/3` and `:erlang.cancel_timer/1`.\n"
"Note `time` cannot be greater than `4294967295`.\n"
"\n"
"Finally, the timer will be automatically canceled if the given `dest` is a pid\n"
"which is not alive or when the given pid exits. Note that timers will not be\n"
"automatically canceled when `dest` is an atom (as the atom resolution is done\n"
"on delivery).\n"
msgstr ""
#. TRANSLATORS: def File.write_stat!(path, stat, opts \\ [])
#: lib/file.ex:306 
msgid ""
"Same as `write_stat/3` but raises an exception if it fails.\n"
"Returns `:ok` otherwise.\n"
msgstr ""
#. TRANSLATORS: def File.write!(path, content, modes \\ [])
#: lib/file.ex:636 
msgid ""
"Same as `write/3` but raises an exception if it fails, returns `:ok` otherwise.\n"
msgstr ""
#. TRANSLATORS: def File.touch!(path, time \\ :calendar.local_time())
#: lib/file.ex:340 
msgid ""
"Same as `touch/2` but raises an exception if it fails.\n"
"Returns `:ok` otherwise.\n"
msgstr ""
#. TRANSLATORS: def File.stat!(path, opts \\ [])
#: lib/file.ex:283 
msgid ""
"Same as `stat/2` but returns the `File.Stat` directly and\n"
"throws `File.Error` if an error is returned.\n"
msgstr ""
#. TRANSLATORS: def File.stream!(path, modes \\ [], line_or_bytes \\ :line)
#: lib/file.ex:1139 
msgid ""
"Returns a `File.Stream` for the given `path` with the given `modes`.\n"
"\n"
"The stream implements both `Enumerable` and `Collectable` protocols,\n"
"which means it can be used both for read and write.\n"
"\n"
"The `line_or_byte` argument configures how the file is read when\n"
"streaming, by `:line` (default) or by a given number of bytes.\n"
"\n"
"Operating the stream can fail on open for the same reasons as\n"
"`File.open!/2`. Note that the file is automatically opened only and\n"
"every time streaming begins. There is no need to pass `:read` and\n"
"`:write` modes, as those are automatically set by Elixir.\n"
"\n"
"## Raw files\n"
"\n"
"Since Elixir controls when the streamed file is opened, the underlying\n"
"device cannot be shared and as such it is convenient to open the file\n"
"in raw mode for performance reasons. Therefore, Elixir **will** open\n"
"streams in `:raw` mode with the `:read_ahead` option unless an encoding\n"
"is specified.\n"
"\n"
"One may also consider passing the `:delayed_write` option if the stream\n"
"is meant to be written to under a tight loop.\n"
msgstr ""
#. TRANSLATORS: def File.read(path)
#: lib/file.ex:230 
msgid ""
"Returns `{:ok, binary}`, where `binary` is a binary data object that contains the contents\n"
"of `path`, or `{:error, reason}` if an error occurs.\n"
"\n"
"Typical error reasons:\n"
"\n"
"  * `:enoent`  - the file does not exist\n"
"  * `:eacces`  - missing permission for reading the file,\n"
"                 or for searching one of the parent directories\n"
"  * `:eisdir`  - the named file is a directory\n"
"  * `:enotdir` - a component of the file name is not a directory;\n"
"                 on some platforms, `:enoent` is returned instead\n"
"  * `:enomem`  - there is not enough memory for the contents of the file\n"
"\n"
"You can use `:file.format_error/1` to get a descriptive string of the error.\n"
msgstr ""
#. TRANSLATORS: def Kernel.!==(left, right)
#: lib/kernel.ex:1066 
msgid ""
"Returns `true` if the two items do not match.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 !== 2\n"
"    true\n"
"\n"
"    iex> 1 !== 1.0\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.!=(left, right)
#: lib/kernel.ex:1020 
msgid ""
"Returns `true` if the two items are not equal.\n"
"\n"
"This operator considers 1 and 1.0 to be equal. For match\n"
"comparison, use `!==` instead.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 != 2\n"
"    true\n"
"\n"
"    iex> 1 != 1.0\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.--(left, right)
#: lib/kernel.ex:884 
msgid ""
"Removes the first occurrence of an item on the left\n"
"for each item on the right.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> [1, 2, 3] -- [1, 2]\n"
"    [3]\n"
"\n"
"    iex> [1, 2, 3, 2, 1] -- [1, 2, 2]\n"
"    [3,1]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Dict.delete(dict, key)
#: lib/dict.ex:452 
msgid ""
"Removes the entry stored under the given `key` from `dict`.\n"
"If `dict` does not contain `key`, returns the dictionary unchanged.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.delete(dict, :a)\n"
"    iex> Dict.get(dict, :a)\n"
"    nil\n"
"\n"
"    iex> dict = Enum.into([b: 2], dict_impl.new)\n"
"    iex> Dict.delete(dict, :a) == dict\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: def Exception.format(kind, payload, stacktrace \\ nil)
#: lib/exception.ex:133 
msgid ""
"Normalizes and formats throw/errors/exits and stacktrace.\n"
"\n"
"It relies on `format_banner/3` and `format_stacktrace/1`\n"
"to generate the final format.\n"
"\n"
"Note that `{:EXIT, pid}` do not generate a stacktrace though\n"
"(as they are retrieved as messages without stacktraces).\n"
msgstr ""
#. TRANSLATORS: def Exception.format_banner(kind, exception, stacktrace \\ nil)
#: lib/exception.ex:102 
msgid ""
"Normalizes and formats any throw, error and exit.\n"
"\n"
"The message is formatted and displayed in the same\n"
"format as used by Elixir's CLI.\n"
"\n"
"The third argument, a stacktrace, is optional. If it is\n"
"not supplied `System.stacktrace/0` will sometimes be used\n"
"to get additional information for the `kind` `:error`. If\n"
"the stacktrace is unknown and `System.stacktrace/0` would\n"
"not return the stacktrace corresponding to the exception\n"
"an empty stacktrace, `[]`, must be used.\n"
msgstr ""
#. TRANSLATORS: def Exception.normalize(kind, payload, stacktrace \\ nil)
#: lib/exception.ex:74 
msgid ""
"Normalizes an exception, converting Erlang exceptions\n"
"to Elixir exceptions.\n"
"\n"
"It takes the `kind` spilled by `catch` as an argument and\n"
"normalizes only `:error`, returning the untouched payload\n"
"for others.\n"
"\n"
"The third argument, a stacktrace, is optional. If it is\n"
"not supplied `System.stacktrace/0` will sometimes be used\n"
"to get additional information for the `kind` `:error`. If\n"
"the stacktrace is unknown and `System.stacktrace/0` would\n"
"not return the stacktrace corresponding to the exception\n"
"an empty stacktrace, `[]`, must be used.\n"
msgstr ""
#. TRANSLATORS: def GenEvent.remove_handler(manager, handler, args)
#: lib/gen_event.ex:460 
msgid ""
"Removes an event handler from the event `manager`.\n"
"\n"
"The event manager will call `terminate/2` to terminate the event handler\n"
"and return the callback value. If the specified event handler is not\n"
"installed, the function returns `{:error, :not_found}`.\n"
msgstr ""
#. TRANSLATORS: def GenEvent.call(manager, handler, request, timeout \\ 5000)
#: lib/gen_event.ex:441 
msgid ""
"Makes a synchronous call to the event `handler` installed in `manager`.\n"
"\n"
"The given `request` is sent and the caller waits until a reply arrives or\n"
"a timeout occurs. The event manager will call `handle_call/2` to handle\n"
"the request.\n"
"\n"
"The return value `reply` is defined in the return value of `handle_call/2`.\n"
"If the specified event handler is not installed, the function returns\n"
"`{:error, :not_found}`.\n"
msgstr ""
#. TRANSLATORS: def GenServer.call(server, request, timeout \\ 5000)
#: lib/gen_server.ex:351 
msgid ""
"Makes a synchronous call to the `server` and waits for its reply.\n"
"\n"
"The client sends the given `request` to the server and waits until a reply\n"
"arrives or a timeout occurs. `handle_call/3` will be called on the server\n"
"to handle the request.\n"
"\n"
"The server can be any of the values described in the `Name Registration`\n"
"section of the module documentation.\n"
"\n"
"## Timeouts\n"
"\n"
"The `timeout` is an integer greater than zero which specifies how many\n"
"milliseconds to wait for a reply, or the atom `:infinity` to wait\n"
"indefinitely. The default value is 5000. If no reply is received within\n"
"the specified time, the function call fails. If the caller catches the\n"
"failure and continues running, and the server is just late with the reply,\n"
"it may arrive at any time later into the caller's message queue. The caller\n"
"must in this case be prepared for this and discard any such garbage messages\n"
"that are two element tuples with a reference as the first element.\n"
msgstr ""
#. TRANSLATORS: def IO.binstream(device, line_or_bytes)
#: lib/io.ex:308 
msgid ""
"Converts the IO device into a `IO.Stream`.\n"
"\n"
"An `IO.Stream` implements both `Enumerable` and\n"
"`Collectable`, allowing it to be used for both read\n"
"and write.\n"
"\n"
"The device is iterated line by line or by a number of bytes.\n"
"This reads the IO device as a raw binary.\n"
"\n"
"Note that an IO stream has side effects and every time\n"
"you go over the stream you may get different results.\n"
"\n"
"Finally, do not use this function on IO devices in unicode\n"
"mode as it will return the wrong result.\n"
msgstr ""
#. TRANSLATORS: def Protocol.consolidate(protocol, types)
#: lib/protocol.ex:264 
msgid ""
"Receives a protocol and a list of implementations and\n"
"consolidates the given protocol.\n"
"\n"
"Consolidation happens by changing the protocol `impl_for`\n"
"in the abstract format to have fast lookup rules. Usually\n"
"the list of implementations to use during consolidation\n"
"are retrieved with the help of `extract_impls/2`.\n"
"\n"
"It returns the updated version of the protocol bytecode.\n"
"A given bytecode or protocol implementation can be checked\n"
"to be consolidated or not by analyzing the protocol\n"
"attribute:\n"
"\n"
"    Protocol.consolidated?(Enumerable)\n"
"\n"
"If the first element of the tuple is true, it means\n"
"the protocol was consolidated.\n"
"\n"
"This function does not load the protocol at any point\n"
"nor loads the new bytecode for the compiled module.\n"
"However each implementation must be available and\n"
"it will be loaded.\n"
msgstr ""
#. TRANSLATORS: def IO.ANSI.crossed_out()
#: lib/io/ansi.ex:75 
msgid ""
"Crossed-out. Characters legible, but marked for deletion. Not widely supported."
msgstr ""
#. TRANSLATORS: def Tuple.delete_at(tuple, index)
#: lib/tuple.ex:63 
msgid ""
"Removes an element from a tuple.\n"
"\n"
"Deletes the element at the zero-based `index` from `tuple`.\n"
"Raises an `ArgumentError` if `index` is greater than\n"
"or equal to the length of `tuple`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> tuple = {:foo, :bar, :baz}\n"
"    iex> Tuple.delete_at(tuple, 0)\n"
"    {:bar, :baz}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Code.unload_files(files)
#: lib/code.ex:23 
msgid ""
"Remove files from the loaded files list.\n"
"\n"
"The modules defined in the file are not removed;\n"
"calling this function only removes them from the list,\n"
"allowing them to be required again.\n"
msgstr ""
#. TRANSLATORS: def Exception.format_mfa(module, fun, arity)
#: lib/exception.ex:416 
msgid ""
"Receives a module, fun and arity and formats it\n"
"as shown in stacktraces. The arity may also be a list\n"
"of arguments.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Exception.format_mfa Foo, :bar, 1\n"
"    \"Foo.bar/1\"\n"
"\n"
"    iex> Exception.format_mfa Foo, :bar, []\n"
"    \"Foo.bar()\"\n"
"\n"
"    iex> Exception.format_mfa nil, :bar, []\n"
"    \"nil.bar()\"\n"
"\n"
"Anonymous functions are reported as -func/arity-anonfn-count-,\n"
"where func is the name of the enclosing function. Convert to\n"
"\"anonymous fn in func/arity\"\n"
msgstr ""
#. TRANSLATORS: def File.rm_rf(path)
#: lib/file.ex:763 
msgid ""
"Remove files and directories recursively at the given `path`.\n"
"Symlinks are not followed but simply removed, non-existing\n"
"files are simply ignored (i.e. doesn't make this function fail).\n"
"\n"
"Returns `{:ok, files_and_directories}` with all files and\n"
"directories removed in no specific order, `{:error, reason, file}`\n"
"otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    File.rm_rf \"samples\"\n"
"    #=> {:ok, [\"samples\", \"samples/1.txt\"]}\n"
"\n"
"    File.rm_rf \"unknown\"\n"
"    #=> {:ok, []}\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Integer.is_odd(n)
#: lib/integer.ex:15 
msgid ""
"Determines if an integer is odd.\n"
"\n"
"Returns `true` if `n` is an odd number, otherwise `false`.\n"
"\n"
"Allowed in guard clauses.\n"
msgstr ""
#. TRANSLATORS: defmacro Integer.is_even(n)
#: lib/integer.ex:26 
msgid ""
"Determines if an integer is even.\n"
"\n"
"Returns `true` if `n` is an even number, otherwise `false`.\n"
"\n"
"Allowed in guard clauses.\n"
msgstr ""
#. TRANSLATORS: def List.keysort(list, position)
#: lib/list.ex:232 
msgid ""
"Receives a list of tuples and sorts the items\n"
"at `position` of the tuples. The sort is stable.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.keysort([a: 5, b: 1, c: 3], 1)\n"
"    [b: 1, c: 3, a: 5]\n"
"\n"
"    iex> List.keysort([a: 5, c: 1, b: 3], 0)\n"
"    [a: 5, b: 3, c: 1]\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.keyfind(list, key, position, default \\ nil)
#: lib/list.ex:177 
msgid ""
"Receives a list of tuples and returns the first tuple\n"
"where the item at `position` in the tuple matches the\n"
"given `key`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.keyfind([a: 1, b: 2], :a, 0)\n"
"    {:a, 1}\n"
"\n"
"    iex> List.keyfind([a: 1, b: 2], 2, 1)\n"
"    {:b, 2}\n"
"\n"
"    iex> List.keyfind([a: 1, b: 2], :c, 0)\n"
"    nil\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.keymember?(list, key, position)
#: lib/list.ex:199 
msgid ""
"Receives a list of tuples and returns `true` if there is\n"
"a tuple where the item at `position` in the tuple matches\n"
"the given `key`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.keymember?([a: 1, b: 2], :a, 0)\n"
"    true\n"
"\n"
"    iex> List.keymember?([a: 1, b: 2], 2, 1)\n"
"    true\n"
"\n"
"    iex> List.keymember?([a: 1, b: 2], :c, 0)\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.keystore(list, key, position, new_tuple)
#: lib/list.ex:251 
msgid ""
"Receives a list of tuples and replaces the item\n"
"identified by `key` at `position`. If the item\n"
"does not exist, it is added to the end of the list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.keystore([a: 1, b: 2], :a, 0, {:a, 3})\n"
"    [a: 3, b: 2]\n"
"\n"
"    iex> List.keystore([a: 1, b: 2], :c, 0, {:c, 3})\n"
"    [a: 1, b: 2, c: 3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.keyreplace(list, key, position, new_tuple)
#: lib/list.ex:214 
msgid ""
"Receives a list of tuples and replaces the item\n"
"identified by `key` at `position` if it exists.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.keyreplace([a: 1, b: 2], :a, 0, {:a, 3})\n"
"    [a: 3, b: 2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.keydelete(list, key, position)
#: lib/list.ex:273 
msgid ""
"Receives a list of tuples and deletes the first tuple\n"
"where the item at `position` matches the\n"
"given `key`. Returns the new list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.keydelete([a: 1, b: 2], :a, 0)\n"
"    [b: 2]\n"
"\n"
"    iex> List.keydelete([a: 1, b: 2], 2, 1)\n"
"    [a: 1]\n"
"\n"
"    iex> List.keydelete([a: 1, b: 2], :c, 0)\n"
"    [a: 1, b: 2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def IO.ANSI.normal()
#: lib/io/ansi.ex:86 
msgid ""
"Normal color or intensity"
msgstr ""
#. TRANSLATORS: def Inspect.Algebra.nest(x, i)
#: lib/inspect/algebra.ex:266 
msgid ""
"Nests document entity `x` positions deep.\n"
"\n"
"Nesting will be appended to the line breaks.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.nest(Inspect.Algebra.glue(\"hello\", \"world\"), 5)\n"
"    iex> Inspect.Algebra.format(doc, 5)\n"
"    [\"hello\", \"\\n     \", \"world\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.delete(list, item)
#: lib/list.ex:36 
msgid ""
"Deletes the given item from the list. Returns a list without\n"
"the item. If the item occurs more than once in the list, just\n"
"the first occurrence is removed.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.delete([1, 2, 3], 1)\n"
"    [2,3]\n"
"\n"
"    iex> List.delete([1, 2, 2, 3], 2)\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Module.register_attribute(module, new, opts)
#: lib/module.ex:829 
msgid ""
"Registers an attribute. By registering an attribute, a developer\n"
"is able to customize how Elixir will store and accumulate the\n"
"attribute values.\n"
"\n"
"## Options\n"
"\n"
"When registering an attribute, two options can be given:\n"
"\n"
"  * `:accumulate` - several calls to the same attribute will\n"
"    accumulate instead of override the previous one. New attributes\n"
"    are always added to the top of the accumulated list.\n"
"\n"
"  * `:persist` - the attribute will be persisted in the Erlang\n"
"    Abstract Format. Useful when interfacing with Erlang libraries.\n"
"\n"
"By default, both options are `false`.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule MyModule do\n"
"      Module.register_attribute __MODULE__,\n"
"        :custom_threshold_for_lib,\n"
"        accumulate: true, persist: false\n"
"\n"
"      @custom_threshold_for_lib 10\n"
"      @custom_threshold_for_lib 20\n"
"      @custom_threshold_for_lib #=> [20, 10]\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def Node.monitor(node, flag)
#: lib/node.ex:92 
msgid ""
"Monitors the status of the node.\n"
"\n"
"If `flag` is `true`, monitoring is turned on.\n"
"If `flag` is `false`, monitoring is turned off.\n"
"\n"
"See http://www.erlang.org/doc/man/erlang.html#monitor_node-2 for more info.\n"
msgstr ""
#. TRANSLATORS: def OptionParser.next(argv, opts \\ [])
#: lib/option_parser.ex:192 
msgid ""
"Low-level function that parses one option.\n"
"\n"
"It accepts the same options as `parse/2` and `parse_head/2`\n"
"as both functions are built on top of next. This function\n"
"may return:\n"
"\n"
"  * `{:ok, key, value, rest}` - the option `key` with `value` was\n"
"    successfully parsed\n"
"\n"
"  * `{:invalid, key, value, rest}` - the option `key` is invalid with `value`\n"
"    (returned when the switch type does not match the one given via the\n"
"    command line)\n"
"\n"
"  * `{:undefined, key, value, rest}` - the option `key` is undefined\n"
"    (returned on strict cases and the switch is unknown)\n"
"\n"
"  * `{:error, rest}` - there are no switches at the top of the given argv\n"
msgstr ""
#. TRANSLATORS: def Process.delete(key)
#: lib/process.ex:70 
msgid ""
"Deletes the given `key` from the dictionary.\n"
msgstr ""
#. TRANSLATORS: def Keyword.delete_first(keywords, key)
#: lib/keyword.ex:282 
msgid ""
"Deletes the first entry in the keyword list for a specific `key`.\n"
"\n"
"If the `key` does not exist, returns the keyword list unchanged.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.delete_first([a: 1, b: 2, a: 3], :a)\n"
"    [b: 2, a: 3]\n"
"\n"
"    iex> Keyword.delete_first([b: 2], :a)\n"
"    [b: 2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.delete(keywords, key)
#: lib/keyword.ex:263 
msgid ""
"Deletes the entries in the keyword list for a specific `key`.\n"
"\n"
"If the `key` does not exist, returns the keyword list unchanged.\n"
"Use `delete_first/2` to delete just the first entry in case of\n"
"duplicated keys.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.delete([a: 1, b: 2], :a)\n"
"    [b: 2]\n"
"\n"
"    iex> Keyword.delete([a: 1, b: 2, a: 3], :a)\n"
"    [b: 2]\n"
"\n"
"    iex> Keyword.delete([b: 2], :a)\n"
"    [b: 2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.delete(keywords, key, value)
#: lib/keyword.ex:239 
msgid ""
"Deletes the entries in the keyword list for a `key` with `value`.\n"
"\n"
"If no `key` with `value` exists, returns the keyword list unchanged.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.delete([a: 1, b: 2], :a, 1)\n"
"    [b: 2]\n"
"\n"
"    iex> Keyword.delete([a: 1, b: 2, a: 3], :a, 3)\n"
"    [a: 1, b: 2]\n"
"\n"
"    iex> Keyword.delete([b: 2], :a, 5)\n"
"    [b: 2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Module.delete_attribute(module, key)
#: lib/module.ex:791 
msgid ""
"Deletes all attributes that match the given key.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule MyModule do\n"
"      Module.put_attribute __MODULE__, :custom_threshold_for_lib, 10\n"
"      Module.delete_attribute __MODULE__, :custom_threshold_for_lib\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.Regex Summary
#: lib/regex.ex:1 
msgid ""
"Regular expressions for Elixir built on top of Erlang's `re` module.\n"
"\n"
"As the `re` module, Regex is based on PCRE\n"
"(Perl Compatible Regular Expressions). More information can be\n"
"found in the [`re` documentation](http://www.erlang.org/doc/man/re.html).\n"
"\n"
"Regular expressions in Elixir can be created using `Regex.compile!/2`\n"
"or using the special form with [`~r`](Kernel.html#sigil_r/2):\n"
"\n"
"    # A simple regular expressions that matches foo anywhere in the string\n"
"    ~r/foo/\n"
"\n"
"    # A regular expression with case insensitive and unicode options\n"
"    ~r/foo/iu\n"
"\n"
"A Regex is represented internally as the `Regex` struct. Therefore,\n"
"`%Regex{}` can be used whenever there is a need to match on them.\n"
"\n"
"## Modifiers\n"
"\n"
"The modifiers available when creating a Regex are:\n"
"\n"
"  * `unicode` (u) - enables unicode specific patterns like `\\p` and changes\n"
"    modifiers like `\\w`, `\\W`, `\\s` and friends to also match on unicode.\n"
"    It expects valid unicode strings to be given on match\n"
"\n"
"  * `caseless` (i) - add case insensitivity\n"
"\n"
"  * `dotall` (s) - causes dot to match newlines and also set newline to\n"
"    anycrlf; the new line setting can be overridden by setting `(*CR)` or\n"
"    `(*LF)` or `(*CRLF)` or `(*ANY)` according to re documentation\n"
"\n"
"  * `multiline` (m) - causes `^` and `$` to mark the beginning and end of\n"
"    each line; use `\\A` and `\\z` to match the end or beginning of the string\n"
"\n"
"  * `extended` (x) - whitespace characters are ignored except when escaped\n"
"    and allow `#` to delimit comments\n"
"\n"
"  * `firstline` (f) - forces the unanchored pattern to match before or at the\n"
"    first newline, though the matched text may continue over the newline\n"
"\n"
"  * `ungreedy` (U) - inverts the \"greediness\" of the regexp\n"
"    (the previous `r` option is deprecated in favor of `U`)\n"
"\n"
"The options not available are:\n"
"\n"
"  * `anchored` - not available, use `^` or `\\A` instead\n"
"  * `dollar_endonly` - not available, use `\\z` instead\n"
"  * `no_auto_capture` - not available, use `?:` instead\n"
"  * `newline` - not available, use `(*CR)` or `(*LF)` or `(*CRLF)` or\n"
"    `(*ANYCRLF)` or `(*ANY)` at the beginning of the regexp according to the\n"
"    re documentation\n"
"\n"
"## Captures\n"
"\n"
"Many functions in this module allows what to capture in a regex\n"
"match via the `:capture` option. The supported values are:\n"
"\n"
"  * `:all` - all captured subpatterns including the complete matching string\n"
"    (this is the default)\n"
"\n"
"  * `:first` - only the first captured subpattern, which is always the\n"
"    complete matching part of the string; all explicitly captured subpatterns\n"
"    are discarded\n"
"\n"
"  * `:all_but_first`- all but the first matching subpattern, i.e. all\n"
"    explicitly captured subpatterns, but not the complete matching part of\n"
"    the string\n"
"\n"
"  * `:none` - do not return matching subpatterns at all\n"
"\n"
"  * `:all_names` - captures all names in the Regex\n"
"\n"
"  * `list(binary)` - a list of named captures to capture\n"
"\n"
msgstr ""
#. TRANSLATORS: def System.at_exit(fun)
#: lib/system.ex:226 
msgid ""
"Registers a program exit handler function.\n"
"\n"
"Registers a function that will be invoked at the end of program execution.\n"
"Useful for invoking a hook in \"script\" mode.\n"
"\n"
"The handler always executes in a different process from the one it was\n"
"registered in. As a consequence, any resources managed by the calling process\n"
"(ETS tables, open files, etc.) won't be available by the time the handler\n"
"function is invoked.\n"
"\n"
"The function must receive the exit status code as an argument.\n"
msgstr ""
#. TRANSLATORS: def URI.default_port(scheme, port)
#: lib/uri.ex:63 
msgid ""
"Registers a scheme with a default port.\n"
"\n"
"It is recommended for this function to be invoked in your\n"
"application start callback in case you want to register\n"
"new URIs.\n"
msgstr ""
#. TRANSLATORS: def Enumerable.reduce(collection, acc, fun)
#: lib/enum.ex:112 
msgid ""
"Reduces the collection into a value.\n"
"\n"
"Most of the operations in `Enum` are implemented in terms of reduce.\n"
"This function should apply the given `reducer` function to each\n"
"item in the collection and proceed as expected by the returned accumulator.\n"
"\n"
"As an example, here is the implementation of `reduce` for lists:\n"
"\n"
"    def reduce(_,     {:halt, acc}, _fun),   do: {:halted, acc}\n"
"    def reduce(list,  {:suspend, acc}, fun), do: {:suspended, acc, &reduce(list, &1, fun)}\n"
"    def reduce([],    {:cont, acc}, _fun),   do: {:done, acc}\n"
"    def reduce([h|t], {:cont, acc}, fun),    do: reduce(t, fun.(h, acc), fun)\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.!(arg)
#: lib/kernel.ex:1152 
msgid ""
"Receives any argument and returns `true` if it is `false`\n"
"or `nil`. Returns `false` otherwise. Not allowed in guard\n"
"clauses.\n"
"\n"
"## Examples\n"
"\n"
"    iex> !Enum.empty?([])\n"
"    false\n"
"\n"
"    iex> !List.first([])\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: def Macro.escape(expr, opts \\ [])
#: lib/macro.ex:306 
msgid ""
"Recursively escapes a value so it can be inserted\n"
"into a syntax tree.\n"
"\n"
"One may pass `unquote: true` to `escape/2`\n"
"which leaves `unquote` statements unescaped, effectively\n"
"unquoting the contents on escape.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Macro.escape(:foo)\n"
"    :foo\n"
"\n"
"    iex> Macro.escape({:a, :b, :c})\n"
"    {:{}, [], [:a, :b, :c]}\n"
"\n"
"    iex> Macro.escape({:unquote, [], [1]}, unquote: true)\n"
"    1\n"
"\n"
msgstr ""
#. TRANSLATORS: def Exception.format_fa(fun, arity)
#: lib/exception.ex:392 
msgid ""
"Receives an anonymous function and arity and formats it as\n"
"shown in stacktraces. The arity may also be a list of arguments.\n"
"\n"
"## Examples\n"
"\n"
"    Exception.format_fa(fn -> end, 1)\n"
"    #=> \"#Function<...>/1\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Macro.expand(tree, env)
#: lib/macro.ex:944 
msgid ""
"Receives an AST node and expands it until it can no longer\n"
"be expanded.\n"
"\n"
"This function uses `expand_once/2` under the hood. Check\n"
"`expand_once/2` for more information and examples.\n"
msgstr ""
#. TRANSLATORS: def Macro.expand_once(ast, env)
#: lib/macro.ex:826 
msgid ""
"Receives an AST node and expands it once.\n"
"\n"
"The following contents are expanded:\n"
"\n"
"  * Macros (local or remote)\n"
"  * Aliases are expanded (if possible) and return atoms\n"
"  * Pseudo-variables (`__ENV__`, `__MODULE__` and `__DIR__`)\n"
"  * Module attributes reader (`@foo`)\n"
"\n"
"If the expression cannot be expanded, it returns the expression\n"
"itself. Notice that `expand_once/2` performs the expansion just\n"
"once and it is not recursive. Check `expand/2` for expansion\n"
"until the node can no longer be expanded.\n"
"\n"
"## Examples\n"
"\n"
"In the example below, we have a macro that generates a module\n"
"with a function named `name_length` that returns the length\n"
"of the module name. The value of this function will be calculated\n"
"at compilation time and not at runtime.\n"
"\n"
"Consider the implementation below:\n"
"\n"
"    defmacro defmodule_with_length(name, do: block) do\n"
"      length = length(Atom.to_char_list(name))\n"
"\n"
"      quote do\n"
"        defmodule unquote(name) do\n"
"          def name_length, do: unquote(length)\n"
"          unquote(block)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"When invoked like this:\n"
"\n"
"    defmodule_with_length My.Module do\n"
"      def other_function, do: ...\n"
"    end\n"
"\n"
"The compilation will fail because `My.Module` when quoted\n"
"is not an atom, but a syntax tree as follow:\n"
"\n"
"    {:__aliases__, [], [:My, :Module]}\n"
"\n"
"That said, we need to expand the aliases node above to an\n"
"atom, so we can retrieve its length. Expanding the node is\n"
"not straight-forward because we also need to expand the\n"
"caller aliases. For example:\n"
"\n"
"    alias MyHelpers, as: My\n"
"\n"
"    defmodule_with_length My.Module do\n"
"      def other_function, do: ...\n"
"    end\n"
"\n"
"The final module name will be `MyHelpers.Module` and not\n"
"`My.Module`. With `Macro.expand/2`, such aliases are taken\n"
"into consideration. Local and remote macros are also\n"
"expanded. We could rewrite our macro above to use this\n"
"function as:\n"
"\n"
"    defmacro defmodule_with_length(name, do: block) do\n"
"      expanded = Macro.expand(name, __CALLER__)\n"
"      length   = length(Atom.to_char_list(expanded))\n"
"\n"
"      quote do\n"
"        defmodule unquote(name) do\n"
"          def name_length, do: unquote(length)\n"
"          unquote(block)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def Exception.format_stacktrace_entry(entry)
#: lib/exception.ex:333 
msgid ""
"Receives a stacktrace entry and formats it into a string.\n"
msgstr ""
#. TRANSLATORS: def Regex.replace(regex, string, replacement, options \\ [])
#: lib/regex.ex:455 
msgid ""
"Receives a regex, a binary and a replacement, returns a new\n"
"binary where the all matches are replaced by replacement.\n"
"\n"
"The replacement can be either a string or a function. The string\n"
"is used as a replacement for every match and it allows specific\n"
"captures to be accessed via `\\N`, where `N` is the capture. In\n"
"case `\\0` is used, the whole match is inserted.\n"
"\n"
"When the replacement is a function, the function may have arity\n"
"N where each argument maps to a capture, with the first argument\n"
"being the whole match. If the function expects more arguments\n"
"than captures found, the remaining arguments will receive `\"\"`.\n"
"\n"
"## Options\n"
"\n"
"  * `:global` - when `false`, replaces only the first occurrence\n"
"    (defaults to true)\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.replace(~r/d/, \"abc\", \"d\")\n"
"    \"abc\"\n"
"\n"
"    iex> Regex.replace(~r/b/, \"abc\", \"d\")\n"
"    \"adc\"\n"
"\n"
"    iex> Regex.replace(~r/b/, \"abc\", \"[\\\\0]\")\n"
"    \"a[b]c\"\n"
"\n"
"    iex> Regex.replace(~r/a(b|d)c/, \"abcadc\", \"[\\\\1]\")\n"
"    \"[b][d]\"\n"
"\n"
"    iex> Regex.replace(~r/a(b|d)c/, \"abcadc\", fn _, x -> \"[#{x}]\" end)\n"
"    \"[b][d]\"\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.Kernel.Typespec Summary
#: lib/kernel/typespec.ex:1 
msgid ""
"Provides macros and functions for working with typespecs.\n"
"\n"
"Elixir comes with a notation for declaring types and specifications. Elixir is\n"
"dynamically typed, as such typespecs are never used by the compiler to\n"
"optimize or modify code. Still, using typespecs is useful as documentation and\n"
"tools such as [Dialyzer](http://www.erlang.org/doc/man/dialyzer.html) can\n"
"analyze the code with typespecs to find bugs.\n"
"\n"
"The attributes `@type`, `@opaque`, `@typep`, `@spec` and `@callback` available\n"
"in modules are handled by the equivalent macros defined by this module. See\n"
"sub-sections \"Defining a type\" and \"Defining a specification\" below.\n"
"\n"
"## Types and their syntax\n"
"\n"
"The type syntax provided by Elixir is fairly similar to the one in\n"
"[Erlang](http://www.erlang.org/doc/reference_manual/typespec.html).\n"
"\n"
"Most of the built-in types provided in Erlang (for example, `pid()`) are\n"
"expressed the same way: `pid()` or simply `pid`. Parametrized types are also\n"
"supported (`list(integer)`) and so are remote types (`Enum.t`).\n"
"\n"
"Integers and atom literals are allowed as types (ex. `1`, `:atom` or\n"
"`false`). All other types are built of unions of predefined types. Certain\n"
"shorthands are allowed, such as `[...]`, `<<>>` and `{...}`.\n"
"\n"
"### Predefined types\n"
"\n"
"    Type :: any         # the top type, the set of all terms\n"
"          | none        # the bottom type, contains no terms\n"
"          | pid\n"
"          | port\n"
"          | reference\n"
"          | Atom\n"
"          | Bitstring\n"
"          | float\n"
"          | Fun\n"
"          | Integer\n"
"          | List\n"
"          | Map\n"
"          | Tuple\n"
"          | Union\n"
"          | UserDefined # Described in section \"Defining a type\"\n"
"\n"
"    Atom :: atom\n"
"          | ElixirAtom # `:foo`, `:bar`, ...\n"
"\n"
"    Bitstring :: <<>>\n"
"               | << _ :: M >>             # M is a positive integer\n"
"               | << _ :: _ * N >>         # N is a positive integer\n"
"               | << _ :: M, _ :: _ * N >>\n"
"\n"
"    Fun :: (... -> any)    # any function\n"
"         | (... -> Type)   # any arity, returning Type\n"
"         | (() -> Type))\n"
"         | (TList -> Type)\n"
"\n"
"    Integer :: integer\n"
"             | ElixirInteger                # ..., -1, 0, 1, ... 42 ...\n"
"             | ElixirInteger..ElixirInteger # an integer range\n"
"\n"
"    List :: list(Type)                        # proper list ([]-terminated)\n"
"          | improper_list(Type1, Type2)       # Type1=contents, Type2=termination\n"
"          | maybe_improper_list(Type1, Type2) # Type1 and Type2 as above\n"
"          | nonempty_list(Type)               # proper non-empty list\n"
"          | []                                # empty list\n"
"          | [Type]                            # shorthand for list(Type)\n"
"          | [...]                             # shorthand for nonempty_list()\n"
"          | [Type, ...]                       # shorthand for nonempty_list(Type)\n"
"          | [Keyword]\n"
"\n"
"    Map :: map()            # map of any size\n"
"         | %{}              # map of any size\n"
"         | %Struct{}        # struct (see defstruct/1)\n"
"         | %Struct{Keyword}\n"
"         | %{Keyword}\n"
"         | %{Pairs}\n"
"\n"
"    Tuple :: tuple                 # a tuple of any size\n"
"           | {}                    # empty tuple\n"
"           | {TList}\n"
"           | record(Atom)          # record (see Record)\n"
"           | record(Atom, Keyword)\n"
"\n"
"    Keyword :: ElixirAtom: Type\n"
"             | ElixirAtom: Type, Keyword\n"
"\n"
"    Pairs :: Type => Type\n"
"           | Type => Type, Pairs\n"
"\n"
"    TList :: Type\n"
"           | Type, TList\n"
"\n"
"    Union :: Type | Type\n"
"\n"
"### Bit strings\n"
"\n"
"Bit string with a base size of 3:\n"
"\n"
"    << _ :: 3 >>\n"
"\n"
"Bit string with a unit size of 8:\n"
"\n"
"    << _ :: _ * 8 >>\n"
"\n"
"### Anonymous functions\n"
"\n"
"Any anonymous function:\n"
"\n"
"    ((...) -> any)\n"
"    (... -> any)\n"
"\n"
"Anonymous function with arity of zero:\n"
"\n"
"    (() -> type)\n"
"\n"
"Anonymous function with some arity:\n"
"\n"
"    ((type, type) -> type)\n"
"    (type, type -> type)\n"
"\n"
"## Built-in types\n"
"\n"
"Built-in type         | Defined as\n"
":-------------------- | :---------\n"
"`term`                | `any`\n"
"`binary`              | `<< _ :: _ * 8 >>`\n"
"`bitstring`           | `<< _ :: _ * 1 >>`\n"
"`boolean`             | `false` \\| `true`\n"
"`byte`                | `0..255`\n"
"`char`                | `0..0x10ffff`\n"
"`number`              | `integer` \\| `float`\n"
"`char_list`           | `[char]`\n"
"`list`                | `[any]`\n"
"`maybe_improper_list` | `maybe_improper_list(any, any)`\n"
"`nonempty_list`       | `nonempty_list(any)`\n"
"`iodata`              | `iolist` \\| `binary`\n"
"`iolist`              | `maybe_improper_list(byte` \\| `binary` \\| `iolist, binary` \\| `[])`\n"
"`module`              | `atom` \\| `tuple`\n"
"`mfa`                 | `{atom, atom, arity}`\n"
"`arity`               | `0..255`\n"
"`node`                | `atom`\n"
"`timeout`             | `:infinity` \\| `non_neg_integer`\n"
"`no_return`           | `none`\n"
"`fun`                 | `(... -> any)`\n"
"\n"
"\n"
"Some built-in types cannot be expressed with valid syntax according to the\n"
"language defined above.\n"
"\n"
"Built-in type     | Can be interpreted as\n"
":---------------- | :--------------------\n"
"`non_neg_integer` | `0..`\n"
"`pos_integer`     | `1..`\n"
"`neg_integer`     | `..-1`\n"
"\n"
"Types defined in other modules are referred to as \"remote types\", they are\n"
"referenced as `Module.type_name` (ex. `Enum.t` or `String.t`).\n"
"\n"
"## Defining a type\n"
"\n"
"    @type type_name :: type\n"
"    @typep type_name :: type\n"
"    @opaque type_name :: type\n"
"\n"
"A type defined with `@typep` is private. An opaque type, defined with\n"
"`@opaque` is a type where the internal structure of the type will not be\n"
"visible, but the type is still public.\n"
"\n"
"Types can be parametrised by defining variables as parameters, these variables\n"
"can then be used to define the type.\n"
"\n"
"    @type dict(key, value) :: [{key, value}]\n"
"\n"
"## Defining a specification\n"
"\n"
"    @spec function_name(type1, type2) :: return_type\n"
"    @callback function_name(type1, type2) :: return_type\n"
"\n"
"Callbacks are used to define the callbacks functions of behaviours (see\n"
"`Behaviour`).\n"
"\n"
"Guards can be used to restrict type variables given as arguments to the\n"
"function.\n"
"\n"
"    @spec function(arg) :: [arg] when arg: atom\n"
"\n"
"Type variables with no restriction can also be defined.\n"
"\n"
"    @spec function(arg) :: [arg] when arg: var\n"
"\n"
"Specifications can be overloaded just like ordinary functions.\n"
"\n"
"    @spec function(integer) :: atom\n"
"    @spec function(atom)    :: integer\n"
"\n"
"## Notes\n"
"\n"
"Elixir discourages the use of type `string` as it might be confused with\n"
"binaries which are referred to as \"strings\" in Elixir (as opposed to character\n"
"lists). In order to use the type that is called `string` in Erlang, one has to\n"
"use the `char_list` type which is a synonym for `string`. If you use `string`,\n"
"you'll get a warning from the compiler.\n"
"\n"
"If you want to refer to the \"string\" type (the one operated on by functions in\n"
"the `String` module), use `String.t` type instead.\n"
msgstr ""
#. TRANSLATORS: def Set.delete(set, value)
#: lib/set.ex:74 
msgid ""
"Deletes `value` from `set`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> s = Enum.into([1, 2, 3], set_impl.new)\n"
"    iex> Set.delete(s, 4) |> Enum.sort\n"
"    [1, 2, 3]\n"
"\n"
"    iex> s = Enum.into([1, 2, 3], set_impl.new)\n"
"    iex> Set.delete(s, 2) |> Enum.sort\n"
"    [1, 3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Supervisor.delete_child(supervisor, child_id)
#: lib/supervisor.ex:313 
msgid ""
"Deletes the child specification identified by `child_id`.\n"
"\n"
"The corresponding child process must not be running, use `terminate_child/2`\n"
"to terminate it.\n"
"\n"
"If successful, the function returns `:ok`. This function may error with an\n"
"appropriate error tuple if the `child_id` is not found, or if the current\n"
"process is running or being restarted.\n"
"\n"
"This operation is not supported by `simple_one_for_one` supervisors.\n"
msgstr ""
#. TRANSLATORS: def Application.delete_env(app, key, opts \\ [])
#: lib/application.ex:178 
msgid ""
"Deletes the `key` from the given `app` environment.\n"
"\n"
"See `put_env/4` for a description of the options.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms..(left, right)
#: lib/kernel/special_forms.ex:401 
msgid ""
"Defines a remote call or an alias.\n"
"\n"
"The dot (`.`) in Elixir can be used for remote calls:\n"
"\n"
"    iex> String.downcase(\"FOO\")\n"
"    \"foo\"\n"
"\n"
"In this example above, we have used `.` to invoke `downcase` in the\n"
"`String` alias, passing \"FOO\" as argument. We can also use the dot\n"
"for creating aliases:\n"
"\n"
"    iex> Hello.World\n"
"    Hello.World\n"
"\n"
"This time, we have joined two aliases, defining the final alias\n"
"`Hello.World`.\n"
"\n"
"## Syntax\n"
"\n"
"The right side of `.` may be a word starting in upcase, which represents\n"
"an alias, a word starting with lowercase or underscore, any valid language\n"
"operator or any name wrapped in single- or double-quotes. Those are all valid\n"
"examples:\n"
"\n"
"    iex> Kernel.Sample\n"
"    Kernel.Sample\n"
"\n"
"    iex> Kernel.length([1,2,3])\n"
"    3\n"
"\n"
"    iex> Kernel.+(1, 2)\n"
"    3\n"
"\n"
"    iex> Kernel.\"length\"([1,2,3])\n"
"    3\n"
"\n"
"    iex> Kernel.'+'(1, 2)\n"
"    3\n"
"\n"
"Note that `Kernel.\"HELLO\"` will be treated as a remote call and not an alias.\n"
"This choice was done so every time single- or double-quotes are used, we have\n"
"a remote call regardless of the quote contents. This decision is also reflected\n"
"in the quoted expressions discussed below.\n"
"\n"
"## Quoted expression\n"
"\n"
"When `.` is used, the quoted expression may take two distinct\n"
"forms. When the right side starts with a lowercase letter (or\n"
"underscore):\n"
"\n"
"    iex> quote do: String.downcase(\"FOO\")\n"
"    {{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], [\"FOO\"]}\n"
"\n"
"Notice we have an inner tuple, containing the atom `:.` representing\n"
"the dot as first element:\n"
"\n"
"    {:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}\n"
"\n"
"This tuple follows the general quoted expression structure in Elixir,\n"
"with the name as first argument, some keyword list as metadata as second,\n"
"and the number of arguments as third. In this case, the arguments is the\n"
"alias `String` and the atom `:downcase`. The second argument is **always**\n"
"an atom:\n"
"\n"
"    iex> quote do: String.\"downcase\"(\"FOO\")\n"
"    {{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], [\"FOO\"]}\n"
"\n"
"The tuple containing `:.` is wrapped in another tuple, which actually\n"
"represents the function call, and has `\"FOO\"` as argument.\n"
"\n"
"When the right side is an alias (i.e. starts with uppercase), we get instead:\n"
"\n"
"    iex> quote do: Hello.World\n"
"    {:__aliases__, [alias: false], [:Hello, :World]}\n"
"\n"
"We got into more details about aliases in the `__aliases__` special form\n"
"documentation.\n"
"\n"
"## Unquoting\n"
"\n"
"We can also use unquote to generate a remote call in a quoted expression:\n"
"\n"
"    iex> x = :downcase\n"
"    iex> quote do: String.unquote(x)(\"FOO\")\n"
"    {{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], [\"FOO\"]}\n"
"\n"
"Similar to `Kernel.\"HELLO\"`, `unquote(x)` will always generate a remote call,\n"
"independent of the value of `x`. To generate an alias via the quoted expression,\n"
"one needs to rely on `Module.concat/2`:\n"
"\n"
"    iex> x = Sample\n"
"    iex> quote do: Module.concat(String, unquote(x))\n"
"    {{:., [], [{:__aliases__, [alias: false], [:Module]}, :concat]}, [],\n"
"     [{:__aliases__, [alias: false], [:String]}, Sample]}\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Behaviour.defmacrocallback(spec)
#: lib/behaviour.ex:56 
msgid ""
"Define a macro callback according to the given type specification.\n"
msgstr ""
#. TRANSLATORS: defmacro Behaviour.defcallback(spec)
#: lib/behaviour.ex:49 
msgid ""
"Define a function callback according to the given type specification.\n"
msgstr ""
#. TRANSLATORS: def IO.ANSI.default_color()
#: lib/io/ansi.ex:109 
msgid ""
"Default text color"
msgstr ""
#. TRANSLATORS: def IO.ANSI.default_background()
#: lib/io/ansi.ex:112 
msgid ""
"Default background color"
msgstr ""
#. TRANSLATORS: defmacro Kernel.defprotocol(name, list2)
#: lib/kernel.ex:3175 
msgid ""
"Defines a protocol.\n"
"\n"
"A protocol specifies an API that should be defined by its\n"
"implementations.\n"
"\n"
"## Examples\n"
"\n"
"In Elixir, only `false` and `nil` are considered falsy values.\n"
"Everything else evaluates to true in `if` clauses. Depending\n"
"on the application, it may be important to specify a `blank?`\n"
"protocol that returns a boolean for other data types that should\n"
"be considered `blank?`. For instance, an empty list or an empty\n"
"binary could be considered blanks.\n"
"\n"
"We could implement this protocol as follow:\n"
"\n"
"    defprotocol Blank do\n"
"      @doc \"Returns true if data is considered blank/empty\"\n"
"      def blank?(data)\n"
"    end\n"
"\n"
"Now that the protocol is defined, we can implement it. We need\n"
"to implement the protocol for each Elixir type. For example:\n"
"\n"
"    # Integers are never blank\n"
"    defimpl Blank, for: Integer do\n"
"      def blank?(number), do: false\n"
"    end\n"
"\n"
"    # Just empty list is blank\n"
"    defimpl Blank, for: List do\n"
"      def blank?([]), do: true\n"
"      def blank?(_),  do: false\n"
"    end\n"
"\n"
"    # Just the atoms false and nil are blank\n"
"    defimpl Blank, for: Atom do\n"
"      def blank?(false), do: true\n"
"      def blank?(nil),   do: true\n"
"      def blank?(_),     do: false\n"
"    end\n"
"\n"
"And we would have to define the implementation for all types.\n"
"The supported types available are:\n"
"\n"
"  * Structs (see below)\n"
"  * `Tuple`\n"
"  * `Atom`\n"
"  * `List`\n"
"  * `BitString`\n"
"  * `Integer`\n"
"  * `Float`\n"
"  * `Function`\n"
"  * `PID`\n"
"  * `Map`\n"
"  * `Port`\n"
"  * `Reference`\n"
"  * `Any` (see below)\n"
"\n"
"## Protocols + Structs\n"
"\n"
"The real benefit of protocols comes when mixed with structs.\n"
"For instance, Elixir ships with many data types implemented as\n"
"structs, like `HashDict` and `HashSet`. We can implement the\n"
"`Blank` protocol for those types as well:\n"
"\n"
"    defimpl Blank, for: [HashDict, HashSet] do\n"
"      def blank?(enum_like), do: Enum.empty?(enum_like)\n"
"    end\n"
"\n"
"If a protocol is not found for a given type, it will fallback to\n"
"`Any`.\n"
"\n"
"## Fallback to any\n"
"\n"
"In some cases, it may be convenient to provide a default\n"
"implementation for all types. This can be achieved by\n"
"setting `@fallback_to_any` to `true` in the protocol\n"
"definition:\n"
"\n"
"    defprotocol Blank do\n"
"      @fallback_to_any true\n"
"      def blank?(data)\n"
"    end\n"
"\n"
"Which can now be implemented as:\n"
"\n"
"    defimpl Blank, for: Any do\n"
"      def blank?(_), do: true\n"
"    end\n"
"\n"
"One may wonder why such fallback is not true by default.\n"
"\n"
"It is two-fold: first, the majority of protocols cannot\n"
"implement an action in a generic way for all types. In fact,\n"
"providing a default implementation may be harmful, because users\n"
"may rely on the default implementation instead of providing a\n"
"specialized one.\n"
"\n"
"Second, falling back to `Any` adds an extra lookup to all types,\n"
"which is unnecessary overhead unless an implementation for Any is\n"
"required.\n"
"\n"
"## Types\n"
"\n"
"Defining a protocol automatically defines a type named `t`, which\n"
"can be used as:\n"
"\n"
"    @spec present?(Blank.t) :: boolean\n"
"    def present?(blank) do\n"
"      not Blank.blank?(blank)\n"
"    end\n"
"\n"
"The `@spec` above expresses that all types allowed to implement the\n"
"given protocol are valid argument types for the given function.\n"
"\n"
"## Reflection\n"
"\n"
"Any protocol module contains three extra functions:\n"
"\n"
"\n"
"  * `__protocol__/1` - returns the protocol name when `:name` is given, and a\n"
"    keyword list with the protocol functions when `:functions` is given\n"
"\n"
"  * `impl_for/1` - receives a structure and returns the module that\n"
"    implements the protocol for the structure, `nil` otherwise\n"
"\n"
"  * `impl_for!/1` - same as above but raises an error if an implementation is\n"
"    not found\n"
"\n"
"## Consolidation\n"
"\n"
"In order to cope with code loading in development, protocols in\n"
"Elixir provide a slow implementation of protocol dispatching specific\n"
"to development.\n"
"\n"
"In order to speed up dispatching in production environments, where\n"
"all implementations are known up-front, Elixir provides a feature\n"
"called protocol consolidation. For this reason, all protocols are\n"
"compiled with `debug_info` set to true, regardless of the option\n"
"set by `elixirc` compiler. The debug info though may be removed\n"
"after consolidation.\n"
"\n"
"For more information on how to apply protocol consolidation to\n"
"a given project, please check the functions in the `Protocol`\n"
"module or the `mix compile.protocols` task.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.<<>>(args)
#: lib/kernel/special_forms.ex:302 
msgid ""
"Defines a new bitstring.\n"
"\n"
"## Examples\n"
"\n"
"    iex> << 1, 2, 3 >>\n"
"    << 1, 2, 3 >>\n"
"\n"
"## Bitstring types\n"
"\n"
"A bitstring is made of many segments. Each segment has a\n"
"type, which defaults to integer:\n"
"\n"
"    iex> <<1, 2, 3>>\n"
"    <<1, 2, 3>>\n"
"\n"
"Elixir also accepts by default the segment to be a literal\n"
"string or a literal char list, which are by expanded to integers:\n"
"\n"
"    iex> <<0, \"foo\">>\n"
"    <<0, 102, 111, 111>>\n"
"\n"
"Any other type needs to be explicitly tagged. For example,\n"
"in order to store a float type in the binary, one has to do:\n"
"\n"
"    iex> <<3.14 :: float>>\n"
"    <<64, 9, 30, 184, 81, 235, 133, 31>>\n"
"\n"
"This also means that variables need to be explicitly tagged,\n"
"otherwise Elixir defaults to integer:\n"
"\n"
"    iex> rest = \"oo\"\n"
"    iex> <<102, rest>>\n"
"    ** (ArgumentError) argument error\n"
"\n"
"We can solve this by explicitly tagging it as a binary:\n"
"\n"
"    <<102, rest :: binary>>\n"
"\n"
"The type can be integer, float, bitstring/bits, binary/bytes,\n"
"utf8, utf16 or utf32, e.g.:\n"
"\n"
"    <<102 :: float, rest :: binary>>\n"
"\n"
"An integer can be any arbitrary precision integer. A float is an\n"
"IEEE 754 binary32 or binary64 floating point number. A bitstring\n"
"is an arbitrary series of bits. A binary is a special case of\n"
"bitstring that has a total size divisible by 8.\n"
"\n"
"The utf8, utf16, and utf32 types are for unicode codepoints. They\n"
"can also be applied to literal strings and char lists:\n"
"\n"
"    iex> <<\"foo\" :: utf16>>\n"
"    <<0,102,0,111,0,111>>\n"
"\n"
"The bits type is an alias for bitstring. The bytes type is an\n"
"alias for binary.\n"
"\n"
"The signedness can also be given as signed or unsigned. The\n"
"signedness only matters for matching and relevant only for\n"
"integers. If unspecified, it defaults to unsigned. Example:\n"
"\n"
"    iex> <<-100 :: signed, _rest :: binary>> = <<-100, \"foo\">>\n"
"    <<156,102,111,111>>\n"
"\n"
"This match would have failed if we did not specify that the\n"
"value -100 is signed. If we're matching into a variable instead\n"
"of a value, the signedness won't be checked; rather, the number\n"
"will simply be interpreted as having the given (or implied)\n"
"signedness, e.g.:\n"
"\n"
"    iex> <<val, _rest :: binary>> = <<-100, \"foo\">>\n"
"    iex> val\n"
"    156\n"
"\n"
"Here, `val` is interpreted as unsigned.\n"
"\n"
"The endianness of a segment can be big, little or native (the\n"
"latter meaning it will be resolved at VM load time). Many options\n"
"can be given by using `-` as separator:\n"
"\n"
"    <<102 :: integer-native, rest :: binary>>\n"
"\n"
"Or:\n"
"\n"
"    <<102 :: unsigned-big-integer, rest :: binary>>\n"
"\n"
"And so on.\n"
"\n"
"Endianness only makes sense for integers and some UTF code\n"
"point types (utf16 and utf32).\n"
"\n"
"Finally, we can also specify size and unit for each segment. The\n"
"unit is multiplied by the size to give the effective size of\n"
"the segment in bits. The default unit for integers, floats,\n"
"and bitstrings is 1. For binaries, it is 8.\n"
"\n"
"Since integers are default, the default unit is 1. The example below\n"
"matches because the string \"foo\" takes 24 bits and we match it\n"
"against a segment of 24 bits, 8 of which are taken by the integer\n"
"102 and the remaining 16 bits are specified on the rest.\n"
"\n"
"    iex> <<102, _rest :: size(16)>> = \"foo\"\n"
"    \"foo\"\n"
"\n"
"We can also match by specifying size and unit explicitly:\n"
"\n"
"    iex> <<102, _rest :: size(2)-unit(8)>> = \"foo\"\n"
"    \"foo\"\n"
"\n"
"However, if we expect a size of 32, it won't match:\n"
"\n"
"    iex> <<102, _rest :: size(32)>> = \"foo\"\n"
"    ** (MatchError) no match of right hand side value: \"foo\"\n"
"\n"
"Size and unit are not applicable to utf8, utf16, and utf32.\n"
"\n"
"The default size for integers is 8. For floats, it is 64. For\n"
"binaries, it is the size of the binary. Only the last binary\n"
"in a binary match can use the default size (all others must\n"
"have their size specified explicitly).\n"
"\n"
"Size and unit can also be specified using a syntax shortcut\n"
"when passing integer values:\n"
"\n"
"    << x :: 8 >> == << x :: size(8) >>\n"
"    << x :: 8 * 4 >> == << x :: size(8)-unit(4) >>\n"
"    << x :: _ * 4 >> == << x :: unit(4) >>\n"
"\n"
"This syntax reflects the fact the effective size is given by\n"
"multiplying the size by the unit.\n"
"\n"
"For floats, `size * unit` must result in 32 or 64, corresponding\n"
"to binary32 and binary64, respectively.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.Typespec.deftypep(type)
#: lib/kernel/typespec.ex:249 
msgid ""
"Defines a private type.\n"
"This macro is responsible for handling the attribute `@typep`.\n"
"\n"
"## Examples\n"
"\n"
"    @typep my_type :: atom\n"
"\n"
msgstr ""
#. TRANSLATORS: def Macro.decompose_call(arg1)
#: lib/macro.ex:272 
msgid ""
"Decomposes a local or remote call into its remote part (when provided),\n"
"function name and argument list.\n"
"\n"
"Returns `:error` when an invalid call syntax is provided.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Macro.decompose_call(quote do: foo)\n"
"    {:foo, []}\n"
"\n"
"    iex> Macro.decompose_call(quote do: foo())\n"
"    {:foo, []}\n"
"\n"
"    iex> Macro.decompose_call(quote do: foo(1, 2, 3))\n"
"    {:foo, [1, 2, 3]}\n"
"\n"
"    iex> Macro.decompose_call(quote do: Elixir.M.foo(1, 2, 3))\n"
"    {{:__aliases__, [], [:Elixir, :M]}, :foo, [1, 2, 3]}\n"
"\n"
"    iex> Macro.decompose_call(quote do: 42)\n"
"    :error\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Protocol.def(signature)
#: lib/protocol.ex:13 
msgid ""
"Defines a new protocol function.\n"
"\n"
"Protocols do not allow functions to be defined directly, instead, the\n"
"regular `Kernel.def/*` macros are replaced by this macro which\n"
"defines the protocol functions with the appropriate callbacks.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.defmodule(alias, list2)
#: lib/kernel.ex:2618 
msgid ""
"Defines a module given by name with the given contents.\n"
"\n"
"It returns the module name, the module binary and the\n"
"block contents result.\n"
"\n"
"## Examples\n"
"\n"
"    iex> defmodule Foo do\n"
"    ...>   def bar, do: :baz\n"
"    ...> end\n"
"    iex> Foo.bar\n"
"    :baz\n"
"\n"
"## Nesting\n"
"\n"
"Nesting a module inside another module affects its name:\n"
"\n"
"    defmodule Foo do\n"
"      defmodule Bar do\n"
"      end\n"
"    end\n"
"\n"
"In the example above, two modules `Foo` and `Foo.Bar` are created.\n"
"When nesting, Elixir automatically creates an alias, allowing the\n"
"second module `Foo.Bar` to be accessed as `Bar` in the same lexical\n"
"scope.\n"
"\n"
"This means that, if the module `Bar` is moved to another file,\n"
"the references to `Bar` needs to be updated or an alias needs to\n"
"be explicitly set with the help of `Kernel.SpecialForms.alias/2`.\n"
"\n"
"## Dynamic names\n"
"\n"
"Elixir module names can be dynamically generated. This is very\n"
"useful for macros. For instance, one could write:\n"
"\n"
"    defmodule String.to_atom(\"Foo#{1}\") do\n"
"      # contents ...\n"
"    end\n"
"\n"
"Elixir will accept any module name as long as the expression\n"
"returns an atom. Note that, when a dynamic name is used, Elixir\n"
"won't nest the name under the current module nor automatically\n"
"set up an alias.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.defmacro(call, expr \\ nil)
#: lib/kernel.ex:2802 
msgid ""
"Defines a macro with the given name and contents.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule MyLogic do\n"
"      defmacro unless(expr, opts) do\n"
"        quote do\n"
"          if !unquote(expr), unquote(opts)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    require MyLogic\n"
"    MyLogic.unless false do\n"
"      IO.puts \"It works\"\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.defmacrop(call, expr \\ nil)
#: lib/kernel.ex:2812 
msgid ""
"Defines a macro that is private. Private macros are\n"
"only accessible from the same module in which they are defined.\n"
"\n"
"Check `defmacro/2` for more information\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.def(call, expr \\ nil)
#: lib/kernel.ex:2756 
msgid ""
"Defines a function with the given name and contents.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Foo do\n"
"      def bar, do: :baz\n"
"    end\n"
"\n"
"    Foo.bar #=> :baz\n"
"\n"
"A function that expects arguments can be defined as follow:\n"
"\n"
"    defmodule Foo do\n"
"      def sum(a, b) do\n"
"        a + b\n"
"      end\n"
"    end\n"
"\n"
"In the example above, we defined a function `sum` that receives\n"
"two arguments and sums them.\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.defp(call, expr \\ nil)
#: lib/kernel.ex:2779 
msgid ""
"Defines a function that is private. Private functions are\n"
"only accessible from within the module in which they are defined.\n"
"\n"
"Check `def/2` for more information\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Foo do\n"
"      def bar do\n"
"        sum(1, 2)\n"
"      end\n"
"\n"
"      defp sum(a, b), do: a + b\n"
"    end\n"
"\n"
"In the example above, `sum` is private and accessing it\n"
"through `Foo.sum` will raise an error.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.Typespec.defcallback(spec)
#: lib/kernel/typespec.ex:279 
msgid ""
"Defines a callback.\n"
"This macro is responsible for handling the attribute `@callback`.\n"
"\n"
"## Examples\n"
"\n"
"    @callback add(number, number) :: number\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.Typespec.define_type(kind, expr, doc \\ nil, env)
#: lib/kernel/typespec.ex:288 
msgid ""
"Defines a `type`, `typep` or `opaque` by receiving a typespec expression.\n"
msgstr ""
#. TRANSLATORS: def Kernel.Typespec.define_spec(kind, expr, env)
#: lib/kernel/typespec.ex:295 
msgid ""
"Defines a `spec` by receiving a typespec expression.\n"
msgstr ""
#. TRANSLATORS: def Supervisor.Spec.supervise(children, options)
#: lib/supervisor/spec.ex:160 
msgid ""
"Receives a list of children (workers or supervisors) to\n"
"supervise and a set of options.\n"
"\n"
"Returns a tuple containing the supervisor specification.\n"
"\n"
"## Examples\n"
"\n"
"    supervise children, strategy: :one_for_one\n"
"\n"
"## Options\n"
"\n"
"  * `:strategy` - the restart strategy option. It can be either\n"
"    `:one_for_one`, `:rest_for_one`, `:one_for_all`, or\n"
"    `:simple_one_for_one`. You can learn more about strategies\n"
"    in the `Supervisor` module docs.\n"
"\n"
"  * `:max_restarts` - the maximum amount of restarts allowed in\n"
"    a time frame. Defaults to 3.\n"
"\n"
"  * `:max_seconds` - the time frame in which `:max_restarts` applies.\n"
"    Defaults to 5.\n"
"\n"
"The `:strategy` option is required and by default maximum 3 restarts\n"
"are allowed within 5 seconds. Please check the `Supervisor` module for\n"
"a complete description of the available strategies.\n"
msgstr ""
#. TRANSLATORS: def OptionParser.to_argv(enum)
#: lib/option_parser.ex:251 
msgid ""
"Receives a key-value enumerable and convert it to argv.\n"
"\n"
"Keys must be atoms. Keys with nil value are discarded,\n"
"boolean values are converted to `--key` or `--no-key`\n"
"and all other values are converted using `to_string/1`.\n"
"\n"
"## Examples\n"
"\n"
"    iex>  OptionParser.to_argv([foo_bar: \"baz\"])\n"
"    [\"--foo-bar\", \"baz\"]\n"
"\n"
"    iex>  OptionParser.to_argv([bool: true, bool: false, discarded: nil])\n"
"    [\"--bool\", \"--no-bool\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Task.find(tasks, msg)
#: lib/task.ex:227 
msgid ""
"Receives a group of tasks and a message and finds\n"
"a task that matches the given message.\n"
"\n"
"This function returns a tuple with the task and the\n"
"returned value in case the message matches a task that\n"
"exited with success, it raises in case the found task\n"
"failed or `nil` if no task was found.\n"
"\n"
"This function is useful in situations where multiple\n"
"tasks are spawned and their results are collected\n"
"later on. For example, a `GenServer` can spawn tasks,\n"
"store the tasks in a list and later use `Task.find/2`\n"
"to see if incoming messages are from any of the tasks.\n"
msgstr ""
#. TRANSLATORS: def IO.gets(device \\ :erlang.group_leader(), prompt)
#: lib/io.ex:258 
msgid ""
"Reads a line from the IO device. It returns:\n"
"\n"
"  * `data` - the characters in the line terminated\n"
"    by a LF (or end of file)\n"
"\n"
"  * `:eof` - end of file was encountered\n"
"\n"
"  * `{:error, reason}` - other (rare) error condition;\n"
"    for instance, `{:error, :estale}` if reading from an\n"
"    NFS volume\n"
msgstr ""
#. TRANSLATORS: def IO.binread(device \\ :erlang.group_leader(), chars_or_line)
#: lib/io.ex:106 
msgid ""
"Reads `count` characters from the IO device, a whole\n"
"`:line` or the whole device with `:all`.\n"
"\n"
"It returns:\n"
"\n"
"  * `data` - the input characters\n"
"\n"
"  * `:eof` - end of file was encountered\n"
"\n"
"  * `{:error, reason}` - other (rare) error condition;\n"
"    for instance, `{:error, :estale}` if reading from an\n"
"    NFS volume\n"
"\n"
"If `:all` is given, `:eof` is never returned, but an\n"
"empty string in case the device has reached EOF.\n"
"\n"
"Note: do not use this function on IO devices in unicode mode\n"
"as it will return the wrong result.\n"
msgstr ""
#. TRANSLATORS: def IO.read(device \\ :erlang.group_leader(), chars_or_line)
#: lib/io.ex:63 
msgid ""
"Reads `count` characters from the IO device, a whole\n"
"`:line` or the whole device with `:all`.\n"
"\n"
"It returns:\n"
"\n"
"  * `data` - the input characters\n"
"\n"
"  * `:eof` - end of file was encountered\n"
"\n"
"  * `{:error, reason}` - other (rare) error condition;\n"
"    for instance, `{:error, :estale}` if reading from an\n"
"    NFS volume\n"
"\n"
"If `:all` is given, `:eof` is never returned, but an\n"
"empty string in case the device has reached EOF.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.@(expr)
#: lib/kernel.ex:1992 
msgid ""
"Read and write attributes of th current module.\n"
"\n"
"The canonical example for attributes is annotating that a module\n"
"implements the OTP behaviour called `gen_server`:\n"
"\n"
"    defmodule MyServer do\n"
"      @behaviour :gen_server\n"
"      # ... callbacks ...\n"
"    end\n"
"\n"
"By default Elixir supports all Erlang module attributes, but any developer\n"
"can also add custom attributes:\n"
"\n"
"    defmodule MyServer do\n"
"      @my_data 13\n"
"      IO.inspect @my_data #=> 13\n"
"    end\n"
"\n"
"Unlike Erlang, such attributes are not stored in the module by\n"
"default since it is common in Elixir to use such attributes to store\n"
"temporary data. A developer can configure an attribute to behave closer\n"
"to Erlang by calling `Module.register_attribute/3`.\n"
"\n"
"Finally, notice that attributes can also be read inside functions:\n"
"\n"
"    defmodule MyServer do\n"
"      @my_data 11\n"
"      def first_data, do: @my_data\n"
"      @my_data 13\n"
"      def second_data, do: @my_data\n"
"    end\n"
"\n"
"    MyServer.first_data #=> 11\n"
"    MyServer.second_data #=> 13\n"
"\n"
"It is important to note that reading an attribute takes a snapshot of\n"
"its current value. In other words, the value is read at compilation\n"
"time and not at runtime. Check the module `Module` for other functions\n"
"to manipulate module attributes.\n"
msgstr ""
#. TRANSLATORS: def Code.readd_paths()
#: lib/code.ex:64 
msgid ""
"Re-add paths given to the command line to keep their position\n"
"on the overall code path.\n"
"\n"
"Some tools may change the code path by prepending new items but\n"
"still want the paths given by the user to have higher priority.\n"
"Calling this function guarantees the paths are re-added on\n"
"top of the user given ones.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.raise(msg)
#: lib/kernel.ex:1234 
msgid ""
"Raises an exception.\n"
"\n"
"If the argument is a binary, it raises `RuntimeError`\n"
"using the given argument as message.\n"
"\n"
"If an atom, it will become a call to `raise(atom, [])`.\n"
"\n"
"If anything else, it will just raise the given exception.\n"
"\n"
"## Examples\n"
"\n"
"    raise \"Given values do not match\"\n"
"\n"
"    try do\n"
"      1 + :foo\n"
"    rescue\n"
"      x in [ArithmeticError] ->\n"
"        IO.puts \"that was expected\"\n"
"        raise x\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.raise(exception, attrs)
#: lib/kernel.ex:1285 
msgid ""
"Raises an exception.\n"
"\n"
"Calls `.exception` on the given argument passing\n"
"the attributes in order to retrieve the appropriate exception\n"
"structure.\n"
"\n"
"Any module defined via `defexception/1` automatically\n"
"implements `exception(attrs)` callback expected by `raise/2`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> raise(ArgumentError, message: \"Sample\")\n"
"    ** (ArgumentError) Sample\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.reraise(exception, attrs, stacktrace)
#: lib/kernel.ex:1364 
msgid ""
"Raises an exception preserving a previous stacktrace.\n"
"\n"
"Works like `raise/2` but does not generate a new stacktrace.\n"
"\n"
"See `reraise/2` for more details.\n"
"\n"
"## Examples\n"
"\n"
"    try do\n"
"      raise \"Oops\"\n"
"    rescue\n"
"      exception ->\n"
"        stacktrace = System.stacktrace\n"
"        reraise WrapperError, [exception: exception], stacktrace\n"
"    end\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.reraise(msg, stacktrace)
#: lib/kernel.ex:1315 
msgid ""
"Raises an exception preserving a previous stacktrace.\n"
"\n"
"Works like `raise/1` but does not generate a new stacktrace.\n"
"\n"
"Notice that `System.stacktrace` returns the stacktrace\n"
"of the last exception. That said, it is common to assign\n"
"the stacktrace as the first expression inside a `rescue`\n"
"clause as any other exception potentially raised (and\n"
"rescued) in between the rescue clause and the raise call\n"
"may change the `System.stacktrace` value.\n"
"\n"
"## Examples\n"
"\n"
"    try do\n"
"      raise \"Oops\"\n"
"    rescue\n"
"      exception ->\n"
"        stacktrace = System.stacktrace\n"
"        if Exception.message(exception) == \"Oops\" do\n"
"          reraise exception, stacktrace\n"
"        end\n"
"    end\n"
msgstr ""
#. TRANSLATORS: def Keyword.put(keywords, key, value)
#: lib/keyword.ex:302 
msgid ""
"Puts the given `value` under `key`.\n"
"\n"
"If a previous value is already stored, all entries are\n"
"removed and the value is overridden.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.put([a: 1, b: 2], :a, 3)\n"
"    [a: 3, b: 2]\n"
"\n"
"    iex> Keyword.put([a: 1, b: 2, a: 4], :a, 3)\n"
"    [a: 3, b: 2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.put_new(keywords, key, value)
#: lib/keyword.ex:320 
msgid ""
"Puts the given `value` under `key` unless the entry `key`\n"
"already exists.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.put_new([a: 1], :b, 2)\n"
"    [b: 2, a: 1]\n"
"\n"
"    iex> Keyword.put_new([a: 1, b: 2], :a, 3)\n"
"    [a: 1, b: 2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Dict.put_new(dict, key, val)
#: lib/dict.ex:431 
msgid ""
"Puts the given `value` under `key` in `dict` unless `key` already existed.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.put_new(dict, :a, 3)\n"
"    iex> Dict.get(dict, :a)\n"
"    1\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.put_elem(tuple, index, value)
#: lib/kernel.ex:1100 
msgid ""
"Puts the element in `tuple` at the zero-based `index` to the given `value`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Example\n"
"\n"
"    iex> tuple = {:foo, :bar, 3}\n"
"    iex> put_elem(tuple, 0, :baz)\n"
"    {:baz, :bar, 3}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Application.put_env(app, key, value, opts \\ [])
#: lib/application.ex:168 
msgid ""
"Puts the `value` in `key` for the given `app`.\n"
"\n"
"## Options\n"
"\n"
"  * `:timeout`    - the timeout for the change (defaults to 5000ms)\n"
"  * `:persistent` - persists the given value on application load and reloads\n"
"\n"
"If `put_env/4` is called before the application is loaded, the application\n"
"environment values specified in the `.app` file will override the ones\n"
"previously set.\n"
"\n"
"The persistent option can be set to true when there is a need to guarantee\n"
"parameters set with this function will not be overridden by the ones defined\n"
"in the application resource file on load. This means persistent values will\n"
"stick after the application is loaded and also on application reload.\n"
msgstr ""
#. TRANSLATORS: def Module.put_attribute(module, key, value)
#: lib/module.ex:729 
msgid ""
"Puts an Erlang attribute to the given module with the given\n"
"key and value. The semantics of putting the attribute depends\n"
"if the attribute was registered or not via `register_attribute/3`.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule MyModule do\n"
"      Module.put_attribute __MODULE__, :custom_threshold_for_lib, 10\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.put_in(data, keys, value)
#: lib/kernel.ex:1585 
msgid ""
"Puts a value in a nested structure.\n"
"\n"
"Uses the `Access` protocol to traverse the structures\n"
"according to the given `keys`, unless the `key` is a\n"
"function. If the key is a function, it will be invoked\n"
"as specified in `get_and_update_in/3`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> put_in(users, [\"john\", :age], 28)\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"In case any of entries in the middle returns `nil`,\n"
"an error will be raised when trying to access it next.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.put_in(path, value)
#: lib/kernel.ex:1696 
msgid ""
"Puts a value in a nested structure via the given `path`.\n"
"\n"
"This is similar to `put_in/3`, except the path is extracted via\n"
"a macro rather than passing a list. For example:\n"
"\n"
"    put_in(opts[:foo][:bar], :baz)\n"
"\n"
"Is equivalent to:\n"
"\n"
"    put_in(opts, [:foo, :bar], :baz)\n"
"\n"
"Note that in order for this macro to work, the complete path must always\n"
"be visible by this macro. For more information about the supported path\n"
"expressions, please check `get_and_update_in/2` docs.\n"
"\n"
"## Examples\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> put_in(users[\"john\"][:age], 28)\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> put_in(users[\"john\"].age, 28)\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Module.__info__(kind)
#: lib/module.ex:308 
msgid ""
"Provides runtime information about functions and macros defined by the\n"
"module, enables docstring extraction, etc.\n"
"\n"
"Each module gets an `__info__/1` function when it's compiled. The function\n"
"takes one of the following atoms:\n"
"\n"
"  * `:functions`  - keyword list of public functions along with their arities\n"
"\n"
"  * `:macros`     - keyword list of public macros along with their arities\n"
"\n"
"  * `:module`     - module name (`Module == Module.__info__(:module)`)\n"
"\n"
"In addition to the above, you may also pass to `__info__/1` any atom supported\n"
"by Erlang's `module_info` function which also gets defined for each compiled\n"
"module. See http://erlang.org/doc/reference_manual/modules.html#id69430 for\n"
"more information.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.if(condition, clauses)
#: lib/kernel.ex:2151 
msgid ""
"Provides an `if` macro. This macro expects the first argument to\n"
"be a condition and the rest are keyword arguments.\n"
"\n"
"## One-liner examples\n"
"\n"
"    if(foo, do: bar)\n"
"\n"
"In the example above, `bar` will be returned if `foo` evaluates to\n"
"`true` (i.e. it is neither `false` nor `nil`). Otherwise, `nil` will be returned.\n"
"\n"
"An `else` option can be given to specify the opposite:\n"
"\n"
"    if(foo, do: bar, else: baz)\n"
"\n"
"## Blocks examples\n"
"\n"
"Elixir also allows you to pass a block to the `if` macro. The first\n"
"example above would be translated to:\n"
"\n"
"    if foo do\n"
"      bar\n"
"    end\n"
"\n"
"Notice that `do/end` becomes delimiters. The second example would\n"
"then translate to:\n"
"\n"
"    if foo do\n"
"      bar\n"
"    else\n"
"      baz\n"
"    end\n"
"\n"
"If you want to compare more than two clauses, you can use the `cond/1`\n"
"macro.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.||(left, right)
#: lib/kernel.ex:2313 
msgid ""
"Provides a short-circuit operator that evaluates and returns the second\n"
"expression only if the first one does not evaluate to true (i.e. it\n"
"is either nil or false). Returns the first expression otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.empty?([1]) || Enum.empty?([1])\n"
"    false\n"
"\n"
"    iex> List.first([]) || true\n"
"    true\n"
"\n"
"    iex> Enum.empty?([1]) || 1\n"
"    1\n"
"\n"
"    iex> Enum.empty?([]) || throw(:bad)\n"
"    true\n"
"\n"
"Notice that, unlike Erlang's `or` operator,\n"
"this operator accepts any expression as an argument,\n"
"not only booleans, however it is not allowed in guards.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.&&(left, right)
#: lib/kernel.ex:2279 
msgid ""
"Provides a short-circuit operator that evaluates and returns\n"
"the second expression only if the first one evaluates to true\n"
"(i.e. it is not nil nor false). Returns the first expression\n"
"otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.empty?([]) && Enum.empty?([])\n"
"    true\n"
"\n"
"    iex> List.first([]) && true\n"
"    nil\n"
"\n"
"    iex> Enum.empty?([]) && List.first([1])\n"
"    1\n"
"\n"
"    iex> false && throw(:bad)\n"
"    false\n"
"\n"
"Notice that, unlike Erlang's `and` operator,\n"
"this operator accepts any expression as an argument,\n"
"not only booleans, however it is not allowed in guards.\n"
msgstr ""
#. TRANSLATORS: def Agent.cast(agent, fun)
#: lib/agent.ex:274 
msgid ""
"Performs a cast (fire and forget) operation on the agent state.\n"
"\n"
"The function `fun` is sent to the `agent` which invokes the function\n"
"passing the agent state. The function must return the new state.\n"
"\n"
"Note that `cast` returns `:ok` immediately, regardless of whether the\n"
"destination node or agent exists.\n"
msgstr ""
#. TRANSLATORS: def Agent.cast(agent, module, fun, args)
#: lib/agent.ex:286 
msgid ""
"Performs a cast (fire and forget) operation on the agent state.\n"
"\n"
"Same as `cast/2` but a module, function and args are expected\n"
"instead of an anonymous function. The state is added as first\n"
"argument to the given list of args.\n"
msgstr ""
#. TRANSLATORS: Elixir.Enum Summary
#: lib/enum.ex:143 
msgid ""
"Provides a set of algorithms that enumerate over collections according to the\n"
"`Enumerable` protocol:\n"
"\n"
"    iex> Enum.map([1, 2, 3], fn(x) -> x * 2 end)\n"
"    [2,4,6]\n"
"\n"
"Some particular types, like dictionaries, yield a specific format on\n"
"enumeration. For dicts, the argument is always a `{key, value}` tuple:\n"
"\n"
"    iex> dict = %{a: 1, b: 2}\n"
"    iex> Enum.map(dict, fn {k, v} -> {k, v * 2} end)\n"
"    [a: 2, b: 4]\n"
"\n"
"Note that the functions in the `Enum` module are eager: they always start\n"
"the enumeration of the given collection. The `Stream` module allows\n"
"lazy enumeration of collections and provides infinite streams.\n"
"\n"
"Since the majority of the functions in `Enum` enumerate the whole\n"
"collection and return a list as result, infinite streams need to\n"
"be carefully used with such functions, as they can potentially run\n"
"forever. For example:\n"
"\n"
"    Enum.each Stream.cycle([1,2,3]), &IO.puts(&1)\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.delete_at(list, index)
#: lib/list.ex:432 
msgid ""
"Produces a new list by removing the value at the specified `index`.\n"
"Negative indices indicate an offset from the end of the list.\n"
"If `index` is out of bounds, the original `list` is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.delete_at([1, 2, 3], 0)\n"
"    [2, 3]\n"
"\n"
"    iex List.delete_at([1, 2, 3], 10)\n"
"    [1, 2, 3]\n"
"\n"
"    iex> List.delete_at([1, 2, 3], -1)\n"
"    [1, 2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Code.prepend_path(path)
#: lib/code.ex:41 
msgid ""
"Prepend a path to the Erlang VM code path.\n"
"\n"
"The path is expanded with `Path.expand/1` before being prepended.\n"
msgstr ""
#. TRANSLATORS: def IO.ANSI.Docs.print_heading(heading, options \\ [])
#: lib/io/ansi/docs.ex:41 
msgid ""
"Prints the head of the documentation (i.e. the function signature).\n"
"\n"
"See `default_options/0` for docs on the supported options.\n"
msgstr ""
#. TRANSLATORS: def IO.ANSI.Docs.print(doc, options \\ [])
#: lib/io/ansi/docs.ex:57 
msgid ""
"Prints the documentation body.\n"
"\n"
"In addition to the printing string, takes a set of options\n"
"defined in `default_options/1`.\n"
msgstr ""
#. TRANSLATORS: def Kernel.div(left, right)
#: lib/kernel.ex:172 
msgid ""
"Performs an integer division.\n"
"\n"
"Raises an error if one of the arguments is not an integer.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> div(5, 2)\n"
"    2\n"
"\n"
msgstr ""
#. TRANSLATORS: def URI.decode(uri)
#: lib/uri.ex:238 
msgid ""
"Percent-unescape a URI.\n"
"\n"
"## Examples\n"
"\n"
"    iex> URI.decode(\"http%3A%2F%2Felixir-lang.org\")\n"
"    \"http://elixir-lang.org\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def URI.encode(str, predicate \\ &(char_unescaped? / 1))
#: lib/uri.ex:196 
msgid ""
"Percent-escape a URI.\n"
"Accepts `predicate` function as an argument to specify if char can be left as is.\n"
"\n"
"## Example\n"
"\n"
"    iex> URI.encode(\"ftp://s-ite.tld/?value=put it+Ð¹\")\n"
"    \"ftp://s-ite.tld/?value=put%20it+%D0%B9\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.partition(collection, fun)
#: lib/enum.ex:1214 
msgid ""
"Partitions `collection` into two collections, where the first one contains elements\n"
"for which `fun` returns a truthy value, and the second one -- for which `fun`\n"
"returns `false` or `nil`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.partition([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    {[2], [1,3]}\n"
"\n"
msgstr ""
#. TRANSLATORS: def File.open(path, modes \\ [])
#: lib/file.ex:919 
msgid ""
"Opens the given `path` according to the given list of modes.\n"
"\n"
"In order to write and read files, one must use the functions\n"
"in the `IO` module. By default, a file is opened in binary mode\n"
"which requires the functions `IO.binread/2` and `IO.binwrite/2`\n"
"to interact with the file. A developer may pass `:utf8` as an\n"
"option when opening the file and then all other functions from\n"
"`IO` are available, since they work directly with Unicode data.\n"
"\n"
"The allowed modes:\n"
"\n"
"  * `:read` - the file, which must exist, is opened for reading.\n"
"\n"
"  * `:write` - the file is opened for writing. It is created if it does not\n"
"    exist.\n"
"\n"
"    If the file does exists, and if write is not combined with read, the file\n"
"    will be truncated.\n"
"\n"
"  * `:append` - the file will be opened for writing, and it will be created\n"
"    if it does not exist. Every write operation to a file opened with append\n"
"    will take place at the end of the file.\n"
"\n"
"  * `:exclusive` - the file, when opened for writing, is created if it does\n"
"    not exist. If the file exists, open will return `{:error, :eexist}`.\n"
"\n"
"  * `:char_list` - when this term is given, read operations on the file will\n"
"    return char lists rather than binaries.\n"
"\n"
"  * `:compressed` - makes it possible to read or write gzip compressed files.\n"
"\n"
"    The compressed option must be combined with either read or write, but not\n"
"    both. Note that the file size obtained with `stat/1` will most probably\n"
"    not match the number of bytes that can be read from a compressed file.\n"
"\n"
"  * `:utf8` - this option denotes how data is actually stored in the disk\n"
"    file and makes the file perform automatic translation of characters to\n"
"    and from utf-8.\n"
"\n"
"    If data is sent to a file in a format that cannot be converted to the\n"
"    utf-8 or if data is read by a function that returns data in a format that\n"
"    cannot cope with the character range of the data, an error occurs and the\n"
"    file will be closed.\n"
"\n"
"Check http://www.erlang.org/doc/man/file.html#open-2 for more information about\n"
"other options like `:read_ahead` and `:delayed_write`.\n"
"\n"
"This function returns:\n"
"\n"
"  * `{:ok, io_device}` - the file has been opened in the requested mode.\n"
"\n"
"    `io_device` is actually the pid of the process which handles the file.\n"
"    This process is linked to the process which originally opened the file.\n"
"    If any process to which the `io_device` is linked terminates, the file\n"
"    will be closed and the process itself will be terminated.\n"
"\n"
"    An `io_device` returned from this call can be used as an argument to the\n"
"    `IO` module functions.\n"
"\n"
"  * `{:error, reason}` - the file could not be opened.\n"
"\n"
"## Examples\n"
"\n"
"    {:ok, file} = File.open(\"foo.tar.gz\", [:read, :compressed])\n"
"    IO.read(file, :line)\n"
"    File.close(file)\n"
"\n"
msgstr ""
#. TRANSLATORS: def Float.parse(binary)
#: lib/float.ex:33 
msgid ""
"Parses a binary into a float.\n"
"\n"
"If successful, returns a tuple of the form `{float, remainder_of_binary}`.\n"
"Otherwise `:error`.\n"
"\n"
"If a float formated string wants to be directly converted to float,\n"
"`String.to_float/1\" can be used instead.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Float.parse(\"34\")\n"
"    {34.0,\"\"}\n"
"\n"
"    iex> Float.parse(\"34.25\")\n"
"    {34.25,\"\"}\n"
"\n"
"    iex> Float.parse(\"56.5xyz\")\n"
"    {56.5,\"xyz\"}\n"
"\n"
"    iex> Float.parse(\"pi\")\n"
"    :error\n"
"\n"
msgstr ""
#. TRANSLATORS: def IO.ANSI.overlined()
#: lib/io/ansi.ex:121 
msgid ""
"Overlined"
msgstr ""
#. TRANSLATORS: def IO.ANSI.not_overlined()
#: lib/io/ansi.ex:127 
msgid ""
"Not overlined"
msgstr ""
#. TRANSLATORS: def IO.ANSI.not_italic()
#: lib/io/ansi.ex:89 
msgid ""
"Not italic"
msgstr ""
#. TRANSLATORS: def IO.ANSI.not_framed_encircled()
#: lib/io/ansi.ex:124 
msgid ""
"Not framed or encircled"
msgstr ""
#. TRANSLATORS: def Macro.pipe(expr, call_args, position)
#: lib/macro.ex:76 
msgid ""
"Pipes `expr` into the `call_args` at the given `position`.\n"
msgstr ""
#. TRANSLATORS: def Macro.prewalk(ast, fun)
#: lib/macro.ex:154 
msgid ""
"Performs a depth-first, pre-order traversal of quoted expressions.\n"
msgstr ""
#. TRANSLATORS: def Macro.prewalk(ast, acc, fun)
#: lib/macro.ex:163 
msgid ""
"Performs a depth-first, pre-order traversal of quoted expressions\n"
"using an accumulator.\n"
msgstr ""
#. TRANSLATORS: def Macro.postwalk(ast, fun)
#: lib/macro.ex:207 
msgid ""
"Performs a depth-first, post-order traversal of quoted expressions.\n"
msgstr ""
#. TRANSLATORS: def Macro.postwalk(ast, acc, fun)
#: lib/macro.ex:216 
msgid ""
"Performs a depth-first, post-order traversal of quoted expressions\n"
"using an accumulator.\n"
msgstr ""
#. TRANSLATORS: def URI.parse(uri)
#: lib/uri.ex:294 
msgid ""
"Parses a URI into components.\n"
"\n"
"URIs have portions that are handled specially for the particular\n"
"scheme of the URI. For example, http and https have different\n"
"default ports. Such values can be accessed and registered via\n"
"`URI.default_port/1` and `URI.default_port/2`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> URI.parse(\"http://elixir-lang.org/\")\n"
"    %URI{scheme: \"http\", path: \"/\", query: nil, fragment: nil,\n"
"         authority: \"elixir-lang.org\", userinfo: nil,\n"
"         host: \"elixir-lang.org\", port: 80}\n"
"\n"
msgstr ""
#. TRANSLATORS: def OptionParser.parse(argv, opts \\ [])
#: lib/option_parser.ex:109 
msgid ""
"Parses `argv` into a keywords list.\n"
"\n"
"It returns the parsed values, remaining arguments and the\n"
"invalid options.\n"
"\n"
"## Examples\n"
"\n"
"    iex> OptionParser.parse([\"--debug\"])\n"
"    {[debug: true], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--source\", \"lib\"])\n"
"    {[source: \"lib\"], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--source-path\", \"lib\", \"test/enum_test.exs\", \"--verbose\"])\n"
"    {[source_path: \"lib\", verbose: true], [\"test/enum_test.exs\"], []}\n"
"\n"
"By default, Elixir will try to automatically parse switches.\n"
"Switches without an argument, like `--debug` will automatically\n"
"be set to true. Switches followed by a value will be assigned\n"
"to the value, always as strings.\n"
"\n"
"Note Elixir also converts the switches to underscore atoms, as\n"
"`--source-path` becomes `:source_path`, to better suit Elixir\n"
"conventions. This means that option names on the command line cannot contain\n"
"underscores; such options will be reported as `:undefined` (in strict mode)\n"
"or `:invalid` (in basic mode).\n"
"\n"
"## Switches\n"
"\n"
"Many times though, it is better to explicitly list the available\n"
"switches and their formats. The switches can be specified via two\n"
"different options:\n"
"\n"
"  * `:strict` - the switches are strict. Any switch that does not\n"
"    exist in the switch list is treated as an error.\n"
"\n"
"  * `:switches` - defines some switches. Switches that does not\n"
"    exist in the switch list are still attempted to be parsed.\n"
"\n"
"Note only `:strict` or `:switches` may be given at once.\n"
"\n"
"For each switch, the following types are supported:\n"
"\n"
"  * `:boolean` - marks the given switch as a boolean. Boolean switches\n"
"                 never consume the following value unless it is `true` or\n"
"                 `false`.\n"
"  * `:integer` - parses the switch as an integer.\n"
"  * `:float`   - parses the switch as a float.\n"
"  * `:string`  - returns the switch as a string.\n"
"\n"
"If a switch can't be parsed or is not specified in the strict case,\n"
"the option is returned in the invalid options list (third element\n"
"of the returned tuple).\n"
"\n"
"The following extra \"types\" are supported:\n"
"\n"
"  * `:keep` - keeps duplicated items in the list instead of overriding\n"
"\n"
"Examples:\n"
"\n"
"    iex> OptionParser.parse([\"--unlock\", \"path/to/file\"], strict: [unlock: :boolean])\n"
"    {[unlock: true], [\"path/to/file\"], []}\n"
"\n"
"    iex> OptionParser.parse([\"--unlock\", \"--limit\", \"0\", \"path/to/file\"],\n"
"    ...>                    strict: [unlock: :boolean, limit: :integer])\n"
"    {[unlock: true, limit: 0], [\"path/to/file\"], []}\n"
"\n"
"    iex> OptionParser.parse([\"--limit\", \"3\"], strict: [limit: :integer])\n"
"    {[limit: 3], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--limit\", \"xyz\"], strict: [limit: :integer])\n"
"    {[], [], [{\"--limit\", \"xyz\"}]}\n"
"\n"
"    iex> OptionParser.parse([\"--unknown\", \"xyz\"], strict: [])\n"
"    {[], [\"xyz\"], [{\"--unknown\", nil}]}\n"
"\n"
"    iex> OptionParser.parse([\"--limit\", \"3\", \"--unknown\", \"xyz\"],\n"
"    ...>                    switches: [limit: :integer])\n"
"    {[limit: 3, unknown: \"xyz\"], [], []}\n"
"\n"
"## Negation switches\n"
"\n"
"In case a switch is declared as boolean, it may be passed as `--no-SWITCH`\n"
"which will set the option to false:\n"
"\n"
"    iex> OptionParser.parse([\"--no-op\", \"path/to/file\"], switches: [op: :boolean])\n"
"    {[op: false], [\"path/to/file\"], []}\n"
"\n"
"## Aliases\n"
"\n"
"A set of aliases can be given as options too:\n"
"\n"
"    iex> OptionParser.parse([\"-d\"], aliases: [d: :debug])\n"
"    {[debug: true], [], []}\n"
"\n"
msgstr ""
#. TRANSLATORS: def URI.normalize_scheme(scheme)
#: lib/uri.ex:26 
msgid ""
"Normalizes the scheme according to the spec by downcasing it.\n"
msgstr ""
#. TRANSLATORS: def Version.parse(string)
#: lib/version.ex:181 
msgid ""
"Parse a version string into a `Version`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> {:ok, version} = Version.parse(\"2.0.1-alpha1\")\n"
"    iex> version\n"
"    #Version<2.0.1-alpha1>\n"
"\n"
"    iex> Version.parse(\"2.0-alpha1\")\n"
"    :error\n"
"\n"
msgstr ""
#. TRANSLATORS: def Version.parse_requirement(string)
#: lib/version.ex:206 
msgid ""
"Parse a version requirement string into a `Version.Requirement`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> {:ok, req} = Version.parse_requirement(\"== 2.0.1\")\n"
"    iex> req\n"
"    #Version.Requirement<== 2.0.1>\n"
"\n"
"    iex> Version.parse_requirement(\"== == 2.0.1\")\n"
"    :error\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.Record Summary
#: lib/record.ex:1 
msgid ""
"Module to work, define and import records.\n"
"\n"
"Records are simply tuples where the first element is an atom:\n"
"\n"
"    iex> Record.is_record {User, \"john\", 27}\n"
"    true\n"
"\n"
"This module provides conveniences for working with records at\n"
"compilation time, where compile-time field names are used to\n"
"manipulate the tuples, providing fast operations on top of\n"
"the tuples compact structure.\n"
"\n"
"In Elixir, records are used mostly in two situations:\n"
"\n"
"  1. to work with short, internal data\n"
"  2. to interface with Erlang records\n"
"\n"
"The macros `defrecord/3` and `defrecordp/3` can be used to create\n"
"records while `extract/2` can be used to extract records from Erlang\n"
"files.\n"
"\n"
"## Types\n"
"\n"
"Types can be defined for tuples with the `record/2` macro (only available\n"
"in typespecs). Like with the generated record macros it will expand to\n"
"a tuple.\n"
"\n"
"    defmodule MyModule do\n"
"      require Record\n"
"      Record.defrecord :user name: \"john\", age: 25\n"
"\n"
"      @type user :: record(:user, name: String.t, age: integer)\n"
"      # expands to: `@type user :: {:user, String.t, integer}`\n"
"    end\n"
msgstr ""
#. TRANSLATORS: Elixir.Stream Summary
#: lib/stream.ex:1 
msgid ""
"Module for creating and composing streams.\n"
"\n"
"Streams are composable, lazy enumerables. Any enumerable that generates\n"
"items one by one during enumeration is called a stream. For example,\n"
"Elixir's `Range` is a stream:\n"
"\n"
"    iex> range = 1..5\n"
"    1..5\n"
"    iex> Enum.map range, &(&1 * 2)\n"
"    [2,4,6,8,10]\n"
"\n"
"In the example above, as we mapped over the range, the elements being\n"
"enumerated were created one by one, during enumeration. The `Stream`\n"
"module allows us to map the range, without triggering its enumeration:\n"
"\n"
"    iex> range = 1..3\n"
"    iex> stream = Stream.map(range, &(&1 * 2))\n"
"    iex> Enum.map(stream, &(&1 + 1))\n"
"    [3,5,7]\n"
"\n"
"Notice we started with a range and then we created a stream that is\n"
"meant to multiply each item in the range by 2. At this point, no\n"
"computation was done yet. Just when `Enum.map/2` is called we\n"
"enumerate over each item in the range, multiplying it by 2 and adding 1.\n"
"We say the functions in `Stream` are *lazy* and the functions in `Enum`\n"
"are *eager*.\n"
"\n"
"Due to their laziness, streams are useful when working with large\n"
"(or even infinite) collections. When chaining many operations with `Enum`,\n"
"intermediate lists are created, while `Stream` creates a recipe of\n"
"computations that are executed at a later moment. Let's see another\n"
"example:\n"
"\n"
"    1..3 |>\n"
"      Enum.map(&IO.inspect(&1)) |>\n"
"      Enum.map(&(&1 * 2)) |>\n"
"      Enum.map(&IO.inspect(&1))\n"
"    1\n"
"    2\n"
"    3\n"
"    2\n"
"    4\n"
"    6\n"
"    #=> [2,4,6]\n"
"\n"
"Notice that we first printed each item in the list, then multiplied each\n"
"element by 2 and finally printed each new value. In this example, the list\n"
"was enumerated three times. Let's see an example with streams:\n"
"\n"
"    stream = 1..3 |>\n"
"      Stream.map(&IO.inspect(&1)) |>\n"
"      Stream.map(&(&1 * 2)) |>\n"
"      Stream.map(&IO.inspect(&1))\n"
"    Enum.to_list(stream)\n"
"    1\n"
"    2\n"
"    2\n"
"    4\n"
"    3\n"
"    6\n"
"    #=> [2,4,6]\n"
"\n"
"Although the end result is the same, the order in which the items were\n"
"printed changed! With streams, we print the first item and then print\n"
"its double. In this example, the list was enumerated just once!\n"
"\n"
"That's what we meant when we first said that streams are composable,\n"
"lazy enumerables. Notice we could call `Stream.map/2` multiple times,\n"
"effectively composing the streams and they are lazy. The computations\n"
"are performed only when you call a function from the `Enum` module.\n"
"\n"
"## Creating Streams\n"
"\n"
"There are many functions in Elixir's standard library that return\n"
"streams, some examples are:\n"
"\n"
"  * `IO.stream/2`         - streams input lines, one by one\n"
"  * `URI.query_decoder/1` - decodes a query string, pair by pair\n"
"\n"
"This module also provides many convenience functions for creating streams,\n"
"like `Stream.cycle/1`, `Stream.unfold/2`, `Stream.resource/3` and more.\n"
"\n"
"Note the functions in this module are guaranteed to return enumerables.\n"
"Since enumerables can have different shapes (structs, anonymous functions,\n"
"and so on), the functions in this module may return any of those shapes\n"
"and that it may change at any time. For example, a function that today\n"
"returns an anonymous function may return a struct in future releases.\n"
msgstr ""
#. TRANSLATORS: def System.argv(args)
#: lib/system.ex:85 
msgid ""
"Modify command line arguments.\n"
"\n"
"Changes the list of command line arguments. Use it with caution,\n"
"as it destroys any previous argv information.\n"
msgstr ""
#. TRANSLATORS: def Keyword.merge(d1, d2)
#: lib/keyword.ex:356 
msgid ""
"Merges two keyword lists into one. \n"
"\n"
"If they have duplicated keys, the one given in the second argument wins.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4]) |> Enum.sort\n"
"    [a: 3, b: 2, d: 4]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.merge(d1, d2, fun)
#: lib/keyword.ex:375 
msgid ""
"Merges two keyword lists into one. \n"
"\n"
"If they have duplicated keys, the given function is invoked to solve conflicts.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4], fn (_k, v1, v2) ->\n"
"    ...>  v1 + v2\n"
"    ...> end)\n"
"    [a: 4, b: 2, d: 4]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Dict.merge(dict1, dict2, fun \\ fn _k, _v1, v2 -> v2 end)
#: lib/dict.ex:485 
msgid ""
"Merges the dict `dict2` into dict `dict1`.\n"
"\n"
"If one of the `dict2` entries already existed in `dict1`, the\n"
"conflicting entries in `dict2` have higher precedence unless a\n"
"function is given to resolve conflicts.\n"
"\n"
"Notice this function is polymorphic as it merges dicts of any\n"
"type. Each dict implementation also provides a `merge` function,\n"
"but they can only merge dicts of the same type.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict1 = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict2 = Enum.into([a: 3, d: 4], dict_impl.new)\n"
"    iex> dict = Dict.merge(dict1, dict2)\n"
"    iex> [a: Dict.get(dict, :a), b: Dict.get(dict, :b), d: Dict.get(dict, :d)]\n"
"    [a: 3, b: 2, d: 4]\n"
"\n"
"    iex> dict1 = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict2 = Enum.into([a: 3, d: 4], dict_impl.new)\n"
"    iex> dict = Dict.merge(dict1, dict2, fn(_k, v1, v2) ->\n"
"    ...>   v1 + v2\n"
"    ...> end)\n"
"    iex> [a: Dict.get(dict, :a), b: Dict.get(dict, :b), d: Dict.get(dict, :d)]\n"
"    [a: 4, b: 2, d: 4]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.=~(left, right)
#: lib/kernel.ex:1390 
msgid ""
"Matches the term on the left against the regular expression or string on the\n"
"right. Returns true if `left` matches `right` (if it's a regular expression)\n"
"or contains `right` (if it's a string).\n"
"\n"
"## Examples\n"
"\n"
"    iex> \"abcd\" =~ ~r/c(d)/\n"
"    true\n"
"\n"
"    iex> \"abcd\" =~ ~r/e/\n"
"    false\n"
"\n"
"    iex> \"abcd\" =~ \"bc\"\n"
"    true\n"
"\n"
"    iex> \"abcd\" =~ \"ad\"\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.case(condition, clauses)
#: lib/kernel/special_forms.ex:1372 
msgid ""
"Matches the given expression against the given clauses.\n"
"\n"
"## Examples\n"
"\n"
"    case thing do\n"
"      {:selector, i, value} when is_integer(i) ->\n"
"        value\n"
"      value ->\n"
"        value\n"
"    end\n"
"\n"
"In the example above, we match `thing` against each clause \"head\"\n"
"and execute the clause \"body\" corresponding to the first clause\n"
"that matches. If no clause matches, an error is raised.\n"
"\n"
"## Variables handling\n"
"\n"
"Notice that variables bound in a clause \"head\" do not leak to the\n"
"outer context:\n"
"\n"
"    case data do\n"
"      {:ok, value} -> value\n"
"      :error -> nil\n"
"    end\n"
"\n"
"    value #=> unbound variable value\n"
"\n"
"However, variables explicitly bound in the clause \"body\" are\n"
"accessible from the outer context:\n"
"\n"
"    value = 7\n"
"\n"
"    case lucky? do\n"
"      false -> value = 13\n"
"      true  -> true\n"
"    end\n"
"\n"
"    value #=> 7 or 13\n"
"\n"
"In the example above, value is going to be `7` or `13` depending on\n"
"the value of `lucky?`. In case `value` has no previous value before\n"
"case, clauses that do not explicitly bind a value have the variable\n"
"bound to nil.\n"
msgstr ""
#. TRANSLATORS: def Enum.flat_map_reduce(collection, acc, fun)
#: lib/enum.ex:818 
msgid ""
"Maps and reduces a collection, flattening the given results.\n"
"\n"
"It expects an accumulator and a function that receives each stream item\n"
"and an accumulator, and must return a tuple containing a new stream\n"
"(often a list) with the new accumulator or a tuple with `:halt` as first\n"
"element and the accumulator as second.\n"
"\n"
"## Examples\n"
"\n"
"    iex> enum = 1..100\n"
"    iex> n = 3\n"
"    iex> Enum.flat_map_reduce(enum, 0, fn i, acc ->\n"
"    ...>   if acc < n, do: {[i], acc + 1}, else: {:halt, acc}\n"
"    ...> end)\n"
"    {[1,2,3], 3}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.map_join(collection, joiner \\ "", mapper)
#: lib/enum.ex:1004 
msgid ""
"Maps and joins the given `collection` in one pass.\n"
"`joiner` can be either a binary or a list and the\n"
"result will be of the same type as `joiner`. If\n"
"`joiner` is not passed at all, it defaults to an\n"
"empty binary.\n"
"\n"
"All items in the collection must be convertible\n"
"to a binary, otherwise an error is raised.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.map_join([1, 2, 3], &(&1 * 2))\n"
"    \"246\"\n"
"\n"
"    iex> Enum.map_join([1, 2, 3], \" = \", &(&1 * 2))\n"
"    \"2 = 4 = 6\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Inspect.Algebra.surround_many(left, docs, right, opts, fun, separator \\ ",")
#: lib/inspect/algebra.ex:439 
msgid ""
"Maps and glues a collection of items.\n"
"\n"
"It uses the given left and right as surrounding and a separator for\n"
"each item. A limit can be passed which, once reached, stops gluing\n"
"and outputs \"...\" instead.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.surround_many(\"[\", Enum.to_list(1..5), \"]\",\n"
"    ...>         %Inspect.Opts{limit: :infinity}, fn i, _opts -> to_string(i) end)\n"
"    iex> Inspect.Algebra.format(doc, 5) |> IO.iodata_to_binary\n"
"    \"[1,\\n 2,\\n 3,\\n 4,\\n 5]\"\n"
"\n"
"    iex> doc = Inspect.Algebra.surround_many(\"[\", Enum.to_list(1..5), \"]\",\n"
"    ...>         %Inspect.Opts{limit: 3}, fn i, _opts -> to_string(i) end)\n"
"    iex> Inspect.Algebra.format(doc, 20) |> IO.iodata_to_binary\n"
"    \"[1, 2, 3, ...]\"\n"
"\n"
"    iex> doc = Inspect.Algebra.surround_many(\"[\", Enum.to_list(1..5), \"]\",\n"
"    ...>         %Inspect.Opts{limit: 3}, fn i, _opts -> to_string(i) end, \"!\")\n"
"    iex> Inspect.Algebra.format(doc, 20) |> IO.iodata_to_binary\n"
"    \"[1! 2! 3! ...]\"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.defoverridable(tuples)
#: lib/kernel.ex:3221 
msgid ""
"Makes the given functions in the current module overridable. An overridable\n"
"function is lazily defined, allowing a developer to customize it.\n"
"\n"
"## Example\n"
"\n"
"    defmodule DefaultMod do\n"
"      defmacro __using__(_opts) do\n"
"        quote do\n"
"          def test(x, y) do\n"
"            x + y\n"
"          end\n"
"\n"
"          defoverridable [test: 2]\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    defmodule InheritMod do\n"
"      use DefaultMod\n"
"\n"
"      def test(x, y) do\n"
"        x * y + super(x, y)\n"
"      end\n"
"    end\n"
"\n"
"As seen as in the example `super` can be used to call the default\n"
"implementation.\n"
msgstr ""
#. TRANSLATORS: def Module.make_overridable(module, tuples)
#: lib/module.ex:684 
msgid ""
"Makes the given functions in `module` overridable.\n"
"An overridable function is lazily defined, allowing a\n"
"developer to customize it. See `Kernel.defoverridable/1` for\n"
"more information and documentation.\n"
msgstr ""
#. TRANSLATORS: def System.find_executable(program)
#: lib/system.ex:240 
msgid ""
"Locates an executable on the system.\n"
"\n"
"This function looks up an executable program given\n"
"its name using the environment variable PATH on Unix\n"
"and Windows. It also considers the proper executable\n"
"extension for each OS, so for Windows it will try to\n"
"lookup files with `.com`, `.cmd` or similar extensions.\n"
msgstr ""
#. TRANSLATORS: def Application.load(app)
#: lib/application.ex:268 
msgid ""
"Loads the given `app`.\n"
"\n"
"In order to be loaded, an `.app` file must be in the load paths.\n"
"All `:included_applications` will also be loaded.\n"
"\n"
"Loading the application does not start it nor load its modules, but\n"
"it does load its environment.\n"
msgstr ""
#. TRANSLATORS: def Code.load_file(file, relative_to \\ nil)
#: lib/code.ex:284 
msgid ""
"Load the given file.\n"
"\n"
"Accepts `relative_to` as an argument to tell where the file is located.\n"
"If the file was already required/loaded, loads it again.\n"
"\n"
"It returns a list of tuples `{ModuleName, <<byte_code>>}`, one tuple for\n"
"each module defined in the file.\n"
"\n"
"Notice that if `load_file` is invoked by different processes concurrently,\n"
"the target file will be loaded concurrently many times. Check `require_file/2`\n"
"if you don't want a file to be loaded concurrently.\n"
msgstr ""
#. TRANSLATORS: def System.argv()
#: lib/system.ex:74 
msgid ""
"List command line arguments.\n"
"\n"
"Returns the list of command line arguments passed to the program.\n"
msgstr ""
#. TRANSLATORS: def Code.loaded_files()
#: lib/code.ex:12 
msgid ""
"List all loaded files.\n"
msgstr ""
#. TRANSLATORS: def Enum.concat(enumerables)
#: lib/enum.ex:387 
msgid ""
"Given an enumerable of enumerables, concatenate the enumerables into a single list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.concat([1..3, 4..6, 7..9])\n"
"    [1,2,3,4,5,6,7,8,9]\n"
"\n"
"    iex> Enum.concat([[1, [2], 3], [4], [5, 6]])\n"
"    [1,[2],3,4,5,6]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Path.join(left, right)
#: lib/path.ex:466 
msgid ""
"Joins two paths.\n"
"\n"
"The right path will always be expanded to its relative format\n"
"and any trailing slash is removed on join.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.join(\"foo\", \"bar\")\n"
"    \"foo/bar\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.join(collection, joiner \\ "")
#: lib/enum.ex:946 
msgid ""
"Joins the given `collection` according to `joiner`.\n"
"`joiner` can be either a binary or a list and the\n"
"result will be of the same type as `joiner`. If\n"
"`joiner` is not passed at all, it defaults to an\n"
"empty binary.\n"
"\n"
"All items in the collection must be convertible\n"
"to a binary, otherwise an error is raised.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.join([1, 2, 3])\n"
"    \"123\"\n"
"\n"
"    iex> Enum.join([1, 2, 3], \" = \")\n"
"    \"1 = 2 = 3\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def IO.ANSI.italic()
#: lib/io/ansi.ex:54 
msgid ""
"Italic: on. Not widely supported. Sometimes treated as inverse."
msgstr ""
#. TRANSLATORS: def Kernel.apply(fun, args)
#: lib/kernel.ex:71 
msgid ""
"Invokes the given `fun` with the array of arguments `args`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> apply(fn x -> x * 2 end, [2])\n"
"    4\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.apply(module, fun, args)
#: lib/kernel.ex:87 
msgid ""
"Invokes the given `fun` from `module` with the array of arguments `args`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> apply(Enum, :reverse, [[1, 2, 3]])\n"
"    [3,2,1]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.each(collection, fun)
#: lib/enum.ex:536 
msgid ""
"Invokes the given `fun` for each item in the `collection`.\n"
"Returns `:ok`.\n"
"\n"
"## Examples\n"
"\n"
"    Enum.each([\"some\", \"example\"], fn(x) -> IO.puts x end)\n"
"    \"some\"\n"
"    \"example\"\n"
"    #=> :ok\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.any?(collection, fun \\ fn x -> x end)
#: lib/enum.ex:259 
msgid ""
"Invokes the given `fun` for each item in the `collection` and returns `true` if\n"
"at least one invocation returns `true`. Returns `false` otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.any?([2, 4, 6], fn(x) -> rem(x, 2) == 1 end)\n"
"    false\n"
"\n"
"    iex> Enum.any?([2, 3, 4], fn(x) -> rem(x, 2) == 1 end)\n"
"    true\n"
"\n"
"If no function is given, it defaults to checking if\n"
"at least one item in the collection evaluates to `true`.\n"
"\n"
"    iex> Enum.any?([false, false, false])\n"
"    false\n"
"\n"
"    iex> Enum.any?([false, true, false])\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.all?(collection, fun \\ fn x -> x end)
#: lib/enum.ex:222 
msgid ""
"Invokes the given `fun` for each item in the `collection` and returns `false`\n"
"if at least one invocation returns `false`. Otherwise returns `true`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.all?([2, 4, 6], fn(x) -> rem(x, 2) == 0 end)\n"
"    true\n"
"\n"
"    iex> Enum.all?([2, 3, 4], fn(x) -> rem(x, 2) == 0 end)\n"
"    false\n"
"\n"
"If no function is given, it defaults to checking if\n"
"all items in the collection evaluate to `true`.\n"
"\n"
"    iex> Enum.all?([1, 2, 3])\n"
"    true\n"
"\n"
"    iex> Enum.all?([1, nil, 3])\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.map_reduce(collection, acc, fun)
#: lib/enum.ex:1035 
msgid ""
"Invokes the given `fun` for each item in the `collection`\n"
"while also keeping an accumulator. Returns a tuple where\n"
"the first element is the mapped collection and the second\n"
"one is the final accumulator.\n"
"\n"
"For dicts, the first tuple element must be a `{key, value}`\n"
"tuple.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.map_reduce([1, 2, 3], 0, fn(x, acc) -> {x * 2, x + acc} end)\n"
"    {[2, 4, 6], 6}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.reduce(collection, fun)
#: lib/enum.ex:1282 
msgid ""
"Invokes `fun` for each element in the collection passing that element and the\n"
"accumulator `acc` as arguments. `fun`'s return value is stored in `acc`.\n"
"The first element of the collection is used as the initial value of `acc`.\n"
"Returns the accumulator.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reduce([1, 2, 3, 4], fn(x, acc) -> x * acc end)\n"
"    24\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.reduce(collection, acc, fun)
#: lib/enum.ex:1260 
msgid ""
"Invokes `fun` for each element in the collection passing that element and the\n"
"accumulator `acc` as arguments. `fun`'s return value is stored in `acc`.\n"
"Returns the accumulator.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reduce([1, 2, 3], 0, fn(x, acc) -> x + acc end)\n"
"    6\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.intersperse(collection, element)
#: lib/enum.ex:850 
msgid ""
"Intersperses `element` between each element of the enumeration.\n"
"\n"
"Complexity: O(n)\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.intersperse([1, 2, 3], 0)\n"
"    [1, 0, 2, 0, 3]\n"
"\n"
"    iex> Enum.intersperse([1], 0)\n"
"    [1]\n"
"\n"
"    iex> Enum.intersperse([], 0)\n"
"    []\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.__aliases__(args)
#: lib/kernel/special_forms.ex:1319 
msgid ""
"Internal special form to hold aliases information.\n"
"\n"
"It is usually compiled to an atom:\n"
"\n"
"    iex> quote do: Foo.Bar\n"
"    {:__aliases__, [alias: false], [:Foo, :Bar]}\n"
"\n"
"Elixir represents `Foo.Bar` as `__aliases__` so calls can be\n"
"unambiguously identified by the operator `:.`. For example:\n"
"\n"
"    iex> quote do: Foo.bar\n"
"    {{:., [], [{:__aliases__, [alias: false], [:Foo]}, :bar]}, [], []}\n"
"\n"
"Whenever an expression iterator sees a `:.` as the tuple key,\n"
"it can be sure that it represents a call and the second argument\n"
"in the list is an atom.\n"
"\n"
"On the other hand, aliases holds some properties:\n"
"\n"
"  1. The head element of aliases can be any term that must expand to\n"
"     an atom at compilation time.\n"
"\n"
"  2. The tail elements of aliases are guaranteed to always be atoms.\n"
"\n"
"  3. When the head element of aliases is the atom `:Elixir`, no expansion happen.\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.__block__(args)
#: lib/kernel/special_forms.ex:1220 
msgid ""
"Internal special form for block expressions.\n"
"\n"
"This is the special form used whenever we have a block\n"
"of expressions in Elixir. This special form is private\n"
"and should not be invoked directly:\n"
"\n"
"    iex> quote do: (1; 2; 3)\n"
"    {:__block__, [], [1, 2, 3]}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Application.app_dir(app)
#: lib/application.ex:308 
msgid ""
"Gets the directory for app.\n"
"\n"
"This information is returned based on the code path. Here is an\n"
"example:\n"
"\n"
"    File.mkdir_p!(\"foo/ebin\")\n"
"    Code.prepend_path(\"foo/ebin\")\n"
"    Application.app_dir(:foo)\n"
"    #=> \"foo\"\n"
"\n"
"Even though the directory is empty and there is no `.app` file\n"
"it is considered the application directory based on the name\n"
"\"foo/ebin\". The name may contain a dash `-` which is considered\n"
"to be the app version and it is removed for the lookup purposes:\n"
"\n"
"    File.mkdir_p!(\"bar-123/ebin\")\n"
"    Code.prepend_path(\"bar-123/ebin\")\n"
"    Application.app_dir(:bar)\n"
"    #=> \"bar-123\"\n"
"\n"
"For more information on code paths, check the `Code` module in\n"
"Elixir and also Erlang's `:code` module.\n"
msgstr ""
#. TRANSLATORS: def Code.compiler_options()
#: lib/code.ex:327 
msgid ""
"Gets the compilation options from the code server.\n"
"\n"
"Check `compiler_options/1` for more information.\n"
msgstr ""
#. TRANSLATORS: def Code.eval_quoted(quoted, binding \\ [], opts \\ [])
#: lib/code.ex:163 
msgid ""
"Evaluate the quoted contents.\n"
"\n"
"See `eval_string/3` for a description of arguments and return values.\n"
"\n"
"## Examples\n"
"\n"
"    iex> contents = quote(do: var!(a) + var!(b))\n"
"    iex> Code.eval_quoted(contents, [a: 1, b: 2], file: __ENV__.file, line: __ENV__.line)\n"
"    {3, [a: 1, b: 2]}\n"
"\n"
"For convenience, you can pass `__ENV__` as the `opts` argument and\n"
"all options will be automatically extracted from the current environment:\n"
"\n"
"    iex> contents = quote(do: var!(a) + var!(b))\n"
"    iex> Code.eval_quoted(contents, [a: 1, b: 2], __ENV__)\n"
"    {3, [a: 1, b: 2]}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Code.eval_string(string, binding \\ [], opts \\ [])
#: lib/code.ex:131 
msgid ""
"Evaluate the contents given by `string`.\n"
"\n"
"The `binding` argument is a keyword list of variable bindings.\n"
"The `opts` argument is a keyword list of environment options.\n"
"\n"
"Those options can be:\n"
"\n"
"  * `:file`               - the file to be considered in the evaluation\n"
"  * `:line`               - the line on which the script starts\n"
"  * `:delegate_locals_to` - delegate local calls to the given module,\n"
"                            the default is to not delegate\n"
"\n"
"Additionally, the following scope values can be configured:\n"
"\n"
"  * `:aliases` - a list of tuples with the alias and its target\n"
"\n"
"  * `:requires` - a list of modules required\n"
"\n"
"  * `:functions` - a list of tuples where the first element is a module\n"
"    and the second a list of imported function names and arity; the list\n"
"    of function names and arity must be sorted\n"
"\n"
"  * `:macros` - a list of tuples where the first element is a module\n"
"    and the second a list of imported macro names and arity; the list\n"
"    of function names and arity must be sorted\n"
"\n"
"Notice that setting any of the values above overrides Elixir's default\n"
"values. For example, setting `:requires` to `[]`, will no longer\n"
"automatically require the `Kernel` module; in the same way setting\n"
"`:macros` will no longer auto-import `Kernel` macros like `if`, `case`,\n"
"etc.\n"
"\n"
"Returns a tuple of the form `{value, binding}`,\n"
"where `value` is the value returned from evaluating `string`.\n"
"If an error occurs while evaluating `string` an exception will be raised.\n"
"\n"
"`binding` is a keyword list with the value of all variable bindings\n"
"after evaluating `string`. The binding key is usually an atom, but it\n"
"may be a tuple for variables defined in a different context.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Code.eval_string(\"a + b\", [a: 1, b: 2], file: __ENV__.file, line: __ENV__.line)\n"
"    {3, [a: 1, b: 2]}\n"
"\n"
"    iex> Code.eval_string(\"c = a + b\", [a: 1, b: 2], __ENV__)\n"
"    {3, [a: 1, b: 2, c: 3]}\n"
"\n"
"    iex> Code.eval_string(\"a = a + b\", [a: 1, b: 2])\n"
"    {3, [a: 3, b: 2]}\n"
"\n"
"For convenience, you can pass `__ENV__` as the `opts` argument and\n"
"all imports, requires and aliases defined in the current environment\n"
"will be automatically carried over:\n"
"\n"
"    iex> Code.eval_string(\"a + b\", [a: 1, b: 2], __ENV__)\n"
"    {3, [a: 1, b: 2]}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Code.eval_file(file, relative_to \\ nil)
#: lib/code.ex:266 
msgid ""
"Evals the given file.\n"
"\n"
"Accepts `relative_to` as an argument to tell where the file is located.\n"
"\n"
"While `load_file` loads a file and returns the loaded modules and their\n"
"byte code, `eval_file` simply evaluates the file contents and returns the\n"
"evaluation result and its bindings.\n"
msgstr ""
#. TRANSLATORS: def Exception.message(exception)
#: lib/exception.ex:43 
msgid ""
"Gets the message for an exception.\n"
msgstr ""
#. TRANSLATORS: def File.cwd()
#: lib/file.ex:1003 
msgid ""
"Gets the current working directory.\n"
"\n"
"In rare circumstances, this function can fail on Unix. It may happen\n"
"if read permission does not exist for the parent directories of the\n"
"current directory. For this reason, returns `{:ok, cwd}` in case\n"
"of success, `{:error, reason}` otherwise.\n"
msgstr ""
#. TRANSLATORS: def Kernel.LexicalTracker.dest(arg)
#: lib/kernel/lexical_tracker.ex:29 
msgid ""
"Gets the destination the lexical scope is meant to\n"
"compile to.\n"
msgstr ""
#. TRANSLATORS: def Agent.get_and_update(agent, fun, timeout \\ 5000)
#: lib/agent.ex:222 
msgid ""
"Gets and updates the agent state in one operation.\n"
"\n"
"The function `fun` is sent to the `agent` which invokes the function\n"
"passing the agent state. The function must return a tuple with two\n"
"elements, the first being the value to return (i.e. the `get` value)\n"
"and the second one is the new state.\n"
"\n"
"A timeout can also be specified (it has a default value of 5000).\n"
msgstr ""
#. TRANSLATORS: def Agent.get_and_update(agent, module, fun, args, timeout \\ 5000)
#: lib/agent.ex:234 
msgid ""
"Gets and updates the agent state in one operation.\n"
"\n"
"Same as `get_and_update/3` but a module, function and args are expected\n"
"instead of an anonymous function. The state is added as first\n"
"argument to the given list of args.\n"
msgstr ""
#. TRANSLATORS: def Agent.get(agent, fun, timeout \\ 5000)
#: lib/agent.ex:195 
msgid ""
"Gets an agent value via the given function.\n"
"\n"
"The function `fun` is sent to the `agent` which invokes the function\n"
"passing the agent state. The result of the function invocation is\n"
"returned.\n"
"\n"
"A timeout can also be specified (it has a default value of 5000).\n"
msgstr ""
#. TRANSLATORS: def Agent.get(agent, module, fun, args, timeout \\ 5000)
#: lib/agent.ex:207 
msgid ""
"Gets an agent value via the given function.\n"
"\n"
"Same as `get/3` but a module, function and args are expected\n"
"instead of an anonymous function. The state is added as first\n"
"argument to the given list of args.\n"
msgstr ""
#. TRANSLATORS: def Access.get_and_update(container, key, fun)
#: lib/access.ex:44 
msgid ""
"Gets a value and updates the given `key` in one pass.\n"
"\n"
"The function must receive the value for the given `key`\n"
"(or `nil` if the key doesn't exist in `container`) and\n"
"the function must return a tuple containing the `get`\n"
"value and the new value to be stored in the `container`.\n"
msgstr ""
#. TRANSLATORS: def Application.format_error(reason)
#: lib/application.ex:329 
msgid ""
"Formats the error reason returned by `start/2`,\n"
"`ensure_started/2`, `stop/1`, `load/1` and `unload/1`,\n"
"returns a string.\n"
msgstr ""
#. TRANSLATORS: def Enum.fetch(collection, n)
#: lib/enum.ex:596 
msgid ""
"Finds the element at the given index (zero-based).\n"
"\n"
"Returns `{:ok, element}` if found, otherwise `:error`.\n"
"\n"
"A negative index can be passed, which means the collection is\n"
"enumerated once and the index is counted from the end (i.e.\n"
"`-1` fetches the last element).\n"
"\n"
"Note this operation takes linear time. In order to access\n"
"the element at index `n`, it will need to traverse `n`\n"
"previous elements.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.fetch([2, 4, 6], 0)\n"
"    {:ok, 2}\n"
"\n"
"    iex> Enum.fetch([2, 4, 6], 2)\n"
"    {:ok, 6}\n"
"\n"
"    iex> Enum.fetch([2, 4, 6], 4)\n"
"    :error\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.at(collection, n, default \\ nil)
#: lib/enum.ex:296 
msgid ""
"Finds the element at the given index (zero-based).\n"
"\n"
"Returns `default` if index is out of bounds.\n"
"\n"
"Note this operation takes linear time. In order to access\n"
"the element at index `n`, it will need to traverse `n`\n"
"previous elements.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.at([2, 4, 6], 0)\n"
"    2\n"
"\n"
"    iex> Enum.at([2, 4, 6], 2)\n"
"    6\n"
"\n"
"    iex> Enum.at([2, 4, 6], 4)\n"
"    nil\n"
"\n"
"    iex> Enum.at([2, 4, 6], 4, :none)\n"
"    :none\n"
"\n"
msgstr ""
#. TRANSLATORS: def IO.ANSI.faint()
#: lib/io/ansi.ex:51 
msgid ""
"Faint (decreased intensity), not widely supported"
msgstr ""
#. TRANSLATORS: def Kernel.get_in(data, keys)
#: lib/kernel.ex:1550 
msgid ""
"Gets a value from a nested structure.\n"
"\n"
"Uses the `Access` protocol to traverse the structures\n"
"according to the given `keys`, unless the `key` is a\n"
"function.\n"
"\n"
"If a key is a function, the function will be invoked\n"
"passing three arguments, the operation (`:get`), the\n"
"data to be accessed, and a function to be invoked next.\n"
"\n"
"This means `get_in/2` can be extended to provide\n"
"custom lookups. The downside is that functions cannot be\n"
"stored as keys in the accessed data structures.\n"
"\n"
"## Examples\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> get_in(users, [\"john\", :age])\n"
"    27\n"
"\n"
"In case any of entries in the middle returns `nil`, `nil` will be returned\n"
"as per the Access protocol:\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> get_in(users, [\"unknown\", :age])\n"
"    nil\n"
"\n"
"When one of the keys is a function, the function is invoked.\n"
"In the example below, we use a function to get all the maps\n"
"inside a list:\n"
"\n"
"    iex> users = [%{name: \"john\", age: 27}, %{name: \"meg\", age: 23}]\n"
"    iex> all = fn :get, data, next -> Enum.map(data, next) end\n"
"    iex> get_in(users, [all, :age])\n"
"    [27, 23]\n"
"\n"
"If the previous value before invoking the function is nil,\n"
"the function *will* receive nil as a value and must handle it\n"
"accordingly.\n"
msgstr ""
#. TRANSLATORS: def Kernel.get_and_update_in(data, keys, fun)
#: lib/kernel.ex:1657 
msgid ""
"Gets a value and updates a nested structure.\n"
"\n"
"It expects a tuple to be returned, containing the value\n"
"retrieved and the update one.\n"
"\n"
"Uses the `Access` protocol to traverse the structures\n"
"according to the given `keys`, unless the `key` is a\n"
"function.\n"
"\n"
"If a key is a function, the function will be invoked\n"
"passing three arguments, the operation (`:get_and_update`),\n"
"the data to be accessed, and a function to be invoked next.\n"
"\n"
"This means `get_and_update_in/3` can be extended to provide\n"
"custom lookups. The downside is that functions cannot be stored\n"
"as keys in the accessed data structures.\n"
"\n"
"## Examples\n"
"\n"
"This function is useful when there is a need to retrieve the current\n"
"value (or something calculated in function of the current value) and\n"
"update it at the same time. For example, it could be used to increase\n"
"the age of a user by one and return the previous age in one pass:\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> get_and_update_in(users, [\"john\", :age], &{&1, &1 + 1})\n"
"    {27, %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}}\n"
"\n"
"When one of the keys is a function, the function is invoked.\n"
"In the example below, we use a function to get and increment all\n"
"ages inside a list:\n"
"\n"
"    iex> users = [%{name: \"john\", age: 27}, %{name: \"meg\", age: 23}]\n"
"    iex> all = fn :get_and_update, data, next ->\n"
"    ...>   Enum.map(data, next) |> :lists.unzip\n"
"    ...> end\n"
"    iex> get_and_update_in(users, [all, :age], &{&1, &1 + 1})\n"
"    {[27, 23], [%{name: \"john\", age: 28}, %{name: \"meg\", age: 24}]}\n"
"\n"
"If the previous value before invoking the function is nil,\n"
"the function *will* receive `nil` as a value and must handle it\n"
"accordingly (be it by failing or providing a sane default).\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.get_and_update_in(path, fun)
#: lib/kernel.ex:1783 
msgid ""
"Gets a value and updates a nested data structure via the given `path`.\n"
"\n"
"This is similar to `get_and_update_in/3`, except the path is extracted\n"
"via a macro rather than passing a list. For example:\n"
"\n"
"    get_and_update_in(opts[:foo][:bar], &{&1, &1 + 1})\n"
"\n"
"Is equivalent to:\n"
"\n"
"    get_and_update_in(opts, [:foo, :bar], &{&1, &1 + 1})\n"
"\n"
"Note that in order for this macro to work, the complete path must always\n"
"be visible by this macro. See the Paths section below.\n"
"\n"
"## Examples\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> get_and_update_in(users[\"john\"].age, &{&1, &1 + 1})\n"
"    {27, %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}}\n"
"\n"
"## Paths\n"
"\n"
"A path may start with a variable, local or remote call, and must be\n"
"followed by one or more:\n"
"\n"
"  * `foo[bar]` - access a field; in case an intermediate field is not\n"
"    present or returns nil, an empty map is used\n"
"\n"
"  * `foo.bar` - access a map/struct field; in case the field is not\n"
"    present, an error is raised\n"
"\n"
"Here are some valid paths:\n"
"\n"
"    users[\"john\"][:age]\n"
"    users[\"john\"].age\n"
"    User.all[\"john\"].age\n"
"    all_users()[\"john\"].age\n"
"\n"
"Here are some invalid ones:\n"
"\n"
"    # Does a remote call after the initial value\n"
"    users[\"john\"].do_something(arg1, arg2)\n"
"\n"
"    # Does not access any field\n"
"    users\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.binary_part(binary, start, length)
#: lib/kernel.ex:112 
msgid ""
"Extracts the part of the binary starting at `start` with length `length`.\n"
"Binaries are zero-indexed.\n"
"\n"
"If start or length references in any way outside the binary, an\n"
"`ArgumentError` exception is raised.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> binary_part(\"foo\", 1, 2)\n"
"    \"oo\"\n"
"\n"
"A negative length can be used to extract bytes at the end of a binary:\n"
"\n"
"    iex> binary_part(\"foo\", 3, -1)\n"
"    \"o\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Code.ensure_loaded?(module)
#: lib/code.ex:441 
msgid ""
"Ensures the given module is loaded.\n"
"\n"
"Similar to `ensure_loaded/1`, but returns `true` if the module\n"
"is already loaded or was successfully loaded. Returns `false`\n"
"otherwise.\n"
msgstr ""
#. TRANSLATORS: def Code.ensure_loaded(module)
#: lib/code.ex:430 
msgid ""
"Ensures the given module is loaded.\n"
"\n"
"If the module is already loaded, this works as no-op. If the module\n"
"was not yet loaded, it tries to load it.\n"
"\n"
"If it succeeds loading the module, it returns `{:module, module}`.\n"
"If not, returns `{:error, reason}` with the error reason.\n"
"\n"
"## Code loading on the Erlang VM\n"
"\n"
"Erlang has two modes to load code: interactive and embedded.\n"
"\n"
"By default, the Erlang VM runs in interactive mode, where modules\n"
"are loaded as needed. In embedded mode the opposite happens, as all\n"
"modules need to be loaded upfront or explicitly.\n"
"\n"
"Therefore, this function is used to check if a module is loaded\n"
"before using it and allows one to react accordingly. For example, the `URI`\n"
"module uses this function to check if a specific parser exists for a given\n"
"URI scheme.\n"
"\n"
"## `Code.ensure_compiled/1`\n"
"\n"
"Elixir also contains an `ensure_compiled/1` function that is a\n"
"superset of `ensure_loaded/1`.\n"
"\n"
"Since Elixir's compilation happens in parallel, in some situations\n"
"you may need to use a module that was not yet compiled, therefore\n"
"it can't even be loaded.\n"
"\n"
"`ensure_compiled/1` halts the current process until the\n"
"module we are depending on is available.\n"
"\n"
"In most cases, `ensure_loaded/1` is enough. `ensure_compiled/1`\n"
"must be used in rare cases, usually involving macros that need to\n"
"invoke a module for callback information.\n"
msgstr ""
#. TRANSLATORS: def Code.ensure_compiled?(module)
#: lib/code.ex:482 
msgid ""
"Ensures the given module is compiled and loaded.\n"
"\n"
"Similar to `ensure_compiled/1`, but returns `true` if the module\n"
"is already loaded or was successfully loaded and compiled.\n"
"Returns `false` otherwise.\n"
msgstr ""
#. TRANSLATORS: def Code.ensure_compiled(module)
#: lib/code.ex:458 
msgid ""
"Ensures the given module is compiled and loaded.\n"
"\n"
"If the module is already loaded, it works as no-op. If the module was\n"
"not loaded yet, it checks if it needs to be compiled first and then\n"
"tries to load it.\n"
"\n"
"If it succeeds loading the module, it returns `{:module, module}`.\n"
"If not, returns `{:error, reason}` with the error reason.\n"
"\n"
"Check `ensure_loaded/1` for more information on module loading\n"
"and when to use `ensure_loaded/1` or `ensure_compiled/1`.\n"
msgstr ""
#. TRANSLATORS: def Application.ensure_started(app, type \\ :temporary)
#: lib/application.ex:193 
msgid ""
"Ensures the given `app` is started.\n"
"\n"
"Same as `start/2` but returns `:ok` if the application was already\n"
"started. This is useful in scripts and in test setup, where test\n"
"applications need to be explicitly started:\n"
"\n"
"    :ok = Application.ensure_started(:my_test_dep)\n"
"\n"
msgstr ""
#. TRANSLATORS: def Application.ensure_all_started(app, type \\ :temporary)
#: lib/application.ex:205 
msgid ""
"Ensures the given `app` and its applications are started.\n"
"\n"
"Same as `start/2` but also starts the applications listed under\n"
"`:applications` in the `.app` file in case they were not previously\n"
"started.\n"
msgstr ""
#. TRANSLATORS: def Base.encode64(data)
#: lib/base.ex:234 
msgid ""
"Encodes a binary string into a base 64 encoded string.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Base.encode64(\"foobar\")\n"
"    \"Zm9vYmFy\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def IO.inspect(device, item, opts)
#: lib/io.ex:200 
msgid ""
"Inspects the item with options using the given device.\n"
msgstr ""
#. TRANSLATORS: def IO.inspect(item, opts \\ [])
#: lib/io.ex:192 
msgid ""
"Inspects and writes the given argument to the device.\n"
"\n"
"It enables pretty printing by default with width of\n"
"80 characters. The width can be changed by explicitly\n"
"passing the `:width` option.\n"
"\n"
"## Examples\n"
"\n"
"    IO.inspect Process.list, width: 40\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.inspect(arg, opts \\ [])
#: lib/kernel.ex:1447 
msgid ""
"Inspect the given argument according to the `Inspect` protocol.\n"
"The second argument is a keywords list with options to control\n"
"inspection.\n"
"\n"
"## Options\n"
"\n"
"`inspect/2` accepts a list of options that are internally\n"
"translated to an `Inspect.Opts` struct. Check the docs for\n"
"`Inspect.Opts` to see the supported options.\n"
"\n"
"## Examples\n"
"\n"
"    iex> inspect(:foo)\n"
"    \":foo\"\n"
"\n"
"    iex> inspect [1, 2, 3, 4, 5], limit: 3\n"
"    \"[1, 2, 3, ...]\"\n"
"\n"
"    iex> inspect(\"olÃ¡\" <> <<0>>)\n"
"    \"<<111, 108, 195, 161, 0>>\"\n"
"\n"
"    iex> inspect(\"olÃ¡\" <> <<0>>, binaries: :as_strings)\n"
"    \"\\\"olÃ¡\\\\0\\\"\"\n"
"\n"
"    iex> inspect(\"olÃ¡\", binaries: :as_binaries)\n"
"    \"<<111, 108, 195, 161>>\"\n"
"\n"
"    iex> inspect('bar')\n"
"    \"'bar'\"\n"
"\n"
"    iex> inspect([0|'bar'])\n"
"    \"[0, 98, 97, 114]\"\n"
"\n"
"    iex> inspect(100, base: :octal)\n"
"    \"0o144\"\n"
"\n"
"    iex> inspect(100, base: :hex)\n"
"    \"0x64\"\n"
"\n"
"Note that the inspect protocol does not necessarily return a valid\n"
"representation of an Elixir term. In such cases, the inspected result\n"
"must start with `#`. For example, inspecting a function will return:\n"
"\n"
"    inspect fn a, b -> a + b end\n"
"    #=> #Function<...>\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.into(collection, list)
#: lib/enum.ex:875 
msgid ""
"Inserts the given enumerable into a collectable.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.into([1, 2], [0])\n"
"    [0, 1, 2]\n"
"\n"
"    iex> Enum.into([a: 1, b: 2], %{})\n"
"    %{a: 1, b: 2}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.into(collection, list, transform)
#: lib/enum.ex:902 
msgid ""
"Inserts the given enumerable into a collectable\n"
"according to the transformation function.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.into([2, 3], [3], fn x -> x * 3 end)\n"
"    [3, 6, 9]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.get_values(keywords, key)
#: lib/keyword.ex:179 
msgid ""
"Gets all values for a specific `key`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.get_values([a: 1, a: 2], :a)\n"
"    [1,2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def IO.getn(prompt, count \\ 1)
#: lib/io.ex:224 
msgid ""
"Gets a number of bytes from the io device. If the\n"
"io device is a unicode device, `count` implies\n"
"the number of unicode codepoints to be retrieved.\n"
"Otherwise, `count` is the number of raw bytes to be retrieved.\n"
"It returns:\n"
"\n"
"  * `data` - the input characters\n"
"\n"
"  * `:eof` - end of file was encountered\n"
"\n"
"  * `{:error, reason}` - other (rare) error condition;\n"
"    for instance, `{:error, :estale}` if reading from an\n"
"    NFS volume\n"
msgstr ""
#. TRANSLATORS: def IO.getn(device, prompt, count)
#: lib/io.ex:241 
msgid ""
"Gets a number of bytes from the io device. If the\n"
"io device is a unicode device, `count` implies\n"
"the number of unicode codepoints to be retrieved.\n"
"Otherwise, `count` is the number of raw bytes to be retrieved.\n"
msgstr ""
#. TRANSLATORS: def Kernel.elem(tuple, index)
#: lib/kernel.ex:1083 
msgid ""
"Get the element at the zero-based `index` in `tuple`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Example\n"
"\n"
"    iex> tuple = {:foo, :bar, 3}\n"
"    iex> elem(tuple, 1)\n"
"    :bar\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.fetch!(collection, n)
#: lib/enum.ex:643 
msgid ""
"Finds the element at the given index (zero-based).\n"
"\n"
"Raises `OutOfBoundsError` if the given position\n"
"is outside the range of the collection.\n"
"\n"
"Note this operation takes linear time. In order to access\n"
"the element at index `n`, it will need to traverse `n`\n"
"previous elements.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.fetch!([2, 4, 6], 0)\n"
"    2\n"
"\n"
"    iex> Enum.fetch!([2, 4, 6], 2)\n"
"    6\n"
"\n"
"    iex> Enum.fetch!([2, 4, 6], 4)\n"
"    ** (Enum.OutOfBoundsError) out of bounds error\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.filter(collection, fun)
#: lib/enum.ex:661 
msgid ""
"Filters the collection, i.e. returns only those elements\n"
"for which `fun` returns `true`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.filter([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    [2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.filter_map(collection, filter, mapper)
#: lib/enum.ex:680 
msgid ""
"Filters the collection and maps its values in one pass.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.filter_map([1, 2, 3], fn(x) -> rem(x, 2) == 0 end, &(&1 * 2))\n"
"    [4]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.drop(keywords, keys)
#: lib/keyword.ex:539 
msgid ""
"Drops the given keys from the keyword list.\n"
"\n"
"Duplicated keys are preserved in the new keyword list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> d = [a: 1, b: 2, c: 3, d: 4]\n"
"    iex> Keyword.drop(d, [:b, :d])\n"
"    [a: 1, c: 3]\n"
"\n"
"    iex> d = [a: 1, b: 2, b: 3, c: 3, d: 4, a: 5]\n"
"    iex> Keyword.drop(d, [:b, :d])\n"
"    [a: 1, c: 3, a: 5]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.drop(collection, count)
#: lib/enum.ex:485 
msgid ""
"Drops the first `count` items from `collection`.\n"
"\n"
"If a negative value `count` is given, the last `count`\n"
"values will be dropped. The collection is enumerated\n"
"once to retrieve the proper index and the remaining\n"
"calculation is performed from the end.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.drop([1, 2, 3], 2)\n"
"    [3]\n"
"\n"
"    iex> Enum.drop([1, 2, 3], 10)\n"
"    []\n"
"\n"
"    iex> Enum.drop([1, 2, 3], 0)\n"
"    [1,2,3]\n"
"\n"
"    iex> Enum.drop([1, 2, 3], -1)\n"
"    [1,2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.drop_while(collection, fun)
#: lib/enum.ex:513 
msgid ""
"Drops items at the beginning of `collection` while `fun` returns `true`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.drop_while([1, 2, 3, 4, 5], fn(x) -> x < 3 end)\n"
"    [3,4,5]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Inspect.Algebra.break(s)
#: lib/inspect/algebra.ex:298 
msgid ""
"Document entity representing a break.\n"
"\n"
"This break can be rendered as a linebreak or as spaces,\n"
"depending on the `mode` of the chosen layout or the provided\n"
"separator.\n"
"\n"
"## Examples\n"
"\n"
"Let's glue two docs together with a break and then render it:\n"
"\n"
"    iex> doc = Inspect.Algebra.glue(\"a\", \" \", \"b\")\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"a\", \" \", \"b\"]\n"
"\n"
"Notice the break was represented as is, because we haven't reached\n"
"a line limit. Once we do, it is replaced by a newline:\n"
"\n"
"    iex> doc = Inspect.Algebra.glue(String.duplicate(\"a\", 20), \" \", \"b\")\n"
"    iex> Inspect.Algebra.format(doc, 10)\n"
"    [\"aaaaaaaaaaaaaaaaaaaa\", \"\\n\", \"b\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Macro.var(var, context)
#: lib/macro.ex:146 
msgid ""
"Genrates a AST node representing the variable given\n"
"by the atoms `var` and `context`.\n"
"\n"
"## Examples\n"
"\n"
"In order to build a variable, a context is expected.\n"
"Most of the times, in order to preserve hygiene, the\n"
"context must be `__MODULE__`:\n"
"\n"
"    iex> Macro.var(:foo, __MODULE__)\n"
"    {:foo, [], __MODULE__}\n"
"\n"
"However, if there is a need to access the user variable,\n"
"nil can be given:\n"
"\n"
"    iex> Macro.var(:foo, nil)\n"
"    {:foo, [], nil}\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.Exception Summary
#: lib/exception.ex:1 
msgid ""
"Functions to format throw/catch/exit and exceptions.\n"
"\n"
"Note that stacktraces in Elixir are updated on throw,\n"
"errors and exits. For example, at any given moment,\n"
"`System.stacktrace` will return the stacktrace for the\n"
"last throw/error/exit that occurred in the current process.\n"
"\n"
"Do not rely on the particular format returned by the `format`\n"
"functions in this module. They may be changed in future releases\n"
"in order to better suit Elixir's tool chain. In other words,\n"
"by using the functions in this module it is guaranteed you will\n"
"format exceptions as in the current Elixir version being used.\n"
msgstr ""
#. TRANSLATORS: def Exception.format_stacktrace(trace \\ nil)
#: lib/exception.ex:371 
msgid ""
"Formats the stacktrace.\n"
"\n"
"A stacktrace must be given as an argument. If not, the stacktrace\n"
"is retrieved from `Process.info/2`.\n"
msgstr ""
#. TRANSLATORS: def Exception.format_file_line(file, line)
#: lib/exception.ex:456 
msgid ""
"Formats the given file and line as shown in stacktraces.\n"
"If any of the values are nil, they are omitted.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Exception.format_file_line(\"foo\", 1)\n"
"    \"foo:1:\"\n"
"\n"
"    iex> Exception.format_file_line(\"foo\", nil)\n"
"    \"foo:\"\n"
"\n"
"    iex> Exception.format_file_line(nil, nil)\n"
"    \"\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Exception.format_exit(reason)
#: lib/exception.ex:157 
msgid ""
"Formats an exit, returns a string.\n"
"\n"
"Often there are errors/exceptions inside exits. Exits are often\n"
"wrapped by the caller and provide stacktraces too. This function\n"
"formats exits in a way to nicely show the exit reason, caller\n"
"and stacktrace.\n"
msgstr ""
#. TRANSLATORS: def Tuple.insert_at(tuple, index, term)
#: lib/tuple.ex:42 
msgid ""
"Inserts an element into a tuple.\n"
"\n"
"Inserts `value` into `tuple` at the given zero-based `index`.\n"
"Raises an `ArgumentError` if `index` is greater than the\n"
"length of `tuple`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> tuple = {:bar, :baz}\n"
"    iex> Tuple.insert_at(tuple, 0, :foo)\n"
"    {:foo, :bar, :baz}\n"
"\n"
msgstr ""
#. TRANSLATORS: def IO.ANSI.reverse()
#: lib/io/ansi.ex:69 
msgid ""
"Image: Negative. Swap foreground and background"
msgstr ""
#. TRANSLATORS: def Inspect.Algebra.space(x, y)
#: lib/inspect/algebra.ex:359 
msgid ""
"Inserts a mandatory single space between two document entities.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.space \"Hughes\", \"Wadler\"\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"Hughes\", \" \", \"Wadler\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Inspect.Algebra.line(x, y)
#: lib/inspect/algebra.ex:372 
msgid ""
"Inserts a mandatory linebreak between two document entities.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.line \"Hughes\", \"Wadler\"\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"Hughes\", \"\\n\", \"Wadler\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Inspect.Algebra.glue(x, g, y)
#: lib/inspect/algebra.ex:314 
msgid ""
"Inserts a break, passed as the second argument, between two docs,\n"
"the first and the third arguments.\n"
msgstr ""
#. TRANSLATORS: def Inspect.Algebra.glue(x, y)
#: lib/inspect/algebra.ex:307 
msgid ""
"Inserts a break between two docs. See `break/1` for more info.\n"
msgstr ""
#. TRANSLATORS: Elixir.Node Summary
#: lib/node.ex:1 
msgid ""
"Functions related to VM nodes.\n"
"\n"
"Some of the functions in this module are inlined by the compiler,\n"
"similar to functions in the `Kernel` module and they are explicitly\n"
"marked in their docs as \"inlined by the compiler\". For more information\n"
"about inlined functions, check out the `Kernel` module.\n"
msgstr ""
#. TRANSLATORS: def Node.connect(node)
#: lib/node.ex:147 
msgid ""
"Establishes a connection to `node`.\n"
"\n"
"Returns `true` if successful, `false` if not, and the atom\n"
"`:ignored` if the local node is not alive.\n"
"\n"
"See http://erlang.org/doc/man/net_kernel.html#connect_node-1 for more info.\n"
msgstr ""
#. TRANSLATORS: def Path.expand(path, relative_to)
#: lib/path.ex:165 
msgid ""
"Expands the path relative to the path given as the second argument\n"
"expanding any `.` and `..` characters. If the path is already an\n"
"absolute path, `relative_to` is ignored.\n"
"\n"
"Note, that this function treats `path` with a leading `~` as\n"
"an absolute one.\n"
"\n"
"The second argument is first expanded to an absolute path.\n"
"\n"
"## Examples\n"
"\n"
"    # Assuming that the absolute path to baz is /quux/baz\n"
"    Path.expand(\"foo/bar/../bar\", \"baz\")\n"
"    #=> \"/quux/baz/foo/bar\"\n"
"\n"
"    Path.expand(\"foo/bar/../bar\", \"/baz\")\n"
"    \"/baz/foo/bar\"\n"
"    Path.expand(\"/foo/bar/../bar\", \"/baz\")\n"
"    \"/foo/bar\"\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.Port Summary
#: lib/port.ex:1 
msgid ""
"Functions related to Erlang ports.\n"
msgstr ""
#. TRANSLATORS: Elixir.IO Summary
#: lib/io.ex:1 
msgid ""
"Functions handling IO.\n"
"\n"
"Many functions in this module expect an IO device as an argument.\n"
"An IO device must be a pid or an atom representing a process.\n"
"For convenience, Elixir provides `:stdio` and `:stderr` as\n"
"shortcuts to Erlang's `:standard_io` and `:standard_error`.\n"
"\n"
"The majority of the functions expect char data, i.e. strings or\n"
"lists of characters and strings. In case another type is given,\n"
"it will do a conversion to string via the `String.Chars` protocol\n"
"(as shown in typespecs).\n"
"\n"
"The functions starting with `bin*` expect iodata as an argument,\n"
"i.e. binaries or lists of bytes and binaries.\n"
"\n"
"## IO devices\n"
"\n"
"An IO device may be an atom or a pid. In case it is an atom,\n"
"the atom must be the name of a registered process. However,\n"
"there are three exceptions for this rule:\n"
"\n"
"  * `:standard_io` - when the `:standard_io` atom is given,\n"
"    it is treated as a shortcut for `Process.group_leader`\n"
"\n"
"  * `:stdio` - is a shortcut for `:standard_io`\n"
"\n"
"  * `:stderr` - is a shortcut for `:standard_error`\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Record.extract(name, opts)
#: lib/record.ex:55 
msgid ""
"Extracts record information from an Erlang file.\n"
"\n"
"Returns a quoted expression containing the fields as a list\n"
"of tuples. It expects the record name to be an atom and the\n"
"library path to be a string at expansion time.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Record.extract(:file_info, from_lib: \"kernel/include/file.hrl\")\n"
"    [size: :undefined, type: :undefined, access: :undefined, atime: :undefined,\n"
"     mtime: :undefined, ctime: :undefined, mode: :undefined, links: :undefined,\n"
"     major_device: :undefined, minor_device: :undefined, inode: :undefined,\n"
"     uid: :undefined, gid: :undefined]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Protocol.extract_impls(protocol, paths)
#: lib/protocol.ex:177 
msgid ""
"Extract all types implemented for the given protocol from\n"
"the given paths.\n"
"\n"
"The paths can be either a char list or a string. Internally\n"
"they are worked on as char lists, so passing them as lists\n"
"avoid extra conversion.\n"
"\n"
"Does not load any of the implementations.\n"
"\n"
"## Examples\n"
"\n"
"    # Get Elixir's ebin and retrieve all protocols\n"
"    iex> path = :code.lib_dir(:elixir, :ebin)\n"
"    iex> mods = Protocol.extract_impls(Enumerable, [path])\n"
"    iex> List in mods\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: def Protocol.extract_protocols(paths)
#: lib/protocol.ex:147 
msgid ""
"Extract all protocols from the given paths.\n"
"\n"
"The paths can be either a char list or a string. Internally\n"
"they are worked on as char lists, so passing them as lists\n"
"avoid extra conversion.\n"
"\n"
"Does not load any of the protocols.\n"
"\n"
"## Examples\n"
"\n"
"    # Get Elixir's ebin and retrieve all protocols\n"
"    iex> path = :code.lib_dir(:elixir, :ebin)\n"
"    iex> mods = Protocol.extract_protocols([path])\n"
"    iex> Enumerable in mods\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: def System.cmd(command, args, opts \\ [])
#: lib/system.ex:433 
msgid ""
"Executes the given `command` with `args`.\n"
"\n"
"`command` is expected to be an executable available in PATH\n"
"unless an absolute path is given.\n"
"\n"
"`args` must be a list of strings which are not expanded\n"
"in any way. For example, this means wildcard expansion will\n"
"not happen unless `Path.wildcard/2` is used. On Windows though,\n"
"wildcard expansion is up to the program.\n"
"\n"
"A set of options are also supported and described below.\n"
"\n"
"## Options\n"
"\n"
"  * `:into` - injects the result into the given collectable, defaults to `\"\"`\n"
"  * `:cd` - the directory to run the command in\n"
"  * `:env` - an enumerable of tuples containing environment key-value as binary\n"
"  * `:arg0` - set the command arg0\n"
"  * `:stderr_to_stdout` - redirects stderr to stdout when true\n"
"  * `:parallelism` - when true, the VM will schedule port tasks to improve\n"
"    parallelism in the system. If set to false, the VM will try to perform\n"
"    commands immediately, improving latency at the expense of parallelism.\n"
"    The default can be set on system startup by passing the \"+spp\" argument\n"
"    to `--erl`.\n"
"\n"
"## Error reasons\n"
"\n"
"If invalid arguments are given, `ArgumentError` is raised by\n"
"`System.cmd/3`. `System.cmd/3` also expects a strict set of\n"
"options and will raise if unknown or invalid options are given.\n"
"\n"
"Furthermore, `System.cmd/3` may fail with one of the POSIX reasons\n"
"detailed below:\n"
"\n"
"  * `:system_limit` - all available ports in the Erlang emulator are in use\n"
"\n"
"  * `:enomem` - there was not enough memory to create the port\n"
"\n"
"  * `:eagain` - there are no more available operating system processes\n"
"\n"
"  * `:enametoolong` - the external command given was too long\n"
"\n"
"  * `:emfile` - there are no more available file descriptors\n"
"    (for the operating system process that the Erlang emulator runs in)\n"
"\n"
"  * `:enfile` - the file table is full (for the entire operating system)\n"
"\n"
"  * `:eacces` - the command does not point to an executable file\n"
"\n"
"  * `:enoent` - the command does not point to an existing file\n"
"\n"
"## Shell commands\n"
"\n"
"If you desire to execute a trusted command inside a shell, with pipes,\n"
"redirecting and so on, please check\n"
"[Erlang's :os.cmd/1 function](http://www.erlang.org/doc/man/os.html#cmd-1).\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.cond(clauses)
#: lib/kernel/special_forms.ex:1392 
msgid ""
"Evaluates the expression corresponding to the first clause that\n"
"evaluates to truth value.\n"
"\n"
"Raises an error if all conditions evaluate to to nil or false.\n"
"\n"
"## Examples\n"
"\n"
"    cond do\n"
"      1 + 1 == 1 ->\n"
"        \"This will never match\"\n"
"      2 * 2 != 4 ->\n"
"        \"Nor this\"\n"
"      true ->\n"
"        \"This will\"\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def Process.demonitor(monitor_ref, options \\ [])
#: lib/process.ex:221 
msgid ""
"If `monitor_ref` is a reference which the calling process\n"
"obtained by calling `monitor/1`, this monitoring is turned off.\n"
"If the monitoring is already turned off, nothing happens.\n"
"\n"
"See http://www.erlang.org/doc/man/erlang.html#demonitor-2 for more info.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: defmacro Protocol.derive(protocol, module, options \\ [])
#: lib/protocol.ex:119 
msgid ""
"Derive the `protocol` for `module` with the given options.\n"
msgstr ""
#. TRANSLATORS: def Stream.each(enum, fun)
#: lib/stream.ex:286 
msgid ""
"Execute the given function for each item.\n"
"\n"
"Useful for adding side effects (like printing) to a stream.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.each([1, 2, 3], fn(x) -> send self, x end)\n"
"    iex> Enum.to_list(stream)\n"
"    iex> receive do: (x when is_integer(x) -> x)\n"
"    1\n"
"    iex> receive do: (x when is_integer(x) -> x)\n"
"    2\n"
"    iex> receive do: (x when is_integer(x) -> x)\n"
"    3\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.Tuple Summary
#: lib/tuple.ex:1 
msgid ""
"Functions for working with tuples.\n"
msgstr ""
#. TRANSLATORS: Elixir.Protocol Summary
#: lib/protocol.ex:1 
msgid ""
"Functions for working with protocols.\n"
msgstr ""
#. TRANSLATORS: Elixir.Integer Summary
#: lib/integer.ex:1 
msgid ""
"Functions for working with integers.\n"
msgstr ""
#. TRANSLATORS: Elixir.Float Summary
#: lib/float.ex:3 
msgid ""
"Functions for working with floating point numbers.\n"
msgstr ""
#. TRANSLATORS: def URI.encode_query(l)
#: lib/uri.ex:85 
msgid ""
"Encodes an enumerable into a query string.\n"
"\n"
"Takes an enumerable (containing a sequence of two-item tuples)\n"
"and returns a string of the form \"key1=value1&key2=value2...\" where\n"
"keys and values are URL encoded as per `encode/2`.\n"
"\n"
"Keys and values can be any term that implements the `String.Chars`\n"
"protocol, except lists which are explicitly forbidden.\n"
"\n"
"## Examples\n"
"\n"
"    iex> hd = %{\"foo\" => 1, \"bar\" => 2}\n"
"    iex> URI.encode_query(hd)\n"
"    \"bar=2&foo=1\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Base.url_encode64(data)
#: lib/base.ex:284 
msgid ""
"Encodes a binary string into a base 64 encoded string with URL and filename\n"
"safe alphabet.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Base.url_encode64(<<255,127,254,252>>)\n"
"    \"_3_-_A==\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Base.encode32(data, opts \\ [])
#: lib/base.ex:340 
msgid ""
"Encodes a binary string into a base 32 encoded string.\n"
"\n"
"Accepts an atom `:upper` (default) for encoding to upper case characters or\n"
"`:lower` for lower case characters.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Base.encode32(\"foobar\")\n"
"    \"MZXW6YTBOI======\"\n"
"\n"
"    iex> Base.encode32(\"foobar\", case: :lower)\n"
"    \"mzxw6ytboi======\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Base.hex_encode32(data, opts \\ [])
#: lib/base.ex:420 
msgid ""
"Encodes a binary string into a base 32 encoded string with an\n"
"extended hexadecimal alphabet.\n"
"\n"
"Accepts an atom `:upper` (default) for encoding to upper case characters or\n"
"`:lower` for lower case characters.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Base.hex_encode32(\"foobar\")\n"
"    \"CPNMUOJ1E8======\"\n"
"\n"
"    iex> Base.hex_encode32(\"foobar\", case: :lower)\n"
"    \"cpnmuoj1e8======\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Base.encode16(data, opts \\ [])
#: lib/base.ex:161 
msgid ""
"Encodes a binary string into a base 16 encoded string.\n"
"\n"
"Accepts an atom `:upper` (default) for encoding to upper case characters or\n"
"`:lower` for lower case characters.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Base.encode16(\"foobar\")\n"
"    \"666F6F626172\"\n"
"\n"
"    iex> Base.encode16(\"foobar\", case: :lower)\n"
"    \"666f6f626172\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Module.eval_quoted(module, quoted, binding \\ [], opts \\ [])
#: lib/module.ex:346 
msgid ""
"Evaluates the quoted contents in the given module's context.\n"
"\n"
"A list of environment options can also be given as argument.\n"
"See `Code.eval_string/3` for more information.\n"
"\n"
"Raises an error if the module was already compiled.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Foo do\n"
"      contents = quote do: (def sum(a, b), do: a + b)\n"
"      Module.eval_quoted __MODULE__, contents\n"
"    end\n"
"\n"
"    Foo.sum(1, 2) #=> 3\n"
"\n"
"For convenience, you can my pass `__ENV__` as argument and\n"
"all options will be automatically extracted from the environment:\n"
"\n"
"    defmodule Foo do\n"
"      contents = quote do: (def sum(a, b), do: a + b)\n"
"      Module.eval_quoted __MODULE__, contents, [], __ENV__\n"
"    end\n"
"\n"
"    Foo.sum(1, 2) #=> 3\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.unless(clause, options)
#: lib/kernel.ex:2178 
msgid ""
"Evaluates and returns the do-block passed in as a second argument\n"
"unless clause evaluates to true.\n"
"Returns nil otherwise.\n"
"See also `if`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> unless(Enum.empty?([]), do: \"Hello\")\n"
"    nil\n"
"\n"
"    iex> unless(Enum.empty?([1,2,3]), do: \"Hello\")\n"
"    \"Hello\"\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.try(args)
#: lib/kernel/special_forms.ex:1613 
msgid ""
"Evaluate the given expressions and handle any error, exit\n"
"or throw that may have happened.\n"
"\n"
"## Examples\n"
"\n"
"    try do\n"
"      do_something_that_may_fail(some_arg)\n"
"    rescue\n"
"      ArgumentError ->\n"
"        IO.puts \"Invalid argument given\"\n"
"    catch\n"
"      value ->\n"
"        IO.puts \"caught #{value}\"\n"
"    else\n"
"      value ->\n"
"        IO.puts \"Success! The result was #{value}\"\n"
"    after\n"
"      IO.puts \"This is printed regardless if it failed or succeed\"\n"
"    end\n"
"\n"
"The rescue clause is used to handle exceptions, while the catch\n"
"clause can be used to catch thrown values. The else clause can\n"
"be used to control flow based on the result of the expression.\n"
"Catch, rescue and else clauses work based on pattern matching.\n"
"\n"
"Note that calls inside `try` are not tail recursive since the VM\n"
"needs to keep the stacktrace in case an exception happens.\n"
"\n"
"## Rescue clauses\n"
"\n"
"Besides relying on pattern matching, rescue clauses provides some\n"
"conveniences around exceptions that allows one to rescue an\n"
"exception by its name. All the following formats are valid rescue\n"
"expressions:\n"
"\n"
"    try do\n"
"      UndefinedModule.undefined_function\n"
"    rescue\n"
"      UndefinedFunctionError -> nil\n"
"    end\n"
"\n"
"    try do\n"
"      UndefinedModule.undefined_function\n"
"    rescue\n"
"      [UndefinedFunctionError] -> nil\n"
"    end\n"
"\n"
"    # rescue and bind to x\n"
"    try do\n"
"      UndefinedModule.undefined_function\n"
"    rescue\n"
"      x in [UndefinedFunctionError] -> nil\n"
"    end\n"
"\n"
"    # rescue all and bind to x\n"
"    try do\n"
"      UndefinedModule.undefined_function\n"
"    rescue\n"
"      x -> nil\n"
"    end\n"
"\n"
"## Erlang errors\n"
"\n"
"Erlang errors are transformed into Elixir ones during rescue:\n"
"\n"
"    try do\n"
"      :erlang.error(:badarg)\n"
"    rescue\n"
"      ArgumentError -> :ok\n"
"    end\n"
"\n"
"The most common Erlang errors will be transformed into their\n"
"Elixir counter-part. Those which are not will be transformed\n"
"into `ErlangError`:\n"
"\n"
"    try do\n"
"      :erlang.error(:unknown)\n"
"    rescue\n"
"      ErlangError -> :ok\n"
"    end\n"
"\n"
"In fact, ErlangError can be used to rescue any error that is\n"
"not an Elixir error proper. For example, it can be used to rescue\n"
"the earlier `:badarg` error too, prior to transformation:\n"
"\n"
"    try do\n"
"      :erlang.error(:badarg)\n"
"    rescue\n"
"      ErlangError -> :ok\n"
"    end\n"
"\n"
"## Catching throws and exits\n"
"\n"
"The catch clause can be used to catch throws values and exits.\n"
"\n"
"    try do\n"
"      exit(:shutdown)\n"
"    catch\n"
"      :exit, :shutdown -> IO.puts \"Exited with shutdown reason\"\n"
"    end\n"
"\n"
"    try do\n"
"      throw(:sample)\n"
"    catch\n"
"      :throw, :sample ->\n"
"        IO.puts \"sample thrown\"\n"
"    end\n"
"\n"
"catch values also support `:error`, as in Erlang, although it is\n"
"commonly avoided in favor of raise/rescue control mechanisms.\n"
"\n"
"## Else clauses\n"
"\n"
"Else clauses allow the result of the expression to be pattern\n"
"matched on:\n"
"\n"
"    x = 2\n"
"    try do\n"
"      1 / x\n"
"    rescue\n"
"      ArithmeticError ->\n"
"        :infinity\n"
"    else\n"
"      y when y < 1 and y > -1 ->\n"
"        :small\n"
"      _ ->\n"
"        :large\n"
"    end\n"
"\n"
"If an else clause is not present the result of the expression will\n"
"be return, if no exceptions are raised:\n"
"\n"
"    x = 1\n"
"    ^x =\n"
"      try do\n"
"        1 / x\n"
"      rescue\n"
"        ArithmeticError ->\n"
"          :infinity\n"
"      end\n"
"\n"
"However when an else clause is present but the result of the expression\n"
"does not match any of the patterns an exception will be raised. This\n"
"exception will not be caught by a catch or rescue in the same try:\n"
"\n"
"    x = 1\n"
"    try do\n"
"      try do\n"
"        1 / x\n"
"      rescue\n"
"        # The TryClauseError can not be rescued here:\n"
"        TryClauseError ->\n"
"          :error_a\n"
"      else\n"
"        0 ->\n"
"          :small\n"
"      end\n"
"    rescue\n"
"      # The TryClauseError is rescued here:\n"
"      TryClauseError ->\n"
"        :error_b\n"
"    end\n"
"\n"
"Similarly an exception inside an else clause is not caught or rescued\n"
"inside the same try:\n"
"\n"
"    try do\n"
"      try do\n"
"        nil\n"
"      catch\n"
"        # The exit(1) call below can not be caught here:\n"
"        :exit, _ ->\n"
"          :exit_a\n"
"      else\n"
"        _ ->\n"
"          exit(1)\n"
"      end\n"
"    catch\n"
"      # The exit is caught here:\n"
"      :exit, _ ->\n"
"        :exit_b\n"
"    end\n"
"\n"
"This means the VM no longer needs to keep the stacktrace once inside\n"
"an else clause and so tail recursion is possible when using a `try`\n"
"with a tail call as the final call inside an else clause. The same\n"
"is true for rescue and catch clauses.\n"
"\n"
"## Variable handling\n"
"\n"
"Since an expression inside `try` may not have been evaluated\n"
"due to an exception, any variable created inside `try` cannot\n"
"be accessed externally. For instance:\n"
"\n"
"    try do\n"
"      x = 1\n"
"      do_something_that_may_fail(same_arg)\n"
"      :ok\n"
"    catch\n"
"      _, _ -> :failed\n"
"    end\n"
"\n"
"    x #=> unbound variable `x`\n"
"\n"
"In the example above, `x` cannot be accessed since it was defined\n"
"inside the `try` clause. A common practice to address this issue\n"
"is to return the variables defined inside `try`:\n"
"\n"
"    x =\n"
"      try do\n"
"        x = 1\n"
"        do_something_that_may_fail(same_arg)\n"
"        x\n"
"      catch\n"
"        _, _ -> :failed\n"
"      end\n"
"\n"
msgstr ""
#. TRANSLATORS: def Regex.escape(string)
#: lib/regex.ex:599 
msgid ""
"Escapes a string to be literally matched in a regex.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.escape(\".\")\n"
"    \"\\\\.\"\n"
"\n"
"    iex> Regex.escape(\"\\\\what if\")\n"
"    \"\\\\\\\\what\\\\ if\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def System.get_pid()
#: lib/system.ex:286 
msgid ""
"Erlang VM process identifier.\n"
"\n"
"Returns the process identifier of the current Erlang emulator\n"
"in the format most commonly used by the operating system environment.\n"
"\n"
"See http://www.erlang.org/doc/man/os.html#getpid-0 for more info.\n"
msgstr ""
#. TRANSLATORS: def System.get_env(varname)
#: lib/system.ex:270 
msgid ""
"Environment variable value.\n"
"\n"
"Returns the value of the environment variable\n"
"`varname` as a binary, or `nil` if the environment\n"
"variable is undefined.\n"
msgstr ""
#. TRANSLATORS: def Enum.uniq(collection, fun \\ fn x -> x end)
#: lib/enum.ex:1818 
msgid ""
"Enumerates the collection, removing all duplicated items.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.uniq([1, 2, 3, 2, 1])\n"
"    [1, 2, 3]\n"
"\n"
"    iex> Enum.uniq([{1, :x}, {2, :y}, {1, :z}], fn {x, _} -> x end)\n"
"    [{1,:x}, {2,:y}]\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.Version Summary
#: lib/version.ex:1 
msgid ""
"Functions for parsing and matching versions against requirements.\n"
"\n"
"A version is a string in a specific format or a `Version`\n"
"generated after parsing via `Version.parse/1`.\n"
"\n"
"`Version` parsing and requirements follow\n"
"[SemVer 2.0 schema](http://semver.org/).\n"
"\n"
"## Versions\n"
"\n"
"In a nutshell, a version is given by three numbers:\n"
"\n"
"    MAJOR.MINOR.PATCH\n"
"\n"
"Pre-releases are supported by appending `-[0-9A-Za-z-\\.]`:\n"
"\n"
"    \"1.0.0-alpha.3\"\n"
"\n"
"Build information can be added by appending `+[0-9A-Za-z-\\.]`:\n"
"\n"
"    \"1.0.0-alpha.3+20130417140000\"\n"
"\n"
"## Struct\n"
"\n"
"The version is represented by the Version struct and it has its\n"
"fields named according to Semver: `:major`, `:minor`, `:patch`,\n"
"`:pre` and `:build`.\n"
"\n"
"## Requirements\n"
"\n"
"Requirements allow you to specify which versions of a given\n"
"dependency you are willing to work against. It supports common\n"
"operators like `>=`, `<=`, `>`, `==` and friends that\n"
"work as one would expect:\n"
"\n"
"    # Only version 2.0.0\n"
"    \"== 2.0.0\"\n"
"\n"
"    # Anything later than 2.0.0\n"
"    \"> 2.0.0\"\n"
"\n"
"Requirements also support `and` and `or` for complex conditions:\n"
"\n"
"    # 2.0.0 and later until 2.1.0\n"
"    \">= 2.0.0 and < 2.1.0\"\n"
"\n"
"Since the example above is such a common requirement, it can\n"
"be expressed as:\n"
"\n"
"    \"~> 2.0.0\"\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.IO.ANSI Summary
#: lib/io/ansi.ex:17 
msgid ""
"Functionality to render ANSI escape sequences\n"
"(http://en.wikipedia.org/wiki/ANSI_escape_code) â€”  characters embedded\n"
"in text used to control formatting, color, and other output options\n"
"on video text terminals.\n"
msgstr ""
#. TRANSLATORS: def IO.ANSI.framed()
#: lib/io/ansi.ex:115 
msgid ""
"Framed"
msgstr ""
#. TRANSLATORS: def IO.ANSI.format(chardata, emit \\ enabled?())
#: lib/io/ansi.ex:158 
msgid ""
"Formats a chardata-like argument by converting named ANSI sequences into actual\n"
"ANSI codes.\n"
"\n"
"The named sequences are represented by atoms.\n"
"\n"
"It will also append an `IO.ANSI.reset` to the chardata when a conversion is\n"
"performed. If you don't want this behaviour, use `format_fragment/2`.\n"
"\n"
"An optional boolean parameter can be passed to enable or disable\n"
"emitting actual ANSI codes. When `false`, no ANSI codes will emitted.\n"
"By default checks if ANSI is enabled using the `enabled?/0` function.\n"
"\n"
"## Examples\n"
"\n"
"    iex> IO.ANSI.format([\"Hello, \", :red, :bright, \"world!\"], true)\n"
"    [[[[[[], \"Hello, \"] | \"\\e[31m\"] | \"\\e[1m\"], \"world!\"] | \"\\e[0m\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def IO.ANSI.format_fragment(chardata, emit \\ enabled?())
#: lib/io/ansi.ex:178 
msgid ""
"Formats a chardata-like argument by converting named ANSI sequences into actual\n"
"ANSI codes.\n"
"\n"
"The named sequences are represented by atoms.\n"
"\n"
"An optional boolean parameter can be passed to enable or disable\n"
"emitting actual ANSI codes. When `false`, no ANSI codes will emitted.\n"
"By default checks if ANSI is enabled using the `enabled?/0` function.\n"
"\n"
"## Examples\n"
"\n"
"    iex> IO.ANSI.format_fragment([:bright, 'Word'], true)\n"
"    [[[[[[] | \"\\e[1m\"], 87], 111], 114], 100]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Node.disconnect(node)
#: lib/node.ex:134 
msgid ""
"Forces the disconnection of a node.\n"
"\n"
"This will appear to the `node` as if the local node has crashed.\n"
"This function is mainly used in the Erlang network authentication\n"
"protocols. Returns `true` if disconnection succeeds, otherwise `false`.\n"
"If the local node is not alive, the function returns `:ignored`.\n"
"\n"
"See http://www.erlang.org/doc/man/erlang.html#disconnect_node-1 for more info.\n"
msgstr ""
#. TRANSLATORS: def Stream.take(enum, n)
#: lib/stream.ex:519 
msgid ""
"Lazily takes the next `n` items from the enumerable and stops\n"
"enumeration.\n"
"\n"
"If a negative `n` is given, the last `n` values will be taken.\n"
"For such, the collection is fully enumerated keeping up to `2 * n`\n"
"elements in memory. Once the end of the collection is reached,\n"
"the last `count` elements will be executed. Therefore, using\n"
"a negative `n` on an infinite collection will never return.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.take(1..100, 5)\n"
"    iex> Enum.to_list(stream)\n"
"    [1,2,3,4,5]\n"
"\n"
"    iex> stream = Stream.take(1..100, -5)\n"
"    iex> Enum.to_list(stream)\n"
"    [96,97,98,99,100]\n"
"\n"
"    iex> stream = Stream.cycle([1, 2, 3]) |> Stream.take(5)\n"
"    iex> Enum.to_list(stream)\n"
"    [1,2,3,1,2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.take_while(enum, fun)
#: lib/stream.ex:588 
msgid ""
"Lazily takes elements of the enumerable while the given\n"
"function returns `true`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.take_while(1..100, &(&1 <= 5))\n"
"    iex> Enum.to_list(stream)\n"
"    [1,2,3,4,5]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.drop(enum, n)
#: lib/stream.ex:224 
msgid ""
"Lazily drops the next `n` items from the enumerable.\n"
"\n"
"If a negative `n` is given, it will drop the last `n` items from\n"
"the collection. Note that the mechanism by which this is implemented\n"
"will delay the emission of any item until `n` additional items have\n"
"been emitted by the enum.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.drop(1..10, 5)\n"
"    iex> Enum.to_list(stream)\n"
"    [6,7,8,9,10]\n"
"\n"
"    iex> stream = Stream.drop(1..10, -5)\n"
"    iex> Enum.to_list(stream)\n"
"    [1,2,3,4,5]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.drop_while(enum, fun)
#: lib/stream.ex:264 
msgid ""
"Lazily drops elements of the enumerable while the given\n"
"function returns `true`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.drop_while(1..10, &(&1 <= 5))\n"
"    iex> Enum.to_list(stream)\n"
"    [6,7,8,9,10]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Inspect.Algebra.folddoc(list1, f)
#: lib/inspect/algebra.ex:389 
msgid ""
"Folds a list of document entities into a document entity\n"
"using a function that is passed as the first argument.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = [\"A\", \"B\"]\n"
"    iex> doc = Inspect.Algebra.folddoc(doc, fn(x,y) ->\n"
"    ...>   Inspect.Algebra.concat [x, \"!\", y]\n"
"    ...> end)\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"A\", \"!\", \"B\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.fetch!(keywords, key)
#: lib/keyword.ex:162 
msgid ""
"Fetches the value for specific `key`. \n"
"\n"
"If `key` does not exist, a `KeyError` is raised.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.fetch!([a: 1], :a)\n"
"    1\n"
"\n"
"    iex> Keyword.fetch!([a: 1], :b)\n"
"    ** (KeyError) key :b not found in: [a: 1]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.fetch(keywords, key)
#: lib/keyword.ex:140 
msgid ""
"Fetches the value for a specific `key` and returns it in a tuple.\n"
"\n"
"If the `key` does not exist, returns `:error`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.fetch([a: 1], :a)\n"
"    {:ok, 1}\n"
"\n"
"    iex> Keyword.fetch([a: 1], :b)\n"
"    :error\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.foldr(list, acc, function)
#: lib/list.ex:116 
msgid ""
"Folds (reduces) the given list from the right with\n"
"a function. Requires an accumulator.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.foldr([1, 2, 3, 4], 0, fn (x, acc) -> x - acc end)\n"
"    -2\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.foldl(list, acc, function)
#: lib/list.ex:101 
msgid ""
"Folds (reduces) the given list from the left with\n"
"a function. Requires an accumulator.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.foldl([5, 5], 10, fn (x, acc) -> x + acc end)\n"
"    20\n"
"\n"
"    iex> List.foldl([1, 2, 3, 4], 0, fn (x, acc) -> x - acc end)\n"
"    2\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.flatten(list, tail)
#: lib/list.ex:83 
msgid ""
"Flattens the given `list` of nested lists.\n"
"The list `tail` will be added at the end of\n"
"the flattened list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.flatten([1, [[2], 3]], [4, 5])\n"
"    [1,2,3,4,5]\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.flatten(list)
#: lib/list.ex:67 
msgid ""
"Flattens the given `list` of nested lists.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.flatten([1, [[2], 3]])\n"
"    [1,2,3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Path.relative(name)
#: lib/path.ex:211 
msgid ""
"Forces the path to be a relative path.\n"
"\n"
"## Unix examples\n"
"\n"
"    Path.relative(\"/usr/local/bin\")   #=> \"usr/local/bin\"\n"
"    Path.relative(\"usr/local/bin\")    #=> \"usr/local/bin\"\n"
"    Path.relative(\"../usr/local/bin\") #=> \"../usr/local/bin\"\n"
"\n"
"## Windows examples\n"
"\n"
"    Path.relative(\"D:/usr/local/bin\") #=> \"usr/local/bin\"\n"
"    Path.relative(\"usr/local/bin\")    #=> \"usr/local/bin\"\n"
"    Path.relative(\"D:bar.ex\")         #=> \"bar.ex\"\n"
"    Path.relative(\"/bar/foo.ex\")      #=> \"bar/foo.ex\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def StringIO.flush(pid)
#: lib/string_io.ex:72 
msgid ""
"Flushes output buffer.\n"
"\n"
"## Examples\n"
"\n"
"    iex> {:ok, pid} = StringIO.open(\"in\")\n"
"    iex> IO.write(pid, \"out\")\n"
"    iex> StringIO.flush(pid)\n"
"    \"out\"\n"
"    iex> StringIO.contents(pid)\n"
"    {\"in\", \"\"}\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.Enumerable Summary
#: lib/enum.ex:1 
msgid ""
"Enumerable protocol used by `Enum` and `Stream` modules.\n"
"\n"
"When you invoke a function in the `Enum` module, the first argument\n"
"is usually a collection that must implement this protocol. For example,\n"
"the expression\n"
"\n"
"    Enum.map([1, 2, 3], &(&1 * 2))\n"
"\n"
"invokes underneath `Enumerable.reduce/3` to perform the reducing\n"
"operation that builds a mapped list by calling the mapping function\n"
"`&(&1 * 2)` on every element in the collection and cons'ing the\n"
"element with an accumulated list.\n"
"\n"
"Internally, `Enum.map/2` is implemented as follows:\n"
"\n"
"    def map(enum, fun) do\n"
"      reducer = fn x, acc -> {:cont, [fun.(x)|acc]} end\n"
"      Enumerable.reduce(enum, {:cont, []}, reducer) |> elem(1) |> :lists.reverse()\n"
"    end\n"
"\n"
"Notice the user given function is wrapped into a `reducer` function.\n"
"The `reducer` function must return a tagged tuple after each step,\n"
"as described in the `acc/0` type.\n"
"\n"
"The reason the accumulator requires a tagged tuple is to allow the\n"
"reducer function to communicate to the underlying enumerable the end\n"
"of enumeration, allowing any open resource to be properly closed. It\n"
"also allows suspension of the enumeration, which is useful when\n"
"interleaving between many enumerables is required (as in zip).\n"
"\n"
"Finally, `Enumerable.reduce/3` will return another tagged tuple,\n"
"as represented by the `result/0` type.\n"
msgstr ""
#. TRANSLATORS: def IO.ANSI.encircled()
#: lib/io/ansi.ex:118 
msgid ""
"Encircled"
msgstr ""
#. TRANSLATORS: def Set.put(set, value)
#: lib/set.ex:237 
msgid ""
"Inserts `value` into `set` if it does not already contain it.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Set.put(Enum.into([1, 2, 3], set_impl.new), 3) |> Enum.sort\n"
"    [1, 2, 3]\n"
"\n"
"    iex> Set.put(Enum.into([1, 2, 3], set_impl.new), 4) |> Enum.sort\n"
"    [1, 2, 3, 4]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.into(enum, collectable, transform \\ fn x -> x end)
#: lib/stream.ex:371 
msgid ""
"Injects the stream values into the given collectable as a side-effect.\n"
"\n"
"This function is often used with `run/1` since any evaluation\n"
"is delayed until the stream is executed. See `run/1` for an example.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.sigil_w(arg1, modifiers)
#: lib/kernel.ex:3487 
msgid ""
"Handles the sigil ~w. It returns a list of \"words\" split by whitespace.\n"
"\n"
"## Modifiers\n"
"\n"
"  * `s`: strings (default)\n"
"  * `a`: atoms\n"
"  * `c`: char lists\n"
"\n"
"## Examples\n"
"\n"
"    iex> ~w(foo #{:bar} baz)\n"
"    [\"foo\", \"bar\", \"baz\"]\n"
"\n"
"    iex> ~w(--source test/enum_test.exs)\n"
"    [\"--source\", \"test/enum_test.exs\"]\n"
"\n"
"    iex> ~w(foo bar baz)a\n"
"    [:foo, :bar, :baz]\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.sigil_s(arg1, list2)
#: lib/kernel.ex:3381 
msgid ""
"Handles the sigil ~s. It returns a string as if it was double quoted\n"
"string, unescaping characters and replacing interpolations.\n"
"\n"
"## Examples\n"
"\n"
"    iex> ~s(foo)\n"
"    \"foo\"\n"
"\n"
"    iex> ~s(f#{:o}o)\n"
"    \"foo\"\n"
"\n"
"    iex> ~s(f\\#{:o}o)\n"
"    \"f\\#{:o}o\"\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.sigil_r(arg1, options)
#: lib/kernel.ex:3439 
msgid ""
"Handles the sigil ~r. It returns a Regex pattern.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.match?(~r(foo), \"foo\")\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.sigil_c(arg1, list2)
#: lib/kernel.ex:3421 
msgid ""
"Handles the sigil ~c. It returns a char list as if it were a single\n"
"quoted string, unescaping characters and replacing interpolations.\n"
"\n"
"## Examples\n"
"\n"
"    iex> ~c(foo)\n"
"    'foo'\n"
"\n"
"    iex> ~c(f#{:o}o)\n"
"    'foo'\n"
"\n"
"    iex> ~c(f\\#{:o}o)\n"
"    'f\\#{:o}o'\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.sigil_W(arg1, modifiers)
#: lib/kernel.ex:3512 
msgid ""
"Handles the sigil ~W. It returns a list of \"words\" split by whitespace\n"
"without escaping nor interpreting interpolations.\n"
"\n"
"## Modifiers\n"
"\n"
"  * `s`: strings (default)\n"
"  * `a`: atoms\n"
"  * `c`: char lists\n"
"\n"
"## Examples\n"
"\n"
"    iex> ~W(foo #{bar} baz)\n"
"    [\"foo\", \"\\#{bar}\", \"baz\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.sigil_S(string, list2)
#: lib/kernel.ex:3361 
msgid ""
"Handles the sigil ~S. It simply returns a string\n"
"without escaping characters and without interpolations.\n"
"\n"
"## Examples\n"
"\n"
"    iex> ~S(foo)\n"
"    \"foo\"\n"
"\n"
"    iex> ~S(f#{o}o)\n"
"    \"f\\#{o}o\"\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.sigil_R(arg1, options)
#: lib/kernel.ex:3460 
msgid ""
"Handles the sigil ~R. It returns a Regex pattern without escaping\n"
"nor interpreting interpolations.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.match?(~R(f#{1,3}o), \"f#o\")\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.sigil_C(arg1, list2)
#: lib/kernel.ex:3398 
msgid ""
"Handles the sigil ~C. It simply returns a char list\n"
"without escaping characters and without interpolations.\n"
"\n"
"## Examples\n"
"\n"
"    iex> ~C(foo)\n"
"    'foo'\n"
"\n"
"    iex> ~C(f#{o}o)\n"
"    'f\\#{o}o'\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.Kernel.SpecialForms Summary
#: lib/kernel/special_forms.ex:1 
msgid ""
"In this module we define Elixir special forms. Special forms\n"
"cannot be overridden by the developer and are the basic\n"
"building blocks of Elixir code.\n"
"\n"
"Some of those forms are lexical (like `alias`, `case`, etc).\n"
"The macros `{}` and `<<>>` are also special forms used to define\n"
"tuple and binary data structures respectively.\n"
"\n"
"This module also documents Elixir's pseudo variables (`__ENV__`,\n"
"`__MODULE__`, `__DIR__` and `__CALLER__`). Pseudo variables return\n"
"information about Elixir's compilation environment and can only\n"
"be read, never assigned to.\n"
"\n"
"Finally, it also documents 2 special forms, `__block__` and\n"
"`__aliases__`, which are not intended to be called directly by the\n"
"developer but they appear in quoted contents since they are essential\n"
"in Elixir's constructs.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.import(module, opts)
#: lib/kernel/special_forms.ex:570 
msgid ""
"Imports function and macros from other modules.\n"
"\n"
"`import` allows one to easily access functions or macros from\n"
"others modules without using the qualified name.\n"
"\n"
"## Examples\n"
"\n"
"If you are using several functions from a given module, you can\n"
"import those functions and reference them as local functions,\n"
"for example:\n"
"\n"
"    iex> import List\n"
"    iex> flatten([1, [2], 3])\n"
"    [1,2,3]\n"
"\n"
"## Selector\n"
"\n"
"By default, Elixir imports functions and macros from the given\n"
"module, except the ones starting with underscore (which are\n"
"usually callbacks):\n"
"\n"
"    import List\n"
"\n"
"A developer can filter to import only macros or functions via\n"
"the only option:\n"
"\n"
"    import List, only: :functions\n"
"    import List, only: :macros\n"
"\n"
"Alternatively, Elixir allows a developer to pass pairs of\n"
"name/arities to `:only` or `:except` as a fine grained control\n"
"on what to import (or not):\n"
"\n"
"    import List, only: [flatten: 1]\n"
"    import String, except: [split: 2]\n"
"\n"
"Notice that calling `except` for a previously declared `import`\n"
"simply filters the previously imported elements. For example:\n"
"\n"
"    import List, only: [flatten: 1, keyfind: 3]\n"
"    import List, except: [flatten: 1]\n"
"\n"
"After the two import calls above, only `List.keyfind/3` will be\n"
"imported.\n"
"\n"
"## Lexical scope\n"
"\n"
"It is important to notice that `import` is lexical. This means you\n"
"can import specific macros inside specific functions:\n"
"\n"
"    defmodule Math do\n"
"      def some_function do\n"
"        # 1) Disable `if/2` from Kernel\n"
"        import Kernel, except: [if: 2]\n"
"\n"
"        # 2) Require the new `if` macro from MyMacros\n"
"        import MyMacros\n"
"\n"
"        # 3) Use the new macro\n"
"        if do_something, it_works\n"
"      end\n"
"    end\n"
"\n"
"In the example above, we imported macros from `MyMacros`,\n"
"replacing the original `if/2` implementation by our own\n"
"within that specific function. All other functions in that\n"
"module will still be able to use the original one.\n"
"\n"
"## Warnings\n"
"\n"
"If you import a module and you don't use any of the imported\n"
"functions or macros from this module, Elixir is going to issue\n"
"a warning implying the import is not being used.\n"
"\n"
"In case the import is generated automatically by a macro,\n"
"Elixir won't emit any warnings though, since the import\n"
"was not explicitly defined.\n"
"\n"
"Both warning behaviours could be changed by explicitly\n"
"setting the `:warn` option to true or false.\n"
"\n"
"## Ambiguous function/macro names\n"
"\n"
"If two modules `A` and `B` are imported and they both contain\n"
"a `foo` function with an arity of `1`, an error is only emitted\n"
"if an ambiguous call to `foo/1` is actually made; that is, the\n"
"errors are emitted lazily, not eagerly.\n"
msgstr ""
#. TRANSLATORS: def Keyword.get(keywords, key, default \\ nil)
#: lib/keyword.ex:118 
msgid ""
"Gets the value for a specific `key`.\n"
"\n"
"If `key` does not exist, return the default value (`nil` if no default value).\n"
"\n"
"If duplicated entries exist, the first one is returned.\n"
"Use `get_values/2` to retrieve all entries.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.get([a: 1], :a)\n"
"    1\n"
"\n"
"    iex> Keyword.get([a: 1], :b)\n"
"    nil\n"
"\n"
"    iex> Keyword.get([a: 1], :b, 3)\n"
"    3\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.quote(opts, block)
#: lib/kernel/special_forms.ex:1089 
msgid ""
"Gets the representation of any expression.\n"
"\n"
"## Examples\n"
"\n"
"    quote do: sum(1, 2, 3)\n"
"    #=> {:sum, [], [1, 2, 3]}\n"
"\n"
"## Explanation\n"
"\n"
"Any Elixir code can be represented using Elixir data structures.\n"
"The building block of Elixir macros is a tuple with three elements,\n"
"for example:\n"
"\n"
"    {:sum, [], [1, 2, 3]}\n"
"\n"
"The tuple above represents a function call to `sum` passing 1, 2 and\n"
"3 as arguments. The tuple elements are:\n"
"\n"
"  * The first element of the tuple is always an atom or\n"
"    another tuple in the same representation.\n"
"\n"
"  * The second element of the tuple represents metadata.\n"
"\n"
"  * The third element of the tuple are the arguments for the\n"
"    function call. The third argument may be an atom, which is\n"
"    usually a variable (or a local call).\n"
"\n"
"## Options\n"
"\n"
"  * `:unquote` - when false, disables unquoting. Useful when you have a quote\n"
"    inside another quote and want to control what quote is able to unquote.\n"
"\n"
"  * `:location` - when set to `:keep`, keeps the current line and file from\n"
"    quote. Read the Stacktrace information section below for more\n"
"    information.\n"
"\n"
"  * `:context` - sets the resolution context.\n"
"\n"
"  * `:bind_quoted` - passes a binding to the macro. Whenever a binding is\n"
"    given, `unquote` is automatically disabled.\n"
"\n"
"## Quote literals\n"
"\n"
"Besides the tuple described above, Elixir has a few literals that\n"
"when quoted return themselves. They are:\n"
"\n"
"    :sum         #=> Atoms\n"
"    1            #=> Integers\n"
"    2.0          #=> Floats\n"
"    [1, 2]       #=> Lists\n"
"    \"strings\"    #=> Strings\n"
"    {key, value} #=> Tuples with two elements\n"
"\n"
"## Quote and macros\n"
"\n"
"`quote` is commonly used with macros for code generation. As an exercise,\n"
"let's define a macro that multiplies a number by itself (squared). Note\n"
"there is no reason to define such as a macro (and it would actually be\n"
"seen as a bad practice), but it is simple enough that it allows us to focus\n"
"on the important aspects of quotes and macros:\n"
"\n"
"    defmodule Math do\n"
"      defmacro squared(x) do\n"
"        quote do\n"
"          unquote(x) * unquote(x)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"We can invoke it as:\n"
"\n"
"    import Math\n"
"    IO.puts \"Got #{squared(5)}\"\n"
"\n"
"At first, there is nothing in this example that actually reveals it is a\n"
"macro. But what is happening is that, at compilation time, `squared(5)`\n"
"becomes `5 * 5`. The argument `5` is duplicated in the produced code, we\n"
"can see this behaviour in practice though because our macro actually has\n"
"a bug:\n"
"\n"
"    import Math\n"
"    my_number = fn ->\n"
"      IO.puts \"Returning 5\"\n"
"      5\n"
"    end\n"
"    IO.puts \"Got #{squared(my_number.())}\"\n"
"\n"
"The example above will print:\n"
"\n"
"    Returning 5\n"
"    Returning 5\n"
"    25\n"
"\n"
"Notice how \"Returning 5\" was printed twice, instead of just once. This is\n"
"because a macro receives an expression and not a value (which is what we\n"
"would expect in a regular function). This means that:\n"
"\n"
"    squared(my_number.())\n"
"\n"
"Actually expands to:\n"
"\n"
"    my_number.() * my_number.()\n"
"\n"
"Which invokes the function twice, explaining why we get the printed value\n"
"twice! In the majority of the cases, this is actually unexpected behaviour,\n"
"and that's why one of the first things you need to keep in mind when it\n"
"comes to macros is to **not unquote the same value more than once**.\n"
"\n"
"Let's fix our macro:\n"
"\n"
"    defmodule Math do\n"
"      defmacro squared(x) do\n"
"        quote do\n"
"          x = unquote(x)\n"
"          x * x\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"Now invoking `square(my_number.())` as before will print the value just\n"
"once.\n"
"\n"
"In fact, this pattern is so common that most of the times you will want\n"
"to use the `bind_quoted` option with `quote`:\n"
"\n"
"    defmodule Math do\n"
"      defmacro squared(x) do\n"
"        quote bind_quoted: [x: x] do\n"
"          x * x\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"`:bind_quoted` will translate to the same code as the example above.\n"
"`:bind_quoted` can be used in many cases and is seen as good practice,\n"
"not only because it helps us from running into common mistakes but also\n"
"because it allows us to leverage other tools exposed by macros, such as\n"
"unquote fragments discussed in some sections below.\n"
"\n"
"Before we finish this brief introduction, you will notice that, even though\n"
"we defined a variable `x` inside our quote:\n"
"\n"
"    quote do\n"
"      x = unquote(x)\n"
"      x * x\n"
"    end\n"
"\n"
"When we call:\n"
"\n"
"    import Math\n"
"    squared(5)\n"
"    x #=> ** (RuntimeError) undefined function or variable: x\n"
"\n"
"We can see that `x` did not leak to the user context. This happens\n"
"because Elixir macros are hygienic, a topic we will discuss at length\n"
"in the next sections as well.\n"
"\n"
"## Hygiene in variables\n"
"\n"
"Consider the following example:\n"
"\n"
"    defmodule Hygiene do\n"
"      defmacro no_interference do\n"
"        quote do: a = 1\n"
"      end\n"
"    end\n"
"\n"
"    require Hygiene\n"
"\n"
"    a = 10\n"
"    Hygiene.no_interference\n"
"    a #=> 10\n"
"\n"
"In the example above, `a` returns 10 even if the macro\n"
"is apparently setting it to 1 because variables defined\n"
"in the macro does not affect the context the macro is executed in.\n"
"If you want to set or get a variable in the caller's context, you\n"
"can do it with the help of the `var!` macro:\n"
"\n"
"    defmodule NoHygiene do\n"
"      defmacro interference do\n"
"        quote do: var!(a) = 1\n"
"      end\n"
"    end\n"
"\n"
"    require NoHygiene\n"
"\n"
"    a = 10\n"
"    NoHygiene.interference\n"
"    a #=> 1\n"
"\n"
"Note that you cannot even access variables defined in the same\n"
"module unless you explicitly give it a context:\n"
"\n"
"    defmodule Hygiene do\n"
"      defmacro write do\n"
"        quote do\n"
"          a = 1\n"
"        end\n"
"      end\n"
"\n"
"      defmacro read do\n"
"        quote do\n"
"          a\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    Hygiene.write\n"
"    Hygiene.read\n"
"    #=> ** (RuntimeError) undefined function or variable: a\n"
"\n"
"For such, you can explicitly pass the current module scope as\n"
"argument:\n"
"\n"
"    defmodule ContextHygiene do\n"
"      defmacro write do\n"
"        quote do\n"
"          var!(a, ContextHygiene) = 1\n"
"        end\n"
"      end\n"
"\n"
"      defmacro read do\n"
"        quote do\n"
"          var!(a, ContextHygiene)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    ContextHygiene.write\n"
"    ContextHygiene.read\n"
"    #=> 1\n"
"\n"
"## Hygiene in aliases\n"
"\n"
"Aliases inside quote are hygienic by default.\n"
"Consider the following example:\n"
"\n"
"    defmodule Hygiene do\n"
"      alias HashDict, as: D\n"
"\n"
"      defmacro no_interference do\n"
"        quote do: D.new\n"
"      end\n"
"    end\n"
"\n"
"    require Hygiene\n"
"    Hygiene.no_interference #=> #HashDict<[]>\n"
"\n"
"Notice that, even though the alias `D` is not available\n"
"in the context the macro is expanded, the code above works\n"
"because `D` still expands to `HashDict`.\n"
"\n"
"Similarly, even if we defined an alias with the same name\n"
"before invoking a macro, it won't affect the macro's result:\n"
"\n"
"    defmodule Hygiene do\n"
"      alias HashDict, as: D\n"
"\n"
"      defmacro no_interference do\n"
"        quote do: D.new\n"
"      end\n"
"    end\n"
"\n"
"    require Hygiene\n"
"    alias SomethingElse, as: D\n"
"    Hygiene.no_interference #=> #HashDict<[]>\n"
"\n"
"In some cases, you want to access an alias or a module defined\n"
"in the caller. For such, you can use the `alias!` macro:\n"
"\n"
"    defmodule Hygiene do\n"
"      # This will expand to Elixir.Nested.hello\n"
"      defmacro no_interference do\n"
"        quote do: Nested.hello\n"
"      end\n"
"\n"
"      # This will expand to Nested.hello for\n"
"      # whatever is Nested in the caller\n"
"      defmacro interference do\n"
"        quote do: alias!(Nested).hello\n"
"      end\n"
"    end\n"
"\n"
"    defmodule Parent do\n"
"      defmodule Nested do\n"
"        def hello, do: \"world\"\n"
"      end\n"
"\n"
"      require Hygiene\n"
"      Hygiene.no_interference\n"
"      #=> ** (UndefinedFunctionError) ...\n"
"\n"
"      Hygiene.interference\n"
"      #=> \"world\"\n"
"    end\n"
"\n"
"## Hygiene in imports\n"
"\n"
"Similar to aliases, imports in Elixir are hygienic. Consider the\n"
"following code:\n"
"\n"
"    defmodule Hygiene do\n"
"      defmacrop get_size do\n"
"        quote do\n"
"          size(\"hello\")\n"
"        end\n"
"      end\n"
"\n"
"      def return_size do\n"
"        import Kernel, except: [size: 1]\n"
"        get_size\n"
"      end\n"
"    end\n"
"\n"
"    Hygiene.return_size #=> 5\n"
"\n"
"Notice how `return_size` returns 5 even though the `size/1`\n"
"function is not imported. In fact, even if `return_size` imported\n"
"a function from another module, it wouldn't affect the function\n"
"result:\n"
"\n"
"    def return_size do\n"
"      import Dict, only: [size: 1]\n"
"      get_size\n"
"    end\n"
"\n"
"Calling this new `return_size` will still return 5 as result.\n"
"\n"
"Elixir is smart enough to delay the resolution to the latest\n"
"moment possible. So, if you call `size(\"hello\")` inside quote,\n"
"but no `size/1` function is available, it is then expanded in\n"
"the caller:\n"
"\n"
"    defmodule Lazy do\n"
"      defmacrop get_size do\n"
"        import Kernel, except: [size: 1]\n"
"\n"
"        quote do\n"
"          size([a: 1, b: 2])\n"
"        end\n"
"      end\n"
"\n"
"      def return_size do\n"
"        import Kernel, except: [size: 1]\n"
"        import Dict, only: [size: 1]\n"
"        get_size\n"
"      end\n"
"    end\n"
"\n"
"    Lazy.return_size #=> 2\n"
"\n"
"## Stacktrace information\n"
"\n"
"When defining functions via macros, developers have the option of\n"
"choosing if runtime errors will be reported from the caller or from\n"
"inside the quote. Let's see an example:\n"
"\n"
"    # adder.ex\n"
"    defmodule Adder do\n"
"      @doc \"Defines a function that adds two numbers\"\n"
"      defmacro defadd do\n"
"        quote location: :keep do\n"
"          def add(a, b), do: a + b\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    # sample.ex\n"
"    defmodule Sample do\n"
"      import Adder\n"
"      defadd\n"
"    end\n"
"\n"
"When using `location: :keep` and invalid arguments are given to\n"
"`Sample.add/2`, the stacktrace information will point to the file\n"
"and line inside the quote. Without `location: :keep`, the error is\n"
"reported to where `defadd` was invoked. Note `location: :keep` affects\n"
"only definitions inside the quote.\n"
"\n"
"## Binding and unquote fragments\n"
"\n"
"Elixir quote/unquote mechanisms provides a functionality called\n"
"unquote fragments. Unquote fragments provide an easy way to generate\n"
"functions on the fly. Consider this example:\n"
"\n"
"    kv = [foo: 1, bar: 2]\n"
"    Enum.each kv, fn {k, v} ->\n"
"      def unquote(k)(), do: unquote(v)\n"
"    end\n"
"\n"
"In the example above, we have generated the functions `foo/0` and\n"
"`bar/0` dynamically. Now, imagine that, we want to convert this\n"
"functionality into a macro:\n"
"\n"
"    defmacro defkv(kv) do\n"
"      Enum.map kv, fn {k, v} ->\n"
"        quote do\n"
"          def unquote(k)(), do: unquote(v)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"We can invoke this macro as:\n"
"\n"
"    defkv [foo: 1, bar: 2]\n"
"\n"
"However, we can't invoke it as follows:\n"
"\n"
"    kv = [foo: 1, bar: 2]\n"
"    defkv kv\n"
"\n"
"This is because the macro is expecting its arguments to be a\n"
"keyword list at **compilation** time. Since in the example above\n"
"we are passing the representation of the variable `kv`, our\n"
"code fails.\n"
"\n"
"This is actually a common pitfall when developing macros. We are\n"
"assuming a particular shape in the macro. We can work around it\n"
"by unquoting the variable inside the quoted expression:\n"
"\n"
"    defmacro defkv(kv) do\n"
"      quote do\n"
"        Enum.each unquote(kv), fn {k, v} ->\n"
"          def unquote(k)(), do: unquote(v)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"If you try to run our new macro, you will notice it won't\n"
"even compile, complaining that the variables `k` and `v`\n"
"does not exist. This is because of the ambiguity: `unquote(k)`\n"
"can either be an unquote fragment, as previously, or a regular\n"
"unquote as in `unquote(kv)`.\n"
"\n"
"One solution to this problem is to disable unquoting in the\n"
"macro, however, doing that would make it impossible to inject the\n"
"`kv` representation into the tree. That's when the `:bind_quoted`\n"
"option comes to the rescue (again!). By using `:bind_quoted`, we\n"
"can automatically disable unquoting while still injecting the\n"
"desired variables into the tree:\n"
"\n"
"    defmacro defkv(kv) do\n"
"      quote bind_quoted: [kv: kv] do\n"
"        Enum.each kv, fn {k, v} ->\n"
"          def unquote(k)(), do: unquote(v)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"In fact, the `:bind_quoted` option is recommended every time\n"
"one desires to inject a value into the quote.\n"
msgstr ""
#. TRANSLATORS: Elixir.List Summary
#: lib/list.ex:1 
msgid ""
"Implements functions that only make sense for lists\n"
"and cannot be part of the Enum protocol. In general,\n"
"favor using the Enum API instead of List.\n"
"\n"
"Some functions in this module expect an index. Index\n"
"access for list is linear. Negative indexes are also\n"
"supported but they imply the list will be iterated twice,\n"
"one to calculate the proper index and another to the\n"
"operation.\n"
"\n"
"A decision was taken to delegate most functions to\n"
"Erlang's standard library but follow Elixir's convention\n"
"of receiving the target (in this case, a list) as the\n"
"first argument.\n"
msgstr ""
#. TRANSLATORS: def URI.encode_www_form(str)
#: lib/uri.ex:209 
msgid ""
"Encode a string as \"x-www-urlencoded\".\n"
"\n"
"## Example\n"
"\n"
"    iex> URI.encode_www_form(\"put: it+Ð¹\")\n"
"    \"put%3A+it%2B%D0%B9\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.resource(start_fun, next_fun, after_fun)
#: lib/stream.ex:1014 
msgid ""
"Emits a sequence of values for the given resource.\n"
"\n"
"Similar to `transform/2` but the initial accumulated value is\n"
"computed lazily via `start_fun` and executes an `after_fun` at\n"
"the end of enumeration (both in cases of success and failure).\n"
"\n"
"Successive values are generated by calling `next_fun` with the\n"
"previous accumulator (the initial value being the result returned\n"
"by `start_fun`) and it must return a tuple containing a list\n"
"of items to be emitted and the next accumulator. The enumeration\n"
"finishes if it returns `{:halt, acc}`.\n"
"\n"
"As the name says, this function is useful to stream values from\n"
"resources.\n"
"\n"
"## Examples\n"
"\n"
"    Stream.resource(fn -> File.open!(\"sample\") end,\n"
"                    fn file ->\n"
"                      case IO.read(file, :line) do\n"
"                        data when is_binary(data) -> {[data], file}\n"
"                        _ -> {:halt, file}\n"
"                      end\n"
"                    end,\n"
"                    fn file -> File.close(file) end)\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.unfold(next_acc, next_fun)
#: lib/stream.ex:1114 
msgid ""
"Emits a sequence of values for the given accumulator.\n"
"\n"
"Successive values are generated by calling `next_fun` with the previous\n"
"accumulator and it must return a tuple with the current value and next\n"
"accumulator. The enumeration finishes if it returns `nil`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.unfold(5, fn 0 -> nil; n -> {n, n-1} end) |> Enum.to_list()\n"
"    [5, 4, 3, 2, 1]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.iterate(start_value, next_fun)
#: lib/stream.ex:949 
msgid ""
"Emit a sequence of values, starting with `start_value`. Successive\n"
"values are generated by calling `next_fun` on the previous value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.iterate(0, &(&1+1)) |> Enum.take(5)\n"
"    [0,1,2,3,4]\n"
"\n"
msgstr ""
#. TRANSLATORS: def String.split(string, pattern, options \\ [])
#: lib/string.ex:289 
msgid ""
"Divides a string into substrings based on a pattern.\n"
"\n"
"Returns a list of these substrings. The pattern can\n"
"be a string, a list of strings or a regular expression.\n"
"\n"
"The string is split into as many parts as possible by\n"
"default, but can be controlled via the `parts: num` option.\n"
"If you pass `parts: :infinity`, it will return all possible parts.\n"
"\n"
"Empty strings are only removed from the result if the\n"
"`trim` option is set to `true`.\n"
"\n"
"## Examples\n"
"\n"
"Splitting with a string pattern:\n"
"\n"
"    iex> String.split(\"a,b,c\", \",\")\n"
"    [\"a\", \"b\", \"c\"]\n"
"\n"
"    iex> String.split(\"a,b,c\", \",\", parts: 2)\n"
"    [\"a\", \"b,c\"]\n"
"\n"
"    iex> String.split(\" a b c \", \" \", trim: true)\n"
"    [\"a\", \"b\", \"c\"]\n"
"\n"
"A list of patterns:\n"
"\n"
"    iex> String.split(\"1,2 3,4\", [\" \", \",\"])\n"
"    [\"1\", \"2\", \"3\", \"4\"]\n"
"\n"
"A regular expression:\n"
"\n"
"    iex> String.split(\"a,b,c\", ~r{,})\n"
"    [\"a\", \"b\", \"c\"]\n"
"\n"
"    iex> String.split(\"a,b,c\", ~r{,}, parts: 2)\n"
"    [\"a\", \"b,c\"]\n"
"\n"
"    iex> String.split(\" a b c \", ~r{\\s}, trim: true)\n"
"    [\"a\", \"b\", \"c\"]\n"
"\n"
"Splitting on empty patterns returns codepoints:\n"
"\n"
"    iex> String.split(\"abc\", ~r{})\n"
"    [\"a\", \"b\", \"c\", \"\"]\n"
"\n"
"    iex> String.split(\"abc\", \"\")\n"
"    [\"a\", \"b\", \"c\", \"\"]\n"
"\n"
"    iex> String.split(\"abc\", \"\", trim: true)\n"
"    [\"a\", \"b\", \"c\"]\n"
"\n"
"    iex> String.split(\"abc\", \"\", parts: 2)\n"
"    [\"a\", \"bc\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def String.split(binary)
#: lib/string.ex:228 
msgid ""
"Divides a string into substrings at each Unicode whitespace\n"
"occurrence with leading and trailing whitespace ignored.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.split(\"foo bar\")\n"
"    [\"foo\", \"bar\"]\n"
"\n"
"    iex> String.split(\"foo\" <> <<194, 133>> <> \"bar\")\n"
"    [\"foo\", \"bar\"]\n"
"\n"
"    iex> String.split(\" foo bar \")\n"
"    [\"foo\", \"bar\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def System.version()
#: lib/system.ex:56 
msgid ""
"Elixir version information.\n"
"\n"
"Returns Elixir's version as binary.\n"
msgstr ""
#. TRANSLATORS: def System.build_info()
#: lib/system.ex:64 
msgid ""
"Elixir build information.\n"
"\n"
"Returns a keyword list with Elixir version, git tag info and compilation date.\n"
msgstr ""
#. TRANSLATORS: def List.duplicate(elem, n)
#: lib/list.ex:53 
msgid ""
"Duplicates the given element `n` times in a list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.duplicate(\"hello\", 3)\n"
"    [\"hello\",\"hello\",\"hello\"]\n"
"\n"
"    iex> List.duplicate([1, 2], 2)\n"
"    [[1,2],[1,2]]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Module.get_attribute(module, key)
#: lib/module.ex:775 
msgid ""
"Gets the given attribute from a module. If the attribute\n"
"was marked with `accumulate` with `Module.register_attribute/3`,\n"
"a list is always returned.\n"
"\n"
"The `@` macro compiles to a call to this function. For example,\n"
"the following code:\n"
"\n"
"    @foo\n"
"\n"
"Expands close to:\n"
"\n"
"    Module.get_attribute(__MODULE__, :foo)\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Foo do\n"
"      Module.put_attribute __MODULE__, :value, 1\n"
"      Module.get_attribute __MODULE__, :value #=> 1\n"
"\n"
"      Module.register_attribute __MODULE__, :value, accumulate: true\n"
"      Module.put_attribute __MODULE__, :value, 1\n"
"      Module.get_attribute __MODULE__, :value #=> [1]\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def Path.join(list1)
#: lib/path.ex:448 
msgid ""
"Joins a list of strings.\n"
"\n"
"This function should be used to convert a list of strings to a path.\n"
"Note that any trailing slash is removed on join.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.join([\"~\", \"foo\"])\n"
"    \"~/foo\"\n"
"\n"
"    iex> Path.join([\"foo\"])\n"
"    \"foo\"\n"
"\n"
"    iex> Path.join([\"/\", \"foo\", \"bar/\"])\n"
"    \"/foo/bar\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def System.stacktrace()
#: lib/system.ex:330 
msgid ""
"Last exception stacktrace.\n"
"\n"
"Note that the Erlang VM (and therefore this function) does not\n"
"return the current stacktrace but rather the stacktrace of the\n"
"latest exception.\n"
"\n"
"Inlined by the compiler into `:erlang.get_stacktrace/0`.\n"
msgstr ""
#. TRANSLATORS: def System.halt(status \\ 0)
#: lib/system.ex:363 
msgid ""
"Halt the Erlang runtime system.\n"
"\n"
"Halts the Erlang runtime system where the argument `status` must be a\n"
"non-negative integer, the atom `:abort` or a binary.\n"
"\n"
"  * If an integer, the runtime system exits with the integer value which\n"
"    is returned to the operating system.\n"
"\n"
"  * If `:abort`, the runtime system aborts producing a core dump, if that is\n"
"    enabled in the operating system.\n"
"\n"
"  * If a string, an erlang crash dump is produced with status as slogan,\n"
"    and then the runtime system exits with status code 1.\n"
"\n"
"Note that on many platforms, only the status codes 0-255 are supported\n"
"by the operating system.\n"
"\n"
"For more information, check: http://www.erlang.org/doc/man/erlang.html#halt-1\n"
"\n"
"## Examples\n"
"\n"
"    System.halt(0)\n"
"    System.halt(1)\n"
"    System.halt(:abort)\n"
"\n"
msgstr ""
#. TRANSLATORS: def Supervisor.start_child(supervisor, child_spec_or_args)
#: lib/supervisor.ex:271 
msgid ""
"Dynamically adds and starts a child specification to the supervisor.\n"
"\n"
"`child_spec` should be a valid child specification (unless the supervisor\n"
"is a `:simple_one_for_one` supervisor, see below). The child process will\n"
"be started as defined in the child specification.\n"
"\n"
"In the case of `:simple_one_for_one`, the child specification defined in\n"
"the supervisor will be used and instead of a `child_spec`, an arbitrary list\n"
"of terms is expected. The child process will then be started by appending\n"
"the given list to the existing function arguments in the child specification.\n"
"\n"
"If there already exists a child specification with the specified id,\n"
"`child_spec` is discarded and the function returns an error with `:already_started`\n"
"or `:already_present` if the corresponding child process is running or not.\n"
"\n"
"If the child process start function returns `{:ok, child}` or `{:ok, child, info}`,\n"
"the child specification and pid is added to the supervisor and the function returns\n"
"the same value.\n"
"\n"
"If the child process start function returns `:ignore, the child specification is\n"
"added to the supervisor, the pid is set to undefined and the function returns\n"
"`{:ok, :undefined}`.\n"
"\n"
"If the child process start function returns an error tuple or an erroneous value,\n"
"or if it fails, the child specification is discarded and the function returns\n"
"`{:error, error}` where `error` is a term containing information about the error\n"
"and child specification.\n"
msgstr ""
#. TRANSLATORS: Elixir.IO.Stream Summary
#: lib/io/stream.ex:11 
msgid ""
"Defines a `IO.Stream` struct returned by `IO.stream/2` and `IO.binstream/2`.\n"
"\n"
"The following fields are public:\n"
"\n"
"  * `device`        - the IO device\n"
"  * `raw`           - a boolean indicating if bin functions should be used\n"
"  * `line_or_bytes` - if reading should read lines or a given amount of bytes\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.GenEvent.Stream Summary
#: lib/gen_event/stream.ex:1 
msgid ""
"Defines a `GenEvent` stream.\n"
"\n"
"This is a struct returned by `stream/2`. The struct is public and\n"
"contains the following fields:\n"
"\n"
"  * `:manager`  - the manager reference given to `GenEvent.stream/2`\n"
"  * `:timeout`  - the timeout in between events, defaults to `:infinity`\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.File.Stream Summary
#: lib/file/stream.ex:1 
msgid ""
"Defines a `File.Stream` struct returned by `File.stream!/3`.\n"
"\n"
"The following fields are public:\n"
"\n"
"  * `path`          - the file path\n"
"  * `modes`         - the file modes\n"
"  * `raw`           - a boolean indicating if bin functions should be used\n"
"  * `line_or_bytes` - if reading should read lines or a given amount of bytes\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.Range Summary
#: lib/range.ex:1 
msgid ""
"Defines a Range.\n"
"\n"
"A Range is represented internally as a struct. However,\n"
"the most common form of creating and matching on ranges\n"
"is via the `../2` macro, auto-imported from Kernel:\n"
"\n"
"    iex> range = 1..3\n"
"    1..3\n"
"    iex> first .. last = range\n"
"    iex> first\n"
"    1\n"
"    iex> last\n"
"    3\n"
"\n"
msgstr ""
#. TRANSLATORS: def System.cwd()
#: lib/system.ex:95 
msgid ""
"Current working directory.\n"
"\n"
"Returns the current working directory or `nil` if one\n"
"is not available.\n"
msgstr ""
#. TRANSLATORS: def System.cwd!()
#: lib/system.ex:116 
msgid ""
"Current working directory, exception on error.\n"
"\n"
"Returns the current working directory or raises `RuntimeError`.\n"
msgstr ""
#. TRANSLATORS: def URI.decode_query(q, dict \\ %{})
#: lib/uri.ex:102 
msgid ""
"Decodes a query string into a dictionary (by default uses a map).\n"
"\n"
"Given a query string of the form \"key1=value1&key2=value2...\", produces a\n"
"map with one entry for each key-value pair. Each key and value will be a\n"
"binary. Keys and values will be percent-unescaped.\n"
"\n"
"Use `query_decoder/1` if you want to iterate over each value manually.\n"
"\n"
"## Examples\n"
"\n"
"    iex> URI.decode_query(\"foo=1&bar=2\")\n"
"    %{\"bar\" => \"2\", \"foo\" => \"1\"}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Base.url_decode64!(string)
#: lib/base.ex:319 
msgid ""
"Decodes a base 64 encoded string with URL and filename safe alphabet\n"
"into a binary string.\n"
"\n"
"An `ArgumentError` exception is raised if the padding is incorrect or\n"
"a non-alphabet character is present in the string.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Base.url_decode64!(\"_3_-_A==\")\n"
"    <<255,127,254,252>>\n"
"\n"
msgstr ""
#. TRANSLATORS: def Base.url_decode64(string)
#: lib/base.ex:299 
msgid ""
"Decodes a base 64 encoded string with URL and filename safe alphabet\n"
"into a binary string.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Base.url_decode64(\"_3_-_A==\")\n"
"    {:ok, <<255,127,254,252>>}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Base.decode64!(string)
#: lib/base.ex:269 
msgid ""
"Decodes a base 64 encoded string into a binary string.\n"
"\n"
"The following alphabet is used both for encoding and decoding:\n"
"\n"
"An `ArgumentError` exception is raised if the padding is incorrect or\n"
"a non-alphabet character is present in the string.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Base.decode64!(\"Zm9vYmFy\")\n"
"    \"foobar\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Base.decode64(string)
#: lib/base.ex:248 
msgid ""
"Decodes a base 64 encoded string into a binary string.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Base.decode64(\"Zm9vYmFy\")\n"
"    {:ok, \"foobar\"}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Base.hex_decode32!(string, opts \\ [])
#: lib/base.ex:479 
msgid ""
"Decodes a base 32 encoded string with extended hexadecimal alphabet\n"
"into a binary string.\n"
"\n"
"Accepts an atom `:upper` (default) for decoding from upper case characters or\n"
"`:lower` for lower case characters. `:mixed` can be given for mixed case\n"
"characters.\n"
"\n"
"An `ArgumentError` exception is raised if the padding is incorrect or\n"
"a non-alphabet character is present in the string.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Base.hex_decode32!(\"CPNMUOJ1E8======\")\n"
"    \"foobar\"\n"
"\n"
"    iex> Base.hex_decode32!(\"cpnmuoj1e8======\", case: :lower)\n"
"    \"foobar\"\n"
"\n"
"    iex> Base.hex_decode32!(\"cpnMuOJ1E8======\", case: :mixed)\n"
"    \"foobar\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Base.hex_decode32(string, opts \\ [])
#: lib/base.ex:447 
msgid ""
"Decodes a base 32 encoded string with extended hexadecimal alphabet\n"
"into a binary string.\n"
"\n"
"Accepts an atom `:upper` (default) for decoding from upper case characters or\n"
"`:lower` for lower case characters. `:mixed` can be given for mixed case\n"
"characters.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Base.hex_decode32(\"CPNMUOJ1E8======\")\n"
"    {:ok, \"foobar\"}\n"
"\n"
"    iex> Base.hex_decode32(\"cpnmuoj1e8======\", case: :lower)\n"
"    {:ok, \"foobar\"}\n"
"\n"
"    iex> Base.hex_decode32(\"cpnMuOJ1E8======\", case: :mixed)\n"
"    {:ok, \"foobar\"}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Base.decode32!(string, opts \\ [])
#: lib/base.ex:397 
msgid ""
"Decodes a base 32 encoded string into a binary string.\n"
"\n"
"Accepts an atom `:upper` (default) for decoding from upper case characters or\n"
"`:lower` for lower case characters. `:mixed` can be given for mixed case\n"
"characters.\n"
"\n"
"An `ArgumentError` exception is raised if the padding is incorrect or\n"
"a non-alphabet character is present in the string.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Base.decode32!(\"MZXW6YTBOI======\")\n"
"    \"foobar\"\n"
"\n"
"    iex> Base.decode32!(\"mzxw6ytboi======\", case: :lower)\n"
"    \"foobar\"\n"
"\n"
"    iex> Base.decode32!(\"mzXW6ytBOi======\", case: :mixed)\n"
"    \"foobar\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Base.decode32(string, opts \\ [])
#: lib/base.ex:366 
msgid ""
"Decodes a base 32 encoded string into a binary string.\n"
"\n"
"Accepts an atom `:upper` (default) for decoding from upper case characters or\n"
"`:lower` for lower case characters. `:mixed` can be given for mixed case\n"
"characters.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Base.decode32(\"MZXW6YTBOI======\")\n"
"    {:ok, \"foobar\"}\n"
"\n"
"    iex> Base.decode32(\"mzxw6ytboi======\", case: :lower)\n"
"    {:ok, \"foobar\"}\n"
"\n"
"    iex> Base.decode32(\"mzXW6ytBOi======\", case: :mixed)\n"
"    {:ok, \"foobar\"}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Base.decode16!(string, opts \\ [])
#: lib/base.ex:219 
msgid ""
"Decodes a base 16 encoded string into a binary string.\n"
"\n"
"Accepts an atom `:upper` (default) for decoding from upper case characters or\n"
"`:lower` for lower case characters. `:mixed` can be given for mixed case\n"
"characters.\n"
"\n"
"An `ArgumentError` exception is raised if the padding is incorrect or\n"
"a non-alphabet character is present in the string.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Base.decode16!(\"666F6F626172\")\n"
"    \"foobar\"\n"
"\n"
"    iex> Base.decode16!(\"666f6f626172\", case: :lower)\n"
"    \"foobar\"\n"
"\n"
"    iex> Base.decode16!(\"666f6F626172\", case: :mixed)\n"
"    \"foobar\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Base.decode16(string, opts \\ [])
#: lib/base.ex:188 
msgid ""
"Decodes a base 16 encoded string into a binary string.\n"
"\n"
"Accepts an atom `:upper` (default) for decoding from upper case characters or\n"
"`:lower` for lower case characters. `:mixed` can be given for mixed case\n"
"characters.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Base.decode16(\"666F6F626172\")\n"
"    {:ok, \"foobar\"}\n"
"\n"
"    iex> Base.decode16(\"666f6f626172\", case: :lower)\n"
"    {:ok, \"foobar\"}\n"
"\n"
"    iex> Base.decode16(\"666f6F626172\", case: :mixed)\n"
"    {:ok, \"foobar\"}\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.Typespec.defopaque(type)
#: lib/kernel/typespec.ex:234 
msgid ""
"Defines an opaque type.\n"
"This macro is responsible for handling the attribute `@opaque`.\n"
"\n"
"## Examples\n"
"\n"
"    @opaque my_type :: atom\n"
"\n"
msgstr ""
#. TRANSLATORS: def System.delete_env(varname)
#: lib/system.ex:316 
msgid ""
"Deletes an environment variable.\n"
"\n"
"Removes the variable `varname` from the environment.\n"
msgstr ""
#. TRANSLATORS: def Code.delete_path(path)
#: lib/code.ex:50 
msgid ""
"Delete a path from the Erlang VM code path.\n"
"\n"
"The path is expanded with `Path.expand/1` before being deleted.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.defdelegate(funs, opts)
#: lib/kernel.ex:3316 
msgid ""
"Defines the given functions in the current module that will\n"
"delegate to the given `target`. Functions defined with\n"
"`defdelegate` are public and are allowed to be invoked\n"
"from external. If you find yourself wishing to define a\n"
"delegation as private, you should likely use import\n"
"instead.\n"
"\n"
"Delegation only works with functions, delegating to macros\n"
"is not supported.\n"
"\n"
"## Options\n"
"\n"
"  * `:to` - the expression to delegate to. Any expression\n"
"    is allowed and its results will be calculated on runtime.\n"
"\n"
"  * `:as` - the function to call on the target given in `:to`.\n"
"    This parameter is optional and defaults to the name being\n"
"    delegated.\n"
"\n"
"  * `:append_first` - if true, when delegated, first argument\n"
"    passed to the delegate will be relocated to the end of the\n"
"    arguments when dispatched to the target.\n"
"\n"
"    The motivation behind this is because Elixir normalizes\n"
"    the \"handle\" as a first argument and some Erlang modules\n"
"    expect it as last argument.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule MyList do\n"
"      defdelegate reverse(list), to: :lists\n"
"      defdelegate [reverse(list), map(callback, list)], to: :lists\n"
"      defdelegate other_reverse(list), to: :lists, as: :reverse\n"
"    end\n"
"\n"
"    MyList.reverse([1, 2, 3])\n"
"    #=> [3,2,1]\n"
"\n"
"    MyList.other_reverse([1, 2, 3])\n"
"    #=> [3,2,1]\n"
"\n"
msgstr ""
#. TRANSLATORS: def File.ln_s(existing, new)
#: lib/file.ex:356 
msgid ""
"Creates a symbolic link `new` to the file or directory `existing`.\n"
"\n"
"Returns `:ok` if successful, `{:error, reason}` otherwise.\n"
"If the operating system does not support symlinks, returns\n"
"`{:error, :enotsup}`.\n"
msgstr ""
#. TRANSLATORS: def IO.iodata_to_binary(item)
#: lib/io.ex:373 
msgid ""
"Converts iodata (a list of integers representing bytes, lists\n"
"and binaries) into a binary.\n"
"\n"
"Notice that this function treats lists of integers as raw bytes\n"
"and does not perform any kind of encoding conversion. If you want\n"
"to convert from a char list to a string (UTF-8 encoded), please\n"
"use `chardata_to_string/1` instead.\n"
"\n"
"If this function receives a binary, the same binary is returned.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> bin1 = <<1, 2, 3>>\n"
"    iex> bin2 = <<4, 5>>\n"
"    iex> bin3 = <<6>>\n"
"    iex> IO.iodata_to_binary([bin1, 1, [2, 3, bin2], 4|bin3])\n"
"    <<1,2,3,1,2,3,4,5,4,6>>\n"
"\n"
"    iex> bin = <<1, 2, 3>>\n"
"    iex> IO.iodata_to_binary(bin)\n"
"    <<1,2,3>>\n"
"\n"
msgstr ""
#. TRANSLATORS: def IO.chardata_to_string(string)
#: lib/io.ex:329 
msgid ""
"Converts chardata (a list of integers representing codepoints,\n"
"lists and strings) into a string.\n"
"\n"
"In case the conversion fails, it raises a `UnicodeConversionError`.\n"
"If a string is given, returns the string itself.\n"
"\n"
"## Examples\n"
"\n"
"    iex> IO.chardata_to_string([0x00E6, 0x00DF])\n"
"    \"Ã¦ÃŸ\"\n"
"\n"
"    iex> IO.chardata_to_string([0x0061, \"bc\"])\n"
"    \"abc\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.struct(struct, kv \\ [])
#: lib/kernel.ex:1489 
msgid ""
"Creates and updates structs.\n"
"\n"
"The struct argument may be an atom (which defines `defstruct`)\n"
"or a struct itself. The second argument is any Enumerable that\n"
"emits two-item tuples (key-value) during enumeration.\n"
"\n"
"If one of the keys in the Enumerable does not exist in the struct,\n"
"they are automatically discarded.\n"
"\n"
"This function is useful for dynamically creating and updating\n"
"structs.\n"
"\n"
"## Example\n"
"\n"
"    defmodule User do\n"
"      defstruct name: \"john\"\n"
"    end\n"
"\n"
"    struct(User)\n"
"    #=> %User{name: \"john\"}\n"
"\n"
"    opts = [name: \"meg\"]\n"
"    user = struct(User, opts)\n"
"    #=> %User{name: \"meg\"}\n"
"\n"
"    struct(user, unknown: \"value\")\n"
"    #=> %User{name: \"meg\"}\n"
"\n"
msgstr ""
#. TRANSLATORS: def StringIO.open(string, options \\ [])
#: lib/string_io.ex:38 
msgid ""
"Creates an IO device.\n"
"\n"
"If the `:capture_prompt` option is set to `true`,\n"
"prompts (specified as arguments to `IO.get*` functions)\n"
"are captured.\n"
"\n"
"## Examples\n"
"\n"
"    iex> {:ok, pid} = StringIO.open(\"foo\")\n"
"    iex> IO.gets(pid, \">\")\n"
"    \"foo\"\n"
"    iex> StringIO.contents(pid)\n"
"    {\"\", \"\"}\n"
"\n"
"    iex> {:ok, pid} = StringIO.open(\"foo\", capture_prompt: true)\n"
"    iex> IO.gets(pid, \">\")\n"
"    \"foo\"\n"
"    iex> StringIO.contents(pid)\n"
"    {\"\", \">\"}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Atom.to_string(atom)
#: lib/atom.ex:12 
msgid ""
"Converts an atom to string.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Atom.to_char_list(atom)
#: lib/atom.ex:22 
msgid ""
"Converts an atom to a char list.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Inspect.Algebra.to_doc(map, opts)
#: lib/inspect/algebra.ex:182 
msgid ""
"Converts an Elixir structure to an algebra document\n"
"according to the inspect protocol.\n"
msgstr ""
#. TRANSLATORS: def Supervisor.Spec.worker(module, args, options \\ [])
#: lib/supervisor/spec.ex:206 
msgid ""
"Defines the given `module` as a worker which will be started\n"
"with the given arguments.\n"
"\n"
"    worker ExUnit.Runner, [], restart: :permanent\n"
"\n"
"By default, the function `start_link` is invoked on the given\n"
"module. Overall, the default values for the options are:\n"
"\n"
"    [id: module,\n"
"     function: :start_link,\n"
"     restart: :permanent,\n"
"     shutdown: 5000,\n"
"     modules: [module]]\n"
"\n"
"Check `Supervisor.Spec` module docs for more information on\n"
"the options.\n"
msgstr ""
#. TRANSLATORS: def Supervisor.Spec.supervisor(module, args, options \\ [])
#: lib/supervisor/spec.ex:230 
msgid ""
"Defines the given `module` as a supervisor which will be started\n"
"with the given arguments.\n"
"\n"
"    supervisor ExUnit.Runner, [], restart: :permanent\n"
"\n"
"By default, the function `start_link` is invoked on the given\n"
"module. Overall, the default values for the options are:\n"
"\n"
"    [id: module,\n"
"     function: :start_link,\n"
"     restart: :permanent,\n"
"     shutdown: :infinity,\n"
"     modules: [module]]\n"
"\n"
"Check `Supervisor.Spec` module docs for more information on\n"
"the options.\n"
msgstr ""
#. TRANSLATORS: Elixir.Inspect.Opts Summary
#: lib/inspect/algebra.ex:1 
msgid ""
"Defines the Inspect.Opts used by the Inspect protocol.\n"
"\n"
"The following fields are available:\n"
"\n"
"  * `:structs` - when false, structs are not formatted by the inspect\n"
"    protocol, they are instead printed as maps, defaults to true.\n"
"\n"
"  * `:binaries` - when `:as_strings` all binaries will be printed as strings,\n"
"    non-printable bytes will be escaped.\n"
"\n"
"    When `:as_binaries` all binaries will be printed in bit syntax.\n"
"\n"
"    When the default `:infer`, the binary will be printed as a string if it\n"
"    is printable, otherwise in bit syntax.\n"
"\n"
"  * `:char_lists` - when `:as_char_lists` all lists will be printed as char\n"
"    lists, non-printable elements will be escaped.\n"
"\n"
"    When `:as_lists` all lists will be printed as lists.\n"
"\n"
"    When the default `:infer`, the list will be printed as a char list if it\n"
"    is printable, otherwise as list.\n"
"\n"
"  * `:limit` - limits the number of items that are printed for tuples,\n"
"    bitstrings, and lists, does not apply to strings nor char lists, defaults\n"
"    to 50.\n"
"\n"
"  * `:pretty` - if set to true enables pretty printing, defaults to false.\n"
"\n"
"  * `:width` - defaults to the 80 characters, used when pretty is true or\n"
"    when printing to IO devices.\n"
"\n"
"  * `:base` - print integers as :binary, :octal, :decimal, or :hex, defaults\n"
"    to :decimal\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.defimpl(name, opts, do_block \\ [])
#: lib/kernel.ex:3186 
msgid ""
"Defines an implementation for the given protocol. See\n"
"`defprotocol/2` for examples.\n"
"\n"
"Inside an implementation, the name of the protocol can be accessed\n"
"via `@protocol` and the current target as `@for`.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.defexception(fields)
#: lib/kernel.ex:2999 
msgid ""
"Defines an exception.\n"
"\n"
"Exceptions are structs backed by a module that implements\n"
"the Exception behaviour. The Exception behaviour requires\n"
"two functions to be implemented:\n"
"\n"
"  * `exception/1` - that receives the arguments given to `raise/2`\n"
"     and returns the exception struct. The default implementation\n"
"     accepts a set of keyword arguments that is merged into the\n"
"     struct.\n"
"\n"
"  * `message/1` - receives the exception struct and must return its\n"
"    message. Most commonly exceptions have a message field which\n"
"    by default is accessed by this function. However, if your exception\n"
"    does not have a message field, this function must be explicitly\n"
"    implemented.\n"
"\n"
"Since exceptions are structs, all the API supported by `defstruct/1`\n"
"is also available in `defexception/1`.\n"
"\n"
"## Raising exceptions\n"
"\n"
"The most common way to raise an exception is via the `raise/2`\n"
"function:\n"
"\n"
"    defmodule MyAppError do\n"
"      defexception [:message]\n"
"    end\n"
"\n"
"    value = [:hello]\n"
"\n"
"    raise MyAppError,\n"
"      message: \"did not get what was expected, got: #{inspect value}\"\n"
"\n"
"In many cases it is more convenient to pass the expected value to\n"
"`raise` and generate the message in the `exception/1` callback:\n"
"\n"
"    defmodule MyAppError do\n"
"      defexception [:message]\n"
"\n"
"      def exception(value) do\n"
"        msg = \"did not get what was expected, got: #{inspect value}\"\n"
"        %MyAppError{message: msg}\n"
"      end\n"
"    end\n"
"\n"
"    raise MyAppError, value\n"
"\n"
"The example above is the preferred mechanism for customizing\n"
"exception messages.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.defstruct(fields)
#: lib/kernel.ex:2913 
msgid ""
"Defines a struct for the current module.\n"
"\n"
"A struct is a tagged map that allows developers to provide\n"
"default values for keys, tags to be used in polymorphic\n"
"dispatches and compile time assertions.\n"
"\n"
"To define a struct, a developer needs to only define\n"
"a function named `__struct__/0` that returns a map with the\n"
"structs field. This macro is a convenience for defining such\n"
"function, with the addition of a type `t` and deriving\n"
"conveniences.\n"
"\n"
"For more information about structs, please check\n"
"`Kernel.SpecialForms.%/2`.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule User do\n"
"      defstruct name: nil, age: nil\n"
"    end\n"
"\n"
"Struct fields are evaluated at definition time, which allows\n"
"them to be dynamic. In the example below, `10 + 11` will be\n"
"evaluated at compilation time and the age field will be stored\n"
"with value `21`:\n"
"\n"
"    defmodule User do\n"
"      defstruct name: nil, age: 10 + 11\n"
"    end\n"
"\n"
"## Deriving\n"
"\n"
"Although structs are maps, by default structs do not implement\n"
"any of the protocols implemented for maps. For example, if you\n"
"attempt to use the access protocol with the User struct, it\n"
"will lead to an error:\n"
"\n"
"    %User{}[:age]\n"
"    ** (Protocol.UndefinedError) protocol Access not implemented for %User{...}\n"
"\n"
"However, `defstruct/1` allows implementation for protocols to\n"
"derived by defining a `@derive` attribute as a list before `defstruct/1`\n"
"is invoked:\n"
"\n"
"    defmodule User do\n"
"      @derive [Access]\n"
"      defstruct name: nil, age: 10 + 11\n"
"    end\n"
"\n"
"    %User{}[:age] #=> 21\n"
"\n"
"For each protocol given to `@derive`, Elixir will assert there is an\n"
"implementation of that protocol for maps and check if the map\n"
"implementation defines a `__deriving__/3` callback. If so, the callback\n"
"is invoked, otherwise an implementation that simply points to the map\n"
"one is automatically derived.\n"
"\n"
"## Types\n"
"\n"
"It is recommended to define types for structs, by convention this type\n"
"is called `t`. To define a struct in a type the struct literal syntax\n"
"is used:\n"
"\n"
"    defmodule User do\n"
"      defstruct name: \"john\", age: 25\n"
"      @type t :: %User{name: String.t, age: integer}\n"
"    end\n"
"\n"
"It is recommended to only use the struct syntax when defining the struct's\n"
"type. When referring to another struct use `User.t`, not `%User{}`. Fields\n"
"in the struct not included in the type defaults to `term`.\n"
"\n"
"Private structs that are not used outside its module should use the private\n"
"type attribute `@typep`. Public structs whose internal structure is private\n"
"to the local module (you are not allowed to pattern match it or directly\n"
"access fields) should use the `@opaque` attribute. Structs whose internal\n"
"structure is public should use `@type`.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.fn(clauses)
#: lib/kernel/special_forms.ex:1207 
msgid ""
"Defines an anonymous function.\n"
"\n"
"## Examples\n"
"\n"
"    iex> add = fn a, b -> a + b end\n"
"    iex> add.(1, 2)\n"
"    3\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.Typespec.deftype(type)
#: lib/kernel/typespec.ex:219 
msgid ""
"Defines a type.\n"
"This macro is responsible for handling the attribute `@type`.\n"
"\n"
"## Examples\n"
"\n"
"    @type my_type :: atom\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.Typespec.defspec(spec)
#: lib/kernel/typespec.ex:264 
msgid ""
"Defines a spec.\n"
"This macro is responsible for handling the attribute `@spec`.\n"
"\n"
"## Examples\n"
"\n"
"    @spec add(number, number) :: number\n"
"\n"
msgstr ""
#. TRANSLATORS: def Module.create(module, quoted, opts)
#: lib/module.ex:395 
msgid ""
"Creates a module with the given name and defined by\n"
"the given quoted expressions.\n"
"\n"
"The line where the module is defined and its file **must**\n"
"be passed as options.\n"
"\n"
"## Examples\n"
"\n"
"    contents =\n"
"      quote do\n"
"        def world, do: true\n"
"      end\n"
"\n"
"    Module.create(Hello, contents, Macro.Env.location(__ENV__))\n"
"\n"
"    Hello.world #=> true\n"
"\n"
"## Differences from `defmodule`\n"
"\n"
"`Module.create` works similarly to `defmodule` and\n"
"return the same results. While one could also use\n"
"`defmodule` to define modules dynamically, this\n"
"function is preferred when the module body is given\n"
"by a quoted expression.\n"
"\n"
"Another important distinction is that `Module.create`\n"
"allows you to control the environment variables used\n"
"when defining the module, while `defmodule` automatically\n"
"shares the same environment.\n"
msgstr ""
#. TRANSLATORS: defmacro Record.defrecord(name, tag \\ nil, kv)
#: lib/record.ex:160 
msgid ""
"Defines a set of macros to create and access a record.\n"
"\n"
"The macros are going to have `name`, a tag (which defaults)\n"
"to the name if none is given, and a set of fields given by\n"
"`kv`.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule User do\n"
"      require Record\n"
"      Record.defrecord :user, [name: \"meg\", age: \"25\"]\n"
"    end\n"
"\n"
"In the example above, a set of macros named `user` but with different\n"
"arities will be defined to manipulate the underlying record:\n"
"\n"
"    # To create records\n"
"    record = user()        #=> {:user, \"meg\", 25}\n"
"    record = user(age: 26) #=> {:user, \"meg\", 26}\n"
"\n"
"    # To get a field from the record\n"
"    user(record, :name) #=> \"meg\"\n"
"\n"
"    # To update the record\n"
"    user(record, age: 26) #=> {:user, \"meg\", 26}\n"
"\n"
"    # Convert a record to a keyword list\n"
"    user(record) #=> [name: \"meg\", age: 26]\n"
"\n"
"By default, Elixir uses the record name as the first element of\n"
"the tuple (the tag). But it can be changed to something else:\n"
"\n"
"    defmodule User do\n"
"      require Record\n"
"      Record.defrecord :user, User, name: nil\n"
"    end\n"
"\n"
"    require User\n"
"    User.user() #=> {User, nil}\n"
"\n"
msgstr ""
#. TRANSLATORS: def URI.decode_www_form(str)
#: lib/uri.ex:254 
msgid ""
"Decode a string as \"x-www-urlencoded\".\n"
"\n"
"## Examples\n"
"\n"
"    iex> URI.decode_www_form(\"%3Call+in%2F\")\n"
"    \"<all in/\"\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.{}(args)
#: lib/kernel/special_forms.ex:43 
msgid ""
"Creates a tuple.\n"
"\n"
"Only two item tuples are considered literals in Elixir.\n"
"Therefore all other tuples are represented in the AST\n"
"as a call to the special form `:{}`.\n"
"\n"
"Conveniences for manipulating tuples can be found in the\n"
"`Tuple` module. Some functions for working with tuples are\n"
"also available in `Kernel`, namely `Kernel.elem/2`,\n"
"`Kernel.put_elem/3` and `Kernel.tuple_size/1`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> {1, 2, 3}\n"
"    {1, 2, 3}\n"
"\n"
"    iex> quote do: {1, 2, 3}\n"
"    {:{}, [], [1,2,3]}\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.%(struct, map)
#: lib/kernel/special_forms.ex:165 
msgid ""
"Creates a struct.\n"
"\n"
"A struct is a tagged map that allows developers to provide\n"
"default values for keys, tags to be used in polymorphic\n"
"dispatches and compile time assertions.\n"
"\n"
"To define a struct, you just need to implement the `__struct__/0`\n"
"function in a module:\n"
"\n"
"    defmodule User do\n"
"      def __struct__ do\n"
"        %{name: \"john\", age: 27}\n"
"      end\n"
"    end\n"
"\n"
"In practice though, structs are usually defined with the\n"
"`Kernel.defstruct/1` macro:\n"
"\n"
"    defmodule User do\n"
"      defstruct name: \"john\", age: 27\n"
"    end\n"
"\n"
"Now a struct can be created as follows:\n"
"\n"
"    %User{}\n"
"\n"
"Underneath a struct is just a map with a `__struct__` field\n"
"pointing to the `User` module:\n"
"\n"
"    %User{} == %{__struct__: User, name: \"john\", age: 27}\n"
"\n"
"A struct also validates that the given keys are part of the defined\n"
"struct. The example below will fail because there is no key\n"
"`:full_name` in the `User` struct:\n"
"\n"
"    %User{full_name: \"john doe\"}\n"
"\n"
"Note that a struct specifies a minimum set of keys required\n"
"for operations. Other keys can be added to structs via the\n"
"regular map operations:\n"
"\n"
"    user = %User{}\n"
"    Map.put(user, :a_non_struct_key, :value)\n"
"\n"
"An update operation specific for structs is also available:\n"
"\n"
"    %User{user | age: 28}\n"
"\n"
"The syntax above will guarantee the given keys are valid at\n"
"compilation time and it will guarantee at runtime the given\n"
"argument is a struct, failing with `BadStructError` otherwise.\n"
"\n"
"Although structs are maps, by default structs do not implement\n"
"any of the protocols implemented for maps. Check\n"
"`Kernel.defprotocol/2` for more information on how structs\n"
"can be used with protocols for polymorphic dispatch. Also\n"
"see `Kernel.struct/2` for examples on how to create and update\n"
"structs dynamically.\n"
msgstr ""
#. TRANSLATORS: def Kernel.Typespec.type_to_ast(arg1)
#: lib/kernel/typespec.ex:385 
msgid ""
"Converts a type clause back to Elixir AST.\n"
msgstr ""
#. TRANSLATORS: def Map.from_struct(struct)
#: lib/map.ex:60 
msgid ""
"Converts a struct to map.\n"
"\n"
"It accepts the struct module or a struct itself and\n"
"simply removes the `__struct__` field from the struct.\n"
"\n"
"## Example\n"
"\n"
"    defmodule User do\n"
"      defstruct [:name]\n"
"    end\n"
"\n"
"    Map.from_struct(User)\n"
"    #=> %{name: nil}\n"
"\n"
"    Map.from_struct(%User{name: \"john\"})\n"
"    #=> %{name: \"john\"}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.with_index(enum)
#: lib/stream.ex:763 
msgid ""
"Creates a stream where each item in the enumerable will\n"
"be wrapped in a tuple alongside its index.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.with_index([1, 2, 3])\n"
"    iex> Enum.to_list(stream)\n"
"    [{1,0},{2,1},{3,2}]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.reject(enum, fun)
#: lib/stream.ex:430 
msgid ""
"Creates a stream that will reject elements according to\n"
"the given function on enumeration.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.reject([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    iex> Enum.to_list(stream)\n"
"    [1,3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.flat_map(enum, mapper)
#: lib/stream.ex:307 
msgid ""
"Creates a stream that will apply the given function on enumeration and\n"
"flatten the result.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.flat_map([1, 2, 3], fn(x) -> [x, x * 2] end)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 2, 4, 3, 6]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.map(enum, fun)
#: lib/stream.ex:414 
msgid ""
"Creates a stream that will apply the given function on\n"
"enumeration.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.map([1, 2, 3], fn(x) -> x * 2 end)\n"
"    iex> Enum.to_list(stream)\n"
"    [2,4,6]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.take_every(enum, n)
#: lib/stream.ex:570 
msgid ""
"Creates a stream that takes every `n` item from the enumerable.\n"
"\n"
"The first item is always included, unless `n` is 0.\n"
"\n"
"`n` must be a non-negative integer, or `FunctionClauseError` will be thrown.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.take_every(1..10, 2)\n"
"    iex> Enum.to_list(stream)\n"
"    [1,3,5,7,9]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.uniq(enum, fun \\ fn x -> x end)
#: lib/stream.ex:747 
msgid ""
"Creates a stream that only emits elements if they are unique.\n"
"\n"
"Keep in mind that, in order to know if an element is unique\n"
"or not, this function needs to store all unique values emitted\n"
"by the stream. Therefore, if the stream is infinite, the number\n"
"of items stored will grow infinitely, never being garbage collected.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.uniq([1, 2, 3, 2, 1]) |> Enum.to_list\n"
"    [1, 2, 3]\n"
"\n"
"    iex> Stream.uniq([{1, :x}, {2, :y}, {1, :z}], fn {x, _} -> x end) |> Enum.to_list\n"
"    [{1,:x}, {2,:y}]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.filter(enum, fun)
#: lib/stream.ex:323 
msgid ""
"Creates a stream that filters elements according to\n"
"the given function on enumeration.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.filter([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    iex> Enum.to_list(stream)\n"
"    [2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.filter_map(enum, filter, mapper)
#: lib/stream.ex:341 
msgid ""
"Creates a stream that filters and then maps elements according\n"
"to given functions.\n"
"\n"
"Exists for symmetry with `Enum.filter_map/3`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.filter_map(1..6, fn(x) -> rem(x, 2) == 0 end, &(&1 * 2))\n"
"    iex> Enum.to_list(stream)\n"
"    [4,8,12]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.concat(first, second)
#: lib/stream.ex:801 
msgid ""
"Creates a stream that enumerates the first argument, followed by the second.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.concat(1..3, 4..6)\n"
"    iex> Enum.to_list(stream)\n"
"    [1,2,3,4,5,6]\n"
"\n"
"    iex> stream1 = Stream.cycle([1, 2, 3])\n"
"    iex> stream2 = Stream.cycle([4, 5, 6])\n"
"    iex> stream = Stream.concat(stream1, stream2)\n"
"    iex> Enum.take(stream, 6)\n"
"    [1,2,3,1,2,3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.concat(enumerables)
#: lib/stream.ex:780 
msgid ""
"Creates a stream that enumerates each enumerable in an enumerable.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.concat([1..3, 4..6, 7..9])\n"
"    iex> Enum.to_list(stream)\n"
"    [1,2,3,4,5,6,7,8,9]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.interval(n)
#: lib/stream.ex:357 
msgid ""
"Creates a stream that emits a value every `n` milliseconds.\n"
"\n"
"The values emitted are an increasing counter starting at `0`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.interval(10) |> Enum.take(10)\n"
"    [0,1,2,3,4,5,6,7,8,9]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.timer(n)
#: lib/stream.ex:604 
msgid ""
"Creates a stream that emits a single value after `n` milliseconds.\n"
"\n"
"The value emitted is `0`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.timer(10) |> Enum.to_list\n"
"    [0]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.cycle(enumerable)
#: lib/stream.ex:892 
msgid ""
"Creates a stream that cycles through the given enumerable,\n"
"infinitely.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.cycle([1,2,3])\n"
"    iex> Enum.take(stream, 5)\n"
"    [1,2,3,1,2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.scan(enum, acc, fun)
#: lib/stream.ex:489 
msgid ""
"Creates a stream that applies the given function to each\n"
"element, emits the result and uses the same result as the accumulator\n"
"for the next computation. Uses the given `acc` as the starting value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.scan(1..5, 0, &(&1 + &2))\n"
"    iex> Enum.to_list(stream)\n"
"    [1,3,6,10,15]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Stream.scan(enum, fun)
#: lib/stream.ex:472 
msgid ""
"Creates a stream that applies the given function to each\n"
"element, emits the result and uses the same result as the accumulator\n"
"for the next computation.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.scan(1..5, &(&1 + &2))\n"
"    iex> Enum.to_list(stream)\n"
"    [1,3,6,10,15]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Tuple.duplicate(data, size)
#: lib/tuple.ex:21 
msgid ""
"Creates a new tuple.\n"
"\n"
"Creates a tuple of size `size` containing the\n"
"given `data` at every position.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Tuple.duplicate(:hello, 3)\n"
"    {:hello, :hello, :hello}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Range.new(first, last)
#: lib/range.ex:27 
msgid ""
"Creates a new range.\n"
msgstr ""
#. TRANSLATORS: def HashSet.new()
#: lib/hash_set.ex:36 
msgid ""
"Creates a new empty set.\n"
msgstr ""
#. TRANSLATORS: def HashDict.new()
#: lib/hash_dict.ex:36 
msgid ""
"Creates a new empty dict.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.%{}(args)
#: lib/kernel/special_forms.ex:103 
msgid ""
"Creates a map.\n"
"\n"
"Maps are key-value stores where keys are compared\n"
"using the match operator (`===`). Maps can be created with\n"
"the `%{}` special form where keys are associated via `=>`:\n"
"\n"
"    %{1 => 2}\n"
"\n"
"Maps also support the keyword notation, as other special forms,\n"
"as long as they are at the end of the argument list:\n"
"\n"
"    %{hello: :world, with: :keywords}\n"
"    %{:hello => :world, with: :keywords}\n"
"\n"
"If a map has duplicated keys, the last key will always have\n"
"higher precedence:\n"
"\n"
"    iex> %{a: :b, a: :c}\n"
"    %{a: :c}\n"
"\n"
"Conveniences for manipulating maps can be found in the\n"
"`Map` module.\n"
"\n"
"## Access syntax\n"
"\n"
"Besides the access functions available in the `Map` module,\n"
"like `Map.get/3` and `Map.fetch/2`, a map can be accessed using the\n"
"`.` operator:\n"
"\n"
"    iex> map = %{a: :b}\n"
"    iex> map.a\n"
"    :b\n"
"\n"
"Note that the `.` operator expects the field to exist in the map.\n"
"If not, an `ArgumentError` is raised.\n"
"\n"
"## Update syntax\n"
"\n"
"Maps also support an update syntax:\n"
"\n"
"    iex> map = %{:a => :b}\n"
"    iex> %{map | :a => :c}\n"
"    %{:a => :c}\n"
"\n"
"Notice the update syntax requires the given keys to exist.\n"
"Trying to update a key that does not exist will raise an `ArgumentError`.\n"
"\n"
"## AST representation\n"
"\n"
"Regardless if `=>` or the keywords syntax is used, Maps are\n"
"always represented internally as a list of two-items tuples\n"
"for simplicity:\n"
"\n"
"    iex> quote do: %{:a => :b, c: :d}\n"
"    {:%{}, [], [{:a, :b}, {:c, :d}]}\n"
"\n"
msgstr ""
#. TRANSLATORS: def File.close(io_device)
#: lib/file.ex:1110 
msgid ""
"Closes the file referenced by `io_device`. It mostly returns `:ok`, except\n"
"for some severe errors such as out of memory.\n"
"\n"
"Note that if the option `:delayed_write` was used when opening the file,\n"
"`close/1` might return an old write error and not even try to close the file.\n"
"See `open/2`.\n"
msgstr ""
#. TRANSLATORS: def IO.ANSI.conceal()
#: lib/io/ansi.ex:72 
msgid ""
"Conceal. Not widely supported"
msgstr ""
#. TRANSLATORS: def Kernel.++(left, right)
#: lib/kernel.ex:864 
msgid ""
"Concatenates two lists.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> [1] ++ [2, 3]\n"
"    [1,2,3]\n"
"\n"
"    iex> 'foo' ++ 'bar'\n"
"    'foobar'\n"
"\n"
msgstr ""
#. TRANSLATORS: def IO.ANSI.clear()
#: lib/io/ansi.ex:133 
msgid ""
"Clear screen"
msgstr ""
#. TRANSLATORS: def Inspect.Algebra.concat(x, y)
#: lib/inspect/algebra.ex:241 
msgid ""
"Concatenates two document entities.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.concat \"hello\", \"world\"\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"hello\", \"world\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.<>(left, right)
#: lib/kernel.ex:1188 
msgid ""
"Concatenates two binaries.\n"
"\n"
"## Examples\n"
"\n"
"    iex> \"foo\" <> \"bar\"\n"
"    \"foobar\"\n"
"\n"
"The `<>` operator can also be used in guard clauses as\n"
"long as the first part is a literal binary:\n"
"\n"
"    iex> \"foo\" <> x = \"foobar\"\n"
"    iex> x\n"
"    \"bar\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Module.concat(left, right)
#: lib/module.ex:438 
msgid ""
"Concatenates two aliases and returns a new alias.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Module.concat(Foo, Bar)\n"
"    Foo.Bar\n"
"\n"
"    iex> Module.concat(Foo, \"Bar\")\n"
"    Foo.Bar\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.concat(left, right)
#: lib/enum.ex:406 
msgid ""
"Concatenates the enumerable on the right with the enumerable on the left.\n"
"\n"
"This function produces the same result as the `Kernel.++/2` operator for lists.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.concat(1..3, 4..6)\n"
"    [1,2,3,4,5,6]\n"
"\n"
"    iex> Enum.concat([1, 2, 3], [4, 5, 6])\n"
"    [1,2,3,4,5,6]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Inspect.Algebra.concat(docs)
#: lib/inspect/algebra.ex:249 
msgid ""
"Concatenates a list of documents.\n"
msgstr ""
#. TRANSLATORS: def Module.concat(list)
#: lib/module.ex:421 
msgid ""
"Concatenates a list of aliases and returns a new alias.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Module.concat([Foo, Bar])\n"
"    Foo.Bar\n"
"\n"
"    iex> Module.concat([Foo, \"Bar\"])\n"
"    Foo.Bar\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.for(args)
#: lib/kernel/special_forms.ex:1195 
msgid ""
"Comprehensions allow you to quickly build a data structure from\n"
"an enumerable or a bitstring.\n"
"\n"
"Let's start with an example:\n"
"\n"
"    iex> for n <- [1, 2, 3, 4], do: n * 2\n"
"    [2, 4, 6, 8]\n"
"\n"
"A comprehension accepts many generators and filters. Enumerable\n"
"generators are defined using `<-`:\n"
"\n"
"    # A list generator:\n"
"    iex> for n <- [1, 2, 3, 4], do: n * 2\n"
"    [2, 4, 6, 8]\n"
"\n"
"    # A comprehension with two generators\n"
"    iex> for x <- [1, 2], y <- [2, 3], do: x*y\n"
"    [2, 3, 4, 6]\n"
"\n"
"Filters can also be given:\n"
"\n"
"    # A comprehension with a generator and a filter\n"
"    iex> for n <- [1, 2, 3, 4, 5, 6], rem(n, 2) == 0, do: n\n"
"    [2, 4, 6]\n"
"\n"
"Note generators can also be used to filter as it removes any value\n"
"that doesn't match the left side of `<-`:\n"
"\n"
"    iex> for {:user, name} <- [user: \"john\", admin: \"john\", user: \"meg\"] do\n"
"    ...>   String.upcase(name)\n"
"    ...> end\n"
"    [\"JOHN\", \"MEG\"]\n"
"\n"
"Bitstring generators are also supported and are very useful when you\n"
"need to organize bitstring streams:\n"
"\n"
"    iex> pixels = <<213, 45, 132, 64, 76, 32, 76, 0, 0, 234, 32, 15>>\n"
"    iex> for <<r::8, g::8, b::8 <- pixels >>, do: {r, g, b}\n"
"    [{213,45,132},{64,76,32},{76,0,0},{234,32,15}]\n"
"\n"
"Variable assignments inside the comprehension, be it in generators,\n"
"filters or inside the block, are not reflected outside of the\n"
"comprehension.\n"
"\n"
"## Into\n"
"\n"
"In the examples above, the result returned by the comprehension was\n"
"always a list. The returned result can be configured by passing an\n"
"`:into` option, that accepts any structure as long as it implements\n"
"the `Collectable` protocol.\n"
"\n"
"For example, we can use bitstring generators with the `:into` option\n"
"to easily remove all spaces in a string:\n"
"\n"
"    iex> for <<c <- \" hello world \">>, c != ?\\s, into: \"\", do: <<c>>\n"
"    \"helloworld\"\n"
"\n"
"The `IO` module provides streams, that are both `Enumerable` and\n"
"`Collectable`, here is an upcase echo server using comprehensions:\n"
"\n"
"    for line <- IO.stream(:stdio, :line), into: IO.stream(:stdio, :line) do\n"
"      String.upcase(line)\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def GenServer.multi_call(nodes \\ nodes(), name, request, timeout \\ :infinity)
#: lib/gen_server.ex:446 
msgid ""
"Calls all servers locally registered as `name` at the specified `nodes`.\n"
"\n"
"The `request` is first sent to every node and then we wait for the\n"
"replies. This function returns a tuple containing the node and its reply\n"
"as first element and all bad nodes as second element. The bad nodes is a\n"
"list of nodes that either did not exist, or where a server with the given\n"
"`name` did not exist or did not reply.\n"
"\n"
"Nodes is a list of node names to which the request is sent. The default\n"
"value is the list of all known nodes.\n"
"\n"
"To avoid that late answers (after the timeout) pollute the caller's message\n"
"queue, a middleman process is used to do the actual calls. Late answers will\n"
"then be discarded when they arrive to a terminated process.\n"
msgstr ""
#. TRANSLATORS: def Kernel.rem(left, right)
#: lib/kernel.ex:526 
msgid ""
"Calculates the remainder of an integer division.\n"
"\n"
"Raises an error if one of the arguments is not an integer.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> rem(5, 2)\n"
"    1\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.+(value)
#: lib/kernel.ex:791 
msgid ""
"Arithmetic unary plus.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> +1\n"
"    1\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.-(value)
#: lib/kernel.ex:807 
msgid ""
"Arithmetic unary minus.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> -2\n"
"    -2\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.+(left, right)
#: lib/kernel.ex:759 
msgid ""
"Arithmetic plus.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 + 2\n"
"    3\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.*(left, right)
#: lib/kernel.ex:823 
msgid ""
"Arithmetic multiplication.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 * 2\n"
"    2\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.-(left, right)
#: lib/kernel.ex:775 
msgid ""
"Arithmetic minus.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 - 2\n"
"    -1\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel./(left, right)
#: lib/kernel.ex:845 
msgid ""
"Arithmetic division.\n"
"\n"
"The result is always a float. Use `div` and `rem` if you want\n"
"a natural division or the remainder.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 / 2\n"
"    0.5\n"
"\n"
"    iex> 2 / 1\n"
"    2.0\n"
"\n"
msgstr ""
#. TRANSLATORS: def Module.safe_concat(list)
#: lib/module.ex:458 
msgid ""
"Concatenates a list of aliases and returns a new alias only\n"
"if the alias was already referenced. If the alias was not\n"
"referenced yet, fails with `ArgumentError`.\n"
"It handles char lists, binaries and atoms.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Module.safe_concat([Unknown, Module])\n"
"    ** (ArgumentError) argument error\n"
"\n"
"    iex> Module.safe_concat([List, Chars])\n"
"    List.Chars\n"
"\n"
msgstr ""
#. TRANSLATORS: def Path.absname(path, relative_to)
#: lib/path.ex:60 
msgid ""
"Builds a path from `relative_to` to `path`. If `path` is already\n"
"an absolute path, `relative_to` is ignored. See also `relative_to/2`.\n"
"\n"
"Unlike `expand/2`, no attempt is made to\n"
"resolve `..`, `.` or `~`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.absname(\"foo\", \"bar\")\n"
"    \"bar/foo\"\n"
"\n"
"    iex> Path.absname(\"../x\", \"bar\")\n"
"    \"bar/../x\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def IO.ANSI.bright()
#: lib/io/ansi.ex:48 
msgid ""
"Bright (increased intensity) or Bold"
msgstr ""
#. TRANSLATORS: defmacro Bitwise.bsr(left, right)
#: lib/bitwise.ex:118 
msgid ""
"Arithmetic bitshift right.\n"
msgstr ""
#. TRANSLATORS: defmacro Bitwise.>>>(left, right)
#: lib/bitwise.ex:125 
msgid ""
"Arithmetic bitshift right as operator.\n"
msgstr ""
#. TRANSLATORS: defmacro Bitwise.bsl(left, right)
#: lib/bitwise.ex:104 
msgid ""
"Arithmetic bitshift left.\n"
msgstr ""
#. TRANSLATORS: defmacro Bitwise.<<<(left, right)
#: lib/bitwise.ex:111 
msgid ""
"Arithmetic bitshift left as operator.\n"
msgstr ""
#. TRANSLATORS: def Regex.compile(source, options \\ "")
#: lib/regex.ex:108 
msgid ""
"Compiles the regular expression.\n"
"\n"
"The given options can either be a binary with the characters\n"
"representing the same regex options given to the `~r` sigil,\n"
"or a list of options, as expected by the [Erlang `re` docs](http://www.erlang.org/doc/man/re.html).\n"
"\n"
"It returns `{:ok, regex}` in case of success,\n"
"`{:error, reason}` otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.compile(\"foo\")\n"
"    {:ok, ~r\"foo\"}\n"
"\n"
"    iex> Regex.compile(\"*foo\")\n"
"    {:error, {'nothing to repeat', 0}}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Regex.compile!(source, options \\ "")
#: lib/regex.ex:138 
msgid ""
"Compiles the regular expression according to the given options.\n"
"Fails with `Regex.CompileError` if the regex cannot be compiled.\n"
msgstr ""
#. TRANSLATORS: def Code.compile_quoted(quoted, file \\ "nofile")
#: lib/code.ex:388 
msgid ""
"Compiles the quoted expression.\n"
"\n"
"Returns a list of tuples where the first element is the module name and\n"
"the second one is its byte code (as a binary).\n"
msgstr ""
#. TRANSLATORS: def Code.compile_string(string, file \\ "nofile")
#: lib/code.ex:378 
msgid ""
"Compiles the given string.\n"
"\n"
"Returns a list of tuples where the first element is the module name\n"
"and the second one is its byte code (as a binary).\n"
"\n"
"For compiling many files at once, check `Kernel.ParallelCompiler.files/2`.\n"
msgstr ""
#. TRANSLATORS: def File.chgrp(path, gid)
#: lib/file.ex:1173 
msgid ""
"Changes the user group given by the group id `gid`\n"
"for a given `file`. Returns `:ok` on success, or\n"
"`{:error, reason}` on failure.\n"
msgstr ""
#. TRANSLATORS: def File.chmod(path, mode)
#: lib/file.ex:1150 
msgid ""
"Changes the unix file `mode` for a given `file`.\n"
"Returns `:ok` on success, or `{:error, reason}`\n"
"on failure.\n"
msgstr ""
#. TRANSLATORS: def File.chown(path, uid)
#: lib/file.ex:1196 
msgid ""
"Changes the owner given by the user id `uid`\n"
"for a given `file`. Returns `:ok` on success,\n"
"or `{:error, reason}` on failure.\n"
msgstr ""
#. TRANSLATORS: def File.cd!(path, function)
#: lib/file.ex:1063 
msgid ""
"Changes the current directory to the given `path`,\n"
"executes the given function and then revert back\n"
"to the previous path regardless if there is an exception.\n"
"\n"
"Raises an error if retrieving or changing the current\n"
"directory fails.\n"
msgstr ""
#. TRANSLATORS: def GenServer.abcast(nodes \\ nodes(), name, request)
#: lib/gen_server.ex:413 
msgid ""
"Casts all servers locally registered as `name` at the specified nodes.\n"
"\n"
"The function returns immediately and ignores nodes that do not exist, or where the\n"
"server name does not exist.\n"
"\n"
"See `multi_call/4` for more information.\n"
msgstr ""
#. TRANSLATORS: def Kernel.ParallelCompiler.files(files, options \\ [])
#: lib/kernel/parallel_compiler.ex:33 
msgid ""
"Compiles the given files.\n"
"\n"
"Those files are compiled in parallel and can automatically\n"
"detect dependencies between them. Once a dependency is found,\n"
"the current file stops being compiled until the dependency is\n"
"resolved.\n"
"\n"
"If there is an error during compilation or if `warnings_as_errors`\n"
"is set to `true` and there is a warning, this function will fail\n"
"with an exception.\n"
"\n"
"This function accepts the following options:\n"
"\n"
"  * `:each_file` - for each file compiled, invokes the callback passing the\n"
"    file\n"
"\n"
"  * `:each_module` - for each module compiled, invokes the callback passing\n"
"    the file, module and the module bytecode\n"
"\n"
"  * `:dest` - the destination directory for the beam files. When using `files/2`,\n"
"    this information is only used to properly annotate the beam files before\n"
"    they are loaded into memory. If you want a file to actually be writen to\n"
"    `dest`, use `files_to_path/3` instead.\n"
"\n"
"Returns the modules generated by each compiled file.\n"
msgstr ""
#. TRANSLATORS: def Kernel.ParallelCompiler.files_to_path(files, path, options \\ [])
#: lib/kernel/parallel_compiler.ex:43 
msgid ""
"Compiles the given files to the given path.\n"
"Read `files/2` for more information.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.&(expr)
#: lib/kernel/special_forms.ex:1289 
msgid ""
"Captures or creates an anonymous function.\n"
"\n"
"## Capture\n"
"\n"
"The capture operator is most commonly used to capture a\n"
"function with given name and arity from a module:\n"
"\n"
"    iex> fun = &Kernel.is_atom/1\n"
"    iex> fun.(:atom)\n"
"    true\n"
"    iex> fun.(\"string\")\n"
"    false\n"
"\n"
"In the example above, we captured `Kernel.is_atom/1` as an\n"
"anonymous function and then invoked it.\n"
"\n"
"The capture operator can also be used to capture local functions,\n"
"including private ones, and imported functions by omitting the\n"
"module name:\n"
"\n"
"    &local_function/1\n"
"\n"
"## Anonymous functions\n"
"\n"
"The capture operator can also be used to partially apply\n"
"functions, where `&1`, `&2` and so on can be used as value\n"
"placeholders. For example:\n"
"\n"
"    iex> double = &(&1 * 2)\n"
"    iex> double.(2)\n"
"    4\n"
"\n"
"In other words, `&(&1 * 2)` is equivalent to `fn x -> x * 2 end`.\n"
"Another example using a local function:\n"
"\n"
"    iex> fun = &is_atom(&1)\n"
"    iex> fun.(:atom)\n"
"    true\n"
"\n"
"The `&` operator can be used with more complex expressions:\n"
"\n"
"    iex> fun = &(&1 + &2 + &3)\n"
"    iex> fun.(1, 2, 3)\n"
"    6\n"
"\n"
"As well as with lists and tuples:\n"
"\n"
"    iex> fun = &{&1, &2}\n"
"    iex> fun.(1, 2)\n"
"    {1, 2}\n"
"\n"
"    iex> fun = &[&1|&2]\n"
"    iex> fun.(1, 2)\n"
"    [1|2]\n"
"\n"
"The only restrictions when creating anonymous functions is that at\n"
"least one placeholder must be present, i.e. it must contain at least\n"
"`&1`:\n"
"\n"
"    # No placeholder fails to compile\n"
"    &var\n"
"\n"
"    # Block expressions are also not supported\n"
"    &(foo(&1, &2); &3 + &4)\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.equal?(left, right)
#: lib/keyword.ex:340 
msgid ""
"Checks if two keywords are equal. \n"
"\n"
"Two keywords are considered to be equal if they contain\n"
"the same keys and those keys contain the same values.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.equal?([a: 1, b: 2], [b: 2, a: 1])\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.or(left, right)
#: lib/kernel.ex:1118 
msgid ""
"Boolean or. Requires only the first argument to be a\n"
"boolean since it short-circuits.\n"
"\n"
"Allowed in guard tests.\n"
"\n"
"## Examples\n"
"\n"
"    iex> true or false\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.not(arg)
#: lib/kernel.ex:900 
msgid ""
"Boolean not. Argument must be a boolean.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> not false\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.and(left, right)
#: lib/kernel.ex:1134 
msgid ""
"Boolean and. Requires only the first argument to be a\n"
"boolean since it short-circuits.\n"
"\n"
"Allowed in guard tests.\n"
"\n"
"## Examples\n"
"\n"
"    iex> true and false\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def IO.ANSI.blink_off()
#: lib/io/ansi.ex:95 
msgid ""
"Blink: off"
msgstr ""
#. TRANSLATORS: def IO.ANSI.blink_slow()
#: lib/io/ansi.ex:60 
msgid ""
"Blink: Slow. Less than 150 per minute"
msgstr ""
#. TRANSLATORS: def IO.ANSI.blink_rapid()
#: lib/io/ansi.ex:63 
msgid ""
"Blink: Rapid. MS-DOS ANSI.SYS; 150 per minute or more; not widely supported"
msgstr ""
#. TRANSLATORS: defmacro Bitwise.bxor(left, right)
#: lib/bitwise.ex:90 
msgid ""
"Bitwise xor.\n"
msgstr ""
#. TRANSLATORS: defmacro Bitwise.^^^(left, right)
#: lib/bitwise.ex:97 
msgid ""
"Bitwise xor as operator.\n"
msgstr ""
#. TRANSLATORS: defmacro Bitwise.bor(left, right)
#: lib/bitwise.ex:76 
msgid ""
"Bitwise or.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.receive(args)
#: lib/kernel/special_forms.ex:1662 
msgid ""
"Checks if there is a message matching the given clauses\n"
"in the current process mailbox.\n"
"\n"
"In case there is no such message, the current process hangs\n"
"until a message arrives or waits until a given timeout value.\n"
"\n"
"## Examples\n"
"\n"
"    receive do\n"
"      {:selector, i, value} when is_integer(i) ->\n"
"        value\n"
"      value when is_atom(value) ->\n"
"        value\n"
"      _ ->\n"
"        IO.puts :stderr, \"Unexpected message received\"\n"
"    end\n"
"\n"
"An optional after clause can be given in case the message was not\n"
"received after the specified period of time:\n"
"\n"
"    receive do\n"
"      {:selector, i, value} when is_integer(i) ->\n"
"        value\n"
"      value when is_atom(value) ->\n"
"        value\n"
"      _ ->\n"
"        IO.puts :stderr, \"Unexpected message received\"\n"
"    after\n"
"      5000 ->\n"
"        IO.puts :stderr, \"No message in 5 seconds\"\n"
"    end\n"
"\n"
"The `after` clause can be specified even if there are no match clauses.\n"
"There are two special cases for the timeout value given to `after`\n"
"\n"
"  * `:infinity` - the process should wait indefinitely for a matching\n"
"    message, this is the same as not using a timeout\n"
"\n"
"  * 0 - if there is no matching message in the mailbox, the timeout\n"
"    will occur immediately\n"
"\n"
"## Variables handling\n"
"\n"
"The `receive` special form handles variables exactly as the `case`\n"
"special macro. For more information, check the docs for `case/2`.\n"
msgstr ""
#. TRANSLATORS: def Module.defines?(module, tuple)
#: lib/module.ex:613 
msgid ""
"Checks if the module defines the given function or macro.\n"
"Use `defines?/3` to assert for a specific type.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Example do\n"
"      Module.defines? __MODULE__, {:version, 0} #=> false\n"
"      def version, do: 1\n"
"      Module.defines? __MODULE__, {:version, 0} #=> true\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def Module.defines?(module, tuple, kind)
#: lib/module.ex:633 
msgid ""
"Checks if the module defines a function or macro of the\n"
"given `kind`. `kind` can be any of `:def`, `:defp`,\n"
"`:defmacro` or `:defmacrop`.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Example do\n"
"      Module.defines? __MODULE__, {:version, 0}, :defp #=> false\n"
"      def version, do: 1\n"
"      Module.defines? __MODULE__, {:version, 0}, :defp #=> false\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def Protocol.assert_protocol!(module)
#: lib/protocol.ex:61 
msgid ""
"Checks if the given module is loaded and is protocol.\n"
"\n"
"Returns `:ok` if so, otherwise raises ArgumentError.\n"
msgstr ""
#. TRANSLATORS: def Protocol.assert_impl!(protocol, base)
#: lib/protocol.ex:88 
msgid ""
"Checks if the given module is loaded and is an implementation\n"
"of the given protocol.\n"
"\n"
"Returns `:ok` if so, otherwise raises ArgumentError.\n"
msgstr ""
#. TRANSLATORS: def Stream.chunk_by(enum, fun)
#: lib/stream.ex:190 
msgid ""
"Chunks the `enum` by buffering elements for which `fun` returns\n"
"the same value and only emit them when `fun` returns a new value\n"
"or the `enum` finishes.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.chunk_by([1, 2, 2, 3, 4, 4, 6, 7, 7], &(rem(&1, 2) == 1))\n"
"    iex> Enum.to_list(stream)\n"
"    [[1], [2, 2], [3], [4, 4, 6], [7, 7]]\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.in(left, right)
#: lib/kernel.ex:2455 
msgid ""
"Checks if the element on the left side is member of the\n"
"collection on the right side.\n"
"\n"
"## Examples\n"
"\n"
"    iex> x = 1\n"
"    iex> x in [1, 2, 3]\n"
"    true\n"
"\n"
"This macro simply translates the expression above to:\n"
"\n"
"    Enum.member?([1,2,3], x)\n"
"\n"
"## Guards\n"
"\n"
"The `in` operator can be used on guard clauses as long as the\n"
"right side is a range or a list. Elixir will then expand the\n"
"operator to a valid guard expression. For example:\n"
"\n"
"    when x in [1,2,3]\n"
"\n"
"Translates to:\n"
"\n"
"    when x === 1 or x === 2 or x === 3\n"
"\n"
"When using ranges:\n"
"\n"
"    when x in 1..3\n"
"\n"
"Translates to:\n"
"\n"
"    when x >= 1 and x <= 3\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.keyword?(arg1)
#: lib/keyword.ex:40 
msgid ""
"Checks if the given argument is a keyword list or not.\n"
msgstr ""
#. TRANSLATORS: defmacro Record.is_record(data)
#: lib/record.ex:102 
msgid ""
"Checks if the given `data` is a record.\n"
"\n"
"This is implemented as a macro so it can be used in guard clauses.\n"
"\n"
"## Examples\n"
"\n"
"    iex> record = {User, \"john\", 27}\n"
"    iex> Record.is_record(record)\n"
"    true\n"
"    iex> tuple = {}\n"
"    iex> Record.is_record(tuple)\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Record.is_record(data, kind)
#: lib/record.ex:71 
msgid ""
"Checks if the given `data` is a record of `kind`.\n"
"\n"
"This is implemented as a macro so it can be used in guard clauses.\n"
"\n"
"## Examples\n"
"\n"
"    iex> record = {User, \"john\", 27}\n"
"    iex> Record.is_record(record, User)\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: def URI.char_unescaped?(c)
#: lib/uri.ex:182 
msgid ""
"Checks if the character is allowed unescaped in a URI.\n"
"\n"
"This is the default used by `URI.encode/2` where both\n"
"reserved and unreserved characters are kept unescaped.\n"
msgstr ""
#. TRANSLATORS: def URI.char_unreserved?(c)
#: lib/uri.ex:169 
msgid ""
"Checks if the character is a \"unreserved\" character in a URI.\n"
"\n"
"Unreserved characters are specified in RFC3986, section 2.3.\n"
msgstr ""
#. TRANSLATORS: def URI.char_reserved?(c)
#: lib/uri.ex:160 
msgid ""
"Checks if the character is a \"reserved\" character in a URI.\n"
"\n"
"Reserved characters are specified in RFC3986, section 2.2.\n"
msgstr ""
#. TRANSLATORS: def Version.compare(vsn1, vsn2)
#: lib/version.ex:151 
msgid ""
"Compares two versions. Returns `:gt` if first version is greater than\n"
"the second and `:lt` for vice versa. If the two versions are equal `:eq`\n"
"is returned\n"
"\n"
"Raises a `Version.InvalidVersionError` exception if `version` is not parseable.\n"
"If given an already parsed version this function won't raise.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Version.compare(\"2.0.1-alpha1\", \"2.0.0\")\n"
"    :gt\n"
"\n"
"    iex> Version.compare(\"2.0.1+build0\", \"2.0.1\")\n"
"    :eq\n"
"\n"
"    iex> Version.compare(\"invalid\", \"2.0.1\")\n"
"    ** (Version.InvalidVersionError) invalid\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enumerable.member?(collection, value)
#: lib/enum.ex:126 
msgid ""
"Checks if a value exists within the collection.\n"
"\n"
"It should return `{:ok, boolean}`.\n"
"\n"
"If `{:error, __MODULE__}` is returned a default algorithm using `reduce` and\n"
"the match (`===`) operator is used. This algorithm runs in linear time.\n"
"\n"
"Please force use of the default algorithm unless you can implement an\n"
"algorithm that is significantly faster.\n"
msgstr ""
#. TRANSLATORS: def Enum.member?(collection, value)
#: lib/enum.ex:1117 
msgid ""
"Checks if `value` exists within the `collection`.\n"
"\n"
"Membership is tested with the match (`===`) operator, although\n"
"enumerables like ranges may include floats inside the given\n"
"range.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.member?(1..10, 5)\n"
"    true\n"
"\n"
"    iex> Enum.member?([:a, :b, :c], :d)\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Set.member?(set, value)
#: lib/set.ex:220 
msgid ""
"Checks if `set` contains `value`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Set.member?(Enum.into([1, 2, 3], set_impl.new), 2)\n"
"    true\n"
"\n"
"    iex> Set.member?(Enum.into([1, 2, 3], set_impl.new), 4)\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Set.subset?(set1, set2)
#: lib/set.ex:272 
msgid ""
"Checks if `set1`'s members are all contained in `set2`.\n"
"\n"
"Notice this function is polymorphic as it checks the subset for\n"
"any type. Each set implementation also provides a `subset?` function,\n"
"but they can only work with sets of the same type.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Set.subset?(Enum.into([1, 2], set_impl.new), Enum.into([1, 2, 3], set_impl.new))\n"
"    true\n"
"\n"
"    iex> Set.subset?(Enum.into([1, 2, 3], set_impl.new), Enum.into([1, 2], set_impl.new))\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Set.disjoint?(set1, set2)
#: lib/set.ex:122 
msgid ""
"Checks if `set1` and `set2` have no members in common.\n"
"\n"
"Notice this function is polymorphic as it checks for disjoint sets of\n"
"any type. Each set implementation also provides a `disjoint?` function,\n"
"but they can only work with sets of the same type.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Set.disjoint?(Enum.into([1, 2], set_impl.new), Enum.into([3, 4], set_impl.new))\n"
"    true\n"
"\n"
"    iex> Set.disjoint?(Enum.into([1, 2], set_impl.new), Enum.into([2, 3], set_impl.new))\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def IO.ANSI.enabled?()
#: lib/io/ansi.ex:40 
msgid ""
"Checks if ANSI coloring is supported and enabled on this machine.\n"
"\n"
"This function simply reads the configuration value for\n"
"`:ansi_enabled` in the `:elixir` application. The value is by\n"
"default false unless Elixir can detect during startup that\n"
"both `stdout` and `stderr` are terminals.\n"
msgstr ""
#. TRANSLATORS: def Set.equal?(set1, set2)
#: lib/set.ex:161 
msgid ""
"Check if two sets are equal using `===`.\n"
"\n"
"Notice this function is polymorphic as it compares sets of\n"
"any type. Each set implementation also provides an `equal?`\n"
"function, but they can only work with sets of the same type.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Set.equal?(Enum.into([1, 2], set_impl.new), Enum.into([2, 1, 1], set_impl.new))\n"
"    true\n"
"\n"
"    iex> Set.equal?(Enum.into([1, 2], set_impl.new), Enum.into([3, 4], set_impl.new))\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Dict.equal?(dict1, dict2)
#: lib/dict.ex:663 
msgid ""
"Check if two dicts are equal using `===`.\n"
"\n"
"Notice this function is polymorphic as it compares dicts of any\n"
"type. Each dict implementation also provides an `equal?` function,\n"
"but they can only compare dicts of the same type.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict1 = Enum.into([a: 2, b: 3, f: 5, c: 123], dict_impl.new)\n"
"    iex> dict2 = [a: 2, b: 3, f: 5, c: 123]\n"
"    iex> Dict.equal?(dict1, dict2)\n"
"    true\n"
"\n"
"    iex> dict1 = Enum.into([a: 2, b: 3, f: 5, c: 123], dict_impl.new)\n"
"    iex> dict2 = []\n"
"    iex> Dict.equal?(dict1, dict2)\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Version.match?(vsn, req)
#: lib/version.ex:116 
msgid ""
"Check if the given version matches the specification.\n"
"\n"
"Returns `true` if `version` satisfies `requirement`, `false` otherwise.\n"
"Raises a `Version.InvalidRequirementError` exception if `requirement` is not\n"
"parseable, or `Version.InvalidVersionError` if `version` is not parseable.\n"
"If given an already parsed version and requirement this function won't\n"
"raise.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Version.match?(\"2.0.0\", \">1.0.0\")\n"
"    true\n"
"\n"
"    iex> Version.match?(\"2.0.0\", \"==1.0.0\")\n"
"    false\n"
"\n"
"    iex> Version.match?(\"foo\", \"==1.0.0\")\n"
"    ** (Version.InvalidVersionError) foo\n"
"\n"
"    iex> Version.match?(\"2.0.0\", \"== ==1.0.0\")\n"
"    ** (Version.InvalidRequirementError) == ==1.0.0\n"
"\n"
msgstr ""
#. TRANSLATORS: def Module.open?(module)
#: lib/module.ex:314 
msgid ""
"Check if a module is open, i.e. it is currently being defined\n"
"and its attributes and functions can be modified.\n"
msgstr ""
#. TRANSLATORS: def String.valid_character?(codepoint)
#: lib/string.ex:827 
msgid ""
"Checks whether `str` is a valid character.\n"
"\n"
"All characters are codepoints, but some codepoints\n"
"are not valid characters. They may be reserved, private,\n"
"or other.\n"
"\n"
"More info at: http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Noncharacters\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.valid_character?(\"a\")\n"
"    true\n"
"\n"
"    iex> String.valid_character?(\"Ã¸\")\n"
"    true\n"
"\n"
"    iex> String.valid_character?(\"\\x{ffff}\")\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def String.valid?(arg1)
#: lib/string.ex:797 
msgid ""
"Checks whether `str` contains only valid characters.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.valid?(\"a\")\n"
"    true\n"
"\n"
"    iex> String.valid?(\"Ã¸\")\n"
"    true\n"
"\n"
"    iex> String.valid?(<<0xffff :: 16>>)\n"
"    false\n"
"\n"
"    iex> String.valid?(\"asd\" <> <<0xffff :: 16>>)\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def String.printable?(b)
#: lib/string.ex:190 
msgid ""
"Checks if a string is printable considering it is encoded\n"
"as UTF-8. Returns `true` if so, `false` otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.printable?(\"abc\")\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: def String.match?(string, regex)
#: lib/string.ex:1279 
msgid ""
"Check if `string` matches the given regular expression.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.match?(\"foo\", ~r/foo/)\n"
"    true\n"
"\n"
"    iex> String.match?(\"bar\", ~r/foo/)\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def String.contains?(string, contents)
#: lib/string.ex:1302 
msgid ""
"Check if `string` contains any of the given `contents`.\n"
"\n"
"`matches` can be either a single string or a list of strings.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.contains? \"elixir of life\", \"of\"\n"
"    true\n"
"\n"
"    iex> String.contains? \"elixir of life\", [\"life\", \"death\"]\n"
"    true\n"
"\n"
"    iex> String.contains? \"elixir of life\", [\"death\", \"mercury\"]\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.super(args)
#: lib/kernel/special_forms.ex:1325 
msgid ""
"Calls the overriden function when overriding it with `defoverridable`.\n"
"See `Kernel.defoverridable` for more information and documentation.\n"
msgstr ""
#. TRANSLATORS: def Macro.unpipe(expr)
#: lib/macro.ex:60 
msgid ""
"Breaks a pipeline expression into a list.\n"
"\n"
"Raises if the pipeline is ill-formed.\n"
msgstr ""
#. TRANSLATORS: defmacro Bitwise.|||(left, right)
#: lib/bitwise.ex:83 
msgid ""
"Bitwise or as operator.\n"
msgstr ""
#. TRANSLATORS: defmacro Bitwise.bnot(expr)
#: lib/bitwise.ex:48 
msgid ""
"Bitwise not.\n"
msgstr ""
#. TRANSLATORS: defmacro Bitwise.~~~(expr)
#: lib/bitwise.ex:55 
msgid ""
"Bitwise not as operator.\n"
msgstr ""
#. TRANSLATORS: defmacro Bitwise.band(left, right)
#: lib/bitwise.ex:62 
msgid ""
"Bitwise and.\n"
msgstr ""
#. TRANSLATORS: defmacro Bitwise.&&&(left, right)
#: lib/bitwise.ex:69 
msgid ""
"Bitwise and as operator.\n"
msgstr ""
#. TRANSLATORS: def Kernel.===(left, right)
#: lib/kernel.ex:1045 
msgid ""
"Returns `true` if the two items are match.\n"
"\n"
"This operator gives the same semantics as the one existing in\n"
"pattern matching, i.e., `1` and `1.0` are equal, but they do\n"
"not match.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 === 2\n"
"    false\n"
"\n"
"    iex> 1 === 1.0\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.==(left, right)
#: lib/kernel.ex:996 
msgid ""
"Returns `true` if the two items are equal.\n"
"\n"
"This operator considers 1 and 1.0 to be equal. For match\n"
"semantics, use `===` instead.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 == 2\n"
"    false\n"
"\n"
"    iex> 1 == 1.0\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.has_key?(keywords, key)
#: lib/keyword.ex:400 
msgid ""
"Returns whether a given `key` exists in the given `keywords`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.has_key?([a: 1], :a)\n"
"    true\n"
"\n"
"    iex> Keyword.has_key?([a: 1], :b)\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Macro.Env.in_match?(arg1)
#: lib/macro/env.ex:116 
msgid ""
"Returns whether the compilation environment is currently\n"
"inside a match clause.\n"
msgstr ""
#. TRANSLATORS: def Macro.Env.in_guard?(arg1)
#: lib/macro/env.ex:110 
msgid ""
"Returns whether the compilation environment is currently\n"
"inside a guard.\n"
msgstr ""
#. TRANSLATORS: def Process.alive?(pid)
#: lib/process.ex:24 
msgid ""
"Returns true if the process exists and is alive, that is,\n"
"is not exiting and has not exited. Otherwise, returns false.\n"
"\n"
"`pid` must refer to a process at the local node.\n"
msgstr ""
#. TRANSLATORS: def File.regular?(path)
#: lib/file.ex:94 
msgid ""
"Returns `true` if the path is a regular file.\n"
"\n"
"## Examples\n"
"\n"
"    File.regular? __ENV__.file #=> true\n"
"\n"
msgstr ""
#. TRANSLATORS: def File.dir?(path)
#: lib/file.ex:102 
msgid ""
"Returns `true` if the path is a directory.\n"
msgstr ""
#. TRANSLATORS: def Node.alive?()
#: lib/node.ex:54 
msgid ""
"Returns `true` if the local node is alive.\n"
"\n"
"That is, if the node can be part of a distributed system.\n"
msgstr ""
#. TRANSLATORS: def Protocol.consolidated?(protocol)
#: lib/protocol.ex:232 
msgid ""
"Returns true if the protocol was consolidated.\n"
msgstr ""
#. TRANSLATORS: def File.exists?(path)
#: lib/file.ex:124 
msgid ""
"Returns `true` if the given path exists.\n"
"It can be regular file, directory, socket,\n"
"symbolic link, named pipe or device file.\n"
"\n"
"## Examples\n"
"\n"
"    File.exists?(\"test/\")\n"
"    #=> true\n"
"\n"
"    File.exists?(\"missing.txt\")\n"
"    #=> false\n"
"\n"
"    File.exists?(\"/dev/null\")\n"
"    #=> true\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.Typespec.defines_type?(module, name, arity)
#: lib/kernel/typespec.ex:304 
msgid ""
"Returns `true` if the current module defines a given type\n"
"(private, opaque or not). This function is only available\n"
"for modules being compiled.\n"
msgstr ""
#. TRANSLATORS: def Kernel.Typespec.defines_spec?(module, name, arity)
#: lib/kernel/typespec.ex:317 
msgid ""
"Returns `true` if the current module defines a given spec.\n"
"This function is only available for modules being compiled.\n"
msgstr ""
#. TRANSLATORS: def Kernel.Typespec.defines_callback?(module, name, arity)
#: lib/kernel/typespec.ex:328 
msgid ""
"Returns `true` if the current module defines a callback.\n"
"This function is only available for modules being compiled.\n"
msgstr ""
#. TRANSLATORS: defmacro Record.defrecordp(name, tag \\ nil, kv)
#: lib/record.ex:178 
msgid ""
"Same as `defrecord/3` but generates private macros.\n"
msgstr ""
#. TRANSLATORS: def Enum.empty?(collection)
#: lib/enum.ex:562 
msgid ""
"Returns `true` if the collection is empty, otherwise `false`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.empty?([])\n"
"    true\n"
"\n"
"    iex> Enum.empty?([1, 2, 3])\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Exception.exception?(arg1)
#: lib/exception.ex:37 
msgid ""
"Returns true if the given argument is an exception.\n"
msgstr ""
#. TRANSLATORS: def GenEvent.which_handlers(manager)
#: lib/gen_event.ex:499 
msgid ""
"Returns a list of all event handlers installed in the `manager`.\n"
msgstr ""
#. TRANSLATORS: def Kernel.>(left, right)
#: lib/kernel.ex:936 
msgid ""
"Returns `true` if left is more than right.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 > 2\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.>=(left, right)
#: lib/kernel.ex:972 
msgid ""
"Returns `true` if left is more than or equal to right.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 >= 2\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.<(left, right)
#: lib/kernel.ex:918 
msgid ""
"Returns `true` if left is less than right.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 < 2\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.<=(left, right)
#: lib/kernel.ex:954 
msgid ""
"Returns `true` if left is less than or equal to right.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 <= 2\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Bitwise.__using__(options)
#: lib/bitwise.ex:31 
msgid ""
"Allow a developer to use this module in their programs with\n"
"the following options:\n"
"\n"
"  * `:only_operators` - include only operators\n"
"  * `:skip_operators` - skip operators\n"
"\n"
msgstr ""
#. TRANSLATORS: def File.copy(source, destination, bytes_count \\ :infinity)
#: lib/file.ex:383 
msgid ""
"Copies the contents of `source` to `destination`.\n"
"\n"
"Both parameters can be a filename or an io device opened\n"
"with `open/2`. `bytes_count` specifies the number of\n"
"bytes to copy, the default being `:infinity`.\n"
"\n"
"If file `destination` already exists, it is overwritten\n"
"by the contents in `source`.\n"
"\n"
"Returns `{:ok, bytes_copied}` if successful,\n"
"`{:error, reason}` otherwise.\n"
"\n"
"Compared to the `cp/3`, this function is more low-level,\n"
"allowing a copy from device to device limited by a number of\n"
"bytes. On the other hand, `cp/3` performs more extensive\n"
"checks on both source and destination and it also preserves\n"
"the file mode after copy.\n"
"\n"
"Typical error reasons are the same as in `open/2`,\n"
"`read/1` and `write/3`.\n"
msgstr ""
#. TRANSLATORS: def Process.link(pid)
#: lib/process.ex:249 
msgid ""
"Creates a link between the calling process and another process\n"
"(or port) `pid`, if there is not such a link already.\n"
"\n"
"See http://www.erlang.org/doc/man/erlang.html#link-1 for more info.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Keyword.new(pairs)
#: lib/keyword.ex:69 
msgid ""
"Creates a keyword from an enumerable.\n"
"\n"
"Duplicated entries are removed, the latest one prevails.\n"
"Unlike `Enum.into(enumerable, [])`,\n"
"`Keyword.new(enumerable)` guarantees the keys are unique.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.new([{:b, 1}, {:a, 2}])\n"
"    [a: 2, b: 1]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Keyword.new(pairs, transform)
#: lib/keyword.ex:89 
msgid ""
"Creates a keyword from an enumerable via the transformation function.\n"
"\n"
"Duplicated entries are removed, the latest one prevails.\n"
"Unlike `Enum.into(enumerable, [], fun)`,\n"
"`Keyword.new(enumerable, fun)` guarantees the keys are unique.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.new([:a, :b], fn (x) -> {x, x} end) |> Enum.sort\n"
"    [a: :a, b: :b]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Range.Iterator.count(first, range)
#: lib/range.ex:60 
msgid ""
"Count how many items are in the range.\n"
msgstr ""
#. TRANSLATORS: def File.cp_r(source, destination, callback \\ fn _, _ -> true end)
#: lib/file.ex:494 
msgid ""
"Copies the contents in source to destination.\n"
"\n"
"If the source is a file, it copies `source` to\n"
"`destination`. If the source is a directory, it copies\n"
"the contents inside source into the destination.\n"
"\n"
"If a file already exists in the destination,\n"
"it invokes a callback which should return\n"
"`true` if the existing file should be overwritten,\n"
"`false` otherwise. It defaults to return `true`.\n"
"\n"
"If a directory already exists in the destination\n"
"where a file is meant to be (or otherwise), this\n"
"function will fail.\n"
"\n"
"This function may fail while copying files,\n"
"in such cases, it will leave the destination\n"
"directory in a dirty state, where already\n"
"copied files won't be removed.\n"
"\n"
"It returns `{:ok, files_and_directories}` in case of\n"
"success with all files and directories copied in no\n"
"specific order, `{:error, reason, file}` otherwise.\n"
"\n"
"Note: The command `cp` in Unix systems behaves differently\n"
"depending if `destination` is an existing directory or not.\n"
"We have chosen to explicitly disallow this behaviour.\n"
"\n"
"## Examples\n"
"\n"
"    # Copies \"a.txt\" to \"tmp\"\n"
"    File.cp_r \"a.txt\", \"tmp.txt\"\n"
"\n"
"    # Copies all files in \"samples\" to \"tmp\"\n"
"    File.cp_r \"samples\", \"tmp\"\n"
"\n"
"    # Same as before, but asks the user how to proceed in case of conflicts\n"
"    File.cp_r \"samples\", \"tmp\", fn(source, destination) ->\n"
"      IO.gets(\"Overwriting #{destination} by #{source}. Type y to confirm.\") == \"y\"\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def File.cp(source, destination, callback \\ fn _, _ -> true end)
#: lib/file.ex:423 
msgid ""
"Copies the contents in `source` to `destination` preserving its mode.\n"
"\n"
"If a file already exists in the destination, it invokes a\n"
"callback which should return `true` if the existing file\n"
"should be overwritten, `false` otherwise. It defaults to return `true`.\n"
"\n"
"It returns `:ok` in case of success, returns\n"
"`{:error, reason}` otherwise.\n"
"\n"
"If you want to copy contents from an io device to another device\n"
"or do a straight copy from a source to a destination without\n"
"preserving modes, check `copy/3` instead.\n"
"\n"
"Note: The command `cp` in Unix systems behaves differently depending\n"
"if `destination` is an existing directory or not. We have chosen to\n"
"explicitly disallow this behaviour. If destination is a directory, an\n"
"error will be returned.\n"
msgstr ""
#. TRANSLATORS: def Path.expand(path)
#: lib/path.ex:138 
msgid ""
"Converts the path to an absolute one and expands\n"
"any `.` and `..` characters and a leading `~`.\n"
"\n"
"## Examples\n"
"\n"
"    Path.expand(\"/foo/bar/../bar\")\n"
"    \"/foo/bar\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def IO.stream(device, line_or_codepoints)
#: lib/io.ex:287 
msgid ""
"Converts the io device into a `IO.Stream`.\n"
"\n"
"An `IO.Stream` implements both `Enumerable` and\n"
"`Collectable`, allowing it to be used for both read\n"
"and write.\n"
"\n"
"The device is iterated line by line if `:line` is given or\n"
"by a given number of codepoints.\n"
"\n"
"This reads the IO as utf-8. Check out\n"
"`IO.binstream/2` to handle the IO as a raw binary.\n"
"\n"
"Note that an IO stream has side effects and every time\n"
"you go over the stream you may get different results.\n"
"\n"
"## Examples\n"
"\n"
"Here is an example on how we mimic an echo server\n"
"from the command line:\n"
"\n"
"    Enum.each IO.stream(:stdio, :line), &IO.write(&1)\n"
"\n"
msgstr ""
#. TRANSLATORS: def Path.absname(path)
#: lib/path.ex:39 
msgid ""
"Converts the given path to an absolute one. Unlike\n"
"`expand/1`, no attempt is made to resolve `..`, `.` or `~`.\n"
"\n"
"## Unix examples\n"
"\n"
"    Path.absname(\"foo\")\n"
"    #=> \"/usr/local/foo\"\n"
"\n"
"    Path.absname(\"../x\")\n"
"    #=> \"/usr/local/../x\"\n"
"\n"
"## Windows\n"
"\n"
"    Path.absname(\"foo\").\n"
"    \"D:/usr/local/foo\"\n"
"    Path.absname(\"../x\").\n"
"    \"D:/usr/local/../x\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Macro.to_string(tree, fun \\ fn _ast, string -> string end)
#: lib/macro.ex:453 
msgid ""
"Converts the given expression to a binary.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Macro.to_string(quote do: foo.bar(1, 2, 3))\n"
"    \"foo.bar(1, 2, 3)\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def String.capitalize(string)
#: lib/string.ex:443 
msgid ""
"Converts the first character in the given string to\n"
"uppercase and the remaining to lowercase.\n"
"\n"
"This relies on the titlecase information provided\n"
"by the Unicode Standard. Note this function makes\n"
"no attempt to capitalize all words in the string\n"
"(usually known as titlecase).\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.capitalize(\"abcd\")\n"
"    \"Abcd\"\n"
"\n"
"    iex> String.capitalize(\"ï¬n\")\n"
"    \"Fin\"\n"
"\n"
"    iex> String.capitalize(\"olÃ¡\")\n"
"    \"OlÃ¡\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Integer.parse(bin)
#: lib/integer.ex:49 
msgid ""
"Converts a binary to an integer.\n"
"\n"
"If successful, returns a tuple of the form `{integer, remainder_of_binary}`.\n"
"Otherwise `:error`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Integer.parse(\"34\")\n"
"    {34,\"\"}\n"
"\n"
"    iex> Integer.parse(\"34.5\")\n"
"    {34,\".5\"}\n"
"\n"
"    iex> Integer.parse(\"three\")\n"
"    :error\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.Typespec.spec_to_ast(name, arg2)
#: lib/kernel/typespec.ex:338 
msgid ""
"Converts a spec clause back to Elixir AST.\n"
msgstr ""
#. TRANSLATORS: def Code.string_to_quoted(string, opts \\ [])
#: lib/code.ex:235 
msgid ""
"Convert the given string to its quoted form.\n"
"\n"
"Returns `{:ok, quoted_form}`\n"
"if it succeeds, `{:error, {line, error, token}}` otherwise.\n"
"\n"
"## Options\n"
"\n"
"  * `:file` - the filename to be used in stacktraces\n"
"    and the file reported in the `__ENV__` variable\n"
"\n"
"  * `:line` - the line reported in the `__ENV__` variable\n"
"\n"
"  * `:existing_atoms_only` - when `true`, raises an error\n"
"    when non-existing atoms are found by the tokenizer\n"
"\n"
"## Macro.to_string/2\n"
"\n"
"The opposite of converting a string to its quoted form is\n"
"`Macro.to_string/2`, which converts a quoted form to a string/binary\n"
"representation.\n"
msgstr ""
#. TRANSLATORS: def Code.string_to_quoted!(string, opts \\ [])
#: lib/code.ex:251 
msgid ""
"Convert the given string to its quoted form.\n"
"\n"
"It returns the ast if it succeeds,\n"
"raises an exception otherwise. The exception is a `TokenMissingError`\n"
"in case a token is missing (usually because the expression is incomplete),\n"
"`SyntaxError` otherwise.\n"
"\n"
"Check `string_to_quoted/2` for options information.\n"
msgstr ""
#. TRANSLATORS: def Module.add_doc(module, line, kind, tuple, signature \\ [], doc)
#: lib/module.ex:498 
msgid ""
"Attaches documentation to a given function or type. It expects\n"
"the module the function/type belongs to, the line (a non negative\n"
"integer), the kind (`def` or `defmacro`), a tuple representing\n"
"the function and its arity, the function signature (the signature\n"
"should be omitted for types) and the documentation, which should\n"
"be either a binary or a boolean.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule MyModule do\n"
"      Module.add_doc(__MODULE__, __ENV__.line + 1, :def, {:version, 0}, [], \"Manually added docs\")\n"
"      def version, do: 1\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def Code.append_path(path)
#: lib/code.ex:32 
msgid ""
"Append a path to the Erlang VM code path.\n"
"\n"
"The path is expanded with `Path.expand/1` before being appended.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.to_char_list(arg)
#: lib/kernel.ex:1876 
msgid ""
"Convert the argument to a list according to the List.Chars protocol.\n"
"\n"
"## Examples\n"
"\n"
"    iex> to_char_list(:foo)\n"
"    'foo'\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.to_tuple(list)
#: lib/list.ex:532 
msgid ""
"Converts a list to a tuple.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.to_tuple([:share, [:elixir, 163]])\n"
"    {:share, [:elixir, 163]}\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.to_string(list)
#: lib/list.ex:554 
msgid ""
"Converts a list of integers representing codepoints, lists or\n"
"strings into a string.\n"
"\n"
"Notice that this function expects a list of integers representing\n"
"UTF-8 codepoints. If you have a list of bytes, you must instead use\n"
"[the `:binary` module](http://erlang.org/doc/man/binary.html).\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.to_string([0x00E6, 0x00DF])\n"
"    \"Ã¦ÃŸ\"\n"
"\n"
"    iex> List.to_string([0x0061, \"bc\"])\n"
"    \"abc\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.to_existing_atom(char_list)
#: lib/list.ex:468 
msgid ""
"Converts a char list to an existing atom.\n"
"\n"
"Currently Elixir does not support conversions from char lists\n"
"which contains Unicode codepoints greater than 0xFF.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def List.to_atom(char_list)
#: lib/list.ex:455 
msgid ""
"Converts a char list to an atom.\n"
"\n"
"Currently Elixir does not support conversions from char lists\n"
"which contains Unicode codepoints greater than 0xFF.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.to_atom('elixir')\n"
"    :elixir\n"
"\n"
msgstr ""
#. TRANSLATORS: def File.Stat.to_record(stat)
#: lib/file/stat.ex:65 
msgid ""
"Converts a `File.Stat` struct to a `:file_info` record.\n"
msgstr ""
#. TRANSLATORS: def File.Stat.from_record(arg1)
#: lib/file/stat.ex:72 
msgid ""
"Converts a `:file_info` record into a `File.Stat`.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.destructure(left, right)
#: lib/kernel.ex:2217 
msgid ""
"Allows you to destructure two lists, assigning each term in the right to the\n"
"matching term in the left. Unlike pattern matching via `=`, if the sizes of\n"
"the left and right lists don't match, destructuring simply stops instead of\n"
"raising an error.\n"
"\n"
"## Examples\n"
"\n"
"    iex> destructure([x, y, z], [1, 2, 3, 4, 5])\n"
"    iex> {x, y, z}\n"
"    {1, 2, 3}\n"
"\n"
"Notice in the example above, even though the right\n"
"size has more entries than the left, destructuring works\n"
"fine. If the right size is smaller, the remaining items\n"
"are simply assigned to nil:\n"
"\n"
"    iex> destructure([x, y, z], [1])\n"
"    iex> {x, y, z}\n"
"    {1, nil, nil}\n"
"\n"
"The left side supports any expression you would use\n"
"on the left side of a match:\n"
"\n"
"    x = 1\n"
"    destructure([^x, y, z], [1, 2, 3])\n"
"\n"
"The example above will only work if x matches\n"
"the first value from the right side. Otherwise,\n"
"it will raise a CaseClauseError.\n"
msgstr ""
#. TRANSLATORS: Elixir.Agent Summary
#: lib/agent.ex:1 
msgid ""
"Agents are a simple abstraction around state.\n"
"\n"
"Often in Elixir there is a need to share or store state that\n"
"must be accessed from different processes or by the same process\n"
"at different points in time.\n"
"\n"
"The Agent module provides a basic server implementation that\n"
"allows state to be retrieved and updated via a simple API.\n"
"\n"
"## Examples\n"
"\n"
"For example, in the Mix tool that ships with Elixir, we need\n"
"to keep a set of all tasks executed by a given project. Since\n"
"this set is shared, we can implement it with an Agent:\n"
"\n"
"    defmodule Mix.TasksServer do\n"
"      def start_link do\n"
"        Agent.start_link(fn -> HashSet.new end, name: __MODULE__)\n"
"      end\n"
"\n"
"      @doc \"Checks if the task has already executed\"\n"
"      def executed?(task, project) do\n"
"        item = {task, project}\n"
"        Agent.get(__MODULE__, fn set ->\n"
"          item in set\n"
"        end)\n"
"      end\n"
"\n"
"      @doc \"Marks a task as executed\"\n"
"      def put_task(task, project) do\n"
"        item = {task, project}\n"
"        Agent.update(__MODULE__, &Set.put(&1, item))\n"
"      end\n"
"    end\n"
"\n"
"Note that agents still provide a segregation between the\n"
"client and server APIs, as seen in GenServers. In particular,\n"
"all code inside the function passed to the agent is executed\n"
"by the agent. This distinction is important because you may\n"
"want to avoid expensive operations inside the agent, as it will\n"
"effectively block the agent until the request is fulfilled.\n"
"\n"
"Consider these two examples:\n"
"\n"
"    # Compute in the agent/server\n"
"    def get_something(agent) do\n"
"      Agent.get(agent, fn state -> do_something_expensive(state) end)\n"
"    end\n"
"\n"
"    # Compute in the agent/client\n"
"    def get_something(agent) do\n"
"      Agent.get(agent, &(&1)) |> do_something_expensive()\n"
"    end\n"
"\n"
"The first one blocks the agent while the second one copies\n"
"all the state to the client and executes the operation in the client.\n"
"The trade-off here is exactly if the data is small enough to be\n"
"sent to the client cheaply or large enough to require processing on\n"
"the server (or at least some initial processing).\n"
"\n"
"## Name Registration\n"
"\n"
"An Agent is bound to the same name registration rules as GenServers.\n"
"Read more about it in the `GenServer` docs.\n"
"\n"
"## A word on distributed agents\n"
"\n"
"It is important to consider the limitations of distributed agents. Agents\n"
"provides two APIs, one that works with anonymous functions and another\n"
"that expects explicit module, function and arguments.\n"
"\n"
"In a distributed setup with multiple nodes, the API that accepts anonymous\n"
"functions only works if the caller (client) and the agent have the same\n"
"version of the caller module.\n"
"\n"
"Keep in mind this issue also shows up when performing \"rolling upgrades\"\n"
"with agents. By rolling upgrades we mean the following situation: you wish\n"
"to deploy a new version of your software by *shutting down* some of your\n"
"nodes and replacing them with nodes running a new version of the software.\n"
"In this setup, part of your environment will have one version of a given\n"
"module and the other part another version (the newer one) of the same module.\n"
"\n"
"The best solution is to simply use the explicit module, function and arguments\n"
"APIs when working with distributed agents.\n"
"\n"
"## Hot code swapping\n"
"\n"
"An agent can have its code hot swapped live by simply passing a module,\n"
"function and args tuple to the update instruction. For example, imagine\n"
"you have an agent named `:sample` and you want to convert its inner state\n"
"from some dict structure to a map. It can be done with the following\n"
"instruction:\n"
"\n"
"    {:update, :sample, {:advanced, {Enum, :into, [%{}]}}}\n"
"\n"
"The agent's state will be added to the given list as the first argument.\n"
msgstr ""
#. TRANSLATORS: def GenEvent.add_handler(manager, handler, args)
#: lib/gen_event.ex:316 
msgid ""
"Adds a new event handler to the event `manager`.\n"
"\n"
"The event manager will call the `init/1` callback with `args` to\n"
"initiate the event handler and its internal state.\n"
"\n"
"If `init/1` returns a correct value indicating successful completion,\n"
"the event manager adds the event handler and this function returns\n"
"`:ok`. If the callback fails with `reason` or returns `{:error, reason}`,\n"
"the event handler is ignored and this function returns `{:error, reason}`.\n"
"\n"
"If the given handler was previously installed at the manager, this\n"
"function returns `{:error, :already_present}`.\n"
msgstr ""
#. TRANSLATORS: def GenEvent.add_mon_handler(manager, handler, args)
#: lib/gen_event.ex:361 
msgid ""
"Adds a monitored event handler to the event `manager`.\n"
"\n"
"Expects the same input and returns the same values as `add_handler/3`.\n"
"\n"
"## Monitored handlers\n"
"\n"
"A monitored handler implies the calling process will now be monitored\n"
"by the GenEvent manager.\n"
"\n"
"If the calling process later terminates with `reason`, the event manager\n"
"will delete the event handler by calling the `terminate/2` callback with\n"
"`{:stop, reason}` as argument. If the event handler later is deleted,\n"
"the event manager sends a message `{:gen_event_EXIT, handler, reason}`\n"
"to the calling process. Reason is one of the following:\n"
"\n"
"  * `:normal` - if the event handler has been removed due to a call to\n"
"    `remove_handler/3`, or `:remove_handler` has been returned by a callback\n"
"    function\n"
"\n"
"  * `:shutdown` - if the event handler has been removed because the event\n"
"    manager is terminating\n"
"\n"
"  * `{:swapped, new_handler, pid}` - if the process pid has replaced the\n"
"    event handler by another\n"
"\n"
"  * a term - if the event handler is removed due to an error. Which term\n"
"    depends on the error\n"
"\n"
"Keep in mind that the `{:gen_event_EXIT, handler, reason}` message is not\n"
"guaranteed to be delivered in case the manager crashes. If you want to\n"
"guarantee the message is delivered, you have two options:\n"
"\n"
"  * monitor the event manager\n"
"  * link to the event manager and then set `Process.flag(:trap_exit, true)`\n"
"    in your handler callback\n"
"\n"
"Finally, this functionality only works with GenEvent started via this\n"
"module (it is not backwards compatible with Erlang's `:gen_event`).\n"
msgstr ""
#. TRANSLATORS: def Module.overridable?(module, tuple)
#: lib/module.ex:713 
msgid ""
"Returns `true` if `tuple` in `module` is marked as overridable.\n"
msgstr ""
#. TRANSLATORS: def Supervisor.restart_child(supervisor, child_id)
#: lib/supervisor.ex:344 
msgid ""
"Restarts a child process identified by `child_id`.\n"
"\n"
"The child specification must exist and the corresponding child process must not\n"
"be running.\n"
"\n"
"Note that for temporary children, the child specification is automatically deleted\n"
"when the child terminates, and thus it is not possible to restart such children.\n"
"\n"
"If the child process start function returns `{:ok, child}` or\n"
"`{:ok, child, info}`, the pid is added to the supervisor and the function returns\n"
"the same value.\n"
"\n"
"If the child process start function returns `:ignore`, the pid remains set to\n"
"`:undefined` and the function returns `{:ok, :undefined}`.\n"
"\n"
"This function may error with an appropriate error tuple if the `child_id` is not\n"
"found, or if the current process is running or being restarted.\n"
"\n"
"If the child process start function returns an error tuple or an erroneous value,\n"
"or if it fails, the function returns `{:error, error}`.\n"
"\n"
"This operation is not supported by `simple_one_for_one` supervisors.\n"
msgstr ""
#. TRANSLATORS: def String.starts_with?(string, prefixes)
#: lib/string.ex:1213 
msgid ""
"Returns `true` if `string` starts with any of the prefixes given, otherwise\n"
"`false`. `prefixes` can be either a single prefix or a list of prefixes.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.starts_with? \"elixir\", \"eli\"\n"
"    true\n"
"\n"
"    iex> String.starts_with? \"elixir\", [\"erlang\", \"elixir\"]\n"
"    true\n"
"\n"
"    iex> String.starts_with? \"elixir\", [\"erlang\", \"ruby\"]\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def String.ends_with?(string, suffixes)
#: lib/string.ex:1247 
msgid ""
"Returns `true` if `string` ends with any of the suffixes given, otherwise\n"
"`false`. `suffixes` can be either a single suffix or a list of suffixes.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.ends_with? \"language\", \"age\"\n"
"    true\n"
"\n"
"    iex> String.ends_with? \"language\", [\"youth\", \"age\"]\n"
"    true\n"
"\n"
"    iex> String.ends_with? \"language\", [\"youth\", \"elixir\"]\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.min(first, second)
#: lib/kernel.ex:485 
msgid ""
"Return the smallest of the two given terms according to\n"
"Erlang's term ordering. If the terms compare equal, the\n"
"first one is returned.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> min(1, 2)\n"
"    1\n"
"\n"
msgstr ""
#. TRANSLATORS: def Kernel.max(first, second)
#: lib/kernel.ex:467 
msgid ""
"Return the biggest of the two given terms according to\n"
"Erlang's term ordering. If the terms compare equal, the\n"
"first one is returned.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> max(1, 2)\n"
"    2\n"
"\n"
msgstr ""
#. TRANSLATORS: def Module.definitions_in(module)
#: lib/module.ex:653 
msgid ""
"Return all functions defined in `module`.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Example do\n"
"      def version, do: 1\n"
"      Module.definitions_in __MODULE__ #=> [{:version,0}]\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def IO.ANSI.reset()
#: lib/io/ansi.ex:45 
msgid ""
"Resets all attributes"
msgstr ""
#. TRANSLATORS: def Kernel.ParallelRequire.files(files, callback \\ fn x -> x end)
#: lib/kernel/parallel_require.ex:16 
msgid ""
"Requires the given files.\n"
"\n"
"A callback that is invoked every time a file is required\n"
"can be optionally given as argument.\n"
"\n"
"Returns the modules generated by each required file.\n"
msgstr ""
#. TRANSLATORS: def Set.to_list(set)
#: lib/set.ex:293 
msgid ""
"Converts `set` to a list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> set_impl.to_list(Enum.into([1, 2, 3], set_impl.new)) |> Enum.sort\n"
"    [1,2,3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def String.upcase(binary)
#: lib/string.ex:401 
msgid ""
"Convert all characters on the given string to uppercase.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.upcase(\"abcd\")\n"
"    \"ABCD\"\n"
"\n"
"    iex> String.upcase(\"ab 123 xpto\")\n"
"    \"AB 123 XPTO\"\n"
"\n"
"    iex> String.upcase(\"olÃ¡\")\n"
"    \"OLÃ\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def String.downcase(binary)
#: lib/string.ex:419 
msgid ""
"Convert all characters on the given string to lowercase.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.downcase(\"ABCD\")\n"
"    \"abcd\"\n"
"\n"
"    iex> String.downcase(\"AB 123 XPTO\")\n"
"    \"ab 123 xpto\"\n"
"\n"
"    iex> String.downcase(\"OLÃ\")\n"
"    \"olÃ¡\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Node.monitor(node, flag, options)
#: lib/node.ex:103 
msgid ""
"Behaves as `monitor/2` except that it allows an extra\n"
"option to be given, namely `:allow_passive_connect`.\n"
"\n"
"See http://www.erlang.org/doc/man/erlang.html#monitor_node-3 for more info.\n"
msgstr ""
#. TRANSLATORS: def Task.await(task, timeout \\ 5000)
#: lib/task.ex:194 
msgid ""
"Awaits a task reply.\n"
"\n"
"A timeout, in milliseconds, can be given with default value\n"
"of `5000`. In case the task process dies, this function will\n"
"exit with the same reason as the task.\n"
msgstr ""
#. TRANSLATORS: def container[key]
#: lib/access.ex:33 
msgid ""
"Accesses the given key in the container.\n"
msgstr ""
#. TRANSLATORS: def Macro.Env.location(arg1)
#: lib/macro/env.ex:102 
msgid ""
"Returns a keyword list containing the file and line\n"
"information as keys.\n"
msgstr ""
#. TRANSLATORS: def Range.range?(range)
#: lib/range.ex:43 
msgid ""
"Returns true if the given argument is a range.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Range.range?(1..3)\n"
"    true\n"
"\n"
"    iex> Range.range?(0)\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Regex.scan(regex, string, options \\ [])
#: lib/regex.ex:316 
msgid ""
"Same as `run/3`, but scans the target several times collecting all\n"
"matches of the regular expression. A list of lists is returned,\n"
"where each entry in the primary list represents a match and each\n"
"entry in the secondary list represents the captured contents.\n"
"\n"
"## Options\n"
"\n"
"  * `:return`  - set to `:index` to return indexes. Defaults to `:binary`.\n"
"  * `:capture` - what to capture in the result. Check the moduledoc for `Regex`\n"
"                 to see the possible capture values.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.scan(~r/c(d|e)/, \"abcd abce\")\n"
"    [[\"cd\", \"d\"], [\"ce\", \"e\"]]\n"
"\n"
"    iex> Regex.scan(~r/c(?:d|e)/, \"abcd abce\")\n"
"    [[\"cd\"], [\"ce\"]]\n"
"\n"
"    iex> Regex.scan(~r/e/, \"abcd\")\n"
"    []\n"
"\n"
msgstr ""
#. TRANSLATORS: def Regex.regex?(regex)
#: lib/regex.ex:176 
msgid ""
"Returns true if the given argument is a regex.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.regex?(~r/foo/)\n"
"    true\n"
"\n"
"    iex> Regex.regex?(0)\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Code.require_file(file, relative_to \\ nil)
#: lib/code.ex:307 
msgid ""
"Requires the given `file`.\n"
"\n"
"Accepts `relative_to` as an argument to tell where the file is located.\n"
"The return value is the same as that of `load_file/2`. If the file was already\n"
"required/loaded, doesn't do anything and returns `nil`.\n"
"\n"
"Notice that if `require_file` is invoked by different processes concurrently,\n"
"the first process to invoke `require_file` acquires a lock and the remaining\n"
"ones will block until the file is available. I.e. if `require_file` is called\n"
"N times with a given file, it will be loaded only once. The first process to\n"
"call `require_file` will get the list of loaded modules, others will get `nil`.\n"
"\n"
"Check `load_file/2` if you want a file to be loaded multiple times.\n"
msgstr ""
#. TRANSLATORS: def GenServer.reply(client, reply)
#: lib/gen_server.ex:464 
msgid ""
"Replies to a client.\n"
"\n"
"This function can be used by a server to explicitly send a reply to a\n"
"client that called `call/3` or `multi_call/4`. When the reply cannot be\n"
"defined in the return value of `handle_call/3`.\n"
"\n"
"The `client` must be the `from` argument (the second argument) received\n"
"in `handle_call/3` callbacks. Reply is an arbitrary term which will be\n"
"given back to the client as the return value of the call.\n"
"\n"
"This function always returns `:ok`.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.require(module, opts)
#: lib/kernel/special_forms.ex:479 
msgid ""
"Requires a given module to be compiled and loaded.\n"
"\n"
"## Examples\n"
"\n"
"Notice that usually modules should not be required before usage,\n"
"the only exception is if you want to use the macros from a module.\n"
"In such cases, you need to explicitly require them.\n"
"\n"
"Let's suppose you created your own `if` implementation in the module\n"
"`MyMacros`. If you want to invoke it, you need to first explicitly\n"
"require the `MyMacros`:\n"
"\n"
"    defmodule Math do\n"
"      require MyMacros\n"
"      MyMacros.if do_something, it_works\n"
"    end\n"
"\n"
"An attempt to call a macro that was not loaded will raise an error.\n"
"\n"
"## Alias shortcut\n"
"\n"
"`require` also accepts `as:` as an option so it automatically sets\n"
"up an alias. Please check `alias` for more information.\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.to_list(collection)
#: lib/enum.ex:1796 
msgid ""
"Convert `collection` to a list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.to_list(1 .. 3)\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Process.register(pid, name)
#: lib/process.ex:277 
msgid ""
"Associates the name with a pid or a port identifier. `name`, which must\n"
"be an atom, can be used instead of the pid / port identifier with the\n"
"`Kernel.send/2` function.\n"
"\n"
"`Process.register/2` will fail with `ArgumentError` if the pid supplied\n"
"is no longer alive, (check with `alive?/1`) or if the name is\n"
"already registered (check with `whereis/1`).\n"
msgstr ""
#. TRANSLATORS: def Enum.scan(enum, acc, fun)
#: lib/enum.ex:1393 
msgid ""
"Applies the given function to each element in the collection,\n"
"storing the result in a list and passing it as the accumulator\n"
"for the next computation. Uses the given `acc` as the starting value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.scan(1..5, 0, &(&1 + &2))\n"
"    [1,3,6,10,15]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.scan(enum, fun)
#: lib/enum.ex:1375 
msgid ""
"Applies the given function to each element in the collection,\n"
"storing the result in a list and passing it as the accumulator\n"
"for the next computation.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.scan(1..5, &(&1 + &2))\n"
"    [1,3,6,10,15]\n"
"\n"
msgstr ""
#. TRANSLATORS: def GenEvent.swap_handler(manager, handler1, args1, handler2, args2)
#: lib/gen_event.ex:481 
msgid ""
"Replaces an old event handler with a new one in the event `manager`.\n"
"\n"
"First, the old event handler is deleted by calling `terminate/2` with\n"
"the given `args1` and collects the return value. Then the new event handler\n"
"is added and initiated by calling `init({args2, state}), where term is the\n"
"return value of calling `terminate/2` in the old handler. This makes it\n"
"possible to transfer information from one handler to another.\n"
"\n"
"The new handler will be added even if the specified old event handler\n"
"is not installed or if the handler fails to terminate with a given reason\n"
"in which case `state = {:error, term}`.\n"
"\n"
"If `init/1` in the second handler returns a correct value, this\n"
"function returns `:ok`.\n"
msgstr ""
#. TRANSLATORS: def GenEvent.swap_mon_handler(manager, handler1, args1, handler2, args2)
#: lib/gen_event.ex:491 
msgid ""
"Replaces an old event handler with a new monitored one in the event `manager`.\n"
"\n"
"Read the docs for `add_mon_handler/3` and `swap_handler/5` for more information.\n"
msgstr ""
#. TRANSLATORS: def Kernel.tl(list)
#: lib/kernel.ex:715 
msgid ""
"Returns the tail of a list. Raises `ArgumentError` if the list is empty.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.to_string(arg)
#: lib/kernel.ex:1861 
msgid ""
"Converts the argument to a string according to the\n"
"`String.Chars` protocol.\n"
"\n"
"This is the function invoked when there is string interpolation.\n"
"\n"
"## Examples\n"
"\n"
"    iex> to_string(:foo)\n"
"    \"foo\"\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.SpecialForms.^(var)
#: lib/kernel/special_forms.ex:633 
msgid ""
"Accesses an already bound variable in match clauses.\n"
"\n"
"## Examples\n"
"\n"
"Elixir allows variables to be rebound via static single assignment:\n"
"\n"
"    iex> x = 1\n"
"    iex> x = 2\n"
"    iex> x\n"
"    2\n"
"\n"
"However, in some situations, it is useful to match against an existing\n"
"value, instead of rebinding. This can be done with the `^` special form:\n"
"\n"
"    iex> x = 1\n"
"    iex> ^x = List.first([1])\n"
"    iex> ^x = List.first([2])\n"
"    ** (MatchError) no match of right hand side value: 2\n"
"\n"
"Note that `^` always refers to the value of x prior to the match. The\n"
"following example will match:\n"
"\n"
"    iex> x = 0\n"
"    iex> {x, ^x} = {1, 0}\n"
"    iex> x\n"
"    1\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.Task.Supervisor Summary
#: lib/task/supervisor.ex:1 
msgid ""
"A tasks supervisor.\n"
"\n"
"This module defines a supervisor which can be used to dynamically\n"
"supervise tasks. Behind the scenes, this module is implemented as a\n"
"`:simple_one_for_one` supervisor where the workers are temporary\n"
"(i.e. they are not restarted after they die).\n"
"\n"
"The functions in this module allow tasks to be spawned and awaited\n"
"from a supervisor, similar to the functions defined in the `Task` module.\n"
"\n"
"## Name Registration\n"
"\n"
"A `Task.Supervisor` is bound to the same name registration rules as a\n"
"`GenServer`. Read more about it in the `GenServer` docs.\n"
msgstr ""
#. TRANSLATORS: Elixir.Macro.Env Summary
#: lib/macro/env.ex:1 
msgid ""
"A struct that holds compile time environment information.\n"
"\n"
"The current environment can be accessed at any time as\n"
"`__ENV__`. Inside macros, the caller environment can be\n"
"accessed as `__CALLER__`.\n"
"\n"
"An instance of `Macro.Env` must not be modified by hand. If you need to\n"
"create a custom environment to pass to `Code.eval_quoted/3`, use the\n"
"following trick:\n"
"\n"
"    def make_custom_env do\n"
"      import SomeModule, only: [some_function: 2]\n"
"      alias A.B.C\n"
"      __ENV__\n"
"    end\n"
"\n"
"You may then call `make_custom_env()` to get a struct with the desired\n"
"imports and aliases included.\n"
"\n"
"It contains the following fields:\n"
"\n"
"  * `module` - the current module name\n"
"  * `file` - the current file name as a binary\n"
"  * `line` - the current line as an integer\n"
"  * `function` - a tuple as `{atom, integer`}, where the first\n"
"    element is the function name and the seconds its arity; returns\n"
"    `nil` if not inside a function\n"
"  * `context` - the context of the environment; it can be `nil`\n"
"    (default context), inside a guard or inside an assign\n"
"  * `aliases` -  a list of two item tuples, where the first\n"
"    item is the aliased name and the second the actual name\n"
"  * `requires` - the list of required modules\n"
"  * `functions` - a list of functions imported from each module\n"
"  * `macros` - a list of macros imported from each module\n"
"  * `macro_aliases` - a list of aliases defined inside the current macro\n"
"  * `context_modules` - a list of modules defined in the current context\n"
"  * `vars` - a list keeping all defined variables as `{var, context}`\n"
"  * `export_vars` - a list keeping all variables to be exported in a\n"
"    construct (may be `nil`)\n"
"  * `lexical_tracker` - PID of the lexical tracker which is responsible to\n"
"    keep user info\n"
"  * `local` - the module to expand local functions to\n"
msgstr ""
#. TRANSLATORS: Elixir.File.Stat Summary
#: lib/file/stat.ex:3 
msgid ""
"A struct responsible to hold file information.\n"
"\n"
"In Erlang, this struct is represented by a `:file_info` record.\n"
"Therefore this module also provides functions for converting\n"
"in between the Erlang record and the Elixir struct.\n"
"\n"
"Its fields are:\n"
"\n"
"  * `size` - size of file in bytes.\n"
"\n"
"  * `type` - `:device | :directory | :regular | :other`; the type of the\n"
"    file.\n"
"\n"
"  * `access` - `:read | :write | :read_write | :none`; the current system\n"
"    access to the file.\n"
"\n"
"  * `atime` - the last time the file was read.\n"
"\n"
"  * `mtime` - the last time the file was written.\n"
"\n"
"  * `ctime` - the interpretation of this time field depends on the operating\n"
"    system. On Unix, it is the last time the file or the inode was changed.\n"
"    In Windows, it is the time of creation.\n"
"\n"
"  * `mode` - the file permissions.\n"
"\n"
"  * `links` - the number of links to this file. This is always 1 for file\n"
"    systems which have no concept of links.\n"
"\n"
"  * `major_device` - identifies the file system where the file is located.\n"
"    In windows, the number indicates a drive as follows: 0 means A:, 1 means\n"
"    B:, and so on.\n"
"\n"
"  * `minor_device` - only valid for character devices on Unix. In all other\n"
"    cases, this field is zero.\n"
"\n"
"  * `inode` - gives the inode number. On non-Unix file systems, this field\n"
"    will be zero.\n"
"\n"
"  * `uid` - indicates the owner of the file.\n"
"\n"
"  * `gid` - gives the group that the owner of the file belongs to. Will be\n"
"    zero for non-Unix file systems.\n"
"\n"
"The time type returned in `atime`, `mtime`, and `ctime` is dependent on the\n"
"time type set in options. `{:time, type}` where type can be `:local`,\n"
"`:universal`, or `:posix`. Default is `:local`.\n"
msgstr ""
#. TRANSLATORS: Elixir.HashSet Summary
#: lib/hash_set.ex:1 
msgid ""
"A set store.\n"
"\n"
"The `HashSet` is represented internally as a struct, therefore\n"
"`%HashSet{}` can be used whenever there is a need to match\n"
"on any `HashSet`. Note though the struct fields are private and\n"
"must not be accessed directly. Instead, use the functions on this\n"
"or in the `Set` module.\n"
"\n"
"The `HashSet` is implemented using tries, which grows in\n"
"space as the number of keys grows, working well with both\n"
"small and large set of keys. For more information about the\n"
"functions and their APIs, please consult the `Set` module.\n"
msgstr ""
#. TRANSLATORS: Elixir.Inspect.Algebra Summary
#: lib/inspect/algebra.ex:58 
msgid ""
"A set of functions for creating and manipulating algebra\n"
"documents, as described in [\"Strictly Pretty\" (2000) by Christian Lindig][0].\n"
"\n"
"An algebra document is represented by an `Inspect.Algebra` node\n"
"or a regular string.\n"
"\n"
"    iex> Inspect.Algebra.empty\n"
"    :doc_nil\n"
"\n"
"    iex> \"foo\"\n"
"    \"foo\"\n"
"\n"
"With the functions in this module, we can concatenate different\n"
"elements together and render them:\n"
"\n"
"    iex> doc = Inspect.Algebra.concat(Inspect.Algebra.empty, \"foo\")\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"foo\"]\n"
"\n"
"The functions `nest/2`, `space/2` and `line/2` help you put the\n"
"document together into a rigid structure. However, the document\n"
"algebra gets interesting when using functions like `break/2`, which\n"
"converts the given string into a line break depending on how much space\n"
"there is to print. Let's glue two docs together with a break and then\n"
"render it:\n"
"\n"
"    iex> doc = Inspect.Algebra.glue(\"a\", \" \", \"b\")\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"a\", \" \", \"b\"]\n"
"\n"
"Notice the break was represented as is, because we haven't reached\n"
"a line limit. Once we do, it is replaced by a newline:\n"
"\n"
"    iex> doc = Inspect.Algebra.glue(String.duplicate(\"a\", 20), \" \", \"b\")\n"
"    iex> Inspect.Algebra.format(doc, 10)\n"
"    [\"aaaaaaaaaaaaaaaaaaaa\", \"\\n\", \"b\"]\n"
"\n"
"Finally, this module also contains Elixir related functions, a bit\n"
"tied to Elixir formatting, namely `surround/3` and `surround_many/5`.\n"
"\n"
"## Implementation details\n"
"\n"
"The original Haskell implementation of the algorithm by [Wadler][1]\n"
"relies on lazy evaluation to unfold document groups on two alternatives:\n"
"`:flat` (breaks as spaces) and `:break` (breaks as newlines).\n"
"Implementing the same logic in a strict language such as Elixir leads\n"
"to an exponential growth of possible documents, unless document groups\n"
"are encoded explictly as `:flat` or `:break`. Those groups are then reduced\n"
"to a simple document, where the layout is already decided, per [Lindig][0].\n"
"\n"
"This implementation slightly changes the semantic of Lindig's algorithm\n"
"to allow elements that belong to the same group to be printed together\n"
"in the same line, even if they do not fit the line fully. This was achieved\n"
"by changing `:break` to mean a possible break and `:flat` to force a flat\n"
"structure. Then deciding if a break works as a newline is just a matter\n"
"of checking if we have enough space until the next break that is not\n"
"inside a group (which is still flat).\n"
"\n"
"Custom pretty printers can be implemented using the documents returned\n"
"by this module and by providing their own rendering functions.\n"
"\n"
"  [0]: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.2200\n"
"  [1]: http://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.Range.Iterator Summary
#: lib/range.ex:47 
msgid ""
"A protocol used for iterating range elements.\n"
msgstr ""
#. TRANSLATORS: Elixir.Collectable Summary
#: lib/collectable.ex:1 
msgid ""
"A protocol to traverse data structures.\n"
"\n"
"The `Enum.into/2` function uses this protocol to insert an\n"
"enumerable into a collection:\n"
"\n"
"    iex> Enum.into([a: 1, b: 2], %{})\n"
"    %{a: 1, b: 2}\n"
"\n"
"## Why Collectable?\n"
"\n"
"The `Enumerable` protocol is useful to take values out of a collection.\n"
"In order to support a wide range of values, the functions provided by\n"
"the `Enumerable` protocol do not keep shape. For example, passing a\n"
"dictionary to `Enum.map/2` always returns a list.\n"
"\n"
"This design is intentional. `Enumerable` was designed to support infinite\n"
"collections, resources and other structures with fixed shape. For example,\n"
"it doesn't make sense to insert values into a range, as it has a fixed\n"
"shape where just the range limits are stored.\n"
"\n"
"The `Collectable` module was designed to fill the gap left by the\n"
"`Enumerable` protocol. `into/1` can be seen as the opposite of\n"
"`Enumerable.reduce/3`. If `Enumerable` is about taking values out,\n"
"`Collectable.into/1` is about collecting those values into a structure.\n"
msgstr ""
#. TRANSLATORS: def Kernel.throw(term)
#: lib/kernel.ex:705 
msgid ""
"A non-local return from a function. Check `Kernel.SpecialForms.try/1` for more information.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: Elixir.Kernel.ParallelRequire Summary
#: lib/kernel/parallel_require.ex:1 
msgid ""
"A module responsible for requiring files in parallel.\n"
msgstr ""
#. TRANSLATORS: Elixir.Kernel.ParallelCompiler Summary
#: lib/kernel/parallel_compiler.ex:1 
msgid ""
"A module responsible for compiling files in parallel.\n"
msgstr ""
#. TRANSLATORS: Elixir.Application Summary
#: lib/application.ex:1 
msgid ""
"A module for working with applications and defining application callbacks.\n"
"\n"
"In Elixir (actually, in Erlang/OTP), an application is a component\n"
"implementing some specific functionality, that can be started and stopped\n"
"as a unit, and which can be re-used in other systems as well.\n"
"\n"
"Applications are defined with an application file named `APP.app` where\n"
"`APP` is the APP name, usually in `underscore_case` convention. The\n"
"application file must reside in the same `ebin` directory as the\n"
"application's modules bytecode.\n"
"\n"
"In Elixir, Mix is responsible for compiling your source code and\n"
"generating your application `.app` file. Furthermore, Mix is also\n"
"responsible for configuring, starting and stopping your application\n"
"and its dependencies. For this reason, this documentation will focus\n"
"on the remaining aspects of your application: the application environment,\n"
"and the application callback module.\n"
"\n"
"You can learn more about Mix compilation of `.app` files by typing\n"
"`mix help compile.app`.\n"
"\n"
"## Application environment\n"
"\n"
"Once an application is started, OTP provides an application environment\n"
"that can be used to configure applications.\n"
"\n"
"Assuming you are inside a Mix project, you can edit your application\n"
"function in the `mix.exs` file to the following:\n"
"\n"
"    def application do\n"
"      [env: [hello: :world]]\n"
"    end\n"
"\n"
"In the application function, we can define the default environment values\n"
"for our application. By starting your application with `iex -S mix`, you\n"
"can access the default value:\n"
"\n"
"    Application.get_env(:APP_NAME, :hello)\n"
"    #=> :world\n"
"\n"
"It is also possible to put and delete values from the application value,\n"
"including new values that are not defined in the environment file (although\n"
"those should be avoided).\n"
"\n"
"In the future, we plan to support configuration files which allows\n"
"developers to configure the environment of their dependencies.\n"
"\n"
"Keep in mind that each application is responsible for its environment.\n"
"Do not use the functions in this module for directly access or modify\n"
"the environment of other application (as it may lead to inconsistent\n"
"data in the application environment).\n"
"\n"
"## Application module callback\n"
"\n"
"Often times, an application defines a supervision tree that must be started\n"
"and stopped when the application starts and stops. For such, we need to\n"
"define an application module callback. The first step is to define the\n"
"module callback in the application definition in the `mix.exs` file:\n"
"\n"
"    def application do\n"
"      [mod: {MyApp, []}]\n"
"    end\n"
"\n"
"Our application now requires the `MyApp` module to provide an application\n"
"callback. This can be done by invoking `use Application` in that module\n"
"and defining a `start/2` callback, for example:\n"
"\n"
"    defmodule MyApp do\n"
"      use Application\n"
"\n"
"      def start(_type, _args) do\n"
"        MyApp.Supervisor.start_link()\n"
"      end\n"
"    end\n"
"\n"
"`start/2` most commonly returns `{:ok, pid}` or `{:ok, pid, state}` where\n"
"`pid` identifies the supervision tree and the state is the application state.\n"
"`args` is second element of the tuple given to the `:mod` option.\n"
"\n"
"The `type` passed into `start/2` is usually `:normal` unless in a distributed\n"
"setup where applications takeovers and failovers are configured. This particular\n"
"aspect of applications can be read with more detail in the OTP documentation:\n"
"\n"
"  * http://www.erlang.org/doc/man/application.html\n"
"  * http://www.erlang.org/doc/design_principles/applications.html\n"
"\n"
"A developer may also implement the `stop/1` callback (automatically defined\n"
"by `use Application`) which does any application cleanup. It receives the\n"
"application state and can return any value. Notice that shutting down the\n"
"supervisor is automatically handled by the VM.\n"
msgstr ""
#. TRANSLATORS: Elixir.Keyword Summary
#: lib/keyword.ex:1 
msgid ""
"A keyword is a list of tuples where the first element\n"
"of the tuple is an atom and the second element can be\n"
"any value.\n"
"\n"
"A keyword may have duplicated keys so it is not strictly\n"
"a dictionary. However most of the functions in this module\n"
"behave exactly as a dictionary and mimic the API defined\n"
"by the `Dict` behaviour.\n"
"\n"
"For example, `Keyword.get/3` will get the first entry matching\n"
"the given key, regardless if duplicated entries exist.\n"
"Similarly, `Keyword.put/3` and `Keyword.delete/3` ensure all\n"
"duplicated entries for a given key are removed when invoked.\n"
"\n"
"A handful of functions exist to handle duplicated keys, in\n"
"particular, `Enum.into/2` allows creating new keywords without\n"
"removing duplicated keys, `get_values/2` returns all values for\n"
"a given key and `delete_first/2` deletes just one of the existing\n"
"entries.\n"
"\n"
"Since a keyword list is simply a list, all the operations defined\n"
"in `Enum` and `List` can be applied.\n"
msgstr ""
#. TRANSLATORS: Elixir.HashDict Summary
#: lib/hash_dict.ex:1 
msgid ""
"A key-value store.\n"
"\n"
"The `HashDict` is represented internally as a struct, therefore\n"
"`%HashDict{}` can be used whenever there is a need to match\n"
"on any `HashDict`. Note though the struct fields are private and\n"
"must not be accessed directly. Instead, use the functions on this\n"
"or in the `Dict` module.\n"
"\n"
"Implementation-wise, `HashDict` is implemented using tries, which\n"
"grows in space as the number of keys grows, working well with both\n"
"small and large set of keys. For more information about the\n"
"functions and their APIs, please consult the `Dict` module.\n"
msgstr ""
#. TRANSLATORS: defmacro Kernel.match?(pattern, expr)
#: lib/kernel.ex:1933 
msgid ""
"A convenience macro that checks if the right side (an expression)\n"
"matches the left side (a pattern).\n"
"\n"
"## Examples\n"
"\n"
"    iex> match?(1, 1)\n"
"    true\n"
"\n"
"    iex> match?(1, 2)\n"
"    false\n"
"\n"
"    iex> match?({1, _}, {1, 2})\n"
"    true\n"
"\n"
"Match can also be used to filter or find a value in an enumerable:\n"
"\n"
"    list = [{:a, 1}, {:b, 2}, {:a, 3}]\n"
"    Enum.filter list, &match?({:a, _}, &1)\n"
"\n"
"Guard clauses can also be given to the match:\n"
"\n"
"    list = [{:a, 1}, {:b, 2}, {:a, 3}]\n"
"    Enum.filter list, &match?({:a, x} when x < 2, &1)\n"
"\n"
"However, variables assigned in the match will not be available\n"
"outside of the function call:\n"
"\n"
"    iex> match?(x, 1)\n"
"    true\n"
"\n"
"    iex> binding([:x]) == []\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.Task Summary
#: lib/task.ex:1 
msgid ""
"Conveniences for spawning and awaiting for tasks.\n"
"\n"
"Tasks are processes meant to execute one particular\n"
"action throughout their life-cycle, often with little or no\n"
"communication with other processes. The most common use case\n"
"for tasks is to compute a value asynchronously:\n"
"\n"
"    task = Task.async(fn -> do_some_work() end)\n"
"    res  = do_some_other_work()\n"
"    res + Task.await(task)\n"
"\n"
"Tasks spawned with `async` can be awaited on by its caller\n"
"process (and only its caller) as shown in the example above.\n"
"They are implemented by spawning a process that sends a message\n"
"to the caller once the given computation is performed.\n"
"\n"
"Besides `async/1` and `await/2`, tasks can also be\n"
"started as part of supervision trees and dynamically spawned\n"
"in remote nodes. We will explore all three scenarios next.\n"
"\n"
"## async and await\n"
"\n"
"The most common way to spawn a task is with `Task.async/1`. A new\n"
"process will be created, linked and monitored by the caller. Once\n"
"the task action finishes, a message will be sent to the caller\n"
"with the result.\n"
"\n"
"`Task.await/2` is used to read the message sent by the task. On\n"
"`await`, Elixir will also setup a monitor to verify if the process\n"
"exited for any abnormal reason (or in case exits are being\n"
"trapped by the caller).\n"
"\n"
"## Supervised tasks\n"
"\n"
"It is also possible to spawn a task inside a supervision tree\n"
"with `start_link/1` and `start_link/3`:\n"
"\n"
"    Task.start_link(fn -> IO.puts \"ok\" end)\n"
"\n"
"Such tasks can be mounted in your supervision tree as:\n"
"\n"
"    import Supervisor.Spec\n"
"\n"
"    children = [\n"
"      worker(Task, [fn -> IO.puts \"ok\" end])\n"
"    ]\n"
"\n"
"Since these tasks are supervised and not directly linked to\n"
"the caller, they cannot be awaited on. Note `start_link/1`,\n"
"unlike `async/1`, returns `{:ok, pid}` (which is\n"
"the result expected by supervision trees).\n"
"\n"
"## Supervision trees\n"
"\n"
"The `Task.Supervisor` module allows developers to start supervisors\n"
"that dynamically supervise tasks:\n"
"\n"
"    {:ok, pid} = Task.Supervisor.start_link()\n"
"    Task.Supervisor.async(pid, MyMod, :my_fun, [arg1, arg2, arg3])\n"
"\n"
"`Task.Supervisor` also makes it possible to spawn tasks in remote nodes as\n"
"long as the supervisor is registered locally or globally:\n"
"\n"
"    # In the remote node\n"
"    Task.Supervisor.start_link(name: :tasks_sup)\n"
"\n"
"    # In the client\n"
"    Task.Supervisor.async({:tasks_sup, :remote@local}, MyMod, :my_fun, [arg1, arg2, arg3])\n"
"\n"
"`Task.Supervisor` is more often started in your supervision tree as:\n"
"\n"
"    import Supervisor.Spec\n"
"\n"
"    children = [\n"
"      supervisor(Task.Supervisor, [[name: :tasks_sup]])\n"
"    ]\n"
"\n"
"Note that, when working with distributed tasks, one should use the `async/3` API,\n"
"that expects explicit module, function and arguments, instead of `async/1` that\n"
"works with anonymous functions. That's because the anonymous function API expects\n"
"the same module version to exist on all involved nodes. Check the `Agent` module\n"
"documentation for more information on distributed processes, as the limitations\n"
"described in the agents documentation apply to the whole ecosystem.\n"
"\n"
"Finally, check `Task.Supervisor` for other operations supported by the Task\n"
"supervisor.\n"
msgstr ""
#. TRANSLATORS: Elixir.Process Summary
#: lib/process.ex:1 
msgid ""
"Conveniences for working with processes and the process dictionary.\n"
"\n"
"Besides the functions available in this module, the `Kernel` module\n"
"exposes and auto-imports some basic functionality related to processes\n"
"available through the functions:\n"
"\n"
"  * `Kernel.spawn/1` and `Kernel.spawn/3`\n"
"  * `Kernel.spawn_link/1` and `Kernel.spawn_link/3`\n"
"  * `Kernel.spawn_monitor/1` and `Kernel.spawn_monitor/3`\n"
"  * `Kernel.self/0`\n"
"  * `Kernel.send/2`\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.Macro Summary
#: lib/macro.ex:3 
msgid ""
"Conveniences for working with macros.\n"
msgstr ""
#. TRANSLATORS: def Path.relative_to_cwd(path)
#: lib/path.ex:311 
msgid ""
"Convenience to get the path relative to the current working\n"
"directory. If, for some reason, the current working directory\n"
"cannot be retrieved, returns the full path.\n"
msgstr ""
#. TRANSLATORS: def Module.safe_concat(left, right)
#: lib/module.ex:478 
msgid ""
"Concatenates two aliases and returns a new alias only\n"
"if the alias was already referenced. If the alias was not\n"
"referenced yet, fails with `ArgumentError`.\n"
"It handles char lists, binaries and atoms.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Module.safe_concat(Unknown, Module)\n"
"    ** (ArgumentError) argument error\n"
"\n"
"    iex> Module.safe_concat(List, Chars)\n"
"    List.Chars\n"
"\n"
msgstr ""
#. TRANSLATORS: def String.to_integer(string)
#: lib/string.ex:1398 
msgid ""
"Returns a integer whose text representation is `string`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.to_integer(\"123\")\n"
"    123\n"
"\n"
msgstr ""
#. TRANSLATORS: def String.to_float(string)
#: lib/string.ex:1438 
msgid ""
"Returns a float whose text representation is `string`.\n"
"\n"
"`string` must be the string representation of a float.\n"
"If a string representation of an integer wants to be used,\n"
"then `Float.parse/1` should be used instead,\n"
"otherwise an argument error will be raised.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.to_float(\"2.2017764e+0\")\n"
"    2.2017764\n"
"\n"
"    iex> String.to_float(\"3.0\")\n"
"    3.0\n"
"\n"
msgstr ""
#. TRANSLATORS: def Process.unregister(name)
#: lib/process.ex:287 
msgid ""
"Removes the registered name, associated with a pid or a port identifier.\n"
"\n"
"See http://www.erlang.org/doc/man/erlang.html#unregister-1 for more info.\n"
msgstr ""
#. TRANSLATORS: def Process.unlink(pid)
#: lib/process.ex:263 
msgid ""
"Removes the link, if there is one, between the calling process and\n"
"the process or port referred to by `pid`. Returns `true` and does not\n"
"fail, even if there is no link or `id` does not exist\n"
"\n"
"See http://www.erlang.org/doc/man/erlang.html#unlink-1 for more info.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def String.to_existing_atom(string)
#: lib/string.ex:1382 
msgid ""
"Converts a string to an existing atom.\n"
"\n"
"Currently Elixir does not support conversions from strings\n"
"which contains Unicode codepoints greater than 0xFF.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> :my_atom\n"
"    iex> String.to_existing_atom(\"my_atom\")\n"
"    :my_atom\n"
"\n"
"    iex> String.to_existing_atom(\"this_atom_will_never_exist\")\n"
"    ** (ArgumentError) argument error\n"
"\n"
msgstr ""
#. TRANSLATORS: def String.to_atom(string)
#: lib/string.ex:1359 
msgid ""
"Converts a string to an atom.\n"
"\n"
"Currently Elixir does not support conversions from strings\n"
"which contains Unicode codepoints greater than 0xFF.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.to_atom(\"my_atom\")\n"
"    :my_atom\n"
"\n"
msgstr ""
#. TRANSLATORS: def String.to_char_list(string)
#: lib/string.ex:1331 
msgid ""
"Converts a string into a char list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.to_char_list(\"Ã¦ÃŸ\")\n"
"    'Ã¦ÃŸ'\n"
"\n"
"Notice that this function expects a list of integers representing\n"
"UTF-8 codepoints. If you have a raw binary, you must instead use\n"
"[the `:binary` module](http://erlang.org/doc/man/binary.html).\n"
msgstr ""
#. TRANSLATORS: def Tuple.to_list(tuple)
#: lib/tuple.ex:73 
msgid ""
"Converts a tuple to a list.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
#. TRANSLATORS: def Macro.update_meta(quoted, fun)
#: lib/macro.ex:115 
msgid ""
"Applies the given function to the node metadata if it contains one.\n"
"\n"
"This is often useful when used with `Macro.prewalk/1` to remove\n"
"information like lines and hygienic counters from the expression\n"
"for either storage or comparison.\n"
"\n"
"## Examples\n"
"\n"
"    iex> quoted = quote line: 10, do: sample()\n"
"    {:sample, [line: 10], []}\n"
"    iex> Macro.update_meta(quoted, &Keyword.delete(&1, :line))\n"
"    {:sample, [], []}\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.Supervisor.Spec Summary
#: lib/supervisor/spec.ex:1 
msgid ""
"Convenience functions for defining a supervision specification.\n"
"\n"
"## Example\n"
"\n"
"By using the functions in this module one can define a supervisor\n"
"and start it with `Supervisor.start_link/2`:\n"
"\n"
"    import Supervisor.Spec\n"
"\n"
"    children = [\n"
"      worker(MyWorker, [arg1, arg2, arg3]),\n"
"      supervisor(MySupervisor, [arg1])\n"
"    ]\n"
"\n"
"    Supervisor.start_link(children, strategy: :one_for_one)\n"
"\n"
"In many situations, it may be handy to define supervisors backed\n"
"by a module:\n"
"\n"
"    defmodule MySupervisor do\n"
"      use Supervisor\n"
"\n"
"      def start_link(arg) do\n"
"        Supervisor.start_link(__MODULE__, arg)\n"
"      end\n"
"\n"
"      def init(arg) do\n"
"        children = [\n"
"          worker(MyWorker, [arg], restart: :temporary)\n"
"        ]\n"
"\n"
"        supervise(children, strategy: :simple_one_for_one)\n"
"      end\n"
"    end\n"
"\n"
"Notice in this case we don't have to explicitly import\n"
"`Supervisor.Spec` as `use Supervisor` automatically does so.\n"
"\n"
"Explicit supervisors as above are required when there is a need to:\n"
"\n"
"  1. Partially change the supervision tree during hot-code swaps.\n"
"\n"
"  2. Define supervisors inside other supervisors.\n"
"\n"
"  3. Perform actions inside the supervision `init/1` callback.\n"
"\n"
"     For example, you may want to start an ETS table that is linked to\n"
"     the supervisor (i.e. if the supervision tree needs to be restarted,\n"
"     the ETS table must be restarted too).\n"
"\n"
"## Supervisor and worker options\n"
"\n"
"In the example above, we have defined workers and supervisors\n"
"and each accepts the following options:\n"
"\n"
"  * `:id` - a name used to identify the child specification\n"
"    internally by the supervisor; defaults to the given module\n"
"    name\n"
"\n"
"  * `:function` - the function to invoke on the child to start it\n"
"\n"
"  * `:restart` - defines when the child process should restart\n"
"\n"
"  * `:shutdown` - defines how a child process should be terminated\n"
"\n"
"  * `:modules` - it should be a list with one element `[module]`,\n"
"    where module is the name of the callback module only if the\n"
"    child process is a `Supervisor` or `GenServer`; if the child\n"
"    process is a `GenEvent`, modules should be `:dynamic`\n"
"\n"
"### Restart values (:restart)\n"
"\n"
"The following restart values are supported:\n"
"\n"
"  * `:permanent` - the child process is always restarted\n"
"\n"
"  * `:temporary` - the child process is never restarted (not even\n"
"    when the supervisor's strategy is `:rest_for_one` or `:one_for_all`)\n"
"\n"
"  * `:transient` - the child process is restarted only if it\n"
"    terminates abnormally, i.e. with another exit reason than\n"
"    `:normal`, `:shutdown` or `{:shutdown, term}`\n"
"\n"
"### Shutdown values (:shutdown)\n"
"\n"
"The following shutdown values are supported:\n"
"\n"
"  * `:brutal_kill` - the child process is unconditionally terminated\n"
"    using `exit(child, :kill)`.\n"
"\n"
"  * `:infinity` - if the child process is a supervisor, it is a mechanism\n"
"    to give the subtree enough time to shutdown. It can also be used with\n"
"    workers with care.\n"
"\n"
"  * Finally, it can also be any integer meaning that the supervisor tells\n"
"    the child process to terminate by calling `Process.exit(child, :shutdown)`\n"
"    and then waits for an exit signal back. If no exit signal is received\n"
"    within the specified time (in miliseconds), the child process is\n"
"    unconditionally terminated using `Process.exit(child, :kill)`.\n"
msgstr ""
#. TRANSLATORS: Elixir.GenServer Summary
#: lib/gen_server.ex:1 
msgid ""
"A behaviour module for implementing the server of a client-server relation.\n"
"\n"
"A GenServer is a process as any other Elixir process and it can be used\n"
"to keep state, execute code asynchronously and so on. The advantage of using\n"
"a generic server process (GenServer) implemented using this module is that it\n"
"will have a standard set of interface functions and include functionality for\n"
"tracing and error reporting. It will also fit into a supervision tree.\n"
"\n"
"## Example\n"
"\n"
"The GenServer behaviour abstracts the common client-server interaction.\n"
"Developers are only required to implement the callbacks and functionality they are\n"
"interested in.\n"
"\n"
"Let's start with a code example and then explore the available callbacks.\n"
"Imagine we want a GenServer that works like a stack, allowing us to push\n"
"and pop items:\n"
"\n"
"    defmodule Stack do\n"
"      use GenServer\n"
"\n"
"      # Callbacks\n"
"\n"
"      def handle_call(:pop, _from, [h|t]) do\n"
"        {:reply, h, t}\n"
"      end\n"
"\n"
"      def handle_cast({:push, item}, state) do\n"
"        {:noreply, [item|state]}\n"
"      end\n"
"    end\n"
"\n"
"    # Start the server\n"
"    {:ok, pid} = GenServer.start_link(Stack, [:hello])\n"
"\n"
"    # This is the client\n"
"    GenServer.call(pid, :pop)\n"
"    #=> :hello\n"
"\n"
"    GenServer.cast(pid, {:push, :world})\n"
"    #=> :ok\n"
"\n"
"    GenServer.call(pid, :pop)\n"
"    #=> :world\n"
"\n"
"We start our `Stack` by calling `start_link/3`, passing the module\n"
"with the server implementation and its initial argument (a list\n"
"representing the stack containing the item `:hello`). We can primarily\n"
"interact with the server by sending two types of messages. **call**\n"
"messages expect a reply from the server (and are therefore synchronous)\n"
"while **cast** messages do not.\n"
"\n"
"Every time you do a `GenServer.call/3`, the client will send a message\n"
"that must be handled by the `handle_call/3` callback in the GenServer.\n"
"A `cast/2` message must be handled by `handle_cast/2`.\n"
"\n"
"## Callbacks\n"
"\n"
"There are 6 callbacks required to be implemented in a `GenServer`. By\n"
"adding `use GenServer` to your module, Elixir will automatically define\n"
"all 6 callbacks for you, leaving it up to you to implement the ones\n"
"you want to customize. The callbacks are:\n"
"\n"
"  * `init(args)` - invoked when the server is started.\n"
"\n"
"    It must return:\n"
"\n"
"    -  `{:ok, state}`\n"
"    -  `{:ok, state, timeout}`\n"
"    -  `:ignore`\n"
"    -  `{:stop, reason}`\n"
"\n"
"  * `handle_call(msg, {from, ref}, state)` and `handle_cast(msg, state)` -\n"
"    invoked to handle call (sync) and cast (async) messages.\n"
"\n"
"    It must return:\n"
"\n"
"    -  `{:reply, reply, new_state}`\n"
"    -  `{:reply, reply, new_state, timeout}`\n"
"    -  `{:reply, reply, new_state, :hibernate}`\n"
"    -  `{:noreply, new_state}`\n"
"    -  `{:noreply, new_state, timeout}`\n"
"    -  `{:noreply, new_state, :hibernate}`\n"
"    -  `{:stop, reason, new_state}`\n"
"    -  `{:stop, reason, reply, new_state}`\n"
"\n"
"  * `handle_info(msg, state)` - invoked to handle all other messages which\n"
"    are received by the process.\n"
"\n"
"    It must return:\n"
"\n"
"    -  `{:noreply, state}`\n"
"    -  `{:noreply, state, timeout}`\n"
"    -  `{:stop, reason, state}`\n"
"\n"
"  * `terminate(reason, state)` - called when the server is about to\n"
"    terminate, useful for cleaning up. It must return `:ok`.\n"
"\n"
"  * `code_change(old_vsn, state, extra)` - called when the application\n"
"    code is being upgraded live (hot code swapping).\n"
"\n"
"    It must return:\n"
"\n"
"    -  `{:ok, new_state}`\n"
"    -  `{:error, reason}`\n"
"\n"
"## Name Registration\n"
"\n"
"Both `start_link/3` and `start/3` support the `GenServer` to register\n"
"a name on start via the `:name` option. Registered names are also\n"
"automatically cleaned up on termination. The supported values are:\n"
"\n"
"  * an atom - the GenServer is registered locally with the given name\n"
"    using `Process.register/2`.\n"
"\n"
"  * `{:global, term}`- the GenServer is registered globally with the given\n"
"    term using the functions in the `:global` module.\n"
"\n"
"  * `{:via, module, term}` - the GenServer is registered with the given\n"
"    mechanism and name. The `:via` option expects a module name to control\n"
"    the registration mechanism alongside a name which can be any term.\n"
"\n"
"For example, we could start and register our Stack server locally as follows:\n"
"\n"
"    # Start the server and register it locally with name MyStack\n"
"    {:ok, _} = GenServer.start_link(Stack, [:hello], name: MyStack)\n"
"\n"
"    # Now messages can be sent directly to MyStack\n"
"    GenServer.call(MyStack, :pop) #=> :hello\n"
"\n"
"Once the server is started, the remaining functions in this module (`call/3`,\n"
"`cast/2`, and friends) will also accept an atom, or any `:global` or `:via`\n"
"tuples. In general, the following formats are supported:\n"
"\n"
"  * a `pid`\n"
"  * an `atom` if the server is locally registered\n"
"  * `{atom, node}` if the server is locally registered at another node\n"
"  * `{:global, term}` if the server is globally registered\n"
"  * `{:via, module, name}` if the server is registered through an alternative\n"
"    registry\n"
"\n"
"## Client / Server APIs\n"
"\n"
"Although in the example above we have used `GenServer.start_link/3` and\n"
"friends to directly start and communicate with the server, most of the\n"
"time we don't call the `GenServer` functions directly. Instead, we wrap\n"
"the calls in new functions representing the public API of the server.\n"
"\n"
"Here is a better implementation of our Stack module:\n"
"\n"
"    defmodule Stack do\n"
"      use GenServer\n"
"\n"
"      # Client\n"
"\n"
"      def start_link(default) do\n"
"        GenServer.start_link(__MODULE__, default)\n"
"      end\n"
"\n"
"      def push(pid, item) do\n"
"        GenServer.cast(pid, {:push, item})\n"
"      end\n"
"\n"
"      def pop(pid) do\n"
"        GenServer.call(pid, :pop)\n"
"      end\n"
"\n"
"      # Server (callbacks)\n"
"\n"
"      def handle_call(:pop, _from, [h|t]) do\n"
"        {:reply, h, t}\n"
"      end\n"
"\n"
"      def handle_call(request, from, state) do\n"
"        # Call the default implementation from GenServer\n"
"        super(request, from, state)\n"
"      end\n"
"\n"
"      def handle_cast({:push, item}, state) do\n"
"        {:noreply, [item|state]}\n"
"      end\n"
"\n"
"      def handle_cast(request, state) do\n"
"        super(request, state)\n"
"      end\n"
"    end\n"
"\n"
"In practice, it is common to have both server and client functions in\n"
"the same module. If the server and/or client implementations are growing\n"
"complex, you may want to have them in different modules.\n"
"\n"
"## Learn more\n"
"\n"
"If you wish to find out more about gen servers, Elixir getting started\n"
"guides provide a tutorial-like introduction. The documentation and links\n"
"in Erlang can also provide extra insight.\n"
"\n"
"  * http://elixir-lang.org/getting_started/mix_otp/1.html\n"
"  * http://www.erlang.org/doc/man/gen_server.html\n"
"  * http://www.erlang.org/doc/design_principles/gen_server_concepts.html\n"
"  * http://learnyousomeerlang.com/clients-and-servers\n"
msgstr ""
#. TRANSLATORS: Elixir.Supervisor Summary
#: lib/supervisor.ex:1 
msgid ""
"A behaviour module for implementing supervision functionality.\n"
"\n"
"A supervisor is a process which supervises other processes called\n"
"child processes. Supervisors are used to build an hierarchical process\n"
"structure called a supervision tree, a nice way to structure fault-tolerant\n"
"applications.\n"
"\n"
"A supervisor implemented using this module will have a standard set\n"
"of interface functions and include functionality for tracing and error\n"
"reporting. It will also fit into a supervision tree.\n"
"\n"
"## Example\n"
"\n"
"In order to define a supervisor, we need to first define a child process\n"
"that is going to be supervised. In order to do so, we will define a GenServer\n"
"that represents a stack:\n"
"\n"
"    defmodule Stack do\n"
"      use GenServer\n"
"\n"
"      def start_link(state) do\n"
"        GenServer.start_link(__MODULE__, state, [name: :sup_stack])\n"
"      end\n"
"\n"
"      def handle_call(:pop, _from, [h|t]) do\n"
"        {:reply, h, t}\n"
"      end\n"
"\n"
"      def handle_cast({:push, h}, t) do\n"
"        {:noreply, [h|t]}\n"
"      end\n"
"    end\n"
"\n"
"We can now define our supervisor and start it as follows:\n"
"\n"
"    # Import helpers for defining supervisors\n"
"    import Supervisor.Spec\n"
"\n"
"    # We are going to supervise the Stack server which will\n"
"    # be started with a single argument [:hello]\n"
"    children = [\n"
"      worker(Stack, [[:hello]])\n"
"    ]\n"
"\n"
"    # Start the supervisor with our one child\n"
"    {:ok, pid} = Supervisor.start_link(children, strategy: :one_for_one)\n"
"\n"
"Notice that when starting the GenServer, we have registered it\n"
"with name `:sup_stack`, which allows us to call it directly and\n"
"get what is on the stack:\n"
"\n"
"    GenServer.call(:sup_stack, :pop)\n"
"    #=> :hello\n"
"\n"
"    GenServer.cast(:sup_stack, {:push, :world})\n"
"    #=> :ok\n"
"\n"
"    GenServer.call(:sup_stack, :pop)\n"
"    #=> :world\n"
"\n"
"However, there is a bug in our stack server. If we call `:pop` and\n"
"the stack is empty, it is going to crash because no clause matches.\n"
"Let's try it:\n"
"\n"
"    GenServer.call(:sup_stack, :pop)\n"
"    =ERROR REPORT====\n"
"\n"
"Luckily, since the server is being supervised by a supervisor, the\n"
"supervisor will automatically start a new one, with the default stack\n"
"of `[:hello]` like before:\n"
"\n"
"    GenServer.call(:sup_stack, :pop) == :hello\n"
"\n"
"Supervisors support different strategies; in the example above, we\n"
"have chosen `:one_for_one`. Furthermore, each supervisor can have many\n"
"workers and supervisors as children, each of them with their specific\n"
"configuration, shutdown values, and restart strategies.\n"
"\n"
"Continue reading this moduledoc to learn more about supervision strategies\n"
"and then follow to the `Supervisor.Spec` module documentation to learn\n"
"about the specification for workers and supervisors.\n"
"\n"
"## Module-based supervisors\n"
"\n"
"In the example above, a supervisor was dynamically created by passing\n"
"the supervision structure to `start_link/2`. However, supervisors\n"
"can also be created by explicitly defining a supervision module:\n"
"\n"
"    defmodule MyApp.Supervisor do\n"
"      use Supervisor\n"
"\n"
"      def start_link do\n"
"        Supervisor.start_link(__MODULE__, [])\n"
"      end\n"
"\n"
"      def init([]) do\n"
"        children = [\n"
"          worker(Stack, [[:hello]])\n"
"        ]\n"
"\n"
"        supervise(children, strategy: :one_for_one)\n"
"      end\n"
"    end\n"
"\n"
"You may want to use a module-based supervisor if:\n"
"\n"
"  * You need to do some particular action on supervisor\n"
"    initialization, like setting up a ETS table.\n"
"\n"
"  * You want to perform partial hot-code swapping of the\n"
"    tree. For example, if you add or remove a children,\n"
"    the module-based supervision will add and remove the\n"
"    new children directly, while the dynamic supervision\n"
"    requires the whole tree to be restarted in order to\n"
"    perform such swaps.\n"
"\n"
"## Strategies\n"
"\n"
"  * `:one_for_one` - if a child process terminates, only that\n"
"    process is restarted.\n"
"\n"
"  * `:one_for_all` - if a child process terminates, all other child\n"
"    processes are terminated and then all child processes (including\n"
"    the terminated one) are restarted.\n"
"\n"
"  * `:rest_for_one` - if a child process terminates, the \"rest\" of\n"
"    the child processes, i.e. the child processes after the terminated\n"
"    one in start order, are terminated. Then the terminated child\n"
"    process and the rest of the child processes are restarted.\n"
"\n"
"  * `:simple_one_for_one` - similar to `:one_for_one` but suits better\n"
"    when dynamically attaching children. This strategy requires the\n"
"    supervisor specification to contain only one child. Many functions\n"
"    in this module behave slightly differently when this strategy is\n"
"    used.\n"
"\n"
"## Name Registration\n"
"\n"
"A supervisor is bound to the same name registration rules as a `GenServer`.\n"
"Read more about it in the `GenServer` docs.\n"
msgstr ""
#. TRANSLATORS: Elixir.GenEvent Summary
#: lib/gen_event.ex:1 
msgid ""
"A behaviour module for implementing event handling functionality.\n"
"\n"
"The event handling model consists of a generic event manager\n"
"process with an arbitrary number of event handlers which are\n"
"added and deleted dynamically.\n"
"\n"
"An event manager implemented using this module will have a standard\n"
"set of interface functions and include functionality for tracing and\n"
"error reporting. It will also fit into a supervision tree.\n"
"\n"
"## Example\n"
"\n"
"There are many use cases for event handlers. For example, a logging\n"
"system can be built using event handlers where each log message is\n"
"an event and different event handlers can be plugged to handle the\n"
"log messages. One handler may print error messages on the terminal,\n"
"another can write it to a file, while a third one can keep the\n"
"messages in memory (like a buffer) until they are read.\n"
"\n"
"As an example, let's have a GenEvent that accumulates messages until\n"
"they are collected by an explicit call.\n"
"\n"
"    defmodule LoggerHandler do\n"
"      use GenEvent\n"
"\n"
"      # Callbacks\n"
"\n"
"      def handle_event({:log, x}, messages) do\n"
"        {:ok, [x|messages]}\n"
"      end\n"
"\n"
"      def handle_call(:messages, messages) do\n"
"        {:ok, Enum.reverse(messages), []}\n"
"      end\n"
"    end\n"
"\n"
"    {:ok, pid} = GenEvent.start_link()\n"
"\n"
"    GenEvent.add_handler(pid, LoggerHandler, [])\n"
"    #=> :ok\n"
"\n"
"    GenEvent.notify(pid, {:log, 1})\n"
"    #=> :ok\n"
"\n"
"    GenEvent.notify(pid, {:log, 2})\n"
"    #=> :ok\n"
"\n"
"    GenEvent.call(pid, LoggerHandler, :messages)\n"
"    #=> [1, 2]\n"
"\n"
"    GenEvent.call(pid, LoggerHandler, :messages)\n"
"    #=> []\n"
"\n"
"We start a new event manager by calling `GenEvent.start_link/0`.\n"
"Notifications can be sent to the event manager which will then\n"
"invoke `handle_event/2` for each registered handler.\n"
"\n"
"We can add new handlers with `add_handler/3` and `add_mon_handler/3`.\n"
"Calls can also be made to specific handlers by using `call/3`.\n"
"\n"
"## Callbacks\n"
"\n"
"There are 6 callbacks required to be implemented in a `GenEvent`. By\n"
"adding `use GenEvent` to your module, Elixir will automatically define\n"
"all 6 callbacks for you, leaving it up to you to implement the ones\n"
"you want to customize. The callbacks are:\n"
"\n"
"  * `init(args)` - invoked when the event handler is added.\n"
"\n"
"    It must return:\n"
"\n"
"    -  `{:ok, state}`\n"
"    -  `{:ok, state, :hibernate}`\n"
"    -  `{:error, reason}`\n"
"\n"
"  * `handle_event(msg, state)` - invoked whenever an event is sent via\n"
"    `notify/2`, `ack_notify/2` or `sync_notify/2`.\n"
"\n"
"    It must return:\n"
"\n"
"    -  `{:ok, new_state}`\n"
"    -  `{:ok, new_state, :hibernate}`\n"
"    -  `:remove_handler`\n"
"\n"
"  * `handle_call(msg, state)` - invoked when a `call/3` is done to a specific\n"
"    handler.\n"
"\n"
"    It must return:\n"
"\n"
"    -  `{:ok, reply, new_state}`\n"
"    -  `{:ok, reply, new_state, :hibernate}`\n"
"    -  `{:remove_handler, reply}`\n"
"\n"
"  * `handle_info(msg, state)` - invoked to handle all other messages which\n"
"    are received by the process. Must return the same values as\n"
"    `handle_event/2`.\n"
"\n"
"  * `terminate(reason, state)` - called when the event handler is removed or\n"
"    the event manager is terminating. It can return any term.\n"
"\n"
"    The reason is one of:\n"
"\n"
"    -  `:stop` - manager is terminating\n"
"    -  `{:stop, reason}` - monitored process terminated (for monitored handlers)\n"
"    -  `:remove_handler` - handler is being removed\n"
"    -  `{:error, term}` - handler crashed or returned a bad value\n"
"    -  `term` - any term passed to functions like `GenEvent.remove_handler/2`\n"
"\n"
"  * `code_change(old_vsn, state, extra)` - called when the application\n"
"    code is being upgraded live (hot code swapping).\n"
"\n"
"    It must return:\n"
"\n"
"    -  `{:ok, new_state}`\n"
"\n"
"## Name Registration\n"
"\n"
"A GenEvent is bound to the same name registration rules as a `GenServer`.\n"
"Read more about it in the `GenServer` docs.\n"
"\n"
"## Modes\n"
"\n"
"GenEvent stream supports three different notifications.\n"
"\n"
"On `GenEvent.ack_notify/2`, the manager acknowledges each event,\n"
"providing back pressure, but processing of the message happens\n"
"asynchronously.\n"
"\n"
"On `GenEvent.sync_notify/2`, the manager acknowledges an event\n"
"just after it was processed by all event handlers.\n"
"\n"
"On `GenEvent.notify/2`, all events are processed asynchronously and\n"
"there is no ack (which means there is no backpressure).\n"
"\n"
"## Streaming\n"
"\n"
"`GenEvent` messages can be streamed with the help of `stream/2`.\n"
"Here are some examples:\n"
"\n"
"    stream = GenEvent.stream(pid)\n"
"\n"
"    # Discard the next 10 events\n"
"    _ = Enum.drop(stream, 10)\n"
"\n"
"    # Print all remaining events\n"
"    for event <- stream do\n"
"      IO.inspect event\n"
"    end\n"
"\n"
"## Learn more and compatibility\n"
"\n"
"If you wish to find out more about gen events, Elixir getting started\n"
"guides provide a tutorial-like introduction. The documentation and links\n"
"in Erlang can also provide extra insight.\n"
"\n"
"  * http://elixir-lang.org/getting_started/mix_otp/1.html\n"
"  * http://www.erlang.org/doc/man/gen_event.html\n"
"  * http://learnyousomeerlang.com/event-handlers\n"
"\n"
"Keep in mind though Elixir and Erlang gen events are not 100% compatible.\n"
"The `:gen_event.add_sup_handler/3` is not supported by Elixir's GenEvent,\n"
"which in turn supports `GenEvent.add_mon_handler/3`.\n"
"\n"
"The benefits of the monitoring approach are described in the \"Don't drink\n"
"too much kool aid\" section of the \"Learn you some Erlang\" link above. Due\n"
"to those changes, Elixir's GenEvent does not trap exits by default.\n"
"\n"
"Futhermore, Elixir's also normalizes the `{:error, _}` tuples returned\n"
"by many functions, in order to be more consistent with themselves and\n"
"the `GenServer` module.\n"
msgstr ""
#. TRANSLATORS: Elixir.String Summary
#: lib/string.ex:3 
msgid ""
"A String in Elixir is a UTF-8 encoded binary.\n"
"\n"
"## Codepoints and graphemes\n"
"\n"
"The functions in this module act according to the Unicode\n"
"Standard, version 6.3.0. As per the standard, a codepoint is\n"
"an Unicode Character, which may be represented by one or more\n"
"bytes. For example, the character \"Ã©\" is represented with two\n"
"bytes:\n"
"\n"
"    iex> byte_size(\"Ã©\")\n"
"    2\n"
"\n"
"However, this module returns the proper length:\n"
"\n"
"    iex> String.length(\"Ã©\")\n"
"    1\n"
"\n"
"Furthermore, this module also presents the concept of\n"
"graphemes, which are multiple characters that may be\n"
"\"perceived as a single character\" by readers. For example,\n"
"the same \"Ã©\" character written above could be represented\n"
"by the letter \"e\" followed by the accent Ì:\n"
"\n"
"    iex> string = \"\\x{0065}\\x{0301}\"\n"
"    iex> byte_size(string)\n"
"    3\n"
"    iex> String.length(string)\n"
"    1\n"
"\n"
"Although the example above is made of two characters, it is\n"
"perceived by users as one.\n"
"\n"
"Graphemes can also be two characters that are interpreted\n"
"as one by some languages. For example, some languages may\n"
"consider \"ch\" as a grapheme. However, since this information\n"
"depends on the locale, it is not taken into account by this\n"
"module.\n"
"\n"
"In general, the functions in this module rely on the Unicode\n"
"Standard, but do not contain any of the locale specific behaviour.\n"
"\n"
"More information about graphemes can be found in the [Unicode\n"
"Standard Annex #29](http://www.unicode.org/reports/tr29/).\n"
"This current Elixir version implements Extended Grapheme Cluster\n"
"algorithm.\n"
"\n"
"## String and binary operations\n"
"\n"
"To act accordingly to the Unicode Standard, many functions\n"
"in this module runs in linear time, as it needs to traverse\n"
"the whole string considering the proper Unicode codepoints.\n"
"\n"
"For example, `String.length/1` is going to take longer as\n"
"the input grows. On the other hand, `Kernel.byte_size/1` always runs\n"
"in constant time (i.e. regardless of the input size).\n"
"\n"
"This means often there are performance costs in using the\n"
"functions in this module, compared to the more low-level\n"
"operations that work directly with binaries:\n"
"\n"
"  * `Kernel.binary_part/3` - retrieves part of the binary\n"
"  * `Kernel.bit_size/1` and `Kernel.byte_size/1` - size related functions\n"
"  * `Kernel.is_bitstring/1` and `Kernel.is_binary/1` - type checking function\n"
"  * Plus a number of functions for working with binaries (bytes)\n"
"    [in the `:binary` module](http://erlang.org/doc/man/binary.html)\n"
"\n"
"There are many situations where using the `String` module can\n"
"be avoided in favor of binary functions or pattern matching.\n"
"For example, imagine you have a string `prefix` and you want to\n"
"remove this prefix from another string named `full`.\n"
"\n"
"One may be tempted to write:\n"
"\n"
"    iex> take_prefix = fn full, prefix ->\n"
"    ...>   base = String.length(prefix)\n"
"    ...>   String.slice(full, base, String.length(full) - base)\n"
"    ...> end\n"
"    iex> take_prefix.(\"Mr. John\", \"Mr. \")\n"
"    \"John\"\n"
"\n"
"Although the function above works, it performs poorly. To\n"
"calculate the length of the string, we need to traverse it\n"
"fully, so we traverse both `prefix` and `full` strings, then\n"
"slice the `full` one, traversing it again.\n"
"\n"
"A first attempting at improving it could be with ranges:\n"
"\n"
"    iex> take_prefix = fn full, prefix ->\n"
"    ...>   base = String.length(prefix)\n"
"    ...>   String.slice(full, base..-1)\n"
"    ...> end\n"
"    iex> take_prefix.(\"Mr. John\", \"Mr. \")\n"
"    \"John\"\n"
"\n"
"While this is much better (we don't traverse `full` twice),\n"
"it could still be improved. In this case, since we want to\n"
"extract a substring from a string, we can use `byte_size/1`\n"
"and `binary_part/3` as there is no chance we will slice in\n"
"the middle of a codepoint made of more than one byte:\n"
"\n"
"    iex> take_prefix = fn full, prefix ->\n"
"    ...>   base = byte_size(prefix)\n"
"    ...>   binary_part(full, base, byte_size(full) - base)\n"
"    ...> end\n"
"    iex> take_prefix.(\"Mr. John\", \"Mr. \")\n"
"    \"John\"\n"
"\n"
"Or simply use pattern matching:\n"
"\n"
"    iex> take_prefix = fn full, prefix ->\n"
"    ...>   base = byte_size(prefix)\n"
"    ...>   <<_ :: binary-size(base), rest :: binary>> = full\n"
"    ...>   rest\n"
"    ...> end\n"
"    iex> take_prefix.(\"Mr. John\", \"Mr. \")\n"
"    \"John\"\n"
"\n"
"On the other hand, if you want to dynamically slice a string\n"
"based on an integer value, then using `String.slice/3` is the\n"
"best option as it guarantees we won't incorrectly split a valid\n"
"codepoint in multiple bytes.\n"
"\n"
"## Integer codepoints\n"
"\n"
"Although codepoints could be represented as integers, this\n"
"module represents all codepoints as strings. For example:\n"
"\n"
"    iex> String.codepoints(\"olÃ¡\")\n"
"    [\"o\", \"l\", \"Ã¡\"]\n"
"\n"
"There are a couple of ways to retrieve a character integer\n"
"codepoint. One may use the `?` construct:\n"
"\n"
"    iex> ?o\n"
"    111\n"
"\n"
"    iex> ?Ã¡\n"
"    225\n"
"\n"
"Or also via pattern matching:\n"
"\n"
"    iex> << eacute :: utf8 >> = \"Ã¡\"\n"
"    iex> eacute\n"
"    225\n"
"\n"
"As we have seen above, codepoints can be inserted into\n"
"a string by their hexadecimal code:\n"
"\n"
"    \"ol\\x{0061}\\x{0301}\" #=>\n"
"    \"olÃ¡\"\n"
"\n"
"## Self-synchronization\n"
"\n"
"The UTF-8 encoding is self-synchronizing. This means that\n"
"if malformed data (i.e., data that is not possible according\n"
"to the definition of the encoding) is encountered, only one\n"
"codepoint needs to be rejected.\n"
"\n"
"This module relies on this behaviour to ignore such invalid\n"
"characters. For example, `length/1` is going to return\n"
"a correct result even if an invalid codepoint is fed into it.\n"
"\n"
"In other words, this module expects invalid data to be detected\n"
"when retrieving data from the external source. For example, a\n"
"driver that reads strings from a database will be the one\n"
"responsible to check the validity of the encoding.\n"
msgstr ""
#. TRANSLATORS: Elixir.Map Summary
#: lib/map.ex:1 
msgid ""
"A Dict implementation that works on maps.\n"
"\n"
"Maps are key-value stores where keys are compared using\n"
"the match operator (`===`). Maps can be created with\n"
"the `%{}` special form defined in the `Kernel.SpecialForms`\n"
"module.\n"
"\n"
"For more information about the functions in this module and\n"
"their APIs, please consult the `Dict` module.\n"
msgstr ""
