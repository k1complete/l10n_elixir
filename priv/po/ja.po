msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2015-04-18 15:12+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: @type debug
#: lib/gen_server.ex:0
msgid "debug options supported by the `start*` functions"
msgstr "`start*`関数によりサポートされるデバッグオプション"

#. TRANSLATORS: def Agent.update(agent, fun, timeout \\ 5000)
#: lib/agent.ex:248
msgid ""
"Updates the agent state.\n"
"\n"
"The function `fun` is sent to the `agent` which invokes the function\n"
"passing the agent state. The function must return the new state.\n"
"\n"
"A timeout can also be specified (it has a default value of 5000).\n"
"This function always returns `:ok`.\n"
msgstr ""
"エージェントステートを更新します。\n"
"\n"
"エージェントステートを関数にわたしてその関数を呼び出す`agent`へ\n"
"`fun`関数は送信されます。\n"
"関数は新しいステートを返さなければなりません。\n"
"\n"
"タイムアウトを指定することもできます(デフォルト値は5000です)。\n"
"この関数は常に`:ok`を返します。\n"

#. TRANSLATORS: def Agent.update(agent, module, fun, args, timeout \\ 5000)
#: lib/agent.ex:260
msgid ""
"Updates the agent state.\n"
"\n"
"Same as `update/3` but a module, function and args are expected\n"
"instead of an anonymous function. The state is added as first\n"
"argument to the given list of args.\n"
msgstr ""
"エージェントステートを更新します。\n"
"\n"
"`update/3`と同じですが、無名関数のかわりにモジュール、関数、引数を指定\n"
"します。ステートは与えられた引数リストの最初の引数として追加されます。\n"

#. TRANSLATORS: def Enum.find_value(collection, ifnone \\ nil, fun)
#: lib/enum.ex:732
msgid ""
"Similar to `find/3`, but returns the value of the function\n"
"invocation instead of the element itself.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.find_value([2, 4, 6], fn(x) -> rem(x, 2) == 1 end)\n"
"    nil\n"
"\n"
"    iex> Enum.find_value([2, 3, 4], fn(x) -> rem(x, 2) == 1 end)\n"
"    true\n"
"\n"
msgstr ""
"`find/3`と似ていますが、要素それ自身の替わりに、呼び出した関数の値を返\n"
"します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.find_value([2, 4, 6], fn(x) -> rem(x, 2) == 1 end)\n"
"    nil\n"
"\n"
"    iex> Enum.find_value([2, 3, 4], fn(x) -> rem(x, 2) == 1 end)\n"
"    true\n"
"\n"

#. TRANSLATORS: def Enum.find_index(collection, fun)
#: lib/enum.ex:759
msgid ""
"Similar to `find/3`, but returns the index (zero-based)\n"
"of the element instead of the element itself.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.find_index([2, 4, 6], fn(x) -> rem(x, 2) == 1 end)\n"
"    nil\n"
"\n"
"    iex> Enum.find_index([2, 3, 4], fn(x) -> rem(x, 2) == 1 end)\n"
"    1\n"
"\n"
msgstr ""
"`find/3`と似ていますが、要素自身の替わりに要素のインデックス(ゼロ始ま\n"
"り)を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.find_index([2, 4, 6], fn(x) -> rem(x, 2) == 1 end)\n"
"    nil\n"
"\n"
"    iex> Enum.find_index([2, 3, 4], fn(x) -> rem(x, 2) == 1 end)\n"
"    1\n"
"\n"

#. TRANSLATORS: def File.ls!(path \\ ".")
#: lib/file.ex:1135
msgid ""
"The same as `ls/1` but raises `File.Error`\n"
"in case of an error.\n"
msgstr "`ls/1`と同じですが、エラーのとき`File.Error`例外を上げます。\n"

#. TRANSLATORS: def File.cwd!()
#: lib/file.ex:1066
msgid "The same as `cwd/0`, but raises an exception if it fails.\n"
msgstr "`cwd/0`と同じですが、失敗すると例外を上げます。\n"

#. TRANSLATORS: def File.cp_r!(source, destination, callback \\ fn _, _ -> true end)
#: lib/file.ex:552
msgid ""
"The same as `cp_r/3`, but raises `File.CopyError` if it fails.\n"
"Returns the list of copied files otherwise.\n"
msgstr ""
"`cp_r/3`と同じですが、失敗すると`File.CopyError`を上げます。\n"
"さもなければコピーされたファイルのリストを返します。\n"

#. TRANSLATORS: def File.cp!(source, destination, callback \\ fn _, _ -> true end)
#: lib/file.ex:481
msgid ""
"The same as `cp/3`, but raises `File.CopyError` if it fails.\n"
"Returns the list of copied files otherwise.\n"
msgstr ""
"`cp/3`と同じですが、失敗すると`File.CopyError`を上げます。\n"
"さもなければコピーされたファイルのリストを返します。\n"

#. TRANSLATORS: def File.copy!(source, destination, bytes_count \\ :infinity)
#: lib/file.ex:435
msgid ""
"The same as `copy/3` but raises an `File.CopyError` if it fails.\n"
"Returns the `bytes_copied` otherwise.\n"
msgstr ""
"`copy/3`と同じですが、失敗すると`File.CopyError`を上げます。\n"
"さもなければ、`bytes_copied`(コピーされたバイト数)を返します。\n"

#. TRANSLATORS: def File.cd!(path)
#: lib/file.ex:1088
msgid "The same as `cd/1`, but raises an exception if it fails.\n"
msgstr "`cd/1`と同じですが、失敗すると例外を上げます。\n"

#. TRANSLATORS: @type result
#: lib/enum.ex:0
msgid ""
"The result of the reduce operation.\n"
"\n"
"It may be *done* when the enumeration is finished by reaching\n"
"its end, or *halted*/*suspended* when the enumeration was halted\n"
"or suspended by the reducer function.\n"
"\n"
"In case a reducer function returns the `:suspend` accumulator, the\n"
"`:suspended` tuple must be explicitly handled by the caller and\n"
"never leak. In practice, this means regular enumeration functions\n"
"just need to be concerned about `:done` and `:halted` results.\n"
"\n"
"Furthermore, a `:suspend` call must always be followed by another call,\n"
"eventually halting or continuing until the end.\n"
msgstr ""
"reduceオペレーションの結果です。\n"
"\n"
"終りに到達することで数え上げ(enumeration)が終了したときに\n"
"*done* になり、reducer関数により数え上げ(enumeration)が中止\n"
"(halted)や中断(suspend)された時に *halted*/*suspended* になり\n"
"ます。\n"
"\n"
"reducer関数が`:suspend`アキュムレータを返した場合、呼出し側に\n"
"より、`:suspended`タプルは漏れ無く明示的にハンドルされなけれ\n"
"ばなりません。実際には、これは標準の数え上げ(enumeration)関数\n"
"は`:done`と`:halted`についてだけ心配する必要があることを意味\n"
"します。\n"
"\n"
"さらに、`:suspend`呼出しは、常にもう一つの呼出しがつづき、結\n"
"局中止(halting)するか、終りまで続け(continuing)ます。\n"

#. TRANSLATORS: @type reducer
#: lib/enum.ex:0
msgid ""
"The reducer function.\n"
"\n"
"Should be called with the collection element and the\n"
"accumulator contents. Returns the accumulator for\n"
"the next enumeration step.\n"
msgstr ""
"reducer関数\n"
"\n"
"コレクションの要素とアキュムレータコンテンツを伴って呼び出さ\n"
"れなければなりません。次の数え上げ(enumeration)ステップのための\n"
"アキュムレータを返します。\n"

#. TRANSLATORS: @type kind
#: lib/exception.ex:0
msgid "The kind handled by formatting functions"
msgstr "書式整形関数によりハンドルされます"

#. TRANSLATORS: def GenEvent.ack_notify(manager, event)
#: lib/gen_event.ex:425
msgid ""
"Sends a ack event notification to the event `manager`.\n"
"\n"
"In other words, this function only returns `:ok` as soon as the\n"
"event manager starts processing this event, but it does not wait\n"
"for event handlers to process the sent event.\n"
"\n"
"See `notify/2` for more info. Note this function is specific\n"
"to Elixir's GenEvent and does not work with Erlang ones.\n"
msgstr ""
"同期イベント通知をイベント`manager`へ送信します。\n"
"\n"
"言い替えると、この関数は、イベントマネージャで各々のインストールされた\n"
"イベントハンドラ`handle_event/2`が呼び出されたあと、`:ok`を返すだけです。\n"
"しかし、イベントハンドラがプロセスへイベントを送信するのを\n"
"待ちません。\n"
"\n"
"更なる情報は、`notify/2`を参照してください。この関数は、Elixirの\n"
"GenEvent特有で、Erlangのものと一緒には動作しません。\n"

#. TRANSLATORS: @type name
#: lib/gen_server.ex:0
msgid "The GenServer name"
msgstr "GenServerの名前"

#. TRANSLATORS: @type name
#: lib/gen_event.ex:0
msgid "The GenEvent manager name"
msgstr "GenEvent managerの名前"

#. TRANSLATORS: def IO.write(device \\ :erlang.group_leader(), item)
#: lib/io.ex:150
msgid ""
"Writes the given argument to the given device.\n"
"\n"
"By default the device is the standard output.\n"
"It returns `:ok` if it succeeds.\n"
"\n"
"## Examples\n"
"\n"
"    IO.write \"sample\"\n"
"    #=> \"sample\"\n"
"\n"
"    IO.write :stderr, \"error\"\n"
"    #=> \"error\"\n"
"\n"
msgstr ""
"与えらえれた引数を与えられたデバイスに書き出します。\n"
"\n"
"デフォルトではデバイスは標準出力です。\n"
"もし成功すれば、`:ok`を返します。\n"
"\n"
"## 例\n"
"\n"
"    IO.write \"sample\"\n"
"    #=> \"sample\"\n"
"\n"
"    IO.write :stderr, \"error\"\n"
"    #=> \"error\"\n"
"\n"

#. TRANSLATORS: def IO.binwrite(device \\ :erlang.group_leader(), item)
#: lib/io.ex:164
msgid ""
"Writes the given argument to the given device\n"
"as a binary, no unicode conversion happens.\n"
"\n"
"Check `write/2` for more information.\n"
"\n"
"Note: do not use this function on IO devices in unicode mode\n"
"as it will return the wrong result.\n"
msgstr ""
"与えられた引数を与えられたデバイスにバイナリとして、\n"
"unocode変換を起さずに、書き出します。\n"
"\n"
"それ異常の情報は`write/2`をチェックしてください。\n"
"\n"
"Note: 間違った結果を返すのでunicodeモードのデバイスで\n"
"この関数を使ってはいけません。\n"

#. TRANSLATORS: def File.write_stat(path, stat, opts \\ [])
#: lib/file.ex:340
msgid ""
"Writes the given `File.Stat` back to the filesystem at the given\n"
"path. Returns `:ok` or `{:error, reason}`.\n"
msgstr ""
"与えられた`File.Stat`を与えられたパスのファイルシステムに書き出します。\n"
"`:ok`または`{:error, reason}`を返します。\n"

#. TRANSLATORS: def IO.puts(device \\ :erlang.group_leader(), item)
#: lib/io.ex:174
msgid ""
"Writes the argument to the device, similar to `write/2`,\n"
"but adds a newline at the end. The argument is expected\n"
"to be a chardata.\n"
msgstr ""
"`write/2`と似て、引数をデバイスへ書き出しますが、最後に改行を付加します。\n"
"引数はchardataであることを期待しています。\n"

#. TRANSLATORS: def File.write(path, content, modes \\ [])
#: lib/file.ex:671
msgid ""
"Writes `content` to the file `path`.\n"
"\n"
"The file is created if it does not exist. If it exists, the previous\n"
"contents are overwritten. Returns `:ok` if successful, or `{:error, reason}"
"`\n"
"if an error occurs.\n"
"\n"
"**Warning:** Every time this function is invoked, a file descriptor is "
"opened\n"
"and a new process is spawned to write to the file. For this reason, if you "
"are\n"
"doing multiple writes in a loop, opening the file via `File.open/2` and "
"using\n"
"the functions in `IO` to write to the file will yield much better "
"performance\n"
"then calling this function multiple times.\n"
"\n"
"Typical error reasons are:\n"
"\n"
"  * `:enoent`  - a component of the file name does not exist\n"
"  * `:enotdir` - a component of the file name is not a directory;\n"
"                 on some platforms, enoent is returned instead\n"
"  * `:enospc`  - there is a no space left on the device\n"
"  * `:eacces`  - missing permission for writing the file or searching one "
"of\n"
"                 the parent directories\n"
"  * `:eisdir`  - the named file is a directory\n"
"\n"
"Check `File.open/2` for other available options.\n"
msgstr ""
"`content`を`path`に書き出します。\n"
"\n"
"ファイルはもし存在しなかったら作成されます。もし存在したら、以前の内容\n"
"は上書きされます。成功したら`:ok`を、エラーが起きたら`{:error,\n"
"reason}` を返します。\n"
"\n"
"**警告:** この関数が呼び出されたら毎回、ファイルディスクプリタはオープン\n"
"され、ファイルへ書き出すための新しいプロセスが生成されます。\n"
"この理由から、ループの中で複数回書き出しをするなら、`File.open/2`でファイル"
"を\n"
"オープンして、ファイルへ書き出すために`IO`モジュールの関数を使うことが\n"
"この関数を複数回呼び出すよりも非常によいパフォーマンスを与えます。\n"
"\n"
"典型的なエラー理由は以下の通りです:\n"
"\n"
"  * `:enoent`  - ファイル名の構成要素が存在しません\n"
"  * `:enotdir` - ファイル名の構成要素がディレクトリではありません;\n"
"                 いくつかのプラットフォームでは、enoentが替わりに返されます\n"
"  * `:enospc`  - デバイスに残りスペースがありません。\n"
"  * `:eacces`  - ファイルを書くための、あるいは、親ディレクトリでサーチする\n"
"                 ためのパーミッションがありません。\n"
"  * `:eisdir`  - ファイル名がディレクトリです。\n"
"\n"
"そのほか有効なオプションについて`File.open/2`をチェックしてください\n"

#. TRANSLATORS: def IO.ANSI.underline()
#: lib/io/ansi.ex:57
msgid "Underline: Single"
msgstr "下線: 一重"

#. TRANSLATORS: def IO.ANSI.no_underline()
#: lib/io/ansi.ex:92
msgid "Underline: None"
msgstr "下線: なし"

#. TRANSLATORS: def Inspect.Algebra.format(d, w)
#: lib/inspect/algebra.ex:486
msgid ""
"The formatting function.\n"
"\n"
"Takes the maximum width and a document to print as its arguments\n"
"and returns an IO data representation of the best layout for the\n"
"document to fit in the given width.\n"
msgstr ""
"フォーマット関数です。\n"
"\n"
"最大幅とその引数で表示するドキュメントをとり、その幅にフィットするドキュ\n"
"メントのためのベストレイアウトのIOデータ表現を返します。\n"

#. TRANSLATORS: defmacro Kernel.|>(left, right)
#: lib/kernel.ex:2372
msgid ""
"`|>` is the pipe operator.\n"
"\n"
"This operator introduces the expression on the left as\n"
"the first argument to the function call on the right.\n"
"\n"
"## Examples\n"
"\n"
"    iex> [1, [2], 3] |> List.flatten()\n"
"    [1, 2, 3]\n"
"\n"
"The example above is the same as calling `List.flatten([1, [2], 3])`,\n"
"i.e. the argument on the left side of `|>` is introduced as the first\n"
"argument of the function call on the right side.\n"
"\n"
"This pattern is mostly useful when there is a desire to execute\n"
"a bunch of operations, resembling a pipeline:\n"
"\n"
"    iex> [1, [2], 3] |> List.flatten |> Enum.map(fn x -> x * 2 end)\n"
"    [2, 4, 6]\n"
"\n"
"The example above will pass the list to `List.flatten/1`, then get\n"
"the flattened list and pass to `Enum.map/2`, which will multiply\n"
"each entry in the list per two.\n"
"\n"
"In other words, the expression above simply translates to:\n"
"\n"
"    Enum.map(List.flatten([1, [2], 3]), fn x -> x * 2 end)\n"
"\n"
"Beware of operator precedence when using the pipe operator.\n"
"For example, the following expression:\n"
"\n"
"    String.graphemes \"Hello\" |> Enum.reverse\n"
"\n"
"Translates to:\n"
"\n"
"    String.graphemes(\"Hello\" |> Enum.reverse)\n"
"\n"
"Which will result in an error as Enumerable protocol is not defined\n"
"for binaries. Adding explicit parenthesis resolves the ambiguity:\n"
"\n"
"    String.graphemes(\"Hello\") |> Enum.reverse\n"
"\n"
"Or, even better:\n"
"\n"
"    \"Hello\" |> String.graphemes |> Enum.reverse\n"
"\n"
msgstr ""
"`|>` はパイプオペレータです。\n"
"\n"
"この演算子は右の関数呼び出しの最初の引数として左の式を送ります。\n"
"\n"
"## 例\n"
"\n"
"    iex> [1, [2], 3] |> List.flatten()\n"
"    [1, 2, 3]\n"
"\n"
"上の例は`List.flatten([1, [2], 3])`を呼び出すのと同じです。\n"
"すなわち、`|>`の左側の引数は右側の呼びだし関数の最初の引数として\n"
"送られます。\n"
"\n"
"沢山のオペレーションを実行したいとき、このパターンは非常に使い易いです。\n"
"そしてパイプラインに似ています:\n"
"\n"
"    iex> [1, [2], 3] |> List.flatten |> Enum.map(fn x -> x * 2 end)\n"
"    [2, 4, 6]\n"
"\n"
"上の例は`List.flatten/1`にリストを送り、それから平坦化されたリストを\n"
"得て、リストのそれぞれのエントリを2倍するために`Enum.map/2`へ送ります。\n"
"\n"
"言い替えると、上の式は単に以下のように翻訳できます:\n"
"\n"
"    Enum.map(List.flatten([1, [2], 3]), fn x -> x * 2 end)\n"
"\n"
"パイプオペレータを使用するとき、演算子の優先順位に注意してください。\n"
"例えば、以下の式は:\n"
"\n"
"    String.graphemes \"Hello\" |> Enum.reverse\n"
"\n"
"このように翻訳されます:\n"
"\n"
"    String.graphemes(\"Hello\" |> Enum.reverse)\n"
"\n"
"バイナリに対するEnumerableプロトコルが定義されていないのでエラーに終りま"
"す。\n"
"明示的に括弧を加えることで曖昧さを解決します:\n"
"\n"
"    String.graphemes(\"Hello\") |> Enum.reverse\n"
"\n"
"または、もっとよい方法で:\n"
"\n"
"    \"Hello\" |> String.graphemes |> Enum.reverse\n"
"\n"

#. TRANSLATORS: defmacro Kernel.use(module, opts \\ [])
#: lib/kernel.ex:3245
msgid ""
"`use` is a simple mechanism for using a given module into\n"
"the current context.\n"
"\n"
"## Examples\n"
"\n"
"For example, in order to write tests using the ExUnit framework,\n"
"a developer should use the `ExUnit.Case` module:\n"
"\n"
"    defmodule AssertionTest do\n"
"      use ExUnit.Case, async: true\n"
"\n"
"      test \"always pass\" do\n"
"        assert true\n"
"      end\n"
"    end\n"
"\n"
"By calling `use`, a hook called `__using__` will be invoked in\n"
"`ExUnit.Case` which will then do the proper setup.\n"
"\n"
"Simply put, `use` is simply a translation to:\n"
"\n"
"    defmodule AssertionTest do\n"
"      require ExUnit.Case\n"
"      ExUnit.Case.__using__([async: true])\n"
"\n"
"      test \"always pass\" do\n"
"        assert true\n"
"      end\n"
"    end\n"
"\n"
msgstr ""
"`use`はカレントコンテキストに与えられたモジュールを使うための\n"
"シンプルなメカニズムです。\n"
"\n"
"## 例\n"
"\n"
"例えば、ExUnitフレームワークを使ってテストを書くために、\n"
"開発者は`ExUnit.Case`モジュールをuseしなければなりません。\n"
"\n"
"    defmodule AssertionTest do\n"
"      use ExUnit.Case, async: true\n"
"\n"
"      test \"always pass\" do\n"
"        assert true\n"
"      end\n"
"    end\n"
"\n"
"`use`を呼ぶことにより、`ExUnit.Case`のセットアップをするために\n"
"`__using__`と呼ばれるフックが起動されます。\n"
"\n"
"単に、`use`は以下のように翻訳されます:\n"
"\n"
"    defmodule AssertionTest do\n"
"      require ExUnit.Case\n"
"      ExUnit.Case.__using__([async: true])\n"
"\n"
"      test \"always pass\" do\n"
"        assert true\n"
"      end\n"
"    end\n"
"\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.alias(module, opts)
#: lib/kernel/special_forms.ex:460
msgid ""
"`alias` is used to setup aliases, often useful with modules names.\n"
"\n"
"## Examples\n"
"\n"
"`alias` can be used to setup an alias for any module:\n"
"\n"
"    defmodule Math do\n"
"      alias MyKeyword, as: Keyword\n"
"    end\n"
"\n"
"In the example above, we have set up `MyKeyword` to be aliased\n"
"as `Keyword`. So now, any reference to `Keyword` will be\n"
"automatically replaced by `MyKeyword`.\n"
"\n"
"In case one wants to access the original `Keyword`, it can be done\n"
"by accessing `Elixir`:\n"
"\n"
"    Keyword.values   #=> uses MyKeyword.values\n"
"    Elixir.Keyword.values #=> uses Keyword.values\n"
"\n"
"Notice that calling `alias` without the `as:` option automatically\n"
"sets an alias based on the last part of the module. For example:\n"
"\n"
"    alias Foo.Bar.Baz\n"
"\n"
"Is the same as:\n"
"\n"
"    alias Foo.Bar.Baz, as: Baz\n"
"\n"
"## Lexical scope\n"
"\n"
"`import`, `require` and `alias` are called directives and all\n"
"have lexical scope. This means you can set up aliases inside\n"
"specific functions and it won't affect the overall scope.\n"
"\n"
"## Warnings\n"
"\n"
"If you alias a module and you don't use the alias, Elixir is\n"
"going to issue a warning implying the alias is not being used.\n"
"\n"
"In case the alias is generated automatically by a macro,\n"
"Elixir won't emit any warnings though, since the alias\n"
"was not explicitly defined.\n"
"\n"
"Both warning behaviours could be changed by explicitly\n"
"setting the `:warn` option to true or false.\n"
msgstr ""
"`alias`は別名をセットアップするのに使われ、しばしばモジュール名で役に立ちま"
"す。\n"
"\n"
"## 例\n"
"\n"
"`alias`は任意のモジュールの別名をセットアップするのに使うことができます:\n"
"\n"
"    defmodule Math do\n"
"      alias MyKeyword, as: Keyword\n"
"    end\n"
"\n"
"上の例で、`MyKeyword`の別名として`Keyword`をセットアップしました。だか\n"
"ら今や、`Keyword`へのどんな参照も`MyKeyword`に自動的に置き換えられます。\n"
"\n"
"オリジナルの`Keyword`へアクセスしたい場合は、`Elixir`を付けることで\n"
"可能になります:\n"
"\n"
"    Keyword.values   #=> uses MyKeyword.values\n"
"    Elixir.Keyword.values #=> uses Keyword.values\n"
"\n"
"`as:`オプションなしで`alias`を呼び出すと自動的にモジュールの最後の\n"
"パートを元に別名をセットアップすることに気を付けてください。例えば:\n"
"\n"
"    alias Foo.Bar.Baz\n"
"\n"
"これは以下と同じです:\n"
"\n"
"    alias Foo.Bar.Baz, as: Baz\n"
"\n"
"## レキシカルスコープ\n"
"\n"
"`import`, `require`そして`alias`はディレクトリと呼ばれていて\n"
"レキシカルスコープを持ちます。これは、特定の関数の中に別名を\n"
"セットアップ出来ること、そしてそれが全体のスコープに影響を及ぼさないことを\n"
"意味します。\n"
"\n"
"## 警告\n"
"\n"
"もしモジュールの別名を設定したのにその別名を使わない場合、Elixirは別名\n"
"が使われていないことを意味する警告を発するように思えます。\n"
"\n"
"別名はマクロによって自動的に生成されることに備えて、Elixirは別名が明示\n"
"的に定義されなかった時からいかなる警告も発しないようです。\n"
"\n"
"両方の警告の振舞は`:warn`オプションをtrueまたはfalseに明示的に設定する\n"
"ことで変更できるようになるかもしれません。\n"

#. TRANSLATORS: Elixir.Kernel Summary
#: lib/kernel.ex:8
msgid ""
"`Kernel` provides the default macros and functions\n"
"Elixir imports into your environment. These macros and functions\n"
"can be skipped or cherry-picked via the `import` macro. For\n"
"instance, if you want to tell Elixir not to import the `if`\n"
"macro, you can do:\n"
"\n"
"    import Kernel, except: [if: 2]\n"
"\n"
"Elixir also has special forms that are always imported and\n"
"cannot be skipped. These are described in `Kernel.SpecialForms`.\n"
"\n"
"Some of the functions described in this module are inlined by\n"
"the Elixir compiler into their Erlang counterparts in the `:erlang`\n"
"module. Those functions are called BIFs (builtin internal functions)\n"
"in Erlang-land and they exhibit interesting properties, as some of\n"
"them are allowed in guards and others are used for compiler\n"
"optimizations.\n"
"\n"
"Most of the inlined functions can be seen in effect when capturing\n"
"the function:\n"
"\n"
"    iex> &Kernel.is_atom/1\n"
"    &:erlang.is_atom/1\n"
"\n"
"Those functions will be explicitly marked in their docs as\n"
"\"inlined by the compiler\".\n"
msgstr ""
"Elixirが環境にインポートするデフォルトのマクロと関数を`Kernel`は提供し\n"
"ます。これらのマクロと関数は`import`マクロによってチェリーピッキングや\n"
"スキップすることが出来ます。例えば、もし`if`マクロをインポートしないよ\n"
"うにElixirへ言いたいならば、以下のようにできます:\n"
"\n"
"    import Kernel, except: [if: 2]\n"
"\n"
"Elixirは常にインポートされ、スキップできないスペシャルフォームももって\n"
"います。それらは`Kernel.SpecialForms`に記述されています。\n"
"\n"
"このモジュールで記述される関数のいくつかは、Elixirコンパイラによって\n"
"`:erlang`モジュールでErlangに対応するものにインライン化されます。それら\n"
"の関数はErlang-landでBIFs(builtin internal functions)と呼ばれ、それらの\n"
"幾つかはガードに使うことができたり、コンパイラの最適化に使われたり面白\n"
"い特性を示します。\n"
"\n"
"ほとんどのインライン関数はその関数をキャプチャすると実質的に見られます:\n"
"\n"
"    iex> &Kernel.is_atom/1\n"
"    &:erlang.is_atom/1\n"
"\n"
"それらの関数は\"コンパイラによりインライン化される\"ようにドキュメントで\n"
"明示的にマークされます。\n"

#. TRANSLATORS: def Node.start(name, type \\ :longnames, tick_time \\ 15000)
#: lib/node.ex:21
msgid ""
"Turns a non-distributed node into a distributed node.\n"
"\n"
"This functionality starts the `:net_kernel` and other\n"
"related processes.\n"
msgstr ""
"非分散ノードを分散ノードに変えます。\n"
"\n"
"この関数は`:net_kernel`アプリケーションと、そのほかの関連するプロセスを\n"
"開始します。\n"

#. TRANSLATORS: def Node.stop()
#: lib/node.ex:34
msgid ""
"Turns a distributed node into a non-distributed node.\n"
"\n"
"For other nodes in the network, this is the same as the node going down.\n"
"Only possible when the node was started with `Node.start/3`, otherwise\n"
"returns `{:error, :not_allowed}`. Returns `{:error, :not_found}` if the\n"
"local node is not alive.\n"
msgstr ""
"分散ノードを非分散ノードに変えます。\n"
"\n"
"ネットワークの他のノードからは、これはノードがダウンしたのと同じです。\n"
"`Node.start/3`でそのノードがスタートしていたときだけ、この関数を\n"
"呼ぶことができ、さもなければ、`{:error,:not_allowed}`を返します。\n"
"もしローカルノードが生きていないとき、`{:error, :not_found}`を返します。\n"

#. TRANSLATORS: def Node.ping(node)
#: lib/node.ex:119
msgid ""
"Tries to set up a connection to node.\n"
"\n"
"Returns `:pang` if it fails, or `:pong` if it is successful.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Node.ping(:unknown_node)\n"
"    :pang\n"
"\n"
msgstr ""
"ノードへのコネクションをセットアップします。\n"
"\n"
"失敗したら`:pang`を返し、成功したら`:pong`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Node.ping(:unknown_node)\n"
"    :pang\n"
"\n"

#. TRANSLATORS: def File.rm(path)
#: lib/file.ex:713
msgid ""
"Tries to delete the file `path`.\n"
"\n"
"Returns `:ok` if successful, or `{:error, reason}` if an error occurs.\n"
"Note the file is deleted even if in read-only mode.\n"
"\n"
"Typical error reasons are:\n"
"\n"
"  * `:enoent`  - the file does not exist\n"
"  * `:eacces`  - missing permission for the file or one of its parents\n"
"  * `:eperm`   - the file is a directory and user is not super-user\n"
"  * `:enotdir` - a component of the file name is not a directory;\n"
"                 on some platforms, enoent is returned instead\n"
"  * `:einval`  - filename had an improper type, such as tuple\n"
"\n"
"## Examples\n"
"\n"
"    File.rm('file.txt')\n"
"    #=> :ok\n"
"\n"
"    File.rm('tmp_dir/')\n"
"    #=> {:error, :eperm}\n"
"\n"
msgstr ""
"`path`ファイルの削除を試みます。\n"
"\n"
"成功したら`:ok`を、エラーが発生したら`{:error, reason}`を返します。\n"
"たとえ読み出し専用モードであってもファイルが削除される点に注意してくださ"
"い。\n"
"\n"
"典型的なエラー原因は以下の通りです:\n"
"\n"
"  * `:enoent`  - ファイルが存在しない\n"
"  * `:eacces`  - ファイルまたはその親のいずれかのパーミッションがない\n"
"  * `:eperm`   - ファイルがディレクトリで、ユーザがスーパーユーザでない\n"
"  * `:enotdir` - ファイル名の一部がディレクトリでない;\n"
"                 いくつかのプラットフォームでは、かわりにenoentが返される\n"
"  * `:einval`  - ファイル名にタプルのような不適当なタイプがあった\n"
"\n"
"## 例\n"
"\n"
"    File.rm('file.txt')\n"
"    #=> :ok\n"
"\n"
"    File.rm('tmp_dir/')\n"
"    #=> {:error, :eperm}\n"
"\n"

#. TRANSLATORS: def File.rmdir(path)
#: lib/file.ex:770
msgid ""
"Tries to delete the dir at `path`.\n"
"Returns `:ok` if successful, or `{:error, reason}` if an error occurs.\n"
"\n"
"## Examples\n"
"\n"
"    File.rmdir('tmp_dir')\n"
"    #=> :ok\n"
"\n"
"    File.rmdir('file.txt')\n"
"    #=> {:error, :enotdir}\n"
"\n"
msgstr ""
"`path`のディレクトリの削除を試みます。\n"
"成功したら`{:ok}`を、エラーが発生したら`{:error, reason}`を返します。\n"
"\n"
"## 例\n"
"\n"
"    File.rmdir('tmp_dir')\n"
"    #=> :ok\n"
"\n"
"    File.rmdir('file.txt')\n"
"    #=> {:error, :enotdir}\n"
"\n"

#. TRANSLATORS: def File.mkdir(path)
#: lib/file.ex:143
msgid ""
"Tries to create the directory `path`. Missing parent directories are not "
"created.\n"
"Returns `:ok` if successful, or `{:error, reason}` if an error occurs.\n"
"\n"
"Typical error reasons are:\n"
"\n"
"  * `:eacces`  - missing search or write permissions for the parent\n"
"     directories of `path`\n"
"  * `:eexist`  - there is already a file or directory named `path`\n"
"  * `:enoent`  - a component of `path` does not exist\n"
"  * `:enospc`  - there is a no space left on the device\n"
"  * `:enotdir` - a component of `path` is not a directory;\n"
"     on some platforms, `:enoent` is returned instead\n"
msgstr ""
"`path`ディレクトリの作成を試みます。親ディレクトリが存在しない場合、作\n"
"成されません。\n"
"成功したら`{:ok}`を、エラーが発生したら`{:error, reason}`を返します。\n"
"\n"
"典型的なエラーは以下のとおりです:\n"
"\n"
"  * `:eacces`  - `path`の親ディレクトリへの検索または書込みパーミッションがな"
"い\n"
"  * `:eexist`  - `path`という名前のファイル又はディレクトリが既に存在する\n"
"  * `:enoent`  - `path`の一部が存在しない\n"
"  * `:enospc`  - デバイスの残り容量がない\n"
"  * `:enotdir` - `path`の一部がディレクトリでない;\n"
"     幾つかのプラットフォームではかわりに`:enoent`が返される。\n"

#. TRANSLATORS: def File.mkdir_p(path)
#: lib/file.ex:172
msgid ""
"Tries to create the directory `path`. Missing parent directories are "
"created.\n"
"Returns `:ok` if successful, or `{:error, reason}` if an error occurs.\n"
"\n"
"Typical error reasons are:\n"
"\n"
"  * `:eacces`  - missing search or write permissions for the parent\n"
"                 directories of `path`\n"
"  * `:enospc`  - there is a no space left on the device\n"
"  * `:enotdir` - a component of `path` is not a directory\n"
msgstr ""
"`path`ディレクトリの作成を試みます。親ディレクトリが存在しない場合、作\n"
"成されます。\n"
"\n"
"典型的なエラーは以下のとおりです:\n"
"\n"
"  * `:eacces`  - `path`の親ディレクトリへの検索または書込みパーミッションがな"
"い\n"
"  * `:enospc`  - デバイスの残り容量がない\n"
"  * `:enotdir` - `path`の一部がディレクトリでない;\n"

#. TRANSLATORS: @type t
#: lib/exception.ex:0
msgid "The exception type"
msgstr "例外のタイプ"

#. TRANSLATORS: @type manager
#: lib/gen_event.ex:0
msgid "The event manager reference"
msgstr "イベントマネージャのリファレンス"

#. TRANSLATORS: def IO.ANSI.Docs.default_options()
#: lib/io/ansi/docs.ex:24
msgid ""
"The default options used by this module.\n"
"\n"
"The supported values are:\n"
"\n"
"  * `:enabled`           - toggles coloring on and off (true)\n"
"  * `:doc_bold`          - bold text (bright)\n"
"  * `:doc_code`          - code blocks (cyan, bright)\n"
"  * `:doc_headings`      - h1 and h2 headings (yellow, bright)\n"
"  * `:doc_inline_code`   - inline code (cyan)\n"
"  * `:doc_table_heading` - style for table headings\n"
"  * `:doc_title`         - top level heading (reverse, yellow, bright)\n"
"  * `:doc_underline`     - underlined text (underline)\n"
"  * `:width`             - the width to format the text (80)\n"
"\n"
"Values for the color settings are strings with\n"
"comma-separated ANSI values.\n"
msgstr ""
"このモジュールで使われるデフォルトオプション\n"
"\n"
"サポートされる値は以下の通りです:\n"
"\n"
"  * `:enabled`           - カラーon/offトグル(true)\n"
"  * `:doc_bold`          - ボールドテキスト(bright)\n"
"  * `:doc_code`          - コードブロック(cyan, bright)\n"
"  * `:doc_headings`      - h1、h2ヘディング(yellow, bright)\n"
"  * `:doc_inline_code`   - インラインコード(cyan)\n"
"  * `:doc_table_heading` - テーブルヘディングのスタイル\n"
"  * `:doc_title`         - トップレベルヘディング(reverse, yellow, bright)\n"
"  * `:doc_underline`     - アンダーラインテキスト(underline)\n"
"  * `:width`             - テキストフォーマットの幅(80)\n"
"\n"
"カラーセッティングの値はカンマ区切りANSIの値の文字列です。\n"

#. TRANSLATORS: def Path.wildcard(glob, opts \\ [])
#: lib/path.ex:588
msgid ""
"Traverses paths according to the given `glob` expression.\n"
"\n"
"The wildcard looks like an ordinary path, except that certain\n"
"\"wildcard characters\" are interpreted in a special way. The\n"
"following characters are special:\n"
"\n"
"  * `?` - matches one character\n"
"\n"
"  * `*` - matches any number of characters up to the end of the filename, "
"the\n"
"    next dot, or the next slash\n"
"\n"
"  * `**` - two adjacent `*`'s used as a single pattern will match all\n"
"    files and zero or more directories and subdirectories\n"
"\n"
"  * `[char1,char2,...]` - matches any of the characters listed; two\n"
"    characters separated by a hyphen will match a range of characters\n"
"\n"
"  * `{item1,item2,...}` - matches one of the alternatives\n"
"\n"
"Other characters represent themselves. Only paths that have\n"
"exactly the same character in the same position will match. Note\n"
"that matching is case-sensitive; i.e. \"a\" will not match \"A\".\n"
"\n"
"By default, the patterns `*` and `?` do not match files starting\n"
"with a dot `.` unless `match_dot: true` is given.\n"
"\n"
"## Examples\n"
"\n"
"Imagine you have a directory called `projects` with three Elixir projects\n"
"inside of it: `elixir`, `ex_doc` and `dynamo`. You can find all `.beam` "
"files\n"
"inside the `ebin` directory of each project as follows:\n"
"\n"
"    Path.wildcard(\"projects/*/ebin/**/*.beam\")\n"
"\n"
"If you want to search for both `.beam` and `.app` files, you could do:\n"
"\n"
"    Path.wildcard(\"projects/*/ebin/**/*.{beam,app}\")\n"
"\n"
msgstr ""
"与えられた`glob`表現でパスをトラバースします。\n"
"\n"
"ワイルドカードは普通のパスに見えますが、特定の\"ワイルドカード文字\"は\n"
"特別な方法で解釈されます。以下の文字が特別です:\n"
"\n"
"  * `?` - 一文字にマッチします\n"
"\n"
"  * `*` - ファイル名の終わり、次のドットあるいは、次のスラッシュまでの\n"
"    任意の文字列にマッチします\n"
"\n"
"  * `**` - 一つのパターンとして使われた二つ隣接した`*`は\n"
"    ファイルと0以上のディレクトリとサブディレクトリ全てにマッチします\n"
"\n"
"  * `[char1,char2,...]` - リストされた文字の何れか一つにマッチします; \n"
"     ハイフンで区切られた二つの文字は文字の範囲にマッチします\n"
"\n"
"  * `{item1,item2,...}` - 文字列の何れかひとつにマッチします。\n"
"\n"
"他の文字はそれ自身を表します。正確に同じ場所で同じ文字の場合にだけ\n"
"パスはマッチします。例えば、\"a\"は\"A\"にマッチしません。\n"
"\n"
"`matuch_dot: true`オプションを与えない限り、デフォルトでは`*`と`?`はファ\n"
"イル名先頭の`.`にはマッチしません。\n"
"\n"
"## 例\n"
"\n"
"`elixir`, `ex_doc`, `dynamo`という三つのElixirプロジェクトを含む\n"
"`projects`と呼ばれるディレクトリをもっているとします。以下のようにして、\n"
"それぞれのプロジェクトの`ebin`ディレクトリの中の`.beam`ファイルを見付け\n"
"ることができます。\n"
"\n"
"    Path.wildcard(\"projects/*/ebin/**/*.beam\")\n"
"\n"
"このようにして`.beam`と`.app`ファイル両方を探すこともできます:\n"
"\n"
"    Path.wildcard(\"projects/*/ebin/**/*.{beam,app}\")\n"
"\n"

#. TRANSLATORS: def Process.monitor(item)
#: lib/process.ex:206
msgid ""
"The calling process starts monitoring the item given.\n"
"It returns the monitor reference.\n"
"\n"
"See http://www.erlang.org/doc/man/erlang.html#monitor-2 for more info.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"呼び出したプロセスは与えられたアイテムのモニタを開始します。\n"
"モニタリファレンスを返します。\n"
"\n"
"更なる情報は http://www.erlang.org/doc/man/erlang.html#monitor-2 を参照\n"
"してください。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: @type state
#: lib/agent.ex:0
msgid "The agent state"
msgstr "エージェントのステート"

#. TRANSLATORS: @type agent
#: lib/agent.ex:0
msgid "The agent reference"
msgstr "エージェントのリファレンス"

#. TRANSLATORS: @type name
#: lib/agent.ex:0
msgid "The agent name"
msgstr "エージェントの名前"

#. TRANSLATORS: def File.touch(path, time \\ :calendar.local_time())
#: lib/file.ex:363
msgid ""
"Updates modification time (mtime) and access time (atime) of\n"
"the given file. File is created if it doesn’t exist.\n"
msgstr ""
"与えられたファイルの変更時刻(mtime)とアクセス時刻(atime)を更新します。\n"
"存在しない場合、ファイルは作成されます。\n"

#. TRANSLATORS: def Application.unload(app)
#: lib/application.ex:279
msgid ""
"Unloads the given `app`.\n"
"\n"
"It will also unload all `:included_applications`.\n"
"Note that the function does not purge the application modules.\n"
msgstr ""
"与えられた`app`をアンロードします。\n"
"\n"
"それは`:included_applications`全てをもアンロードします。\n"
"関数はアプリケーションモジュールをパージしないことに\n"
"注意してください。\n"

#. TRANSLATORS: def Dict.update(dict, key, initial, fun)
#: lib/dict.ex:559
msgid ""
"Updates a value in `dict` by calling `fun` on the value to get a new value. "
"If\n"
"`key` is not present in `dict` then `initial` will be stored as the first\n"
"value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.update(dict, :c, 3, fn(val) -> -val end)\n"
"    iex> Dict.get(dict, :c)\n"
"    3\n"
"\n"
msgstr ""
"値から新しい値を取得する`fun`を呼ぶことによって`dict`の値を更新します。\n"
"もし`key`が`dict`に表れなかったら`initial`が最初の値として格納されるで\n"
"しょう。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.update(dict, :c, 3, fn(val) -> -val end)\n"
"    iex> Dict.get(dict, :c)\n"
"    3\n"
"\n"

#. TRANSLATORS: def Keyword.update!(keywords, key, fun)
#: lib/keyword.ex:422
msgid ""
"Updates the `key` with the given function. \n"
"\n"
"If the `key` does not exist, raises `KeyError`.\n"
"\n"
"If there are duplicated keys, they are all removed and only the first one\n"
"is updated.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.update!([a: 1], :a, &(&1 * 2))\n"
"    [a: 2]\n"
"\n"
"    iex> Keyword.update!([a: 1], :b, &(&1 * 2))\n"
"    ** (KeyError) key :b not found in: [a: 1]\n"
"\n"
msgstr ""
"与えられた関数で`key`を更新します。\n"
"\n"
"もし`key`が存在しないなら、`KeyError`を上げます。\n"
"\n"
"もしキーが重複していたら、全て削除され、最初の値だけが\n"
"更新されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.update!([a: 1], :a, &(&1 * 2))\n"
"    [a: 2]\n"
"\n"
"    iex> Keyword.update!([a: 1], :b, &(&1 * 2))\n"
"    ** (KeyError) key :b not found in: [a: 1]\n"
"\n"

#. TRANSLATORS: def Keyword.update(list1, key, initial, fun)
#: lib/keyword.ex:456
msgid ""
"Updates the `key` with the given function. \n"
"\n"
"If the `key` does not exist, inserts the given `initial` value.\n"
"\n"
"If there are duplicated keys, they are all removed and only the first one\n"
"is updated.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.update([a: 1], :a, 13, &(&1 * 2))\n"
"    [a: 2]\n"
"\n"
"    iex> Keyword.update([a: 1], :b, 11, &(&1 * 2))\n"
"    [a: 1, b: 11]\n"
"\n"
msgstr ""
"与えられた関数で`key`を更新します。\n"
"\n"
"もし`key`が存在しないなら、与えられた`initial`値を挿入します。\n"
"\n"
"もしキーが重複していたら、全て削除され、最初の値だけが\n"
"更新されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.update([a: 1], :a, 13, &(&1 * 2))\n"
"    [a: 2]\n"
"\n"
"    iex> Keyword.update([a: 1], :b, 11, &(&1 * 2))\n"
"    [a: 1, b: 11]\n"
"\n"

#. TRANSLATORS: def Dict.update!(dict, key, fun)
#: lib/dict.ex:541
msgid ""
"Updates a value in `dict` by calling `fun` on the value to get a new\n"
"value. An exception is generated if `key` is not present in the dict.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.update!(dict, :a, fn(val) -> -val end)\n"
"    iex> Dict.get(dict, :a)\n"
"    -1\n"
"\n"
msgstr ""
"値から新しい値を取得する`fun`を呼ぶことによって`dict`の値を更新します。\n"
"もし`key`が`dict`に表れなかったら例外が生成されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.update!(dict, :a, fn(val) -> -val end)\n"
"    iex> Dict.get(dict, :a)\n"
"    -1\n"
"\n"

#. TRANSLATORS: @type acc
#: lib/enum.ex:0
msgid ""
"The accumulator value for each step.\n"
"\n"
"It must be a tagged tuple with one of the following \"tags\":\n"
"\n"
"  * `:cont`    - the enumeration should continue\n"
"  * `:halt`    - the enumeration should halt immediately\n"
"  * `:suspend` - the enumeration should be suspended immediately\n"
"\n"
"Depending on the accumulator value, the result returned by\n"
"`Enumerable.reduce/3` will change. Please check the `result`\n"
"type docs for more information.\n"
"\n"
"In case a reducer function returns a `:suspend` accumulator,\n"
"it must be explicitly handled by the caller and never leak.\n"
msgstr ""
"それぞれのステップのアキュムレータの値。\n"
"\n"
"以下の\"タグ\"の何れかにタグ付けられたタプルでなければなりません:\n"
"\n"
"  * `:cont`    - 数え上げ(enumeration)を続けなければならない\n"
"  * `:halt`    - 数え上げ(enumeration)は直ちに中止されなければならない\n"
"  * `:suspend` - 数え上げ(enumeration)は直ちに中断されなければならない\n"
"\n"
"アキュムレータ値に依存して`Enumerable.reduce/3`の戻値は変わり\n"
"ます。詳細は `result` type docをチェックしてください。\n"
"\n"
"reducer関数が`:suspend`アキュムレータを返す場合、呼出し側で明\n"
"示的にハンドルされなければならず、決して漏れてはなりません。\n"

#. TRANSLATORS: def Stream.zip(left, right)
#: lib/stream.ex:819
msgid ""
"Zips two collections together, lazily.\n"
"\n"
"The zipping finishes as soon as any enumerable completes.\n"
"\n"
"## Examples\n"
"\n"
"    iex> concat = Stream.concat(1..3, 4..6)\n"
"    iex> cycle  = Stream.cycle([:a, :b, :c])\n"
"    iex> Stream.zip(concat, cycle) |> Enum.to_list\n"
"    [{1,:a},{2,:b},{3,:c},{4,:a},{5,:b},{6,:c}]\n"
"\n"
msgstr ""
"二つのコレクションを一緒に、遅延評価しながら、zipします。\n"
"\n"
"Enumerableの何れかが完了するとすぐに、zippingも終了します。\n"
"\n"
"## 例\n"
"\n"
"    iex> concat = Stream.concat(1..3, 4..6)\n"
"    iex> cycle  = Stream.cycle([:a, :b, :c])\n"
"    iex> Stream.zip(concat, cycle) |> Enum.to_list\n"
"    [{1,:a},{2,:b},{3,:c},{4,:a},{5,:b},{6,:c}]\n"
"\n"

#. TRANSLATORS: def Enum.zip(coll1, coll2)
#: lib/enum.ex:2034
msgid ""
"Zips corresponding elements from two collections into one list\n"
"of tuples.\n"
"\n"
"The zipping finishes as soon as any enumerable completes.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.zip([1, 2, 3], [:a, :b, :c])\n"
"    [{1,:a},{2,:b},{3,:c}]\n"
"\n"
"    iex> Enum.zip([1,2,3,4,5], [:a, :b, :c])\n"
"    [{1,:a},{2,:b},{3,:c}]\n"
"\n"
msgstr ""
"二つのコレクションから対応する要素を一つのタプルのリストにzipします。\n"
"\n"
"Enumerable何れかが完了するとzippingも終了します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.zip([1, 2, 3], [:a, :b, :c])\n"
"    [{1,:a},{2,:b},{3,:c}]\n"
"\n"
"    iex> Enum.zip([1,2,3,4,5], [:a, :b, :c])\n"
"    [{1,:a},{2,:b},{3,:c}]\n"
"\n"

#. TRANSLATORS: def List.zip(list_of_lists)
#: lib/list.ex:322
msgid ""
"Zips corresponding elements from each list in `list_of_lists`.\n"
"\n"
"The zipping finishes as soon as any list terminates.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.zip([[1, 2], [3, 4], [5, 6]])\n"
"    [{1, 3, 5}, {2, 4, 6}]\n"
"\n"
"    iex> List.zip([[1, 2], [3], [5, 6]])\n"
"    [{1, 3, 5}]\n"
"\n"
msgstr ""
"`list_of_list`のそれぞれのリストから対応する要素をzipします。\n"
"\n"
"どれかのリストが終了するとすぐに、zippingも終了します。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.zip([[1, 2], [3, 4], [5, 6]])\n"
"    [{1, 3, 5}, {2, 4, 6}]\n"
"\n"
"    iex> List.zip([[1, 2], [3], [5, 6]])\n"
"    [{1, 3, 5}]\n"
"\n"

#. TRANSLATORS: def List.wrap(list)
#: lib/list.ex:295
msgid ""
"Wraps the argument in a list.\n"
"If the argument is already a list, returns the list.\n"
"If the argument is `nil`, returns an empty list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.wrap(\"hello\")\n"
"    [\"hello\"]\n"
"\n"
"    iex> List.wrap([1, 2, 3])\n"
"    [1,2,3]\n"
"\n"
"    iex> List.wrap(nil)\n"
"    []\n"
"\n"
msgstr ""
"リストに引数をラップします。\n"
"もし引数が既にリストなら、そのリストを返します。\n"
"もし引数が`nil`なら、空のリストを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.wrap(\"hello\")\n"
"    [\"hello\"]\n"
"\n"
"    iex> List.wrap([1, 2, 3])\n"
"    [1,2,3]\n"
"\n"
"    iex> List.wrap(nil)\n"
"    []\n"
"\n"

#. TRANSLATORS: def System.tmp_dir()
#: lib/system.ex:173
msgid ""
"Writable temporary directory.\n"
"\n"
"Returns a writable temporary directory.\n"
"Searches for directories in the following order:\n"
"\n"
"  1. the directory named by the TMPDIR environment variable\n"
"  2. the directory named by the TEMP environment variable\n"
"  3. the directory named by the TMP environment variable\n"
"  4. `C:\\TMP` on Windows or `/tmp` on Unix\n"
"  5. as a last resort, the current working directory\n"
"\n"
"Returns `nil` if none of the above are writable.\n"
msgstr ""
"書き込み可能なテンポラリディレクトリ\n"
"\n"
"書き込み可能なテンポラリディレクトリを返します。\n"
"以下の順序でディレクトリを探します:\n"
"\n"
"  1. TMPDIR環境変数によるディレクトリ名\n"
"  2. TEMP環境変数によるディレクトリ名\n"
"  3. TMP環境変数によるディレクトリ名\n"
"  4. Windowsでは`C:\\TMP`、Linuxでは`/tmp`\n"
"  5. 最後にカレントワーキングディレクトリ\n"
"\n"
"上の全てが書込み不可だった場合、`nil`を返します。\n"

#. TRANSLATORS: def System.tmp_dir!()
#: lib/system.ex:187
msgid ""
"Writable temporary directory, exception on error.\n"
"\n"
"Same as `tmp_dir/0` but raises `RuntimeError`\n"
"instead of returning `nil` if no temp dir is set.\n"
msgstr ""
"書き込み可能なテンポラリディレクトリ、エラーで例外\n"
"\n"
"`tmp_dir/0`と同じですが、もしテンポラリディレクトリが\n"
"無い場合、`nil`を返すかわりに、`RuntimeError`を上げます。\n"

#. TRANSLATORS: defmacro Kernel.var!(var, context \\ nil)
#: lib/kernel.ex:2514
msgid ""
"When used inside quoting, marks that the variable should\n"
"not be hygienized. The argument can be either a variable\n"
"unquoted or in standard tuple form `{name, meta, context}`.\n"
"\n"
"Check `Kernel.SpecialForms.quote/2` for more information.\n"
msgstr ""
"quoteの内側で使われた時、その変数が衛生的(hygienized)であってはならない\n"
"とマークします。引数はunquoteされた変数か、標準タプルフォームの`{name,\n"
"meta, context}`です。\n"
"\n"
"更なる情報は、`Kernel.SpecialForms.quote/2`をチェックしてください。\n"

#. TRANSLATORS: defmacro Kernel.alias!(alias)
#: lib/kernel.ex:2544
msgid ""
"When used inside quoting, marks that the alias should not\n"
"be hygienized. This means the alias will be expanded when\n"
"the macro is expanded.\n"
"\n"
"Check `Kernel.SpecialForms.quote/2` for more information.\n"
msgstr ""
"quoteの内側で使われた時、その別名が健全(hygienezed)であっては\n"
"ならないとマークします。これは別名はマクロが展開された時に展開\n"
"されるだろうことを意味します。\n"
"\n"
"更なる情報は、`Kernel.SpecialForms.quote/2`をチェックしてくだ\n"
"さい。\n"

#. TRANSLATORS: def Macro.validate(expr)
#: lib/macro.ex:317
msgid ""
"Validates the given expressions are valid quoted expressions.\n"
"\n"
"Check the `type:Macro.t` for the specification of a valid\n"
"quoted expression.\n"
msgstr ""
"与えられた式がquoteされた式として正しいか検証します。\n"
"\n"
"正しいquoteされた式の仕様については`type:Macro.t`をチェック\n"
"してください。\n"

#. TRANSLATORS: def Stream.transform(enum, acc, reducer)
#: lib/stream.ex:638
msgid ""
"Transforms an existing stream.\n"
"\n"
"It expects an accumulator and a function that receives each stream item\n"
"and an accumulator, and must return a tuple containing a new stream\n"
"(often a list) with the new accumulator or a tuple with `:halt` as first\n"
"element and the accumulator as second.\n"
"\n"
"Note: this function is similar to `Enum.flat_map_reduce/3` except the\n"
"latter returns both the flat list and accumulator, while this one returns\n"
"only the stream.\n"
"\n"
"## Examples\n"
"\n"
"`Stream.transform/3` is useful as it can be used as the basis to implement\n"
"many of the functions defined in this module. For example, we can implement\n"
"`Stream.take(enum, n)` as follows:\n"
"\n"
"    iex> enum = 1..100\n"
"    iex> n = 3\n"
"    iex> stream = Stream.transform(enum, 0, fn i, acc ->\n"
"    ...>   if acc < n, do: {[i], acc + 1}, else: {:halt, acc}\n"
"    ...> end)\n"
"    iex> Enum.to_list(stream)\n"
"    [1,2,3]\n"
"\n"
msgstr ""
"既存のストリームを変換します。\n"
"\n"
"アキュムレータとそれぞれのストリームアイテムとアキュムレータを受けとり、\n"
"新しいストリーム(しばしばリスト)と新しいアキュムレータを含むタプルか、\n"
"最初の要素が`:halt`で次の要素がアキュムレータとなるタプルを返す関数を\n"
"期待します。\n"
"\n"
"注: この関数は、`Enum.flat_map_reduce/3`が、フラットリストとアキュムレー\n"
"タを返すこと対して、ストリームだけを返ことを除いては、似ています。\n"
"\n"
"## 例\n"
"\n"
"このモジュールで定義される関数の多くを実装するための基礎として使うこと\n"
"ができるように、`Stream.transform/3`は便利です。例えば、\n"
"`Stream.take(enum, n)`は以下の様に実装できます:\n"
"\n"
"    iex> enum = 1..100\n"
"    iex> n = 3\n"
"    iex> stream = Stream.transform(enum, 0, fn i, acc ->\n"
"    ...>   if acc < n, do: {[i], acc + 1}, else: {:halt, acc}\n"
"    ...> end)\n"
"    iex> Enum.to_list(stream)\n"
"    [1,2,3]\n"
"\n"

#. TRANSLATORS: Elixir.URI Summary
#: lib/uri.ex:1
msgid "Utilities for working with and creating URIs.\n"
msgstr "URIの作成と動作についてのユーティリティです。\n"

#. TRANSLATORS: Elixir.Code Summary
#: lib/code.ex:1
msgid ""
"Utilities for managing code compilation, code evaluation and code loading.\n"
"\n"
"This module complements [Erlang's code module](http://www.erlang.org/doc/man/"
"code.html)\n"
"to add behaviour which is specific to Elixir.\n"
msgstr ""
"コードコンパイル、コード評価、コードローディングの管理のためのユーティ\n"
"リティです。\n"
"\n"
"このモジュールは [Erlangのcodeモジュー\n"
"ル](http://www.erlang.org/doc/man/code.html) にElixir固有の振舞いを追加\n"
"して補足しました。\n"

#. TRANSLATORS: Elixir.Behaviour Summary
#: lib/behaviour.ex:1
msgid ""
"Utilities for defining behaviour interfaces.\n"
"\n"
"Behaviours can be referenced by other modules\n"
"to ensure they implement required callbacks.\n"
"\n"
"For example, you can specify the `URI.Parser`\n"
"behaviour as follows:\n"
"\n"
"    defmodule URI.Parser do\n"
"      use Behaviour\n"
"\n"
"      @doc \"Parses the given URL\"\n"
"      defcallback parse(uri_info :: URI.t) :: URI.t\n"
"\n"
"      @doc \"Defines a default port\"\n"
"      defcallback default_port() :: integer\n"
"    end\n"
"\n"
"And then a module may use it as:\n"
"\n"
"    defmodule URI.HTTP do\n"
"      @behaviour URI.Parser\n"
"      def default_port(), do: 80\n"
"      def parse(info), do: info\n"
"    end\n"
"\n"
"If the behaviour changes or `URI.HTTP` does\n"
"not implement one of the callbacks, a warning\n"
"will be raised.\n"
"\n"
"## Implementation\n"
"\n"
"Since Erlang R15, behaviours must be defined via\n"
"`@callback` attributes. `defcallback` is a simple\n"
"mechanism that defines the `@callback` attribute\n"
"according to the given type specification. `defcallback` allows\n"
"documentation to be created for the callback and defines\n"
"a custom function signature.\n"
"\n"
"The callbacks and their documentation can be retrieved\n"
"via the `__behaviour__` callback function.\n"
msgstr ""
"ビヘイビアインタフェース定義のユーティリティです。\n"
"\n"
"ビヘイビアは必須のコールバックの実装を確実とするために\n"
"他のモジュールにより参照されることができます。\n"
"\n"
"たとえば、`URI.Parser`を以下のとおりにビヘイビアを\n"
"指定することができます:\n"
"\n"
"    defmodule URI.Parser do\n"
"      use Behaviour\n"
"\n"
"      @doc \"Parses the given URL\"\n"
"      defcallback parse(uri_info :: URI.t) :: URI.t\n"
"\n"
"      @doc \"Defines a default port\"\n"
"      defcallback default_port() :: integer\n"
"    end\n"
"\n"
"そしてモジュールはそれを使うかももしれません:\n"
"\n"
"    defmodule URI.HTTP do\n"
"      @behaviour URI.Parser\n"
"      def default_port(), do: 80\n"
"      def parse(info), do: info\n"
"    end\n"
"\n"
"もしビヘイビアが変わるか、`URI.HTTP`がコールバックの\n"
"一つを実装していないなら、警告が引き起されるでしょう。\n"
"\n"
"## 実装\n"
"\n"
"Erlang R15から、ビヘイビアは`@callback`アトリビュートによって定義されな\n"
"ければなりません。`defcallback`は所定のタイプ仕様にしたがって\n"
"`@callback`アトリビュートを定義するシンプルなメカニズムです。\n"
"`defcallback`はコールバックのためのドキュメンテーションを作成することを\n"
"許して、カスタムの関数シグネチャを定義します。\n"
"\n"
"コールバックとそのドキュメンテーションは`__behaviour__`コールバック関数\n"
"によって検索されることが出来ます。\n"

#. TRANSLATORS: def System.user_home()
#: lib/system.ex:127
msgid ""
"User home directory.\n"
"\n"
"Returns the user home directory (platform independent).\n"
"Returns `nil` if no user home is set.\n"
msgstr ""
"ユーザホームディレクトリです。\n"
"\n"
"(プラットフォーム依存の)ユーザホームディレクトリを返します。\n"
"もしユーザホームがセットされていない場合、`nil`を返します。\n"

#. TRANSLATORS: def System.user_home!()
#: lib/system.ex:140
msgid ""
"User home directory, exception on error.\n"
"\n"
"Same as `user_home/0` but raises `RuntimeError`\n"
"instead of returning `nil` if no user home is set.\n"
msgstr ""
"ユーザホームディレクトリを返し、エラー時に例外を生成します。\n"
"\n"
"`user_home/0`と同じですが、\n"
"もしユーザホームがセットされていない場合、`nil`を返すか\n"
"わりに`RuntimeError`を上げます。\n"

#. TRANSLATORS: Elixir.Set Summary
#: lib/set.ex:1
msgid ""
"This module specifies the Set API expected to be\n"
"implemented by different representations.\n"
"\n"
"It also provides functions that redirect to the\n"
"underlying Set, allowing a developer to work with\n"
"different Set implementations using one API.\n"
"\n"
"To create a new set, use the `new` functions defined\n"
"by each set type:\n"
"\n"
"    HashSet.new  #=> creates an empty HashSet\n"
"\n"
"In the examples below, `set_impl` means a specific\n"
"`Set` implementation, for example `HashSet`.\n"
"\n"
"## Protocols\n"
"\n"
"Sets are required to implement both `Enumerable` and `Collectable`\n"
"protocols.\n"
"\n"
"## Match\n"
"\n"
"Sets are required to implement all operations using the match (`===`)\n"
"operator.\n"
msgstr ""
"このモジュールは異った表現による実装に期待されるべき、Set API仕様を\n"
"指定します。\n"
"\n"
"一つのAPIを使って異るSetの実装で開発者が仕事をすることを許す、基礎をな\n"
"すSetへリダイレクトする関数も提供します。\n"
"\n"
"新しい集合を作成するために、それぞれの集合のタイプ毎に\n"
"定義された`new`関数を使います:\n"
"\n"
"    HashSet.new  #=> creates an empty HashSet\n"
"\n"
"下の例では、`set_impl`は特定の`Set`実装、例えば`HashSet`を意味します。\n"
"\n"
"## プロトコル\n"
"\n"
"Setは`Enumerable`と`Collectable`プロトコルの両方の実装を要求します。\n"
"\n"
"## マッチ\n"
"\n"
"Setは実装をマッチオペレータ(`===`)を使う全ての操作の実装を\n"
"要求します。\n"

#. TRANSLATORS: Elixir.Dict Summary
#: lib/dict.ex:1
msgid ""
"This module specifies the Dict API expected to be\n"
"implemented by different dictionaries. It also provides\n"
"functions that redirect to the underlying Dict, allowing\n"
"a developer to work with different Dict implementations\n"
"using one API.\n"
"\n"
"To create a new dict, use the `new` functions defined\n"
"by each dict type:\n"
"\n"
"    HashDict.new  #=> creates an empty HashDict\n"
"\n"
"In the examples below, `dict_impl` means a specific\n"
"`Dict` implementation, for example `HashDict` or `Map`.\n"
"\n"
"## Protocols\n"
"\n"
"Besides implementing the functions in this module, all\n"
"dictionaries are required to implement the `Access`\n"
"protocol:\n"
"\n"
"    iex> dict = dict_impl.new\n"
"    iex> dict = Dict.put(dict, :hello, :world)\n"
"    iex> dict[:hello]\n"
"    :world\n"
"\n"
"As well as the `Enumerable` and `Collectable` protocols.\n"
"\n"
"## Match\n"
"\n"
"Dictionaries are required to implement all operations\n"
"using the match (`===`) operator.\n"
"\n"
"## Default implementation\n"
"\n"
"Default implementations for some functions in the `Dict` module\n"
"are provided via `use Dict`.\n"
"\n"
"For example:\n"
"\n"
"    defmodule MyDict do\n"
"      use Dict\n"
"\n"
"      # implement required functions (see below)\n"
"      # override default implementations if optimization\n"
"      # is needed\n"
"    end\n"
"\n"
"The client module must contain the following functions:\n"
"\n"
"  * `delete/2`\n"
"  * `fetch/2`\n"
"  * `put/3`\n"
"  * `reduce/3`\n"
"  * `size/1`\n"
"\n"
"All functions, except `reduce/3`, are required by the Dict behaviour.\n"
"`reduce/3` must be implemented as per the Enumerable protocol.\n"
"\n"
"Based on these functions, `Dict` generates default implementations\n"
"for the following functions:\n"
"\n"
"  * `drop/2`\n"
"  * `equal?/2`\n"
"  * `fetch!/2`\n"
"  * `get/2`\n"
"  * `get/3`\n"
"  * `has_key?/2`\n"
"  * `keys/1`\n"
"  * `merge/2`\n"
"  * `merge/3`\n"
"  * `pop/2`\n"
"  * `pop/3`\n"
"  * `put_new/3`\n"
"  * `split/2`\n"
"  * `take/2`\n"
"  * `to_list/1`\n"
"  * `update/4`\n"
"  * `update!/3`\n"
"  * `values/1`\n"
"\n"
"All of these functions are defined as overridable, so you can provide\n"
"your own implementation if needed.\n"
"\n"
"Note you can also test your custom module via `Dict`'s doctests:\n"
"\n"
"    defmodule MyDict do\n"
"      # ...\n"
"    end\n"
"\n"
"    defmodule MyTests do\n"
"      use ExUnit.Case\n"
"      doctest Dict\n"
"      defp dict_impl, do: MyDict\n"
"    end\n"
"\n"
msgstr ""
"このモジュールは異った辞書による実装に期待されるべき、Dict API仕様を\n"
"指定します。\n"
"\n"
"一つのAPIを使って異るDictの実装で開発者が仕事をすることを許す、基礎をな\n"
"すDictへリダイレクトする関数も提供します。\n"
"\n"
"新しいDictを作成するために、それぞれのDictのタイプ毎に定義された`new`関\n"
"数を使います:\n"
"\n"
"    HashDict.new  #=> creates an empty HashDict\n"
"\n"
"下の例では、`dict_impl`は特定の`Dict`実装、例えば`HashDict` または\n"
"`Map`を意味します。\n"
"\n"
"## プロトコル\n"
"\n"
"このモジュールで実装している関数の他に、全ての辞書は\n"
"`Access`プロトコルを実装することが要求されます:\n"
"\n"
"    iex> dict = dict_impl.new\n"
"    iex> dict = Dict.put(dict, :hello, :world)\n"
"    iex> dict[:hello]\n"
"    :world\n"
"\n"
"`Enumerable`と`Collectable`プロトコルの実装も同様です。\n"
"\n"
"## マッチ\n"
"\n"
"Dictは実装をマッチオペレータ(`===`)を使う全ての操作の実装を\n"
"要求します。\n"
"\n"
"## デフォルトの実装\n"
"\n"
"`Dict`モジュールの幾つかの関数でのデフォルトの実装は`use Dict`により\n"
"提供されます。\n"
"\n"
"例えば:\n"
"\n"
"    defmodule MyDict do\n"
"      use Dict\n"
"\n"
"      # 要求された関数(下記参照)の実装をします\n"
"      # 最適化が必要ならデフォルトの実装を\n"
"      # オーバーライドします\n"
"    end\n"
"\n"
"クライアントモジュールは以下の関数を含んでいなければなりません:\n"
"\n"
"  * `delete/2`\n"
"  * `fetch/2`\n"
"  * `put/3`\n"
"  * `reduce/3`\n"
"  * `size/1`\n"
"\n"
"`reduce/3`を除く全ての関数はDictビヘイビアにより要求されます。\n"
"`reduce/3`はEnumerableプロトコルにより実装されなければなりません。\n"
"\n"
"これらの関数の基いて、`Dict`は以下の関数のデフォルトの実装を生成します:\n"
"\n"
"  * `drop/2`\n"
"  * `equal?/2`\n"
"  * `fetch!/2`\n"
"  * `get/2`\n"
"  * `get/3`\n"
"  * `has_key?/2`\n"
"  * `keys/1`\n"
"  * `merge/2`\n"
"  * `merge/3`\n"
"  * `pop/2`\n"
"  * `pop/3`\n"
"  * `put_new/3`\n"
"  * `split/2`\n"
"  * `take/2`\n"
"  * `to_list/1`\n"
"  * `update/4`\n"
"  * `update!/3`\n"
"  * `values/1`\n"
"\n"
"これらの関数の全てはオーバーライド可能に定義されていますので、\n"
"必要に応じて自分で実装を提供することができます。\n"
"\n"
"`Dict`のdoctestによりカスタムモジュールをテストすることもできる\n"
"ことに注意してください:\n"
"\n"
"    defmodule MyDict do\n"
"      # ...\n"
"    end\n"
"\n"
"    defmodule MyTests do\n"
"      use ExUnit.Case\n"
"      doctest Dict\n"
"      defp dict_impl, do: MyDict\n"
"    end\n"
"\n"

#. TRANSLATORS: Elixir.Module Summary
#: lib/module.ex:1
msgid ""
"This module provides many functions to deal with modules during\n"
"compilation time. It allows a developer to dynamically attach\n"
"documentation, add, delete and register attributes and so forth.\n"
"\n"
"After a module is compiled, using many of the functions in\n"
"this module will raise errors, since it is out of their scope\n"
"to inspect runtime data. Most of the runtime data can be inspected\n"
"via the `__info__(attr)` function attached to each compiled module.\n"
"\n"
"## Module attributes\n"
"\n"
"Each module can be decorated with one or more attributes. The following "
"ones\n"
"are currently defined by Elixir:\n"
"\n"
"  * `@after_compile`\n"
"\n"
"    A hook that will be invoked right after the current module is compiled.\n"
"\n"
"    Accepts a module or a tuple `{<module>, <function atom>}`. The function\n"
"    must take two arguments: the module environment and its bytecode.\n"
"    When just a module is provided, the function is assumed to be\n"
"    `__after_compile__/2`.\n"
"\n"
"    ### Example\n"
"\n"
"        defmodule M do\n"
"          @after_compile __MODULE__\n"
"\n"
"          def __after_compile__(env, _bytecode) do\n"
"            IO.inspect env\n"
"          end\n"
"        end\n"
"\n"
"  * `@before_compile`\n"
"\n"
"    A hook that will be invoked before the module is compiled.\n"
"\n"
"    Accepts a module or a tuple `{<module>, <function/macro atom>}`. The\n"
"    function/macro must take one argument: the module environment. If it's "
"a\n"
"    macro, its returned value will be injected at the end of the module "
"definition\n"
"    before the compilation starts.\n"
"\n"
"    When just a module is provided, the function/macro is assumed to be\n"
"    `__before_compile__/1`.\n"
"\n"
"    Note: unlike `@after_compile`, the callback function/macro must\n"
"    be placed in a separate module (because when the callback is invoked,\n"
"    the current module does not yet exist).\n"
"\n"
"    ### Example\n"
"\n"
"        defmodule A do\n"
"          defmacro __before_compile__(_env) do\n"
"            quote do\n"
"              def hello, do: \"world\"\n"
"            end\n"
"          end\n"
"        end\n"
"\n"
"        defmodule B do\n"
"          @before_compile A\n"
"        end\n"
"\n"
"  * `@behaviour`   (notice the British spelling)\n"
"\n"
"    Specifies an OTP or user-defined behaviour.\n"
"\n"
"    ### Example\n"
"\n"
"        defmodule M do\n"
"          @behaviour gen_event\n"
"\n"
"          # ...\n"
"        end\n"
"\n"
"  * `@compile`\n"
"\n"
"    Defines options for module compilation that are passed to the Erlang\n"
"    compiler.\n"
"\n"
"    Accepts an atom, a tuple, or a list of atoms and tuples.\n"
"\n"
"    See http://www.erlang.org/doc/man/compile.html for the list of "
"supported\n"
"    options.\n"
"\n"
"    Several uses of `@compile` will accumulate instead of overriding\n"
"    previous ones.\n"
"\n"
"    ### Example\n"
"\n"
"          defmodule M do\n"
"            @compile {:inline, myfun: 1}\n"
"\n"
"            def myfun(arg) do\n"
"              to_string(arg)\n"
"            end\n"
"          end\n"
"\n"
"  * `@doc`\n"
"\n"
"    Provides documentation for the function or macro that follows the\n"
"    attribute.\n"
"\n"
"    Accepts a string (often a heredoc) or `false` where `@doc false` will\n"
"    make the function/macro invisible to the documentation extraction tools\n"
"    like ExDoc.\n"
"\n"
"    Can be invoked more than once.\n"
"\n"
"    ### Example\n"
"\n"
"          defmodule M do\n"
"            @doc \"Hello world\"\n"
"            def hello do\n"
"              \"world\"\n"
"            end\n"
"\n"
"            @doc \"\"\"\n"
"            Sum.\n"
"            \"\"\"\n"
"            def sum(a, b) do\n"
"              a + b\n"
"            end\n"
"          end\n"
"\n"
"  * `@file`\n"
"\n"
"    Changes the filename used in stacktraces for the function or macro that\n"
"    follows the attribute.\n"
"\n"
"    Accepts a string. Can be used more than once.\n"
"\n"
"    ### Example\n"
"\n"
"          defmodule M do\n"
"            @doc \"Hello world\"\n"
"            @file \"hello.ex\"\n"
"            def hello do\n"
"              \"world\"\n"
"            end\n"
"          end\n"
"\n"
"  * `@moduledoc`\n"
"\n"
"    Provides documentation for the current module.\n"
"\n"
"    Accepts a string (which is often a heredoc) or `false` where\n"
"    `@moduledoc false` will make the module invisible to the\n"
"    documentation extraction tools like ExDoc.\n"
"\n"
"    ### Example\n"
"\n"
"          defmodule M do\n"
"            @moduledoc \"\"\"\n"
"            A very useful module\n"
"            \"\"\"\n"
"          end\n"
"\n"
"\n"
"  * `@on_definition`\n"
"\n"
"    A hook that will be invoked when each function or macro in the current\n"
"    module is defined. Useful when annotating functions.\n"
"\n"
"    Accepts a module or a tuple `{<module>, <function atom>}`. The function\n"
"    must take 6 arguments:\n"
"\n"
"      - the module environment\n"
"      - kind: `:def`, `:defp`, `:defmacro`, or `:defmacrop`\n"
"      - function/macro name\n"
"      - list of expanded arguments\n"
"      - list of expanded guards\n"
"      - expanded function body\n"
"\n"
"    Note the hook receives the expanded arguments and it is invoked before\n"
"    the function is stored in the module. So `Module.defines?/2` will "
"return\n"
"    false for the first clause of every function.\n"
"\n"
"    If the function/macro being defined has multiple clauses, the hook will\n"
"    be called for each clause.\n"
"\n"
"    Unlike other hooks, `@on_definition` will only invoke functions\n"
"    and never macros. This is because the hook is invoked inside the "
"context\n"
"    of the function (and nested function definitions are not allowed in\n"
"    Elixir).\n"
"\n"
"    When just a module is provided, the function is assumed to be\n"
"    `__on_definition__/6`.\n"
"\n"
"    ### Example\n"
"\n"
"          defmodule H do\n"
"            def on_def(_env, kind, name, args, guards, body) do\n"
"              IO.puts \"Defining #{kind} named #{name} with args:\"\n"
"              IO.inspect args\n"
"              IO.puts \"and guards\"\n"
"              IO.inspect guards\n"
"              IO.puts \"and body\"\n"
"              IO.puts Macro.to_string(body)\n"
"            end\n"
"          end\n"
"\n"
"          defmodule M do\n"
"            @on_definition {H, :on_def}\n"
"\n"
"            def hello(arg) when is_binary(arg) or is_list(arg) do\n"
"              \"Hello\" <> to_string(arg)\n"
"            end\n"
"\n"
"            def hello(_) do\n"
"              :ok\n"
"            end\n"
"          end\n"
"\n"
"  * `@on_load`\n"
"\n"
"    A hook that will be invoked whenever the module is loaded.\n"
"\n"
"    Accepts a function atom of a function in the current module. The "
"function\n"
"    must have arity 0 (no arguments) and has to return `:ok`, otherwise the\n"
"    loading of the module will be aborted.\n"
"\n"
"    ### Example\n"
"\n"
"          defmodule M do\n"
"            @on_load :load_check\n"
"\n"
"            def load_check do\n"
"              if some_condition() do\n"
"                :ok\n"
"              else\n"
"                nil\n"
"              end\n"
"            end\n"
"\n"
"            def some_condition do\n"
"              false\n"
"            end\n"
"          end\n"
"\n"
"  * `@vsn`\n"
"\n"
"    Specify the module version. Accepts any valid Elixir value.\n"
"\n"
"    ### Example\n"
"\n"
"          defmodule M do\n"
"            @vsn \"1.0\"\n"
"          end\n"
"\n"
"  * `@external_resource`\n"
"\n"
"    Specifies an external resource to the current module.\n"
"\n"
"    Many times a module embeds information from an external file. This\n"
"    attribute allows the module to annotate which external resources\n"
"    have been used.\n"
"\n"
"    Tools like Mix may use this information to ensure the module is\n"
"    recompiled in case any of the external resources change.\n"
"\n"
"The following attributes are part of typespecs and are also reserved by\n"
"Elixir (see `Kernel.Typespec` for more information about typespecs):\n"
"\n"
"  * `@type`        - defines a type to be used in `@spec`\n"
"  * `@typep`       - defines a private type to be used in `@spec`\n"
"  * `@opaque`      - defines an opaque type to be used in `@spec`\n"
"  * `@spec`        - provides a specification for a function\n"
"  * `@callback`    - provides a specification for the behaviour callback\n"
"\n"
"In addition to the built-in attributes outlined above, custom attributes "
"may\n"
"also be added. A custom attribute is any valid identifier prefixed with an\n"
"`@` and followed by a valid Elixir value:\n"
"\n"
"      defmodule M do\n"
"        @custom_attr [some: \"stuff\"]\n"
"      end\n"
"\n"
"For more advanced options available when defining custom attributes, see\n"
"`register_attribute/3`.\n"
"\n"
"## Runtime information about a module\n"
"\n"
"It is possible to query a module at runtime to find out which functions and\n"
"macros it defines, extract its docstrings, etc. See `__info__/1`.\n"
msgstr ""
"このモジュールはコンパイル時にモジュールを取り扱う多くの関数を提供しま\n"
"す。それらは、開発者に動的にドキュメントを添付したり、アトリビュートや\n"
"その他を追加、削除、登録することを許可します。\n"
"\n"
"モジュールがコンパイルされた後では、実行時データを調べるそれらのスコー\n"
"プの外にあるため、このモジュールの関数の多くは利用すると、エラーを上げ\n"
"ます。多くの実行時データはそれぞれコンパイルされたモジュールにアタッチ\n"
"された`__info__(attr)`関数により調べることができます。\n"
"\n"
"## モジュールアトリビュート\n"
"\n"
"それぞののモジュールは一つ以上のアトリビュートで装飾することができます。\n"
"以下は現在のElixirで定義されているものです:\n"
"\n"
"  * `@after_compile`\n"
"\n"
"    カレントモジュールがコンパイルされた直後に実行されるフックです。\n"
"\n"
"    モジュールまたは、`{<module>, <function atom>}`タプルを受け付けます。\n"
"    functionは二つの引数をとらなければなりません: モジュールの環境と\n"
"    バイトコードです。\n"
"    引数としてモジュールのみが提供されたとき、その関数は\n"
"     `__after_compile__/2`であるとされます。\n"
"\n"
"    ### 例\n"
"\n"
"        defmodule M do\n"
"          @after_compile __MODULE__\n"
"\n"
"          def __after_compile__(env, _bytecode) do\n"
"            IO.inspect env\n"
"          end\n"
"        end\n"
"\n"
"  * `@before_compile`\n"
"\n"
"    モジュールがコンパイルされる前に実行されるフックです。\n"
"\n"
"    モジュールまたは、`{<module>, <function/macro atom>}`タプルを受け\n"
"    付けます。そのfunction/macroは一つの引数をとらなければなりません: \n"
"    モジュールの環境です。もしマクロであるならば、その戻値がコンパイルが\n"
"    初まる前にモジュール定義の最後に差し込まれます。\n"
"\n"
"    引数としてモジュールが提供されたとき、その関数/マクロは\n"
"     `__before_compile__/1`であるとされます。\n"
"\n"
"    注: `@after_compile`と異なり、コールバック関数/マクロは\n"
"    別のモジュールに置かれなければなりません(何故なら、\n"
"    コールバックが実行されるとき、カレントモジュールはまだ存在して\n"
"    いないからです)。\n"
"\n"
"    ### 例\n"
"\n"
"        defmodule A do\n"
"          defmacro __before_compile__(_env) do\n"
"            quote do\n"
"              def hello, do: \"world\"\n"
"            end\n"
"          end\n"
"        end\n"
"\n"
"        defmodule B do\n"
"          @before_compile A\n"
"        end\n"
"\n"
"  * `@behaviour`   (英式綴であることに注意してください)\n"
"\n"
"    OTPまたはユーザ定義のビヘイビアを指定します。\n"
"\n"
"    ### 例\n"
"\n"
"        defmodule M do\n"
"          @behaviour gen_event\n"
"\n"
"          # ...\n"
"        end\n"
"\n"
"  * `@compile`\n"
"\n"
"    モジュールのErlangコンパイラに渡されるコンパイルオプションを定義しま"
"す。\n"
"\n"
"    アトム、タプルあるいはアトムやタプルのリストを受け付けます。\n"
"\n"
"    サポートされるオプションのリストについては\n"
"    http://www.erlang.org/doc/man/compile.html\n"
"    を参照してください。\n"
"\n"
"    '@compile`を何度か使うと、前のものを上書きするかわりに、\n"
"    累積します。\n"
"\n"
"    ### 例\n"
"\n"
"          defmodule M do\n"
"            @compile {:inline, myfun: 1}\n"
"\n"
"            def myfun(arg) do\n"
"              to_string(arg)\n"
"            end\n"
"          end\n"
"\n"
"  * `@doc`\n"
"\n"
"    アトリビュートの後の関数またはマクロへのドキュメントを提供します。\n"
"\n"
"    文字列(しばしばヒアドキュメントです)または、`false`を受け付けます。\n"
"    `@doc false`とした関数/マクロはExDocの様なドキュメント抽出ツールに\n"
"    より非表示にされるでしょう。\n"
"\n"
"    ひとつ以上記述することができます。\n"
"\n"
"    ### 例\n"
"\n"
"          defmodule M do\n"
"            @doc \"Hello world\"\n"
"            def hello do\n"
"              \"world\"\n"
"            end\n"
"\n"
"            @doc \"\"\"\n"
"            Sum.\n"
"            \"\"\"\n"
"            def sum(a, b) do\n"
"              a + b\n"
"            end\n"
"          end\n"
"\n"
"  * `@file`\n"
"\n"
"    アトリビュートの後の関数またはマクロについてのスタックトレースで\n"
"    使われるファイル名を変更します。\n"
"\n"
"    文字列を受け付けます。ひとつ以上使うことができます。\n"
"\n"
"    ### 例\n"
"\n"
"          defmodule M do\n"
"            @doc \"Hello world\"\n"
"            @file \"hello.ex\"\n"
"            def hello do\n"
"              \"world\"\n"
"            end\n"
"          end\n"
"\n"
"  * `@moduledoc`\n"
"\n"
"    カレントモジュールについてのドキュメントを提供します。\n"
"\n"
"    文字列(しばしばヒアドキュメントです)または、`false`を受け付けます。\n"
"    `@moduledoc false`としたモジュールはExDocの様なドキュメント抽出\n"
"    ツールにより非表示にされるでしょう。\n"
"\n"
"    ### 例\n"
"\n"
"          defmodule M do\n"
"            @moduledoc \"\"\"\n"
"            A very useful module\n"
"            \"\"\"\n"
"          end\n"
"\n"
"\n"
"  * `@on_definition`\n"
"\n"
"    カレントモジュールのそれぞれの関数あるいはマクロが定義されたれた時\n"
"    に実行されるフックです。関数に注をつけるときに役に立ちます。\n"
"\n"
"    モジュールあるいは、`{<module>, <function atom>}`タプルを受け付けます。\n"
"    関数は6個の引数を取らなければなりません: \n"
"\n"
"      - モジュールの環境\n"
"      - 種類: `:def`, `:defp`, `:defmacro`, あるいは `:defmacrop`\n"
"      - 関数/マクロの名前\n"
"      - 展開された引数のリスト\n"
"      - 展開されたガードのリスト\n"
"      - 展開された関数本体\n"
"\n"
"    フックは、関数がモジュールにストアされる前に実行され、\n"
"    展開された引数を受信することに注意してください。\n"
"    だから、`Module.defines?/2`はそれぞれの関数について最初の節の\n"
"    ためfalseで返るでしょう。\n"
"\n"
"    もし定義しようとしている関数/マクロが複数の節をもつなら、\n"
"    フックはそれぞれの節毎に呼ばれるでしょう。\n"
"\n"
"    他のフックと異なり、`@on_definition`はマクロでは決してなく、\n"
"    関数だけを実行します。これは、関数のコンテキストの内側で\n"
"    フックが実行されるからです(そしてElixirはネストした関数定義は\n"
"    許されていないのです)。\n"
"\n"
"    引数としてモジュールのみが提供されたとき、その関数は\n"
"    `__on_definition__/6` であるとされます。\n"
"\n"
"    ### 例\n"
"\n"
"          defmodule H do\n"
"            def on_def(_env, kind, name, args, guards, body) do\n"
"              IO.puts \"Defining #{kind} named #{name} with args:\"\n"
"              IO.inspect args\n"
"              IO.puts \"and guards\"\n"
"              IO.inspect guards\n"
"              IO.puts \"and body\"\n"
"              IO.puts Macro.to_string(body)\n"
"            end\n"
"          end\n"
"\n"
"          defmodule M do\n"
"            @on_definition {H, :on_def}\n"
"\n"
"            def hello(arg) when is_binary(arg) or is_list(arg) do\n"
"              \"Hello\" <> to_string(arg)\n"
"            end\n"
"\n"
"            def hello(_) do\n"
"              :ok\n"
"            end\n"
"          end\n"
"\n"
"  * `@on_load`\n"
"\n"
"    モジュールがロードされる時には何時でも実行されるフックです。    \n"
"\n"
"    カレントモジュール内の関数名を示すアトムを\n"
"    受け付けます。関数は、アリティ0(引数なし)で、`:ok`を返さなければ\n"
"    なりません。さもなくば、モジュールのローディングは中止されます。\n"
"\n"
"    ### 例\n"
"\n"
"          defmodule M do\n"
"            @on_load :load_check\n"
"\n"
"            def load_check do\n"
"              if some_condition() do\n"
"                :ok\n"
"              else\n"
"                nil\n"
"              end\n"
"            end\n"
"\n"
"            def some_condition do\n"
"              false\n"
"            end\n"
"          end\n"
"\n"
"  * `@vsn`\n"
"\n"
"    モジュールのバージョンを指定します。任意の正しいElixirの値を\n"
"    受け付けます。\n"
"\n"
"    ### 例\n"
"\n"
"          defmodule M do\n"
"            @vsn \"1.0\"\n"
"          end\n"
"\n"
"  * `@external_resource`\n"
"\n"
"    カレントモジュールに外部リソースを指定します。\n"
"\n"
"    しばしば、モジュールは外部から情報を埋め込みます。\n"
"    このアトリビュートはモジュールにどの外部リソースが使われたかに\n"
"    ついて注釈を付けることを許可します。\n"
"\n"
"    Mixの様なツールはこの情報を、外部リソースが変更された場合に\n"
"    モジュールが再コンパイルされることを確実にするために、使うかも\n"
"    しれません。\n"
"\n"
"以下のアトリビュートはtypespecの一部で、Elixirにより予約されています\n"
"(typespecについての詳細は`Kernel.Typespec`を参照してください):\n"
"\n"
"  * `@type`        - `@spec` でタイプの定義に使われます。\n"
"  * `@typep`       - `@spec`でプライベートタイプの定義に使われます。\n"
"  * `@opaque`      - `@spec`不透明なタイプの定義に使われます。\n"
"  * `@spec`        - 関数のspecを提供します。\n"
"  * `@callback`    - ビヘイビアコールバックのspecを提供します。\n"
"\n"
"上で概説されたビルトインのアトリビュートに加えて、カスタムアトリビュートも\n"
"追加できます。カスタムアトリビュートは`@`が前についた有効な識別子なら\n"
"なんてもよく、後ろにElixirの値がつきます:\n"
"\n"
"      defmodule M do\n"
"        @custom_attr [some: \"stuff\"]\n"
"      end\n"
"\n"
"カスタムアトリビュートの定義時のより進んだオプションについては\n"
"`register_attribute/3`を参照してください。\n"
"\n"
"## モジュールについての実行時情報\n"
"\n"
"どの関数やマクロが定義を見付けるため、あるいはドキュメント\n"
"文字列を抽出するために、実行時にモジュールに問合せることが可能です。\n"
"`__info__/1`を参照してください。\n"

#. TRANSLATORS: Elixir.Bitwise Summary
#: lib/bitwise.ex:1
msgid ""
"This module provides macros and operators for bitwise operators.\n"
"These macros can be used in guards.\n"
"\n"
"The easiest way to use is to simply import them into\n"
"your module:\n"
"\n"
"    iex> use Bitwise\n"
"    iex> bnot 1\n"
"    -2\n"
"    iex> 1 &&& 1\n"
"    1\n"
"\n"
"You can select to include only or skip operators by passing options:\n"
"\n"
"    iex> use Bitwise, only_operators: true\n"
"    iex> 1 &&& 1\n"
"    1\n"
"\n"
msgstr ""
"このモジュールはビット毎演算のためのマクロと演算子を提供します。\n"
"これらのマクロはガードで使うことができます。\n"
"\n"
"使うための最も簡単な方法は、単にあなたのモジュールにインポートすること\n"
"です:\n"
"\n"
"    iex> use Bitwise\n"
"    iex> bnot 1\n"
"    -2\n"
"    iex> 1 &&& 1\n"
"    1\n"
"\n"
"only_operatorsまたはskip_operatorsオプションを渡して演算子を\n"
"含むかスキップするか選択することが出来ます:\n"
"\n"
"    iex> use Bitwise, only_operators: true\n"
"    iex> 1 &&& 1\n"
"    1\n"
"\n"

#. TRANSLATORS: Elixir.Base Summary
#: lib/base.ex:1
msgid ""
"This module provides data encoding and decoding functions\n"
"according to [RFC 4648](http://tools.ietf.org/html/rfc4648).\n"
"\n"
"This document defines the commonly used base 16, base 32, and base\n"
"64 encoding schemes.\n"
"\n"
"## Base 16 alphabet\n"
"\n"
"    | Value | Encoding | Value | Encoding | Value | Encoding | Value | "
"Encoding |\n"
"    |------:|---------:|------:|---------:|------:|---------:|------:|---------:|\n"
"    |      0|         0|      4|         4|      8|         8|     "
"12|         C|\n"
"    |      1|         1|      5|         5|      9|         9|     "
"13|         D|\n"
"    |      2|         2|      6|         6|     10|         A|     "
"14|         E|\n"
"    |      3|         3|      7|         7|     11|         B|     "
"15|         F|\n"
"\n"
"## Base 32 alphabet\n"
"\n"
"    | Value | Encoding | Value | Encoding | Value | Encoding | Value | "
"Encoding |\n"
"    |------:|---------:|------:|---------:|------:|---------:|------:|---------:|\n"
"    |      0|         A|      9|         J|     18|         S|     "
"27|         3|\n"
"    |      1|         B|     10|         K|     19|         T|     "
"28|         4|\n"
"    |      2|         C|     11|         L|     20|         U|     "
"29|         5|\n"
"    |      3|         D|     12|         M|     21|         V|     "
"30|         6|\n"
"    |      4|         E|     13|         N|     22|         W|     "
"31|         7|\n"
"    |      5|         F|     14|         O|     23|         X|       "
"|          |\n"
"    |      6|         G|     15|         P|     24|         Y|  "
"(pad)|         =|\n"
"    |      7|         H|     16|         Q|     25|         Z|       "
"|          |\n"
"    |      8|         I|     17|         R|     26|         2|       "
"|          |\n"
"\n"
"\n"
"## Base 32 (extended hex) alphabet\n"
"\n"
"    | Value | Encoding | Value | Encoding | Value | Encoding | Value | "
"Encoding |\n"
"    |------:|---------:|------:|---------:|------:|---------:|------:|---------:|\n"
"    |      0|         0|      9|         9|     18|         I|     "
"27|         R|\n"
"    |      1|         1|     10|         A|     19|         J|     "
"28|         S|\n"
"    |      2|         2|     11|         B|     20|         K|     "
"29|         T|\n"
"    |      3|         3|     12|         C|     21|         L|     "
"30|         U|\n"
"    |      4|         4|     13|         D|     22|         M|     "
"31|         V|\n"
"    |      5|         5|     14|         E|     23|         N|       "
"|          |\n"
"    |      6|         6|     15|         F|     24|         O|  "
"(pad)|         =|\n"
"    |      7|         7|     16|         G|     25|         P|       "
"|          |\n"
"    |      8|         8|     17|         H|     26|         Q|       "
"|          |\n"
"\n"
"## Base 64 alphabet\n"
"\n"
"    | Value | Encoding | Value | Encoding | Value | Encoding | Value | "
"Encoding |\n"
"    |------:|---------:|------:|---------:|------:|---------:|------:|---------:|\n"
"    |      0|         A|     17|         R|     34|         i|     "
"51|         z|\n"
"    |      1|         B|     18|         S|     35|         j|     "
"52|         0|\n"
"    |      2|         C|     19|         T|     36|         k|     "
"53|         1|\n"
"    |      3|         D|     20|         U|     37|         l|     "
"54|         2|\n"
"    |      4|         E|     21|         V|     38|         m|     "
"55|         3|\n"
"    |      5|         F|     22|         W|     39|         n|     "
"56|         4|\n"
"    |      6|         G|     23|         X|     40|         o|     "
"57|         5|\n"
"    |      7|         H|     24|         Y|     41|         p|     "
"58|         6|\n"
"    |      8|         I|     25|         Z|     42|         q|     "
"59|         7|\n"
"    |      9|         J|     26|         a|     43|         r|     "
"60|         8|\n"
"    |     10|         K|     27|         b|     44|         s|     "
"61|         9|\n"
"    |     11|         L|     28|         c|     45|         t|     "
"62|         +|\n"
"    |     12|         M|     29|         d|     46|         u|     "
"63|         /|\n"
"    |     13|         N|     30|         e|     47|         v|       "
"|          |\n"
"    |     14|         O|     31|         f|     48|         w|  "
"(pad)|         =|\n"
"    |     15|         P|     32|         g|     49|         x|       "
"|          |\n"
"    |     16|         Q|     33|         h|     50|         y|       "
"|          |\n"
"\n"
"## Base 64 (URL and filename safe) alphabet\n"
"\n"
"    | Value | Encoding | Value | Encoding | Value | Encoding | Value | "
"Encoding |\n"
"    |------:|---------:|------:|---------:|------:|---------:|------:|---------:|\n"
"    |      0|         A|     17|         R|     34|         i|     "
"51|         z|\n"
"    |      1|         B|     18|         S|     35|         j|     "
"52|         0|\n"
"    |      2|         C|     19|         T|     36|         k|     "
"53|         1|\n"
"    |      3|         D|     20|         U|     37|         l|     "
"54|         2|\n"
"    |      4|         E|     21|         V|     38|         m|     "
"55|         3|\n"
"    |      5|         F|     22|         W|     39|         n|     "
"56|         4|\n"
"    |      6|         G|     23|         X|     40|         o|     "
"57|         5|\n"
"    |      7|         H|     24|         Y|     41|         p|     "
"58|         6|\n"
"    |      8|         I|     25|         Z|     42|         q|     "
"59|         7|\n"
"    |      9|         J|     26|         a|     43|         r|     "
"60|         8|\n"
"    |     10|         K|     27|         b|     44|         s|     "
"61|         9|\n"
"    |     11|         L|     28|         c|     45|         t|     "
"62|         -|\n"
"    |     12|         M|     29|         d|     46|         u|     "
"63|         _|\n"
"    |     13|         N|     30|         e|     47|         v|       "
"|          |\n"
"    |     14|         O|     31|         f|     48|         w|  "
"(pad)|         =|\n"
"    |     15|         P|     32|         g|     49|         x|       "
"|          |\n"
"    |     16|         Q|     33|         h|     50|         y|       "
"|          |\n"
"\n"
msgstr ""
"このモジュールは、[RFC 4648](http://tools.ietf.org/html/rfc4648) に\n"
"準拠した、データエンコードとデコード関数を提供します。\n"
"\n"
"このドキュメントは一般的に用いられる base 16, base 32 そして\n"
"base 64エンコーディングスキームを定めます。\n"
"\n"
"## Base 16 アルファベット\n"
"\n"
"    | Value | Encoding | Value | Encoding | Value | Encoding | Value | "
"Encoding |\n"
"    |------:|---------:|------:|---------:|------:|---------:|------:|---------:|\n"
"    |      0|         0|      4|         4|      8|         8|     "
"12|         C|\n"
"    |      1|         1|      5|         5|      9|         9|     "
"13|         D|\n"
"    |      2|         2|      6|         6|     10|         A|     "
"14|         E|\n"
"    |      3|         3|      7|         7|     11|         B|     "
"15|         F|\n"
"\n"
"## Base 32 アルファベット\n"
"\n"
"    | Value | Encoding | Value | Encoding | Value | Encoding | Value | "
"Encoding |\n"
"    |------:|---------:|------:|---------:|------:|---------:|------:|---------:|\n"
"    |      0|         A|      9|         J|     18|         S|     "
"27|         3|\n"
"    |      1|         B|     10|         K|     19|         T|     "
"28|         4|\n"
"    |      2|         C|     11|         L|     20|         U|     "
"29|         5|\n"
"    |      3|         D|     12|         M|     21|         V|     "
"30|         6|\n"
"    |      4|         E|     13|         N|     22|         W|     "
"31|         7|\n"
"    |      5|         F|     14|         O|     23|         X|       "
"|          |\n"
"    |      6|         G|     15|         P|     24|         Y|  "
"(pad)|         =|\n"
"    |      7|         H|     16|         Q|     25|         Z|       "
"|          |\n"
"    |      8|         I|     17|         R|     26|         2|       "
"|          |\n"
"\n"
"\n"
"## Base 32 (extended hex) アルファベット\n"
"\n"
"    | Value | Encoding | Value | Encoding | Value | Encoding | Value | "
"Encoding |\n"
"    |------:|---------:|------:|---------:|------:|---------:|------:|---------:|\n"
"    |      0|         0|      9|         9|     18|         I|     "
"27|         R|\n"
"    |      1|         1|     10|         A|     19|         J|     "
"28|         S|\n"
"    |      2|         2|     11|         B|     20|         K|     "
"29|         T|\n"
"    |      3|         3|     12|         C|     21|         L|     "
"30|         U|\n"
"    |      4|         4|     13|         D|     22|         M|     "
"31|         V|\n"
"    |      5|         5|     14|         E|     23|         N|       "
"|          |\n"
"    |      6|         6|     15|         F|     24|         O|  "
"(pad)|         =|\n"
"    |      7|         7|     16|         G|     25|         P|       "
"|          |\n"
"    |      8|         8|     17|         H|     26|         Q|       "
"|          |\n"
"\n"
"## Base 64 アルファベット\n"
"\n"
"    | Value | Encoding | Value | Encoding | Value | Encoding | Value | "
"Encoding |\n"
"    |------:|---------:|------:|---------:|------:|---------:|------:|---------:|\n"
"    |      0|         A|     17|         R|     34|         i|     "
"51|         z|\n"
"    |      1|         B|     18|         S|     35|         j|     "
"52|         0|\n"
"    |      2|         C|     19|         T|     36|         k|     "
"53|         1|\n"
"    |      3|         D|     20|         U|     37|         l|     "
"54|         2|\n"
"    |      4|         E|     21|         V|     38|         m|     "
"55|         3|\n"
"    |      5|         F|     22|         W|     39|         n|     "
"56|         4|\n"
"    |      6|         G|     23|         X|     40|         o|     "
"57|         5|\n"
"    |      7|         H|     24|         Y|     41|         p|     "
"58|         6|\n"
"    |      8|         I|     25|         Z|     42|         q|     "
"59|         7|\n"
"    |      9|         J|     26|         a|     43|         r|     "
"60|         8|\n"
"    |     10|         K|     27|         b|     44|         s|     "
"61|         9|\n"
"    |     11|         L|     28|         c|     45|         t|     "
"62|         +|\n"
"    |     12|         M|     29|         d|     46|         u|     "
"63|         /|\n"
"    |     13|         N|     30|         e|     47|         v|       "
"|          |\n"
"    |     14|         O|     31|         f|     48|         w|  "
"(pad)|         =|\n"
"    |     15|         P|     32|         g|     49|         x|       "
"|          |\n"
"    |     16|         Q|     33|         h|     50|         y|       "
"|          |\n"
"\n"
"## Base 64 (URL and filename safe) アルファベット\n"
"\n"
"    | Value | Encoding | Value | Encoding | Value | Encoding | Value | "
"Encoding |\n"
"    |------:|---------:|------:|---------:|------:|---------:|------:|---------:|\n"
"    |      0|         A|     17|         R|     34|         i|     "
"51|         z|\n"
"    |      1|         B|     18|         S|     35|         j|     "
"52|         0|\n"
"    |      2|         C|     19|         T|     36|         k|     "
"53|         1|\n"
"    |      3|         D|     20|         U|     37|         l|     "
"54|         2|\n"
"    |      4|         E|     21|         V|     38|         m|     "
"55|         3|\n"
"    |      5|         F|     22|         W|     39|         n|     "
"56|         4|\n"
"    |      6|         G|     23|         X|     40|         o|     "
"57|         5|\n"
"    |      7|         H|     24|         Y|     41|         p|     "
"58|         6|\n"
"    |      8|         I|     25|         Z|     42|         q|     "
"59|         7|\n"
"    |      9|         J|     26|         a|     43|         r|     "
"60|         8|\n"
"    |     10|         K|     27|         b|     44|         s|     "
"61|         9|\n"
"    |     11|         L|     28|         c|     45|         t|     "
"62|         -|\n"
"    |     12|         M|     29|         d|     46|         u|     "
"63|         _|\n"
"    |     13|         N|     30|         e|     47|         v|       "
"|          |\n"
"    |     14|         O|     31|         f|     48|         w|  "
"(pad)|         =|\n"
"    |     15|         P|     32|         g|     49|         x|       "
"|          |\n"
"    |     16|         Q|     33|         h|     50|         y|       "
"|          |\n"
"\n"

#. TRANSLATORS: Elixir.Path Summary
#: lib/path.ex:1
msgid ""
"This module provides conveniences for manipulating or\n"
"retrieving file system paths.\n"
"\n"
"The functions in this module may receive a char data as\n"
"argument (i.e. a string or a list of characters / string)\n"
"and will always return a string (encoded in UTF-8).\n"
"\n"
"The majority of the functions in this module do not\n"
"interact with the file system, except for a few functions\n"
"that require it (like `wildcard/1` and `expand/1`).\n"
msgstr ""
"このモジュールはファイルシステムパスを操作したり、\n"
"パスから要素を取り出したりするための便利な関数を提供します。\n"
"\n"
"このモジュールの関数は引数として文字データ(つまり、文字列あるいは文字/\n"
"文字列のリストです)を受け取ります。そして、常に(UTF-8でエンコードされ\n"
"た)文字列を返します。\n"
"\n"
"このモジュールの大部分の関数は、(`wildcard/1`と`expand/1`のような)どう\n"
"しても必要な少数の関数を除いては、ファイルシステムと相互作用しません。\n"

#. TRANSLATORS: Elixir.StringIO Summary
#: lib/string_io.ex:1
msgid ""
"This module provides an IO device that wraps a string.\n"
"\n"
"## Examples\n"
"\n"
"    iex> {:ok, pid} = StringIO.open(\"foo\")\n"
"    iex> IO.read(pid, 2)\n"
"    \"fo\"\n"
"\n"
msgstr ""
"このモジュールは文字列をIOデバイスにラップしたものを\n"
"提供します。\n"
"\n"
"## 例\n"
"\n"
"    iex> {:ok, pid} = StringIO.open(\"foo\")\n"
"    iex> IO.read(pid, 2)\n"
"    \"fo\"\n"
"\n"

#. TRANSLATORS: Elixir.OptionParser Summary
#: lib/option_parser.ex:1
msgid "This module contains functions to parse command line arguments.\n"
msgstr "このモジュールはコマンドライン引数をパースするための関数を含みます。\n"

#. TRANSLATORS: Elixir.File Summary
#: lib/file.ex:1
msgid ""
"This module contains functions to manipulate files.\n"
"\n"
"Some of those functions are low-level, allowing the user\n"
"to interact with the file or IO devices, like `open/2`,\n"
"`copy/3` and others. This module also provides higher\n"
"level functions that work with filenames and have their naming\n"
"based on UNIX variants. For example, one can copy a file\n"
"via `cp/3` and remove files and directories recursively\n"
"via `rm_rf/1`\n"
"\n"
"## Encoding\n"
"\n"
"In order to write and read files, one must use the functions\n"
"in the `IO` module. By default, a file is opened in binary mode\n"
"which requires the functions `IO.binread/2` and `IO.binwrite/2`\n"
"to interact with the file. A developer may pass `:utf8` as an\n"
"option when opening the file, then the slower `IO.read/2` and\n"
"`IO.write/2` functions must be used as they are responsible for\n"
"doing the proper conversions and data guarantees.\n"
"\n"
"Note that filenames when given as char lists in Elixir are\n"
"always treated as UTF-8. In particular, we expect that the\n"
"shell and the operating system are configured to use UTF8\n"
"encoding. Binary filenames are considering raw and passed\n"
"to the OS as is.\n"
"\n"
"## API\n"
"\n"
"Most of the functions in this module return `:ok` or\n"
"`{:ok, result}` in case of success, `{:error, reason}`\n"
"otherwise. Those function are also followed by a variant\n"
"that ends with `!` which returns the result (without the\n"
"`{:ok, result}` tuple) in case of success or raises an\n"
"exception in case it fails. For example:\n"
"\n"
"    File.read(\"hello.txt\")\n"
"    #=> {:ok, \"World\"}\n"
"\n"
"    File.read(\"invalid.txt\")\n"
"    #=> {:error, :enoent}\n"
"\n"
"    File.read!(\"hello.txt\")\n"
"    #=> \"World\"\n"
"\n"
"    File.read!(\"invalid.txt\")\n"
"    #=> raises File.Error\n"
"\n"
"In general, a developer should use the former in case they want\n"
"to react if the file does not exist. The latter should be used\n"
"when the developer expects their software to fail in case the\n"
"file cannot be read (i.e. it is literally an exception).\n"
"\n"
"## Processes and raw files\n"
"\n"
"Every time a file is opened, Elixir spawns a new process. Writing\n"
"to a file is equivalent to sending messages to that process that\n"
"writes to the file descriptor.\n"
"\n"
"This means files can be passed between nodes and message passing\n"
"guarantees they can write to the same file in a network.\n"
"\n"
"However, you may not always want to pay the price for this abstraction.\n"
"In such cases, a file can be opened in `:raw` mode. The options `:"
"read_ahead`\n"
"and `:delayed_write` are also useful when operating large files or\n"
"working with files in tight loops.\n"
"\n"
"Check http://www.erlang.org/doc/man/file.html#open-2 for more information\n"
"about such options and other performance considerations.\n"
msgstr ""
"このモジュールはファイルを操作するための関数を含みます。\n"
"\n"
"それらの関数の幾つかは`open/2`, `copy/3`やその他のように、低レベルでファ\n"
"イルあるいはIOデバイスと相互作用することを許します。このモジュールはファ\n"
"イル名とともに動作し、UNIX族に基いた命名の高レベルの関数も提供します。\n"
"例えば、`cp/3`によりファイルのコピーができ、`rm_rf/1`により再帰的に\n"
"ファイルとディレクトリを削除できます。\n"
"\n"
"## エンコーディング\n"
"\n"
"ファイルを読み書きするために、`IO`モジュールの関数を使わなければなりま\n"
"せん。デフォルトではファイルは相互作用するために`IO.binread/2`と\n"
"`IO.binwrite/2`を必要とするバイナリモードでオープンされます。開発者はファ\n"
"イルをオープンするときに、適当な変換とデータの保証の役割をより遅い\n"
"`IO.read/2`と`IO.write/2`に負わせるために、オプションとして`:utf8`を付\n"
"けるかもしれません。\n"
"\n"
"Elixirで文字のリストとして与えられたファイル名は、常にUTF-8として\n"
"扱われることに注意してください。特に、シェルとオペレーティングシステムが\n"
"UTF8エンコーディングを使用するように構成されていると仮定しています。\n"
"バイナリのファイル名はrawであるとみなしてOSへそのままパスされます。\n"
"\n"
"## API\n"
"\n"
"このモジュールのほとんどの関数は成功時に`:ok`あるいは、`{:ok,\n"
"result}`を返し、さもなくば`{:error, reason}`を返します。それらの関数の\n"
"後ろに`!`が付くバージョンもあり、それらは、成功時(`{:ok, result}`タプル\n"
"なしで)resultを返し、失敗時に例外を上げます。\n"
"例えば:\n"
"\n"
"    File.read(\"hello.txt\")\n"
"    #=> {:ok, \"World\"}\n"
"\n"
"    File.read(\"invalid.txt\")\n"
"    #=> {:error, :enoent}\n"
"\n"
"    File.read!(\"hello.txt\")\n"
"    #=> \"World\"\n"
"\n"
"    File.read!(\"invalid.txt\")\n"
"    #=> raises File.Error\n"
"\n"
"一般に、開発者はファイルが存在しないケースに反応したい場合には\n"
"前者を使うべきです。ファイルが読むことが出来ないケースに\n"
"ソフトウエアが失敗すると考えている場合(すなわち、\n"
"それは文字通り例外です)には、後者を使うべきです。\n"
"\n"
"## プロセスとrawファイル\n"
"\n"
"ファイルがオープンされる度に、Elixirは新しいプロセスを生みます。ファイ\n"
"ルへ書くことは、そのファイル記述子に書き込むプロセスへメッセージを送信\n"
"することと等しいです。\n"
"\n"
"これはファイルはノード間で受け渡すことが出来ること、メッセージ\n"
"パッシングはネットワークで同じファイルに書き込むことが出来ることを\n"
"保証していることを意味します。\n"
"\n"
"しかしながら、必ずしもこの抽象概念の対価を支払わなくてもよいです。その\n"
"様な場合、`:raw`モードでオープンすることができます。`:read_ahead`オプショ\n"
"ンと`:delayed_write`オプションも巨大なファイルの操作やタイトなループに\n"
"おいての作業に役に立ちます。\n"
"\n"
"それらのオプションとその他パフォーマンスの考慮点についての詳細は、\n"
"http://www.erlang.org/doc/man/file.html#open-2 をチェックしてください。\n"

#. TRANSLATORS: def Kernel.CLI.main(argv)
#: lib/kernel/cli.ex:11
msgid "This is the API invoked by Elixir boot process.\n"
msgstr "これはElixirブートプロセスにより実行されるAPIです。\n"

#. TRANSLATORS: @type server
#: lib/gen_server.ex:0
msgid "The server reference"
msgstr "サーバのリファレンス"

#. TRANSLATORS: defmacro Kernel.update_in(path, fun)
#: lib/kernel.ex:1729
msgid ""
"Updates a nested structure via the given `path`.\n"
"\n"
"This is similar to `update_in/3`, except the path is extracted via\n"
"a macro rather than passing a list. For example:\n"
"\n"
"    update_in(opts[:foo][:bar], &(&1 + 1))\n"
"\n"
"Is equivalent to:\n"
"\n"
"    update_in(opts, [:foo, :bar], &(&1 + 1))\n"
"\n"
"Note that in order for this macro to work, the complete path must always\n"
"be visible by this macro. For more information about the supported path\n"
"expressions, please check `get_and_update_in/2` docs.\n"
"\n"
"## Examples\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> update_in(users[\"john\"][:age], &(&1 + 1))\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> update_in(users[\"john\"].age, &(&1 + 1))\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
msgstr ""
"ネストした構造を与えられた`path`によって更新します。\n"
"\n"
"pathがリストを渡しているのではなく、マクロによって抽出\n"
"されていることを除けば、これは`update_in/3`と似ています。\n"
"例えば:\n"
"\n"
"    update_in(opts[:foo][:bar], &(&1 + 1))\n"
"\n"
"以下と等しいです:\n"
"\n"
"    update_in(opts, [:foo, :bar], &(&1 + 1))\n"
"\n"
"このマクロが機能するために、完全なパスが常にこのマクロによって見えていなけれ"
"ば\n"
"ならないことに注意してください。\n"
"サポートされたパス式についての更なる情報については、`get_and_update_in/2`の\n"
"ドキュメントをチェックしてください。\n"
"\n"
"## 例\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> update_in(users[\"john\"][:age], &(&1 + 1))\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> update_in(users[\"john\"].age, &(&1 + 1))\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"

#. TRANSLATORS: def Kernel.update_in(data, keys, fun)
#: lib/kernel.ex:1607
msgid ""
"Updates a key in a nested structure.\n"
"\n"
"Uses the `Access` protocol to traverse the structures\n"
"according to the given `keys`, unless the `key` is a\n"
"function. If the key is a function, it will be invoked\n"
"as specified in `get_and_update_in/3`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> update_in(users, [\"john\", :age], &(&1 + 1))\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"In case any of entries in the middle returns `nil`,\n"
"an error will be raised when trying to access it next.\n"
msgstr ""
"ネストした構造を与えられた`path`によって更新します。\n"
"\n"
"pathがリストを渡しているのではなく、マクロによって抽出\n"
"されていることを除けば、これは`update_in/3`と似ています。\n"
"例えば:\n"
"\n"
"    update_in(opts[:foo][:bar], &(&1 + 1))\n"
"\n"
"以下と等しいです:\n"
"\n"
"    update_in(opts, [:foo, :bar], &(&1 + 1))\n"
"\n"
"このマクロが機能するために、完全なパスが常にこのマクロによって見えていなけれ"
"ば\n"
"ならないことに注意してください。\n"
"サポートされたパス式についての更なる情報については、`get_and_update_in/2`の\n"
"ドキュメントをチェックしてください。\n"
"\n"
"ネストした構造のキーを更新します。\n"
"\n"
"`key`が関数でないかぎり、与えられた`key`によって構造を\n"
"トラバースするために`Access`プロトコルを使います。\n"
"もしキーが関数なら、`get_and_update_in/3`で規定により\n"
"実行されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> update_in(users, [\"john\", :age], &(&1 + 1))\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"途中のエントリの何れかが`nil`を返す場合、次に\n"
"それにアクセスしようとするときに、エラーを上げます。\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.unquote_splicing(expr)
#: lib/kernel/special_forms.ex:1136
msgid ""
"Unquotes the given list expanding its arguments. Similar\n"
"to unquote.\n"
"\n"
"## Examples\n"
"\n"
"    values = [2, 3, 4]\n"
"    quote do: sum(1, unquote_splicing(values), 5)\n"
"    #=> {:sum, [], [1, 2, 3, 4, 5]}\n"
"\n"
msgstr ""
"与えられたリストをその引数に拡張してunquoteします。\n"
"unquoteと似ています。\n"
"\n"
"## 例\n"
"\n"
"    values = [2, 3, 4]\n"
"    quote do: sum(1, unquote_splicing(values), 5)\n"
"    #=> {:sum, [], [1, 2, 3, 4, 5]}\n"
"\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.unquote(expr)
#: lib/kernel/special_forms.ex:1123
msgid ""
"Unquotes the given expression from inside a macro.\n"
"\n"
"## Examples\n"
"\n"
"Imagine the situation you have a variable `value` and\n"
"you want to inject it inside some quote. The first attempt\n"
"would be:\n"
"\n"
"    value = 13\n"
"    quote do: sum(1, value, 3)\n"
"\n"
"Which would then return:\n"
"\n"
"    {:sum, [], [1, {:value, [], quoted}, 3]}\n"
"\n"
"Which is not the expected result. For this, we use unquote:\n"
"\n"
"    value = 13\n"
"    quote do: sum(1, unquote(value), 3)\n"
"    #=> {:sum, [], [1, 13, 3]}\n"
"\n"
msgstr ""
"マクロの内側で与えられた式をunquoteします。\n"
"\n"
"## 例\n"
"\n"
"変数`value`を持っていて、それをいくつかのquoteの内側に\n"
"注入したいとします。最初の試みは以下のようになるでしょう:\n"
"\n"
"    value = 13\n"
"    quote do: sum(1, value, 3)\n"
"\n"
"それは以下を返します。\n"
"\n"
"    {:sum, [], [1, {:value, [], quoted}, 3]}\n"
"\n"
"それは期待した結果ではないです。このためにunquoteを使って以下の\n"
"します:\n"
"\n"
"    value = 13\n"
"    quote do: sum(1, unquote(value), 3)\n"
"    #=> {:sum, [], [1, 13, 3]}\n"
"\n"

#. TRANSLATORS: def Macro.unescape_tokens(tokens, map)
#: lib/macro.ex:438
msgid ""
"Unescapes the given tokens according to the given map.\n"
"\n"
"Check `unescape_tokens/1` and `unescape_string/2` for more information.\n"
msgstr ""
"与えられたトークンを与えられたマップに従ってアンエスケープします。\n"
"\n"
"更なる情報は、`unescape_tokens/1`と`unescape_string/2`をチェックしてく\n"
"ださい。\n"

#. TRANSLATORS: def Macro.unescape_tokens(tokens)
#: lib/macro.ex:428
msgid ""
"Unescapes the given tokens according to the default map.\n"
"\n"
"Check `unescape_string/1` and `unescape_string/2` for more\n"
"information about unescaping.\n"
"\n"
"Only tokens that are binaries are unescaped, all others are\n"
"ignored. This function is useful when implementing your own\n"
"sigils. Check the implementation of `Kernel.sigil_s/2`\n"
"for examples.\n"
msgstr ""
"与えられたトークンをデフォルトマップに従ってアンエスケープします。\n"
"\n"
"アンエスケープについての更なる情報は、`unescape_tokens/1`と\n"
"`unescape_string/2`をチェックしてください。\n"
"\n"
"バイナリのトークンだけがアンエスケープされます、他の全ては\n"
"無視されます。この関数は自分でsigilを実装するときに便利です。\n"
"例については`Kernel.sigil_s/2`の実装をチェックしてください。\n"

#. TRANSLATORS: def Macro.unescape_string(chars, map)
#: lib/macro.ex:412
msgid ""
"Unescapes the given chars according to the map given.\n"
"\n"
"Check `unescape_string/1` if you want to use the same map\n"
"as Elixir single- and double-quoted strings.\n"
"\n"
"## Map\n"
"\n"
"The map must be a function. The function receives an integer\n"
"representing the codepoint of the character it wants to unescape.\n"
"Here is the default mapping function implemented by Elixir:\n"
"\n"
"    def unescape_map(?0), do: ?0\n"
"    def unescape_map(?a), do: ?\\a\n"
"    def unescape_map(?b), do: ?\\b\n"
"    def unescape_map(?d), do: ?\\d\n"
"    def unescape_map(?e), do: ?\\e\n"
"    def unescape_map(?f), do: ?\\f\n"
"    def unescape_map(?n), do: ?\\n\n"
"    def unescape_map(?r), do: ?\\r\n"
"    def unescape_map(?s), do: ?\\s\n"
"    def unescape_map(?t), do: ?\\t\n"
"    def unescape_map(?v), do: ?\\v\n"
"    def unescape_map(?x), do: true\n"
"    def unescape_map(e),  do: e\n"
"\n"
"If the `unescape_map` function returns `false`. The char is\n"
"not escaped and `\\` is kept in the char list.\n"
"\n"
"Hexadecimals will be escaped if the map function returns `true`\n"
"for `?x`.\n"
"\n"
"## Examples\n"
"\n"
"Using the `unescape_map` function defined above is easy:\n"
"\n"
"    Macro.unescape_string \"example\\\\n\", &unescape_map(&1)\n"
"\n"
msgstr ""
"与えられたトークンを与えられたマップに従ってアンエスケープします。\n"
"\n"
"Elixirの単一引用符と二重引用符の文字列として同じマップを\n"
"使いたい場合、`unescape_string/1`をチェックしてください。\n"
"\n"
"## マップ\n"
"\n"
"マップは関数でなければなりません。関数はアンエスケープしたい\n"
"文字のコードポイント表現した整数を受け取ります。\n"
"Elixirで実装されたデフォルトマッピング関数は以下のとおりです:\n"
"\n"
"    def unescape_map(?0), do: ?0\n"
"    def unescape_map(?a), do: ?\\a\n"
"    def unescape_map(?b), do: ?\\b\n"
"    def unescape_map(?d), do: ?\\d\n"
"    def unescape_map(?e), do: ?\\e\n"
"    def unescape_map(?f), do: ?\\f\n"
"    def unescape_map(?n), do: ?\\n\n"
"    def unescape_map(?r), do: ?\\r\n"
"    def unescape_map(?s), do: ?\\s\n"
"    def unescape_map(?t), do: ?\\t\n"
"    def unescape_map(?v), do: ?\\v\n"
"    def unescape_map(?x), do: true\n"
"    def unescape_map(e),  do: e\n"
"\n"
"もし`unescape_map`関数が`false`を返したら、その文字はエスケープされず、\n"
"`\\`は文字リストに保持されます。\n"
"\n"
"16進数はマップ関数が`?x`に対して`true`を返したらエスケープされるでしょ\n"
"う。\n"
"\n"
"## 例\n"
"\n"
"上で定義された`unescape_map`関数を使用することは簡単です:\n"
"\n"
"    Macro.unescape_string \"example\\\\n\", &unescape_map(&1)\n"
"\n"

#. TRANSLATORS: def Macro.unescape_string(chars)
#: lib/macro.ex:368
msgid ""
"Unescape the given chars.\n"
"\n"
"This is the unescaping behaviour used by default in Elixir\n"
"single- and double-quoted strings. Check `unescape_string/2`\n"
"for information on how to customize the escaping map.\n"
"\n"
"In this setup, Elixir will escape the following: `\\0`, `\\a`, `\\b`,\n"
"`\\d`, `\\e`, `\\f`, `\\n`, `\\r`, `\\s`, `\\t` and `\\v`. Unicode "
"codepoints\n"
"can be given as hexadecimals via `\\xNN` and `\\x{NN...}` escapes.\n"
"\n"
"This function is commonly used on sigil implementations\n"
"(like `~r`, `~s` and others) which receive a raw, unescaped\n"
"string.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Macro.unescape_string(\"example\\\\n\")\n"
"    \"example\\n\"\n"
"\n"
"In the example above, we pass a string with `\\n` escaped\n"
"and return a version with it unescaped.\n"
msgstr ""
"与えられた文字をアンエスケープします。\n"
"\n"
"このアンエスケープは、Elixirの単一引用符と二重引用符の文字列で使われる\n"
"デフォルトの振舞いです。エスケープマップをカスタマイズする方法について\n"
"の情報は`unescape_string/2`をチェックしてください。\n"
"\n"
"このセットアップでは、Elixirは以下のとおりエスケープします: `\\0`,\n"
"`\\a`, `\\b`, `\\d`, `\\e`, `\\f`, `\\n`, `\\r`, `\\s`, `\\t` そして `"
"\\v`。\n"
"`\\xNN`や`\\x{NN...}`といった16進数構文もサポートされます。\n"
"\n"
"この関数は生の文字列を受信する(`~r`, `~s`やその他のような)sigilの実装で\n"
"共通的に使われ、文字列をアンエスケープします。\n"
"\n"
"## 例\n"
"\n"
"    iex> Macro.unescape_string(\"example\\\\n\")\n"
"    \"example\\n\"\n"
"\n"
"上の例では、エスケープされた`\\n`付きの文字列をパスして\n"
"アンエスケープされたバージョンを返しています。\n"

#. TRANSLATORS: @type spec
#: lib/supervisor/spec.ex:0
msgid "The supervisor specification"
msgstr "スーパバイザの仕様(specification)"

#. TRANSLATORS: @type supervisor
#: lib/supervisor.ex:0
msgid "The supervisor reference"
msgstr "スーパバイザのリファンレンス"

#. TRANSLATORS: Elixir.Inspect Summary
#: lib/inspect.ex:4
msgid ""
"The `Inspect` protocol is responsible for converting any Elixir\n"
"data structure into an algebra document. This document is then\n"
"formatted, either in pretty printing format or a regular one.\n"
"\n"
"The `inspect/2` function receives the entity to be inspected\n"
"followed by the inspecting options, represented by the struct\n"
"`Inspect.Opts`.\n"
"\n"
"Inspection is done using the functions available in `Inspect.Algebra`.\n"
"\n"
"## Examples\n"
"\n"
"Many times, inspecting a structure can be implemented in function\n"
"of existing entities. For example, here is `HashSet`'s `inspect`\n"
"implementation:\n"
"\n"
"    defimpl Inspect, for: HashSet do\n"
"      import Inspect.Algebra\n"
"\n"
"      def inspect(dict, opts) do\n"
"        concat [\"#HashSet<\", to_doc(HashSet.to_list(dict), opts), \">\"]\n"
"      end\n"
"    end\n"
"\n"
"The `concat` function comes from `Inspect.Algebra` and it\n"
"concatenates algebra documents together. In the example above,\n"
"it is concatenating the string `\"HashSet<\"` (all strings are\n"
"valid algebra documents that keep their formatting when pretty\n"
"printed), the document returned by `Inspect.Algebra.to_doc/2` and the\n"
"other string `\">\"`.\n"
"\n"
"Since regular strings are valid entities in an algebra document,\n"
"an implementation of inspect may simply return a string,\n"
"although that will devoid it of any pretty-printing.\n"
"\n"
"## Error handling\n"
"\n"
"In case there is an error while your structure is being inspected,\n"
"Elixir will automatically fall back to a raw representation.\n"
"\n"
"You can however access the underlying error by invoking the Inspect\n"
"implementation directly. For example, to test Inspect.HashSet above,\n"
"you can invoke it as:\n"
"\n"
"    Inspect.HashSet.inspect(HashSet.new, Inspect.Opts.new)\n"
"\n"
msgstr ""
"`Inspect`プロトコルは、任意のElixirデータ構造を、代数学ドキュメントに変\n"
"換する役割りを果します。このドキュメントはプリティプリンティング\n"
"か標準の物のいずれかにフォーマットされます。\n"
"\n"
"`inspect/2`関数は`Inspect.Opts`構造体ににより表現されたインスペクト\n"
"オプションによりインスペクトされるエンティティを受け取ります。\n"
"\n"
"インスペクトは`Inspect.Algebra`で利用できる関数を使用して行われます。\n"
"\n"
"## 例\n"
"\n"
"しばしば、構造を調べることは、既存のエンティティの\n"
"関数で実装されることができます。例えば、`HashSet`の`inspect`実装は\n"
"こうです:\n"
"\n"
"    defimpl Inspect, for: HashSet do\n"
"      import Inspect.Algebra\n"
"\n"
"      def inspect(dict, opts) do\n"
"        concat [\"#HashSet<\", to_doc(HashSet.to_list(dict), opts), \">\"]\n"
"      end\n"
"    end\n"
"\n"
"`concat`関数は`Inspect.Algebra`から来ていて、それは一緒に代数学ドキュメ\n"
"ントを連結します。上の例では、文字列`\"HashSet<\"`(全ての文字列はプリティ\n"
"プリントされた時に書式が保持される有効な代数学ドキュメントです)と、\n"
"`Inspect.Algebra.to_doc/2`関数の戻値と、文字列`\">\"`とが連結されます。\n"
"\n"
"普通の文字列は代数学ドキュメントの有効なエンティティですので、調査の実\n"
"装は任意のプリティプリンティングを取り去り、単に文字列を返すかもしれま\n"
"せん。\n"
"\n"
"## エラーハンドリング\n"
"\n"
"構造の調査中にエラーがあった場合、Elixirは自動的にraw表現に\n"
"フォールバックします。\n"
"\n"
"しかしながら、Inspect実装を直接実行することで根底にあるエラーにアクセス\n"
"することができます。例えば、上のInspect.HashSetをテストするために、\n"
"それを実行することができます:\n"
"\n"
"    Inspect.HashSet.inspect(HashSet.new, Inspect.Opts.new)\n"
"\n"

#. TRANSLATORS: def Task.__struct__()
#: lib/task.ex:102
msgid ""
"The Task struct.\n"
"\n"
"It contains two fields:\n"
"\n"
"  * `:pid` - the process reference of the task process; it may be a pid\n"
"    or a tuple containing the process and node names\n"
"\n"
"  * `:ref` - the task monitor reference\n"
"\n"
msgstr ""
"タスク構造体です。\n"
"\n"
"二つのフィールドを含みます:\n"
"\n"
"  * `:pid` - タスクプロセスのリファレンス; pidかプロセスとノード名を\n"
"             含んだタプルです。\n"
"\n"
"  * `:ref` - タスクモニタのリファレンスです\n"
"\n"

#. TRANSLATORS: @type name
#: lib/supervisor.ex:0
msgid "The Supervisor name"
msgstr "スーパバイザの名前"

#. TRANSLATORS: Elixir.System Summary
#: lib/system.ex:1
msgid ""
"The System module provides access to variables used or\n"
"maintained by the VM and to functions that interact directly\n"
"with the VM or the host system.\n"
msgstr ""
"SystemモジュールはVMにより使用、維持される変数、\n"
"VMまたはホストシステムへの直接の相互作用をする関数\n"
"へのアクセスを提供します。\n"

#. TRANSLATORS: Elixir.String.Chars Summary
#: lib/string/chars.ex:3
msgid ""
"The String.Chars protocol is responsible for\n"
"converting a structure to a Binary (only if applicable).\n"
"The only function required to be implemented is\n"
"`to_string` which does the conversion.\n"
"\n"
"The `to_string` function automatically imported\n"
"by Kernel invokes this protocol. String\n"
"interpolation also invokes to_string in its\n"
"arguments. For example, `\"foo#{bar}\"` is the same\n"
"as `\"foo\" <> to_string(bar)`.\n"
msgstr ""
"String.Charsプロトコルは、構造をBinary(適用できるときだけ)へ変換する役\n"
"割りを果します。要求される関数は、変換を行う`to_string`の実装だけです。\n"
"\n"
"`to_string`関数は自動的にKernelによりインポートされ、このプロトコルが実\n"
"行します。文字列中に挿入された式も `to_string` の引数になり実行されます。例\n"
"えば、`\"foo#{bar}\"`は`\"foo\" <> to_string(bar)`と同じです。\n"

#. TRANSLATORS: Elixir.List.Chars Summary
#: lib/list/chars.ex:1
msgid ""
"The List.Chars protocol is responsible for\n"
"converting a structure to a list (only if applicable).\n"
"The only function required to be implemented is\n"
"`to_char_list` which does the conversion.\n"
"\n"
"The `to_char_list` function automatically imported\n"
"by Kernel invokes this protocol.\n"
msgstr ""
"List.Charsプロトコルは、構造をリスト(適用できるときだけ)へ変換する役割\n"
"りを果します。要求される関数は変換を行う`to_char_list`の実装だけです。\n"
"\n"
"`to_char_list`関数は自動的にカーネルによってインポートされ、このプロト\n"
"コルが実行します。\n"

#. TRANSLATORS: Elixir.Access Summary
#: lib/access.ex:1
msgid ""
"The Access protocol is used by `foo[bar]` and also\n"
"empowers the nested update functions in Kernel.\n"
"\n"
"For instance, `foo[bar]` translates `Access.get(foo, bar)`.\n"
"`Kernel.get_in/2`, `Kernel.put_in/3`, `Kernel.update_in/3` and\n"
"`Kernel.get_and_update_in/3` are also all powered by the Access\n"
"protocol.\n"
"\n"
"This protocol is implemented by default for keywords, maps\n"
"and dictionary like types:\n"
"\n"
"    iex> keywords = [a: 1, b: 2]\n"
"    iex> keywords[:a]\n"
"    1\n"
"\n"
"    iex> map = %{a: 1, b: 2}\n"
"    iex> map[:a]\n"
"    1\n"
"\n"
"    iex> star_ratings = %{1.0 => \"★\", 1.5 => \"★☆\", 2.0 => \"★★\"}\n"
"    iex> star_ratings[1.5]\n"
"    \"★☆\"\n"
"\n"
"The key comparison must be implemented using the `===` operator.\n"
msgstr ""
"Accessプロトコルは`foo[bar]`によって使われ、Kernelのネストした更新関数\n"
"に能力を与えます。\n"
"\n"
"例えば、`foo[bar]`は、`Access.get(foo, bar)`に変換されます。\n"
"`Kernel.get_in/2`、`Kernel.put_in/3`、`Kernel.update_in/3`、\n"
"そして`Kernel.get_and_update_in/3`は全てAccessプロトコル\n"
"で動いています。\n"
"\n"
"このプロトコルはキーワード、マップ、そしてディクショナリのような\n"
"タイプではデフォルトで実装されています:\n"
"\n"
"    iex> keywords = [a: 1, b: 2]\n"
"    iex> keywords[:a]\n"
"    1\n"
"\n"
"    iex> map = %{a: 1, b: 2}\n"
"    iex> map[:a]\n"
"    1\n"
"\n"
"    iex> star_ratings = %{1.0 => \"★\", 1.5 => \"★☆\", 2.0 => \"★★\"}\n"
"    iex> star_ratings[1.5]\n"
"    \"★☆\"\n"
"\n"
"キーの比較は`===`演算子を使って実装されなければなりません。\n"

#. TRANSLATORS: def GenEvent.stop(manager)
#: lib/gen_event.ex:510
msgid ""
"Terminates the event `manager`.\n"
"\n"
"Before terminating, the event manager will call `terminate(:stop, ...)`\n"
"for each installed event handler.\n"
msgstr ""
"イベント`manager`を終了します。\n"
"\n"
"終了する前に、イベントマネージャは、インストールされたイベントハンドラ\n"
"それぞれの`terminate(:stop, ...)`を呼び出します。\n"

#. TRANSLATORS: def Enum.take_while(collection, fun)
#: lib/enum.ex:1939
msgid ""
"Takes the items at the beginning of `collection` while `fun` returns "
"`true`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.take_while([1, 2, 3], fn(x) -> x < 3 end)\n"
"    [1, 2]\n"
"\n"
msgstr ""
"`collection`の先頭から`fun`が`true`を返す間のアイテムを取り出します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.take_while([1, 2, 3], fn(x) -> x < 3 end)\n"
"    [1, 2]\n"
"\n"

#. TRANSLATORS: def Enum.take(collection, count)
#: lib/enum.ex:1883
msgid ""
"Takes the first `count` items from the collection.\n"
"\n"
"`count` must be an integer. If a negative `count` is given, the last `count` "
"values will\n"
"be taken. For such, the collection is fully enumerated keeping up\n"
"to `2 * count` elements in memory. Once the end of the collection is\n"
"reached, the last `count` elements are returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.take([1, 2, 3], 2)\n"
"    [1,2]\n"
"\n"
"    iex> Enum.take([1, 2, 3], 10)\n"
"    [1,2,3]\n"
"\n"
"    iex> Enum.take([1, 2, 3], 0)\n"
"    []\n"
"\n"
"    iex> Enum.take([1, 2, 3], -1)\n"
"    [3]\n"
"\n"
msgstr ""
"最初の`count`個のアイテムを`collection`から取り出します。\n"
"\n"
"`count`は整数でなくてはなりません。`count`に負が与えられると、\n"
"最後の`count`個が取り出されます。そのため、コレクションは完全な\n"
"列挙にはメモリ内に`2 * count`要素が続きます。コレクションの終わ\n"
"りに到達したら、最後の`count`個の要素が返されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.take([1, 2, 3], 2)\n"
"    [1,2]\n"
"\n"
"    iex> Enum.take([1, 2, 3], 10)\n"
"    [1,2,3]\n"
"\n"
"    iex> Enum.take([1, 2, 3], 0)\n"
"    []\n"
"\n"
"    iex> Enum.take([1, 2, 3], -1)\n"
"    [3]\n"
"\n"

#. TRANSLATORS: def Keyword.take(keywords, keys)
#: lib/keyword.ex:519
msgid ""
"Takes all entries corresponding to the given keys and returns them in a new\n"
"keyword list.\n"
"\n"
"Duplicated keys are preserved in the new keyword list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> d = [a: 1, b: 2, c: 3, d: 4]\n"
"    iex> Keyword.take(d, [:a, :c, :e])\n"
"    [a: 1, c: 3]\n"
"\n"
"    iex> d = [a: 1, b: 2, c: 3, d: 4, a: 5]\n"
"    iex> Keyword.take(d, [:a, :c, :e])\n"
"    [a: 1, c: 3, a: 5]\n"
"\n"
msgstr ""
"与えられたキーと一致している全てのエントリを取出して、それらで\n"
"新しいキーワードリストを作成して返します。\n"
"\n"
"重複したキーは新しいキーワードリストに保存されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> d = [a: 1, b: 2, c: 3, d: 4]\n"
"    iex> Keyword.take(d, [:a, :c, :e])\n"
"    [a: 1, c: 3]\n"
"\n"
"    iex> d = [a: 1, b: 2, c: 3, d: 4, a: 5]\n"
"    iex> Keyword.take(d, [:a, :c, :e])\n"
"    [a: 1, c: 3, a: 5]\n"
"\n"

#. TRANSLATORS: def Keyword.split(keywords, keys)
#: lib/keyword.ex:489
msgid ""
"Takes all entries corresponding to the given keys and extracts them into a\n"
"separate keyword list. \n"
"\n"
"Returns a tuple with the new list and the old list with removed keys.\n"
"\n"
"Keys for which there are no entires in the keyword list are ignored.\n"
"\n"
"Entries with duplicated keys end up in the same keyword list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> d = [a: 1, b: 2, c: 3, d: 4]\n"
"    iex> Keyword.split(d, [:a, :c, :e])\n"
"    {[a: 1, c: 3], [b: 2, d: 4]}\n"
"\n"
"    iex> d = [a: 1, b: 2, c: 3, d: 4, a: 5]\n"
"    iex> Keyword.split(d, [:a, :c, :e])\n"
"    {[a: 1, c: 3, a: 5], [b: 2, d: 4]}\n"
"\n"
msgstr ""
"与えられたキーと一致する全てのエントリを取出して、\n"
"キーワードリストを分割します。\n"
"\n"
"新しいリストと古いリストからキーを削除したもののタプルを返します。\n"
"\n"
"キーワードリストにエントリがないキーは無視されます。\n"
"\n"
"重複したキーのエントリは同じキーワードリストになります。\n"
"\n"
"## 例\n"
"\n"
"    iex> d = [a: 1, b: 2, c: 3, d: 4]\n"
"    iex> Keyword.split(d, [:a, :c, :e])\n"
"    {[a: 1, c: 3], [b: 2, d: 4]}\n"
"\n"
"    iex> d = [a: 1, b: 2, c: 3, d: 4, a: 5]\n"
"    iex> Keyword.split(d, [:a, :c, :e])\n"
"    {[a: 1, c: 3, a: 5], [b: 2, d: 4]}\n"
"\n"

#. TRANSLATORS: def Stream.chunk(enum, n)
#: lib/stream.ex:125
msgid "Shortcut to `chunk(enum, n, n)`.\n"
msgstr "`chunk(enum, n, n)`へのショートカットです。\n"

#. TRANSLATORS: def Enum.chunk(coll, n)
#: lib/enum.ex:307
msgid "Shortcut to `chunk(coll, n, n)`.\n"
msgstr "`chunk(coll, n, n)`へのショートカットです。\n"

#. TRANSLATORS: def File.cd(path)
#: lib/file.ex:1080
msgid ""
"Sets the current working directory.\n"
"\n"
"Returns `:ok` if successful, `{:error, reason}` otherwise.\n"
msgstr ""
"カレントワーキングディレクトリをセットします。\n"
"\n"
"成功したら`:ok`を、さもなければ`{:error, reason}`を返します。\n"

#. TRANSLATORS: def IO.ANSI.home()
#: lib/io/ansi.ex:129
msgid "Send cursor home"
msgstr "カーソルをホームへセットします。"

#. TRANSLATORS: def Node.set_cookie(node \\ Node.self(), cookie)
#: lib/node.ex:247
msgid ""
"Sets the magic cookie of `node` to the atom `cookie`.\n"
"\n"
"The default node is `Node.self`, the local node. If `node` is the local "
"node,\n"
"the function also sets the cookie of all other unknown nodes to `cookie`.\n"
"\n"
"This function will raise `FunctionClauseError` if the given `node` is not "
"alive.\n"
msgstr ""
"`node`のマジッククッキーをアトム`cookie`にセットします。\n"
"\n"
"デフォルトノードは`Node.self`で、ローカルノードです。`node`がローカルノー\n"
"ドなら、関数は他のすべての不明なノードのクッキーを`cookie`にセットします。\n"
"\n"
"与えられた`node`が生きていないとき、この関数は`FunctionClauseError`を\n"
"上げます。\n"

#. TRANSLATORS: def Process.group_leader(pid, leader)
#: lib/process.ex:315
msgid ""
"Sets the group leader of `pid` to `leader`. Typically, this is used when a "
"processes\n"
"started from a certain shell should have a group leader other than `:init`.\n"
msgstr ""
"`pid`のグループリーダーを`leader`にセットします。一般的に、特定のシェル\n"
"からスタートするプロセスが`:init`以外のグループリーダーをを持っていなけ\n"
"ればならないとき、これが使われます。\n"

#. TRANSLATORS: def IO.ANSI.primary_font()
#: lib/io/ansi.ex:78
msgid "Sets primary (default) font"
msgstr "プライマリ(default)フォントをセットします。"

#. TRANSLATORS: def Port.list()
#: lib/port.ex:83
msgid ""
"See http://www.erlang.org/doc/man/erlang.html#ports-0.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"http://www.erlang.org/doc/man/erlang.html#ports-0 を参照してください。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Port.info(port, item)
#: lib/port.ex:74
msgid ""
"See http://www.erlang.org/doc/man/erlang.html#port_info-2.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"http://www.erlang.org/doc/man/erlang.html#port_info-2 を参照してください。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Port.info(port)
#: lib/port.ex:65
msgid ""
"See http://www.erlang.org/doc/man/erlang.html#port_info-1.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"http://www.erlang.org/doc/man/erlang.html#port_info-1 を参照してください。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Port.control(port, operation, data)
#: lib/port.ex:47
msgid ""
"See http://www.erlang.org/doc/man/erlang.html#port_control-3.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"http://www.erlang.org/doc/man/erlang.html#port_control-3 を参照してくだ\n"
"さい。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Port.connect(port, pid)
#: lib/port.ex:38
msgid ""
"See http://www.erlang.org/doc/man/erlang.html#port_connect-2.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"http://www.erlang.org/doc/man/erlang.html#port_connect-2 を参照してくだ\n"
"さい。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Port.command(port, data, options \\ [])
#: lib/port.ex:29
msgid ""
"See http://www.erlang.org/doc/man/erlang.html#port_command-2.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"http://www.erlang.org/doc/man/erlang.html#port_command-2 を参照してくだ\n"
"さい。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Port.close(port)
#: lib/port.ex:20
msgid ""
"See http://www.erlang.org/doc/man/erlang.html#port_close-1.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"http://www.erlang.org/doc/man/erlang.html#port_close-1 を参照してくださ\n"
"い。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Port.call(port, operation, data)
#: lib/port.ex:56
msgid ""
"See http://www.erlang.org/doc/man/erlang.html#port_call-3.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"http://www.erlang.org/doc/man/erlang.html#port_call-3 を参照してくださ\n"
"い。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Port.open(name, settings)
#: lib/port.ex:11
msgid ""
"See http://www.erlang.org/doc/man/erlang.html#open_port-2.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"http://www.erlang.org/doc/man/erlang.html#open_port-2 を参照してくださ\n"
"い。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Supervisor.terminate_child(supervisor, pid_or_child_id)
#: lib/supervisor.ex:295
msgid ""
"Terminates the given pid or child id.\n"
"\n"
"If the supervisor is not a `simple_one_for_one`, the child id is expected\n"
"and the process, if there is one, is terminated; the child specification is\n"
"kept unless the child is temporary.\n"
"\n"
"In case of a `simple_one_for_one` supervisor, a pid is expected. If the "
"child\n"
"specification identifier is given instead of a `pid`, the function will\n"
"return `{:error, :simple_one_for_one}`.\n"
"\n"
"A non-temporary child process may later be restarted by the supervisor. The "
"child\n"
"process can also be restarted explicitly by calling `restart_child/2`. Use\n"
"`delete_child/2` to remove the child specification.\n"
"\n"
"If successful, the function returns `:ok`. If there is no child "
"specification or\n"
"pid, the function returns `{:error, :not_found}`.\n"
msgstr ""
"与えられたpidかchild idを終了します。\n"
"\n"
"もしスーパバイザが`simple_one_for_one`でないなら、child idが期待され、\n"
"そのプロセスはまだ生きていれば終了されます; 子プロセスがテンポラ\n"
"リでない限り、child仕様は保持されます。\n"
"\n"
"`simple_one_for_one`スーパバイザの場合、pidが期待されます。もしchild仕\n"
"様識別子が`pid`の代りに与えられたなら、関数は`{:error,\n"
":simple_one_for_one}`を返します。\n"
"\n"
"非テンポラリ子プロセスはスーパバイザにより後でリスタートされます。子プ\n"
"ロセスは、`restart_child/2`を呼び出すことにより明示的にリスタートするこ\n"
"とも出来ます。child仕様を削除するには`delete_child/2`を使います。\n"
"\n"
"成功すると、関数は`:ok`を返します。もしchild仕様あるいはpidがないなら、\n"
"関数は`{:error, :not_found}`を返します。\n"

#. TRANSLATORS: def System.get_env()
#: lib/system.ex:254
msgid ""
"System environment variables.\n"
"\n"
"Returns a list of all environment variables. Each variable is given as a\n"
"`{name, value}` tuple where both `name` and `value` are strings.\n"
msgstr ""
"システム環境変数です。\n"
"\n"
"全ての環境変数のリストを返します。それぞれの変数は`{name, value}`タプル\n"
"で、`name`と`value`はどちらも文字列として与えられます。\n"

#. TRANSLATORS: @type handler
#: lib/gen_event.ex:0
msgid "Supported values for new handlers"
msgstr "新しいハンドラでサポートされる値"

#. TRANSLATORS: def Inspect.Algebra.surround(left, doc, right)
#: lib/inspect/algebra.ex:410
msgid ""
"Surrounds a document with characters.\n"
"\n"
"Puts the document between left and right enclosing and nesting it.\n"
"The document is marked as a group, to show the maximum as possible\n"
"concisely together.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.surround \"[\", Inspect.Algebra.glue(\"a\", "
"\"b\"), \"]\"\n"
"    iex> Inspect.Algebra.format(doc, 3)\n"
"    [\"[\", \"a\", \"\\n \", \"b\", \"]\"]\n"
"\n"
msgstr ""
"文字列でドキュメントを囲みます。\n"
"\n"
"documentを囲み入れ込になっている、leftとrightの間に置きます。\n"
"グループとしてドキュメントはマークされます。そして、\n"
"一緒に簡潔になるように、最大限表示します。\n"
"\n"
"## 例\n"
"\n"
"    iex> doc = Inspect.Algebra.surround \"[\", Inspect.Algebra.glue(\"a\", "
"\"b\"), \"]\"\n"
"    iex> Inspect.Algebra.format(doc, 3)\n"
"    [\"[\", \"a\", \"\\n \", \"b\", \"]\"]\n"
"\n"

#. TRANSLATORS: def System.put_env(dict)
#: lib/system.ex:306
msgid ""
"Sets multiple environment variables.\n"
"\n"
"Sets a new value for each environment variable corresponding\n"
"to each key in `dict`.\n"
msgstr ""
"複数の環境変数をセットします。\n"
"\n"
"`dict`の中のそれぞれのキーに一致しているそれぞれの環境変数に\n"
"新しい値をセットします。\n"

#. TRANSLATORS: def Task.Supervisor.terminate_child(supervisor, pid)
#: lib/task/supervisor.ex:78
msgid "Terminates the child with the given `pid`.\n"
msgstr "与えられた`pid`の子プロセスを終了します。\n"

#. TRANSLATORS: @type worker
#: lib/supervisor/spec.ex:0
msgid "Supported worker values"
msgstr "workerでサポートされる値"

#. TRANSLATORS: @type strategy
#: lib/supervisor/spec.ex:0
msgid "Supported strategies"
msgstr "strategyでサポートされる値"

#. TRANSLATORS: @type shutdown
#: lib/supervisor/spec.ex:0
msgid "Supported shutdown values"
msgstr "shutdownでサポートされる値"

#. TRANSLATORS: @type restart
#: lib/supervisor/spec.ex:0
msgid "Supported restart values"
msgstr "restartでサポートされる値"

#. TRANSLATORS: @type modules
#: lib/supervisor/spec.ex:0
msgid "Supported module values"
msgstr "moduleでサポートされる値"

#. TRANSLATORS: @type child_id
#: lib/supervisor/spec.ex:0
msgid "Supported id values"
msgstr "idでサポートされる値"

#. TRANSLATORS: def Stream.chunk(enum, n, step, pad \\ nil)
#: lib/stream.ex:157
msgid ""
"Streams the enumerable in chunks, containing `n` items each, where\n"
"each new chunk starts `step` elements into the enumerable.\n"
"\n"
"`step` is optional and, if not passed, defaults to `n`, i.e.\n"
"chunks do not overlap. If the final chunk does not have `n`\n"
"elements to fill the chunk, elements are taken as necessary\n"
"from `pad` if it was passed. If `pad` is passed and does not\n"
"have enough elements to fill the chunk, then the chunk is\n"
"returned anyway with less than `n` elements. If `pad` is not\n"
"passed at all or is `nil`, then the partial chunk is discarded\n"
"from the result.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.chunk([1, 2, 3, 4, 5, 6], 2) |> Enum.to_list\n"
"    [[1, 2], [3, 4], [5, 6]]\n"
"\n"
"    iex> Stream.chunk([1, 2, 3, 4, 5, 6], 3, 2) |> Enum.to_list\n"
"    [[1, 2, 3], [3, 4, 5]]\n"
"\n"
"    iex> Stream.chunk([1, 2, 3, 4, 5, 6], 3, 2, [7]) |> Enum.to_list\n"
"    [[1, 2, 3], [3, 4, 5], [5, 6, 7]]\n"
"\n"
"    iex> Stream.chunk([1, 2, 3, 4, 5, 6], 3, 3, []) |> Enum.to_list\n"
"    [[1, 2, 3], [4, 5, 6]]\n"
"\n"
msgstr ""
"それぞれのアイテムは`n`個含んでいて、enumerableの`step`要素毎に\n"
"新しいチャンクが始まる、enumerableをチャンクに流れ出させます。\n"
"\n"
"`step`はオプションで、もし与えられなければ、デフォルトは`n`に\n"
"なります。即ち、チャンクはオーバーラップしません。\n"
"もし最後のチャンクはチャンクを満す`n`個要素を持っていなかったら、\n"
"もし`pad`が与えられていれば、そこから必要に応じて取られます。\n"
"もし`pad`が与えられて、チャンクを満すために十分なエレメントを\n"
"持っていなかったら、チャンクは少なくとも`n`要素より少いもので\n"
"返されます。\n"
"もし`pad`が全く与えられていないか、`nil`なら、結果から\n"
"部分的なチャンクは放棄されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Stream.chunk([1, 2, 3, 4, 5, 6], 2) |> Enum.to_list\n"
"    [[1, 2], [3, 4], [5, 6]]\n"
"\n"
"    iex> Stream.chunk([1, 2, 3, 4, 5, 6], 3, 2) |> Enum.to_list\n"
"    [[1, 2, 3], [3, 4, 5]]\n"
"\n"
"    iex> Stream.chunk([1, 2, 3, 4, 5, 6], 3, 2, [7]) |> Enum.to_list\n"
"    [[1, 2, 3], [3, 4, 5], [5, 6, 7]]\n"
"\n"
"    iex> Stream.chunk([1, 2, 3, 4, 5, 6], 3, 3, []) |> Enum.to_list\n"
"    [[1, 2, 3], [4, 5, 6]]\n"
"\n"

#. TRANSLATORS: def Supervisor.Default.init(args)
#: lib/supervisor/default.ex:10
msgid ""
"Supervisor callback that simply returns the given args.\n"
"\n"
"This is the supervisor used by `Supervisor.start_link/2`.\n"
msgstr ""
"単に与えられた引数を返すスーパバイザコールバックです。\n"
"\n"
"これは`Supervisor.start_link/2`によってスーパーバイザで使われます。\n"

#. TRANSLATORS: def Process.put(key, value)
#: lib/process.ex:62
msgid "Stores the given key-value in the process dictionary.\n"
msgstr "プロセス辞書に与えられたキーバリューを保存します。\n"

#. TRANSLATORS: def Dict.put(dict, key, val)
#: lib/dict.ex:415
msgid ""
"Stores the given `value` under `key` in `dict`.\n"
"If `dict` already has `key`, the stored value is replaced by the new one.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.put(dict, :a, 3)\n"
"    iex> Dict.get(dict, :a)\n"
"    3\n"
"\n"
msgstr ""
"与えられた`value`と`key`を`dict`に保存します。\n"
"もし`dict`が既に`key`を持っていたら、新しい値により置き換えられます。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.put(dict, :a, 3)\n"
"    iex> Dict.get(dict, :a)\n"
"    3\n"
"\n"

#. TRANSLATORS: def Application.stop(app)
#: lib/application.ex:254
msgid ""
"Stops the given `app`.\n"
"\n"
"When stopped, the application is still loaded.\n"
msgstr ""
"与えられた`app`を停止します。\n"
"\n"
"停止したとき、アプリケーションはまだロードされたままです。\n"

#. TRANSLATORS: def Kernel.exit(reason)
#: lib/kernel.ex:238
msgid ""
"Stops the execution of the calling process with the given reason.\n"
"\n"
"Since evaluating this function causes the process to terminate,\n"
"it has no return value.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"When a process reaches its end, by default it exits with\n"
"reason `:normal`. You can also call it explicitly if you\n"
"want to terminate a process but not signal any failure:\n"
"\n"
"    exit(:normal)\n"
"\n"
"In case something goes wrong, you can also use `exit/1` with\n"
"a different reason:\n"
"\n"
"    exit(:seems_bad)\n"
"\n"
"If the reason is not `:normal`, all linked process to the\n"
"exited process will crash (unless they are trapping exits).\n"
"\n"
"## OTP exits\n"
"\n"
"Exits are used by OTP to determine if a process exited abnormally\n"
"or not. The following exits are considered \"normal\":\n"
"\n"
"  * `exit(:normal)`\n"
"  * `exit(:shutdown)`\n"
"  * `exit({:shutdown, term})`\n"
"\n"
"Exiting with any other reason is considered abnormal and treated\n"
"as a crash. This means the default supervisor behaviour kicks in,\n"
"error reports are emitted, etc.\n"
"\n"
"This behaviour is relied on in many different places. For example,\n"
"`ExUnit` uses `exit(:shutdown)` when exiting the test process to\n"
"signal linked processes, supervision trees and so on to politely\n"
"shutdown too.\n"
"\n"
"## CLI exits\n"
"\n"
"Building on top of the exit signals mentioned above, if the\n"
"process started by the command line exits with any of the three\n"
"reasons above, its exit is considered normal and the Operating\n"
"System process will exit with status 0.\n"
"\n"
"It is, however, possible to customize the Operating System exit\n"
"signal by invoking:\n"
"\n"
"    exit({:shutdown, integer})\n"
"\n"
"This will cause the OS process to exit with the status given by\n"
"`integer` while signaling all linked OTP processes to politely\n"
"shutdown.\n"
"\n"
"Any other exit reason will cause the OS process to exit with\n"
"status `1` and linked OTP processes to crash.\n"
msgstr ""
"与えられたreasonで呼び出したプロセスの実行を停止します。\n"
"\n"
"この関数を評価するとき、プロセスは終了する結果となるので、\n"
"値を返しません。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"プロセスが終わりに達するとき、デフォルトでreasonが`:normal`で\n"
"exitが呼ばれます。もし失敗のシグナルを出さずにプロセスを\n"
"終了したいなら、明示的に呼ぶことも出来ます:\n"
"\n"
"    exit(:normal)\n"
"\n"
"何か悪い事が起ったケースでは、異ったreasonで`exit/1`を呼ぶこともできま\n"
"す:\n"
"\n"
"    exit(:seems_bad)\n"
"\n"
"`:normal`以外のreasonなら、exitしたプロセスにリンクされた\n"
"全てのプロセスはクラッシュします(exitをトラップしていない限り)。\n"
"\n"
"## OTPのexit\n"
"\n"
"exitは、OTPによって、プロセスが異常終了したか否かの決定に使われます。\n"
"以下のexitは\"normal\"として扱われます:\n"
"\n"
"  * `exit(:normal)`\n"
"  * `exit(:shutdown)`\n"
"  * `exit({:shutdown, term})`\n"
"\n"
"他のどんなreasonでも異常終了と思われ、クラッシュしたと見做されます。こ\n"
"れはエラーレポートを発行するなどの、デフォルトのスーパーバイザの振舞い\n"
"が効き始めることを意味します。\n"
"\n"
"この振舞いは多くの異る場所で依存されています。例えば、`ExUnit`はテスト\n"
"プロセスが終了する時、リンクされたプロセス、つまり、監督ツリーとその他\n"
"も礼儀正しくシャットダウンさせるときに、`exit(:shutdown)`を使います。\n"
"\n"
"## CLIの exit\n"
"\n"
"上記の終了シグナルの上に作り、もし\n"
"コマンドラインにより開始したプロセスが\n"
"上の3つの何れかのreasonで終了したら、その終了は、正常と\n"
"考え、オペレーティングシステムプロセスはステータス0で終了します。\n"
"\n"
"しかしながら、以下の様に実行することで、オペレーティングシステムのexit\n"
"シグナルをカスタマイズすることも可能です：\n"
"\n"
"    exit({:shutdown, integer})\n"
"\n"
"これは全てのリンクされたOTPプロセスを礼儀正しく終了したうえで、\n"
"OSプロセスを`integer`により与えられたステータスで終了します。\n"
"\n"
"他のexit reasonは全て、リンクされたOTPプロセスをクラッシュさせ、\n"
"OSプロセスをステータス1で終了します。\n"

#. TRANSLATORS: def Agent.stop(agent, timeout \\ 5000)
#: lib/agent.ex:296
msgid ""
"Stops the agent.\n"
"\n"
"Returns `:ok` if the agent is stopped within the given `timeout`.\n"
msgstr ""
"エージェントを停止します。\n"
"\n"
"エージェントが与えられた`timeout`以内に停止されたら`:ok`を返します。\n"

#. TRANSLATORS: def StringIO.close(pid)
#: lib/string_io.ex:88
msgid ""
"Stops the IO device and returns remaining buffers.\n"
"\n"
"## Examples\n"
"\n"
"    iex> {:ok, pid} = StringIO.open(\"in\")\n"
"    iex> IO.write(pid, \"out\")\n"
"    iex> StringIO.close(pid)\n"
"    {:ok, {\"in\", \"out\"}}\n"
"\n"
msgstr ""
"IOデバイスを停止して残りのバッファを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> {:ok, pid} = StringIO.open(\"in\")\n"
"    iex> IO.write(pid, \"out\")\n"
"    iex> StringIO.close(pid)\n"
"    {:ok, {\"in\", \"out\"}}\n"
"\n"

#. TRANSLATORS: def Application.start(app, type \\ :temporary)
#: lib/application.ex:244
msgid ""
"Starts the given `app`.\n"
"\n"
"If the `app` is not loaded, the application will first be loaded using "
"`load/1`.\n"
"Any included application, defined in the `:included_applications` key of "
"the\n"
"`.app` file will also be loaded, but they won't be started.\n"
"\n"
"Furthermore, all applications listed in the `:applications` key must be "
"explicitly\n"
"started before this application is. If not, `{:error, {:not_started, app}}` "
"is\n"
"returned, where `app` is the name of the missing application.\n"
"\n"
"In case you want to automatically  load **and start** all of `app`'s "
"dependencies,\n"
"see `ensure_all_started/2`.\n"
"\n"
"The `type` argument specifies the type of the application:\n"
"\n"
"  * `:permanent` - if `app` terminates, all other applications and the "
"entire\n"
"    node are also terminated.\n"
"\n"
"  * `:transient` - if `app` terminates with `:normal` reason, it is "
"reported\n"
"    but no other applications are terminated. If a transient application\n"
"    terminates abnormally, all other applications and the entire node are\n"
"    also terminated.\n"
"\n"
"  * `:temporary` - if `app` terminates, it is reported but no other\n"
"    applications are terminated (the default).\n"
"\n"
"Note that it is always possible to stop an application explicitly by "
"calling\n"
"`stop/1`. Regardless of the type of the application, no other applications "
"will\n"
"be affected.\n"
"\n"
"Note also that the `:transient` type is of little practical use, since when "
"a\n"
"supervision tree terminates, the reason is set to `:shutdown`, not `:"
"normal`.\n"
msgstr ""
"与えられた`app`を開始します。\n"
"\n"
"`app`がロードされていないなら、アプリケーションは最初に`load/1`を使って\n"
"ロードされます。`.app`ファイルの`:included_applications`キーで定義され\n"
"た任意の含まれたアプリケーションもまた、ロードされますが、開始はされま\n"
"せん。\n"
"\n"
"更にまた、`:application`キーにリストされた全てのアプリケーションはアプ\n"
"リケーションを開始する前に、明示的に開始されなければなりません。もしそ\n"
"うでないなら、`app`が足りないアプリケーションの名前で`{:error,\n"
"{:not_started, app}}`が返されます。\n"
"\n"
"自動的に`app`に依存する全てのアプリケーションをロードし「開始」したい場合、\n"
"`ensure_all_started/2`を参照してください。\n"
"\n"
"`type`引数はアプリケーションのタイプを指定します:\n"
"\n"
"  * `:permanent` - `app`が終了したら、全ての他のアプリケーションと\n"
"     ノード全体も終了されます。\n"
"\n"
"  * `:transient` - `app`が`:normal` reasonで終了したら、\n"
"    レポートされますが、他のアプリケーションは終了しません。\n"
"    もしtransient(一時的)なアプリケーションが異常終了したら、\n"
"    全ての他のアプリケーションとノード全体も終了されます。\n"
"\n"
"  * `:temporary` - `app`が終了したら、レポートされますが、\n"
"    他のアプリケーションは終了されません(これがデフォルトです)。\n"
"\n"
"`stop/1`を呼ぶことで、明示的にアプリケーションを終了することが常にできる\n"
"ことに、気を付けてください。アプリケーションのタイプに関係なく、\n"
"他のいかなるアプリケーションも影響を受けません。\n"
"\n"
"`:transient`タイプがほとんど実用的でない理由は、監督ツリーが終了すると\n"
"き、reasonが`:normal`ではなく、`:shutdown`にセットされるからからである\n"
"ことに注意してください。\n"

#. TRANSLATORS: def Agent.start(module, fun, args, options \\ [])
#: lib/agent.ex:181
msgid ""
"Starts an agent with the given module function and arguments.\n"
"\n"
"Similar to `start/2` but a module, function and args are expected\n"
"instead of an anonymous function.\n"
msgstr ""
"与えられたモジュールと関数、引数でエージェントを開始します。\n"
"\n"
"`start/2`と似ていますが、無名関数の替わりに、\n"
"モジュール、関数、引数を期待しています。\n"

#. TRANSLATORS: def Agent.start(fun, options \\ [])
#: lib/agent.ex:170
msgid ""
"Starts an agent process without links (outside of a supervision tree).\n"
"\n"
"See `start_link/2` for more information.\n"
msgstr ""
"エージェントプロセスをリンクなし(監督ツリーの外側)で開始します。\n"
"\n"
"詳細は `start_link/2` を参照してください。\n"

#. TRANSLATORS: def Agent.start_link(module, fun, args, options \\ [])
#: lib/agent.ex:160
msgid ""
"Starts an agent linked to the current process with the given module\n"
"function and arguments.\n"
"\n"
"Same as `start_link/2` but a module, function and args are expected\n"
"instead of an anonymous function.\n"
msgstr ""
"与えられたモジュール、関数、引数で現在のプロセスにリンクされた\n"
"エージェントを開始します。\n"
"\n"
"`start_link/2`と同じですが、無名関数の替わりに、モジュール、関数、引数\n"
"を期待しています。\n"

#. TRANSLATORS: def Agent.start_link(fun, options \\ [])
#: lib/agent.ex:148
msgid ""
"Starts an agent linked to the current process with the given function.\n"
"\n"
"This is often used to start the agent as part of a supervision tree.\n"
"\n"
"Once the agent is spawned, the given function is invoked and its return\n"
"value is used as the agent state. Note that `start_link` does not return\n"
"until the given function has returned.\n"
"\n"
"## Options\n"
"\n"
"The `:name` option is used for registration as described in the module\n"
"documentation.\n"
"\n"
"If the `:timeout` option is present, the agent is allowed to spend at most\n"
"the given number of milliseconds on initialization or it will be terminated\n"
"and the start function will return `{:error, :timeout}`.\n"
"\n"
"If the `:debug` option is present, the corresponding function in the\n"
"[`:sys` module](http://www.erlang.org/doc/man/sys.html) will be invoked.\n"
"\n"
"If the `:spawn_opt` option is present, its value will be passed as options\n"
"to the underlying process as in `Process.spawn/4`.\n"
"\n"
"## Return values\n"
"\n"
"If the server is successfully created and initialized, the function returns\n"
"`{:ok, pid}`, where `pid` is the pid of the server. If there already exists\n"
"an agent with the specified name, the function returns\n"
"`{:error, {:already_started, pid}}` with the pid of that process.\n"
"\n"
"If the given function callback fails with `reason`, the function returns\n"
"`{:error, reason}`.\n"
msgstr ""
"与えられた関数で、現在のプロセスにリンクされたエージェントを開始します。\n"
"\n"
"これは、しばしば監督ツリーの一部としてエージェントを開始するために\n"
"使われます。\n"
"\n"
"一旦エージェントが生成されると、与えられた関数は実行され、\n"
"その戻値はエージェントのステートとして使われます。`start_link`は、\n"
"与えられた関数が戻るまでは、戻って来ないことに注意してください。\n"
"\n"
"## オプション\n"
"\n"
"`:name`オプションはモジュールドキュメントで記載されているように、\n"
"登録の為に使われます。\n"
"\n"
"`:timeout`オプションがあると、エージェントは、最大\n"
"初期値として与えられたミリセカンド秒間起動に時間をかけることを\n"
"許可します。あるいは、エージェントの起動は終了させられて、\n"
"スタート関数は`{:error, :timeout}`を返します。\n"
"\n"
"`:debug`オプションがあると、[`:sys` モジュール](http://www.erlang.org/doc/"
"man/sys.html) で対応する関数が起動されます。\n"
"\n"
"`:spawn_opt`があると、その値は`Process.spawn/4`のように根底にある\n"
"プロセスまでオプションとして渡されます。\n"
"\n"
"## 戻値\n"
"\n"
"もしサーバがうまく作成されて、初期化されたら、関数は、pidをサーバのプロ\n"
"セス識別子として`{:ok, pid}`を返します。もし与えられた名前でエージェン\n"
"トが既に存在したら、そのプロセスのプロセス識別子をpidとして、関数は\n"
"`{:error, {:already_started, pid}}`を返します。\n"
"\n"
"もし与えられたコールバック関数が`reason`で失敗したら、\n"
"関数は`{:error, reason}`を返します。\n"

#. TRANSLATORS: def Integer.digits(n, base \\ 10)
#: lib/integer.ex:46
msgid ""
"Returns the ordered digits for the given non-negative integer.\n"
"\n"
"An optional base value may be provided representing the radix for the "
"returned\n"
"digits.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Integer.digits(101)\n"
"    [1, 0, 1]\n"
"\n"
"    iex> Integer.digits(58127, 2)\n"
"    [1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1]\n"
"\n"
msgstr ""
"与えられた非負整数の桁のリストを返します。\n"
"\n"
"戻り値の桁の基数を、オプションで与えることができます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Integer.digits(101)\n"
"    [1, 0, 1]\n"
"\n"
"    iex> Integer.digits(58127, 2)\n"
"    [1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1]\n"
"\n"

#. TRANSLATORS: def Kernel.macro_exported?(module, macro, arity)
#: lib/kernel.ex:2399
msgid ""
"Returns true if the `module` is loaded and contains a\n"
"public `macro` with the given `arity`, otherwise false.\n"
"\n"
"Notice that this function does not load the module in case\n"
"it is not loaded. Check `Code.ensure_loaded/1` for more\n"
"information.\n"
msgstr ""
"`module`がロードされていて、与えられた`arity`の公開`macro`が\n"
"含まれていると真を返し、さもなくば偽を返します。\n"
"\n"
"この関数はモジュールがロードされていないときに、ロードを\n"
"しないことに注意してください。さらなる情報は`Code.ensure_loaded/1`\n"
"をチェックしてください。\n"

#. TRANSLATORS: def Kernel.function_exported?(module, function, arity)
#: lib/kernel.ex:2386
msgid ""
"Returns true if the `module` is loaded and contains a\n"
"public `function` with the given `arity`, otherwise false.\n"
"\n"
"Notice that this function does not load the module in case\n"
"it is not loaded. Check `Code.ensure_loaded/1` for more\n"
"information.\n"
msgstr ""
"`module`がロードされていて、与えられた`arity`の公開`function`が\n"
"含まれていると真を返し、さもなくば偽を返します。\n"
"\n"
"この関数はモジュールがロードされていないときに、ロードを\n"
"しないことに注意してください。さらなる情報は`Code.ensure_loaded/1`\n"
"をチェックしてください。\n"

#. TRANSLATORS: def Kernel.bit_size(bitstring)
#: lib/kernel.ex:131
msgid ""
"Returns an integer which is the size in bits of `bitstring`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> bit_size(<<433::16, 3::3>>)\n"
"    19\n"
"\n"
"    iex> bit_size(<<1, 2, 3>>)\n"
"    24\n"
"\n"
msgstr ""
"`bitstring`のビット列の大きさを整数で返します。\n"
"\n"
"ガード中のテストで使うことができます。コンパイラによりインライン化され\n"
"ます。\n"
"\n"
"## 例\n"
"\n"
"    iex> bit_size(<<433::16, 3::3>>)\n"
"    19\n"
"\n"
"    iex> bit_size(<<1, 2, 3>>)\n"
"    24\n"
"\n"

#. TRANSLATORS: def Kernel.abs(number)
#: lib/kernel.ex:55
msgid ""
"Returns an integer or float which is the arithmetical absolute value of "
"`number`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> abs(-3.33)\n"
"    3.33\n"
"\n"
"    iex> abs(-3)\n"
"    3\n"
"\n"
msgstr ""
"`number`の算術的絶対値を整数または小数で返します。\n"
"\n"
"ガード中のテストで使うことができます。コンパイラによりインライン化され\n"
"ます。\n"
"\n"
"## 例\n"
"\n"
"    iex> abs(-3.33)\n"
"    3.33\n"
"\n"
"    iex> abs(-3)\n"
"    3\n"
"\n"

#. TRANSLATORS: def Process.get(key, default \\ nil)
#: lib/process.ex:41
msgid "Returns the value for the given `key`.\n"
msgstr "与えられた`key`の値を返します。\n"

#. TRANSLATORS: def Application.get_env(app, key, default \\ nil)
#: lib/application.ex:129
msgid ""
"Returns the value for `key` in `app`'s environment.\n"
"\n"
"If the specified application is not loaded, or the configuration parameter\n"
"does not exist, the function returns the `default` value.\n"
msgstr ""
"`app`の環境の中の`key`に対応する値を返します。\n"
"\n"
"もし指定されたアプリケーションがロードされていない場合、あるいは、コン\n"
"フィグレーションパラメータが存在しない場合、`default`の値を返します。\n"

#. TRANSLATORS: def Application.fetch_env(app, key)
#: lib/application.ex:143
msgid ""
"Returns the value for `key` in `app`'s environment in a tuple.\n"
"\n"
"If the specified application is not loaded, or the configuration parameter\n"
"does not exist, the function returns `:error`.\n"
msgstr ""
"`app`の環境の`key`に対応する値を返します。\n"
"\n"
"もし指定されたアプリケーションがロードされていない場合、あるいは、コン\n"
"フィグレーションパラメータが存在しない場合、`:error`を返します。\n"

#. TRANSLATORS: def Application.app_dir(app, path)
#: lib/application.ex:319
msgid "Returns the given path inside `app_dir/1`.\n"
msgstr "`app_dir/1`の内側に与えられたパスを追加して返します。\n"

#. TRANSLATORS: def Agent.cast(agent, fun)
#: lib/agent.ex:274
msgid ""
"Performs a cast (fire and forget) operation on the agent state.\n"
"\n"
"The function `fun` is sent to the `agent` which invokes the function\n"
"passing the agent state. The function must return the new state.\n"
"\n"
"Note that `cast` returns `:ok` immediately, regardless of whether the\n"
"destination node or agent exists.\n"
msgstr ""
"エージェントのステートでキャスト(発火して忘れる)オペレーションを実行しま"
"す。\n"
"\n"
"関数`fun`は`agent`に送られ、エージェントステートを渡されて実行されます。\n"
"関数は新しいステートを返さなければなりません。\n"
"\n"
"送信先のノードあるいはエージェントの存在の有無に拘わらず、`cast`は\n"
"`:ok`を直ちに返すことに注意してください。\n"

#. TRANSLATORS: def Agent.cast(agent, module, fun, args)
#: lib/agent.ex:286
msgid ""
"Performs a cast (fire and forget) operation on the agent state.\n"
"\n"
"Same as `cast/2` but a module, function and args are expected\n"
"instead of an anonymous function. The state is added as first\n"
"argument to the given list of args.\n"
msgstr ""
"エージェントのステートでキャスト(発火して忘れる)オペレーションを実行しま"
"す。\n"
"\n"
"`cast/2`と同じですが、無名関数のかわりに、モジュール、関数、引数を明示\n"
"してます。ステートは与えられた引数リストの最初に追加されます。関数\n"
"`fun`は`agent`に送られ、エージェントステートを渡されて実行されます。\n"

#. TRANSLATORS: def Enum.chunk(coll, n, step, pad \\ nil)
#: lib/enum.ex:338
msgid ""
"Returns a collection of lists containing `n` items each, where\n"
"each new chunk starts `step` elements into the collection.\n"
"\n"
"`step` is optional and, if not passed, defaults to `n`, i.e.\n"
"chunks do not overlap. If the final chunk does not have `n`\n"
"elements to fill the chunk, elements are taken as necessary\n"
"from `pad` if it was passed. If `pad` is passed and does not\n"
"have enough elements to fill the chunk, then the chunk is\n"
"returned anyway with less than `n` elements. If `pad` is not\n"
"passed at all or is `nil`, then the partial chunk is discarded\n"
"from the result.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4, 5, 6], 2)\n"
"    [[1, 2], [3, 4], [5, 6]]\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4, 5, 6], 3, 2)\n"
"    [[1, 2, 3], [3, 4, 5]]\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4, 5, 6], 3, 2, [7])\n"
"    [[1, 2, 3], [3, 4, 5], [5, 6, 7]]\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4, 5, 6], 3, 3, [])\n"
"    [[1, 2, 3], [4, 5, 6]]\n"
"\n"
msgstr ""
"コレクションから`step`要素毎に`n`アイテムを含んだリストのコレクションを\n"
"返します。\n"
"\n"
"`step`はオプションで、もし与えられなければ、デフォルトは`n`になります。\n"
"即ち、チャンクはオーバーラップしません。もし最後のチャンクはチャンクを\n"
"満す`n`個要素を持っていなかったら、要素は`pad`から必要に応じて取られま\n"
"す。もし`pad`が与えられていて、チャンクを満すのに十分でなかったら、チャ\n"
"ンクは`n`要素より少くなるでしょう。もし`pad`が全く与えられていないか、\n"
"`nil`なら、結果から部分的なチャンクは放棄されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4, 5, 6], 2)\n"
"    [[1, 2], [3, 4], [5, 6]]\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4, 5, 6], 3, 2)\n"
"    [[1, 2, 3], [3, 4, 5]]\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4, 5, 6], 3, 2, [7])\n"
"    [[1, 2, 3], [3, 4, 5], [5, 6, 7]]\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4, 5, 6], 3, 3, [])\n"
"    [[1, 2, 3], [4, 5, 6]]\n"
"\n"

#. TRANSLATORS: def Inspect.Algebra.empty()
#: lib/inspect/algebra.ex:228
msgid ""
"Returns a document entity used to represent nothingness.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Inspect.Algebra.empty\n"
"    :doc_nil\n"
"\n"
msgstr ""
"無を代表するのに用いられるドキュメントエントリを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Inspect.Algebra.empty\n"
"    :doc_nil\n"
"\n"

#. TRANSLATORS: def Code.ensure_loaded?(module)
#: lib/code.ex:441
msgid ""
"Ensures the given module is loaded.\n"
"\n"
"Similar to `ensure_loaded/1`, but returns `true` if the module\n"
"is already loaded or was successfully loaded. Returns `false`\n"
"otherwise.\n"
msgstr ""
"与えられたモジュールがロードされたことを確実にします。\n"
"\n"
"`ensure_loaded/1`と似ていますが、モジュールが既に\n"
"ロードされたか、ロードに成功したら、`true`を返します。\n"
"さもなければ`false`を返します。\n"

#. TRANSLATORS: def Code.ensure_loaded(module)
#: lib/code.ex:430
msgid ""
"Ensures the given module is loaded.\n"
"\n"
"If the module is already loaded, this works as no-op. If the module\n"
"was not yet loaded, it tries to load it.\n"
"\n"
"If it succeeds loading the module, it returns `{:module, module}`.\n"
"If not, returns `{:error, reason}` with the error reason.\n"
"\n"
"## Code loading on the Erlang VM\n"
"\n"
"Erlang has two modes to load code: interactive and embedded.\n"
"\n"
"By default, the Erlang VM runs in interactive mode, where modules\n"
"are loaded as needed. In embedded mode the opposite happens, as all\n"
"modules need to be loaded upfront or explicitly.\n"
"\n"
"Therefore, this function is used to check if a module is loaded\n"
"before using it and allows one to react accordingly. For example, the `URI`\n"
"module uses this function to check if a specific parser exists for a given\n"
"URI scheme.\n"
"\n"
"## `Code.ensure_compiled/1`\n"
"\n"
"Elixir also contains an `ensure_compiled/1` function that is a\n"
"superset of `ensure_loaded/1`.\n"
"\n"
"Since Elixir's compilation happens in parallel, in some situations\n"
"you may need to use a module that was not yet compiled, therefore\n"
"it can't even be loaded.\n"
"\n"
"`ensure_compiled/1` halts the current process until the\n"
"module we are depending on is available.\n"
"\n"
"In most cases, `ensure_loaded/1` is enough. `ensure_compiled/1`\n"
"must be used in rare cases, usually involving macros that need to\n"
"invoke a module for callback information.\n"
msgstr ""
"与えられたモジュールがロードされたことを確実にします。\n"
"\n"
"もしモジュールが既にロードされていたら、no-op(なにもしない)です。\n"
"もしモジュールが未だロードされてないなら、ロードを試みます。\n"
"\n"
"モジュールのロードに成功したら、`{:module, module}`を返します。\n"
"そうでなかったら、エラーreasonとともに`{:error, reason}`を返します。\n"
"\n"
"## Erlang VMでのコードローディング\n"
"\n"
"Erlangは二つのモードを持ってます: インタラクティブとエンベデッドです。\n"
"\n"
"デフォルトでは、Erlang VMはインタラクティブモードで動き、\n"
"モジュールは必要に応じてロードされます。エンベデッドモードでは、反対に、\n"
"全てのモジュールが事前に、あるいは明示的にロードされている\n"
"必要があります。\n"
"\n"
"従って、この関数は、使う前にモジュールがロードされているかと、それに\n"
"応じて対応出来るかの、チェックに使われます。\n"
"例えば、`URI`モジュールはこの関数を、与えられたURIスキームに\n"
"対応した特定のパーサが存在するかの、チェックに使っています。\n"
"\n"
"## `Code.ensure_compiled/1`\n"
"\n"
"Elixirは、`ensure_loaded/1`のスーパーセットである、\n"
"`ensure_compiled/1`関数も含みます。\n"
"\n"
"Elixirのコンパイルは並列に起きるので、使いたいモジュールがまだコンパイルさ\n"
"れていない、いくつかのシチュエーションでは、決してそれはロードされません。\n"
"\n"
"`ensure_compile/1`は、依存しているモジュールが有効になるまで\n"
"現在のプロセスを停止させます。\n"
"\n"
"殆どの場合、`ensure_loaded/1`で十分です。`ensure_compiled/1`は、\n"
"コールバック情報の為にモジュールを起動する必要があるマクロ\n"
"を実行するような、レアなケースで使用されなければなりません。\n"

#. TRANSLATORS: def Code.ensure_compiled?(module)
#: lib/code.ex:482
msgid ""
"Ensures the given module is compiled and loaded.\n"
"\n"
"Similar to `ensure_compiled/1`, but returns `true` if the module\n"
"is already loaded or was successfully loaded and compiled.\n"
"Returns `false` otherwise.\n"
msgstr ""
"与えられたモジュールがコンパイルされ、ロードされたことを確実にします。\n"
"\n"
"`ensure_compiled/1`と似ていますが、モジュールが既にロード\n"
"されていたか、コンパイルとロードに成功したら、`true`を返します。\n"
"さもなければ、`false`を返します。\n"

#. TRANSLATORS: def Code.ensure_compiled(module)
#: lib/code.ex:458
msgid ""
"Ensures the given module is compiled and loaded.\n"
"\n"
"If the module is already loaded, it works as no-op. If the module was\n"
"not loaded yet, it checks if it needs to be compiled first and then\n"
"tries to load it.\n"
"\n"
"If it succeeds loading the module, it returns `{:module, module}`.\n"
"If not, returns `{:error, reason}` with the error reason.\n"
"\n"
"Check `ensure_loaded/1` for more information on module loading\n"
"and when to use `ensure_loaded/1` or `ensure_compiled/1`.\n"
msgstr ""
"与えられたモジュールがコンパイルされ、ロードされたことを確実にします。\n"
"\n"
"もしモジュールが既にロードされていたら、no-op(なにもしない)です。\n"
"もしモジュールが未だロードされてないなら、まずコンパイルし、それから\n"
"ロードを試みます。\n"
"\n"
"モジュールのロードに成功したら、`{:module, module}`を返します。\n"
"そうでなかったら、エラーreasonとともに`{:error, reason}`を返します。\n"
"\n"
"モジュールローディングの詳細情報と、\n"
"何時`ensure_loaded/1`と`ensure_compile/1`を利用するか\n"
"については、\n"
"`ensure_loaded/1`をチェックしてください。\n"

#. TRANSLATORS: def Application.ensure_started(app, type \\ :temporary)
#: lib/application.ex:193
msgid ""
"Ensures the given `app` is started.\n"
"\n"
"Same as `start/2` but returns `:ok` if the application was already\n"
"started. This is useful in scripts and in test setup, where test\n"
"applications need to be explicitly started:\n"
"\n"
"    :ok = Application.ensure_started(:my_test_dep)\n"
"\n"
msgstr ""
"与えられた`app`が開始しているのを確実にします。\n"
"\n"
"`start/2`と同じですが、そのアプリケーションが既に開始していたら、\n"
"`:ok`を返します。これは、スクリプト中やテストのセットアップで\n"
"テストアプリケーションを明示的に開始させる必要がある場合に、\n"
"便利です:\n"
"\n"
"    :ok = Application.ensure_started(:my_test_dep)\n"
"\n"

#. TRANSLATORS: def Application.ensure_all_started(app, type \\ :temporary)
#: lib/application.ex:205
msgid ""
"Ensures the given `app` and its applications are started.\n"
"\n"
"Same as `start/2` but also starts the applications listed under\n"
"`:applications` in the `.app` file in case they were not previously\n"
"started.\n"
msgstr ""
"与えられた`app`とそれが依存しているアプリケーションが開始していることを\n"
"確実にします。\n"
"\n"
"`start/2`と同じですが、`.app`ファイルに`:applications`でリストされている\n"
"アプリケーションも、まだ開始していない場合には、開始します。\n"

#. TRANSLATORS: def Base.encode64(data)
#: lib/base.ex:234
msgid ""
"Encodes a binary string into a base 64 encoded string.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Base.encode64(\"foobar\")\n"
"    \"Zm9vYmFy\"\n"
"\n"
msgstr ""
"バイナリ文字列をbase64エンコード文字列にエンコードします。\n"
"\n"
"## 例\n"
"\n"
"    iex> Base.encode64(\"foobar\")\n"
"    \"Zm9vYmFy\"\n"
"\n"

#. TRANSLATORS: def Enum.take_every(collection, nth)
#: lib/enum.ex:1920
msgid ""
"Returns a collection of every `nth` item in the collection,\n"
"starting with the first element.\n"
"\n"
"The second argument specifying every `nth` item must be a non-negative "
"integer.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.take_every(1..10, 2)\n"
"    [1, 3, 5, 7, 9]\n"
"\n"
msgstr ""
"コレクションの`nth`番目ごとの要素のコレクションを返します。\n"
"最初の要素からスタートします。\n"
"\n"
"`nth`番目毎を指定する2番目の引数は、非負の整数でなくてはなりま\n"
"せん。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.take_every(1..10, 2)\n"
"    [1, 3, 5, 7, 9]\n"
"\n"

#. TRANSLATORS: def Integer.to_char_list(number)
#: lib/integer.ex:228
msgid ""
"Returns a char list which corresponds to the text representation of the "
"given integer.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Integer.to_char_list(7)\n"
"    '7'\n"
"\n"
msgstr ""
"与えられた整数にテキスト表現に対応する文字のリストを返します。\n"
"\n"
"コンパイラによってインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Integer.to_char_list(7)\n"
"    '7'\n"
"\n"

#. TRANSLATORS: def Float.to_char_list(number)
#: lib/float.ex:174
msgid ""
"Returns a char list which corresponds to the text representation of the "
"given float.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Float.to_char_list(7.0)\n"
"    '7.00000000000000000000e+00'\n"
"\n"
msgstr ""
"与えられた浮動小数点数のテキスト表現に対応する文字のリストを返します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Float.to_char_list(7.0)\n"
"    '7.00000000000000000000e+00'\n"
"\n"

#. TRANSLATORS: def Integer.to_char_list(number, base)
#: lib/integer.ex:245
msgid ""
"Returns a char list which corresponds to the text representation of the\n"
"given integer in the given base.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Integer.to_char_list(1023, 16)\n"
"    '3FF'\n"
"\n"
msgstr ""
"与えられた数の与えられた基数でのテキスト表現に対応する文字のリストを\n"
"返します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Integer.to_char_list(1023, 16)\n"
"    '3FF'\n"
"\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms..(left, right)
#: lib/kernel/special_forms.ex:410
msgid ""
"Defines a remote call or an alias.\n"
"\n"
"The dot (`.`) in Elixir can be used for remote calls:\n"
"\n"
"    iex> String.downcase(\"FOO\")\n"
"    \"foo\"\n"
"\n"
"In this example above, we have used `.` to invoke `downcase` in the\n"
"`String` alias, passing \"FOO\" as argument. We can also use the dot\n"
"for creating aliases:\n"
"\n"
"    iex> Hello.World\n"
"    Hello.World\n"
"\n"
"This time, we have joined two aliases, defining the final alias\n"
"`Hello.World`.\n"
"\n"
"## Syntax\n"
"\n"
"The right side of `.` may be a word starting in upcase, which represents\n"
"an alias, a word starting with lowercase or underscore, any valid language\n"
"operator or any name wrapped in single- or double-quotes. Those are all "
"valid\n"
"examples:\n"
"\n"
"    iex> Kernel.Sample\n"
"    Kernel.Sample\n"
"\n"
"    iex> Kernel.length([1,2,3])\n"
"    3\n"
"\n"
"    iex> Kernel.+(1, 2)\n"
"    3\n"
"\n"
"    iex> Kernel.\"length\"([1,2,3])\n"
"    3\n"
"\n"
"    iex> Kernel.'+'(1, 2)\n"
"    3\n"
"\n"
"Note that `Kernel.\"HELLO\"` will be treated as a remote call and not an "
"alias.\n"
"This choice was done so every time single- or double-quotes are used, we "
"have\n"
"a remote call regardless of the quote contents. This decision is also "
"reflected\n"
"in the quoted expressions discussed below.\n"
"\n"
"## Quoted expression\n"
"\n"
"When `.` is used, the quoted expression may take two distinct\n"
"forms. When the right side starts with a lowercase letter (or\n"
"underscore):\n"
"\n"
"    iex> quote do: String.downcase(\"FOO\")\n"
"    {{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], "
"[\"FOO\"]}\n"
"\n"
"Notice we have an inner tuple, containing the atom `:.` representing\n"
"the dot as first element:\n"
"\n"
"    {:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}\n"
"\n"
"This tuple follows the general quoted expression structure in Elixir,\n"
"with the name as first argument, some keyword list as metadata as second,\n"
"and the number of arguments as third. In this case, the arguments is the\n"
"alias `String` and the atom `:downcase`. The second argument is **always**\n"
"an atom:\n"
"\n"
"    iex> quote do: String.\"downcase\"(\"FOO\")\n"
"    {{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], "
"[\"FOO\"]}\n"
"\n"
"The tuple containing `:.` is wrapped in another tuple, which actually\n"
"represents the function call, and has `\"FOO\"` as argument.\n"
"\n"
"When the right side is an alias (i.e. starts with uppercase), we get "
"instead:\n"
"\n"
"    iex> quote do: Hello.World\n"
"    {:__aliases__, [alias: false], [:Hello, :World]}\n"
"\n"
"We got into more details about aliases in the `__aliases__` special form\n"
"documentation.\n"
"\n"
"## Unquoting\n"
"\n"
"We can also use unquote to generate a remote call in a quoted expression:\n"
"\n"
"    iex> x = :downcase\n"
"    iex> quote do: String.unquote(x)(\"FOO\")\n"
"    {{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], "
"[\"FOO\"]}\n"
"\n"
"Similar to `Kernel.\"HELLO\"`, `unquote(x)` will always generate a remote "
"call,\n"
"independent of the value of `x`. To generate an alias via the quoted "
"expression,\n"
"one needs to rely on `Module.concat/2`:\n"
"\n"
"    iex> x = Sample\n"
"    iex> quote do: Module.concat(String, unquote(x))\n"
"    {{:., [], [{:__aliases__, [alias: false], [:Module]}, :concat]}, [],\n"
"     [{:__aliases__, [alias: false], [:String]}, Sample]}\n"
"\n"
msgstr ""
"リモート呼び出しかエイリアスを定義します。\n"
"\n"
"Elixirでのドット(`.`)は、リモート呼び出しに使われます:\n"
"\n"
"    iex> String.downcase(\"FOO\")\n"
"    \"foo\"\n"
"\n"
"上の例では、`.`を`String`エイリアスの`downcase`を引数として\"FOO\"を渡し、\n"
"起動するために使いました。ドットをエイリアスを作るためにも使うことが\n"
"できます:\n"
"\n"
"    iex> Hello.World\n"
"    Hello.World\n"
"\n"
"この時は、二つのエイリアスを結合し、最終的にエイリアス`Hello.World`を\n"
"定義しました。\n"
"\n"
"## 文法\n"
"\n"
"`.`の右側は以下の、エイリアス表現としての大文字で初まる単語、小文字か\n"
"下線で初まる単語、任意の有効な言語演算子あるいは、任意の単一、二重引用\n"
"符で囲まれた名前のいずれかです。\n"
"全ての有効な例です:\n"
"\n"
"    iex> Kernel.Sample\n"
"    Kernel.Sample\n"
"\n"
"    iex> Kernel.length([1,2,3])\n"
"    3\n"
"\n"
"    iex> Kernel.+(1, 2)\n"
"    3\n"
"\n"
"    iex> Kernel.\"length\"([1,2,3])\n"
"    3\n"
"\n"
"    iex> Kernel.'+'(1, 2)\n"
"    3\n"
"\n"
"`Kernel.\"HELLO\"`は、エイリアスではなく、リモート呼び出しとして扱われる\n"
"ことに、注意してください。この選択はされたので、単一または二重引用符が\n"
"使われたときは何時でも、引用された内容に関係なく、リモート呼び出しをし\n"
"ます。この決定は、以下に議論される、quoteされた式についても\n"
"反映されます。\n"
"\n"
"## quoteされた式\n"
"\n"
"`.`が使われた時、quoteされた式は二つの異ったフォームをとるかもしれませ\n"
"ん。右辺が小文字(または下線)で開始したとき:\n"
"\n"
"    iex> quote do: String.downcase(\"FOO\")\n"
"    {{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], "
"[\"FOO\"]}\n"
"\n"
"最初の要素としてドットの表現であるアトム`:.`を含む内部のタプルを持つこ\n"
"とに、注意してください:\n"
"\n"
"    {:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}\n"
"\n"
"このタプルは、\n"
"Elixirの一般的なquoteされた式の構造である、\n"
"最初の引数として名前、2番目として、メタデータ\n"
"としてのいくつかのキーワードリスト、3番目として、いくつかの引数、\n"
"に従います。\n"
"この場合、引数はエイリアス`String`とアトム`:downcase`です。\n"
"2番目の引数は **常に** アトムです:\n"
"\n"
"    iex> quote do: String.\"downcase\"(\"FOO\")\n"
"    {{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], "
"[\"FOO\"]}\n"
"\n"
"他のタプルにラップされた`:.`を含むタプルは、実際に\n"
"関数呼びだしを意味し、引数`\"FOO\"`を持ちます。\n"
"\n"
"右辺がエイリアスの時(即ち、大文字で初まる時)、そのかわりに以下を得ます:\n"
"\n"
"    iex> quote do: Hello.World\n"
"    {:__aliases__, [alias: false], [:Hello, :World]}\n"
"\n"
"aliasについての詳細は、`__alias__`スペシャルフォームのドキュメントで\n"
"得られます。\n"
"\n"
"## Unquoting\n"
"\n"
"quoteされた式で、リモート呼び出しを生成するために、unquoteを使うこともできま"
"す:\n"
"\n"
"    iex> x = :downcase\n"
"    iex> quote do: String.unquote(x)(\"FOO\")\n"
"    {{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], "
"[\"FOO\"]}\n"
"\n"
"`Kernel.\"HELLO\"`と同様に、`unquote(x)`は、`x`の値に拘わらず、\n"
"常にリモート呼び出しを生成します。quoteされた式でエイリアスを生成するため"
"に、\n"
"`Module.concat/2`に頼る必要があります:\n"
"\n"
"    iex> x = Sample\n"
"    iex> quote do: Module.concat(String, unquote(x))\n"
"    {{:., [], [{:__aliases__, [alias: false], [:Module]}, :concat]}, [],\n"
"     [{:__aliases__, [alias: false], [:String]}, Sample]}\n"
"\n"

#. TRANSLATORS: def IO.ANSI.default_color()
#: lib/io/ansi.ex:108
msgid "Default text color"
msgstr "テキスト色をデフォルトに戻す"

#. TRANSLATORS: def IO.ANSI.default_background()
#: lib/io/ansi.ex:111
msgid "Default background color"
msgstr "背景色をデフォルトに戻す"

#. TRANSLATORS: defmacro Kernel.defprotocol(name, list2)
#: lib/kernel.ex:3161
msgid ""
"Defines a protocol.\n"
"\n"
"A protocol specifies an API that should be defined by its\n"
"implementations.\n"
"\n"
"## Examples\n"
"\n"
"In Elixir, only `false` and `nil` are considered falsy values.\n"
"Everything else evaluates to true in `if` clauses. Depending\n"
"on the application, it may be important to specify a `blank?`\n"
"protocol that returns a boolean for other data types that should\n"
"be considered `blank?`. For instance, an empty list or an empty\n"
"binary could be considered blanks.\n"
"\n"
"We could implement this protocol as follow:\n"
"\n"
"    defprotocol Blank do\n"
"      @doc \"Returns true if data is considered blank/empty\"\n"
"      def blank?(data)\n"
"    end\n"
"\n"
"Now that the protocol is defined, we can implement it. We need\n"
"to implement the protocol for each Elixir type. For example:\n"
"\n"
"    # Integers are never blank\n"
"    defimpl Blank, for: Integer do\n"
"      def blank?(number), do: false\n"
"    end\n"
"\n"
"    # Just empty list is blank\n"
"    defimpl Blank, for: List do\n"
"      def blank?([]), do: true\n"
"      def blank?(_),  do: false\n"
"    end\n"
"\n"
"    # Just the atoms false and nil are blank\n"
"    defimpl Blank, for: Atom do\n"
"      def blank?(false), do: true\n"
"      def blank?(nil),   do: true\n"
"      def blank?(_),     do: false\n"
"    end\n"
"\n"
"And we would have to define the implementation for all types.\n"
"The supported types available are:\n"
"\n"
"  * Structs (see below)\n"
"  * `Tuple`\n"
"  * `Atom`\n"
"  * `List`\n"
"  * `BitString`\n"
"  * `Integer`\n"
"  * `Float`\n"
"  * `Function`\n"
"  * `PID`\n"
"  * `Map`\n"
"  * `Port`\n"
"  * `Reference`\n"
"  * `Any` (see below)\n"
"\n"
"## Protocols + Structs\n"
"\n"
"The real benefit of protocols comes when mixed with structs.\n"
"For instance, Elixir ships with many data types implemented as\n"
"structs, like `HashDict` and `HashSet`. We can implement the\n"
"`Blank` protocol for those types as well:\n"
"\n"
"    defimpl Blank, for: [HashDict, HashSet] do\n"
"      def blank?(enum_like), do: Enum.empty?(enum_like)\n"
"    end\n"
"\n"
"If a protocol is not found for a given type, it will fallback to\n"
"`Any`.\n"
"\n"
"## Fallback to any\n"
"\n"
"In some cases, it may be convenient to provide a default\n"
"implementation for all types. This can be achieved by\n"
"setting `@fallback_to_any` to `true` in the protocol\n"
"definition:\n"
"\n"
"    defprotocol Blank do\n"
"      @fallback_to_any true\n"
"      def blank?(data)\n"
"    end\n"
"\n"
"Which can now be implemented as:\n"
"\n"
"    defimpl Blank, for: Any do\n"
"      def blank?(_), do: true\n"
"    end\n"
"\n"
"One may wonder why such fallback is not true by default.\n"
"\n"
"It is two-fold: first, the majority of protocols cannot\n"
"implement an action in a generic way for all types. In fact,\n"
"providing a default implementation may be harmful, because users\n"
"may rely on the default implementation instead of providing a\n"
"specialized one.\n"
"\n"
"Second, falling back to `Any` adds an extra lookup to all types,\n"
"which is unnecessary overhead unless an implementation for Any is\n"
"required.\n"
"\n"
"## Types\n"
"\n"
"Defining a protocol automatically defines a type named `t`, which\n"
"can be used as:\n"
"\n"
"    @spec present?(Blank.t) :: boolean\n"
"    def present?(blank) do\n"
"      not Blank.blank?(blank)\n"
"    end\n"
"\n"
"The `@spec` above expresses that all types allowed to implement the\n"
"given protocol are valid argument types for the given function.\n"
"\n"
"## Reflection\n"
"\n"
"Any protocol module contains three extra functions:\n"
"\n"
"\n"
"  * `__protocol__/1` - returns the protocol name when `:name` is given, and "
"a\n"
"    keyword list with the protocol functions when `:functions` is given\n"
"\n"
"  * `impl_for/1` - receives a structure and returns the module that\n"
"    implements the protocol for the structure, `nil` otherwise\n"
"\n"
"  * `impl_for!/1` - same as above but raises an error if an implementation "
"is\n"
"    not found\n"
"\n"
"## Consolidation\n"
"\n"
"In order to cope with code loading in development, protocols in\n"
"Elixir provide a slow implementation of protocol dispatching specific\n"
"to development.\n"
"\n"
"In order to speed up dispatching in production environments, where\n"
"all implementations are known up-front, Elixir provides a feature\n"
"called protocol consolidation. For this reason, all protocols are\n"
"compiled with `debug_info` set to true, regardless of the option\n"
"set by `elixirc` compiler. The debug info though may be removed\n"
"after consolidation.\n"
"\n"
"For more information on how to apply protocol consolidation to\n"
"a given project, please check the functions in the `Protocol`\n"
"module or the `mix compile.protocols` task.\n"
msgstr ""
"プロトコルを定義します。\n"
"\n"
"プロトコルは、その実装により定義されるべきAPIを、\n"
"指定します。\n"
"\n"
"## 例\n"
"\n"
"Elixirでは、`false`と`nil`だけが偽の値として考慮されます。`if`節の中で\n"
"は、その他全ては真に評価します。アプリケーションによっては、`空白類?`と\n"
"思わなければならない他のデータタイプの為にブーリアンを返す、`blank?`プ\n"
"ロトコルを指定することが重要かもしれません。\n"
"例えば、空のリストや空のバイナリは空白類と考えることができます。\n"
"\n"
"以下のようにこのプロトコルを実装できます:\n"
"\n"
"    defprotocol Blank do\n"
"      @doc \"Returns true if data is considered blank/empty\"\n"
"      def blank?(data)\n"
"    end\n"
"\n"
"プロトコルが定義された今、それを実装することができます。\n"
"それぞれのElixirタイプについてプロトコルを実装する必要があります。\n"
"例えば:\n"
"\n"
"    # Integers are never blank\n"
"    defimpl Blank, for: Integer do\n"
"      def blank?(number), do: false\n"
"    end\n"
"\n"
"    # Just empty list is blank\n"
"    defimpl Blank, for: List do\n"
"      def blank?([]), do: true\n"
"      def blank?(_),  do: false\n"
"    end\n"
"\n"
"    # Just the atoms false and nil are blank\n"
"    defimpl Blank, for: Atom do\n"
"      def blank?(false), do: true\n"
"      def blank?(nil),   do: true\n"
"      def blank?(_),     do: false\n"
"    end\n"
"\n"
"そして、全てのタイプに実装を定義しなければなりません。\n"
"サポートされている有効なタイプは以下のとおりです:\n"
"\n"
"  * Structs (see below)\n"
"  * `Tuple`\n"
"  * `Atom`\n"
"  * `List`\n"
"  * `BitString`\n"
"  * `Integer`\n"
"  * `Float`\n"
"  * `Function`\n"
"  * `PID`\n"
"  * `Map`\n"
"  * `Port`\n"
"  * `Reference`\n"
"  * `Any` (see below)\n"
"\n"
"## Protocols + Structs\n"
"\n"
"プロトコルの本当の利点は構造体との組み合わせた時です。\n"
"例えば、Elixirは`HashDict`や`HashSet`のような構造体として\n"
"多くのデータタイプを提供しています。\n"
"それらのタイプのために`Blank`プロトコルを実装することが\n"
"できます:\n"
"\n"
"    defimpl Blank, for: [HashDict, HashSet] do\n"
"      def blank?(enum_like), do: Enum.empty?(enum_like)\n"
"    end\n"
"\n"
"もしプロトコルが与えられたタイプに見付からないなら、`Any`に\n"
"フォールバックします。\n"
"\n"
"## Fallback to any\n"
"\n"
"いくつかの場合、全てのタイプの為のデフォルト実装を提供することが\n"
"便利かもしれません。これはプロトコル定義で、\n"
"`@fallback_to_any`を`true`にセットすることで達成できます:\n"
"\n"
"    defprotocol Blank do\n"
"      @fallback_to_any true\n"
"      def blank?(data)\n"
"    end\n"
"\n"
"今や、このように実装できます:\n"
"\n"
"    defimpl Blank, for: Any do\n"
"      def blank?(_), do: true\n"
"    end\n"
"\n"
"なぜ、デフォルトでそのようなフォールバックがtrueでないのか、\n"
"疑問に思うかもしれません。\n"
"\n"
"二つの理由があります: 第一に、大多数のプロトコルが\n"
"全てのタイプのために一般的な方法でアクションを実装することが\n"
"出来ません。実際、ユーザは専門のものを提供する代りに、デフォルト\n"
"実装に頼るかもしれないので、デフォルト実装を提供することは、有害であるかも\n"
"しれません。\n"
"\n"
"第二に、`Any`へのフォールバックは全てのデータタイプに余分の検索を追加し\n"
"ます。Anyの実装を必要とされない限り、それは不必要なオーバーヘッドです。\n"
"\n"
"## Types\n"
"\n"
"プロトコルを定義すると、自動的に`t`と呼ばれるタイプを定義します。\n"
"それは以下のように使うことができます:\n"
"\n"
"    @spec present?(Blank.t) :: boolean\n"
"    def present?(blank) do\n"
"      not Blank.blank?(blank)\n"
"    end\n"
"\n"
"上の`@spec`は、与えられたプロトコルを実装することを許された全てのタイプ\n"
"が、与えられた関数の有効な引数のタイプであることを、表します。\n"
"\n"
"## Reflection\n"
"\n"
"任意のプトロコルモジュールは3つの特別な関数を含みます:\n"
"\n"
"  * `__protocol__/1` - `:name`が与えられたらプロトコル名を返します。\n"
"    `:functions`が与えられたらプロトコルの関数のキーワードリストを返します\n"
"\n"
"  * `impl_for/1` - 構造体を受け取り、その構造体のプロトコルを実装した\n"
"    モジュールを返します。さもなければ`nil`を返します\n"
"\n"
"  * `impl_for!/1` - 上と同じですが、実装が見付からないときにエラーを上げま"
"す\n"
"\n"
"## Consolidation\n"
"\n"
"開発においてコードローディングに対処するために、Elixirのプロトコルは\n"
"開発に特有の遲いプロトコルディスパッチ実装を提供します。\n"
"\n"
"プロダクション環境でディスパッチをスピードアップするために、\n"
"全ての実装は事前に知られているところで、Elixirはプロトコル強化と\n"
"呼ばれている機能を提供します。\n"
"このため、全てのプロトコルは、`elixirc`コンパイラに\n"
"よるオプションの設定に関わりなく、`debug_info`がtrueでコンパイルされます。\n"
"debug infoは強化の後で取り除かれます。\n"
"\n"
"どのようにプロトコル強化をプロジェクトに適用するかについての詳細は、\n"
"`Protocol`モジュールの関数か、`mix compile.protocols`タスクをチェックし\n"
"てください。\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.<<>>(args)
#: lib/kernel/special_forms.ex:311
msgid ""
"Defines a new bitstring.\n"
"\n"
"## Examples\n"
"\n"
"    iex> << 1, 2, 3 >>\n"
"    << 1, 2, 3 >>\n"
"\n"
"## Bitstring types\n"
"\n"
"A bitstring is made of many segments. Each segment has a\n"
"type, which defaults to integer:\n"
"\n"
"    iex> <<1, 2, 3>>\n"
"    <<1, 2, 3>>\n"
"\n"
"Elixir also accepts by default the segment to be a literal\n"
"string or a literal char list, which are by expanded to integers:\n"
"\n"
"    iex> <<0, \"foo\">>\n"
"    <<0, 102, 111, 111>>\n"
"\n"
"Any other type needs to be explicitly tagged. For example,\n"
"in order to store a float type in the binary, one has to do:\n"
"\n"
"    iex> <<3.14 :: float>>\n"
"    <<64, 9, 30, 184, 81, 235, 133, 31>>\n"
"\n"
"This also means that variables need to be explicitly tagged,\n"
"otherwise Elixir defaults to integer:\n"
"\n"
"    iex> rest = \"oo\"\n"
"    iex> <<102, rest>>\n"
"    ** (ArgumentError) argument error\n"
"\n"
"We can solve this by explicitly tagging it as a binary:\n"
"\n"
"    <<102, rest :: binary>>\n"
"\n"
"The type can be integer, float, bitstring/bits, binary/bytes,\n"
"utf8, utf16 or utf32, e.g.:\n"
"\n"
"    <<102 :: float, rest :: binary>>\n"
"\n"
"An integer can be any arbitrary precision integer. A float is an\n"
"IEEE 754 binary32 or binary64 floating point number. A bitstring\n"
"is an arbitrary series of bits. A binary is a special case of\n"
"bitstring that has a total size divisible by 8.\n"
"\n"
"The utf8, utf16, and utf32 types are for unicode codepoints. They\n"
"can also be applied to literal strings and char lists:\n"
"\n"
"    iex> <<\"foo\" :: utf16>>\n"
"    <<0,102,0,111,0,111>>\n"
"\n"
"The bits type is an alias for bitstring. The bytes type is an\n"
"alias for binary.\n"
"\n"
"The signedness can also be given as signed or unsigned. The\n"
"signedness only matters for matching and relevant only for\n"
"integers. If unspecified, it defaults to unsigned. Example:\n"
"\n"
"    iex> <<-100 :: signed, _rest :: binary>> = <<-100, \"foo\">>\n"
"    <<156,102,111,111>>\n"
"\n"
"This match would have failed if we did not specify that the\n"
"value -100 is signed. If we're matching into a variable instead\n"
"of a value, the signedness won't be checked; rather, the number\n"
"will simply be interpreted as having the given (or implied)\n"
"signedness, e.g.:\n"
"\n"
"    iex> <<val, _rest :: binary>> = <<-100, \"foo\">>\n"
"    iex> val\n"
"    156\n"
"\n"
"Here, `val` is interpreted as unsigned.\n"
"\n"
"The endianness of a segment can be big, little or native (the\n"
"latter meaning it will be resolved at VM load time).\n"
"\n"
"Many options can be given by using `-` as separator, order is\n"
"arbitrary. The following are all the same:\n"
"\n"
"    <<102 :: integer-native, rest :: binary>>\n"
"    <<102 :: native-integer, rest :: binary>>  \n"
"    <<102 :: unsigned-big-integer, rest :: binary>>\n"
"    <<102 :: unsigned-big-integer-size(8), rest :: binary>>\n"
"    <<102 :: unsigned-big-integer-8, rest :: binary>>\n"
"    <<102 :: 8-integer-big-unsigned, rest :: binary>>\n"
"    <<102, rest :: binary>>\n"
"\n"
"And so on.\n"
"\n"
"Endianness only makes sense for integers and some UTF code\n"
"point types (utf16 and utf32).\n"
"\n"
"Finally, we can also specify size and unit for each segment. The\n"
"unit is multiplied by the size to give the effective size of\n"
"the segment in bits. The default unit for integers, floats,\n"
"and bitstrings is 1. For binaries, it is 8.\n"
"\n"
"Since integers are default, the default unit is 1. The example below\n"
"matches because the string \"foo\" takes 24 bits and we match it\n"
"against a segment of 24 bits, 8 of which are taken by the integer\n"
"102 and the remaining 16 bits are specified on the rest.\n"
"\n"
"    iex> <<102, _rest :: size(16)>> = \"foo\"\n"
"    \"foo\"\n"
"\n"
"We can also match by specifying size and unit explicitly:\n"
"\n"
"    iex> <<102, _rest :: size(2)-unit(8)>> = \"foo\"\n"
"    \"foo\"\n"
"\n"
"However, if we expect a size of 32, it won't match:\n"
"\n"
"    iex> <<102, _rest :: size(32)>> = \"foo\"\n"
"    ** (MatchError) no match of right hand side value: \"foo\"\n"
"\n"
"Size and unit are not applicable to utf8, utf16, and utf32.\n"
"\n"
"The default size for integers is 8. For floats, it is 64. For\n"
"binaries, it is the size of the binary. Only the last binary\n"
"in a binary match can use the default size (all others must\n"
"have their size specified explicitly).\n"
"\n"
"    iex> <<3.14 :: float>>\n"
"    <<64, 9, 30, 184, 81, 235, 133, 31>>\n"
"    iex> <<3.14 :: float-32>>\n"
"    <<64, 72, 245, 195>>\n"
"\n"
"Size and unit can also be specified using a syntax shortcut\n"
"when passing integer values:\n"
"\n"
"    << x :: 8 >> == << x :: size(8) >>\n"
"    << x :: 8 * 4 >> == << x :: size(8)-unit(4) >>\n"
"    << x :: _ * 4 >> == << x :: unit(4) >>\n"
"\n"
"This syntax reflects the fact the effective size is given by\n"
"multiplying the size by the unit.\n"
"\n"
"For floats, `size * unit` must result in 32 or 64, corresponding\n"
"to binary32 and binary64, respectively.\n"
msgstr ""
"新しいbitstringを定義します。\n"
"\n"
"## 例\n"
"\n"
"    iex> << 1, 2, 3 >>\n"
"    << 1, 2, 3 >>\n"
"\n"
"## Bitstringタイプ\n"
"\n"
"bitstringは多くのセグメントで出来ています。それぞれのセグメントは\n"
"デフォルトは整数のタイプを持っています:\n"
"\n"
"    iex> <<1, 2, 3>>\n"
"    <<1, 2, 3>>\n"
"\n"
"Elixirはリテラル文字列あるいはリテラル文字のリストのセグメントも\n"
"デフォルトで受け付け、整数に展開されます:\n"
"\n"
"    iex> <<0, \"foo\">>\n"
"    <<0, 102, 111, 111>>\n"
"\n"
"他の任意のタイプは明示的にタグづけされる必要があります。例えば、\n"
"バイナリでfloatタイプをストアするために、下のようにします:\n"
"\n"
"    iex> <<3.14 :: float>>\n"
"    <<64, 9, 30, 184, 81, 235, 133, 31>>\n"
"\n"
"これは、変数は明示的にタグづけされる必要があることも意味します。\n"
"さもないと、Elixirはデフォルトの整数として扱おうとします:\n"
"\n"
"    iex> rest = \"oo\"\n"
"    iex> <<102, rest>>\n"
"    ** (ArgumentError) argument error\n"
"\n"
"明示的にバイナリとタグづけすることによって、この問題を解決できます:\n"
"\n"
"    <<102, rest :: binary>>\n"
"\n"
"タイプはinteger, float, bitstring/bits, binary/types, utf8, utf16, \n"
"utf32が可能です。例えば:\n"
"\n"
"    <<102 :: float, rest :: binary>>\n"
"\n"
"integerは任意の精度の整数が可能です。floatはIEEE754 binary32か\n"
"binary64浮動小数点数です。bitstringは任意のbit列です。binaryは\n"
"bitstringの特別な場合で合計の大きさが8の倍数です。\n"
"\n"
"utf8, utf16, utf32タイプはunicodeコードポイントです。\n"
"それらはリテラルの文字列と文字リストにも適用できます:\n"
"\n"
"    iex> <<\"foo\" :: utf16>>\n"
"    <<0,102,0,111,0,111>>\n"
"\n"
"bitsタイプはbitstringの別名です。bytesタイプはbinaryの\n"
"別名です。\n"
"符号の有無はsignedかunsignedとして与えることも出来ます。\n"
"符号の有無は、整数の為だけにあって、マッチングに重要なだけです。\n"
"もし指定されなければ、デフォルトはunsignedです。例は:\n"
"\n"
"    iex> <<-100 :: signed, _rest :: binary>> = <<-100, \"foo\">>\n"
"    <<156,102,111,111>>\n"
"\n"
"もし値-100がsignedと指定しなかったら、このマッチは失敗したでしょう。\n"
"もし値の代りに変数にマッチングさせたら、符号の有無はチェックされません;\n"
"むしろ、与えられた(または意味される)符号の有無を持つとして、\n"
"単に解釈されます。例えば:\n"
"\n"
"    iex> <<val, _rest :: binary>> = <<-100, \"foo\">>\n"
"    iex> val\n"
"    156\n"
"\n"
"ここで、`val`はunsignedとして解釈されています。\n"
"\n"
"セグメントのエンディアンはbig、little, native(その意味は\n"
"VMのロード時に解決されます)が可能です。\n"
"\n"
"セパレータとして`-`を使うことにより、多くのオプションを指定すること\n"
"ができます。以下は全て同じです:\n"
"\n"
"    <<102 :: integer-native, rest :: binary>>\n"
"    <<102 :: native-integer, rest :: binary>>\n"
"    <<102 :: unsigned-big-integer, rest :: binary>>\n"
"    <<102 :: unsigned-big-integer-size(8), rest :: binary>>\n"
"    <<102 :: unsigned-big-integer-8, rest :: binary>>\n"
"    <<102 :: 8-integer-big-unsigned, rest :: binary>>\n"
"    <<102, rest :: binary>>\n"
"\n"
"そしてその他。\n"
"\n"
"エンディアンはintegerといくつかのUTFコードポイントタイプ\n"
"(utf16とutf32)でのみ意味をなすだけです。\n"
"\n"
"最後に、それぞれのセグメントにsizeとunitを指定することもできます。\n"
"unitはbitでセグメントの実質的なサイズを与えるために、\n"
"sizeによって掛け算されます。\n"
"デフォルトunitは、integer, float, bitstringでは1です。binaryでは8です。\n"
"\n"
"integerがデフォルトなので、デフォルトunitは1です。\n"
"下の例では、文字列\"foo\"が24ビットをとります。その24ビットのセグメント\n"
"に対して、整数102により8ビットと、のこり16bitは_restにより指定さ\n"
"れているので、マッチします。\n"
"\n"
"    iex> <<102, _rest :: size(16)>> = \"foo\"\n"
"    \"foo\"\n"
"\n"
"sizeとunitを明示的に指定することによってマッチさせることもできます:\n"
"\n"
"    iex> <<102, _rest :: size(2)-unit(8)>> = \"foo\"\n"
"    \"foo\"\n"
"\n"
"しかしながら、この例でsizeを32にすると、マッチしません:\n"
"\n"
"    iex> <<102, _rest :: size(32)>> = \"foo\"\n"
"    ** (MatchError) no match of right hand side value: \"foo\"\n"
"\n"
"sizeとunitはutf8, utf16, utf32には適用されません。\n"
"\n"
"integerのデフォルトのsizeは8です。floatは64です。binaryはbinaryの大きさ\n"
"です。最後のbinaryのマッチにだけは、デフォルトsizeを使うことができます\n"
"(他の全てはsizeを明示的に指定されていなければなりません)。\n"
"\n"
"    iex> <<3.14 :: float>>\n"
"    <<64, 9, 30, 184, 81, 235, 133, 31>>\n"
"    iex> <<3.14 :: float-32>>\n"
"    <<64, 72, 245, 195>>\n"
"\n"
"\n"
"sizeとunitは、構文上のショートカットを使って指定することも\n"
"できます:\n"
"\n"
"    << x :: 8 >> == << x :: size(8) >>\n"
"    << x :: 8 * 4 >> == << x :: size(8)-unit(4) >>\n"
"    << x :: _ * 4 >> == << x :: unit(4) >>\n"
"\n"
"実際の大きさがsizeとunitの掛け算によって与えられるという事実を、\n"
"この構文は反映しています。\n"
"\n"
"floatでは、`size * unit`は、binary32とbinary64にそれぞれ一致する、\n"
"32か64でなければなりません。\n"

#. TRANSLATORS: defmacro Kernel.Typespec.deftypep(type)
#: lib/kernel/typespec.ex:249
msgid ""
"Defines a private type.\n"
"This macro is responsible for handling the attribute `@typep`.\n"
"\n"
"## Examples\n"
"\n"
"    @typep my_type :: atom\n"
"\n"
msgstr ""
"プライベートタイプを定義します。\n"
"このマクロは属性`@typep`をハンドルする役割りを果します。\n"
"\n"
"## 例\n"
"\n"
"    @typep my_type :: atom\n"
"\n"

#. TRANSLATORS: def Keyword.drop(keywords, keys)
#: lib/keyword.ex:539
msgid ""
"Drops the given keys from the keyword list.\n"
"\n"
"Duplicated keys are preserved in the new keyword list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> d = [a: 1, b: 2, c: 3, d: 4]\n"
"    iex> Keyword.drop(d, [:b, :d])\n"
"    [a: 1, c: 3]\n"
"\n"
"    iex> d = [a: 1, b: 2, b: 3, c: 3, d: 4, a: 5]\n"
"    iex> Keyword.drop(d, [:b, :d])\n"
"    [a: 1, c: 3, a: 5]\n"
"\n"
msgstr ""
"キーワードリストから与えられたキーリストのエントリを削除します。\n"
"\n"
"重複したキーは新しいキーワードリストに保存されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> d = [a: 1, b: 2, c: 3, d: 4]\n"
"    iex> Keyword.drop(d, [:b, :d])\n"
"    [a: 1, c: 3]\n"
"\n"
"    iex> d = [a: 1, b: 2, b: 3, c: 3, d: 4, a: 5]\n"
"    iex> Keyword.drop(d, [:b, :d])\n"
"    [a: 1, c: 3, a: 5]\n"
"\n"

#. TRANSLATORS: def Enum.drop(collection, count)
#: lib/enum.ex:485
msgid ""
"Drops the first `count` items from `collection`.\n"
"\n"
"If a negative value `count` is given, the last `count`\n"
"values will be dropped. The collection is enumerated\n"
"once to retrieve the proper index and the remaining\n"
"calculation is performed from the end.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.drop([1, 2, 3], 2)\n"
"    [3]\n"
"\n"
"    iex> Enum.drop([1, 2, 3], 10)\n"
"    []\n"
"\n"
"    iex> Enum.drop([1, 2, 3], 0)\n"
"    [1,2,3]\n"
"\n"
"    iex> Enum.drop([1, 2, 3], -1)\n"
"    [1,2]\n"
"\n"
msgstr ""
"最初の`count`個のアイテムを`collection`から削除します。\n"
"\n"
"もし負の`count`が与えられたら、最後の`count`個が削除されます。\n"
"コレクションは適切なインデックスを取り出すために\n"
"一度列挙され、残りの計算は終わりから実行されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.drop([1, 2, 3], 2)\n"
"    [3]\n"
"\n"
"    iex> Enum.drop([1, 2, 3], 10)\n"
"    []\n"
"\n"
"    iex> Enum.drop([1, 2, 3], 0)\n"
"    [1,2,3]\n"
"\n"
"    iex> Enum.drop([1, 2, 3], -1)\n"
"    [1,2]\n"
"\n"

#. TRANSLATORS: def Enum.drop_while(collection, fun)
#: lib/enum.ex:513
msgid ""
"Drops items at the beginning of `collection` while `fun` returns `true`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.drop_while([1, 2, 3, 4, 5], fn(x) -> x < 3 end)\n"
"    [3,4,5]\n"
"\n"
msgstr ""
"`collection`の先頭から、`fun`が`true`を返すアイテムを削除します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.drop_while([1, 2, 3, 4, 5], fn(x) -> x < 3 end)\n"
"    [3,4,5]\n"
"\n"

#. TRANSLATORS: def Inspect.Algebra.break(s)
#: lib/inspect/algebra.ex:298
msgid ""
"Document entity representing a break.\n"
"\n"
"This break can be rendered as a linebreak or as spaces,\n"
"depending on the `mode` of the chosen layout or the provided\n"
"separator.\n"
"\n"
"## Examples\n"
"\n"
"Let's glue two docs together with a break and then render it:\n"
"\n"
"    iex> doc = Inspect.Algebra.glue(\"a\", \" \", \"b\")\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"a\", \" \", \"b\"]\n"
"\n"
"Notice the break was represented as is, because we haven't reached\n"
"a line limit. Once we do, it is replaced by a newline:\n"
"\n"
"    iex> doc = Inspect.Algebra.glue(String.duplicate(\"a\", 20), \" \", \"b"
"\")\n"
"    iex> Inspect.Algebra.format(doc, 10)\n"
"    [\"aaaaaaaaaaaaaaaaaaaa\", \"\\n\", \"b\"]\n"
"\n"
msgstr ""
"ドキュメントエンティティのブレークを意味します。\n"
"\n"
"このブレークは、選ばれたレイアウトのモードか提供されたセパレータに従っ\n"
"て、ラインブレークかスペースとして生成されます。\n"
"\n"
"## 例\n"
"\n"
"ブレークと一緒に二つのdocを接着して、それをレンダリンクしてみます:\n"
"\n"
"    iex> doc = Inspect.Algebra.glue(\"a\", \" \", \"b\")\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"a\", \" \", \"b\"]\n"
"\n"
"行の制限に達しなかったので、ブレークが現状のまま表現されたことに注意し\n"
"てください。一旦そうすれば、改行文字と置換されます:\n"
"\n"
"    iex> doc = Inspect.Algebra.glue(String.duplicate(\"a\", 20), \" \", \"b"
"\")\n"
"    iex> Inspect.Algebra.format(doc, 10)\n"
"    [\"aaaaaaaaaaaaaaaaaaaa\", \"\\n\", \"b\"]\n"
"\n"

#. TRANSLATORS: def List.update_at(list, index, fun)
#: lib/list.ex:406
msgid ""
"Returns a list with an updated value at the specified `index`.\n"
"Negative indices indicate an offset from the end of the list.\n"
"If `index` is out of bounds, the original `list` is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.update_at([1, 2, 3], 0, &(&1 + 10))\n"
"    [11, 2, 3]\n"
"\n"
"    iex> List.update_at([1, 2, 3], 10, &(&1 + 10))\n"
"    [1, 2, 3]\n"
"\n"
"    iex> List.update_at([1, 2, 3], -1, &(&1 + 10))\n"
"    [1, 2, 13]\n"
"\n"
"    iex> List.update_at([1, 2, 3], -10, &(&1 + 10))\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
"`index`で指定された場所の値をfunで更新したリストを返します。\n"
"負のインデックスはリストの末尾からのオフセットを示します。\n"
"もし`index`が境界の外なら、オリジナルの`list`が返されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.update_at([1, 2, 3], 0, &(&1 + 10))\n"
"    [11, 2, 3]\n"
"\n"
"    iex> List.update_at([1, 2, 3], 10, &(&1 + 10))\n"
"    [1, 2, 3]\n"
"\n"
"    iex> List.update_at([1, 2, 3], -1, &(&1 + 10))\n"
"    [1, 2, 13]\n"
"\n"
"    iex> List.update_at([1, 2, 3], -10, &(&1 + 10))\n"
"    [1, 2, 3]\n"
"\n"

#. TRANSLATORS: def List.replace_at(list, index, value)
#: lib/list.ex:377
msgid ""
"Returns a list with a replaced value at the specified `index`.\n"
"Negative indices indicate an offset from the end of the list.\n"
"If `index` is out of bounds, the original `list` is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.replace_at([1, 2, 3], 0, 0)\n"
"    [0, 2, 3]\n"
"\n"
"    iex> List.replace_at([1, 2, 3], 10, 0)\n"
"    [1, 2, 3]\n"
"\n"
"    iex> List.replace_at([1, 2, 3], -1, 0)\n"
"    [1, 2, 0]\n"
"\n"
"    iex> List.replace_at([1, 2, 3], -10, 0)\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
"`index`で指定された場所の値を入れ替えたリストを返します。\n"
"負のインデックスはリストの末尾からのオフセットを示します。\n"
"もし`index`が境界の外なら、オリジナルの`list`が返されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.replace_at([1, 2, 3], 0, 0)\n"
"    [0, 2, 3]\n"
"\n"
"    iex> List.replace_at([1, 2, 3], 10, 0)\n"
"    [1, 2, 3]\n"
"\n"
"    iex> List.replace_at([1, 2, 3], -1, 0)\n"
"    [1, 2, 0]\n"
"\n"
"    iex> List.replace_at([1, 2, 3], -10, 0)\n"
"    [1, 2, 3]\n"
"\n"

#. TRANSLATORS: def List.insert_at(list, index, value)
#: lib/list.ex:348
msgid ""
"Returns a list with `value` inserted at the specified `index`.\n"
"Note that `index` is capped at the list length. Negative indices\n"
"indicate an offset from the end of the list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.insert_at([1, 2, 3, 4], 2, 0)\n"
"    [1, 2, 0, 3, 4]\n"
"\n"
"    iex> List.insert_at([1, 2, 3], 10, 0)\n"
"    [1, 2, 3, 0]\n"
"\n"
"    iex> List.insert_at([1, 2, 3], -1, 0)\n"
"    [1, 2, 3, 0]\n"
"\n"
"    iex> List.insert_at([1, 2, 3], -10, 0)\n"
"    [0, 1, 2, 3]\n"
"\n"
msgstr ""
"`value`を指定された`index`の位置に挿入したリストを返します。\n"
"`index`は、リストの長さでキャップされることに注意してください。\n"
"負のインデックスはリストの末尾からのオフセットを指示します。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.insert_at([1, 2, 3, 4], 2, 0)\n"
"    [1, 2, 0, 3, 4]\n"
"\n"
"    iex> List.insert_at([1, 2, 3], 10, 0)\n"
"    [1, 2, 3, 0]\n"
"\n"
"    iex> List.insert_at([1, 2, 3], -1, 0)\n"
"    [1, 2, 3, 0]\n"
"\n"
"    iex> List.insert_at([1, 2, 3], -10, 0)\n"
"    [0, 1, 2, 3]\n"
"\n"

#. TRANSLATORS: def Float.to_char_list(float, options)
#: lib/float.ex:196
msgid ""
"Returns a list which corresponds to the text representation\n"
"of `float`.\n"
"\n"
"## Options\n"
"\n"
"  * `:decimals`   — number of decimal points to show\n"
"  * `:scientific` — number of decimal points to show, in scientific format\n"
"  * `:compact`    — when true, use the most compact representation (ignored\n"
"                    with the `scientific` option)\n"
"\n"
"## Examples\n"
"\n"
"    iex> Float.to_char_list 7.1, [decimals: 2, compact: true]\n"
"    '7.1'\n"
"\n"
msgstr ""
"`float`のテキスト表現に対応するリストを返します。\n"
"\n"
"## オプション\n"
"\n"
"  * `:decimals`   —  表示する小数点以下の桁数\n"
"  * `:scientific` —  科学的フォーマットでの小数点以下の桁数\n"
"  * `:compact`    —  trueの時、最もコンパクトな表現にします(ただし\n"
"                     `scientific`オプションがあるときはこのオプションは\n"
"                     無視されます)\n"
"\n"
"## 例\n"
"\n"
"    iex> Float.to_char_list 7.1, [decimals: 2, compact: true]\n"
"    '7.1'\n"
"\n"

#. TRANSLATORS: def Macro.decompose_call(arg1)
#: lib/macro.ex:272
msgid ""
"Decomposes a local or remote call into its remote part (when provided),\n"
"function name and argument list.\n"
"\n"
"Returns `:error` when an invalid call syntax is provided.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Macro.decompose_call(quote do: foo)\n"
"    {:foo, []}\n"
"\n"
"    iex> Macro.decompose_call(quote do: foo())\n"
"    {:foo, []}\n"
"\n"
"    iex> Macro.decompose_call(quote do: foo(1, 2, 3))\n"
"    {:foo, [1, 2, 3]}\n"
"\n"
"    iex> Macro.decompose_call(quote do: Elixir.M.foo(1, 2, 3))\n"
"    {{:__aliases__, [], [:Elixir, :M]}, :foo, [1, 2, 3]}\n"
"\n"
"    iex> Macro.decompose_call(quote do: 42)\n"
"    :error\n"
"\n"
msgstr ""
"ローカルかリモート呼び出しを、リモートパート(あれば)と関数名と\n"
"引数リストに分解します。\n"
"\n"
"無効な呼び出し構文の場合、`:error`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Macro.decompose_call(quote do: foo)\n"
"    {:foo, []}\n"
"\n"
"    iex> Macro.decompose_call(quote do: foo())\n"
"    {:foo, []}\n"
"\n"
"    iex> Macro.decompose_call(quote do: foo(1, 2, 3))\n"
"    {:foo, [1, 2, 3]}\n"
"\n"
"    iex> Macro.decompose_call(quote do: Elixir.M.foo(1, 2, 3))\n"
"    {{:__aliases__, [], [:Elixir, :M]}, :foo, [1, 2, 3]}\n"
"\n"
"    iex> Macro.decompose_call(quote do: 42)\n"
"    :error\n"
"\n"

#. TRANSLATORS: def Process.list()
#: lib/process.ex:236
msgid ""
"Returns a list of process identifiers corresponding to all the\n"
"processes currently existing on the local node.\n"
"\n"
"Note that a process that is exiting, exists but is not alive, i.e.,\n"
"`alive?/1` will return `false` for a process that is exiting,\n"
"but its process identifier will be part of the result returned.\n"
"\n"
"See http://www.erlang.org/doc/man/erlang.html#processes-0 for more info.\n"
msgstr ""
"ローカルノードに現在存在する、全てのプロセスに対応する\n"
"プロセス識別子のリストを返します。\n"
"\n"
"生きていないが、存在する、即ち`alive?/1`が`false`を返すような、終了しよ\n"
"うとしているプロセスのプロセス識別子は、返された結果の一部に含まれるこ\n"
"とに気を付けてください。\n"
"\n"
"詳細は http://www.erlang.org/doc/man/erlang.html#processes-0 を参照して\n"
"ください。\n"

#. TRANSLATORS: def Node.list(args)
#: lib/node.ex:79
msgid ""
"Returns a list of nodes according to argument given.\n"
"\n"
"The result returned when the argument is a list, is the list of nodes\n"
"satisfying the disjunction(s) of the list elements.\n"
"\n"
"See http://www.erlang.org/doc/man/erlang.html#nodes-1 for more info.\n"
msgstr ""
"与えられた引数に関連するノードのリストを返します。\n"
"\n"
"引数がリストの時、リストのそれぞれの要素のOR条件を満たすノードのリスト\n"
"が結果として返されます。\n"
"\n"
"詳細は、 http://www.erlang.org/doc/man/erlang.html#nodes-1 を参照してく\n"
"ださい。\n"

#. TRANSLATORS: def Process.registered()
#: lib/process.ex:323
msgid ""
"Returns a list of names which have been registered using `register/2`.\n"
msgstr "`register/2`を使って登録された、名前のリストを返します。\n"

#. TRANSLATORS: def Protocol.consolidate(protocol, types)
#: lib/protocol.ex:265
msgid ""
"Receives a protocol and a list of implementations and\n"
"consolidates the given protocol.\n"
"\n"
"Consolidation happens by changing the protocol `impl_for`\n"
"in the abstract format to have fast lookup rules. Usually\n"
"the list of implementations to use during consolidation\n"
"are retrieved with the help of `extract_impls/2`.\n"
"\n"
"It returns the updated version of the protocol bytecode.\n"
"A given bytecode or protocol implementation can be checked\n"
"to be consolidated or not by analyzing the protocol\n"
"attribute:\n"
"\n"
"    Protocol.consolidated?(Enumerable)\n"
"\n"
"If the first element of the tuple is true, it means\n"
"the protocol was consolidated.\n"
"\n"
"This function does not load the protocol at any point\n"
"nor loads the new bytecode for the compiled module.\n"
"However each implementation must be available and\n"
"it will be loaded.\n"
msgstr ""
"プロトコルと実装のリストを受け取り、与えられたプロトコルを\n"
"強化します。\n"
"\n"
"速い検索規則を持つために抽象的なフォーマットで\n"
"`impl_for`プロトコルを変更することにより強化は起きます。\n"
"通常、強化の間の実装のリストは`extract_impls/2`の助けを得て\n"
"検索されます。\n"
"\n"
"プロトコルバイトコードの更新版を返します。与えられたバイトコードまたは\n"
"プロトコル実装は、強化されたかどうかをプロトコルアトリビュートを分析す\n"
"ることで、チェックできます:\n"
"\n"
"\n"
"    Protocol.consolidated?(Enumerable)\n"
"\n"
"もしタプルの最初の要素がtrueならプロトコルは強化されたことを意味します。\n"
"\n"
"この関数はいかなるプロトコルもロードしませんし、コンパイルされたモジュー\n"
"ルの新しいバイトコードもロードしません。しかしながら、それぞれの実装は\n"
"有効にされるはずで、それはロードされるでしょう。\n"

#. TRANSLATORS: def Exception.format_mfa(module, fun, arity)
#: lib/exception.ex:416
msgid ""
"Receives a module, fun and arity and formats it\n"
"as shown in stacktraces. The arity may also be a list\n"
"of arguments.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Exception.format_mfa Foo, :bar, 1\n"
"    \"Foo.bar/1\"\n"
"\n"
"    iex> Exception.format_mfa Foo, :bar, []\n"
"    \"Foo.bar()\"\n"
"\n"
"    iex> Exception.format_mfa nil, :bar, []\n"
"    \"nil.bar()\"\n"
"\n"
"Anonymous functions are reported as -func/arity-anonfn-count-,\n"
"where func is the name of the enclosing function. Convert to\n"
"\"anonymous fn in func/arity\"\n"
msgstr ""
"モジュール、関数とアリティを受け取り、それを\n"
"スタックトレースに表示されるようにフォーマットします。\n"
"アリティは引数のリストかもしれません。\n"
"\n"
"## 例\n"
"\n"
"    iex> Exception.format_mfa Foo, :bar, 1\n"
"    \"Foo.bar/1\"\n"
"\n"
"    iex> Exception.format_mfa Foo, :bar, []\n"
"    \"Foo.bar()\"\n"
"\n"
"    iex> Exception.format_mfa nil, :bar, []\n"
"    \"nil.bar()\"\n"
"\n"
"無名関数は-func/arity-anonfn-count-としてレポートされます。\n"
"funcは囲んでいる関数の名前です。無名関数を、func/airtyに変換します。\n"

#. TRANSLATORS: def List.keysort(list, position)
#: lib/list.ex:232
msgid ""
"Receives a list of tuples and sorts the items\n"
"at `position` of the tuples. The sort is stable.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.keysort([a: 5, b: 1, c: 3], 1)\n"
"    [b: 1, c: 3, a: 5]\n"
"\n"
"    iex> List.keysort([a: 5, c: 1, b: 3], 0)\n"
"    [a: 5, b: 3, c: 1]\n"
"\n"
msgstr ""
"タプルの`position`でアイテムをソートしタプルのリストを返します。\n"
"ソートは安定的です。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.keysort([a: 5, b: 1, c: 3], 1)\n"
"    [b: 1, c: 3, a: 5]\n"
"\n"
"    iex> List.keysort([a: 5, c: 1, b: 3], 0)\n"
"    [a: 5, b: 3, c: 1]\n"
"\n"

#. TRANSLATORS: def List.keyfind(list, key, position, default \\ nil)
#: lib/list.ex:177
msgid ""
"Receives a list of tuples and returns the first tuple\n"
"where the item at `position` in the tuple matches the\n"
"given `key`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.keyfind([a: 1, b: 2], :a, 0)\n"
"    {:a, 1}\n"
"\n"
"    iex> List.keyfind([a: 1, b: 2], 2, 1)\n"
"    {:b, 2}\n"
"\n"
"    iex> List.keyfind([a: 1, b: 2], :c, 0)\n"
"    nil\n"
"\n"
msgstr ""
"タプルのリストを受け取り、リストの各タプル内の`position`番目のアイテム\n"
"が、与えられた`key`にマッチする、最初のタプルを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.keyfind([a: 1, b: 2], :a, 0)\n"
"    {:a, 1}\n"
"\n"
"    iex> List.keyfind([a: 1, b: 2], 2, 1)\n"
"    {:b, 2}\n"
"\n"
"    iex> List.keyfind([a: 1, b: 2], :c, 0)\n"
"    nil\n"
"\n"

#. TRANSLATORS: def List.keymember?(list, key, position)
#: lib/list.ex:199
msgid ""
"Receives a list of tuples and returns `true` if there is\n"
"a tuple where the item at `position` in the tuple matches\n"
"the given `key`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.keymember?([a: 1, b: 2], :a, 0)\n"
"    true\n"
"\n"
"    iex> List.keymember?([a: 1, b: 2], 2, 1)\n"
"    true\n"
"\n"
"    iex> List.keymember?([a: 1, b: 2], :c, 0)\n"
"    false\n"
"\n"
msgstr ""
"タプルのリストを受け取り、リストの各タプル内の`position`番目のアイテム\n"
"が、与えられた`item`にマッチするタプルがあれば、`true`を\n"
"返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.keymember?([a: 1, b: 2], :a, 0)\n"
"    true\n"
"\n"
"    iex> List.keymember?([a: 1, b: 2], 2, 1)\n"
"    true\n"
"\n"
"    iex> List.keymember?([a: 1, b: 2], :c, 0)\n"
"    false\n"
"\n"

#. TRANSLATORS: def List.keystore(list, key, position, new_tuple)
#: lib/list.ex:251
msgid ""
"Receives a list of tuples and replaces the item\n"
"identified by `key` at `position`. If the item\n"
"does not exist, it is added to the end of the list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.keystore([a: 1, b: 2], :a, 0, {:a, 3})\n"
"    [a: 3, b: 2]\n"
"\n"
"    iex> List.keystore([a: 1, b: 2], :c, 0, {:c, 3})\n"
"    [a: 1, b: 2, c: 3]\n"
"\n"
msgstr ""
"タプルのリストを受け取り、`position`の位置の`key`により指定された、アイ\n"
"テムを置き換えます。アイテムが存在しないなら、それは、リストの末尾に追\n"
"加されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.keystore([a: 1, b: 2], :a, 0, {:a, 3})\n"
"    [a: 3, b: 2]\n"
"\n"
"    iex> List.keystore([a: 1, b: 2], :c, 0, {:c, 3})\n"
"    [a: 1, b: 2, c: 3]\n"
"\n"

#. TRANSLATORS: def List.keyreplace(list, key, position, new_tuple)
#: lib/list.ex:214
msgid ""
"Receives a list of tuples and replaces the item\n"
"identified by `key` at `position` if it exists.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.keyreplace([a: 1, b: 2], :a, 0, {:a, 3})\n"
"    [a: 3, b: 2]\n"
"\n"
msgstr ""
"タプルのリストを受け取り、もしあれば、`position`の位置の\n"
"`key`により指定されたアイテムを置き換えます。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.keyreplace([a: 1, b: 2], :a, 0, {:a, 3})\n"
"    [a: 3, b: 2]\n"
"\n"

#. TRANSLATORS: def List.keydelete(list, key, position)
#: lib/list.ex:273
msgid ""
"Receives a list of tuples and deletes the first tuple\n"
"where the item at `position` matches the\n"
"given `key`. Returns the new list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.keydelete([a: 1, b: 2], :a, 0)\n"
"    [b: 2]\n"
"\n"
"    iex> List.keydelete([a: 1, b: 2], 2, 1)\n"
"    [a: 1]\n"
"\n"
"    iex> List.keydelete([a: 1, b: 2], :c, 0)\n"
"    [a: 1, b: 2]\n"
"\n"
msgstr ""
"タプルのリストを受け取り、`position`の位置のアイテムが\n"
"与えられた`item`にマッチする最初のタプルを削除します。\n"
"新しいリストを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.keydelete([a: 1, b: 2], :a, 0)\n"
"    [b: 2]\n"
"\n"
"    iex> List.keydelete([a: 1, b: 2], 2, 1)\n"
"    [a: 1]\n"
"\n"
"    iex> List.keydelete([a: 1, b: 2], :c, 0)\n"
"    [a: 1, b: 2]\n"
"\n"

#. TRANSLATORS: defmacro Protocol.def(signature)
#: lib/protocol.ex:13
msgid ""
"Defines a new protocol function.\n"
"\n"
"Protocols do not allow functions to be defined directly, instead, the\n"
"regular `Kernel.def/*` macros are replaced by this macro which\n"
"defines the protocol functions with the appropriate callbacks.\n"
msgstr ""
"新しいプロトコル関数を定義します。\n"
"\n"
"プロトコルは関数を直接定義することは許されていません。代りに、\n"
"適切なコールバックでプロトコル関数を定義するこのマクロと、\n"
"標準の`Kernel.def/*`マクロが取り替えられます。\n"

#. TRANSLATORS: defmacro Kernel.defmodule(alias, list2)
#: lib/kernel.ex:2604
msgid ""
"Defines a module given by name with the given contents.\n"
"\n"
"It returns the module name, the module binary and the\n"
"block contents result.\n"
"\n"
"## Examples\n"
"\n"
"    iex> defmodule Foo do\n"
"    ...>   def bar, do: :baz\n"
"    ...> end\n"
"    iex> Foo.bar\n"
"    :baz\n"
"\n"
"## Nesting\n"
"\n"
"Nesting a module inside another module affects its name:\n"
"\n"
"    defmodule Foo do\n"
"      defmodule Bar do\n"
"      end\n"
"    end\n"
"\n"
"In the example above, two modules `Foo` and `Foo.Bar` are created.\n"
"When nesting, Elixir automatically creates an alias, allowing the\n"
"second module `Foo.Bar` to be accessed as `Bar` in the same lexical\n"
"scope.\n"
"\n"
"This means that, if the module `Bar` is moved to another file,\n"
"the references to `Bar` needs to be updated or an alias needs to\n"
"be explicitly set with the help of `Kernel.SpecialForms.alias/2`.\n"
"\n"
"## Dynamic names\n"
"\n"
"Elixir module names can be dynamically generated. This is very\n"
"useful for macros. For instance, one could write:\n"
"\n"
"    defmodule String.to_atom(\"Foo#{1}\") do\n"
"      # contents ...\n"
"    end\n"
"\n"
"Elixir will accept any module name as long as the expression\n"
"returns an atom. Note that, when a dynamic name is used, Elixir\n"
"won't nest the name under the current module nor automatically\n"
"set up an alias.\n"
msgstr ""
"与えられた名前とコンテンツのモジュールを定義します。\n"
"\n"
"モジュール名、モジュールバイナリとブロックコンテンツの\n"
"結果を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> defmodule Foo do\n"
"    ...>   def bar, do: :baz\n"
"    ...> end\n"
"    iex> Foo.bar\n"
"    :baz\n"
"\n"
"## ネスト\n"
"\n"
"もう一つのモジュールの中にモジュールをネストすることは、その名前に\n"
"影響を及ぼします:\n"
"\n"
"    defmodule Foo do\n"
"      defmodule Bar do\n"
"      end\n"
"    end\n"
"\n"
"上の例で、二つのモジュール`Foo`と`Foo.Bar`が作られます。\n"
"ネストするとき、Elixirは自動的にエイリアスを作ります。\n"
"そして、二つめのモジュール`Foo.Bar`が同じレキシカルスコープの\n"
"中で`Bar`としてアクセスされることを許します。\n"
"\n"
"これは、モジュール`Bar`が他のファイルに移動されるなら、`Bar`への参照は\n"
"更新される必要があること、または、`Kernel.SpecialForms.alias/2`の助けを\n"
"かりて、エイリアスを明示的にセットアップする必要があることを、意味しま\n"
"す。\n"
"\n"
"## 動的な名前\n"
"\n"
"Elixirモジュール名は、動的に生成することができます。これは\n"
"マクロにとって、非常に便利です。例えば、このように畫けます:\n"
"\n"
"    defmodule String.to_atom(\"Foo#{1}\") do\n"
"      # contents ...\n"
"    end\n"
"\n"
"Elixirはアトムを返す限り、任意のモジュール名を受け入れます。なお、動的\n"
"な名前が使われるとき、Elixirは現在のモジュールの下で、名前のネストもし\n"
"ないし、自動的なエイリアスのセットアップもしません。\n"

#. TRANSLATORS: defmacro Kernel.defmacro(call, expr \\ nil)
#: lib/kernel.ex:2788
msgid ""
"Defines a macro with the given name and contents.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule MyLogic do\n"
"      defmacro unless(expr, opts) do\n"
"        quote do\n"
"          if !unquote(expr), unquote(opts)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    require MyLogic\n"
"    MyLogic.unless false do\n"
"      IO.puts \"It works\"\n"
"    end\n"
"\n"
msgstr ""
"与えられた名前とコンテンツでマクロを定義します。\n"
"\n"
"## 例\n"
"\n"
"    defmodule MyLogic do\n"
"      defmacro unless(expr, opts) do\n"
"        quote do\n"
"          if !unquote(expr), unquote(opts)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    require MyLogic\n"
"    MyLogic.unless false do\n"
"      IO.puts \"It works\"\n"
"    end\n"
"\n"

#. TRANSLATORS: defmacro Behaviour.defmacrocallback(spec)
#: lib/behaviour.ex:56
msgid "Defines a macro callback according to the given type specification.\n"
msgstr "与えられたタイプ仕様に従って、コールバックマクロを定義します。\n"

#. TRANSLATORS: defmacro Kernel.defmacrop(call, expr \\ nil)
#: lib/kernel.ex:2798
msgid ""
"Defines a macro that is private. Private macros are\n"
"only accessible from the same module in which they are defined.\n"
"\n"
"Check `defmacro/2` for more information\n"
msgstr ""
"プライベートマクロを定義します。プライベートマクロは\n"
"それが定義された同じモジュールからのみアクセス可能です。\n"
"\n"
"詳細は `defmacro/2` をチェックしてください。\n"

#. TRANSLATORS: defmacro Kernel.def(call, expr \\ nil)
#: lib/kernel.ex:2742
msgid ""
"Defines a function with the given name and contents.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Foo do\n"
"      def bar, do: :baz\n"
"    end\n"
"\n"
"    Foo.bar #=> :baz\n"
"\n"
"A function that expects arguments can be defined as follow:\n"
"\n"
"    defmodule Foo do\n"
"      def sum(a, b) do\n"
"        a + b\n"
"      end\n"
"    end\n"
"\n"
"In the example above, we defined a function `sum` that receives\n"
"two arguments and sums them.\n"
"\n"
msgstr ""
"与えられた名前とコンテンツで関数を定義します。\n"
"\n"
"## 例\n"
"\n"
"    defmodule Foo do\n"
"      def bar, do: :baz\n"
"    end\n"
"\n"
"    Foo.bar #=> :baz\n"
"\n"
"関数は下のように、引数を付けて定義することもできます:\n"
"\n"
"    defmodule Foo do\n"
"      def sum(a, b) do\n"
"        a + b\n"
"      end\n"
"    end\n"
"\n"
"上の例では、二つの引数をとり、それらの和を返す関数`sum`を定義しました。\n"
"\n"

#. TRANSLATORS: defmacro Behaviour.defcallback(spec)
#: lib/behaviour.ex:49
msgid ""
"Defines a function callback according to the given type specification.\n"
msgstr "与えられたタイプ仕様に従って、コールバック関数を定義します。\n"

#. TRANSLATORS: defmacro Kernel.defp(call, expr \\ nil)
#: lib/kernel.ex:2765
msgid ""
"Defines a function that is private. Private functions are\n"
"only accessible from within the module in which they are defined.\n"
"\n"
"Check `def/2` for more information\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Foo do\n"
"      def bar do\n"
"        sum(1, 2)\n"
"      end\n"
"\n"
"      defp sum(a, b), do: a + b\n"
"    end\n"
"\n"
"In the example above, `sum` is private and accessing it\n"
"through `Foo.sum` will raise an error.\n"
msgstr ""
"プライベート関数を定義します。プライベート関数は\n"
"それが定義された同じモジュールからのみアクセス可能です。\n"
"\n"
"詳細は `def/2` をチェックしてください。\n"
"\n"
"## 例\n"
"\n"
"    defmodule Foo do\n"
"      def bar do\n"
"        sum(1, 2)\n"
"      end\n"
"\n"
"      defp sum(a, b), do: a + b\n"
"    end\n"
"\n"
"上の例では、`sum`はプライベートで、`Foo.sum`を通して\n"
"アクセスすると、エラーが上がります。\n"

#. TRANSLATORS: defmacro Kernel.Typespec.defcallback(spec)
#: lib/kernel/typespec.ex:279
msgid ""
"Defines a callback.\n"
"This macro is responsible for handling the attribute `@callback`.\n"
"\n"
"## Examples\n"
"\n"
"    @callback add(number, number) :: number\n"
"\n"
msgstr ""
"コールバックを定義します。\n"
"このマクロは`@callback`属性をハンドルする役割りを果します。\n"
"\n"
"## 例\n"
"\n"
"    @callback add(number, number) :: number\n"
"\n"

#. TRANSLATORS: def Kernel.Typespec.define_type(kind, expr, doc \\ nil, env)
#: lib/kernel/typespec.ex:288
msgid ""
"Defines a `type`, `typep` or `opaque` by receiving a typespec expression.\n"
msgstr "typespec式を受け取り、`type`、 `typep`または`opaque`を定義します。\n"

#. TRANSLATORS: def Kernel.Typespec.define_spec(kind, expr, env)
#: lib/kernel/typespec.ex:295
msgid "Defines a `spec` by receiving a typespec expression.\n"
msgstr "typespec式を受け取り、`spec`を定義します。\n"

#. TRANSLATORS: def Regex.names(regex)
#: lib/regex.ex:286
msgid ""
"Returns a list of names in the regex.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.names(~r/(?<foo>bar)/)\n"
"    [\"foo\"]\n"
"\n"
msgstr ""
"regex中の名前のリストを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Regex.names(~r/(?<foo>bar)/)\n"
"    [\"foo\"]\n"
"\n"

#. TRANSLATORS: def Dict.to_list(dict)
#: lib/dict.ex:689
msgid ""
"Returns a list of key-value pairs stored in `dict`.\n"
"No particular order is enforced.\n"
msgstr ""
"`dict`に保存されているキーバリューペアのリストを返します。\n"
"\n"
"特定の順序に整列はされません。\n"

#. TRANSLATORS: def Enum.shuffle(collection)
#: lib/enum.ex:1581
msgid ""
"Returns a list of collection elements shuffled.\n"
"\n"
"Notice that you need to explicitly call `:random.seed/1` and\n"
"set a seed value for the random algorithm. Otherwise, the\n"
"default seed will be set which will always return the same\n"
"result. For example, one could do the following to set a seed\n"
"dynamically:\n"
"\n"
"    :random.seed(:os.timestamp)\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.shuffle([1, 2, 3])\n"
"    [3, 2, 1]\n"
"    iex> Enum.shuffle([1, 2, 3])\n"
"    [3, 1, 2]\n"
"\n"
msgstr ""
"コレクションの要素をシャッフルしたリストを返します。\n"
"\n"
"明示的に`:random.seed/1`を呼び出して、乱数アルゴリズムのシード値を設定\n"
"する必要があることに注意してください。さもないと、常に同じデフォルトシー\n"
"ドが設定され、同じ結果が帰って来ます。例えば、以下の様にして一度呼び出\n"
"すと、シードを動的に設定することができます:\n"
"\n"
"    :random.seed(:os.timestamp)\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.shuffle([1, 2, 3])\n"
"    [3, 2, 1]\n"
"    iex> Enum.shuffle([1, 2, 3])\n"
"    [3, 1, 2]\n"
"\n"

#. TRANSLATORS: def Node.list()
#: lib/node.ex:65
msgid ""
"Returns a list of all visible nodes in the system, excluding\n"
"the local node.\n"
"\n"
"Same as `list(:visible)`.\n"
msgstr ""
"ローカルノード以外の、システムのvisibleな全てのノードのリストを返します。\n"
"\n"
"`list(:visible)`と同じです。\n"

#. TRANSLATORS: def Dict.values(dict)
#: lib/dict.ex:313
msgid ""
"Returns a list of all values in `dict`.\n"
"The values are not guaranteed to be in any order.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> Enum.sort(Dict.values(dict))\n"
"    [1,2]\n"
"\n"
msgstr ""
"`dict`の全ての値のリストを返します。\n"
"値の整列は保証されません。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> Enum.sort(Dict.values(dict))\n"
"    [1,2]\n"
"\n"

#. TRANSLATORS: def Dict.keys(dict)
#: lib/dict.ex:297
msgid ""
"Returns a list of all keys in `dict`.\n"
"The keys are not guaranteed to be in any order.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> Enum.sort(Dict.keys(dict))\n"
"    [:a,:b]\n"
"\n"
msgstr ""
"`dict`の全てのキーのリストを返します。\n"
"キーの整列は保証されません。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> Enum.sort(Dict.keys(dict))\n"
"    [:a,:b]\n"
"\n"

#. TRANSLATORS: def GenEvent.which_handlers(manager)
#: lib/gen_event.ex:499
msgid "Returns a list of all event handlers installed in the `manager`.\n"
msgstr ""
"`manager`にインストールされている全てのイベントハンドラの\n"
"リストを返します。\n"

#. TRANSLATORS: def Inspect.Algebra.group(d)
#: lib/inspect/algebra.ex:344
msgid ""
"Returns a group containing the specified document.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.group(\n"
"    ...>   Inspect.Algebra.concat(\n"
"    ...>     Inspect.Algebra.group(\n"
"    ...>       Inspect.Algebra.concat(\n"
"    ...>         \"Hello,\",\n"
"    ...>         Inspect.Algebra.concat(\n"
"    ...>           Inspect.Algebra.break,\n"
"    ...>           \"A\"\n"
"    ...>         )\n"
"    ...>       )\n"
"    ...>     ),\n"
"    ...>     Inspect.Algebra.concat(\n"
"    ...>       Inspect.Algebra.break,\n"
"    ...>       \"B\"\n"
"    ...>     )\n"
"    ...> ))\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"Hello,\", \" \", \"A\", \" \", \"B\"]\n"
"    iex> Inspect.Algebra.format(doc, 6)\n"
"    [\"Hello,\", \"\\n\", \"A\", \" \", \"B\"]\n"
"\n"
msgstr ""
"指定されたドキュメントを含むグループを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> doc = Inspect.Algebra.group(\n"
"    ...>   Inspect.Algebra.concat(\n"
"    ...>     Inspect.Algebra.group(\n"
"    ...>       Inspect.Algebra.concat(\n"
"    ...>         \"Hello,\",\n"
"    ...>         Inspect.Algebra.concat(\n"
"    ...>           Inspect.Algebra.break,\n"
"    ...>           \"A\"\n"
"    ...>         )\n"
"    ...>       )\n"
"    ...>     ),\n"
"    ...>     Inspect.Algebra.concat(\n"
"    ...>       Inspect.Algebra.break,\n"
"    ...>       \"B\"\n"
"    ...>     )\n"
"    ...> ))\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"Hello,\", \" \", \"A\", \" \", \"B\"]\n"
"    iex> Inspect.Algebra.format(doc, 6)\n"
"    [\"Hello,\", \"\\n\", \"A\", \" \", \"B\"]\n"
"\n"

#. TRANSLATORS: def Collectable.into(collectable)
#: lib/collectable.ex:46
msgid ""
"Returns a function that collects values alongside\n"
"the initial accumulation value.\n"
"\n"
"The returned function receives a collectable and injects a given\n"
"value into it for every `{:cont, term}` instruction.\n"
"\n"
"`:done` is passed when no further values will be injected, useful\n"
"for closing resources and normalizing values. A collectable must\n"
"be returned on `:done`.\n"
"\n"
"If injection is suddenly interrupted, `:halt` is passed and it can\n"
"return any value, as it won't be used.\n"
msgstr ""
"初期アキュムレータと一緒に値を集める関数を返します。\n"
"\n"
"返された関数は、collectableであるアキュムレータを受け取り、与えられた値\n"
"を`{:cont, term}`指令毎にアキュムレータに注入して、新しいアキュムレータ\n"
"を返します。\n"
"\n"
"`:done`は更なる値が注入されないときに渡されます。リソースのクローズと値\n"
"の正規化に役立ちます。`:done`ではcollectableが返されなければなりません。\n"
"\n"
"もし注入が突然中断されたら、`:halt`がパスされます。戻り値は使われないの\n"
"で、任意の値を返すことができます。\n"

#. TRANSLATORS: def Module.overridable?(module, tuple)
#: lib/module.ex:713
msgid "Returns `true` if `tuple` in `module` is marked as overridable.\n"
msgstr ""
"もし、`module`の中の`tuple`がoverridableとしてマークされていれば、\n"
"`true`を返します。\n"

#. TRANSLATORS: def Regex.match?(regex, string)
#: lib/regex.ex:158
msgid ""
"Returns a boolean indicating whether there was a match or not.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.match?(~r/foo/, \"foo\")\n"
"    true\n"
"\n"
"    iex> Regex.match?(~r/foo/, \"bar\")\n"
"    false\n"
"\n"
msgstr ""
"マッチするか否かをブーリアンで返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Regex.match?(~r/foo/, \"foo\")\n"
"    true\n"
"\n"
"    iex> Regex.match?(~r/foo/, \"bar\")\n"
"    false\n"
"\n"

#. TRANSLATORS: def String.to_float(string)
#: lib/string.ex:1439
msgid ""
"Returns a float whose text representation is `string`.\n"
"\n"
"`string` must be the string representation of a float.\n"
"If a string representation of an integer wants to be used,\n"
"then `Float.parse/1` should be used instead,\n"
"otherwise an argument error will be raised.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.to_float(\"2.2017764e+0\")\n"
"    2.2017764\n"
"\n"
"    iex> String.to_float(\"3.0\")\n"
"    3.0\n"
"\n"
msgstr ""
"テキスト`string`が表現する浮動小数点数を返します。\n"
"\n"
"`string`は浮動小数点数の文字列表現でなくてはなりません。\n"
"もし整数の文字列表現を使いたいなら、`Float.parse/1`を代わりに\n"
"使うべきです。さもなければ、argument errorが上ります。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.to_float(\"2.2017764e+0\")\n"
"    2.2017764\n"
"\n"
"    iex> String.to_float(\"3.0\")\n"
"    3.0\n"
"\n"

#. TRANSLATORS: def Integer.to_string(some_integer)
#: lib/integer.ex:195
msgid ""
"Returns a binary which corresponds to the text representation\n"
"of `some_integer`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Integer.to_string(123)\n"
"    \"123\"\n"
"\n"
msgstr ""
"`some_integer`のテキスト表現に対応するバイナリを返します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Integer.to_string(123)\n"
"    \"123\"\n"
"\n"

#. TRANSLATORS: def Integer.to_string(some_integer, base)
#: lib/integer.ex:212
msgid ""
"Returns a binary which corresponds to the text representation\n"
"of `some_integer` in base `base`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Integer.to_string(100, 16)\n"
"    \"64\"\n"
"\n"
msgstr ""
"基数`base`での`some_integer`のテキスト表現に対応するバイナリを\n"
"返します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Integer.to_string(100, 16)\n"
"    \"64\"\n"
"\n"

#. TRANSLATORS: def Float.to_string(some_float)
#: lib/float.ex:213
msgid ""
"Returns a binary which corresponds to the text representation\n"
"of `some_float`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Float.to_string(7.0)\n"
"    \"7.00000000000000000000e+00\"\n"
"\n"
msgstr ""
"`some_float`のテキスト表現に対応するバイナリを返します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Float.to_string(7.0)\n"
"    \"7.00000000000000000000e+00\"\n"
"\n"

#. TRANSLATORS: def Float.to_string(float, options)
#: lib/float.ex:235
msgid ""
"Returns a binary which corresponds to the text representation\n"
"of `float`.\n"
"\n"
"## Options\n"
"\n"
"  * `:decimals`   — number of decimal points to show\n"
"  * `:scientific` — number of decimal points to show, in scientific format\n"
"  * `:compact`    — when true, use the most compact representation (ignored\n"
"                    with the `scientific` option)\n"
"\n"
"## Examples\n"
"\n"
"    iex> Float.to_string 7.1, [decimals: 2, compact: true]\n"
"    \"7.1\"\n"
"\n"
msgstr ""
"`float`のテキスト表現に対応するバイナリを返します。\n"
"\n"
"## オプション\n"
"\n"
"  * `:decimals`   —  表示する小数点以下の桁数\n"
"  * `:scientific` —  科学的フォーマットでの小数点以下の桁数\n"
"  * `:compact`    —  trueの時、\n"
"                     `scientific`オプションがあるときはこのオプションは\n"
"                     無視されます)\n"
"\n"
"## 例\n"
"\n"
"    iex> Float.to_string 7.1, [decimals: 2, compact: true]\n"
"    \"7.1\"\n"
"\n"

#. TRANSLATORS: def String.duplicate(subject, n)
#: lib/string.ex:727
msgid ""
"Returns a binary `subject` duplicated `n` times.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.duplicate(\"abc\", 0)\n"
"    \"\"\n"
"\n"
"    iex> String.duplicate(\"abc\", 1)\n"
"    \"abc\"\n"
"\n"
"    iex> String.duplicate(\"abc\", 2)\n"
"    \"abcabc\"\n"
"\n"
msgstr ""
"`subject`を`n`回複製したバイナリを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.duplicate(\"abc\", 0)\n"
"    \"\"\n"
"\n"
"    iex> String.duplicate(\"abc\", 1)\n"
"    \"abc\"\n"
"\n"
"    iex> String.duplicate(\"abc\", 2)\n"
"    \"abcabc\"\n"
"\n"

#. TRANSLATORS: def Dict.fetch(dict, key)
#: lib/dict.ex:382
msgid ""
"Returns `{:ok, value}` associated with `key` in `dict`.\n"
"If `dict` does not contain `key`, returns `:error`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> Dict.fetch(dict, :a)\n"
"    {:ok, 1}\n"
"    iex> Dict.fetch(dict, :b)\n"
"    :error\n"
"\n"
msgstr ""
"`dict`中の`key`に関連した値をvalueとして、`{:ok, value}`を返します。\n"
"もし`dict`が`key`含んでいなかったら、`:error`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> Dict.fetch(dict, :a)\n"
"    {:ok, 1}\n"
"    iex> Dict.fetch(dict, :b)\n"
"    :error\n"
"\n"

#. TRANSLATORS: def File.stream!(path, modes \\ [], line_or_bytes \\ :line)
#: lib/file.ex:1182
msgid ""
"Returns a `File.Stream` for the given `path` with the given `modes`.\n"
"\n"
"The stream implements both `Enumerable` and `Collectable` protocols,\n"
"which means it can be used both for read and write.\n"
"\n"
"The `line_or_byte` argument configures how the file is read when\n"
"streaming, by `:line` (default) or by a given number of bytes.\n"
"\n"
"Operating the stream can fail on open for the same reasons as\n"
"`File.open!/2`. Note that the file is automatically opened only and\n"
"every time streaming begins. There is no need to pass `:read` and\n"
"`:write` modes, as those are automatically set by Elixir.\n"
"\n"
"## Raw files\n"
"\n"
"Since Elixir controls when the streamed file is opened, the underlying\n"
"device cannot be shared and as such it is convenient to open the file\n"
"in raw mode for performance reasons. Therefore, Elixir **will** open\n"
"streams in `:raw` mode with the `:read_ahead` option unless an encoding\n"
"is specified.\n"
"\n"
"One may also consider passing the `:delayed_write` option if the stream\n"
"is meant to be written to under a tight loop.\n"
msgstr ""
"与えられた`path`について、与えられた`modes`での`File.Stream`を返します。\n"
"\n"
"ストリームは`Enumerable`と`Collectable`プロトコルの両方を実装していて、\n"
"これは読み書きの両方が出来ることを意味します。\n"
"\n"
"`line_or_byte`引数は、ファイルがストリーミングされるときの方法を、\n"
"`:line`(デフォルト)か、与えられたバイト数毎か、を構成します。\n"
"\n"
"オペレーティングシステムは`File.open!/2`と同じreasonでオープンに失敗す\n"
"ることがあります。ストリーミングは開始される毎に、ファイルは自動的にオー\n"
"プンされるだけであることに、注意してください。`:read`や`:write`モードは\n"
"Elixirにより自動的にセットされるので指定する必要はありません。\n"
"\n"
"## Rawファイル\n"
"\n"
"ストリームファイルが何時オープンされるかを、Elixirが制御するので、下層\n"
"のデバイスは共有されることはありません。ですので、パフォーマンス上の理\n"
"由からrawモードでファイルをオープンすることは便利です。従って、エンコー\n"
"ディングが指定されない限り、Elixirは、`:read_ahead`オプション付の\n"
"`:raw`モードでストリームをオープン ** します ** 。\n"
"\n"
"人は、もしストリームが堅いループ中で書き込みされるはずなら、\n"
"`:delayed_write`オプションをパスすることを考慮するかもしれません。\n"

#. TRANSLATORS: def File.read(path)
#: lib/file.ex:230
msgid ""
"Returns `{:ok, binary}`, where `binary` is a binary data object that "
"contains the contents\n"
"of `path`, or `{:error, reason}` if an error occurs.\n"
"\n"
"Typical error reasons:\n"
"\n"
"  * `:enoent`  - the file does not exist\n"
"  * `:eacces`  - missing permission for reading the file,\n"
"                 or for searching one of the parent directories\n"
"  * `:eisdir`  - the named file is a directory\n"
"  * `:enotdir` - a component of the file name is not a directory;\n"
"                 on some platforms, `:enoent` is returned instead\n"
"  * `:enomem`  - there is not enough memory for the contents of the file\n"
"\n"
"You can use `:file.format_error/1` to get a descriptive string of the "
"error.\n"
msgstr ""
"`binary`を`path`の内容を含むバイナリデータオブジェクトとして、\n"
"`{:ok, binary}`を返します。または、エラーが起きると`{:error, reason}`を\n"
"返します。\n"
"\n"
"典型的なエラー reason は以下の通りです:\n"
"\n"
"  * `:enoent`  - ファイルが存在しない\n"
"  * `:eacces`  - ファイルを読むため、または、親ディレクトリのサーチ\n"
"                 するためのパーミッションが無い\n"
"  * `:eisdir`  - その名前のファイルはディレクトリです\n"
"  * `:enotdir` - ファイル名を構成する一部がディレクトリでない;\n"
"                 幾つかのプラットフォームではかわりに`:enoent`が返される。\n"
"  * `:enomem`  - ファイルの内容のための十分なメモりがない\n"
"\n"
"エラーの記述文字列を得るために`:file.format_error/1`を使うことができます。\n"

#. TRANSLATORS: def Kernel.!==(left, right)
#: lib/kernel.ex:1066
msgid ""
"Returns `true` if the two items do not match.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 !== 2\n"
"    true\n"
"\n"
"    iex> 1 !== 1.0\n"
"    true\n"
"\n"
msgstr ""
"もし、二つのアイテムが一致しないなら、`true`を返します。\n"
"\n"
"Elixirの全てのアイテムはそれぞれ他と比較加能です。\n"
"\n"
"ガードの中のテストに使えます。\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> 1 !== 2\n"
"    true\n"
"\n"
"    iex> 1 !== 1.0\n"
"    true\n"
"\n"

#. TRANSLATORS: def Kernel.!=(left, right)
#: lib/kernel.ex:1020
msgid ""
"Returns `true` if the two items are not equal.\n"
"\n"
"This operator considers 1 and 1.0 to be equal. For match\n"
"comparison, use `!==` instead.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 != 2\n"
"    true\n"
"\n"
"    iex> 1 != 1.0\n"
"    false\n"
"\n"
msgstr ""
"もし、二つのアイテムが等しくないなら、`true`を返します。\n"
"\n"
"この演算子は1と1.0を等しいと考えます。一致するかどうかの\n"
"比較の為には、`!==`をかわりに使ってください。\n"
"\n"
"Elixirの全てのアイテムはそれぞれ他と比較加能です。\n"
"\n"
"ガードの中のテストに使えます。\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> 1 != 2\n"
"    true\n"
"\n"
"    iex> 1 != 1.0\n"
"    false\n"
"\n"

#. TRANSLATORS: def Kernel.===(left, right)
#: lib/kernel.ex:1045
msgid ""
"Returns `true` if the two items are match.\n"
"\n"
"This operator gives the same semantics as the one existing in\n"
"pattern matching, i.e., `1` and `1.0` are equal, but they do\n"
"not match.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 === 2\n"
"    false\n"
"\n"
"    iex> 1 === 1.0\n"
"    false\n"
"\n"
msgstr ""
"もし、二つのアイテムが一致するなら、`true`を返します。\n"
"\n"
"この演算子はパターンマッチの中に存在しているものと\n"
"同じセマンティクスを与えます。すなわち、`1`と`1.0`は等しいですが、\n"
"それらは一致しません。\n"
"\n"
"Elixirの全てのアイテムはそれぞれ他と比較加能です。\n"
"\n"
"ガードの中のテストに使えます。\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> 1 === 2\n"
"    false\n"
"\n"
"    iex> 1 === 1.0\n"
"    false\n"
"\n"

#. TRANSLATORS: def Kernel.==(left, right)
#: lib/kernel.ex:996
msgid ""
"Returns `true` if the two items are equal.\n"
"\n"
"This operator considers 1 and 1.0 to be equal. For match\n"
"semantics, use `===` instead.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 == 2\n"
"    false\n"
"\n"
"    iex> 1 == 1.0\n"
"    true\n"
"\n"
msgstr ""
"もし、二つのアイテムが等しいなら、`true`を返します。\n"
"\n"
"この演算子は1と1.0を等しいと考えます。一致するかどうかの\n"
"比較の為には、`===`をかわりに使ってください。\n"
"\n"
"Elixirの全てのアイテムはそれぞれ他と比較加能です。\n"
"\n"
"ガードの中のテストに使えます。\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> 1 == 2\n"
"    false\n"
"\n"
"    iex> 1 == 1.0\n"
"    true\n"
"\n"

#. TRANSLATORS: def File.regular?(path)
#: lib/file.ex:94
msgid ""
"Returns `true` if the path is a regular file.\n"
"\n"
"## Examples\n"
"\n"
"    File.regular? __ENV__.file #=> true\n"
"\n"
msgstr ""
"もし、pathが通常ファイルなら、`true`を返します。\n"
"\n"
"## 例\n"
"\n"
"    File.regular? __ENV__.file #=> true\n"
"\n"

#. TRANSLATORS: def File.dir?(path)
#: lib/file.ex:102
msgid "Returns `true` if the path is a directory.\n"
msgstr "もし、pathがディレクトリなら、`true`を返します。\n"

#. TRANSLATORS: def Node.alive?()
#: lib/node.ex:54
msgid ""
"Returns `true` if the local node is alive.\n"
"\n"
"That is, if the node can be part of a distributed system.\n"
msgstr ""
"もし、ローカルノードが生きていれば、`true`を返します。\n"
"\n"
"つまり、もし、ノードが分散システムの一部で有り得るならば、\n"
"`true`を返します。\n"

#. TRANSLATORS: def File.exists?(path)
#: lib/file.ex:124
msgid ""
"Returns `true` if the given path exists.\n"
"It can be regular file, directory, socket,\n"
"symbolic link, named pipe or device file.\n"
"\n"
"## Examples\n"
"\n"
"    File.exists?(\"test/\")\n"
"    #=> true\n"
"\n"
"    File.exists?(\"missing.txt\")\n"
"    #=> false\n"
"\n"
"    File.exists?(\"/dev/null\")\n"
"    #=> true\n"
"\n"
msgstr ""
"与えられたパスが存在するなら、`true`を返します。\n"
"標準ファイル、ディレクトリ、ソケット、シンボリックリンク、\n"
"名前付きパイプあるいはデバイスファイルが有り得ます。\n"
"\n"
"## 例\n"
"\n"
"    File.exists?(\"test/\")\n"
"    #=> true\n"
"\n"
"    File.exists?(\"missing.txt\")\n"
"    #=> false\n"
"\n"
"    File.exists?(\"/dev/null\")\n"
"    #=> true\n"
"\n"

#. TRANSLATORS: def Kernel.Typespec.defines_type?(module, name, arity)
#: lib/kernel/typespec.ex:304
msgid ""
"Returns `true` if the current module defines a given type\n"
"(private, opaque or not). This function is only available\n"
"for modules being compiled.\n"
msgstr ""
"現在のモジュールが所定のタイプ(private, opaqueかどうか)\n"
"を定義していれば、`true`を返します。\n"
"この関数はコンパイルしているモジュールにのみ有効です。\n"

#. TRANSLATORS: def Kernel.Typespec.defines_spec?(module, name, arity)
#: lib/kernel/typespec.ex:317
msgid ""
"Returns `true` if the current module defines a given spec.\n"
"This function is only available for modules being compiled.\n"
msgstr ""
"現在のモジュールが所定のspecを定義していれば、`true`を返します。\n"
"この関数はコンパイルしているモジュールにのみ有効です。\n"

#. TRANSLATORS: def Kernel.Typespec.defines_callback?(module, name, arity)
#: lib/kernel/typespec.ex:328
msgid ""
"Returns `true` if the current module defines a callback.\n"
"This function is only available for modules being compiled.\n"
msgstr ""
"現在のモジュールがコールバックを定義していれば、`true`を返します。\n"
"この関数はコンパイルしているモジュールにのみ有効です。\n"

#. TRANSLATORS: def Enum.empty?(collection)
#: lib/enum.ex:562
msgid ""
"Returns `true` if the collection is empty, otherwise `false`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.empty?([])\n"
"    true\n"
"\n"
"    iex> Enum.empty?([1, 2, 3])\n"
"    false\n"
"\n"
msgstr ""
"もし、コレクションが空なら、`true`を、さもなくば`false`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.empty?([])\n"
"    true\n"
"\n"
"    iex> Enum.empty?([1, 2, 3])\n"
"    false\n"
"\n"

#. TRANSLATORS: def Kernel.>(left, right)
#: lib/kernel.ex:936
msgid ""
"Returns `true` if left is more than right.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 > 2\n"
"    false\n"
"\n"
msgstr ""
"もし、leftがrightより大きければ、`true`を返します。\n"
"\n"
"Elixirの全てのアイテムはそれぞれ他と比較加能です。\n"
"\n"
"ガードの中のテストに使えます。\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> 1 > 2\n"
"    false\n"
"\n"

#. TRANSLATORS: def Kernel.>=(left, right)
#: lib/kernel.ex:972
msgid ""
"Returns `true` if left is more than or equal to right.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 >= 2\n"
"    false\n"
"\n"
msgstr ""
"もし、leftがrightと等しいか、より大きければ、`true`を返します。\n"
"\n"
"Elixirの全てのアイテムはそれぞれ他と比較加能です。\n"
"\n"
"ガードの中のテストに使えます。\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> 1 >= 2\n"
"    false\n"
"\n"

#. TRANSLATORS: def Kernel.<(left, right)
#: lib/kernel.ex:918
msgid ""
"Returns `true` if left is less than right.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 < 2\n"
"    true\n"
"\n"
msgstr ""
"もし、leftがrightより小ければ、`true`を返します。\n"
"\n"
"Elixirの全てのアイテムはそれぞれ他と比較加能です。\n"
"\n"
"ガードの中のテストに使えます。\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> 1 < 2\n"
"    true\n"
"\n"

#. TRANSLATORS: def Kernel.<=(left, right)
#: lib/kernel.ex:954
msgid ""
"Returns `true` if left is less than or equal to right.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 <= 2\n"
"    true\n"
"\n"
msgstr ""
"もし、leftがrightと等しいか、より小ければ、`true`を返します。\n"
"\n"
"Elixirの全てのアイテムはそれぞれ他と比較加能です。\n"
"\n"
"ガードの中のテストに使えます。\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> 1 <= 2\n"
"    true\n"
"\n"

#. TRANSLATORS: def Enumerable.count(collection)
#: lib/enum.ex:140
msgid ""
"Retrieves the collection's size.\n"
"\n"
"It should return `{:ok, size}`.\n"
"\n"
"If `{:error, __MODULE__}` is returned a default algorithm using `reduce` "
"and\n"
"the match (`===`) operator is used. This algorithm runs in linear time.\n"
"\n"
"Please force use of the default algorithm unless you can implement an\n"
"algorithm that is significantly faster.\n"
msgstr ""
"コレクションのサイズを取り出します。\n"
"\n"
"通常は`{:ok, size}`を返すべきです。\n"
"\n"
"もし`{:error, __MODULE__}`を返したら、デフォルトアルゴリズムの\n"
"`reduce`とマッチ(`===`)オペレータが使われます。このアルゴリズムは実行に\n"
"線形時間がかかります。\n"
"\n"
"あなたがより速いアルゴリズムを実装することができない限り、デフォルトの\n"
"アルゴリズムの使用を強制してください。\n"

#. TRANSLATORS: @type on_start
#: lib/gen_server.ex:0
msgid "Return values of `start*` functions"
msgstr "`start*`関数の戻値"

#. TRANSLATORS: def IO.ANSI.reset()
#: lib/io/ansi.ex:45
msgid "Resets all attributes"
msgstr "全ての属性をリセットします"

#. TRANSLATORS: def Kernel.--(left, right)
#: lib/kernel.ex:884
msgid ""
"Removes the first occurrence of an item on the left\n"
"for each item on the right.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> [1, 2, 3] -- [1, 2]\n"
"    [3]\n"
"\n"
"    iex> [1, 2, 3, 2, 1] -- [1, 2, 2]\n"
"    [3,1]\n"
"\n"
msgstr ""
"右のそれぞれのアイテムについて左にあるアイテムを取り除きます。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> [1, 2, 3] -- [1, 2]\n"
"    [3]\n"
"\n"
"    iex> [1, 2, 3, 2, 1] -- [1, 2, 2]\n"
"    [3,1]\n"
"\n"

#. TRANSLATORS: def Dict.delete(dict, key)
#: lib/dict.ex:452
msgid ""
"Removes the entry stored under the given `key` from `dict`.\n"
"If `dict` does not contain `key`, returns the dictionary unchanged.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.delete(dict, :a)\n"
"    iex> Dict.get(dict, :a)\n"
"    nil\n"
"\n"
"    iex> dict = Enum.into([b: 2], dict_impl.new)\n"
"    iex> Dict.delete(dict, :a) == dict\n"
"    true\n"
"\n"
msgstr ""
"`dict`から与えられた`key`でストアされたエントリを取り除きます。\n"
"`dict`が`key`を含んでいないなら、返される辞書は変更されていません。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.delete(dict, :a)\n"
"    iex> Dict.get(dict, :a)\n"
"    nil\n"
"\n"
"    iex> dict = Enum.into([b: 2], dict_impl.new)\n"
"    iex> Dict.delete(dict, :a) == dict\n"
"    true\n"
"\n"

#. TRANSLATORS: defmacro Kernel.is_nil(term)
#: lib/kernel.ex:1894
msgid ""
"Returns `true` if `term` is nil; otherwise returns `false`.\n"
"\n"
"Allowed in guard clauses.\n"
"\n"
"## Examples\n"
"\n"
"    iex> is_nil(1)\n"
"    false\n"
"\n"
"    iex> is_nil(nil)\n"
"    true\n"
"\n"
msgstr ""
"`term`がnilなら`true`を、さもなければ`false`を返します。\n"
"\n"
"ガード節で使えます。\n"
"\n"
"## 例\n"
"\n"
"    iex> is_nil(1)\n"
"    false\n"
"\n"
"    iex> is_nil(nil)\n"
"    true\n"
"\n"

#. TRANSLATORS: def Kernel.is_boolean(term)
#: lib/kernel.ex:291
msgid ""
"Returns `true` if `term` is either the atom `true` or the atom `false` (i.e. "
"a boolean);\n"
"otherwise returns false.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"もし`term`がアトム`true`またはアトム`false`のいずれか(すなわちboolean)\n"
"ならば`true`を返します。さもなければflseを返します。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.is_number(term)
#: lib/kernel.ex:353
msgid ""
"Returns `true` if `term` is either an integer or a floating point number;\n"
"otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`が整数か浮動小数点数のいずれかなら`true`を返します。さもなければ\n"
"`false`を返します。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.is_integer(term)
#: lib/kernel.ex:332
msgid ""
"Returns `true` if `term` is an integer; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`が整数なら`true`を返します。さもなければ`false`を返します。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.is_atom(term)
#: lib/kernel.ex:258
msgid ""
"Returns `true` if `term` is an atom; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`がアトムなら`true`を返します。さもなければ`false`を返します。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.is_tuple(term)
#: lib/kernel.ex:393
msgid ""
"Returns `true` if `term` is a tuple; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`がタプルなら`true`を返します。さもなければ`false`を返します。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.is_reference(term)
#: lib/kernel.ex:383
msgid ""
"Returns `true` if `term` is a reference; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`がリファレンスなら`true`を返します。さもなければ`false`を返します。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.is_port(term)
#: lib/kernel.ex:373
msgid ""
"Returns `true` if `term` is a port identifier; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`がポート識別子なら`true`を返します。さもなければ`false`を返します。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.is_pid(term)
#: lib/kernel.ex:363
msgid ""
"Returns `true` if `term` is a pid (process identifier); otherwise returns "
"`false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`がpid(プロセス識別子)なら`true`を返します。さもなければ`false`を\n"
"返します。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.is_map(term)
#: lib/kernel.ex:403
msgid ""
"Returns `true` if `term` is a map; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`がマップなら`true`を返します。さもなければ`false`を返します。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.is_list(term)
#: lib/kernel.ex:342
msgid ""
"Returns `true` if `term` is a list with zero or more elements; otherwise "
"returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`が0個以上の要素をもつリストなら`true`を返します。さもなければ\n"
"`false`を返します。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.is_function(term)
#: lib/kernel.ex:311
msgid ""
"Returns `true` if `term` is a function; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`が関数なら`true`を返します。さもなければ`false`を返します。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.is_function(term, arity)
#: lib/kernel.ex:322
msgid ""
"Returns `true` if `term` is a function that can be applied with `arity` "
"number of arguments;\n"
"otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`が引数の数が`arity`個で適用可能な関数なら`true`を返します。さもな\n"
"ければ`false`を返します。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.is_float(term)
#: lib/kernel.ex:301
msgid ""
"Returns `true` if `term` is a floating point number; otherwise returns "
"`false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`が浮動小数点数なら`true`を返します。さもなければ`false`を返します。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.is_bitstring(term)
#: lib/kernel.ex:280
msgid ""
"Returns `true` if `term` is a bitstring (including a binary); otherwise "
"returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`がビット列(バイナリを含ふくみます)なら`true`を返します。さもなけ\n"
"れば`false`を返します。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.is_binary(term)
#: lib/kernel.ex:270
msgid ""
"Returns `true` if `term` is a binary; otherwise returns `false`.\n"
"\n"
"A binary always contains a complete number of bytes.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`がバイナリなら`true`を返します。さもなければ`false`を返します。\n"
"\n"
"バイナリは常に完全なバイトの数を含みます。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.ParallelRequire.files(files, callback \\ fn x -> x end)
#: lib/kernel/parallel_require.ex:16
msgid ""
"Requires the given files.\n"
"\n"
"A callback that is invoked every time a file is required\n"
"can be optionally given as argument.\n"
"\n"
"Returns the modules generated by each required file.\n"
msgstr ""
"与えられたファイルをrequireします。\n"
"\n"
"ファイルがrequireされるたびに、実行されるコールバックは、\n"
"オプション引数として与えることができます。\n"
"\n"
"requireされたファイルにより生成された、モジュールを返します。\n"

#. TRANSLATORS: def Code.require_file(file, relative_to \\ nil)
#: lib/code.ex:307
msgid ""
"Requires the given `file`.\n"
"\n"
"Accepts `relative_to` as an argument to tell where the file is located.\n"
"The return value is the same as that of `load_file/2`. If the file was "
"already\n"
"required/loaded, doesn't do anything and returns `nil`.\n"
"\n"
"Notice that if `require_file` is invoked by different processes "
"concurrently,\n"
"the first process to invoke `require_file` acquires a lock and the "
"remaining\n"
"ones will block until the file is available. I.e. if `require_file` is "
"called\n"
"N times with a given file, it will be loaded only once. The first process "
"to\n"
"call `require_file` will get the list of loaded modules, others will get "
"`nil`.\n"
"\n"
"Check `load_file/2` if you want a file to be loaded multiple times.\n"
msgstr ""
"与えられた`file`をrequireします。\n"
"\n"
"ファイルの場所を尋ねるための引数として、`relative_to`を受け付けます。戻\n"
"値は、`load_file/2`と同じです。もしファイルが既にrequireやloadされてい\n"
"たら、何もせず、`nil`を返します。\n"
"\n"
"もし、`require_file`が並行する異るプロセスにより実行されたら、最初のプ\n"
"ロセスは`require_file`を実行するためにロックを要求します。そして残った\n"
"プロセスはファイルが有効になりまでブロックするでしょう。すなわち、もし\n"
"`require_file`がN回呼ばれたら、一度だけロードされるでしょう。\n"
"`require_file`を呼び出す最初のプロセスはロードされたモジュールのリスト\n"
"を得て、他のプロセスは`nil`を得るでしょう。\n"
"\n"
"もし一つのファイルを複数回ロードしたいならば、`load_file/2`を\n"
"チェックしてください。\n"

#. TRANSLATORS: def GenServer.reply(client, reply)
#: lib/gen_server.ex:471
msgid ""
"Replies to a client.\n"
"\n"
"This function can be used by a server to explicitly send a reply to a\n"
"client that called `call/3` or `multi_call/4`. When the reply cannot be\n"
"defined in the return value of `handle_call/3`.\n"
"\n"
"The `client` must be the `from` argument (the second argument) received\n"
"in `handle_call/3` callbacks. Reply is an arbitrary term which will be\n"
"given back to the client as the return value of the call.\n"
"\n"
"This function always returns `:ok`.\n"
msgstr ""
"clientへ応答します。\n"
"\n"
"この関数は、`call/3`または`multi_call/4`を呼び出したクライアントに、\n"
"明示的に応答を送信するために、サーバによって使われることがあります。\n"
"応答が`handle_call/3`の戻値で定義されることが出来無い時。\n"
"\n"
"`client`は、`handle_call/3`コールバックで受信した、(2番目の引数の)\n"
"`from`引数でなくてはなりません。\n"
"`reply`は、呼び出しの戻値としてクライアントに返される、任意のtermです。\n"
"\n"
"この関数は常に`:ok`を返します。\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.require(module, opts)
#: lib/kernel/special_forms.ex:488
msgid ""
"Requires a given module to be compiled and loaded.\n"
"\n"
"## Examples\n"
"\n"
"Notice that usually modules should not be required before usage,\n"
"the only exception is if you want to use the macros from a module.\n"
"In such cases, you need to explicitly require them.\n"
"\n"
"Let's suppose you created your own `if` implementation in the module\n"
"`MyMacros`. If you want to invoke it, you need to first explicitly\n"
"require the `MyMacros`:\n"
"\n"
"    defmodule Math do\n"
"      require MyMacros\n"
"      MyMacros.if do_something, it_works\n"
"    end\n"
"\n"
"An attempt to call a macro that was not loaded will raise an error.\n"
"\n"
"## Alias shortcut\n"
"\n"
"`require` also accepts `as:` as an option so it automatically sets\n"
"up an alias. Please check `alias` for more information.\n"
"\n"
msgstr ""
"コンパイルされてロードされた、与えられたモジュールを\n"
"requireします。\n"
"\n"
"## 例\n"
"\n"
"通常、モジュールが使用の前にrequireされてなくてもよいことに気を付けてく\n"
"ださい。モジュールからマクロを使いたい場合が唯一の例外です。\n"
"そんな場合は、requireを明示的に使う必要があります。\n"
"\n"
"モジュール`MyMacros`の中で独自の`if`の実装を作ったとします。\n"
"もしそれを実行したいなら、最初に明示的に`MyMacros`をrequireする\n"
"必要があります:\n"
"\n"
"    defmodule Math do\n"
"      require MyMacros\n"
"      MyMacros.if do_something, it_works\n"
"    end\n"
"\n"
"ロードされなかったマクロを呼び出す試みは、エラーを上げます。\n"
"\n"
"## Alias ショートカット\n"
"\n"
"`require`は、エイリアスを自動的にセットアップするオプションとして、\n"
"`as:`も受け付けます。詳細は、`alias`をチェックしてください。\n"
"\n"

#. TRANSLATORS: def GenEvent.swap_handler(manager, handler1, args1, handler2, args2)
#: lib/gen_event.ex:481
msgid ""
"Replaces an old event handler with a new one in the event `manager`.\n"
"\n"
"First, the old event handler is deleted by calling `terminate/2` with\n"
"the given `args1` and collects the return value. Then the new event handler\n"
"is added and initiated by calling `init({args2, state}), where term is the\n"
"return value of calling `terminate/2` in the old handler. This makes it\n"
"possible to transfer information from one handler to another.\n"
"\n"
"The new handler will be added even if the specified old event handler\n"
"is not installed or if the handler fails to terminate with a given reason\n"
"in which case `state = {:error, term}`.\n"
"\n"
"If `init/1` in the second handler returns a correct value, this\n"
"function returns `:ok`.\n"
msgstr ""
"イベント`manager`において、古いイベントハンドラを、新しいそれに入れ替えま"
"す。\n"
"\n"
"最初に、古いイベントハンドラは、与えられた`args1`で\n"
"`terminate/2`を呼び出して、削除されます。\n"
"そして戻値を収集します。\n"
"それから、新しいイベントハンドラが追加され、\n"
"`init({args2, term})`を呼びだして初期化します。\n"
"ここでtermは古いハンドラで`terminate/2`の戻値です。\n"
"これは、一方のハンドラからもう一方へ転送することが出来ることを\n"
"意味します。\n"
"\n"
"もし指定された古いイベントハンドラがインストールされていないなら、\n"
"あるいは、もしハンドラが終了に失敗し、`state = {:error, term}`と\n"
"なったら、新しいハンドラが追加されます。\n"
"\n"
"もし二つめのハンドラで`init/1`が正しい値を返せば、この関数は`:ok`を\n"
"返します。\n"

#. TRANSLATORS: def GenEvent.swap_mon_handler(manager, handler1, args1, handler2, args2)
#: lib/gen_event.ex:491
msgid ""
"Replaces an old event handler with a new monitored one in the event "
"`manager`.\n"
"\n"
"Read the docs for `add_mon_handler/3` and `swap_handler/5` for more "
"information.\n"
msgstr ""
"イベント`manager`で、古いイベントマネージャを新しいモニタされた\n"
"イベントハンドラで置き換えます。\n"
"\n"
"詳細は、`add_mon_handler/3`と`swap_handler/5`のドキュメントを参照してく\n"
"ださい。\n"

#. TRANSLATORS: def Code.unload_files(files)
#: lib/code.ex:23
msgid ""
"Removes files from the loaded files list.\n"
"\n"
"The modules defined in the file are not removed;\n"
"calling this function only removes them from the list,\n"
"allowing them to be required again.\n"
msgstr ""
"ロードされたファイルリストからファイルを取り除きます。\n"
"\n"
"ファイルに定義されているモジュールは取り除かれません;この関数を呼ぶこと\n"
"はリストから取り除くだけで、それらは再び要求されることを許します。\n"

#. TRANSLATORS: def File.rm_rf(path)
#: lib/file.ex:806
msgid ""
"Removes files and directories recursively at the given `path`.\n"
"Symlinks are not followed but simply removed, non-existing\n"
"files are simply ignored (i.e. doesn't make this function fail).\n"
"\n"
"Returns `{:ok, files_and_directories}` with all files and\n"
"directories removed in no specific order, `{:error, reason, file}`\n"
"otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    File.rm_rf \"samples\"\n"
"    #=> {:ok, [\"samples\", \"samples/1.txt\"]}\n"
"\n"
"    File.rm_rf \"unknown\"\n"
"    #=> {:ok, []}\n"
"\n"
msgstr ""
"与えられた`path`を再帰的にファイルとディレクトリを削除します。\n"
"シンボリックリンクは辿らずに単に削除します。\n"
"存在しないファイルは単に無視されます(即ち、この関数は失敗しません)。\n"
"\n"
"削除した全てのファイルとディレクトリの順不同のリストを\n"
"file_and_directoriesとして、`{:ok, file_and_directories}`を返します。\n"
"さもなくば、`{:error, reason, file}`を返します。\n"
"\n"
"## 例\n"
"\n"
"    File.rm_rf \"samples\"\n"
"    #=> {:ok, [\"samples\", \"samples/1.txt\"]}\n"
"\n"
"    File.rm_rf \"unknown\"\n"
"    #=> {:ok, []}\n"
"\n"

#. TRANSLATORS: def GenEvent.remove_handler(manager, handler, args)
#: lib/gen_event.ex:460
msgid ""
"Removes an event handler from the event `manager`.\n"
"\n"
"The event manager will call `terminate/2` to terminate the event handler\n"
"and return the callback value. If the specified event handler is not\n"
"installed, the function returns `{:error, :not_found}`.\n"
msgstr ""
"イベントマネージャ`manager`からイベントハンドラを削除します。\n"
"\n"
"イベントマネージャはイベントハンドラを終了し、コールバック値を返すため\n"
"に`terminate/2`を呼び出すでしょう。もし指定されたイベントハンドラがイン\n"
"ストールされていないなら、この関数は`{:error, :not_found}`を返し\n"
"ます。\n"

#. TRANSLATORS: def Process.unregister(name)
#: lib/process.ex:287
msgid ""
"Removes the registered name, associated with a pid or a port identifier.\n"
"\n"
"See http://www.erlang.org/doc/man/erlang.html#unregister-1 for more info.\n"
msgstr ""
"登録されたnameと、それに関連付けられたpidあるいはport識別子を、\n"
"削除します。\n"
"\n"
"詳細は、 http://www.erlang.org/doc/man/erlang.html#unregister-1 \n"
"を参照してください。\n"

#. TRANSLATORS: def Process.unlink(pid)
#: lib/process.ex:263
msgid ""
"Removes the link, if there is one, between the calling process and\n"
"the process or port referred to by `pid`. Returns `true` and does not\n"
"fail, even if there is no link or `id` does not exist\n"
"\n"
"See http://www.erlang.org/doc/man/erlang.html#unlink-1 for more info.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"もし、呼び出したプロセスと、`pid`で参照されたプロセスあるいはポートとの\n"
"間にリンクがあれば、それを削除します。\n"
"もしリンクが無い、あるいは`pid`が存在しないとしても、\n"
"失敗せず、`true`を返します。\n"
"\n"
"詳細は http://www.erlang.org/doc/man/erlang.html#unlink-1 を参照してく\n"
"ださい。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Tuple.delete_at(tuple, index)
#: lib/tuple.ex:63
msgid ""
"Removes an element from a tuple.\n"
"\n"
"Deletes the element at the zero-based `index` from `tuple`.\n"
"Raises an `ArgumentError` if `index` is greater than\n"
"or equal to the length of `tuple`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> tuple = {:foo, :bar, :baz}\n"
"    iex> Tuple.delete_at(tuple, 0)\n"
"    {:bar, :baz}\n"
"\n"
msgstr ""
"タプルから要素を削除します。\n"
"\n"
"`tuple`から0始まりの`index`で要素を削除します。\n"
"もし`index`が`tuple`の長さと同じか大きかったら、\n"
"`ArgumentError`を上げます。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> tuple = {:foo, :bar, :baz}\n"
"    iex> Tuple.delete_at(tuple, 0)\n"
"    {:bar, :baz}\n"
"\n"

#. TRANSLATORS: def Module.register_attribute(module, new, opts)
#: lib/module.ex:829
msgid ""
"Registers an attribute. By registering an attribute, a developer\n"
"is able to customize how Elixir will store and accumulate the\n"
"attribute values.\n"
"\n"
"## Options\n"
"\n"
"When registering an attribute, two options can be given:\n"
"\n"
"  * `:accumulate` - several calls to the same attribute will\n"
"    accumulate instead of override the previous one. New attributes\n"
"    are always added to the top of the accumulated list.\n"
"\n"
"  * `:persist` - the attribute will be persisted in the Erlang\n"
"    Abstract Format. Useful when interfacing with Erlang libraries.\n"
"\n"
"By default, both options are `false`.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule MyModule do\n"
"      Module.register_attribute __MODULE__,\n"
"        :custom_threshold_for_lib,\n"
"        accumulate: true, persist: false\n"
"\n"
"      @custom_threshold_for_lib 10\n"
"      @custom_threshold_for_lib 20\n"
"      @custom_threshold_for_lib #=> [20, 10]\n"
"    end\n"
"\n"
msgstr ""
"アトリビュートを登録します。アトリビュートを登録するとき、\n"
"開発者は、Elixirがアトリビュート値を保存して、累積する方法を、\n"
"カスタマイズできます。\n"
"\n"
"## オプション\n"
"\n"
"アトリビュートを登録するとき、二つのオプションを与えることができます:\n"
"\n"
"  * `:accumulate` - 同じアトリビュートへの幾つかの呼び出しは、\n"
"     前のものを上書きする替わりに累積します。新しいアトリビュートは\n"
"     常に累積リストの先頭に追加されます。\n"
"\n"
"  * `:persist` - アトリビュートはErlang Abstract Formatで保存\n"
"     されます。Erlangライブラリと相互作用するとき役立ちます。\n"
"\n"
"デフォルトでは、両方のオプションは`false`です。\n"
"\n"
"## 例\n"
"\n"
"    defmodule MyModule do\n"
"      Module.register_attribute __MODULE__,\n"
"        :custom_threshold_for_lib,\n"
"        accumulate: true, persist: false\n"
"\n"
"      @custom_threshold_for_lib 10\n"
"      @custom_threshold_for_lib 20\n"
"      @custom_threshold_for_lib #=> [20, 10]\n"
"    end\n"
"\n"

#. TRANSLATORS: Elixir.Regex Summary
#: lib/regex.ex:1
msgid ""
"Regular expressions for Elixir built on top of Erlang's `re` module.\n"
"\n"
"As the `re` module, Regex is based on PCRE\n"
"(Perl Compatible Regular Expressions). More information can be\n"
"found in the [`re` documentation](http://www.erlang.org/doc/man/re.html).\n"
"\n"
"Regular expressions in Elixir can be created using `Regex.compile!/2`\n"
"or using the special form with [`~r`](Kernel.html#sigil_r/2):\n"
"\n"
"    # A simple regular expressions that matches foo anywhere in the string\n"
"    ~r/foo/\n"
"\n"
"    # A regular expression with case insensitive and unicode options\n"
"    ~r/foo/iu\n"
"\n"
"A Regex is represented internally as the `Regex` struct. Therefore,\n"
"`%Regex{}` can be used whenever there is a need to match on them.\n"
"\n"
"## Modifiers\n"
"\n"
"The modifiers available when creating a Regex are:\n"
"\n"
"  * `unicode` (u) - enables unicode specific patterns like `\\p` and "
"changes\n"
"    modifiers like `\\w`, `\\W`, `\\s` and friends to also match on "
"unicode.\n"
"    It expects valid unicode strings to be given on match\n"
"\n"
"  * `caseless` (i) - add case insensitivity\n"
"\n"
"  * `dotall` (s) - causes dot to match newlines and also set newline to\n"
"    anycrlf; the new line setting can be overridden by setting `(*CR)` or\n"
"    `(*LF)` or `(*CRLF)` or `(*ANY)` according to re documentation\n"
"\n"
"  * `multiline` (m) - causes `^` and `$` to mark the beginning and end of\n"
"    each line; use `\\A` and `\\z` to match the end or beginning of the "
"string\n"
"\n"
"  * `extended` (x) - whitespace characters are ignored except when escaped\n"
"    and allow `#` to delimit comments\n"
"\n"
"  * `firstline` (f) - forces the unanchored pattern to match before or at "
"the\n"
"    first newline, though the matched text may continue over the newline\n"
"\n"
"  * `ungreedy` (U) - inverts the \"greediness\" of the regexp\n"
"    (the previous `r` option is deprecated in favor of `U`)\n"
"\n"
"The options not available are:\n"
"\n"
"  * `anchored` - not available, use `^` or `\\A` instead\n"
"  * `dollar_endonly` - not available, use `\\z` instead\n"
"  * `no_auto_capture` - not available, use `?:` instead\n"
"  * `newline` - not available, use `(*CR)` or `(*LF)` or `(*CRLF)` or\n"
"    `(*ANYCRLF)` or `(*ANY)` at the beginning of the regexp according to "
"the\n"
"    re documentation\n"
"\n"
"## Captures\n"
"\n"
"Many functions in this module allows what to capture in a regex\n"
"match via the `:capture` option. The supported values are:\n"
"\n"
"  * `:all` - all captured subpatterns including the complete matching "
"string\n"
"    (this is the default)\n"
"\n"
"  * `:first` - only the first captured subpattern, which is always the\n"
"    complete matching part of the string; all explicitly captured "
"subpatterns\n"
"    are discarded\n"
"\n"
"  * `:all_but_first`- all but the first matching subpattern, i.e. all\n"
"    explicitly captured subpatterns, but not the complete matching part of\n"
"    the string\n"
"\n"
"  * `:none` - do not return matching subpatterns at all\n"
"\n"
"  * `:all_names` - captures all names in the Regex\n"
"\n"
"  * `list(binary)` - a list of named captures to capture\n"
"\n"
msgstr ""
"Erlangの`re`モジュールの上に作られたElixirの正規表現\n"
"\n"
"`re`モジュールとして、RegexはPCRE(Perl Compatible Regular Expressions)\n"
"に基いています。詳細は、[`re`\n"
"documentation](http://www.erlang.org/doc/man/re.html)に見付かります。\n"
"\n"
"Elixirの正規表現は`Regex.compile!/2`またはスペシャルフォーム\n"
"[`~r`](Kernel.html#sigil_r/2)を使って作成することができます:\n"
"\n"
"    # 文字列中のどこでもfooにマッチするシンプルな正規表現\n"
"    ~r/foo/\n"
"\n"
"    # 大文字小文字を無視、unicodeの二つのオプションのついた正規表現\n"
"    ~r/foo/iu\n"
"\n"
"Regexは`Regex`構造体として内部では表現されます。従って、\n"
"それらにマッチする必要があるときは何時でも`%Regex{}`は使われます。\n"
"\n"
"## モディファイア\n"
"\n"
"Regexを作るときに有効なモディファイアは以下の通りです:\n"
"\n"
"  * `unicode` (u) - `\\p`のようなunicode特有のパターンを有効にし、\n"
"    `\\w`、`\\W`、`\\s`などの様なモディファイアをunicodeにも\n"
"     マッチするように変更します。与えられたマッチは有効なunicode\n"
"     文字列を予想します\n"
"\n"
"  * `caseless` (i) - 大文字小文字を無視します\n"
"\n"
"  * `dotall` (s) - ドット(.)を改行にマッチさせ、改行を(*ANYCRLF)に\n"
"    にセットします; 改行設定は`(*CR)`、`(*LF)`、`(*CRLF)`、`(*ANY)`を\n"
"    設定することで上書きできます。それらに関しては re のドキュメントを\n"
"    参照してください\n"
"\n"
"  * `multiline` (m) - `^`と`$`それぞれの行の先頭と末尾にマークします;\n"
"    文字列の先頭と末尾にマッチするためには`\\A`と`\\Z`を使ってください\n"
"\n"
"  * `extended` (x) - エスケープされたものを除き、空白文字は無視されます。\n"
"     そして、`#`でコメントを区切るのを許します。\n"
"\n"
"  * `firstline` (f) - マッチしたテキストが改行を越えて続くかも\n"
"    しれないが、先頭固定ではないパターンでも、最初の改行あるいは\n"
"    その前でマッチすることを強制します。\n"
"\n"
"  * `ungreedy` (U) - 正規表現の\"欲張り\"を反転します。\n"
"     (以前の`r`オプションはdeprecatedで、`U`を使ってください)\n"
"\n"
"有効ではないオプションは以下の通りです:\n"
"\n"
"  * `anchored` - 無効です。 かわりに'^'か`\\A`を使います\n"
"  * `dollar_endonly` - 無効です。かわりに`\\z`を使います。\n"
"  * `no_auto_capture` - 無効です。かわりに`?:`を使います。\n"
"  * `newline` - 無効です。かわりに`(*CR)`、 `(*LF)` 、`(*CRLF)` 、\n"
"    `(*ANYCRLF)` 、`(*ANY)` を正規表現の前に設定します。\n"
"     詳しくは re のドキュメントを参照してください\n"
"\n"
"## キャプチャ(捕捉)\n"
"\n"
"このモジュールの多くの関数は、正規表現マッチで`:capture`オプションにより\n"
"キャプチャすることを許します。サポートされている値は以下の通りです:\n"
"\n"
"  * `:all` - 完全にマッチした文字列を含むサブパターンを全てキャプチャします\n"
"     (これはデフォルトです)\n"
"\n"
"  * `:first` - 常に文字列の部分が完全にマッチした最初のサブパターンだけ\n"
"    キャプチャします; 全ての明確にキャプチャされたサブパターンは\n"
"    放棄されます\n"
"\n"
"  * `:all_but_first`- 最初のサブパターン以外、すなわち全ての明確に\n"
"    キャプチャされたサブパターンで、文字列の完全なマッチしている部分\n"
"    ではないものです\n"
"\n"
"  * `:none` - 全てのサブパターン返しません\n"
"\n"
"  * `:all_names` - Regexの全ての名前をキャプチャします\n"
"\n"
"  * `list(binary)` - キャプチャに名前付されたキャプチャリストを使います\n"
"\n"

#. TRANSLATORS: def System.at_exit(fun)
#: lib/system.ex:226
msgid ""
"Registers a program exit handler function.\n"
"\n"
"Registers a function that will be invoked at the end of program execution.\n"
"Useful for invoking a hook in \"script\" mode.\n"
"\n"
"The handler always executes in a different process from the one it was\n"
"registered in. As a consequence, any resources managed by the calling "
"process\n"
"(ETS tables, open files, etc.) won't be available by the time the handler\n"
"function is invoked.\n"
"\n"
"The function must receive the exit status code as an argument.\n"
msgstr ""
"プログラムのexitハンドラ関数を登録します。\n"
"\n"
"プログラムの実行の終わりに実行される、関数を登録します。\"script\"モード\n"
"でフックとして実行するのに便利です。\n"
"\n"
"ハンドラは登録されたものとは別のプロセスで通常は実行されます。結果とし\n"
"て呼び出したプロセスにより管理された如何なるリソース(ETSテーブル、開い\n"
"ているファイルなど)も、ハンドラ関数が実行された時には利用できません。\n"
"\n"
"関数は引数としてexitステータスコードを受け取らなくてはなりません。\n"

#. TRANSLATORS: def URI.default_port(scheme, port)
#: lib/uri.ex:63
msgid ""
"Registers a scheme with a default port.\n"
"\n"
"It is recommended for this function to be invoked in your\n"
"application start callback in case you want to register\n"
"new URIs.\n"
msgstr ""
"スキームのデフォルトポートを登録します。\n"
"\n"
"新しいURIを登録したい場合に備えて、この関数があなたの\n"
"アプリケーションのstartコールバックで実行されることは\n"
"推奨されます。\n"

#. TRANSLATORS: def Enumerable.reduce(collection, acc, fun)
#: lib/enum.ex:112
msgid ""
"Reduces the collection into a value.\n"
"\n"
"Most of the operations in `Enum` are implemented in terms of reduce.\n"
"This function should apply the given `reducer` function to each\n"
"item in the collection and proceed as expected by the returned accumulator.\n"
"\n"
"As an example, here is the implementation of `reduce` for lists:\n"
"\n"
"    def reduce(_,     {:halt, acc}, _fun),   do: {:halted, acc}\n"
"    def reduce(list,  {:suspend, acc}, fun), do: {:suspended, acc, "
"&reduce(list, &1, fun)}\n"
"    def reduce([],    {:cont, acc}, _fun),   do: {:done, acc}\n"
"    def reduce([h|t], {:cont, acc}, fun),    do: reduce(t, fun.(h, acc), "
"fun)\n"
"\n"
msgstr ""
"コレクションを一つの値に簡約(reduce)します。\n"
"\n"
"`Enum`のほとんどのオペレーションはreduceで実装されています。この関数は\n"
"与えられた`reducer`関数をコレクションのそれぞれのアイテムに適用して、返\n"
"されたアキュムレータにより、繰返し累積しなくてはなりません。\n"
"\n"
"例として、リストの`reduce`の実装です:\n"
"\n"
"    def reduce(_,     {:halt, acc}, _fun),   do: {:halted, acc}\n"
"    def reduce(list,  {:suspend, acc}, fun), do: {:suspended, acc, "
"&reduce(list, &1, fun)}\n"
"    def reduce([],    {:cont, acc}, _fun),   do: {:done, acc}\n"
"    def reduce([h|t], {:cont, acc}, fun),    do: reduce(t, fun.(h, acc), "
"fun)\n"
"\n"

#. TRANSLATORS: defmacro Kernel.!(arg)
#: lib/kernel.ex:1152
msgid ""
"Receives any argument and returns `true` if it is `false`\n"
"or `nil`. Returns `false` otherwise. Not allowed in guard\n"
"clauses.\n"
"\n"
"## Examples\n"
"\n"
"    iex> !Enum.empty?([])\n"
"    false\n"
"\n"
"    iex> !List.first([])\n"
"    true\n"
"\n"
msgstr ""
"任意の引数を受け取って、`false`あるいは`nil`以外なら\n"
"`true`を返します。さもなくば`false`を返します。\n"
"ガード節での使用は許されません。\n"
"\n"
"## 例\n"
"\n"
"    iex> !Enum.empty?([])\n"
"    false\n"
"\n"
"    iex> !List.first([])\n"
"    true\n"
"\n"

#. TRANSLATORS: def String.starts_with?(string, prefixes)
#: lib/string.ex:1214
msgid ""
"Returns `true` if `string` starts with any of the prefixes given, otherwise\n"
"returns `false`. `prefixes` can be either a single prefix or a list of "
"prefixes.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.starts_with? \"elixir\", \"eli\"\n"
"    true\n"
"\n"
"    iex> String.starts_with? \"elixir\", [\"erlang\", \"elixir\"]\n"
"    true\n"
"\n"
"    iex> String.starts_with? \"elixir\", [\"erlang\", \"ruby\"]\n"
"    false\n"
"\n"
msgstr ""
"もし、`string`が与えらえれたプレフィックスの何れかで開始していれば、\n"
"`true`を返します。さもなければ`false`を返します。`prefixes`は一つの\n"
"文字列でも、プレフィックスのリストでもよいです。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.starts_with? \"elixir\", \"eli\"\n"
"    true\n"
"\n"
"    iex> String.starts_with? \"elixir\", [\"erlang\", \"elixir\"]\n"
"    true\n"
"\n"
"    iex> String.starts_with? \"elixir\", [\"erlang\", \"ruby\"]\n"
"    false\n"
"\n"

#. TRANSLATORS: def String.ends_with?(string, suffixes)
#: lib/string.ex:1248
msgid ""
"Returns `true` if `string` ends with any of the suffixes given, otherwise\n"
"returns `false`. `suffixes` can be either a single suffix or a list of "
"suffixes.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.ends_with? \"language\", \"age\"\n"
"    true\n"
"\n"
"    iex> String.ends_with? \"language\", [\"youth\", \"age\"]\n"
"    true\n"
"\n"
"    iex> String.ends_with? \"language\", [\"youth\", \"elixir\"]\n"
"    false\n"
"\n"
msgstr ""
"もし、`string`が与えらえれたサフィックスの何れかで終了していれば、\n"
"`true`を返します。さもなければ`false`を返します。`suffixes`は一つの\n"
"文字列でも、サフィイクスのリストでもよいです。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.ends_with? \"language\", \"age\"\n"
"    true\n"
"\n"
"    iex> String.ends_with? \"language\", [\"youth\", \"age\"]\n"
"    true\n"
"\n"
"    iex> String.ends_with? \"language\", [\"youth\", \"elixir\"]\n"
"    false\n"
"\n"

#. TRANSLATORS: def Macro.escape(expr, opts \\ [])
#: lib/macro.ex:306
msgid ""
"Recursively escapes a value so it can be inserted\n"
"into a syntax tree.\n"
"\n"
"One may pass `unquote: true` to `escape/2`\n"
"which leaves `unquote` statements unescaped, effectively\n"
"unquoting the contents on escape.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Macro.escape(:foo)\n"
"    :foo\n"
"\n"
"    iex> Macro.escape({:a, :b, :c})\n"
"    {:{}, [], [:a, :b, :c]}\n"
"\n"
"    iex> Macro.escape({:unquote, [], [1]}, unquote: true)\n"
"    1\n"
"\n"
msgstr ""
"再帰的に、それが構文ツリーに挿入されることが出来るように値をエスケープしま"
"す。\n"
"\n"
"アンエスケープされた文を`unquote`で残し、エスケープの中で、効果的にコン\n"
"テンツをアンクォートするために、`unquote: true`を`escape/2`に送るかもし\n"
"れません。\n"
"\n"
"## 例\n"
"\n"
"    iex> Macro.escape(:foo)\n"
"    :foo\n"
"\n"
"    iex> Macro.escape({:a, :b, :c})\n"
"    {:{}, [], [:a, :b, :c]}\n"
"\n"
"    iex> Macro.escape({:unquote, [], [1]}, unquote: true)\n"
"    1\n"
"\n"

#. TRANSLATORS: def Exception.format_fa(fun, arity)
#: lib/exception.ex:392
msgid ""
"Receives an anonymous function and arity and formats it as\n"
"shown in stacktraces. The arity may also be a list of arguments.\n"
"\n"
"## Examples\n"
"\n"
"    Exception.format_fa(fn -> end, 1)\n"
"    #=> \"#Function<...>/1\"\n"
"\n"
msgstr ""
"無名関数とアリティを受け取り、スタックトレースに表示されるように\n"
"フォーマットします。アリティは引数のリストかもしれません。\n"
"\n"
"## 例\n"
"\n"
"    Exception.format_fa(fn -> end, 1)\n"
"    #=> \"#Function<...>/1\"\n"
"\n"

#. TRANSLATORS: def Macro.expand(tree, env)
#: lib/macro.ex:944
msgid ""
"Receives an AST node and expands it until it can no longer\n"
"be expanded.\n"
"\n"
"This function uses `expand_once/2` under the hood. Check\n"
"`expand_once/2` for more information and examples.\n"
msgstr ""
"ASTノードを受け取り、それをもはや展開できなくなるまで展開します。\n"
"\n"
"この関数は`expand_once/2`をフードの下で使います。\n"
"詳細と、例については、`expand_once/2`をチェックしてください。\n"

#. TRANSLATORS: def Macro.expand_once(ast, env)
#: lib/macro.ex:826
msgid ""
"Receives an AST node and expands it once.\n"
"\n"
"The following contents are expanded:\n"
"\n"
"  * Macros (local or remote)\n"
"  * Aliases are expanded (if possible) and return atoms\n"
"  * Pseudo-variables (`__ENV__`, `__MODULE__` and `__DIR__`)\n"
"  * Module attributes reader (`@foo`)\n"
"\n"
"If the expression cannot be expanded, it returns the expression\n"
"itself. Notice that `expand_once/2` performs the expansion just\n"
"once and it is not recursive. Check `expand/2` for expansion\n"
"until the node can no longer be expanded.\n"
"\n"
"## Examples\n"
"\n"
"In the example below, we have a macro that generates a module\n"
"with a function named `name_length` that returns the length\n"
"of the module name. The value of this function will be calculated\n"
"at compilation time and not at runtime.\n"
"\n"
"Consider the implementation below:\n"
"\n"
"    defmacro defmodule_with_length(name, do: block) do\n"
"      length = length(Atom.to_char_list(name))\n"
"\n"
"      quote do\n"
"        defmodule unquote(name) do\n"
"          def name_length, do: unquote(length)\n"
"          unquote(block)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"When invoked like this:\n"
"\n"
"    defmodule_with_length My.Module do\n"
"      def other_function, do: ...\n"
"    end\n"
"\n"
"The compilation will fail because `My.Module` when quoted\n"
"is not an atom, but a syntax tree as follow:\n"
"\n"
"    {:__aliases__, [], [:My, :Module]}\n"
"\n"
"That said, we need to expand the aliases node above to an\n"
"atom, so we can retrieve its length. Expanding the node is\n"
"not straight-forward because we also need to expand the\n"
"caller aliases. For example:\n"
"\n"
"    alias MyHelpers, as: My\n"
"\n"
"    defmodule_with_length My.Module do\n"
"      def other_function, do: ...\n"
"    end\n"
"\n"
"The final module name will be `MyHelpers.Module` and not\n"
"`My.Module`. With `Macro.expand/2`, such aliases are taken\n"
"into consideration. Local and remote macros are also\n"
"expanded. We could rewrite our macro above to use this\n"
"function as:\n"
"\n"
"    defmacro defmodule_with_length(name, do: block) do\n"
"      expanded = Macro.expand(name, __CALLER__)\n"
"      length   = length(Atom.to_char_list(expanded))\n"
"\n"
"      quote do\n"
"        defmodule unquote(name) do\n"
"          def name_length, do: unquote(length)\n"
"          unquote(block)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
msgstr ""
"ASTノードを受け取り、それを一度だけ展開します。\n"
"\n"
"以下のコンテンツが展開されます:\n"
"\n"
"  * マクロ (ローカルまたはリモート)\n"
"  * エリアスは展開され(可能なら)、アトムを返します。\n"
"  * 仮想変数(`__ENV__`, `__MODULE__` and `__DIR__`)\n"
"  * モジュールアトリビュート(`@foo`)\n"
"\n"
"もし式が展開できないなら、その式自身を返します。`expand_once/2`はちょう\n"
"ど一回だけ展開を実行し、再帰的ではないいことに注意してください。もはや\n"
"展開できなくなるまで展開するためには、`expand/2`をチェックしてください。\n"
"\n"
"## 例\n"
"\n"
"下の例で、モジュール名の長さを返す`name_length`という名前の関数とモジュー\n"
"ルを生成するマクロがあります。この関数の値はコンパイル時に計算され、実\n"
"行時ではありません。\n"
"\n"
"以下の実装を考えてみます:\n"
"\n"
"    defmacro defmodule_with_length(name, do: block) do\n"
"      length = length(Atom.to_char_list(name))\n"
"\n"
"      quote do\n"
"        defmodule unquote(name) do\n"
"          def name_length, do: unquote(length)\n"
"          unquote(block)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"実行するときは、このようにします:\n"
"\n"
"    defmodule_with_length My.Module do\n"
"      def other_function, do: ...\n"
"    end\n"
"\n"
"引用されたときの`My.Module`はアトムではないので、構文ツリーは\n"
"以下のようになり、コンパイルは失敗するでしょう:\n"
"\n"
"    {:__aliases__, [], [:My, :Module]}\n"
"\n"
"それは、別名ノードをアトムに展開する必要があるということです。そのあと\n"
"で、その長さを取り出すことができます。呼び出しの別名の展開が必要なので、\n"
"ノードの展開は簡単ではありません。例えば:\n"
"\n"
"    alias MyHelpers, as: My\n"
"\n"
"    defmodule_with_length My.Module do\n"
"      def other_function, do: ...\n"
"    end\n"
"\n"
"最後のモジュールは`MyHelpers.Module`と名付け、`My.Module`では\n"
"ありません。`Macro.expand/2`で、それらの別名は考慮されて\n"
"扱われます。ローカルとリモートのマクロもまた展開されます。\n"
"我々は、上記のマクロをこれらの機能を使って書き直すことができます:\n"
"\n"
"    defmacro defmodule_with_length(name, do: block) do\n"
"      expanded = Macro.expand(name, __CALLER__)\n"
"      length   = length(Atom.to_char_list(expanded))\n"
"\n"
"      quote do\n"
"        defmodule unquote(name) do\n"
"          def name_length, do: unquote(length)\n"
"          unquote(block)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"

#. TRANSLATORS: def Exception.format_stacktrace_entry(entry)
#: lib/exception.ex:333
msgid "Receives a stacktrace entry and formats it into a string.\n"
msgstr "スタックトレースエントリを受け取り、文字列にフォーマットします。\n"

#. TRANSLATORS: @type on_start
#: lib/supervisor.ex:0
msgid "Return values of `start_link` functions"
msgstr "`start_link`関数の戻値"

#. TRANSLATORS: @type on_start_child
#: lib/supervisor.ex:0
msgid "Return values of `start_child` functions"
msgstr "`start_child`関数の戻値"

#. TRANSLATORS: def Regex.replace(regex, string, replacement, options \\ [])
#: lib/regex.ex:461
msgid ""
"Receives a regex, a binary and a replacement, returns a new\n"
"binary where the all matches are replaced by replacement.\n"
"\n"
"The replacement can be either a string or a function. The string\n"
"is used as a replacement for every match and it allows specific\n"
"captures to be accessed via `\\N` or `\\g{N}`, where `N` is the\n"
"capture. In case `\\0` is used, the whole match is inserted.\n"
"\n"
"When the replacement is a function, the function may have arity\n"
"N where each argument maps to a capture, with the first argument\n"
"being the whole match. If the function expects more arguments\n"
"than captures found, the remaining arguments will receive `\"\"`.\n"
"\n"
"## Options\n"
"\n"
"  * `:global` - when `false`, replaces only the first occurrence\n"
"    (defaults to true)\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.replace(~r/d/, \"abc\", \"d\")\n"
"    \"abc\"\n"
"\n"
"    iex> Regex.replace(~r/b/, \"abc\", \"d\")\n"
"    \"adc\"\n"
"\n"
"    iex> Regex.replace(~r/b/, \"abc\", \"[\\\\0]\")\n"
"    \"a[b]c\"\n"
"\n"
"    iex> Regex.replace(~r/a(b|d)c/, \"abcadc\", \"[\\\\1]\")\n"
"    \"[b][d]\"\n"
"\n"
"    iex> Regex.replace(~r/a(b|d)c/, \"abcadc\", fn _, x -> \"[#{x}]\" end)\n"
"    \"[b][d]\"\n"
"\n"
msgstr ""
"正規表現、バイナリとreplacementを受け取り、全てのマッチがreplacementで\n"
"置き換えられた、新しいバイナリを返します。\n"
"\n"
"replacementは、文字列でも関数でも可能です。あらゆるマッチの為の\n"
"replacementとして文字列を使われます。そして、それは`N`はキャプチャした\n"
"文字列とすると、`\\N`または`\\g{N}`によってアクセスできる特定のキャプチャを\n"
"許します。`\\0`が使われた場合、マッチ全体が挿入されます。\n"
"\n"
"replacementが関数のとき、関数は、最初の引数はマッチ全体である、それぞれ\n"
"の引数がキャプチャにマップされるアリティNを持つかもしれません。もし関数\n"
"がキャプチャされるより多くの引数を予想していたら、残りの引数は`\"\"`とな\n"
"ります。\n"
"\n"
"## オプション\n"
"\n"
"  * `:global` - `false`の時、最初のだけ置き換えます(デフォルトはtrueです)\n"
"\n"
"## 例\n"
"\n"
"    iex> Regex.replace(~r/d/, \"abc\", \"d\")\n"
"    \"abc\"\n"
"\n"
"    iex> Regex.replace(~r/b/, \"abc\", \"d\")\n"
"    \"adc\"\n"
"\n"
"    iex> Regex.replace(~r/b/, \"abc\", \"[\\\\0]\")\n"
"    \"a[b]c\"\n"
"\n"
"    iex> Regex.replace(~r/a(b|d)c/, \"abcadc\", \"[\\\\1]\")\n"
"    \"[b][d]\"\n"
"\n"
"    iex> Regex.replace(~r/a(b|d)c/, \"abcadc\", fn _, x -> \"[#{x}]\" end)\n"
"    \"[b][d]\"\n"
"\n"

#. TRANSLATORS: def Supervisor.restart_child(supervisor, child_id)
#: lib/supervisor.ex:344
msgid ""
"Restarts a child process identified by `child_id`.\n"
"\n"
"The child specification must exist and the corresponding child process must "
"not\n"
"be running.\n"
"\n"
"Note that for temporary children, the child specification is automatically "
"deleted\n"
"when the child terminates, and thus it is not possible to restart such "
"children.\n"
"\n"
"If the child process start function returns `{:ok, child}` or\n"
"`{:ok, child, info}`, the pid is added to the supervisor and the function "
"returns\n"
"the same value.\n"
"\n"
"If the child process start function returns `:ignore`, the pid remains set "
"to\n"
"`:undefined` and the function returns `{:ok, :undefined}`.\n"
"\n"
"This function may error with an appropriate error tuple if the `child_id` is "
"not\n"
"found, or if the current process is running or being restarted.\n"
"\n"
"If the child process start function returns an error tuple or an erroneous "
"value,\n"
"or if it fails, the function returns `{:error, error}`.\n"
"\n"
"This operation is not supported by `simple_one_for_one` supervisors.\n"
msgstr ""
"`child_id`で指定される子プロセスをリスタートします。\n"
"\n"
"子仕様が存在しなくてはならず、対応する子プロセスは実行中では\n"
"いけません。\n"
"\n"
"テンポラリの子については、子仕様は子が終了すると自動的に削除され、リス\n"
"タートする可能性は無いことに注意してください。\n"
"\n"
"もし子プロセスのスタート関数が`{:ok, child}`または`{:ok, child,\n"
"info}`を返すと、そのpidがスーパバイザに追加され、\n"
"関数は同じ値を返します。\n"
"\n"
"もし子プロセスのスタート関数が`:ignore`を返したら、pidは`:undefined`に\n"
"セットされたままで、関数は`{:ok, :undefined}`を返します。\n"
"\n"
"この関数は、`child_id`が見付からない、あるいは、現在のプロセスが実行中\n"
"でリスタートされたときには、適切なエラーを示すタプルでエラーとなるかも\n"
"しれません。\n"
"\n"
"もし子プロセスのスタート関数がエラータプルあるいは、間違った値を返した\n"
"ら、あるいは失敗したら、関数は`{:error, error}`を返します。\n"
"\n"
"このオペレーションは`simple_one_for_one`スーパバイザではサポートされて\n"
"いません。\n"

#. TRANSLATORS: Elixir.Kernel.Typespec Summary
#: lib/kernel/typespec.ex:1
msgid ""
"Provides macros and functions for working with typespecs.\n"
"\n"
"Elixir comes with a notation for declaring types and specifications. Elixir "
"is\n"
"dynamically typed, as such typespecs are never used by the compiler to\n"
"optimize or modify code. Still, using typespecs is useful as documentation "
"and\n"
"tools such as [Dialyzer](http://www.erlang.org/doc/man/dialyzer.html) can\n"
"analyze the code with typespecs to find bugs.\n"
"\n"
"The attributes `@type`, `@opaque`, `@typep`, `@spec` and `@callback` "
"available\n"
"in modules are handled by the equivalent macros defined by this module. See\n"
"sub-sections \"Defining a type\" and \"Defining a specification\" below.\n"
"\n"
"## Types and their syntax\n"
"\n"
"The type syntax provided by Elixir is fairly similar to the one in\n"
"[Erlang](http://www.erlang.org/doc/reference_manual/typespec.html).\n"
"\n"
"Most of the built-in types provided in Erlang (for example, `pid()`) are\n"
"expressed the same way: `pid()` or simply `pid`. Parameterized types are "
"also\n"
"supported (`list(integer)`) and so are remote types (`Enum.t`).\n"
"\n"
"Integers and atom literals are allowed as types (ex. `1`, `:atom` or\n"
"`false`). All other types are built of unions of predefined types. Certain\n"
"shorthands are allowed, such as `[...]`, `<<>>` and `{...}`.\n"
"\n"
"### Predefined types\n"
"\n"
"    Type :: any         # the top type, the set of all terms\n"
"          | none        # the bottom type, contains no terms\n"
"          | pid\n"
"          | port\n"
"          | reference\n"
"          | Atom\n"
"          | Bitstring\n"
"          | float\n"
"          | Fun\n"
"          | Integer\n"
"          | List\n"
"          | Map\n"
"          | Tuple\n"
"          | Union\n"
"          | UserDefined # Described in section \"Defining a type\"\n"
"\n"
"    Atom :: atom\n"
"          | ElixirAtom # `:foo`, `:bar`, ...\n"
"\n"
"    Bitstring :: <<>>\n"
"               | << _ :: M >>             # M is a positive integer\n"
"               | << _ :: _ * N >>         # N is a positive integer\n"
"               | << _ :: M, _ :: _ * N >>\n"
"\n"
"    Fun :: (... -> any)    # any function\n"
"         | (... -> Type)   # any arity, returning Type\n"
"         | (() -> Type))\n"
"         | (TList -> Type)\n"
"\n"
"    Integer :: integer\n"
"             | ElixirInteger                # ..., -1, 0, 1, ... 42 ...\n"
"             | ElixirInteger..ElixirInteger # an integer range\n"
"\n"
"    List :: list(Type)                        # proper list ([]-terminated)\n"
"          | improper_list(Type1, Type2)       # Type1=contents, "
"Type2=termination\n"
"          | maybe_improper_list(Type1, Type2) # Type1 and Type2 as above\n"
"          | nonempty_list(Type)               # proper non-empty list\n"
"          | []                                # empty list\n"
"          | [Type]                            # shorthand for list(Type)\n"
"          | [...]                             # shorthand for "
"nonempty_list()\n"
"          | [Type, ...]                       # shorthand for "
"nonempty_list(Type)\n"
"          | [Keyword]\n"
"\n"
"    Map :: map()            # map of any size\n"
"         | %{}              # map of any size\n"
"         | %Struct{}        # struct (see defstruct/1)\n"
"         | %Struct{Keyword}\n"
"         | %{Keyword}\n"
"         | %{Pairs}\n"
"\n"
"    Tuple :: tuple                 # a tuple of any size\n"
"           | {}                    # empty tuple\n"
"           | {TList}\n"
"           | record(Atom)          # record (see Record)\n"
"           | record(Atom, Keyword)\n"
"\n"
"    Keyword :: ElixirAtom: Type\n"
"             | ElixirAtom: Type, Keyword\n"
"\n"
"    Pairs :: Type => Type\n"
"           | Type => Type, Pairs\n"
"\n"
"    TList :: Type\n"
"           | Type, TList\n"
"\n"
"    Union :: Type | Type\n"
"\n"
"### Bit strings\n"
"\n"
"Bit string with a base size of 3:\n"
"\n"
"    << _ :: 3 >>\n"
"\n"
"Bit string with a unit size of 8:\n"
"\n"
"    << _ :: _ * 8 >>\n"
"\n"
"### Anonymous functions\n"
"\n"
"Any anonymous function:\n"
"\n"
"    ((...) -> any)\n"
"    (... -> any)\n"
"\n"
"Anonymous function with arity of zero:\n"
"\n"
"    (() -> type)\n"
"\n"
"Anonymous function with some arity:\n"
"\n"
"    ((type, type) -> type)\n"
"    (type, type -> type)\n"
"\n"
"## Built-in types\n"
"\n"
"Built-in type         | Defined as\n"
":-------------------- | :---------\n"
"`term`                | `any`\n"
"`binary`              | `<< _ :: _ * 8 >>`\n"
"`bitstring`           | `<< _ :: _ * 1 >>`\n"
"`boolean`             | `false` \\| `true`\n"
"`byte`                | `0..255`\n"
"`char`                | `0..0x10ffff`\n"
"`number`              | `integer` \\| `float`\n"
"`char_list`           | `[char]`\n"
"`list`                | `[any]`\n"
"`maybe_improper_list` | `maybe_improper_list(any, any)`\n"
"`nonempty_list`       | `nonempty_list(any)`\n"
"`iodata`              | `iolist` \\| `binary`\n"
"`iolist`              | `maybe_improper_list(byte` \\| `binary` \\| `iolist, "
"binary` \\| `[])`\n"
"`module`              | `atom` \\| `tuple`\n"
"`mfa`                 | `{atom, atom, arity}`\n"
"`arity`               | `0..255`\n"
"`node`                | `atom`\n"
"`timeout`             | `:infinity` \\| `non_neg_integer`\n"
"`no_return`           | `none`\n"
"`fun`                 | `(... -> any)`\n"
"\n"
"\n"
"Some built-in types cannot be expressed with valid syntax according to the\n"
"language defined above.\n"
"\n"
"Built-in type     | Can be interpreted as\n"
":---------------- | :--------------------\n"
"`non_neg_integer` | `0..`\n"
"`pos_integer`     | `1..`\n"
"`neg_integer`     | `..-1`\n"
"\n"
"Types defined in other modules are referred to as \"remote types\", they "
"are\n"
"referenced as `Module.type_name` (ex. `Enum.t` or `String.t`).\n"
"\n"
"## Defining a type\n"
"\n"
"    @type type_name :: type\n"
"    @typep type_name :: type\n"
"    @opaque type_name :: type\n"
"\n"
"A type defined with `@typep` is private. An opaque type, defined with\n"
"`@opaque` is a type where the internal structure of the type will not be\n"
"visible, but the type is still public.\n"
"\n"
"Types can be parameterized by defining variables as parameters, these "
"variables\n"
"can then be used to define the type.\n"
"\n"
"    @type dict(key, value) :: [{key, value}]\n"
"\n"
"## Defining a specification\n"
"\n"
"    @spec function_name(type1, type2) :: return_type\n"
"    @callback function_name(type1, type2) :: return_type\n"
"\n"
"Callbacks are used to define the callbacks functions of behaviours (see\n"
"`Behaviour`).\n"
"\n"
"Guards can be used to restrict type variables given as arguments to the\n"
"function.\n"
"\n"
"    @spec function(arg) :: [arg] when arg: atom\n"
"\n"
"Type variables with no restriction can also be defined.\n"
"\n"
"    @spec function(arg) :: [arg] when arg: var\n"
"\n"
"Specifications can be overloaded just like ordinary functions.\n"
"\n"
"    @spec function(integer) :: atom\n"
"    @spec function(atom)    :: integer\n"
"\n"
"## Notes\n"
"\n"
"Elixir discourages the use of type `string` as it might be confused with\n"
"binaries which are referred to as \"strings\" in Elixir (as opposed to "
"character\n"
"lists). In order to use the type that is called `string` in Erlang, one has "
"to\n"
"use the `char_list` type which is a synonym for `string`. If you use "
"`string`,\n"
"you'll get a warning from the compiler.\n"
"\n"
"If you want to refer to the \"string\" type (the one operated on by "
"functions in\n"
"the `String` module), use `String.t` type instead.\n"
msgstr ""
"typespecで働くマクロと関数を提供します。\n"
"\n"
"Elixirにはタイプと仕様を宣言するための記法があります。\n"
"typesepcは、最適化やコードの修正するためにコンパイラによって、\n"
"決して使われないように、Elixirは動的な型付けされます。\n"
"しかし、typespecを使うことは、ドキュメントとツールとして便利です。\n"
"[Dialyzer](http://www.erlang.org/doc/man/dialyzer.html)のようなツールは、\n"
"コードをtypespecでバグを見付けるために、解析することができます。\n"
"\n"
"このモジュールにより定義された同等のマクロにより、\n"
"モジュールで有効な属性`@type`、 `@opaque`、 `@typep`、 \n"
"`@spec`と`@callback`がハンドルされます。\n"
"以下のサブセクション \"Defining a type\" と \"Defining a specification\" を\n"
"参照してください。\n"
"\n"
"## Types and their syntax\n"
"\n"
"Elixirにより提供されたタイプ構文は、かなり\n"
"[Erlang](http://www.erlang.org/doc/reference_manual/typespec.html)の\n"
"それに類似しています。\n"
"\n"
"Erlangで提供されるほとんどのビルトインタイプ(例えば、`pid()`)は、同じ方\n"
"法で表現されます: `pid()`または、単に`pid`。パラメタ化されたタイプもま\n"
"たサポートされ(`list(integer)`)、リモートタイプもサポートされます\n"
"(`Enum.t`)。\n"
"\n"
"整数とアトムリテラルはタイプとして許されます(例, `1`、`:atom`または"
"`false`)。\n"
"他の全てのタイプは、あらかじめ定義されたタイプの結合から構築されます。\n"
"`[...]`、`<<...>>`、`{...}`のような、特定の速記法が許されます。\n"
"\n"
"### Predefined types\n"
"\n"
"    Type :: any         # the top type, the set of all terms\n"
"          | none        # the bottom type, contains no terms\n"
"          | pid\n"
"          | port\n"
"          | reference\n"
"          | Atom\n"
"          | Bitstring\n"
"          | float\n"
"          | Fun\n"
"          | Integer\n"
"          | List\n"
"          | Map\n"
"          | Tuple\n"
"          | Union\n"
"          | UserDefined # Described in section \"Defining a type\"\n"
"\n"
"    Atom :: atom\n"
"          | ElixirAtom # `:foo`, `:bar`, ...\n"
"\n"
"    Bitstring :: <<>>\n"
"               | << _ :: M >>             # M is a positive integer\n"
"               | << _ :: _ * N >>         # N is a positive integer\n"
"               | << _ :: M, _ :: _ * N >>\n"
"\n"
"    Fun :: (... -> any)    # any function\n"
"         | (... -> Type)   # any arity, returning Type\n"
"         | (() -> Type))\n"
"         | (TList -> Type)\n"
"\n"
"    Integer :: integer\n"
"             | ElixirInteger                # ..., -1, 0, 1, ... 42 ...\n"
"             | ElixirInteger..ElixirInteger # an integer range\n"
"\n"
"    List :: list(Type)                        # proper list ([]-terminated)\n"
"          | improper_list(Type1, Type2)       # Type1=contents, "
"Type2=termination\n"
"          | maybe_improper_list(Type1, Type2) # Type1 and Type2 as above\n"
"          | nonempty_list(Type)               # proper non-empty list\n"
"          | []                                # empty list\n"
"          | [Type]                            # shorthand for list(Type)\n"
"          | [...]                             # shorthand for "
"nonempty_list()\n"
"          | [Type, ...]                       # shorthand for "
"nonempty_list(Type)\n"
"          | [Keyword]\n"
"\n"
"    Map :: map()            # map of any size\n"
"         | %{}              # map of any size\n"
"         | %Struct{}        # struct (see defstruct/1)\n"
"         | %Struct{Keyword}\n"
"         | %{Keyword}\n"
"         | %{Pairs}\n"
"\n"
"    Tuple :: tuple                 # a tuple of any size\n"
"           | {}                    # empty tuple\n"
"           | {TList}\n"
"           | record(Atom)          # record (see Record)\n"
"           | record(Atom, Keyword)\n"
"\n"
"    Keyword :: ElixirAtom: Type\n"
"             | ElixirAtom: Type, Keyword\n"
"\n"
"    Pairs :: Type => Type\n"
"           | Type => Type, Pairs\n"
"\n"
"    TList :: Type\n"
"           | Type, TList\n"
"\n"
"    Union :: Type | Type\n"
"\n"
"### Bit strings\n"
"\n"
"Bit string with a base size of 3:\n"
"\n"
"    << _ :: 3 >>\n"
"\n"
"Bit string with a unit size of 8:\n"
"\n"
"    << _ :: _ * 8 >>\n"
"\n"
"### Anonymous functions\n"
"\n"
"Any anonymous function:\n"
"\n"
"    ((...) -> any)\n"
"    (... -> any)\n"
"\n"
"Anonymous function with arity of zero:\n"
"\n"
"    (() -> type)\n"
"\n"
"Anonymous function with some arity:\n"
"\n"
"    ((type, type) -> type)\n"
"    (type, type -> type)\n"
"\n"
"## Built-in types\n"
"\n"
"Built-in type         | Defined as\n"
":-------------------- | :---------\n"
"`term`                | `any`\n"
"`binary`              | `<< _ :: _ * 8 >>`\n"
"`bitstring`           | `<< _ :: _ * 1 >>`\n"
"`boolean`             | `false` \\| `true`\n"
"`byte`                | `0..255`\n"
"`char`                | `0..0x10ffff`\n"
"`number`              | `integer` \\| `float`\n"
"`char_list`           | `[char]`\n"
"`list`                | `[any]`\n"
"`maybe_improper_list` | `maybe_improper_list(any, any)`\n"
"`nonempty_list`       | `nonempty_list(any)`\n"
"`iodata`              | `iolist` \\| `binary`\n"
"`iolist`              | `maybe_improper_list(byte` \\| `binary` \\| `iolist, "
"binary` \\| `[])`\n"
"`module`              | `atom` \\| `tuple`\n"
"`mfa`                 | `{atom, atom, arity}`\n"
"`arity`               | `0..255`\n"
"`node`                | `atom`\n"
"`timeout`             | `:infinity` \\| `non_neg_integer`\n"
"`no_return`           | `none`\n"
"`fun`                 | `(... -> any)`\n"
"\n"
"\n"
"いくつかのビルトインタイプは上で定義された言語によった\n"
"有効な構文で表現できません。\n"
"\n"
"Built-in type     | Can be interpreted as\n"
":---------------- | :--------------------\n"
"`non_neg_integer` | `0..`\n"
"`pos_integer`     | `1..`\n"
"`neg_integer`     | `..-1`\n"
"\n"
"他のモジュールで定義されるタイプは\"リモートタイプ\"として参照されます。\n"
"それらは`Module.type_name`として参照されます(例. `Enum.t` や `String.t`)。\n"
"\n"
"## Defining a type\n"
"\n"
"    @type type_name :: type\n"
"    @typep type_name :: type\n"
"    @opaque type_name :: type\n"
"\n"
"`@typep`により定義されたタイプはプライベートです。\n"
"`@opaque`によって定義された不透明なタイプは、タイプの内部構造が\n"
"不可視なタイプで、そのタイプはまだパブリックです。\n"
"\n"
"タイプはパラメタとして変数を定義することによってパラメタ化でき、\n"
"それらの変数はタイプを定義するために使うことができます。\n"
"\n"
"    @type dict(key, value) :: [{key, value}]\n"
"\n"
"## Defining a specification\n"
"\n"
"    @spec function_name(type1, type2) :: return_type\n"
"    @callback function_name(type1, type2) :: return_type\n"
"\n"
"callbackはビヘイビアのコールバック関数を定義するために使います\n"
"(`Behaviour`参照)。\n"
"\n"
"ガードは関数の引数として与えられた変数のタイプを制限するために使います。\n"
"\n"
"    @spec function(arg) :: [arg] when arg: atom\n"
"\n"
"規制のないタイプ変数も定義することができます。\n"
"\n"
"    @spec function(arg) :: [arg] when arg: var\n"
"\n"
"仕様は通常の関数のようにオーバロードできます。\n"
"\n"
"    @spec function(integer) :: atom\n"
"    @spec function(atom)    :: integer\n"
"\n"
"## Notes\n"
"\n"
"Elixirは、Elixirで\"string\"とバイナリ(文字リストとは対照的に)\n"
"と混同されるかもしれないので、タイプ`string`の使用を阻みます。\n"
"Erlangの`string`と呼ばれるタイプを使うために、人は、\n"
"`string`のシノニムである`char_list`タイプを使わなければなりません。\n"
"もし`string`を使うなら、コンパイラから警告されます。\n"
"\n"
"(`String`モジュールの関数によって操作される)\"string\"タイプ\n"
"を参照したいなら、かわりに`String.t`を使ってください。\n"

#. TRANSLATORS: def Supervisor.Spec.supervise(children, options)
#: lib/supervisor/spec.ex:160
msgid ""
"Receives a list of children (workers or supervisors) to\n"
"supervise and a set of options.\n"
"\n"
"Returns a tuple containing the supervisor specification.\n"
"\n"
"## Examples\n"
"\n"
"    supervise children, strategy: :one_for_one\n"
"\n"
"## Options\n"
"\n"
"  * `:strategy` - the restart strategy option. It can be either\n"
"    `:one_for_one`, `:rest_for_one`, `:one_for_all`, or\n"
"    `:simple_one_for_one`. You can learn more about strategies\n"
"    in the `Supervisor` module docs.\n"
"\n"
"  * `:max_restarts` - the maximum amount of restarts allowed in\n"
"    a time frame. Defaults to 3.\n"
"\n"
"  * `:max_seconds` - the time frame in which `:max_restarts` applies.\n"
"    Defaults to 5.\n"
"\n"
"The `:strategy` option is required and by default maximum 3 restarts\n"
"are allowed within 5 seconds. Please check the `Supervisor` module for\n"
"a complete description of the available strategies.\n"
msgstr ""
"監督対象の子(workerかsupervisor)のリストと、オプション\n"
"を受け取ります。\n"
"\n"
"スーパバイザ仕様を含んだタプルを返します。\n"
"\n"
"## 例\n"
"\n"
"    supervise children, strategy: :one_for_one\n"
"\n"
"## Options\n"
"\n"
"  * `:strategy` - 再起動戦略オプション。取り得る値は、\n"
"    `:one_for_one`、 `:rest_for_one`、 `:one_for_all`、あるいは\n"
"    `:simple_one_for_one`です。`Supervisor`モジュールドキュメントで\n"
"     戦略についてより多く学ぶことができます。\n"
"\n"
"  * `:max_restarts` - 1フレームの間の再起動の回数の最大値です。\n"
"     デフォルトは3です。\n"
"\n"
"  * `:max_seconds` - `:max_restarts`を適用する1フレームの秒数です。\n"
"     デフォルトは5です。\n"
"\n"
"`:strategy`オプションは必要とされます。そして、デフォルトでは5秒\n"
"間に3回のリスタートが許されます。有効な戦略の完全な説明は、\n"
"`Supervisor`モジュールをチェックしてください。\n"

#. TRANSLATORS: def OptionParser.to_argv(enum)
#: lib/option_parser.ex:251
msgid ""
"Receives a key-value enumerable and convert it to argv.\n"
"\n"
"Keys must be atoms. Keys with nil value are discarded,\n"
"boolean values are converted to `--key` or `--no-key`\n"
"and all other values are converted using `to_string/1`.\n"
"\n"
"## Examples\n"
"\n"
"    iex>  OptionParser.to_argv([foo_bar: \"baz\"])\n"
"    [\"--foo-bar\", \"baz\"]\n"
"\n"
"    iex>  OptionParser.to_argv([bool: true, bool: false, discarded: nil])\n"
"    [\"--bool\", \"--no-bool\"]\n"
"\n"
msgstr ""
"キーバリュー enumerableを受け取り、argvに変換します。\n"
"\n"
"キーはアトムでなくてはなりません。値がnilとなるキーは\n"
"捨てられ、値が真偽値となるキーは`--key`あるいは`--no-key`に\n"
"変換され、他の全ての値は`to_string/1`を用いて変換されます。\n"
"\n"
"## 例\n"
"\n"
"    iex>  OptionParser.to_argv([foo_bar: \"baz\"])\n"
"    [\"--foo-bar\", \"baz\"]\n"
"\n"
"    iex>  OptionParser.to_argv([bool: true, bool: false, discarded: nil])\n"
"    [\"--bool\", \"--no-bool\"]\n"
"\n"

#. TRANSLATORS: def Task.find(tasks, msg)
#: lib/task.ex:227
msgid ""
"Receives a group of tasks and a message and finds\n"
"a task that matches the given message.\n"
"\n"
"This function returns a tuple with the task and the\n"
"returned value in case the message matches a task that\n"
"exited with success, it raises in case the found task\n"
"failed or `nil` if no task was found.\n"
"\n"
"This function is useful in situations where multiple\n"
"tasks are spawned and their results are collected\n"
"later on. For example, a `GenServer` can spawn tasks,\n"
"store the tasks in a list and later use `Task.find/2`\n"
"to see if incoming messages are from any of the tasks.\n"
msgstr ""
"タスクとメッセージのグループを受け取り、\n"
"与えられたメッセージにマッチするタスクを見付けます。\n"
"\n"
"この関数は、タスク付のタプルを返し、返された値は成功して終了したタスク\n"
"にマッチするメッセージです。タスクが見付けられない時、タスクが失敗ある\n"
"いは`nil`を返した時はエラーを上げます。\n"
"\n"
"この関数は、複数のタスクが生成され、それらの結果をあとで集めるというシ\n"
"チュエーションで、便利です。例えば、`GenServer`はタスクを生成することが\n"
"でき、タスクをリストに格納して、後で他のタスクからのメッセージが来とき\n"
"に、`Task.find/2`を使い、タスクを参照することが出来ます。\n"

#. TRANSLATORS: def IO.gets(device \\ :erlang.group_leader(), prompt)
#: lib/io.ex:258
msgid ""
"Reads a line from the IO device. It returns:\n"
"\n"
"  * `data` - the characters in the line terminated\n"
"    by a LF (or end of file)\n"
"\n"
"  * `:eof` - end of file was encountered\n"
"\n"
"  * `{:error, reason}` - other (rare) error condition;\n"
"    for instance, `{:error, :estale}` if reading from an\n"
"    NFS volume\n"
msgstr ""
"IOデバイスから行を読みます。以下を返します:\n"
"\n"
"  * `data` - LF(あるいはend of file)で終了された行の文字列\n"
"\n"
"  * `:eof` - end of fileに到達したことを示します\n"
"\n"
"  * `{:error, reason}` - 他の(レアな)エラー状態;\n"
"    例えば、`{:error, :estale}`はNFSボリュームから読み込んだ時に\n"
"    起きるかもしれません。\n"

#. TRANSLATORS: def IO.binread(device \\ :erlang.group_leader(), chars_or_line)
#: lib/io.ex:106
msgid ""
"Reads `count` characters from the IO device, a whole\n"
"`:line` or the whole device with `:all`.\n"
"\n"
"It returns:\n"
"\n"
"  * `data` - the input characters\n"
"\n"
"  * `:eof` - end of file was encountered\n"
"\n"
"  * `{:error, reason}` - other (rare) error condition;\n"
"    for instance, `{:error, :estale}` if reading from an\n"
"    NFS volume\n"
"\n"
"If `:all` is given, `:eof` is never returned, but an\n"
"empty string in case the device has reached EOF.\n"
"\n"
"Note: do not use this function on IO devices in unicode mode\n"
"as it will return the wrong result.\n"
msgstr ""
"`count`文字をIOデバイスから読みます。`:line`なら行全体、\n"
"`:all`なら全てを読みます。\n"
"\n"
"以下を返します:\n"
"\n"
"  * `data` - 入力文字列\n"
"\n"
"  * `:eof` - end of fileに到達したことを示します\n"
"\n"
"  * `{:error, reason}` - 他の(レアな)エラー状態;\n"
"    例えば、`{:error, :estale}`はNFSボリュームから読み込んだ時に\n"
"    起きるかもしれません。\n"
"\n"
"もし`:all`が与えられたら、`:eof`は決して返しません。しかし\n"
"デバイスがEOFになったら空文字列を返します。\n"
"\n"
"注: unicodeモードのIOデバイスにこの関数を使ってはいけません。\n"
"悪い結果を返すでしょう。\n"

#. TRANSLATORS: def IO.read(device \\ :erlang.group_leader(), chars_or_line)
#: lib/io.ex:63
msgid ""
"Reads `count` characters from the IO device, a whole\n"
"`:line` or the whole device with `:all`.\n"
"\n"
"It returns:\n"
"\n"
"  * `data` - the input characters\n"
"\n"
"  * `:eof` - end of file was encountered\n"
"\n"
"  * `{:error, reason}` - other (rare) error condition;\n"
"    for instance, `{:error, :estale}` if reading from an\n"
"    NFS volume\n"
"\n"
"If `:all` is given, `:eof` is never returned, but an\n"
"empty string in case the device has reached EOF.\n"
msgstr ""
"`count`文字をIOデバイスから読みます。`:line`なら行全体、\n"
"`:all`なら全てを読みます。\n"
"\n"
"以下を返します:\n"
"\n"
"  * `data` - 入力文字列\n"
"\n"
"  * `:eof` - end of fileに到達したことを示します\n"
"\n"
"  * `{:error, reason}` - 他の(レアな)エラー状態;\n"
"    例えば、`{:error, :estale}`はNFSボリュームから読み込んだ時に\n"
"    起きるかもしれません。\n"
"\n"
"もし`:all`が与えられたら、`:eof`は決して返しません。しかし\n"
"デバイスがEOFになったら空文字列を返します。\n"

#. TRANSLATORS: defmacro Kernel.@(expr)
#: lib/kernel.ex:1992
msgid ""
"Read and write attributes of the current module.\n"
"\n"
"The canonical example for attributes is annotating that a module\n"
"implements the OTP behaviour called `gen_server`:\n"
"\n"
"    defmodule MyServer do\n"
"      @behaviour :gen_server\n"
"      # ... callbacks ...\n"
"    end\n"
"\n"
"By default Elixir supports all Erlang module attributes, but any developer\n"
"can also add custom attributes:\n"
"\n"
"    defmodule MyServer do\n"
"      @my_data 13\n"
"      IO.inspect @my_data #=> 13\n"
"    end\n"
"\n"
"Unlike Erlang, such attributes are not stored in the module by\n"
"default since it is common in Elixir to use such attributes to store\n"
"temporary data. A developer can configure an attribute to behave closer\n"
"to Erlang by calling `Module.register_attribute/3`.\n"
"\n"
"Finally, notice that attributes can also be read inside functions:\n"
"\n"
"    defmodule MyServer do\n"
"      @my_data 11\n"
"      def first_data, do: @my_data\n"
"      @my_data 13\n"
"      def second_data, do: @my_data\n"
"    end\n"
"\n"
"    MyServer.first_data #=> 11\n"
"    MyServer.second_data #=> 13\n"
"\n"
"It is important to note that reading an attribute takes a snapshot of\n"
"its current value. In other words, the value is read at compilation\n"
"time and not at runtime. Check the module `Module` for other functions\n"
"to manipulate module attributes.\n"
msgstr ""
"現在のモジュールのアトリビュートを読み書きします。\n"
"\n"
"アトリビュートの規範的な例は、モジュールが`gen_server`と呼ばれている\n"
"OTPビヘイビアを実装するという注釈を付けていることです:\n"
"\n"
"    defmodule MyServer do\n"
"      @behaviour :gen_server\n"
"      # ... callbacks ...\n"
"    end\n"
"\n"
"デフォルトでElixirは全てのErlangモジュールアトリビュートをサポートし、\n"
"開発者は、任意のカスタムアトリビュートを追加することもできます:\n"
"\n"
"    defmodule MyServer do\n"
"      @my_data 13\n"
"      IO.inspect @my_data #=> 13\n"
"    end\n"
"\n"
"Erlangとは異なり、一時的なデータを格納するためにそのようなアトリビュー\n"
"トを使うことはElixirでは一般的になった時から、デフォルトではそのような\n"
"アトリビュートはモジュールにには保存されません。開発者は\n"
"`Module.register_attribute/3`を呼ぶことによって、Erlangにより近く振る舞\n"
"うように、アトリビュートを構成することができます。\n"
"\n"
"最後にアトリビュートは関数の内側で読むこともできることに注意してください:\n"
"\n"
"    defmodule MyServer do\n"
"      @my_data 11\n"
"      def first_data, do: @my_data\n"
"      @my_data 13\n"
"      def second_data, do: @my_data\n"
"    end\n"
"\n"
"    MyServer.first_data #=> 11\n"
"    MyServer.second_data #=> 13\n"
"\n"
"アトリビュートを読むことは、現在の値のスナップショットを取ることである\n"
"点に注意することは、重要です。言い替えると、値はコンパイル時に読み、実\n"
"行時ではありません。モジュールアトリビュートを操作する他の関数について\n"
"は、`Module`モジュールをチェックしてください。\n"

#. TRANSLATORS: def Code.readd_paths()
#: lib/code.ex:64
msgid ""
"Re-add paths given to the command line to keep their position\n"
"on the overall code path.\n"
"\n"
"Some tools may change the code path by prepending new items but\n"
"still want the paths given by the user to have higher priority.\n"
"Calling this function guarantees the paths are re-added on\n"
"top of the user given ones.\n"
msgstr ""
"全体的なコードパスのコマンドラインの位置を保つために、\n"
"与えられたパスを再追加します。\n"
"\n"
"幾つかのツールは、新しいアイテムを前に加えることによって、コードパスを\n"
"変更するかもしれませんが、まだ、より高いプライオリティを持つことをユー\n"
"ザが望むかもしれません。この関数を呼ぶことは、ユーザが与えたパスがトッ\n"
"プに再追加されることを保証します。\n"

#. TRANSLATORS: defmacro Kernel.raise(msg)
#: lib/kernel.ex:1234
msgid ""
"Raises an exception.\n"
"\n"
"If the argument is a binary, it raises `RuntimeError`\n"
"using the given argument as message.\n"
"\n"
"If an atom, it will become a call to `raise(atom, [])`.\n"
"\n"
"If anything else, it will just raise the given exception.\n"
"\n"
"## Examples\n"
"\n"
"    raise \"Given values do not match\"\n"
"\n"
"    try do\n"
"      1 + :foo\n"
"    rescue\n"
"      x in [ArithmeticError] ->\n"
"        IO.puts \"that was expected\"\n"
"        raise x\n"
"    end\n"
"\n"
msgstr ""
"例外を上げます。\n"
"\n"
"もし引数がバイナリなら、メッセージとして与えられた\n"
"引数を使い、`RuntimeError`を上げます。\n"
"\n"
"もしアトムなら、`raise(atom, [])`を呼ぶことになります。\n"
"\n"
"もしそれ以外なら、与えられた例外を上げます。\n"
"\n"
"## 例\n"
"\n"
"    raise \"Given values do not match\"\n"
"\n"
"    try do\n"
"      1 + :foo\n"
"    rescue\n"
"      x in [ArithmeticError] ->\n"
"        IO.puts \"that was expected\"\n"
"        raise x\n"
"    end\n"
"\n"

#. TRANSLATORS: defmacro Kernel.raise(exception, attrs)
#: lib/kernel.ex:1285
msgid ""
"Raises an exception.\n"
"\n"
"Calls `.exception` on the given argument passing\n"
"the attributes in order to retrieve the appropriate exception\n"
"structure.\n"
"\n"
"Any module defined via `defexception/1` automatically\n"
"implements `exception(attrs)` callback expected by `raise/2`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> raise(ArgumentError, message: \"Sample\")\n"
"    ** (ArgumentError) Sample\n"
"\n"
msgstr ""
"例外を上げます。\n"
"\n"
"適切な例外構造を取得するために、アトリビュートを渡し、\n"
"与えられた引数の`.exception`を呼び出します。\n"
"\n"
"`defexception/1`により定義された任意のモジュールは、自動的に、\n"
"`raise/2`により期待された`exception(attrs)`コールバックを実装します。\n"
"\n"
"## 例\n"
"\n"
"    iex> raise(ArgumentError, message: \"Sample\")\n"
"    ** (ArgumentError) Sample\n"
"\n"

#. TRANSLATORS: defmacro Kernel.reraise(exception, attrs, stacktrace)
#: lib/kernel.ex:1364
msgid ""
"Raises an exception preserving a previous stacktrace.\n"
"\n"
"Works like `raise/2` but does not generate a new stacktrace.\n"
"\n"
"See `reraise/2` for more details.\n"
"\n"
"## Examples\n"
"\n"
"    try do\n"
"      raise \"Oops\"\n"
"    rescue\n"
"      exception ->\n"
"        stacktrace = System.stacktrace\n"
"        reraise WrapperError, [exception: exception], stacktrace\n"
"    end\n"
msgstr ""
"以前のスタックトレースを保ちながら、例外を上げます。\n"
"\n"
"`raise/2`と似た働きをしますが、新しいスタックトレースを生成しません。\n"
"\n"
"詳細は`reraise/2`を参照してください。\n"
"\n"
"## 例\n"
"\n"
"    try do\n"
"      raise \"Oops\"\n"
"    rescue\n"
"      exception ->\n"
"        stacktrace = System.stacktrace\n"
"        reraise WrapperError, [exception: exception], stacktrace\n"
"    end\n"

#. TRANSLATORS: defmacro Kernel.reraise(msg, stacktrace)
#: lib/kernel.ex:1315
msgid ""
"Raises an exception preserving a previous stacktrace.\n"
"\n"
"Works like `raise/1` but does not generate a new stacktrace.\n"
"\n"
"Notice that `System.stacktrace` returns the stacktrace\n"
"of the last exception. That said, it is common to assign\n"
"the stacktrace as the first expression inside a `rescue`\n"
"clause as any other exception potentially raised (and\n"
"rescued) in between the rescue clause and the raise call\n"
"may change the `System.stacktrace` value.\n"
"\n"
"## Examples\n"
"\n"
"    try do\n"
"      raise \"Oops\"\n"
"    rescue\n"
"      exception ->\n"
"        stacktrace = System.stacktrace\n"
"        if Exception.message(exception) == \"Oops\" do\n"
"          reraise exception, stacktrace\n"
"        end\n"
"    end\n"
msgstr ""
"以前のスタックトレースを保ちながら、例外を上げます。\n"
"\n"
"`raise/1`と似た働きをしますが、新しいスタックトレースを生成しません。\n"
"\n"
"`System.stacktrace`は、最後の例外のスタックトレースを返すことに、気を付\n"
"けてください。それは、レスキュー節とレイズの間で、潜在的に上げられた(そ\n"
"してレスキューされた)他の例外としての、`rescue`節の最初の式として、スタッ\n"
"クトレースを割り当てることは、一般的で、`System.stacktrace`値の変更を呼び\n"
"だすかもしれません。\n"
"\n"
"## 例\n"
"\n"
"    try do\n"
"      raise \"Oops\"\n"
"    rescue\n"
"      exception ->\n"
"        stacktrace = System.stacktrace\n"
"        if Exception.message(exception) == \"Oops\" do\n"
"          reraise exception, stacktrace\n"
"        end\n"
"    end\n"

#. TRANSLATORS: def Keyword.put(keywords, key, value)
#: lib/keyword.ex:302
msgid ""
"Puts the given `value` under `key`.\n"
"\n"
"If a previous value is already stored, all entries are\n"
"removed and the value is overridden.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.put([a: 1, b: 2], :a, 3)\n"
"    [a: 3, b: 2]\n"
"\n"
"    iex> Keyword.put([a: 1, b: 2, a: 4], :a, 3)\n"
"    [a: 3, b: 2]\n"
"\n"
msgstr ""
"与えられた`value`を`key`の下でプットします。\n"
"\n"
"もし値が既に保存されていたら、全てのエントリは\n"
"削除されて、値が上書きされます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.put([a: 1, b: 2], :a, 3)\n"
"    [a: 3, b: 2]\n"
"\n"
"    iex> Keyword.put([a: 1, b: 2, a: 4], :a, 3)\n"
"    [a: 3, b: 2]\n"
"\n"

#. TRANSLATORS: def Keyword.put_new(keywords, key, value)
#: lib/keyword.ex:320
msgid ""
"Puts the given `value` under `key` unless the entry `key`\n"
"already exists.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.put_new([a: 1], :b, 2)\n"
"    [b: 2, a: 1]\n"
"\n"
"    iex> Keyword.put_new([a: 1, b: 2], :a, 3)\n"
"    [a: 1, b: 2]\n"
"\n"
msgstr ""
"既に`key`のエントリが存在しないかぎり、与えられた`value`を`key`の下でプッ\n"
"トします。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.put_new([a: 1], :b, 2)\n"
"    [b: 2, a: 1]\n"
"\n"
"    iex> Keyword.put_new([a: 1, b: 2], :a, 3)\n"
"    [a: 1, b: 2]\n"
"\n"

#. TRANSLATORS: def Dict.put_new(dict, key, val)
#: lib/dict.ex:431
msgid ""
"Puts the given `value` under `key` in `dict` unless `key` already existed.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.put_new(dict, :a, 3)\n"
"    iex> Dict.get(dict, :a)\n"
"    1\n"
"\n"
msgstr ""
"既に`key`のエントリが存在しないかぎり、与えられた`value`を`key`の\n"
"下で`dictにプットします。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.put_new(dict, :a, 3)\n"
"    iex> Dict.get(dict, :a)\n"
"    1\n"
"\n"

#. TRANSLATORS: def Kernel.put_elem(tuple, index, value)
#: lib/kernel.ex:1100
msgid ""
"Puts the element in `tuple` at the zero-based `index` to the given `value`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Example\n"
"\n"
"    iex> tuple = {:foo, :bar, 3}\n"
"    iex> put_elem(tuple, 0, :baz)\n"
"    {:baz, :bar, 3}\n"
"\n"
msgstr ""
"`tuple`に要素をゼロ始まりの`index`の位置に与えられた`value`で\n"
"プットします。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> tuple = {:foo, :bar, 3}\n"
"    iex> put_elem(tuple, 0, :baz)\n"
"    {:baz, :bar, 3}\n"
"\n"

#. TRANSLATORS: def Application.put_env(app, key, value, opts \\ [])
#: lib/application.ex:168
msgid ""
"Puts the `value` in `key` for the given `app`.\n"
"\n"
"## Options\n"
"\n"
"  * `:timeout`    - the timeout for the change (defaults to 5000ms)\n"
"  * `:persistent` - persists the given value on application load and "
"reloads\n"
"\n"
"If `put_env/4` is called before the application is loaded, the application\n"
"environment values specified in the `.app` file will override the ones\n"
"previously set.\n"
"\n"
"The persistent option can be set to true when there is a need to guarantee\n"
"parameters set with this function will not be overridden by the ones "
"defined\n"
"in the application resource file on load. This means persistent values will\n"
"stick after the application is loaded and also on application reload.\n"
msgstr ""
"与えられた`value`を`key`に与えられた`app`の為にプットします。\n"
"\n"
"## オプション\n"
"\n"
"  * `:timeout`    - 変更の為のタイムアウト (デフォルト 5000ms)\n"
"  * `:persistent` - アプリケーションをロードやリロードでしても値を永続化しま"
"す\n"
"\n"
"もしアプリケーションがロードされる前に`put_env/4`が呼ばれると、\n"
"`.app`ファイルで指定されたアプリケーション環境変数は、以前の値を\n"
"上書きされます。\n"
"\n"
"ロードしているアプリケーションリソースファイルで定義された値により、こ\n"
"の関数によりセットされたパラメタが、オーバライドされないように保証する\n"
"必要があるときに、persistent オプションをtrueにセットできます。これは、\n"
"永続化された値はアプリケーションがロードされ、アプリケーションがリロー\n"
"ドされた後も定着することを意味します。\n"

#. TRANSLATORS: def Module.put_attribute(module, key, value)
#: lib/module.ex:729
msgid ""
"Puts an Erlang attribute to the given module with the given\n"
"key and value. The semantics of putting the attribute depends\n"
"if the attribute was registered or not via `register_attribute/3`.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule MyModule do\n"
"      Module.put_attribute __MODULE__, :custom_threshold_for_lib, 10\n"
"    end\n"
"\n"
msgstr ""
"Erlangアトリビュートを与えられたモジュールに与えられたキーと値でプット\n"
"します。アトリビュートをプットするセマンティクスは、\n"
"`register_attribute/3`によってアトリビュートが登録されていたか否かに、\n"
"依存します。\n"
"\n"
"## 例\n"
"\n"
"    defmodule MyModule do\n"
"      Module.put_attribute __MODULE__, :custom_threshold_for_lib, 10\n"
"    end\n"
"\n"

#. TRANSLATORS: def Kernel.put_in(data, keys, value)
#: lib/kernel.ex:1585
msgid ""
"Puts a value in a nested structure.\n"
"\n"
"Uses the `Access` protocol to traverse the structures\n"
"according to the given `keys`, unless the `key` is a\n"
"function. If the key is a function, it will be invoked\n"
"as specified in `get_and_update_in/3`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> put_in(users, [\"john\", :age], 28)\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"In case any of entries in the middle returns `nil`,\n"
"an error will be raised when trying to access it next.\n"
msgstr ""
"値をネストした構造にプットします。\n"
"\n"
"`keys`が関数でない限り、与えられた`keys`によって\n"
"構造を横断するために、`Access`プロトコルを使います。\n"
"もしキーが関数なら、`get_and_update_in/3`の仕様により\n"
"実行されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> put_in(users, [\"john\", :age], 28)\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"中間のエントリのいずれかが`nil`を返す場合、次にそれに\n"
"アクセスしようとするとき、エラーが上ります。\n"

#. TRANSLATORS: defmacro Kernel.put_in(path, value)
#: lib/kernel.ex:1696
msgid ""
"Puts a value in a nested structure via the given `path`.\n"
"\n"
"This is similar to `put_in/3`, except the path is extracted via\n"
"a macro rather than passing a list. For example:\n"
"\n"
"    put_in(opts[:foo][:bar], :baz)\n"
"\n"
"Is equivalent to:\n"
"\n"
"    put_in(opts, [:foo, :bar], :baz)\n"
"\n"
"Note that in order for this macro to work, the complete path must always\n"
"be visible by this macro. For more information about the supported path\n"
"expressions, please check `get_and_update_in/2` docs.\n"
"\n"
"## Examples\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> put_in(users[\"john\"][:age], 28)\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> put_in(users[\"john\"].age, 28)\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
msgstr ""
"値をネストした構造に`path`によりプットします。\n"
"\n"
"pathが、リストを渡しているよりはむしろ、マクロによって抽出される\n"
"こと以外は、`put_in/3`に似ています。例えば:\n"
"\n"
"`keys`が関数でない限り、与えられた`keys`によって\n"
"構造を横断するために、`Access`プロトコルを使います。\n"
"もしキーが関数なら、`get_and_update_in/3`の仕様により\n"
"実行されます。\n"
"\n"
"\n"
"中間のエントリのいずれかが`nil`を返す場合、次にそれに\n"
"アクセスしようとするとき、エラーが上ります。\n"
"\n"
"\n"
"    put_in(opts[:foo][:bar], :baz)\n"
"\n"
"は以下と等価です:\n"
"\n"
"    put_in(opts, [:foo, :bar], :baz)\n"
"\n"
"このマクロが機能するために、完全なパスは、常にこのマクロによって可視で\n"
"なければならないことに注意してください。サポートされたパス表現について\n"
"の詳細は、`get_and_update_in/2`ドキュメントをチェックしてください。\n"
"\n"
"## 例\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> put_in(users[\"john\"][:age], 28)\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> put_in(users[\"john\"].age, 28)\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"

#. TRANSLATORS: def Module.__info__(kind)
#: lib/module.ex:308
msgid ""
"Provides runtime information about functions and macros defined by the\n"
"module, enables docstring extraction, etc.\n"
"\n"
"Each module gets an `__info__/1` function when it's compiled. The function\n"
"takes one of the following atoms:\n"
"\n"
"  * `:functions`  - keyword list of public functions along with their "
"arities\n"
"\n"
"  * `:macros`     - keyword list of public macros along with their arities\n"
"\n"
"  * `:module`     - module name (`Module == Module.__info__(:module)`)\n"
"\n"
"In addition to the above, you may also pass to `__info__/1` any atom "
"supported\n"
"by Erlang's `module_info` function which also gets defined for each "
"compiled\n"
"module. See http://erlang.org/doc/reference_manual/modules.html#id69430 for\n"
"more information.\n"
msgstr ""
"モジュールで定義された、関数とマクロについての実行時情報を提供して、\n"
"docstringの抽出などを可能にします。\n"
"\n"
"それぞれのモジュールはコンパイル時に`__info__/1`関数を取得します。\n"
"関数は以下のアトムを引数として取ります:\n"
"\n"
"  * `:functions`  -  公開関数とそのアリティのキーワードリスト\n"
"\n"
"  * `:macros`     -  公開マクロとそのアリティのキーワードリスト\n"
"\n"
"  * `:module`     -  モジュール名 (`Module == Module.__info__(:module)`)\n"
"\n"
"上記に加えて、`__info__/1`に、コンパイルされたモジュール毎に定義される\n"
"Erlangの `module_info`関数でサポートされた、任意のアトムをパスすること\n"
"も出来ます。詳細は、\n"
"http://erlang.org/doc/reference_manual/modules.html#id69430 を参照して\n"
"ください。\n"

#. TRANSLATORS: defmacro Kernel.if(condition, clauses)
#: lib/kernel.ex:2151
msgid ""
"Provides an `if` macro. This macro expects the first argument to\n"
"be a condition and the rest are keyword arguments.\n"
"\n"
"## One-liner examples\n"
"\n"
"    if(foo, do: bar)\n"
"\n"
"In the example above, `bar` will be returned if `foo` evaluates to\n"
"`true` (i.e. it is neither `false` nor `nil`). Otherwise, `nil` will be "
"returned.\n"
"\n"
"An `else` option can be given to specify the opposite:\n"
"\n"
"    if(foo, do: bar, else: baz)\n"
"\n"
"## Blocks examples\n"
"\n"
"Elixir also allows you to pass a block to the `if` macro. The first\n"
"example above would be translated to:\n"
"\n"
"    if foo do\n"
"      bar\n"
"    end\n"
"\n"
"Notice that `do/end` becomes delimiters. The second example would\n"
"then translate to:\n"
"\n"
"    if foo do\n"
"      bar\n"
"    else\n"
"      baz\n"
"    end\n"
"\n"
"If you want to compare more than two clauses, you can use the `cond/1`\n"
"macro.\n"
msgstr ""
"`if`マクロを提供します。このマクロは最初の引数をコンディションとして、\n"
"残りをキーワード引数として期待します。\n"
"\n"
"## ワンライナーの例\n"
"\n"
"    if(foo, do: bar)\n"
"\n"
"上の例では、`foo`が`true`(即ち、`false`でもなく、`nil`でもないなら)に評\n"
"価されたら、`bar`が返されます。さもなくば、`nil`が返ります。\n"
"\n"
"`else`オプションは正反対を指定させることができます:\n"
"\n"
"    if(foo, do: bar, else: baz)\n"
"\n"
"## ブロックの例\n"
"\n"
"Elixirは`if`マクロにブロックを渡すことも許しています。上の最初の\n"
"例は、以下のように翻訳されます:\n"
"\n"
"    if foo do\n"
"      bar\n"
"    end\n"
"\n"
"`do/end`がブロックのデリミタであることに注意してください。二番目の例は\n"
"次のように翻訳されます:\n"
"\n"
"    if foo do\n"
"      bar\n"
"    else\n"
"      baz\n"
"    end\n"
"\n"
"もし二つ以上の節を比較したいなら、`cond/1`マクロを使うことができます。\n"

#. TRANSLATORS: defmacro Kernel.||(left, right)
#: lib/kernel.ex:2313
msgid ""
"Provides a short-circuit operator that evaluates and returns the second\n"
"expression only if the first one does not evaluate to true (i.e. it\n"
"is either nil or false). Returns the first expression otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.empty?([1]) || Enum.empty?([1])\n"
"    false\n"
"\n"
"    iex> List.first([]) || true\n"
"    true\n"
"\n"
"    iex> Enum.empty?([1]) || 1\n"
"    1\n"
"\n"
"    iex> Enum.empty?([]) || throw(:bad)\n"
"    true\n"
"\n"
"Notice that, unlike Erlang's `or` operator,\n"
"this operator accepts any expression as an argument,\n"
"not only booleans, however it is not allowed in guards.\n"
msgstr ""
"最初の式が`true`(即ち、nilでもfalseでもない)に評価されなかったとき\n"
"だけ二番目の式を評価し、返す、ショートサーキット演算子を提供します。\n"
"さもなければ最初の式を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.empty?([1]) || Enum.empty?([1])\n"
"    false\n"
"\n"
"    iex> List.first([]) || true\n"
"    true\n"
"\n"
"    iex> Enum.empty?([1]) || 1\n"
"    1\n"
"\n"
"    iex> Enum.empty?([]) || throw(:bad)\n"
"    true\n"
"\n"
"Erlangの`or`演算子と違って、この演算子は、ガードの中では許されませんが、\n"
"引数としてブーリアンだけでなく任意の式を受け付けることに、注意してくだ\n"
"さい。\n"

#. TRANSLATORS: defmacro Kernel.&&(left, right)
#: lib/kernel.ex:2279
msgid ""
"Provides a short-circuit operator that evaluates and returns\n"
"the second expression only if the first one evaluates to true\n"
"(i.e. it is not nil nor false). Returns the first expression\n"
"otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.empty?([]) && Enum.empty?([])\n"
"    true\n"
"\n"
"    iex> List.first([]) && true\n"
"    nil\n"
"\n"
"    iex> Enum.empty?([]) && List.first([1])\n"
"    1\n"
"\n"
"    iex> false && throw(:bad)\n"
"    false\n"
"\n"
"Notice that, unlike Erlang's `and` operator,\n"
"this operator accepts any expression as an argument,\n"
"not only booleans, however it is not allowed in guards.\n"
msgstr ""
"最初の式が`true`(即ち、nilでもfalseでもない)に評価されたとき\n"
"だけ二番目の式を評価し、返す、ショートサーキット演算子を提供します。\n"
"さもなければ最初の式を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.empty?([]) && Enum.empty?([])\n"
"    true\n"
"\n"
"    iex> List.first([]) && true\n"
"    nil\n"
"\n"
"    iex> Enum.empty?([]) && List.first([1])\n"
"    1\n"
"\n"
"    iex> false && throw(:bad)\n"
"    false\n"
"\n"
"Erlangの`and`演算子と違って、この演算子は、ガードの中では許されませんが、\n"
"引数としてブーリアンだけでなく任意の式を受け付けることに、注意してくだ\n"
"さい。\n"

#. TRANSLATORS: Elixir.Enum Summary
#: lib/enum.ex:143
msgid ""
"Provides a set of algorithms that enumerate over collections according to "
"the\n"
"`Enumerable` protocol:\n"
"\n"
"    iex> Enum.map([1, 2, 3], fn(x) -> x * 2 end)\n"
"    [2,4,6]\n"
"\n"
"Some particular types, like dictionaries, yield a specific format on\n"
"enumeration. For dicts, the argument is always a `{key, value}` tuple:\n"
"\n"
"    iex> dict = %{a: 1, b: 2}\n"
"    iex> Enum.map(dict, fn {k, v} -> {k, v * 2} end)\n"
"    [a: 2, b: 4]\n"
"\n"
"Note that the functions in the `Enum` module are eager: they always start\n"
"the enumeration of the given collection. The `Stream` module allows\n"
"lazy enumeration of collections and provides infinite streams.\n"
"\n"
"Since the majority of the functions in `Enum` enumerate the whole\n"
"collection and return a list as result, infinite streams need to\n"
"be carefully used with such functions, as they can potentially run\n"
"forever. For example:\n"
"\n"
"    Enum.each Stream.cycle([1,2,3]), &IO.puts(&1)\n"
"\n"
msgstr ""
"`Enumerable`プロトコルに従った、コレクションを列挙するアルゴリズムのセッ\n"
"トを提供します:\n"
"\n"
"    iex> Enum.map([1, 2, 3], fn(x) -> x * 2 end)\n"
"    [2,4,6]\n"
"\n"
"辞書のような、若干の特定のタイプは列挙に特定のフォーマットを与えます。\n"
"dictでは、引数は常に`{key, value}`タプルです:\n"
"\n"
"    iex> dict = %{a: 1, b: 2}\n"
"    iex> Enum.map(dict, fn {k, v} -> {k, v * 2} end)\n"
"    [a: 2, b: 4]\n"
"\n"
"\n"
"`Enum`モジュールはeagerであることに注意してください。\n"
"それらは与えられたコレクションの列挙を常に始めます。\n"
"`Stream`モジュールはコレクションの遅延列挙と無限のストリームを提供します。\n"
"\n"
"`Enum`の大部分の関数が、全部のコレクションを列挙して、\n"
"結果としてリストを返すため、無限のストリームは\n"
"それらの関数で潜在的に永遠に動きつづける可能性があり、\n"
"慎重に使われる必要があります。例えば:\n"
"\n"
"    Enum.each Stream.cycle([1,2,3]), &IO.puts(&1)\n"
"\n"

#. TRANSLATORS: def List.delete_at(list, index)
#: lib/list.ex:432
msgid ""
"Produces a new list by removing the value at the specified `index`.\n"
"Negative indices indicate an offset from the end of the list.\n"
"If `index` is out of bounds, the original `list` is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.delete_at([1, 2, 3], 0)\n"
"    [2, 3]\n"
"\n"
"    iex List.delete_at([1, 2, 3], 10)\n"
"    [1, 2, 3]\n"
"\n"
"    iex> List.delete_at([1, 2, 3], -1)\n"
"    [1, 2]\n"
"\n"
msgstr ""
"指定された`index`の値を削除した、新しいリストを提供します。\n"
"負のインデックスはリストの終わりからのオフセットを示します。\n"
"もし`index`が範囲外なら、オリジナルの`list`が返されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.delete_at([1, 2, 3], 0)\n"
"    [2, 3]\n"
"\n"
"    iex List.delete_at([1, 2, 3], 10)\n"
"    [1, 2, 3]\n"
"\n"
"    iex> List.delete_at([1, 2, 3], -1)\n"
"    [1, 2]\n"
"\n"

#. TRANSLATORS: def Code.prepend_path(path)
#: lib/code.ex:41
msgid ""
"Prepends a path to the Erlang VM code path.\n"
"\n"
"The path is expanded with `Path.expand/1` before being prepended.\n"
msgstr ""
"Erlang VMのコードパスにpathを前に付加します。\n"
"\n"
"pathは付加される前に、`Path.expand/1`で展開されます。\n"

#. TRANSLATORS: def Exception.format(kind, payload, stacktrace \\ nil)
#: lib/exception.ex:133
msgid ""
"Normalizes and formats throw/errors/exits and stacktrace.\n"
"\n"
"It relies on `format_banner/3` and `format_stacktrace/1`\n"
"to generate the final format.\n"
"\n"
"Note that `{:EXIT, pid}` do not generate a stacktrace though\n"
"(as they are retrieved as messages without stacktraces).\n"
msgstr ""
"throw/errors/exitsとスタックトレースを正規化してフォーマットします。\n"
"\n"
"それは`format_banner/3`と`format_stacktrace/1`が最終的な\n"
"フォーマットを生成することをあてにします。\n"
"\n"
"しかし、`{:EXIT, pid}`はスタックトレースを生成しない(それらはスタックト\n"
"レースのないメッセージとして取り出されます)ことに、注意してください。\n"

#. TRANSLATORS: def Exception.format_banner(kind, exception, stacktrace \\ nil)
#: lib/exception.ex:102
msgid ""
"Normalizes and formats any throw, error and exit.\n"
"\n"
"The message is formatted and displayed in the same\n"
"format as used by Elixir's CLI.\n"
"\n"
"The third argument, a stacktrace, is optional. If it is\n"
"not supplied `System.stacktrace/0` will sometimes be used\n"
"to get additional information for the `kind` `:error`. If\n"
"the stacktrace is unknown and `System.stacktrace/0` would\n"
"not return the stacktrace corresponding to the exception\n"
"an empty stacktrace, `[]`, must be used.\n"
msgstr ""
"任意のthrow、errors、exitを正規化してフォーマットします。\n"
"\n"
"メッセージはフォーマットされ、ElixirのCLIによって使われる\n"
"フォーマットと同じように、表示されます。\n"
"\n"
"第3引数のstacktraceはオプションです。もしそれがなければ、\n"
"`System.stacktrace/0`は、`kind` `:error`の追加の情報を得るために時々使\n"
"われます。もし、stacktraceが知られていなくて、`System.stacktrace/0`が例\n"
"外と一致したスタックトレースを返さないならば、空のスタックトレース\n"
"`[]`が使われなければならない。\n"

#. TRANSLATORS: def Exception.normalize(kind, payload, stacktrace \\ nil)
#: lib/exception.ex:74
msgid ""
"Normalizes an exception, converting Erlang exceptions\n"
"to Elixir exceptions.\n"
"\n"
"It takes the `kind` spilled by `catch` as an argument and\n"
"normalizes only `:error`, returning the untouched payload\n"
"for others.\n"
"\n"
"The third argument, a stacktrace, is optional. If it is\n"
"not supplied `System.stacktrace/0` will sometimes be used\n"
"to get additional information for the `kind` `:error`. If\n"
"the stacktrace is unknown and `System.stacktrace/0` would\n"
"not return the stacktrace corresponding to the exception\n"
"an empty stacktrace, `[]`, must be used.\n"
msgstr ""
"例外をErlangの例外をElixirの例外へ変換して、正規化ます。\n"
"\n"
"\n"
"`catch`により流出した`kind`をとり、`:error`だけを\n"
"正規化します。他のペイロードには手をつけずに返します。\n"
"第3引数のstacktraceはオプションです。もしそれがなければ、\n"
"`System.stacktrace/0`は、`kind` `:error`の追加の情報を得るために時々使\n"
"われます。もし、stacktraceが知られていなくて、`System.stacktrace/0`が例\n"
"外と一致したスタックトレースを返さないならば、空のスタックトレース\n"
"`[]`が使われなければならない。\n"

#. TRANSLATORS: def GenEvent.call(manager, handler, request, timeout \\ 5000)
#: lib/gen_event.ex:441
msgid ""
"Makes a synchronous call to the event `handler` installed in `manager`.\n"
"\n"
"The given `request` is sent and the caller waits until a reply arrives or\n"
"a timeout occurs. The event manager will call `handle_call/2` to handle\n"
"the request.\n"
"\n"
"The return value `reply` is defined in the return value of `handle_call/2`.\n"
"If the specified event handler is not installed, the function returns\n"
"`{:error, :not_found}`.\n"
msgstr ""
"`manager`にインストールされた、イベント`handler`を同期的に呼び出します。\n"
"\n"
"与えられた`request`は送信され、呼び出し側は応答が到着するか、タイムアウ\n"
"トが起きるまで待ちます。イベントマネージャは、リクエストをハンドルする\n"
"ために、`handle_call/2`を呼び出します。\n"
"\n"
"戻り値`reply`は`handle_call/2`で定義された戻り値です。もし指定されたイ\n"
"ベントハンドラがインストールされていないなら、関数は`{:error,\n"
":not_found}`を返します。\n"

#. TRANSLATORS: def GenServer.call(server, request, timeout \\ 5000)
#: lib/gen_server.ex:351
msgid ""
"Makes a synchronous call to the `server` and waits for its reply.\n"
"\n"
"The client sends the given `request` to the server and waits until a reply\n"
"arrives or a timeout occurs. `handle_call/3` will be called on the server\n"
"to handle the request.\n"
"\n"
"The server can be any of the values described in the `Name Registration`\n"
"section of the module documentation.\n"
"\n"
"## Timeouts\n"
"\n"
"The `timeout` is an integer greater than zero which specifies how many\n"
"milliseconds to wait for a reply, or the atom `:infinity` to wait\n"
"indefinitely. The default value is 5000. If no reply is received within\n"
"the specified time, the function call fails. If the caller catches the\n"
"failure and continues running, and the server is just late with the reply,\n"
"it may arrive at any time later into the caller's message queue. The caller\n"
"must in this case be prepared for this and discard any such garbage "
"messages\n"
"that are two element tuples with a reference as the first element.\n"
msgstr ""
"`server`を同期的に呼び出し、その応答を待ちます。\n"
"\n"
"クライアントは与えられた`request`をサーバに送信し、\n"
"応答が到着するか、タイムアウトが起きるまで待ちます。\n"
"`handle_call/3`がリクエストをハンドルするためにサーバで呼ばれます。\n"
"\n"
"引数のserverはモジュールドキュメントの`名前登録`セクションで記述された\n"
"任意の値をとることができます。\n"
"\n"
"## タイウアウト\n"
"\n"
"`timeout`は、応答を待つ長さを示すミリ秒で、0より大きな整数か、無限に待\n"
"つことを示すアトムで、`:infinity`のいずれかです。デフォルト値は5000です。\n"
"もし指定された時間内に応答が受信されないなら、関数呼び出しは失敗します。\n"
"もし呼び出し側が失敗を捕捉し、実行を継続し、そして、サーバが送れて応答\n"
"したら、呼び出し側のメッセージキューに送れて到着します。呼び出し側は、\n"
"この場合、これに備えなければならず、最初の要素としてリファレンスである\n"
"2要素のタプルのゴミメッセージを捨てなければなりません。\n"

#. TRANSLATORS: def IO.ANSI.Docs.print_heading(heading, options \\ [])
#: lib/io/ansi/docs.ex:41
msgid ""
"Prints the head of the documentation (i.e. the function signature).\n"
"\n"
"See `default_options/0` for docs on the supported options.\n"
msgstr ""
"ドキュメントのヘッド(即ち、関数のシグネチャ)をプリントします\n"
"\n"
"サポートされたオプションは`default_options/0`のドキュメントを参照してくださ"
"い。\n"

#. TRANSLATORS: def IO.ANSI.Docs.print(doc, options \\ [])
#: lib/io/ansi/docs.ex:57
msgid ""
"Prints the documentation body.\n"
"\n"
"In addition to the printing string, takes a set of options\n"
"defined in `default_options/1`.\n"
msgstr ""
"ドキュメントの本体をプリントします。\n"
"\n"
"プリントする文字列に加えて、`default_options/1`で定義された一連の\n"
"オプションも取ります。\n"

#. TRANSLATORS: def Kernel.div(left, right)
#: lib/kernel.ex:172
msgid ""
"Performs an integer division.\n"
"\n"
"Raises an error if one of the arguments is not an integer.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> div(5, 2)\n"
"    2\n"
"\n"
msgstr ""
"整数の除算を実行します。\n"
"\n"
"引数の一つが整数でないなら、エラーを上げます。\n"
"\n"
"ガードテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> div(5, 2)\n"
"    2\n"
"\n"

#. TRANSLATORS: def IO.ANSI.normal()
#: lib/io/ansi.ex:86
msgid "Normal color or intensity"
msgstr "太文字と低輝度を解除"

#. TRANSLATORS: def Inspect.Algebra.nest(x, i)
#: lib/inspect/algebra.ex:266
msgid ""
"Nests document entity `x` positions deep.\n"
"\n"
"Nesting will be appended to the line breaks.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.nest(Inspect.Algebra.glue(\"hello\", \"world"
"\"), 5)\n"
"    iex> Inspect.Algebra.format(doc, 5)\n"
"    [\"hello\", \"\\n     \", \"world\"]\n"
"\n"
msgstr ""
"ドキュメントエンティティの位置を`x`だけ深くネストする。\n"
"\n"
"ネストには改行が追加されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> doc = Inspect.Algebra.nest(Inspect.Algebra.glue(\"hello\", \"world"
"\"), 5)\n"
"    iex> Inspect.Algebra.format(doc, 5)\n"
"    [\"hello\", \"\\n     \", \"world\"]\n"
"\n"

#. TRANSLATORS: def Node.monitor(node, flag)
#: lib/node.ex:92
msgid ""
"Monitors the status of the node.\n"
"\n"
"If `flag` is `true`, monitoring is turned on.\n"
"If `flag` is `false`, monitoring is turned off.\n"
"\n"
"See http://www.erlang.org/doc/man/erlang.html#monitor_node-2 for more info.\n"
msgstr ""
"ノードのステータスをモニタします。\n"
"\n"
"もし`flag`が`true`なら、モニタをオンにします。\n"
"もし`flag`が`false`なら、モニタをオフにします。\n"
"\n"
"詳細は http://www.erlang.org/doc/man/erlang.html#monitor_node-2 \n"
"を参照してください。\n"

#. TRANSLATORS: def OptionParser.next(argv, opts \\ [])
#: lib/option_parser.ex:192
msgid ""
"Low-level function that parses one option.\n"
"\n"
"It accepts the same options as `parse/2` and `parse_head/2`\n"
"as both functions are built on top of next. This function\n"
"may return:\n"
"\n"
"  * `{:ok, key, value, rest}` - the option `key` with `value` was\n"
"    successfully parsed\n"
"\n"
"  * `{:invalid, key, value, rest}` - the option `key` is invalid with "
"`value`\n"
"    (returned when the switch type does not match the one given via the\n"
"    command line)\n"
"\n"
"  * `{:undefined, key, value, rest}` - the option `key` is undefined\n"
"    (returned on strict cases and the switch is unknown)\n"
"\n"
"  * `{:error, rest}` - there are no switches at the top of the given argv\n"
msgstr ""
"一つのオプションをパースする低レベル関数です。\n"
"\n"
"nextの上で構築される`parse/2`や`parse_head/2`といった関数と\n"
"同じオプションを受け付けます。この関数は以下を返します:\n"
"\n"
"  * `{:ok, key, value, rest}` - `value`付きのオプション`key`はパースに\n"
"    成功しました\n"
"\n"
"  * `{:invalid, key, value, rest}` - `value`付きのオプション`key`は無効です\n"
"    (スイッチタイプがコマンドラインにより渡されたものにマッチしないときに\n"
"     返ります)\n"
"\n"
"  * `{:undefined, key, value, rest}` - オプション`key`は未定義です\n"
"    (大文字小文字の違いやスイッチが不明のときに返ります)\n"
"\n"
"  * `{:error, rest}` - 与えられたargvにスイッチがありません\n"

#. TRANSLATORS: Elixir.Record Summary
#: lib/record.ex:1
msgid ""
"Module to work, define and import records.\n"
"\n"
"Records are simply tuples where the first element is an atom:\n"
"\n"
"    iex> Record.is_record {User, \"john\", 27}\n"
"    true\n"
"\n"
"This module provides conveniences for working with records at\n"
"compilation time, where compile-time field names are used to\n"
"manipulate the tuples, providing fast operations on top of\n"
"the tuples compact structure.\n"
"\n"
"In Elixir, records are used mostly in two situations:\n"
"\n"
"  1. to work with short, internal data\n"
"  2. to interface with Erlang records\n"
"\n"
"The macros `defrecord/3` and `defrecordp/3` can be used to create\n"
"records while `extract/2` can be used to extract records from Erlang\n"
"files.\n"
"\n"
"## Types\n"
"\n"
"Types can be defined for tuples with the `record/2` macro (only available\n"
"in typespecs). Like with the generated record macros it will expand to\n"
"a tuple.\n"
"\n"
"    defmodule MyModule do\n"
"      require Record\n"
"      Record.defrecord :user, name: \"john\", age: 25\n"
"\n"
"      @type user :: record(:user, name: String.t, age: integer)\n"
"      # expands to: `@type user :: {:user, String.t, integer}`\n"
"    end\n"
msgstr ""
"レコードを使用し、定義し、インポートするためのモジュールです。\n"
"\n"
"レコードは、最初の要素がアトムである、単なるタプルです:\n"
"\n"
"    iex> Record.record? {User, \"john\", 27}\n"
"    true\n"
"\n"
"このモジュールは、コンパイル時に以下の様な利便性を提供します。レコード\n"
"利用に対する、コンパイル時のフィールド名はタプルを操作するのに使われま\n"
"す。そして、タプル上のコンパクトな構造で素早い操作を提供します。\n"
"\n"
"Elixirでは、レコードは専ら二つのシチュエーションで使われます:\n"
"\n"
"  1. 小さな、内部データとしての利用\n"
"  2. Erlangレコードへのインタフェース\n"
"\n"
"Erlangファイルからレコードを抽出するのに`extract/2`を使い、レコードを作\n"
"成するために、マクロ`defrecord/3`と`defrecordp/3`を使うことができます。\n"
"\n"
"## タイプ\n"
"\n"
"タイプは`record/2`マクロでタプルに定義されます(typespecとして有効なだけで"
"す)。\n"
"レコードを生成するマクロのように、タプルに展開されます。\n"
"\n"
"    defmodule MyModule do\n"
"      require Record\n"
"      Record.defrecord :user name: \"john\", age: 25\n"
"\n"
"      @type user :: record(:user, name: String.t, age: integer)\n"
"      # expands to: `@type user :: {:user, String.t, integer}`\n"
"    end\n"

#. TRANSLATORS: Elixir.Stream Summary
#: lib/stream.ex:1
msgid ""
"Module for creating and composing streams.\n"
"\n"
"Streams are composable, lazy enumerables. Any enumerable that generates\n"
"items one by one during enumeration is called a stream. For example,\n"
"Elixir's `Range` is a stream:\n"
"\n"
"    iex> range = 1..5\n"
"    1..5\n"
"    iex> Enum.map range, &(&1 * 2)\n"
"    [2,4,6,8,10]\n"
"\n"
"In the example above, as we mapped over the range, the elements being\n"
"enumerated were created one by one, during enumeration. The `Stream`\n"
"module allows us to map the range, without triggering its enumeration:\n"
"\n"
"    iex> range = 1..3\n"
"    iex> stream = Stream.map(range, &(&1 * 2))\n"
"    iex> Enum.map(stream, &(&1 + 1))\n"
"    [3,5,7]\n"
"\n"
"Notice we started with a range and then we created a stream that is\n"
"meant to multiply each item in the range by 2. At this point, no\n"
"computation was done yet. Just when `Enum.map/2` is called we\n"
"enumerate over each item in the range, multiplying it by 2 and adding 1.\n"
"We say the functions in `Stream` are *lazy* and the functions in `Enum`\n"
"are *eager*.\n"
"\n"
"Due to their laziness, streams are useful when working with large\n"
"(or even infinite) collections. When chaining many operations with `Enum`,\n"
"intermediate lists are created, while `Stream` creates a recipe of\n"
"computations that are executed at a later moment. Let's see another\n"
"example:\n"
"\n"
"    1..3 |>\n"
"      Enum.map(&IO.inspect(&1)) |>\n"
"      Enum.map(&(&1 * 2)) |>\n"
"      Enum.map(&IO.inspect(&1))\n"
"    1\n"
"    2\n"
"    3\n"
"    2\n"
"    4\n"
"    6\n"
"    #=> [2,4,6]\n"
"\n"
"Notice that we first printed each item in the list, then multiplied each\n"
"element by 2 and finally printed each new value. In this example, the list\n"
"was enumerated three times. Let's see an example with streams:\n"
"\n"
"    stream = 1..3 |>\n"
"      Stream.map(&IO.inspect(&1)) |>\n"
"      Stream.map(&(&1 * 2)) |>\n"
"      Stream.map(&IO.inspect(&1))\n"
"    Enum.to_list(stream)\n"
"    1\n"
"    2\n"
"    2\n"
"    4\n"
"    3\n"
"    6\n"
"    #=> [2,4,6]\n"
"\n"
"Although the end result is the same, the order in which the items were\n"
"printed changed! With streams, we print the first item and then print\n"
"its double. In this example, the list was enumerated just once!\n"
"\n"
"That's what we meant when we first said that streams are composable,\n"
"lazy enumerables. Notice we could call `Stream.map/2` multiple times,\n"
"effectively composing the streams and they are lazy. The computations\n"
"are performed only when you call a function from the `Enum` module.\n"
"\n"
"## Creating Streams\n"
"\n"
"There are many functions in Elixir's standard library that return\n"
"streams, some examples are:\n"
"\n"
"  * `IO.stream/2`         - streams input lines, one by one\n"
"  * `URI.query_decoder/1` - decodes a query string, pair by pair\n"
"\n"
"This module also provides many convenience functions for creating streams,\n"
"like `Stream.cycle/1`, `Stream.unfold/2`, `Stream.resource/3` and more.\n"
"\n"
"Note the functions in this module are guaranteed to return enumerables.\n"
"Since enumerables can have different shapes (structs, anonymous functions,\n"
"and so on), the functions in this module may return any of those shapes\n"
"and that it may change at any time. For example, a function that today\n"
"returns an anonymous function may return a struct in future releases.\n"
msgstr ""
"ストリームを作り、組み立てるためのモジュールです。\n"
"\n"
"ストリームは組み立て可能な、遅延enumerableです。\n"
"数え上げの間、一つずつアイテムを生成する任意のenumerableが、\n"
"ストリームと呼ばれます。例えば、\n"
"Elixirの`Range`はストリームです:\n"
"\n"
"    iex> range = 1..5\n"
"    1..5\n"
"    iex> Enum.map range, &(&1 * 2)\n"
"    [2,4,6,8,10]\n"
"\n"
"上の例で、rangeの上にマップしたので、列挙の間、列挙されたアイテムは一つ\n"
"ずつ作成されました。`Stream`モジュールは、列挙操作を起動させることなく、\n"
"rangeをマップすることを許します:\n"
"\n"
"    iex> range = 1..3\n"
"    iex> stream = Stream.map(range, &(&1 * 2))\n"
"    iex> Enum.map(stream, &(&1 + 1))\n"
"    [3,5,7]\n"
"\n"
"rangeから開始して、rangeのそれぞれのアイテムを2倍にするストリームを作っ\n"
"たことに注意してください。この点で、まだ計算はされていません。そしてちょ\n"
"うど`Enum.map/2`が呼ばれたとき、rangeのそれぞれのアイテムが列挙され、2\n"
"倍されて、1を加えられます。\n"
"`Stream`の関数は*lazy*で`Enum`の関数は*eager*していると言います。\n"
"\n"
"怠惰であるが故に、ストリームは、巨大な(または更に無限の)コレクションで\n"
"働くとき、役に立ちます。`Enum`で多くの操作を繋ぐとき、\n"
"中間のリストが作成されますが、`Stream`は後で実行される\n"
"計算のレシピを作成します。他の例を見てみましょう:\n"
"\n"
"    1..3 |>\n"
"      Enum.map(&IO.inspect(&1)) |>\n"
"      Enum.map(&(&1 * 2)) |>\n"
"      Enum.map(&IO.inspect(&1))\n"
"    1\n"
"    2\n"
"    3\n"
"    2\n"
"    4\n"
"    6\n"
"    #=> [2,4,6]\n"
"\n"
"最初にリストの各要素をプリントし、それから各要素を2倍し、最期に新しい値を\n"
"プリントしています。この例で、リストは3回列挙されています。\n"
"ストリームでの例を見てみましょう:\n"
"\n"
"    stream = 1..3 |>\n"
"      Stream.map(&IO.inspect(&1)) |>\n"
"      Stream.map(&(&1 * 2)) |>\n"
"      Stream.map(&IO.inspect(&1))\n"
"    Enum.to_list(stream)\n"
"    1\n"
"    2\n"
"    2\n"
"    4\n"
"    3\n"
"    6\n"
"    #=> [2,4,6]\n"
"\n"
"最後の結果は同じですが、要素のプリントされる順番が異っています!\n"
"ストリームでは、最初の要素をプリントし、それからそれを2倍したものを\n"
"プリントしています。この例ではリストは一度だけ列挙されました!\n"
"\n"
"それが、ストリームが構成可能だと最初に言ったときに、意味したものなので\n"
"す。`Stream.map/2`を複数回呼び出し、ストリームを効果的に構成し、それは\n"
"lazyであることに注意してください。計算の実行は`Enum`モジュールの関数を\n"
"呼び出した時にだけ行われます。\n"
"\n"
"## ストリームの作成\n"
"\n"
"ストリームを返す、Elixirの標準ライブラリの沢山の関数があります。\n"
"幾つかの例は:\n"
"\n"
"  * `IO.stream/2`         - 入力行のストリーム、一つずつ。\n"
"  * `URI.query_decoder/1` - query stringのデコード、二つずつ。\n"
"\n"
"このモジュールも、`Stream.cycle/1`、`Stream.unfold/2`、\n"
"`Stream.resource/3`などのストリームを作成する、多くの便利な関数を提供し\n"
"ます。\n"
"\n"
"このモジュールの関数はenumerableを返すことが保証されていることに\n"
"注意してください。\n"
"enumerableは(構造体、無名関数など)異った形を持つことができるので、\n"
"このモジュールの関数はそれらの任意の形を返すかもしれないし、それが\n"
"何時でも変るかもしれません。例えば、今日無名関数を返す、ある関数が、\n"
"将来のリリースでは構造体を返すかもしれません。\n"

#. TRANSLATORS: def System.argv(args)
#: lib/system.ex:85
msgid ""
"Modifies command line arguments.\n"
"\n"
"Changes the list of command line arguments. Use it with caution,\n"
"as it destroys any previous argv information.\n"
msgstr ""
"コマンドライン引数を変更します。\n"
"\n"
"コマンドライン引数のリストを変更します。\n"
"以前のargv情報は全て破壊されますので、注意して使用してください。\n"

#. TRANSLATORS: def Keyword.merge(d1, d2)
#: lib/keyword.ex:356
msgid ""
"Merges two keyword lists into one. \n"
"\n"
"If they have duplicated keys, the one given in the second argument wins.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4]) |> Enum.sort\n"
"    [a: 3, b: 2, d: 4]\n"
"\n"
msgstr ""
"二つのキーワードリストを一つにマージします。\n"
"\n"
"もし重複したキーがあれば、二つめの引数が勝ちます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4]) |> Enum.sort\n"
"    [a: 3, b: 2, d: 4]\n"
"\n"

#. TRANSLATORS: def Keyword.merge(d1, d2, fun)
#: lib/keyword.ex:375
msgid ""
"Merges two keyword lists into one. \n"
"\n"
"If they have duplicated keys, the given function is invoked to solve "
"conflicts.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4], fn (_k, v1, v2) ->\n"
"    ...>  v1 + v2\n"
"    ...> end)\n"
"    [a: 4, b: 2, d: 4]\n"
"\n"
msgstr ""
"二つのキーワードリストを一つにマージます。\n"
"\n"
"もし重複したキーがあれば、衝突を解決するため、与えられた関数が\n"
"起動されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4], fn (_k, v1, v2) ->\n"
"    ...>  v1 + v2\n"
"    ...> end)\n"
"    [a: 4, b: 2, d: 4]\n"
"\n"

#. TRANSLATORS: def Dict.merge(dict1, dict2, fun \\ fn _k, _v1, v2 -> v2 end)
#: lib/dict.ex:485
msgid ""
"Merges the dict `dict2` into dict `dict1`.\n"
"\n"
"If one of the `dict2` entries already existed in `dict1`, the\n"
"conflicting entries in `dict2` have higher precedence unless a\n"
"function is given to resolve conflicts.\n"
"\n"
"Notice this function is polymorphic as it merges dicts of any\n"
"type. Each dict implementation also provides a `merge` function,\n"
"but they can only merge dicts of the same type.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict1 = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict2 = Enum.into([a: 3, d: 4], dict_impl.new)\n"
"    iex> dict = Dict.merge(dict1, dict2)\n"
"    iex> [a: Dict.get(dict, :a), b: Dict.get(dict, :b), d: Dict.get(dict, :"
"d)]\n"
"    [a: 3, b: 2, d: 4]\n"
"\n"
"    iex> dict1 = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict2 = Enum.into([a: 3, d: 4], dict_impl.new)\n"
"    iex> dict = Dict.merge(dict1, dict2, fn(_k, v1, v2) ->\n"
"    ...>   v1 + v2\n"
"    ...> end)\n"
"    iex> [a: Dict.get(dict, :a), b: Dict.get(dict, :b), d: Dict.get(dict, :"
"d)]\n"
"    [a: 4, b: 2, d: 4]\n"
"\n"
msgstr ""
"dict`dicdt2`をdict`dict1`にマージします。\n"
"\n"
"もし、`dict2`のエントリの一つが既に`dict1`に存在したら、\n"
"衝突を解決するための関数が与えられていないかぎり、\n"
"`dict2`のエントリがより高い優先順位を持ちます。\n"
"\n"
"任意のタイプのdictをマージするので、この関数はポリモーフィック(多態的)\n"
"であることに注意してください。\n"
"それぞれのdict実装も、`merge`関数を提供しますが、それらは同じタイプの\n"
"dict同士のマージが出来るだけです。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict1 = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict2 = Enum.into([a: 3, d: 4], dict_impl.new)\n"
"    iex> dict = Dict.merge(dict1, dict2)\n"
"    iex> [a: Dict.get(dict, :a), b: Dict.get(dict, :b), d: Dict.get(dict, :"
"d)]\n"
"    [a: 3, b: 2, d: 4]\n"
"\n"
"    iex> dict1 = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict2 = Enum.into([a: 3, d: 4], dict_impl.new)\n"
"    iex> dict = Dict.merge(dict1, dict2, fn(_k, v1, v2) ->\n"
"    ...>   v1 + v2\n"
"    ...> end)\n"
"    iex> [a: Dict.get(dict, :a), b: Dict.get(dict, :b), d: Dict.get(dict, :"
"d)]\n"
"    [a: 4, b: 2, d: 4]\n"
"\n"

#. TRANSLATORS: def Kernel.=~(left, right)
#: lib/kernel.ex:1390
msgid ""
"Matches the term on the left against the regular expression or string on "
"the\n"
"right. Returns true if `left` matches `right` (if it's a regular "
"expression)\n"
"or contains `right` (if it's a string).\n"
"\n"
"## Examples\n"
"\n"
"    iex> \"abcd\" =~ ~r/c(d)/\n"
"    true\n"
"\n"
"    iex> \"abcd\" =~ ~r/e/\n"
"    false\n"
"\n"
"    iex> \"abcd\" =~ \"bc\"\n"
"    true\n"
"\n"
"    iex> \"abcd\" =~ \"ad\"\n"
"    false\n"
"\n"
msgstr ""
"右辺の正規表現か文字列に対して、左辺をマッチさせます。`left`が、正規表\n"
"現`right`にマッチしたか、文字列`right`を含んでいたら、trueを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> \"abcd\" =~ ~r/c(d)/\n"
"    true\n"
"\n"
"    iex> \"abcd\" =~ ~r/e/\n"
"    false\n"
"\n"
"    iex> \"abcd\" =~ \"bc\"\n"
"    true\n"
"\n"
"    iex> \"abcd\" =~ \"ad\"\n"
"    false\n"
"\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.case(condition, clauses)
#: lib/kernel/special_forms.ex:1381
msgid ""
"Matches the given expression against the given clauses.\n"
"\n"
"## Examples\n"
"\n"
"    case thing do\n"
"      {:selector, i, value} when is_integer(i) ->\n"
"        value\n"
"      value ->\n"
"        value\n"
"    end\n"
"\n"
"In the example above, we match `thing` against each clause \"head\"\n"
"and execute the clause \"body\" corresponding to the first clause\n"
"that matches. If no clause matches, an error is raised.\n"
"\n"
"## Variables handling\n"
"\n"
"Notice that variables bound in a clause \"head\" do not leak to the\n"
"outer context:\n"
"\n"
"    case data do\n"
"      {:ok, value} -> value\n"
"      :error -> nil\n"
"    end\n"
"\n"
"    value #=> unbound variable value\n"
"\n"
"However, variables explicitly bound in the clause \"body\" are\n"
"accessible from the outer context:\n"
"\n"
"    value = 7\n"
"\n"
"    case lucky? do\n"
"      false -> value = 13\n"
"      true  -> true\n"
"    end\n"
"\n"
"    value #=> 7 or 13\n"
"\n"
"In the example above, value is going to be `7` or `13` depending on\n"
"the value of `lucky?`. In case `value` has no previous value before\n"
"case, clauses that do not explicitly bind a value have the variable\n"
"bound to nil.\n"
msgstr ""
"与えられた節に対して、与えられた式をマッチさせます。\n"
"\n"
"## 例\n"
"\n"
"    case thing do\n"
"      {:selector, i, value} when is_integer(i) ->\n"
"        value\n"
"      value ->\n"
"        value\n"
"    end\n"
"\n"
"上の例では、それぞれの\"head\"と`thing`を比べて、\n"
"マッチした最初の節の\"body\"を実行します。\n"
"もしマッチする節が無いと、エラーが上ります。\n"
"\n"
"## 変数の取り扱い(ハンドリング)\n"
"\n"
"節の\"head\"で束縛された変数は、外部のコンテキストには漏れないことに注意\n"
"してください:\n"
"\n"
"    case data do\n"
"      {:ok, value} -> value\n"
"      :error -> nil\n"
"    end\n"
"\n"
"    value #=> unbound variable value\n"
"\n"
"しかしながら、節の\"body\"で明示的に束縛された変数は、\n"
"外部のコンテキストからアクセスできます:\n"
"\n"
"    value = 7\n"
"\n"
"    case lucky? do\n"
"      false -> value = 13\n"
"      true  -> true\n"
"    end\n"
"\n"
"    value #=> 7 or 13\n"
"\n"
"上の例で、`lucky?`の値に依存して、valueは`7`か`13`になります。\n"
"`value`がcaseの前で以前の値を持っていない場合、明示的に束縛されない\n"
"変数の値は、nilに束縛されます。\n"

#. TRANSLATORS: def Enum.flat_map_reduce(collection, acc, fun)
#: lib/enum.ex:818
msgid ""
"Maps and reduces a collection, flattening the given results.\n"
"\n"
"It expects an accumulator and a function that receives each stream item\n"
"and an accumulator, and must return a tuple containing a new stream\n"
"(often a list) with the new accumulator or a tuple with `:halt` as first\n"
"element and the accumulator as second.\n"
"\n"
"## Examples\n"
"\n"
"    iex> enum = 1..100\n"
"    iex> n = 3\n"
"    iex> Enum.flat_map_reduce(enum, 0, fn i, acc ->\n"
"    ...>   if acc < n, do: {[i], acc + 1}, else: {:halt, acc}\n"
"    ...> end)\n"
"    {[1,2,3], 3}\n"
"\n"
msgstr ""
"コレクションをmapしてreduceし、結果をflattenします。\n"
"\n"
"アキュムレータと関数を期待します。関数は、それぞれのストリームのアイテ\n"
"ムとアキュムレータを受信して、新しいストリーム(しばしばリストです)と新\n"
"しいアキュムレータを含むタプルか、最初の要素が`:halt`で二つめの要素がア\n"
"キュムレータであるタプルを、返さなくてはなりません。\n"
"\n"
"## 例\n"
"\n"
"    iex> enum = 1..100\n"
"    iex> n = 3\n"
"    iex> Enum.flat_map_reduce(enum, 0, fn i, acc ->\n"
"    ...>   if acc < n, do: {[i], acc + 1}, else: {:halt, acc}\n"
"    ...> end)\n"
"    {[1,2,3], 3}\n"
"\n"

#. TRANSLATORS: def Enum.map_join(collection, joiner \\ "", mapper)
#: lib/enum.ex:1001
msgid ""
"Maps and joins the given `collection` in one pass.\n"
"`joiner` can be either a binary or a list and the\n"
"result will be of the same type as `joiner`. If\n"
"`joiner` is not passed at all, it defaults to an\n"
"empty binary.\n"
"\n"
"All items in the collection must be convertible\n"
"to a binary, otherwise an error is raised.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.map_join([1, 2, 3], &(&1 * 2))\n"
"    \"246\"\n"
"\n"
"    iex> Enum.map_join([1, 2, 3], \" = \", &(&1 * 2))\n"
"    \"2 = 4 = 6\"\n"
"\n"
msgstr ""
"一度のパスで、与えられた`collection`をmapしてjoinします。\n"
"`joiner`はバイナリでもリストでもよく、結果は\n"
"`joiner`と同じタイプになります。もし`joiner`が全く\n"
"パスされない場合、デフォルトは空のバイナリになります。\n"
"\n"
"コレクションの全てのアイテムはバイナリへ変換できなければ\n"
"なりません。さもないとエラーが上ります。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.map_join([1, 2, 3], &(&1 * 2))\n"
"    \"246\"\n"
"\n"
"    iex> Enum.map_join([1, 2, 3], \" = \", &(&1 * 2))\n"
"    \"2 = 4 = 6\"\n"
"\n"

#. TRANSLATORS: def Inspect.Algebra.surround_many(left, docs, right, opts, fun, separator \\ ",")
#: lib/inspect/algebra.ex:439
msgid ""
"Maps and glues a collection of items.\n"
"\n"
"It uses the given left and right as surrounding and a separator for\n"
"each item. A limit can be passed which, once reached, stops gluing\n"
"and outputs \"...\" instead.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.surround_many(\"[\", Enum.to_list(1..5), "
"\"]\",\n"
"    ...>         %Inspect.Opts{limit: :infinity}, fn i, _opts -> "
"to_string(i) end)\n"
"    iex> Inspect.Algebra.format(doc, 5) |> IO.iodata_to_binary\n"
"    \"[1,\\n 2,\\n 3,\\n 4,\\n 5]\"\n"
"\n"
"    iex> doc = Inspect.Algebra.surround_many(\"[\", Enum.to_list(1..5), "
"\"]\",\n"
"    ...>         %Inspect.Opts{limit: 3}, fn i, _opts -> to_string(i) end)\n"
"    iex> Inspect.Algebra.format(doc, 20) |> IO.iodata_to_binary\n"
"    \"[1, 2, 3, ...]\"\n"
"\n"
"    iex> doc = Inspect.Algebra.surround_many(\"[\", Enum.to_list(1..5), "
"\"]\",\n"
"    ...>         %Inspect.Opts{limit: 3}, fn i, _opts -> to_string(i) end, "
"\"!\")\n"
"    iex> Inspect.Algebra.format(doc, 20) |> IO.iodata_to_binary\n"
"    \"[1! 2! 3! ...]\"\n"
msgstr ""
"アイテムのコレクションをマップして接着します。\n"
"\n"
"周囲として与えられたleft、rightと、それぞれのアイテムのseparatorを\n"
"使います。\n"
"\n"
"制限に一度到達すると、接着を止め、\"...\"を替わりに出力します。\n"
"この制限は渡すことができます。\n"
"\n"
"## 例\n"
"\n"
"    iex> doc = Inspect.Algebra.surround_many(\"[\", Enum.to_list(1..5), "
"\"]\",\n"
"    ...>         %Inspect.Opts{limit: :infinity}, fn i, _opts -> "
"to_string(i) end)\n"
"    iex> Inspect.Algebra.format(doc, 5) |> IO.iodata_to_binary\n"
"    \"[1,\\n 2,\\n 3,\\n 4,\\n 5]\"\n"
"\n"
"    iex> doc = Inspect.Algebra.surround_many(\"[\", Enum.to_list(1..5), "
"\"]\",\n"
"    ...>         %Inspect.Opts{limit: 3}, fn i, _opts -> to_string(i) end)\n"
"    iex> Inspect.Algebra.format(doc, 20) |> IO.iodata_to_binary\n"
"    \"[1, 2, 3, ...]\"\n"
"\n"
"    iex> doc = Inspect.Algebra.surround_many(\"[\", Enum.to_list(1..5), "
"\"]\",\n"
"    ...>         %Inspect.Opts{limit: 3}, fn i, _opts -> to_string(i) end, "
"\"!\")\n"
"    iex> Inspect.Algebra.format(doc, 20) |> IO.iodata_to_binary\n"
"    \"[1! 2! 3! ...]\"\n"

#. TRANSLATORS: defmacro Kernel.defoverridable(tuples)
#: lib/kernel.ex:3207
msgid ""
"Makes the given functions in the current module overridable. An overridable\n"
"function is lazily defined, allowing a developer to customize it.\n"
"\n"
"## Example\n"
"\n"
"    defmodule DefaultMod do\n"
"      defmacro __using__(_opts) do\n"
"        quote do\n"
"          def test(x, y) do\n"
"            x + y\n"
"          end\n"
"\n"
"          defoverridable [test: 2]\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    defmodule InheritMod do\n"
"      use DefaultMod\n"
"\n"
"      def test(x, y) do\n"
"        x * y + super(x, y)\n"
"      end\n"
"    end\n"
"\n"
"As seen as in the example `super` can be used to call the default\n"
"implementation.\n"
msgstr ""
"現在のモジュールの与えられた関数をoverridableにします。overridable関数\n"
"は、開発者がカスタマイズするために、後から定義することを許します。\n"
"\n"
"## 例\n"
"\n"
"    defmodule DefaultMod do\n"
"      defmacro __using__(_opts) do\n"
"        quote do\n"
"          def test(x, y) do\n"
"            x + y\n"
"          end\n"
"\n"
"          defoverridable [test: 2]\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    defmodule InheritMod do\n"
"      use DefaultMod\n"
"\n"
"      def test(x, y) do\n"
"        x * y + super(x, y)\n"
"      end\n"
"    end\n"
"\n"
"上は良くみられる例で、`super`はデオフォルトの実装を呼ぶため使われます。\n"

#. TRANSLATORS: def Module.make_overridable(module, tuples)
#: lib/module.ex:684
msgid ""
"Makes the given functions in `module` overridable.\n"
"An overridable function is lazily defined, allowing a\n"
"developer to customize it. See `Kernel.defoverridable/1` for\n"
"more information and documentation.\n"
msgstr ""
"`module`の与えられた関数をoverridableにします。\n"
"overridable関数は、遅延して定義され、\n"
"開発者にカスタマイズすることを許します。\n"
"詳細については、`Kernel.defoverridable/1` を参照してください。\n"

#. TRANSLATORS: def System.find_executable(program)
#: lib/system.ex:240
msgid ""
"Locates an executable on the system.\n"
"\n"
"This function looks up an executable program given\n"
"its name using the environment variable PATH on Unix\n"
"and Windows. It also considers the proper executable\n"
"extension for each OS, so for Windows it will try to\n"
"lookup files with `.com`, `.cmd` or similar extensions.\n"
msgstr ""
"システム上の実行ファイルの場所を探します。\n"
"\n"
"この関数は、UnixやWindowsでの環境変数PATHを使い、\n"
"与えられた名前の実行可能プログラムを見付けます。\n"
"それぞれのOS毎に適当な実行可能拡張子を考慮するので、\n"
"Windowsでは`.com`、`.cmd`または類似した拡張子で\n"
"ファイルを探します。\n"

#. TRANSLATORS: def Application.load(app)
#: lib/application.ex:268
msgid ""
"Loads the given `app`.\n"
"\n"
"In order to be loaded, an `.app` file must be in the load paths.\n"
"All `:included_applications` will also be loaded.\n"
"\n"
"Loading the application does not start it nor load its modules, but\n"
"it does load its environment.\n"
msgstr ""
"与えられた`app`をロードします。\n"
"\n"
"ロードされる為には、`.app`ファイルはロードパス上になければなりません。\n"
"全ての`:included_applications`もロードされます。\n"
"\n"
"ロードするアプリケーションは開始しませんし、モジュールのロードもしませ\n"
"んが、その環境をロードします。\n"

#. TRANSLATORS: def Enum.concat(enumerables)
#: lib/enum.ex:387
msgid ""
"Given an enumerable of enumerables, concatenates the enumerables into a "
"single list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.concat([1..3, 4..6, 7..9])\n"
"    [1,2,3,4,5,6,7,8,9]\n"
"\n"
"    iex> Enum.concat([[1, [2], 3], [4], [5, 6]])\n"
"    [1,[2],3,4,5,6]\n"
"\n"
msgstr ""
"与えられたenumerableのenumerableを一つのリストに連結します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.concat([1..3, 4..6, 7..9])\n"
"    [1,2,3,4,5,6,7,8,9]\n"
"\n"
"    iex> Enum.concat([[1, [2], 3], [4], [5, 6]])\n"
"    [1,[2],3,4,5,6]\n"
"\n"

#. TRANSLATORS: def Application.format_error(reason)
#: lib/application.ex:329
msgid ""
"Formats the error reason returned by `start/2`,\n"
"`ensure_started/2`, `stop/1`, `load/1` and `unload/1`,\n"
"returns a string.\n"
msgstr ""
"`start/2`、`ensure_started/2`、`stop/1`、`load/1`、`unload/1`で\n"
"返された、エラーのreasonをフォーマットし、文字列を返します。\n"

#. TRANSLATORS: def Enum.fetch(collection, n)
#: lib/enum.ex:596
msgid ""
"Finds the element at the given index (zero-based).\n"
"\n"
"Returns `{:ok, element}` if found, otherwise `:error`.\n"
"\n"
"A negative index can be passed, which means the collection is\n"
"enumerated once and the index is counted from the end (i.e.\n"
"`-1` fetches the last element).\n"
"\n"
"Note this operation takes linear time. In order to access\n"
"the element at index `n`, it will need to traverse `n`\n"
"previous elements.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.fetch([2, 4, 6], 0)\n"
"    {:ok, 2}\n"
"\n"
"    iex> Enum.fetch([2, 4, 6], 2)\n"
"    {:ok, 6}\n"
"\n"
"    iex> Enum.fetch([2, 4, 6], 4)\n"
"    :error\n"
"\n"
msgstr ""
"与えられた(0始まりの)インデックスの要素を見付けます。\n"
"\n"
"見付かれば、`{:ok, 要素}`を返し、さもなければ`:error`を返します。\n"
"\n"
"負のインデックスが渡されると、コレクションは一度列挙され、\n"
"インデックスは終わりから数えられる(即ち、`-1`は最後の要素を\n"
"取ってきます)ことを意味します。\n"
"\n"
"この操作は線形時間がかかることに気を付けてください。\n"
"インデックス`n`の要素へアクセスするために、`n`個の以前の\n"
"要素を渡り歩く必要があります。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.fetch([2, 4, 6], 0)\n"
"    {:ok, 2}\n"
"\n"
"    iex> Enum.fetch([2, 4, 6], 2)\n"
"    {:ok, 6}\n"
"\n"
"    iex> Enum.fetch([2, 4, 6], 4)\n"
"    :error\n"
"\n"

#. TRANSLATORS: def Enum.at(collection, n, default \\ nil)
#: lib/enum.ex:296
msgid ""
"Finds the element at the given index (zero-based).\n"
"\n"
"Returns `default` if index is out of bounds.\n"
"\n"
"Note this operation takes linear time. In order to access\n"
"the element at index `n`, it will need to traverse `n`\n"
"previous elements.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.at([2, 4, 6], 0)\n"
"    2\n"
"\n"
"    iex> Enum.at([2, 4, 6], 2)\n"
"    6\n"
"\n"
"    iex> Enum.at([2, 4, 6], 4)\n"
"    nil\n"
"\n"
"    iex> Enum.at([2, 4, 6], 4, :none)\n"
"    :none\n"
"\n"
msgstr ""
"与えられた(0始まりの)インデックスの要素を見付けます。\n"
"\n"
"インデックスが範囲外なら、`default`を返します。\n"
"\n"
"この操作は線形時間がかかることに気を付けてください。\n"
"インデックス`n`の要素へアクセスするために、`n`個の以前の\n"
"要素を渡り歩く必要があります。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.at([2, 4, 6], 0)\n"
"    2\n"
"\n"
"    iex> Enum.at([2, 4, 6], 2)\n"
"    6\n"
"\n"
"    iex> Enum.at([2, 4, 6], 4)\n"
"    nil\n"
"\n"
"    iex> Enum.at([2, 4, 6], 4, :none)\n"
"    :none\n"
"\n"

#. TRANSLATORS: def IO.ANSI.faint()
#: lib/io/ansi.ex:51
msgid "Faint (decreased intensity), not widely supported"
msgstr "Faint(かすかな)(低輝度)、広くはサポートされていません"

#. TRANSLATORS: def Kernel.binary_part(binary, start, length)
#: lib/kernel.ex:112
msgid ""
"Extracts the part of the binary starting at `start` with length `length`.\n"
"Binaries are zero-indexed.\n"
"\n"
"If start or length references in any way outside the binary, an\n"
"`ArgumentError` exception is raised.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> binary_part(\"foo\", 1, 2)\n"
"    \"oo\"\n"
"\n"
"A negative length can be used to extract bytes at the end of a binary:\n"
"\n"
"    iex> binary_part(\"foo\", 3, -1)\n"
"    \"o\"\n"
"\n"
msgstr ""
"`start`から長さ`length`のバイナリの部分を抽出します。\n"
"バイナリは0始まりです。\n"
"\n"
"もしstartかlengthがバイナリの外部を参照するなら、\n"
"`ArgumentError`例外が上ります。\n"
"\n"
"ガードテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> binary_part(\"foo\", 1, 2)\n"
"    \"oo\"\n"
"\n"
"start位置で終わるバイトを抽出するために、負の長さを使うことができます。\n"
"\n"
"    iex> binary_part(\"foo\", 3, -1)\n"
"    \"o\"\n"
"\n"

#. TRANSLATORS: @type expr
#: lib/macro.ex:0
msgid "Expr node (remaining ones are literals)"
msgstr "Exprノード(残りの物はリテラルです)"

#. TRANSLATORS: def Path.join(left, right)
#: lib/path.ex:466
msgid ""
"Joins two paths.\n"
"\n"
"The right path will always be expanded to its relative format\n"
"and any trailing slash is removed on join.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.join(\"foo\", \"bar\")\n"
"    \"foo/bar\"\n"
"\n"
msgstr ""
"二つのパスを結合します。\n"
"\n"
"右のパスは常に、相対フォーマットで展開され、結合において\n"
"末尾にスラッシュがなかったら、追加されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Path.join(\"foo\", \"bar\")\n"
"    \"foo/bar\"\n"
"\n"

#. TRANSLATORS: def Enum.join(collection, joiner \\ "")
#: lib/enum.ex:943
msgid ""
"Joins the given `collection` into a binary using `joiner` as a separator.\n"
"If `joiner` is not passed at all, it defaults to the empty binary.\n"
"\n"
"All items in the collection must be convertible\n"
"to a binary, otherwise an error is raised.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.join([1, 2, 3])\n"
"    \"123\"\n"
"\n"
"    iex> Enum.join([1, 2, 3], \" = \")\n"
"    \"1 = 2 = 3\"\n"
"\n"
msgstr ""
"`collection`をバイナリ`joiner`をセパレータとしてjoinします。\n"
"もし`joiner`が全くパスされない場合、デフォルトは空のバイナリに\n"
"なります。\n"
"\n"
"コレクションの全てのアイテムはバイナリへ変換できなければ\n"
"なりません。さもないとエラーが上ります。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.join([1, 2, 3])\n"
"    \"123\"\n"
"\n"
"    iex> Enum.join([1, 2, 3], \" = \")\n"
"    \"1 = 2 = 3\"\n"
"\n"

#. TRANSLATORS: def IO.ANSI.italic()
#: lib/io/ansi.ex:54
msgid "Italic: on. Not widely supported. Sometimes treated as inverse."
msgstr "イタリック: on。広くはサポートされていません。時々反転と見做されます。"

#. TRANSLATORS: def Kernel.apply(fun, args)
#: lib/kernel.ex:71
msgid ""
"Invokes the given `fun` with the array of arguments `args`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> apply(fn x -> x * 2 end, [2])\n"
"    4\n"
"\n"
msgstr ""
"引数の配列`args`で与えられた`fun`を起動します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> apply(fn x -> x * 2 end, [2])\n"
"    4\n"
"\n"

#. TRANSLATORS: def Kernel.apply(module, fun, args)
#: lib/kernel.ex:87
msgid ""
"Invokes the given `fun` from `module` with the array of arguments `args`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> apply(Enum, :reverse, [[1, 2, 3]])\n"
"    [3,2,1]\n"
"\n"
msgstr ""
"引数の配列`args`で与えられた`module`の`fun`を起動します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> apply(Enum, :reverse, [[1, 2, 3]])\n"
"    [3,2,1]\n"
"\n"

#. TRANSLATORS: def Enum.each(collection, fun)
#: lib/enum.ex:536
msgid ""
"Invokes the given `fun` for each item in the `collection`.\n"
"Returns `:ok`.\n"
"\n"
"## Examples\n"
"\n"
"    Enum.each([\"some\", \"example\"], fn(x) -> IO.puts x end)\n"
"    \"some\"\n"
"    \"example\"\n"
"    #=> :ok\n"
"\n"
msgstr ""
"`collection`のそれぞれのアイテムに対して、与えられた`fun`を起動します。\n"
"`:ok`を返します。\n"
"\n"
"## 例\n"
"\n"
"    Enum.each([\"some\", \"example\"], fn(x) -> IO.puts x end)\n"
"    \"some\"\n"
"    \"example\"\n"
"    #=> :ok\n"
"\n"

#. TRANSLATORS: def Enum.any?(collection, fun \\ fn x -> x end)
#: lib/enum.ex:259
msgid ""
"Invokes the given `fun` for each item in the `collection` and returns `true` "
"if\n"
"at least one invocation returns `true`. Returns `false` otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.any?([2, 4, 6], fn(x) -> rem(x, 2) == 1 end)\n"
"    false\n"
"\n"
"    iex> Enum.any?([2, 3, 4], fn(x) -> rem(x, 2) == 1 end)\n"
"    true\n"
"\n"
"If no function is given, it defaults to checking if\n"
"at least one item in the collection evaluates to `true`.\n"
"\n"
"    iex> Enum.any?([false, false, false])\n"
"    false\n"
"\n"
"    iex> Enum.any?([false, true, false])\n"
"    true\n"
"\n"
msgstr ""
"`collection`のそれぞれのアイテムに対して、与えられた`fun`を起動し、少な\n"
"くとも一つが`true`を返すなら、`true`を返します。さもなければ、`false`を\n"
"返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.any?([2, 4, 6], fn(x) -> rem(x, 2) == 1 end)\n"
"    false\n"
"\n"
"    iex> Enum.any?([2, 3, 4], fn(x) -> rem(x, 2) == 1 end)\n"
"    true\n"
"\n"
"関数が与えられないと、デフォルトで少なくともひとつのコレク\n"
"ションのアイテムが`true`に評価されるかをチェックします。\n"
"\n"
"    iex> Enum.any?([false, false, false])\n"
"    false\n"
"\n"
"    iex> Enum.any?([false, true, false])\n"
"    true\n"
"\n"

#. TRANSLATORS: def Enum.all?(collection, fun \\ fn x -> x end)
#: lib/enum.ex:222
msgid ""
"Invokes the given `fun` for each item in the `collection` and returns "
"`false`\n"
"if at least one invocation returns `false`. Otherwise returns `true`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.all?([2, 4, 6], fn(x) -> rem(x, 2) == 0 end)\n"
"    true\n"
"\n"
"    iex> Enum.all?([2, 3, 4], fn(x) -> rem(x, 2) == 0 end)\n"
"    false\n"
"\n"
"If no function is given, it defaults to checking if\n"
"all items in the collection evaluate to `true`.\n"
"\n"
"    iex> Enum.all?([1, 2, 3])\n"
"    true\n"
"\n"
"    iex> Enum.all?([1, nil, 3])\n"
"    false\n"
"\n"
msgstr ""
"`collection`のそれぞれのアイテムに対して与えられた`fun`を起動し、\n"
"その結果、少なくとも一つが`false`を返したら、`false`を返します。\n"
"さもなければ、`true`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.all?([2, 4, 6], fn(x) -> rem(x, 2) == 0 end)\n"
"    true\n"
"\n"
"    iex> Enum.all?([2, 3, 4], fn(x) -> rem(x, 2) == 0 end)\n"
"    false\n"
"\n"
"関数が与えられないなら、デフォルトでコレクションの\n"
"全てのアイテムが`true`に評価されるかをチェックします。\n"
"\n"
"    iex> Enum.all?([1, 2, 3])\n"
"    true\n"
"\n"
"    iex> Enum.all?([1, nil, 3])\n"
"    false\n"
"\n"

#. TRANSLATORS: def Enum.map_reduce(collection, acc, fun)
#: lib/enum.ex:1032
msgid ""
"Invokes the given `fun` for each item in the `collection`\n"
"while also keeping an accumulator. Returns a tuple where\n"
"the first element is the mapped collection and the second\n"
"one is the final accumulator.\n"
"\n"
"For dicts, the first tuple element must be a `{key, value}`\n"
"tuple.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.map_reduce([1, 2, 3], 0, fn(x, acc) -> {x * 2, x + acc} end)\n"
"    {[2, 4, 6], 6}\n"
"\n"
msgstr ""
"アキュムレータを保持しながら、`collection`のそれぞれのアイテムで与えら\n"
"れた`fun`を起動します。最初の要素がmapされたコレクションで\n"
"二つめは最終的なアキュムレータであるタプルを返します。\n"
"\n"
"dictでは、最初のタプルの要素は`{key, value}`タプルでなくては\n"
"なりません。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.map_reduce([1, 2, 3], 0, fn(x, acc) -> {x * 2, x + acc} end)\n"
"    {[2, 4, 6], 6}\n"
"\n"

#. TRANSLATORS: def Enum.reduce(collection, fun)
#: lib/enum.ex:1346
msgid ""
"Invokes `fun` for each element in the collection passing that element and "
"the\n"
"accumulator `acc` as arguments. `fun`'s return value is stored in `acc`.\n"
"The first element of the collection is used as the initial value of `acc`.\n"
"Returns the accumulator.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reduce([1, 2, 3, 4], fn(x, acc) -> x * acc end)\n"
"    24\n"
"\n"
msgstr ""
"collectionのそれぞれの要素について、その要素とアキュムレータを引数とし\n"
"て、`fun`を起動します。`fun`の戻り値は、`acc`に保存されます。\n"
"collectionの最初の要素は、`acc`の初期値として使われます。アキュムレータ\n"
"を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.reduce([1, 2, 3, 4], fn(x, acc) -> x * acc end)\n"
"    24\n"
"\n"

#. TRANSLATORS: def Enum.reduce(collection, acc, fun)
#: lib/enum.ex:1315
msgid ""
"Invokes `fun` for each element in the collection passing that element and "
"the\n"
"accumulator `acc` as arguments. `fun`'s return value is stored in `acc`.\n"
"Returns the accumulator.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reduce([1, 2, 3], 0, fn(x, acc) -> x + acc end)\n"
"    6\n"
"\n"
msgstr ""
"collectionのそれぞれの要素について、その要素とアキュムレータを引数とし\n"
"て、`fun`を起動します。`fun`の戻り値は、`acc`に保存されます。アキュムレー\n"
"タを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.reduce([1, 2, 3], 0, fn(x, acc) -> x + acc end)\n"
"    6\n"
"\n"

#. TRANSLATORS: def Enum.intersperse(collection, element)
#: lib/enum.ex:850
msgid ""
"Intersperses `element` between each element of the enumeration.\n"
"\n"
"Complexity: O(n)\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.intersperse([1, 2, 3], 0)\n"
"    [1, 0, 2, 0, 3]\n"
"\n"
"    iex> Enum.intersperse([1], 0)\n"
"    [1]\n"
"\n"
"    iex> Enum.intersperse([], 0)\n"
"    []\n"
"\n"
msgstr ""
"列挙(collection)のそれぞれの要素の間で、`element`を散在さ\n"
"せます。\n"
"\n"
"複雑さ: O(n)\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.intersperse([1, 2, 3], 0)\n"
"    [1, 0, 2, 0, 3]\n"
"\n"
"    iex> Enum.intersperse([1], 0)\n"
"    [1]\n"
"\n"
"    iex> Enum.intersperse([], 0)\n"
"    []\n"
"\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.__aliases__(args)
#: lib/kernel/special_forms.ex:1328
msgid ""
"Internal special form to hold aliases information.\n"
"\n"
"It is usually compiled to an atom:\n"
"\n"
"    iex> quote do: Foo.Bar\n"
"    {:__aliases__, [alias: false], [:Foo, :Bar]}\n"
"\n"
"Elixir represents `Foo.Bar` as `__aliases__` so calls can be\n"
"unambiguously identified by the operator `:.`. For example:\n"
"\n"
"    iex> quote do: Foo.bar\n"
"    {{:., [], [{:__aliases__, [alias: false], [:Foo]}, :bar]}, [], []}\n"
"\n"
"Whenever an expression iterator sees a `:.` as the tuple key,\n"
"it can be sure that it represents a call and the second argument\n"
"in the list is an atom.\n"
"\n"
"On the other hand, aliases holds some properties:\n"
"\n"
"  1. The head element of aliases can be any term that must expand to\n"
"     an atom at compilation time.\n"
"\n"
"  2. The tail elements of aliases are guaranteed to always be atoms.\n"
"\n"
"  3. When the head element of aliases is the atom `:Elixir`, no expansion "
"happen.\n"
"\n"
msgstr ""
"エイリアス情報を保持する内部のスペシャルフォームです。\n"
"\n"
"通常、アトムにコンパイルされます:\n"
"\n"
"    iex> quote do: Foo.Bar\n"
"    {:__aliases__, [alias: false], [:Foo, :Bar]}\n"
"\n"
"呼び出しが`:.`オペレータによって明確に識別されることができるので、\n"
"Eilxirは`Foo.Bar`を`__aliases__`として表現します。\n"
"例えば:\n"
"\n"
"    iex> quote do: Foo.bar\n"
"    {{:., [], [{:__aliases__, [alias: false], [:Foo]}, :bar]}, [], []}\n"
"\n"
"タプルのキーとして式の反復演算子が`:.`を見付けるときは何時でも、\n"
"それが呼び出しを表現し、リストの2番目の引数は、アトムです。\n"
"\n"
"他方で、aliasはいくつかのプロパティを保持します:\n"
"\n"
"  1. aliasのheadの要素は任意のtermで、コンパイル時にアトムに展開されなけれ"
"ば\n"
"     なりません\n"
"\n"
"  2. aliasのtailの要素は常にアトムであることが保証されます。\n"
"\n"
"  3. aliasのheadの要素がアトム`:Elixir`であるとき、展開は起きません。\n"
"\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.__block__(args)
#: lib/kernel/special_forms.ex:1229
msgid ""
"Internal special form for block expressions.\n"
"\n"
"This is the special form used whenever we have a block\n"
"of expressions in Elixir. This special form is private\n"
"and should not be invoked directly:\n"
"\n"
"    iex> quote do: (1; 2; 3)\n"
"    {:__block__, [], [1, 2, 3]}\n"
"\n"
msgstr ""
"ブロック式のための内部のスペシャルフォームです。これは、Elixirで式のブ\n"
"ロックが表れる時は、いつでも使われるスペシャルフォームです。このスペシャ\n"
"ルフォームはプライベートであり、直接起動するべきではありません:\n"
"\n"
"    iex> quote do: (1; 2; 3)\n"
"    {:__block__, [], [1, 2, 3]}\n"
"\n"

#. TRANSLATORS: def Application.app_dir(app)
#: lib/application.ex:308
msgid ""
"Gets the directory for app.\n"
"\n"
"This information is returned based on the code path. Here is an\n"
"example:\n"
"\n"
"    File.mkdir_p!(\"foo/ebin\")\n"
"    Code.prepend_path(\"foo/ebin\")\n"
"    Application.app_dir(:foo)\n"
"    #=> \"foo\"\n"
"\n"
"Even though the directory is empty and there is no `.app` file\n"
"it is considered the application directory based on the name\n"
"\"foo/ebin\". The name may contain a dash `-` which is considered\n"
"to be the app version and it is removed for the lookup purposes:\n"
"\n"
"    File.mkdir_p!(\"bar-123/ebin\")\n"
"    Code.prepend_path(\"bar-123/ebin\")\n"
"    Application.app_dir(:bar)\n"
"    #=> \"bar-123\"\n"
"\n"
"For more information on code paths, check the `Code` module in\n"
"Elixir and also Erlang's `:code` module.\n"
msgstr ""
"appのディレクトリを取得します。\n"
"\n"
"この関数はコードパスに基いて返されます。以下は例です:\n"
"\n"
"    File.mkdir_p!(\"foo/ebin\")\n"
"    Code.prepend_path(\"foo/ebin\")\n"
"    Application.app_dir(:foo)\n"
"    #=> \"foo\"\n"
"\n"
"ディレクトリが空で、`.app`ファイルが無くても、名前\"foo/ebin\"に\n"
"基いてアプリケーションディレクトリと考えられます。\n"
"名前は、appのバージョンとして考えられ検索目的では取り除かれる、\n"
"ダッシュ`-`を含むかもしれません:\n"
"\n"
"    File.mkdir_p!(\"bar-123/ebin\")\n"
"    Code.prepend_path(\"bar-123/ebin\")\n"
"    Application.app_dir(:bar)\n"
"    #=> \"bar-123\"\n"
"\n"
"コードパスについての詳細は、Elixirの`Code`モジュールと、Erlangの\n"
"`:code`モジュールもチェックしてください。\n"

#. TRANSLATORS: def Enum.sort_by(collection, mapper, sorter \\ :erlang.make_fun(:erlang, :"=<", 2))
#: lib/enum.ex:1775
msgid ""
"Sorts the mapped results of the `collection` according to the `sorter` "
"function.\n"
"\n"
"This function maps each element of the collection using the `mapper`\n"
"function.  The collection is then sorted by the mapped elements using the\n"
"`sorter` function, which defaults to `<=/2`\n"
"\n"
"`sort_by/3` differs from `sort/2` in that it only calculates the comparison\n"
"value for each element in the collection once instead of once for each\n"
"element in each comparison.  If the same function is being called on both\n"
"element, it's also more compact to use `sort_by/3`.\n"
"\n"
"This technique is also known as a\n"
"[Schwartzian Transform](https://en.wikipedia.org/wiki/"
"Schwartzian_transform),\n"
"or the Lisp decorate-sort-undecorate idiom as the `mapper` is decorating "
"the\n"
"original `collection`, then `sorter` is sorting the decorations, and "
"finally\n"
"the `collection` is being undecorated so only the original elements remain,\n"
"but now in sorted order.\n"
"\n"
"## Examples\n"
"\n"
"Using the default `sorter` of `<=/2`:\n"
"\n"
"    iex> Enum.sort_by [\"some\", \"kind\", \"of\", \"monster\"], "
"&byte_size/1\n"
"    [\"of\", \"some\", \"kind\", \"monster\"]\n"
"\n"
"Using a custom `sorter` to override the order:\n"
"\n"
"    iex> Enum.sort_by [\"some\", \"kind\", \"of\", \"monster\"], "
"&byte_size/1, &>=/2\n"
"    [\"monster\", \"some\", \"kind\", \"of\"]\n"
"\n"
msgstr ""
"`sorter` 関数によって `collection` をmapperで処理された結果でソートします。\n"
"\n"
"この関数は、`mapper`関数を使ってコレクションのそれぞれの要素をマップし\n"
"ます。コレクションはそれからデフォルトは`<=/2`である`sorter`関数を使っ\n"
"てマップされた要素でソートされます。\n"
"\n"
"それが各の比較において要素ごとに一度だけ比較計算をするという点で\n"
"`sort_by/3`は`sort/2`と違います。もし同じ関数が両方の要素で呼ばれている\n"
"ならば`sort_by/3`を使うことでよりコンパクトになります。\n"
"\n"
"この技術は [Schwartzian\n"
"Transform](https://en.wikipedia.org/wiki/Schwartzian_transform) として\n"
"知られています。あるいは、Lispのdecorate-sort-undecorate イディオムとし\n"
"て知られています。`mapper`がオリジナルの`collection`のデコレーション、\n"
"それから`sorter`はソートのデコレレーションとして、そして最後にソートさ\n"
"れた順番以外は `collection` はデコレーションされずにオリジナルの要素のま\n"
"まです。\n"
"\n"
"## 例\n"
"\n"
"デフォルトの `sorter` である `<=/2` を使います: \n"
"\n"
"    iex> Enum.sort_by [\"some\", \"kind\", \"of\", \"monster\"], "
"&byte_size/1\n"
"    [\"of\", \"some\", \"kind\", \"monster\"]\n"
"\n"
"カスタム`sorter`として上書きます: \n"
"\n"
"    iex> Enum.sort_by [\"some\", \"kind\", \"of\", \"monster\"], "
"&byte_size/1, &>=/2\n"
"    [\"monster\", \"some\", \"kind\", \"of\"]\n"
"\n"

#. TRANSLATORS: def Enum.sort(collection, fun)
#: lib/enum.ex:1734
msgid ""
"Sorts the collection by the given function.\n"
"\n"
"This function uses the merge sort algorithm. The given function\n"
"must return false if the first argument is less than right one.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.sort([1, 2, 3], &(&1 > &2))\n"
"    [3, 2, 1]\n"
"\n"
"The sorting algorithm will be stable as long as the given function\n"
"returns true for values considered equal:\n"
"\n"
"    iex> Enum.sort [\"some\", \"kind\", \"of\", \"monster\"], "
"&(byte_size(&1) <= byte_size(&2))\n"
"    [\"of\", \"some\", \"kind\", \"monster\"]\n"
"\n"
"If the function does not return true, the sorting is not stable and\n"
"the order of equal terms may be shuffled:\n"
"\n"
"    iex> Enum.sort [\"some\", \"kind\", \"of\", \"monster\"], "
"&(byte_size(&1) < byte_size(&2))\n"
"    [\"of\", \"kind\", \"some\", \"monster\"]\n"
"\n"
msgstr ""
"与えられた関数によってコレクションをソートします。\n"
"\n"
"この関数はマージソートアルゴリズムを使います。与えられた関数はもし最初\n"
"の引数が右の物よりも小さいならばfalseを返さなければなりません。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.sort([1, 2, 3], &(&1 > &2))\n"
"    [3, 2, 1]\n"
"\n"
"ソートアルゴリズムは値が等しいときにtrueを返す関数を与えた場合に限り\n"
"安定です:\n"
"\n"
"    iex> Enum.sort [\"some\", \"kind\", \"of\", \"monster\"], "
"&(byte_size(&1) <= byte_size(&2))\n"
"    [\"of\", \"some\", \"kind\", \"monster\"]\n"
"\n"
"もし関数がtrueを返さない場合、ソートは不安定となり、等しい要素の順番は\n"
"シャッフルされるでしょう:\n"
"\n"
"    iex> Enum.sort [\"some\", \"kind\", \"of\", \"monster\"], "
"&(byte_size(&1) < byte_size(&2))\n"
"    [\"of\", \"kind\", \"some\", \"monster\"]\n"
"\n"

#. TRANSLATORS: def Enum.sort(collection)
#: lib/enum.ex:1701
msgid ""
"Sorts the collection according to Elixir's term ordering.\n"
"\n"
"Uses the merge sort algorithm.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.sort([3, 2, 1])\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
"Elixirのタームの順序でコレクションをソートします。\n"
"\n"
"マージソートアルゴリズムを使います。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.sort([3, 2, 1])\n"
"    [1, 2, 3]\n"
"\n"

#. TRANSLATORS: def File.open(path, modes, function)
#: lib/file.ex:995
msgid ""
"Similar to `open/2` but expects a function as last argument.\n"
"\n"
"The file is opened, given to the function as argument and\n"
"automatically closed after the function returns, regardless\n"
"if there was an error when executing the function.\n"
"\n"
"It returns `{:ok, function_result}` in case of success,\n"
"`{:error, reason}` otherwise.\n"
"\n"
"This function expects the file to be closed with success,\n"
"which is usually the case unless the `:delayed_write` option\n"
"is given. For this reason, we do not recommend passing\n"
"`:delayed_write` to this function.\n"
"\n"
"## Examples\n"
"\n"
"    File.open(\"file.txt\", [:read, :write], fn(file) ->\n"
"      IO.read(file, :line)\n"
"    end)\n"
"\n"
msgstr ""
"`open/2`と似ていますが、最後の引数として関数を期待しています。\n"
"\n"
"ファイルは、オープンされ、関数の引数として与えられ、\n"
"関数が戻った後に自動的にクローズされ、\n"
"関数が実行しているときにエラーがあっても気にしません。\n"
"\n"
"成功すると`{:ok, function_result}`を返し、さもなければ\n"
"`{:error, reason}`を返します。\n"
"\n"
"この関数は、成功で閉じられることを期待します。そしてそれは\n"
"`:delayed_write`オプションが与えられない限り正しいです。この理由からこ\n"
"の関数に`deleyed_write`を指定することを薦めません。\n"
"\n"
"## 例\n"
"\n"
"    File.open(\"file.txt\", [:read, :write], fn(file) ->\n"
"      IO.read(file, :line)\n"
"    end)\n"
"\n"

#. TRANSLATORS: def OptionParser.parse_head(argv, opts \\ [])
#: lib/option_parser.ex:129
msgid ""
"Similar to `parse/2` but only parses the head of `argv`;\n"
"as soon as it finds a non-switch, it stops parsing.\n"
"\n"
"See `parse/2` for more information.\n"
"\n"
"## Example\n"
"\n"
"    iex> OptionParser.parse_head([\"--source\", \"lib\", \"test/enum_test.exs"
"\", \"--verbose\"])\n"
"    {[source: \"lib\"], [\"test/enum_test.exs\", \"--verbose\"], []}\n"
"\n"
"    iex> OptionParser.parse_head([\"--verbose\", \"--source\", \"lib\", "
"\"test/enum_test.exs\", \"--unlock\"])\n"
"    {[verbose: true, source: \"lib\"], [\"test/enum_test.exs\", \"--unlock"
"\"], []}\n"
"\n"
msgstr ""
"`paprser/2`と似ていますが、`argv`の先頭までパースし、\n"
"スイッチでないものを見付けたら、パースを停止します。\n"
"\n"
"より詳細は`parse/2`をみてください。\n"
"\n"
"## 例\n"
"\n"
"    iex> OptionParser.parse_head([\"--source\", \"lib\", \"test/enum_test.exs"
"\", \"--verbose\"])\n"
"    {[source: \"lib\"], [\"test/enum_test.exs\", \"--verbose\"], []}\n"
"\n"
"    iex> OptionParser.parse_head([\"--verbose\", \"--source\", \"lib\", "
"\"test/enum_test.exs\", \"--unlock\"])\n"
"    {[verbose: true, source: \"lib\"], [\"test/enum_test.exs\", \"--unlock"
"\"], []}\n"
"\n"

#. TRANSLATORS: def System.put_env(varname, value)
#: lib/system.ex:294
msgid ""
"Sets an environment variable value.\n"
"\n"
"Sets a new `value` for the environment variable `varname`.\n"
msgstr ""
"環境変数の値をセットします。\n"
"\n"
"環境変数`varname`に新しい`value`をセットします。\n"

#. TRANSLATORS: def Task.start(mod, fun, args)
#: lib/task.ex:142
msgid ""
"Starts a task.\n"
"\n"
"This is only used when the task is used for side-effects\n"
"(i.e. no interest in its return result) and it should not\n"
"be linked to the current process.\n"
msgstr ""
"タスクを開始します。\n"
"\n"
"タスクが副作用(即ち、戻り結果に対する関心がない)のために\n"
"使われるときにのみ使われ、それは現在のプロセスとリンク\n"
"されていてはなりません。\n"

#. TRANSLATORS: def Task.async(fun)
#: lib/task.ex:159
msgid ""
"Starts a task that can be awaited on.\n"
"\n"
"This function spawns a process that is linked to and monitored\n"
"by the caller process. A `Task` struct is returned containing\n"
"the relevant information.\n"
"\n"
"## Task's message format\n"
"\n"
"The reply sent by the task will be in the format `{ref, msg}`,\n"
"where `ref` is the monitoring reference held by the task.\n"
msgstr ""
"待機することができるタスクを開始します。\n"
"\n"
"この関数は、呼び出し側プロセスによりリンクされ、モニタされる、\n"
"プロセスを生成します。関連した情報を含む`Task`構造体が返されます。\n"
"\n"
"## Taskのメッセージフォーマット\n"
"\n"
"タスクによって送られる応答は`{ref, msg}`というフォーマットです。\n"
"`ref`はタスクによって保持されるモニタリファレンスです。\n"

#. TRANSLATORS: def Task.Supervisor.async(supervisor, module, fun, args)
#: lib/task/supervisor.ex:66
msgid ""
"Starts a task that can be awaited on.\n"
"\n"
"The `supervisor` must be a reference as defined in `Task.Supervisor`.\n"
"For more information on tasks, check the `Task` module.\n"
msgstr ""
"待機することができるタスクを開始します。\n"
"\n"
"`supervisor`は、`Task.Supervisor`で定義されたリファレンスでなければなり\n"
"ません。タスクについての詳細は、`Task`モジュールをチェックしてください。\n"

#. TRANSLATORS: def Task.async(mod, fun, args)
#: lib/task.ex:170
msgid ""
"Starts a task that can be awaited on.\n"
"\n"
"Similar to `async/1`, but the task is specified by the given\n"
"module, function and arguments.\n"
msgstr ""
"待機することができるタスクを開始します。\n"
"\n"
"`async/1`と似ていますが、タスクは与えられたモジュール、関数\n"
"および引数により指定されます。\n"

#. TRANSLATORS: def GenServer.start(module, args, options \\ [])
#: lib/gen_server.ex:314
msgid ""
"Starts a `GenServer` process without links (outside of a supervision tree).\n"
"\n"
"See `start_link/3` for more information.\n"
msgstr ""
"リンクなし(監督ツリーの外側)で`GenServer`プロセスを開始します。\n"
"\n"
"詳細は`start_link/3`を参照してください。\n"

#. TRANSLATORS: def Task.start_link(mod, fun, args)
#: lib/task.ex:118
msgid "Starts a task as part of a supervision tree.\n"
msgstr "監督ツリーの一部としてタスクを開始します。\n"

#. TRANSLATORS: def Task.Supervisor.start_child(supervisor, module, fun, args)
#: lib/task/supervisor.ex:110
msgid ""
"Starts a task as child of the given `supervisor`.\n"
"\n"
"Similar to `start_child/2` except the task is specified\n"
"by the given `module`, `fun` and `args`.\n"
msgstr ""
"与えられた`supervisor`の子としてタスクを開始します。\n"
"\n"
"`start_child/2`と似ていますが、タスクは`module`、`fun`と`args`によって\n"
"指定されなければなりません。\n"

#. TRANSLATORS: def Task.Supervisor.start_child(supervisor, fun)
#: lib/task/supervisor.ex:99
msgid ""
"Starts a task as child of the given `supervisor`.\n"
"\n"
"Note that the spawned process is not linked to the caller, but\n"
"only to the supervisor. This command is useful in case the\n"
"task needs to perform side-effects (like I/O) and does not need\n"
"to report back to the caller.\n"
msgstr ""
"与えられた`supervisor`の子としてタスクを開始します。\n"
"\n"
"生成されたプロセスは呼び出し側にリンクされていなく、スーパバイザにのみ\n"
"にリンクされていることに注意してください。このコマンドはタスクが副作用\n"
"(IOのような)を実行する必要があって、呼び出し側に報告を返す必要はない場\n"
"合に役に立ちます。\n"

#. TRANSLATORS: def Supervisor.start_link(children, options)
#: lib/supervisor.ex:204
msgid ""
"Starts a supervisor with the given children.\n"
"\n"
"A strategy is required to be given as an option. Furthermore,\n"
"the `:max_restarts` and `:max_seconds` value can be configured\n"
"as described in `Supervisor.Spec.supervise/2` docs.\n"
"\n"
"The options can also be used to register a supervisor name.\n"
"the supported values are described under the `Name Registration`\n"
"section in the `GenServer` module docs.\n"
"\n"
"If the supervisor and its child processes are successfully created\n"
"(i.e. if the start function of all child processes returns `{:ok, child}`,\n"
"`{:ok, child, info}`, or `:ignore`) the function returns\n"
"`{:ok, pid}`, where `pid` is the pid of the supervisor. If there\n"
"already exists a process with the specified name, the function returns\n"
"`{:error, {:already_started, pid}}`, where pid is the pid of that\n"
"process.\n"
"\n"
"If any of the child process start functions fail or return an error tuple "
"or\n"
"an erroneous value, the supervisor will first terminate all already\n"
"started child processes with reason `:shutdown` and then terminate\n"
"itself and return `{:error, {:shutdown, reason}}`.\n"
"\n"
"Note that the `Supervisor` is linked to the parent process\n"
"and will exit not only on crashes but also if the parent process\n"
"exits with `:normal` reason.\n"
msgstr ""
"与えられた子プロセス仕様でスーパバイザを開始します。\n"
"\n"
"再起動戦略はオプションとして要求されます。さらにまた、\n"
"`:max_restarts`と`:max_seconds`の値は`Supervisor.Spec.supervise/2`の\n"
"ドキュメントで記述されているように構成することができます。\n"
"\n"
"オプションはスーパバイザ名を登録するために使うこともできます。\n"
"`GenServer`モジュールドキュメントの`Name Registration`セクションに\n"
"記述されている値がサポートされています。\n"
"\n"
"もしスーパバイザとその子プロセスがうまく作成された(すなわち、\n"
"全ての子プロセスのスタート関数が`{:ok, chlid}`か、`{:ok, child, info}`\n"
"または、`:ignoreを返したら)ならば、関数は`pid`はスーパバイザの\n"
"プロセス識別子として`{:ok, pid}`を返します。\n"
"もし既に指定された名前のプロセスが存在していたならば、関数は、\n"
"そのプロセスのプロセス識別子をpidとして`{:error, {:already_started, pid}}`\n"
"を返します。\n"
"\n"
"もし子プロセスのどれかのスタート関数が失敗するか、あるいは\n"
"エラータプルあるいは誤った値を返すならば、スーパバイザは\n"
"最初に全ての開始済の子プロセスを`:shutdown` reasonで停止し、それから\n"
"自分自身を停止して`{:error, {:shutdown, reason}}`を返します。\n"
"\n"
"`Supervisor`は親プロセスにリンクされていて、クラッシュするだけではなく\n"
"親プロセスが`:normal` reasonで終了するかもしれないことに気を付けてくだ\n"
"さい。\n"
"\n"

#. TRANSLATORS: def Supervisor.start_link(module, arg, options \\ [])
#: lib/supervisor.ex:230
msgid ""
"Starts a supervisor module with the given `arg`.\n"
"\n"
"To start the supervisor, the `init/1` callback will be invoked\n"
"in the given module. The `init/1` callback must return a\n"
"supervision specification which can be created with the help\n"
"of `Supervisor.Spec` module.\n"
"\n"
"If the `init/1` callback returns `:ignore`, this function returns\n"
"`:ignore` as well and the supervisor terminates with reason `:normal`.\n"
"If it fails or returns an incorrect value, this function returns\n"
"`{:error, term}` where `term` is a term with information about the\n"
"error, and the supervisor terminates with reason `term`.\n"
"\n"
"The `:name` option can also be given in order to register a supervisor\n"
"name, the supported values are described under the `Name Registration`\n"
"section in the `GenServer` module docs.\n"
"\n"
"Other failure conditions are specified in `start_link/2` docs.\n"
msgstr ""
"与えられた引数でスーパバイザモジュールを開始します。\n"
"\n"
"スーパバイザを開始するために、与えられたモジュールの\n"
"`init/1`コールバックが実行されます。`init/1`コールバックは\n"
"`Supervisor.Spec`モジュールの助けで作成できる監督仕様を\n"
"返さなくてはなりません。\n"
"\n"
"もし`init/1`コールバックが`:ignore`を返したら、この関数も\n"
"`:ignore`を返し、スーパバイザは`:normal` reasonで終了します。\n"
"もし`init/`が失敗したり、間違った値を返してきたら、この関数は\n"
"`term`をエラーについての情報として、`{:error, term}`を返し、\n"
"スーパバイザは`term` reasonで終了します。\n"
"\n"
"`:name`オプションはスーパバイザ名を登録するために使うこともできます。\n"
"`GenServer`モジュールドキュメントの`Name Registration`セクションに\n"
"記述されている値がサポートされています。\n"
"\n"
"他の失敗の条件は`start_link/2`のドキュメントに説明されています。\n"

#. TRANSLATORS: def Task.Supervisor.start_link(opts \\ [])
#: lib/task/supervisor.ex:40
msgid ""
"Starts a new supervisor.\n"
"\n"
"The supported options are:\n"
"\n"
"* `:name` - used to register a supervisor name, the supported values are\n"
"  described under the `Name Registration` section in the `GenServer` module\n"
"  docs;\n"
"\n"
"* `:restart` - the restart strategy, may be `:temporary` (the default),\n"
"  `:transient` or `:permanent`. Check `Supervisor.Spec` for more info.\n"
"  Defaults to temporary as most tasks can't be effectively restarted after\n"
"  a crash;\n"
"\n"
"* `:shutdown` - `:brutal_kill` if the tasks must be killed directly on "
"shutdown\n"
"  or an integer indicating the timeout value, defaults to 5000 "
"milliseconds;\n"
"\n"
"* `:max_restarts` and `:max_seconds` - as specified in `Supervisor.Spec."
"supervise/2`;\n"
"\n"
msgstr ""
"新しいスーパバイザを開始します。\n"
"\n"
"サポートされているオプションは以下の通りです:\n"
"\n"
"* `:name` - スーパバイザ名を登録するために使います。\n"
"`GenServer`モジュールドキュメントの`Name Registration`セクションに\n"
"記述されている値がサポートされています;\n"
"\n"
"* `:restart` - リスタート戦略で、`:temporary`(デフォルト)、\n"
"  `:transient`か`:permanent`。 詳細は`Supervisor.Spec`を参照してく\n"
"   ださい。、殆どのタスクは、クラッシュ後、事実上リスタートできない\n"
"   ため、temporaryがデフォルトです;\n"
"\n"
"* `:shutdown` - shutdownもしくは、`:brutal_kill`で指定されたタイムアウト値\n"
"(デフォルト5000ミリ秒)で、タスクが直接殺されなければならないならば、\n"
"指定します;\n"
"\n"
"* `:max_restarts` と `:max_seconds` - `Supervisor.Spec.supervise/2`で\n"
"指定されます;\n"

#. TRANSLATORS: def GenServer.start_link(module, args, options \\ [])
#: lib/gen_server.ex:304
msgid ""
"Starts a `GenServer` process linked to the current process.\n"
"\n"
"This is often used to start the `GenServer` as part of a supervision tree.\n"
"\n"
"Once the server is started, it calls the `init/1` function in the given "
"`module`\n"
"passing the given `args` to initialize it. To ensure a synchronized start-"
"up\n"
"procedure, this function does not return until `init/1` has returned.\n"
"\n"
"Note that a `GenServer` started with `start_link/3` is linked to the\n"
"parent process and will exit in case of crashes. The GenServer will also\n"
"exit due to the `:normal` reasons in case it is configured to trap exits\n"
"in the `init/1` callback.\n"
"\n"
"## Options\n"
"\n"
"The `:name` option is used for name registration as described in the module\n"
"documentation. If the option `:timeout` option is present, the server is\n"
"allowed to spend the given milliseconds initializing or it will be\n"
"terminated and the start function will return `{:error, :timeout}`.\n"
"\n"
"If the `:debug` option is present, the corresponding function in the\n"
"[`:sys` module](http://www.erlang.org/doc/man/sys.html) will be invoked.\n"
"\n"
"If the `:spawn_opt` option is present, its value will be passed as options\n"
"to the underlying process as in `Process.spawn/4`.\n"
"\n"
"## Return values\n"
"\n"
"If the server is successfully created and initialized, the function returns\n"
"`{:ok, pid}`, where pid is the pid of the server. If there already exists a\n"
"process with the specified server name, the function returns\n"
"`{:error, {:already_started, pid}}` with the pid of that process.\n"
"\n"
"If the `init/1` callback fails with `reason`, the function returns\n"
"`{:error, reason}`. Otherwise, if it returns `{:stop, reason}`\n"
"or `:ignore`, the process is terminated and the function returns\n"
"`{:error, reason}` or `:ignore`, respectively.\n"
msgstr ""
"現在のプロセスにリンクされた`GenServer`プロセスを開始します。\n"
"\n"
"これは、しばしば監督ツリーの一部として、`GenServer`を開始するために\n"
"使われます。\n"
"\n"
"一旦サーバが開始したら、与えられたモジュールの`init/1`関数を与えらえた\n"
"引数を伴って初期化の為に呼び出します。スタートアップ手続の同期を\n"
"確実にするために、この関数は`init/1`が帰って来るまで、制御を戻しません。\n"
"\n"
"`start_link/3`で開始した`GenServer`は親プロセスにリンクされていて、\n"
"親プロセスがクラッシュした場合、終了することに注意してください。\n"
"`init/1`コールバックでexitをトラップするように構成されている場合もまた、\n"
"GenServerは`:normal` reasonで終了します。\n"
"\n"
"## オプション\n"
"\n"
"`:name`オプションはモジュールドキュメントで記載されているように、登録の\n"
"為に使われます。`:timeout`オプションがあると、エージェントは、最大初期\n"
"値として与えられたミリセカンド秒間起動に時間をかけることを許可します。\n"
"あるいは、エージェントの起動は終了させられて、スタート関数は`{:error,\n"
":timeout}`を返します。\n"
"\n"
"`:debug`オプションがあると、[`:sys` モジュー\n"
"ル](http://www.erlang.org/doc/man/sys.html) で対応する関数が起動されま\n"
"す。\n"
"\n"
"`:spawn_opt`があると、その値は`Process.spawn/4`のように根底にある\n"
"プロセスまでオプションとして渡されます。\n"
"\n"
"## 戻値\n"
"\n"
"もしサーバがうまく作成されて、初期化されたら、関数は、pidをサーバのプロ\n"
"セス識別子として`{:ok, pid}`を返します。もし与えられた名前でエージェン\n"
"トが既に存在したら、そのプロセスのプロセス識別子をpidとして、関数は\n"
"`{:error, {:already_started, pid}}`を返します。\n"
"\n"
"もし`init/1`コールバックが`reason`で失敗したら、関数は関数は`{:error,\n"
"reason}`を返します。もしくは、`init/1`が`{:stop, reason}`か`:ignore`を\n"
"返したら、プロセスは終了され、関数は`{:error, reason}`か`:ignore`をそれ\n"
"ぞれ返します。\n"

#. TRANSLATORS: def String.chunk(string, trait)
#: lib/string.ex:861
msgid ""
"Splits the string into chunks of characters that share a common trait.\n"
"\n"
"The trait can be one of two options:\n"
"\n"
"  * `:valid` – the string is split into chunks of valid and invalid "
"character\n"
"    sequences\n"
"\n"
"  * `:printable` – the string is split into chunks of printable and\n"
"    non-printable character sequences\n"
"\n"
"Returns a list of binaries each of which contains only one kind of\n"
"characters.\n"
"\n"
"If the given string is empty, an empty list is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.chunk(<<?a, ?b, ?c, 0>>, :valid)\n"
"    [\"abc\\0\"]\n"
"\n"
"    iex> String.chunk(<<?a, ?b, ?c, 0, 0x0ffff::utf8>>, :valid)\n"
"    [\"abc\\0\", <<0x0ffff::utf8>>]\n"
"\n"
"    iex> String.chunk(<<?a, ?b, ?c, 0, 0x0ffff::utf8>>, :printable)\n"
"    [\"abc\", <<0, 0x0ffff::utf8>>]\n"
"\n"
msgstr ""
"文字列を共通するtrait(特質)の文字の塊に分割します。\n"
"\n"
"特質(trait)は二つのオプションのうちひとつを取ることができます:\n"
"\n"
"  * `:valid` - 文字列は文字列として有効か無効かにより塊に分割されます。\n"
"\n"
"  * `:printable` - 文字列は文字列として表示可能か表示不可能かにより\n"
"    塊に分割されます。\n"
"\n"
"それぞれの種類のみを含むバイナリのリストを返します。\n"
"\n"
"与えられた文字列が空なら、空のリストが返されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.chunk(<<?a, ?b, ?c, 0>>, :valid)\n"
"    [\"abc\\0\"]\n"
"\n"
"    iex> String.chunk(<<?a, ?b, ?c, 0, 0x0ffff::utf8>>, :valid)\n"
"    [\"abc\\0\", <<0x0ffff::utf8>>]\n"
"\n"
"    iex> String.chunk(<<?a, ?b, ?c, 0, 0x0ffff::utf8>>, :printable)\n"
"    [\"abc\", <<0, 0x0ffff::utf8>>]\n"
"\n"

#. TRANSLATORS: def Path.split(path)
#: lib/path.ex:510
msgid ""
"Splits the path into a list at the path separator.\n"
"\n"
"If an empty string is given, returns an empty list.\n"
"\n"
"On Windows, path is split on both \"\\\" and \"/\" separators\n"
"and the driver letter, if there is one, is always returned\n"
"in lowercase.\n"
"\n"
"## Examples\n"
"\n"
"     iex> Path.split(\"\")\n"
"     []\n"
"\n"
"     iex> Path.split(\"foo\")\n"
"     [\"foo\"]\n"
"\n"
"     iex> Path.split(\"/foo/bar\")\n"
"     [\"/\", \"foo\", \"bar\"]\n"
"\n"
msgstr ""
"パスをパスセパレータでリストに分割します。\n"
"\n"
"もし空文字列を与えられたら、空リストを返します。\n"
"\n"
"Windowsでは、パスは\"\\\"と\"/\"の両方と、もしあれば、ドライブレターで\n"
"分割されます。そして通常、小文字で返されます。\n"
"\n"
"## 例\n"
"\n"
"     iex> Path.split(\"\")\n"
"     []\n"
"\n"
"     iex> Path.split(\"foo\")\n"
"     [\"foo\"]\n"
"\n"
"     iex> Path.split(\"/foo/bar\")\n"
"     [\"/\", \"foo\", \"bar\"]\n"
"\n"

#. TRANSLATORS: def Regex.split(regex, string, options \\ [])
#: lib/regex.ex:369
msgid ""
"Splits the given target into the number of parts specified.\n"
"\n"
"## Options\n"
"\n"
"  * `:parts` - when specified, splits the string into the given number of\n"
"    parts. If not specified, `:parts` defaults to `:infinity`, which will\n"
"    split the string into the maximum number of parts possible based on the\n"
"    given pattern.\n"
"\n"
"  * `:trim` - when true, remove blank strings from the result.\n"
"\n"
"  * `:on` - specifies which captures and order to split the string\n"
"    on. Check the moduledoc for `Regex` to see the possible capture\n"
"    values. Defaults to `:first` which means captures inside the\n"
"    Regex does not affect the split result.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.split(~r/-/, \"a-b-c\")\n"
"    [\"a\",\"b\",\"c\"]\n"
"\n"
"    iex> Regex.split(~r/-/, \"a-b-c\", [parts: 2])\n"
"    [\"a\",\"b-c\"]\n"
"\n"
"    iex> Regex.split(~r/-/, \"abc\")\n"
"    [\"abc\"]\n"
"\n"
"    iex> Regex.split(~r//, \"abc\")\n"
"    [\"a\", \"b\", \"c\", \"\"]\n"
"\n"
"    iex> Regex.split(~r/a(?<second>b)c/, \"abc\")\n"
"    [\"\", \"\"]\n"
"\n"
"    iex> Regex.split(~r/a(?<second>b)c/, \"abc\", on: [:second])\n"
"    [\"a\", \"c\"]\n"
"\n"
msgstr ""
"与えられたターゲットを指定された数の部分に分割します。\n"
"\n"
"## オプション\n"
"\n"
"  * `:parts` - 指定されたとき、文字列を与えられた数のパーツに分割します。\n"
"    もし指定されてないと、`:parts`のデフォルト値は`:infinity`、つまり、\n"
"    与えられたパターンに基いて、可能な限りの最大の数のパーツに分割されま"
"す。\n"
"\n"
"  * `:trim` - trueの時、結果から空白文字を取り除きます。\n"
"\n"
"  * `:on` - 分割した文字列を捕捉することと、その順番を指定します。\n"
"     可能な値の捕捉については`Regex`モジュールドキュメントをチェック\n"
"     してください。デフォルトは`:first`で、それは、Regexの\n"
"     内部で捕捉することを意味し、分割の結果に影響しません。\n"
"\n"
"## 例\n"
"\n"
"    iex> Regex.split(~r/-/, \"a-b-c\")\n"
"    [\"a\",\"b\",\"c\"]\n"
"\n"
"    iex> Regex.split(~r/-/, \"a-b-c\", [parts: 2])\n"
"    [\"a\",\"b-c\"]\n"
"\n"
"    iex> Regex.split(~r/-/, \"abc\")\n"
"    [\"abc\"]\n"
"\n"
"    iex> Regex.split(~r//, \"abc\")\n"
"    [\"a\", \"b\", \"c\", \"\"]\n"
"\n"
"    iex> Regex.split(~r/a(?<second>b)c/, \"abc\")\n"
"    [\"\", \"\"]\n"
"\n"
"    iex> Regex.split(~r/a(?<second>b)c/, \"abc\", on: [:second])\n"
"    [\"a\", \"c\"]\n"
"\n"

#. TRANSLATORS: def Module.split(module)
#: lib/module.ex:853
msgid ""
"Splits the given module name into binary parts.\n"
"\n"
"## Examples\n"
"\n"
"    Module.split Very.Long.Module.Name.And.Even.Longer\n"
"    #=> [\"Very\", \"Long\", \"Module\", \"Name\", \"And\", \"Even\", "
"\"Longer\"]\n"
"\n"
msgstr ""
"与えられたモジュール名をバイナリの部分に分割します。\n"
"\n"
"## 例\n"
"\n"
"    Module.split Very.Long.Module.Name.And.Even.Longer\n"
"    #=> [\"Very\", \"Long\", \"Module\", \"Name\", \"And\", \"Even\", "
"\"Longer\"]\n"
"\n"

#. TRANSLATORS: def Enum.split(collection, count)
#: lib/enum.ex:1811
msgid ""
"Splits the enumerable into two collections, leaving `count`\n"
"elements in the first one. If `count` is a negative number,\n"
"it starts counting from the back to the beginning of the\n"
"collection.\n"
"\n"
"Be aware that a negative `count` implies the collection\n"
"will be enumerated twice: once to calculate the position, and\n"
"a second time to do the actual splitting.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.split([1, 2, 3], 2)\n"
"    {[1,2], [3]}\n"
"\n"
"    iex> Enum.split([1, 2, 3], 10)\n"
"    {[1,2,3], []}\n"
"\n"
"    iex> Enum.split([1, 2, 3], 0)\n"
"    {[], [1,2,3]}\n"
"\n"
"    iex> Enum.split([1, 2, 3], -1)\n"
"    {[1,2], [3]}\n"
"\n"
"    iex> Enum.split([1, 2, 3], -5)\n"
"    {[], [1,2,3]}\n"
"\n"
msgstr ""
"enumerableを、最初の`count`個の要素とそれ以外の、二つのコレクションに分\n"
"割します。もし`count`が負の数なら、コレクションの最後から最初に向って数\n"
"えます。\n"
"\n"
"負の`count`は、コレクションで2回数え上げられることを意味する\n"
"ということに、注意してください: 一度は位置を計算するために、\n"
"二回目は、実際の分割をするために。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.split([1, 2, 3], 2)\n"
"    {[1,2], [3]}\n"
"\n"
"    iex> Enum.split([1, 2, 3], 10)\n"
"    {[1,2,3], []}\n"
"\n"
"    iex> Enum.split([1, 2, 3], 0)\n"
"    {[], [1,2,3]}\n"
"\n"
"    iex> Enum.split([1, 2, 3], -1)\n"
"    {[1,2], [3]}\n"
"\n"
"    iex> Enum.split([1, 2, 3], -5)\n"
"    {[], [1,2,3]}\n"
"\n"

#. TRANSLATORS: def Enum.group_by(collection, dict \\ %{}, fun)
#: lib/enum.ex:1297
msgid ""
"Splits `collection` into groups based on `fun`.\n"
"\n"
"The result is a dict (by default a map) where each key is\n"
"a group and each value is a list of elements from `collection`\n"
"for which `fun` returned that group. Ordering is not necessarily\n"
"preserved.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.group_by(~w{ant buffalo cat dingo}, &String.length/1)\n"
"    %{3 => [\"cat\", \"ant\"], 7 => [\"buffalo\"], 5 => [\"dingo\"]}\n"
"\n"
msgstr ""
"`collection`を分割して`fun`に基いてグループ化します。\n"
"\n"
"結果は、キーがグループで、値が`fun`が返したグループによる、\n"
"`collection`からの要素のリストとなるdict(デフォルトではマップ)です。\n"
"順序は保存されません。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.group_by(~w{ant buffalo cat dingo}, &String.length/1)\n"
"    %{3 => [\"cat\", \"ant\"], 7 => [\"buffalo\"], 5 => [\"dingo\"]}\n"
"\n"

#. TRANSLATORS: def OptionParser.split(string)
#: lib/option_parser.ex:276
msgid ""
"Splits a string into argv chunks.\n"
"\n"
"## Examples\n"
"\n"
"    iex> OptionParser.split(\"foo bar\")\n"
"    [\"foo\", \"bar\"]\n"
"\n"
"    iex> OptionParser.split(\"foo \\\"bar baz\\\"\")\n"
"    [\"foo\", \"bar baz\"]\n"
msgstr ""
"文字列を引数の塊に分割します。\n"
"\n"
"## 例\n"
"\n"
"    iex> OptionParser.split(\"foo bar\")\n"
"    [\"foo\", \"bar\"]\n"
"\n"
"    iex> OptionParser.split(\"foo \\\"bar baz\\\"\")\n"
"    [\"foo\", \"bar baz\"]\n"

#. TRANSLATORS: def Enum.split_while(collection, fun)
#: lib/enum.ex:1842
msgid ""
"Splits `collection` in two while `fun` returns `true`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.split_while([1, 2, 3, 4], fn(x) -> x < 3 end)\n"
"    {[1, 2], [3, 4]}\n"
"\n"
msgstr ""
"`collection`を`fun`が`true`を返すかどうかで二つに分割します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.split_while([1, 2, 3, 4], fn(x) -> x < 3 end)\n"
"    {[1, 2], [3, 4]}\n"
"\n"

#. TRANSLATORS: def Enum.chunk_by(coll, fun)
#: lib/enum.ex:362
msgid ""
"Splits `coll` on every element for which `fun` returns a new value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.chunk_by([1, 2, 2, 3, 4, 4, 6, 7, 7], &(rem(&1, 2) == 1))\n"
"    [[1], [2, 2], [3], [4, 4, 6], [7, 7]]\n"
"\n"
msgstr ""
"`coll`について、`fun`が新しい値を返すごとに各要素を分割します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.chunk_by([1, 2, 2, 3, 4, 4, 6, 7, 7], &(rem(&1, 2) == 1))\n"
"    [[1], [2, 2], [3], [4, 4, 6], [7, 7]]\n"
"\n"

#. TRANSLATORS: def GenEvent.start(options \\ [])
#: lib/gen_event.ex:262
msgid ""
"Starts an event manager process without links (outside of a supervision "
"tree).\n"
"\n"
"See `start_link/1` for more information.\n"
msgstr ""
"イベントマネージャプロセスをリンクせずに(監督ツリーの外側で)開始します。\n"
"\n"
"詳細は `start_link/1` を参照してください。\n"

#. TRANSLATORS: def GenEvent.start_link(options \\ [])
#: lib/gen_event.ex:252
msgid ""
"Starts an event manager linked to the current process.\n"
"\n"
"This is often used to start the `GenEvent` as part of a supervision tree.\n"
"\n"
"It accepts the `:name` option which is described under the `Name "
"Registration`\n"
"section in the `GenServer` module docs.\n"
"\n"
"If the event manager is successfully created and initialized, the function\n"
"returns `{:ok, pid}`, where pid is the pid of the server. If there already\n"
"exists a process with the specified server name, the function returns\n"
"`{:error, {:already_started, pid}}` with the pid of that process.\n"
"\n"
"Note that a `GenEvent` started with `start_link/1` is linked to the\n"
"parent process and will exit not only on crashes but also if the parent\n"
"process exits with `:normal` reason.\n"
msgstr ""
"イベントマネージャを現在のプロセスにリンクさせて開始します。\n"
"\n"
"これは、しばしば監督ツリーの一部として、`GenEvent`を開始するのに\n"
"使われます。\n"
"\n"
"`:name`オプションを受け付けます。内容は`GenServer`モジュールドキュメン\n"
"トの`Name Registration`セクションに記述されています。\n"
"\n"
"もしイベントマネージャがうまく作成されて、初期化されたら、\n"
"pidをサーバのプロセス識別子として、関数は`{:ok, pid}`を返します。\n"
"もし指定されたサーバの名前で既にプロセスが存在したら、そのプロセスの\n"
"プロセス識別子をpidとして、関数は`{:error, {:already_started, pid}}`\n"
"を返します。\n"
"\n"
"`start_link/1`で開始した`GenEvent`は親プロセスにリンクされていて、\n"
"親プロセスがクラッシュした場合だけでなく、`:normal` reasonで\n"
"終了した場合にも、終了することに注意してください。\n"

#. TRANSLATORS: def Kernel.spawn_monitor(module, fun, args)
#: lib/kernel.ex:695
msgid ""
"Spawns the given module and function passing the given args,\n"
"monitors it and returns its pid and monitoring reference.\n"
"\n"
"Check the modules `Process` and `Node` for other functions\n"
"to handle processes, including spawning functions in nodes.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    spawn_monitor(SomeModule, :function, [1, 2, 3])\n"
"\n"
msgstr ""
"与えられたモジュールと関数に与えられた引数を送ってプロセスを生成し、\n"
"生成したプロセスのpidと、そのプロセスのモニタリファレンスを返します。\n"
"\n"
"他のノードで関数を生成することを含む、プロセスを取り扱う他の関数につい\n"
"ては`Process`と`Node`モジュールをチェックしてください。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    spawn_monitor(SomeModule, :function, [1, 2, 3])\n"
"\n"

#. TRANSLATORS: def Kernel.spawn_link(module, fun, args)
#: lib/kernel.ex:656
msgid ""
"Spawns the given module and function passing the given args,\n"
"links it to the current process and returns its pid.\n"
"\n"
"Check the modules `Process` and `Node` for other functions\n"
"to handle processes, including spawning functions in nodes.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    spawn_link(SomeModule, :function, [1, 2, 3])\n"
"\n"
msgstr ""
"与えられたモジュールと関数に与えられた引数を送ってプロセスを生成し、\n"
"そのプロセスを現在のプロセスにリンクして、生成したプロセスのpidを\n"
"返します。\n"
"\n"
"他のノードで関数を生成することを含む、プロセスを取り扱う他の関数につい\n"
"ては`Process`と`Node`モジュールをチェックしてください。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    spawn_link(SomeModule, :function, [1, 2, 3])\n"
"\n"

#. TRANSLATORS: def Kernel.spawn(module, fun, args)
#: lib/kernel.ex:614
msgid ""
"Spawns the given module and function passing the given args\n"
"and returns its pid.\n"
"\n"
"Check the modules `Process` and `Node` for other functions\n"
"to handle processes, including spawning functions in nodes.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    spawn(SomeModule, :function, [1, 2, 3])\n"
"\n"
msgstr ""
"与えられたモジュールと関数に与えられた引数を送ってプロセスを生成し、\n"
"生成したプロセスのpidを返します。\n"
"\n"
"他のノードで関数を生成することを含む、プロセスを取り扱う他の関数につい\n"
"ては`Process`と`Node`モジュールをチェックしてください。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    spawn(SomeModule, :function, [1, 2, 3])\n"
"\n"

#. TRANSLATORS: def Process.spawn(mod, fun, args, opts)
#: lib/process.ex:193
msgid ""
"Spawns the given module and function passing the given args\n"
"according to the given options.\n"
"\n"
"The result depends on the given options. In particular,\n"
"if `:monitor` is given as an option, it will return a tuple\n"
"containing the pid and the monitoring reference, otherwise\n"
"just the spawned process pid.\n"
"\n"
"It also accepts extra options, for the list of available options\n"
"check http://www.erlang.org/doc/man/erlang.html#spawn_opt-4\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"与えられたオプションによって、与えられたモジュールと関数に与えられた引\n"
"数を送ってプロセスを生成します。\n"
"\n"
"戻値は、与えられたオプションによります。特に、`:monitor`オプションが与\n"
"えられると、pidとモニタリファレンスを含むタプルを返し、さもなければ、生\n"
"成されたプロセスのpidを返します。\n"
"\n"
"\n"
"他のオプションも受け入れます。利用できるオプションのリストについては\n"
"http://www.erlang.org/doc/man/erlang.html#spawn_opt-4 をチェックしてく\n"
"ださい。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.spawn_monitor(fun)
#: lib/kernel.ex:676
msgid ""
"Spawns the given function, monitors it and returns its pid\n"
"and monitoring reference.\n"
"\n"
"Check the modules `Process` and `Node` for other functions\n"
"to handle processes, including spawning functions in nodes.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    current = Kernel.self\n"
"    spawn_monitor(fn -> send current, {Kernel.self, 1 + 2} end)\n"
"\n"
msgstr ""
"与えられた関数のプロセス生成し、生成したプロセスのpidと、そのプロセスの\n"
"モニタリファレンスを返します。\n"
"\n"
"他のノードで関数を生成することを含む、プロセスを取り扱う他の関数につい\n"
"ては`Process`と`Node`モジュールをチェックしてください。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    current = Kernel.self\n"
"    spawn_monitor(fn -> send current, {Kernel.self, 1 + 2} end)\n"
"\n"

#. TRANSLATORS: def Kernel.spawn_link(fun)
#: lib/kernel.ex:637
msgid ""
"Spawns the given function, links it to the current process and returns its "
"pid.\n"
"\n"
"Check the modules `Process` and `Node` for other functions\n"
"to handle processes, including spawning functions in nodes.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    current = Kernel.self\n"
"    child   = spawn_link(fn -> send current, {Kernel.self, 1 + 2} end)\n"
"\n"
"    receive do\n"
"      {^child, 3} -> IO.puts \"Received 3 back\"\n"
"    end\n"
"\n"
msgstr ""
"与えられた関数のプロセスを生成し、そのプロセスを現在のプロセスにリンク\n"
"して、生成したプロセスのpidを返します。\n"
"\n"
"他のノードで関数を生成することを含む、プロセスを取り扱う他の関数につい\n"
"ては`Process`と`Node`モジュールをチェックしてください。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    current = Kernel.self\n"
"    child   = spawn_link(fn -> send current, {Kernel.self, 1 + 2} end)\n"
"\n"
"    receive do\n"
"      {^child, 3} -> IO.puts \"Received 3 back\"\n"
"    end\n"
"\n"

#. TRANSLATORS: def Kernel.spawn(fun)
#: lib/kernel.ex:595
msgid ""
"Spawns the given function and returns its pid.\n"
"\n"
"Check the modules `Process` and `Node` for other functions\n"
"to handle processes, including spawning functions in nodes.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    current = Kernel.self\n"
"    child   = spawn(fn -> send current, {Kernel.self, 1 + 2} end)\n"
"\n"
"    receive do\n"
"      {^child, 3} -> IO.puts \"Received 3 back\"\n"
"    end\n"
"\n"
msgstr ""
"与えられた関数のプロセスを生成し、生成したプロセスのpidを返します。\n"
"\n"
"他のノードで関数を生成することを含む、プロセスを取り扱う他の関数につい\n"
"ては`Process`と`Node`モジュールをチェックしてください。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    current = Kernel.self\n"
"    child   = spawn(fn -> send current, {Kernel.self, 1 + 2} end)\n"
"\n"
"    receive do\n"
"      {^child, 3} -> IO.puts \"Received 3 back\"\n"
"    end\n"
"\n"

#. TRANSLATORS: def String.split_at(string, offset)
#: lib/string.ex:366
msgid ""
"Splits a string into two at the specified offset. When the offset given is\n"
"negative, location is counted from the end of the string.\n"
"\n"
"The offset is capped to the length of the string.\n"
"\n"
"Returns a tuple with two elements.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.split_at \"sweetelixir\", 5\n"
"    {\"sweet\", \"elixir\"}\n"
"\n"
"    iex> String.split_at \"sweetelixir\", -6\n"
"    {\"sweet\", \"elixir\"}\n"
"\n"
"    iex> String.split_at \"abc\", 0\n"
"    {\"\", \"abc\"}\n"
"\n"
"    iex> String.split_at \"abc\", 1000\n"
"    {\"abc\", \"\"}\n"
"\n"
"    iex> String.split_at \"abc\", -1000\n"
"    {\"\", \"abc\"}\n"
"\n"
msgstr ""
"文字列を指定したオフセットで二つに分割します。与えられたオフセットが負\n"
"なら、文字列の終わりから場所を数えます。\n"
"\n"
"オフセットは文字列の長さでキャップされます。\n"
"\n"
"二つの要素のタプルが返されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.split_at \"sweetelixir\", 5\n"
"    {\"sweet\", \"elixir\"}\n"
"\n"
"    iex> String.split_at \"sweetelixir\", -6\n"
"    {\"sweet\", \"elixir\"}\n"
"\n"
"    iex> String.split_at \"abc\", 0\n"
"    {\"\", \"abc\"}\n"
"\n"
"    iex> String.split_at \"abc\", 1000\n"
"    {\"abc\", \"\"}\n"
"\n"
"    iex> String.split_at \"abc\", -1000\n"
"    {\"\", \"abc\"}\n"
"\n"

#. TRANSLATORS: def File.write_stat!(path, stat, opts \\ [])
#: lib/file.ex:349
msgid ""
"Same as `write_stat/3` but raises an exception if it fails.\n"
"Returns `:ok` otherwise.\n"
msgstr ""
"`write_state/3`と同じですが、失敗すると例外を上げます。\n"
"さもなくば`:ok`を返します。\n"

#. TRANSLATORS: def File.write!(path, content, modes \\ [])
#: lib/file.ex:679
msgid ""
"Same as `write/3` but raises an exception if it fails, returns `:ok` "
"otherwise.\n"
msgstr ""
"`write/3`と同じですが、失敗すると例外を上げます。さもなくば`:ok`を\n"
"返します。\n"

#. TRANSLATORS: def File.touch!(path, time \\ :calendar.local_time())
#: lib/file.ex:383
msgid ""
"Same as `touch/2` but raises an exception if it fails.\n"
"Returns `:ok` otherwise.\n"
msgstr ""
"`touch/2`と同じですが、失敗すると例外を上げます。さもなくば\n"
"`:ok`を返します。\n"

#. TRANSLATORS: def File.stat!(path, opts \\ [])
#: lib/file.ex:283
msgid ""
"Same as `stat/2` but returns the `File.Stat` directly and\n"
"throws `File.Error` if an error is returned.\n"
msgstr ""
"`stat/2`と同じですが、もしエラーが帰って来たら`File.Stat`を直接返さず、\n"
"`File.Errorを投げます。\n"

#. TRANSLATORS: def IO.ANSI.yellow()
#: lib/io/ansi.ex:101
msgid "Sets foreground color to yellow"
msgstr "前面色を黄色にセットします。"

#. TRANSLATORS: def IO.ANSI.white()
#: lib/io/ansi.ex:101
msgid "Sets foreground color to white"
msgstr "前面色を白にセットします"

#. TRANSLATORS: def IO.ANSI.red()
#: lib/io/ansi.ex:101
msgid "Sets foreground color to red"
msgstr "前面色を赤にセットします"

#. TRANSLATORS: def IO.ANSI.magenta()
#: lib/io/ansi.ex:101
msgid "Sets foreground color to magenta"
msgstr "前面色をマゼンタにセットします"

#. TRANSLATORS: def IO.ANSI.green()
#: lib/io/ansi.ex:101
msgid "Sets foreground color to green"
msgstr "前面色を緑にセットします"

#. TRANSLATORS: def IO.ANSI.cyan()
#: lib/io/ansi.ex:101
msgid "Sets foreground color to cyan"
msgstr "前面色をシアンにセットします"

#. TRANSLATORS: def IO.ANSI.blue()
#: lib/io/ansi.ex:101
msgid "Sets foreground color to blue"
msgstr "前面色を青にセットします"

#. TRANSLATORS: def IO.ANSI.black()
#: lib/io/ansi.ex:101
msgid "Sets foreground color to black"
msgstr "前面色を黒にセットします"

#. TRANSLATORS: def Code.compiler_options(opts)
#: lib/code.ex:361
msgid ""
"Sets compilation options.\n"
"\n"
"These options are global since they are stored by Elixir's Code Server.\n"
"\n"
"Available options are:\n"
"\n"
"  * `:docs` - when `true`, retain documentation in the compiled module,\n"
"    `true` by default\n"
"\n"
"  * `:debug_info` - when `true`, retain debug information in the compiled\n"
"    module; this allows a developer to reconstruct the original source\n"
"    code, `false` by default\n"
"\n"
"  * `:ignore_module_conflict` - when `true`, override modules that were\n"
"    already defined without raising errors, `false` by default\n"
"\n"
"  * `:warnings_as_errors` - cause compilation to fail when warnings are\n"
"    generated\n"
"\n"
msgstr ""
"コンパイラオプションをセットします。\n"
"\n"
"これらのオプションはElixirコードサーバに保存されるときからグローバルに\n"
"有効になります。\n"
"\n"
"指定できるオプションは以下のとおりです:\n"
"\n"
"  * `:docs` - `true`にすると、コンパイルされたモジュールでドキュメントを\n"
"    保持します。デフォルトは`true`です。\n"
"\n"
"  * `:debug_info` - `true`にすると、コンパイルされたモジュールで\n"
"    デバッグ情報を保持します。これは開発者にオリジナルのソースコードを\n"
"    再構築することを許します。デフォルトは`false`です。\n"
"\n"
"  * `:ignore_module_conflict` - `true`にすると、定義済のモジュールを\n"
"     エラーを引き起すことなしに上書きします。デフォルトは`false`です。\n"
"\n"
"  * `:warnings_as_errors` - 警告が発生したときに、それを原因にコンパイラを\n"
"     失敗させます。\n"
"\n"

#. TRANSLATORS: def Dict.get(dict, key, default \\ nil)
#: lib/dict.ex:364
msgid ""
"Returns the value associated with `key` in `dict`. If `dict` does not\n"
"contain `key`, returns `default` (or `nil` if not provided).\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> Dict.get(dict, :a)\n"
"    1\n"
"    iex> Dict.get(dict, :b)\n"
"    nil\n"
"    iex> Dict.get(dict, :b, 3)\n"
"    3\n"
msgstr ""
"`dict`の`key`に関連付けられた値を返します。もし`dict`が`key`を含んでい\n"
"ない場合、`default`(それも提供されていない場合は`nil`)を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> Dict.get(dict, :a)\n"
"    1\n"
"    iex> Dict.get(dict, :b)\n"
"    nil\n"
"    iex> Dict.get(dict, :b, 3)\n"
"    3\n"

#. TRANSLATORS: def Dict.fetch!(dict, key)
#: lib/dict.ex:398
msgid ""
"Returns the value associated with `key` in `dict`. If `dict` does not\n"
"contain `key`, it raises `KeyError`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> Dict.fetch!(dict, :a)\n"
"    1\n"
"\n"
msgstr ""
"`dict`中の`key`に関連した値を返します。もし`dict`が`key`を含んでいない\n"
"場合、`KeyError`を上げます。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> Dict.fetch!(dict, :a)\n"
"    1\n"
"\n"

#. TRANSLATORS: def Dict.pop(dict, key, default \\ nil)
#: lib/dict.ex:524
msgid ""
"Returns the value associated with `key` in `dict` as\n"
"well as the `dict` without `key`.\n"
"\n"
"If `key` is not present in `dict`, then the `dict` will\n"
"be returned unmodified.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> {v, dict} = Dict.pop dict, :a\n"
"    iex> {v, Enum.sort(dict)}\n"
"    {1,[]}\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> {v, dict} = Dict.pop dict, :b\n"
"    iex> {v, Enum.sort(dict)}\n"
"    {nil,[a: 1]}\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> {v, dict} = Dict.pop dict, :b, 3\n"
"    iex> {v, Enum.sort(dict)}\n"
"    {3,[a: 1]}\n"
"\n"
msgstr ""
"`dict`の中の`key`に関連した値と`key`を取り除いた`dict`を返します。\n"
"\n"
"`key`が`dict`に無いなら、`dict`は変更されずに返されます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> {v, dict} = Dict.pop dict, :a\n"
"    iex> {v, Enum.sort(dict)}\n"
"    {1,[]}\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> {v, dict} = Dict.pop dict, :b\n"
"    iex> {v, Enum.sort(dict)}\n"
"    {nil,[a: 1]}\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> {v, dict} = Dict.pop dict, :b, 3\n"
"    iex> {v, Enum.sort(dict)}\n"
"    {3,[a: 1]}\n"
"\n"

#. TRANSLATORS: def Regex.re_pattern(regex)
#: lib/regex.ex:244
msgid "Returns the underlying `re_pattern` in the regular expression.\n"
msgstr "正規表現で根底にある`re_pattern`を返します。\n"

#. TRANSLATORS: def Enum.sum(collection)
#: lib/enum.ex:1253
msgid ""
"Returns the sum of all values.\n"
"\n"
"Raises `ArithmeticError` if collection contains a non-numeric value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.sum([1, 2, 3])\n"
"    6\n"
"\n"
msgstr ""
"全ての値の和を返します。\n"
"\n"
"もしコレクションが非数値を含んでないなら`ArithmeticError`を上げます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.sum([1, 2, 3])\n"
"    6\n"
"\n"

#. TRANSLATORS: def IO.iodata_length(item)
#: lib/io.ex:389
msgid ""
"Returns the size of an iodata.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> IO.iodata_length([1, 2|<<3, 4>>])\n"
"    4\n"
"\n"
msgstr ""
"iodataのサイズを返します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> IO.iodata_length([1, 2|<<3, 4>>])\n"
"    4\n"
"\n"

#. TRANSLATORS: def Kernel.min(first, second)
#: lib/kernel.ex:485
msgid ""
"Returns the smallest of the two given terms according to\n"
"Erlang's term ordering. If the terms compare equal, the\n"
"first one is returned.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> min(1, 2)\n"
"    1\n"
"\n"
msgstr ""
"与えられた二つのtermのうち、Erlangのtermの順序について、\n"
"小さいほうを返します。termが等しいなら、firstを返します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> min(1, 2)\n"
"    1\n"
"\n"

#. TRANSLATORS: def Kernel.tuple_size(tuple)
#: lib/kernel.ex:743
msgid ""
"Returns the size of a tuple.\n"
"\n"
"This operation happens in constant time.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"タプルのサイズを返します。\n"
"\n"
"このオペレーションは定数時間で実行されます。\n"
"\n"
"ガード中のテストに使うことができます。コンパイラによりインライン化され\n"
"ます。\n"

#. TRANSLATORS: def Kernel.map_size(map)
#: lib/kernel.ex:449
msgid ""
"Returns the size of a map.\n"
"\n"
"This operation happens in constant time.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"マップのサイズを返します。\n"
"\n"
"このオペレーションは定数時間で実行されます。\n"
"\n"
"ガード中のテストに使うことができます。コンパイラによりインライン化され\n"
"ます。\n"

#. TRANSLATORS: def Kernel.self()
#: lib/kernel.ex:572
msgid ""
"Returns the pid (process identifier) of the calling process.\n"
"\n"
"Allowed in guard clauses. Inlined by the compiler.\n"
msgstr ""
"呼び出したプロセスのpid(プロセス識別子)を返します。\n"
"\n"
"ガード節の中で使用できます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Regex.source(regex)
#: lib/regex.ex:258
msgid ""
"Returns the regex source as a binary.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.source(~r(foo))\n"
"    \"foo\"\n"
"\n"
msgstr ""
"正規表現のソースをバイナリとして返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Regex.source(~r(foo))\n"
"    \"foo\"\n"
"\n"

#. TRANSLATORS: def Regex.opts(regex)
#: lib/regex.ex:272
msgid ""
"Returns the regex options as a string.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.opts(~r(foo)m)\n"
"    \"m\"\n"
"\n"
msgstr ""
"正規表現オプションを文字列として返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Regex.opts(~r(foo)m)\n"
"    \"m\"\n"
"\n"

#. TRANSLATORS: def Kernel.trunc(number)
#: lib/kernel.ex:731
msgid ""
"Returns an integer by truncating the given number.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> trunc(5.5)\n"
"    5\n"
"\n"
msgstr ""
"与えられた数をトランケートした整数を返します。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> trunc(5.5)\n"
"    5\n"
"\n"

#. TRANSLATORS: def Kernel.round(number)
#: lib/kernel.ex:542
msgid ""
"Returns an integer by rounding the given number.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> round(5.5)\n"
"    6\n"
"\n"
msgstr ""
"与えられた数を丸めた整数を返します。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> round(5.5)\n"
"    6\n"
"\n"

#. TRANSLATORS: def Kernel.Typespec.beam_types(module)
#: lib/kernel/typespec.ex:427
msgid ""
"Returns all types available from the module's beam code.\n"
"\n"
"The result is returned as a list of tuples where the first\n"
"element is the type (`:typep`, `:type` and `:opaque`).\n"
"\n"
"The module must have a corresponding beam file which can be\n"
"located by the runtime system.\n"
msgstr ""
"モジュールのbeamコードから全ての有効なタイプを返します。\n"
"\n"
"返された結果は、最初の要素がタイプ(`:typep`, `:type`, `:opaque`)となる\n"
"タプルのリストです。\n"
"\n"
"モジュールは実行時システムによって配置された対応するbeamファイルを\n"
"持っていなければなりません。\n"

#. TRANSLATORS: def Kernel.Typespec.beam_typedocs(module)
#: lib/kernel/typespec.ex:407
msgid ""
"Returns all type docs available from the module's beam code.\n"
"\n"
"The result is returned as a list of tuples where the first element is the "
"pair of type\n"
"name and arity and the second element is the documentation.\n"
"\n"
"The module must have a corresponding beam file which can be\n"
"located by the runtime system.\n"
msgstr ""
"モジュールのbeamコードから全ての有効なタイプドキュメントを返します。\n"
"\n"
"返された結果は、最初の要素がタイプの名前とアリティで次の要素がドキュメ\n"
"ントとなる、タプルのリストです。\n"
"\n"
"モジュールは実行時システムによって配置された対応するbeamファイルを\n"
"持っていなければなりません。\n"

#. TRANSLATORS: def Kernel.Typespec.beam_specs(module)
#: lib/kernel/typespec.ex:455
msgid ""
"Returns all specs available from the module's beam code.\n"
"\n"
"The result is returned as a list of tuples where the first\n"
"element is spec name and arity and the second is the spec.\n"
"\n"
"The module must have a corresponding beam file which can be\n"
"located by the runtime system.\n"
msgstr ""
"モジュールのbeamコードから全ての有効なspecを返します。\n"
"\n"
"返された結果は、最初の要素がspecの名前とアリティで次の要素がspec\n"
"となる、タプルのリストです。\n"
"\n"
"モジュールは実行時システムによって配置された対応するbeamファイルを\n"
"持っていなければなりません。\n"

#. TRANSLATORS: def Code.load_file(file, relative_to \\ nil)
#: lib/code.ex:284
msgid ""
"Loads the given file.\n"
"\n"
"Accepts `relative_to` as an argument to tell where the file is located.\n"
"If the file was already required/loaded, loads it again.\n"
"\n"
"It returns a list of tuples `{ModuleName, <<byte_code>>}`, one tuple for\n"
"each module defined in the file.\n"
"\n"
"Notice that if `load_file` is invoked by different processes concurrently,\n"
"the target file will be loaded concurrently many times. Check "
"`require_file/2`\n"
"if you don't want a file to be loaded concurrently.\n"
msgstr ""
"与えられたファイルをロードします。\n"
"\n"
"ファイルの場所を尋ねるための引数として与えられた`relative_to`を受け付け\n"
"ます。\n"
"\n"
"そのファイルに定義されたそれぞれのモジュール毎に1タプルとして、タプル\n"
"`{ModuleName, <<byte_code>>}`のリストを返します。\n"
"\n"
"もし、並行して異なるプロセスにより`load_file`が起動されるなら、ターゲッ\n"
"トファイルは並行して何回もロードされることに、注意してください。一つの\n"
"ファイルを並行してロードしたくないなら、`require_file/2`をチェックして\n"
"ください。\n"

#. TRANSLATORS: def Macro.pipe(expr, call_args, position)
#: lib/macro.ex:76
msgid "Pipes `expr` into the `call_args` at the given `position`.\n"
msgstr "与えられた`position`の`call_args`へ`expr`をパイプします。\n"

#. TRANSLATORS: def Macro.prewalk(ast, fun)
#: lib/macro.ex:154
msgid "Performs a depth-first, pre-order traversal of quoted expressions.\n"
msgstr "quoteされた式の、深さ優先行き掛け順(DFS,pre-order)探索を実行します。\n"

#. TRANSLATORS: def Macro.prewalk(ast, acc, fun)
#: lib/macro.ex:163
msgid ""
"Performs a depth-first, pre-order traversal of quoted expressions\n"
"using an accumulator.\n"
msgstr ""
"quoteされた式をアキュムレータ付きで、深さ優先\n"
"行き掛け順(DFS,pre-order)探索を実行します。\n"

#. TRANSLATORS: def Macro.postwalk(ast, fun)
#: lib/macro.ex:207
msgid "Performs a depth-first, post-order traversal of quoted expressions.\n"
msgstr ""
"quoteされた式の、深さ優先帰り掛け順(DFS,post-order)探索を実行します。\n"

#. TRANSLATORS: def Macro.postwalk(ast, acc, fun)
#: lib/macro.ex:216
msgid ""
"Performs a depth-first, post-order traversal of quoted expressions\n"
"using an accumulator.\n"
msgstr ""
"quoteされた式をアキュムレータ付きで、深さ優先\n"
"帰り掛け順(DFS,post-order)探索を実行します。\n"

#. TRANSLATORS: def System.argv()
#: lib/system.ex:74
msgid ""
"Lists command line arguments.\n"
"\n"
"Returns the list of command line arguments passed to the program.\n"
msgstr ""
"コマンドライン引数のリストです。\n"
"\n"
"プログラムに渡された、コマンドライン引数のリストを返します。\n"

#. TRANSLATORS: def Code.compiler_options()
#: lib/code.ex:327
msgid ""
"Gets the compilation options from the code server.\n"
"\n"
"Check `compiler_options/1` for more information.\n"
msgstr ""
"コンパイラオプションをコードサーバから取得します。\n"
"\n"
"詳細は、`compiler_options/1`をチェックしてください。\n"

#. TRANSLATORS: def IO.inspect(device, item, opts)
#: lib/io.ex:200
msgid "Inspects the item with options using the given device.\n"
msgstr "与えられたデバイスを使い、オプションでアイテムをインスペクトします。\n"

#. TRANSLATORS: def Kernel.inspect(arg, opts \\ [])
#: lib/kernel.ex:1447
msgid ""
"Inspects the given argument according to the `Inspect` protocol.\n"
"The second argument is a keywords list with options to control\n"
"inspection.\n"
"\n"
"## Options\n"
"\n"
"`inspect/2` accepts a list of options that are internally\n"
"translated to an `Inspect.Opts` struct. Check the docs for\n"
"`Inspect.Opts` to see the supported options.\n"
"\n"
"## Examples\n"
"\n"
"    iex> inspect(:foo)\n"
"    \":foo\"\n"
"\n"
"    iex> inspect [1, 2, 3, 4, 5], limit: 3\n"
"    \"[1, 2, 3, ...]\"\n"
"\n"
"    iex> inspect(\"olá\" <> <<0>>)\n"
"    \"<<111, 108, 195, 161, 0>>\"\n"
"\n"
"    iex> inspect(\"olá\" <> <<0>>, binaries: :as_strings)\n"
"    \"\\\"olá\\\\0\\\"\"\n"
"\n"
"    iex> inspect(\"olá\", binaries: :as_binaries)\n"
"    \"<<111, 108, 195, 161>>\"\n"
"\n"
"    iex> inspect('bar')\n"
"    \"'bar'\"\n"
"\n"
"    iex> inspect([0|'bar'])\n"
"    \"[0, 98, 97, 114]\"\n"
"\n"
"    iex> inspect(100, base: :octal)\n"
"    \"0o144\"\n"
"\n"
"    iex> inspect(100, base: :hex)\n"
"    \"0x64\"\n"
"\n"
"Note that the inspect protocol does not necessarily return a valid\n"
"representation of an Elixir term. In such cases, the inspected result\n"
"must start with `#`. For example, inspecting a function will return:\n"
"\n"
"    inspect fn a, b -> a + b end\n"
"    #=> #Function<...>\n"
"\n"
msgstr ""
"`Inspect`プロトコルに従って、与えられた引数でインスペクトします。\n"
"2番目の引数はキーワードリストで、インスペクトを制御するオプションです。\n"
"\n"
"## オプション\n"
"\n"
"`inspect/2`は`Inspect.Opts`構造体に内部的に変換されるオプションの\n"
"リストを受け付けます。サポートするオプションについては、\n"
"`Inspect.Opts`のドキュメントをチェックしてください。\n"
"\n"
"## 例\n"
"\n"
"    iex> inspect(:foo)\n"
"    \":foo\"\n"
"\n"
"    iex> inspect [1, 2, 3, 4, 5], limit: 3\n"
"    \"[1, 2, 3, ...]\"\n"
"\n"
"    iex> inspect(\"olá\" <> <<0>>)\n"
"    \"<<111, 108, 195, 161, 0>>\"\n"
"\n"
"    iex> inspect(\"olá\" <> <<0>>, binaries: :as_strings)\n"
"    \"\\\"olá\\\\0\\\"\"\n"
"\n"
"    iex> inspect(\"olá\", binaries: :as_binaries)\n"
"    \"<<111, 108, 195, 161>>\"\n"
"\n"
"    iex> inspect('bar')\n"
"    \"'bar'\"\n"
"\n"
"    iex> inspect([0|'bar'])\n"
"    \"[0, 98, 97, 114]\"\n"
"\n"
"    iex> inspect(100, base: :octal)\n"
"    \"0o144\"\n"
"\n"
"    iex> inspect(100, base: :hex)\n"
"    \"0x64\"\n"
"\n"
"なお、インスペクトプロトコルは、Elixirタームの有効な表現を返す必要は、\n"
"必ずしもないです。そのような場合、インスペクトされた結果は、`#`から\n"
"始めなければなりません。例えば、関数をインスペクトすると、\n"
"以下のように返されます:\n"
"\n"
"    inspect fn a, b -> a + b end\n"
"    #=> #Function<...>\n"
"\n"

#. TRANSLATORS: def IO.inspect(item, opts \\ [])
#: lib/io.ex:192
msgid ""
"Inspects and writes the given argument to the device.\n"
"\n"
"It enables pretty printing by default with width of\n"
"80 characters. The width can be changed by explicitly\n"
"passing the `:width` option.\n"
"\n"
"## Examples\n"
"\n"
"    IO.inspect Process.list, width: 40\n"
"\n"
msgstr ""
"与えられた引数でデバイスにインスペクトし、書き込みます。\n"
"\n"
"デフォルトで、80文字の幅での、プリティプリンティングを有効にします。\n"
"幅は明示的に`:width`オプションを渡すことで変更できます。\n"
"\n"
"## 例\n"
"\n"
"    IO.inspect Process.list, width: 40\n"
"\n"

#. TRANSLATORS: def Enum.into(collection, list)
#: lib/enum.ex:875
msgid ""
"Inserts the given enumerable into a collectable.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.into([1, 2], [0])\n"
"    [0, 1, 2]\n"
"\n"
"    iex> Enum.into([a: 1, b: 2], %{})\n"
"    %{a: 1, b: 2}\n"
"\n"
msgstr ""
"collectableに与えられたenumerableを挿入します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.into([1, 2], [0])\n"
"    [0, 1, 2]\n"
"\n"
"    iex> Enum.into([a: 1, b: 2], %{})\n"
"    %{a: 1, b: 2}\n"
"\n"

#. TRANSLATORS: def Enum.into(collection, list, transform)
#: lib/enum.ex:902
msgid ""
"Inserts the given enumerable into a collectable\n"
"according to the transformation function.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.into([2, 3], [3], fn x -> x * 3 end)\n"
"    [3, 6, 9]\n"
"\n"
msgstr ""
"変換関数に従って、collectableに与えられたenumerableを挿入します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.into([2, 3], [3], fn x -> x * 3 end)\n"
"    [3, 6, 9]\n"
"\n"

#. TRANSLATORS: def Exception.message(exception)
#: lib/exception.ex:43
msgid "Gets the message for an exception.\n"
msgstr "例外のメッセージを取得します。\n"

#. TRANSLATORS: def File.cwd()
#: lib/file.ex:1046
msgid ""
"Gets the current working directory.\n"
"\n"
"In rare circumstances, this function can fail on Unix. It may happen\n"
"if read permission does not exist for the parent directories of the\n"
"current directory. For this reason, returns `{:ok, cwd}` in case\n"
"of success, `{:error, reason}` otherwise.\n"
msgstr ""
"カレントワーキングディレクトリを返します。\n"
"\n"
"稀な状況では、この関数はUnixで失敗することがあります。カレントディレク\n"
"トリの親ディレクトリの読み込み許可がない場合、それは起きるかもしれませ\n"
"ん。この理由で、成功したら`{:ok, cwd}`(さもなければ`{:error, reason}`)\n"
"が返ります。\n"

#. TRANSLATORS: def Path.expand(path, relative_to)
#: lib/path.ex:165
msgid ""
"Expands the path relative to the path given as the second argument\n"
"expanding any `.` and `..` characters. If the path is already an\n"
"absolute path, `relative_to` is ignored.\n"
"\n"
"Note, that this function treats `path` with a leading `~` as\n"
"an absolute one.\n"
"\n"
"The second argument is first expanded to an absolute path.\n"
"\n"
"## Examples\n"
"\n"
"    # Assuming that the absolute path to baz is /quux/baz\n"
"    Path.expand(\"foo/bar/../bar\", \"baz\")\n"
"    #=> \"/quux/baz/foo/bar\"\n"
"\n"
"    Path.expand(\"foo/bar/../bar\", \"/baz\")\n"
"    \"/baz/foo/bar\"\n"
"    Path.expand(\"/foo/bar/../bar\", \"/baz\")\n"
"    \"/foo/bar\"\n"
"\n"
msgstr ""
"二つめの引数として与えられたパスに相対的なパスを展開します。\n"
"すべての`.`と`..`文字は展開されます。\n"
"もしパスが既に絶対パスなら、`relative_to`は無視されます。\n"
"\n"
"この関数は、`path`先頭の`~`を絶対パスとして扱うことに、\n"
"注意してください。\n"
"\n"
"二つめの引数は最初に絶対パスに展開されます。\n"
"\n"
"## 例\n"
"\n"
"    # この例では、bazの絶対パスは /quux/bazと見做されています。\n"
"    Path.expand(\"foo/bar/../bar\", \"baz\")\n"
"    #=> \"/quux/baz/foo/bar\"\n"
"\n"
"    Path.expand(\"foo/bar/../bar\", \"/baz\")\n"
"    \"/baz/foo/bar\"\n"
"    Path.expand(\"/foo/bar/../bar\", \"/baz\")\n"
"    \"/foo/bar\"\n"
"\n"

#. TRANSLATORS: defmacro Record.extract(name, opts)
#: lib/record.ex:55
msgid ""
"Extracts record information from an Erlang file.\n"
"\n"
"Returns a quoted expression containing the fields as a list\n"
"of tuples. It expects the record name to be an atom and the\n"
"library path to be a string at expansion time.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Record.extract(:file_info, from_lib: \"kernel/include/file.hrl\")\n"
"    [size: :undefined, type: :undefined, access: :undefined, atime: :"
"undefined,\n"
"     mtime: :undefined, ctime: :undefined, mode: :undefined, links: :"
"undefined,\n"
"     major_device: :undefined, minor_device: :undefined, inode: :undefined,\n"
"     uid: :undefined, gid: :undefined]\n"
"\n"
msgstr ""
"Erlangファイルからレコード情報を抽出します。\n"
"\n"
"タプルのリストとしてのフィールドを含む、quoteされた式を返します。レコー\n"
"ド名としてアトムを期待し、ライブラリパスは展開時に文字列として期待しま\n"
"す。\n"
"\n"
"## 例\n"
"\n"
"    iex> Record.extract(:file_info, from_lib: \"kernel/include/file.hrl\")\n"
"    [size: :undefined, type: :undefined, access: :undefined, atime: :"
"undefined,\n"
"     mtime: :undefined, ctime: :undefined, mode: :undefined, links: :"
"undefined,\n"
"     major_device: :undefined, minor_device: :undefined, inode: :undefined,\n"
"     uid: :undefined, gid: :undefined]\n"
"\n"

#. TRANSLATORS: def Protocol.extract_impls(protocol, paths)
#: lib/protocol.ex:178
msgid ""
"Extracts all types implemented for the given protocol from\n"
"the given paths.\n"
"\n"
"The paths can be either a char list or a string. Internally\n"
"they are worked on as char lists, so passing them as lists\n"
"avoid extra conversion.\n"
"\n"
"Does not load any of the implementations.\n"
"\n"
"## Examples\n"
"\n"
"    # Get Elixir's ebin and retrieve all protocols\n"
"    iex> path = :code.lib_dir(:elixir, :ebin)\n"
"    iex> mods = Protocol.extract_impls(Enumerable, [path])\n"
"    iex> List in mods\n"
"    true\n"
"\n"
msgstr ""
"与えられたパスから与えられたプロトコルの為に実装される\n"
"全てのタイプを抽出します。\n"
"\n"
"パスは文字のリストでも文字列でもよいです。内部的には文字のリストとして\n"
"動きますので、リストを渡すと、余分な変換は無視されます。\n"
"\n"
"どんな実装もロードはされません。\n"
"\n"
"## 例\n"
"\n"
"    # Get Elixir's ebin and retrieve all protocols\n"
"    iex> path = :code.lib_dir(:elixir, :ebin)\n"
"    iex> mods = Protocol.extract_impls(Enumerable, [path])\n"
"    iex> List in mods\n"
"    true\n"
"\n"

#. TRANSLATORS: def Protocol.extract_protocols(paths)
#: lib/protocol.ex:148
msgid ""
"Extracts all protocols from the given paths.\n"
"\n"
"The paths can be either a char list or a string. Internally\n"
"they are worked on as char lists, so passing them as lists\n"
"avoid extra conversion.\n"
"\n"
"Does not load any of the protocols.\n"
"\n"
"## Examples\n"
"\n"
"    # Get Elixir's ebin and retrieve all protocols\n"
"    iex> path = :code.lib_dir(:elixir, :ebin)\n"
"    iex> mods = Protocol.extract_protocols([path])\n"
"    iex> Enumerable in mods\n"
"    true\n"
"\n"
msgstr ""
"与えられたパスから全てのプロトコルを抽出します。\n"
"\n"
"パスは文字のリストでも文字列でもよいです。内部的には文字のリストとして\n"
"動きますので、リストを渡すと、余分な変換は無視されます。\n"
"\n"
"どんな実装もロードはされません。\n"
"\n"
"## 例\n"
"\n"
"    # Elixirのebinディレクトリを取得し、全てのプロトコルを取り出します。\n"
"    iex> path = :code.lib_dir(:elixir, :ebin)\n"
"    iex> mods = Protocol.extract_protocols([path])\n"
"    iex> Enumerable in mods\n"
"    true\n"
"\n"

#. TRANSLATORS: def Stream.each(enum, fun)
#: lib/stream.ex:286
msgid ""
"Executes the given function for each item.\n"
"\n"
"Useful for adding side effects (like printing) to a stream.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.each([1, 2, 3], fn(x) -> send self, x end)\n"
"    iex> Enum.to_list(stream)\n"
"    iex> receive do: (x when is_integer(x) -> x)\n"
"    1\n"
"    iex> receive do: (x when is_integer(x) -> x)\n"
"    2\n"
"    iex> receive do: (x when is_integer(x) -> x)\n"
"    3\n"
"\n"
msgstr ""
"それぞれのアテイムについて、与えられた関数を実行します。\n"
"\n"
"ストリームに(プリントするような)副作用を加えるのに役立ちます。\n"
"\n"
"## 例\n"
"\n"
"    iex> stream = Stream.each([1, 2, 3], fn(x) -> send self, x end)\n"
"    iex> Enum.to_list(stream)\n"
"    iex> receive do: (x when is_integer(x) -> x)\n"
"    1\n"
"    iex> receive do: (x when is_integer(x) -> x)\n"
"    2\n"
"    iex> receive do: (x when is_integer(x) -> x)\n"
"    3\n"
"\n"

#. TRANSLATORS: def System.cmd(command, args, opts \\ [])
#: lib/system.ex:433
msgid ""
"Executes the given `command` with `args`.\n"
"\n"
"`command` is expected to be an executable available in PATH\n"
"unless an absolute path is given.\n"
"\n"
"`args` must be a list of strings which are not expanded\n"
"in any way. For example, this means wildcard expansion will\n"
"not happen unless `Path.wildcard/2` is used. On Windows though,\n"
"wildcard expansion is up to the program.\n"
"\n"
"A set of options are also supported and described below.\n"
"\n"
"## Options\n"
"\n"
"  * `:into` - injects the result into the given collectable, defaults to `"
"\"\"`\n"
"  * `:cd` - the directory to run the command in\n"
"  * `:env` - an enumerable of tuples containing environment key-value as "
"binary\n"
"  * `:arg0` - set the command arg0\n"
"  * `:stderr_to_stdout` - redirects stderr to stdout when true\n"
"  * `:parallelism` - when true, the VM will schedule port tasks to improve\n"
"    parallelism in the system. If set to false, the VM will try to perform\n"
"    commands immediately, improving latency at the expense of parallelism.\n"
"    The default can be set on system startup by passing the \"+spp\" "
"argument\n"
"    to `--erl`.\n"
"\n"
"## Error reasons\n"
"\n"
"If invalid arguments are given, `ArgumentError` is raised by\n"
"`System.cmd/3`. `System.cmd/3` also expects a strict set of\n"
"options and will raise if unknown or invalid options are given.\n"
"\n"
"Furthermore, `System.cmd/3` may fail with one of the POSIX reasons\n"
"detailed below:\n"
"\n"
"  * `:system_limit` - all available ports in the Erlang emulator are in use\n"
"\n"
"  * `:enomem` - there was not enough memory to create the port\n"
"\n"
"  * `:eagain` - there are no more available operating system processes\n"
"\n"
"  * `:enametoolong` - the external command given was too long\n"
"\n"
"  * `:emfile` - there are no more available file descriptors\n"
"    (for the operating system process that the Erlang emulator runs in)\n"
"\n"
"  * `:enfile` - the file table is full (for the entire operating system)\n"
"\n"
"  * `:eacces` - the command does not point to an executable file\n"
"\n"
"  * `:enoent` - the command does not point to an existing file\n"
"\n"
"## Shell commands\n"
"\n"
"If you desire to execute a trusted command inside a shell, with pipes,\n"
"redirecting and so on, please check\n"
"[Erlang's :os.cmd/1 function](http://www.erlang.org/doc/man/os.html#cmd-1).\n"
msgstr ""
"与えられた`command`を`args`で実行します。\n"
"\n"
"`command`は、絶対パスを与えられないかぎり、PATHにある、\n"
"有効な実行可能ファイルと期待されます。\n"
"\n"
"`args`は、文字列のリストでなければならず、どのようにも展開されません。\n"
"例えば、これは、ワイルカード展開は`Path.wildcard/2`が使われないかぎり\n"
"起らないことを意味します。しかし、Windowsではワイルドカード\n"
"の展開はプログラム次第です。\n"
"\n"
"サポートされるオプションとその説明は以下の通りです。\n"
"\n"
"## オプション\n"
"\n"
"  * `:into` - 与えられたcollectableに結果を挿入します。デフォルトは`\"\"`で"
"す\n"
"  * `:cd` - コマンドを実行するディレクトリを指定します\n"
"  * `:env` - バイナリの環境変数キーバリュータプルを含むenumerableを指定しま"
"す\n"
"  * `:arg0` - コマンドのarg0を指定します\n"
"  * `:stderr_to_stdout` - trueにすると、stderrをstdoutにリダイレクトします\n"
"  * `:parallelism` - trueにすると、VMはシステムの並行性を改善するために\n"
"    ポートタスクをスケジュールします。もしfalseにすると、VMはコマンドを\n"
"    直ちに実行し、並行性を犠牲にしてレイテンシを改善します。\n"
"    デフォルトは、`--erl`への引数\"+spp\"を渡すことによって、\n"
"    システムスタートアップで設定されます。\n"
"\n"
"## エラー reasons\n"
"\n"
"もし無効な引数が与えられたら、`System.cmd/3`により、`ArgumentError`が上\n"
"ります。`System.cmd/3`は、オプションも正しいもののみを期待していて、不\n"
"明あるいは無効なオプションが与えられたときも、例外が上ります。\n"
"\n"
"更にまた、`System.cmd/3`は、下で詳述されるPOSIX reasonの一つで\n"
"失敗するかもしれません:\n"
"\n"
"  * `:system_limit` - Erlangエミュレータで全ての有効なポートが使われている\n"
"\n"
"  * `:enomem` - ポートを作成するための十分なメモリが無い\n"
"\n"
"  * `:eagain` - これ以上有効なオペレーティングシステムプロセスがない\n"
"\n"
"  * `:enametoolong` - 与えられた外部コマンドが長過ぎた\n"
"\n"
"  * `:emfile` - これ以上有効なファイル記述子が無い\n"
"    (Erlangエミュレータが動作するオペレーティングシステムプロセスで)\n"
"\n"
"  * `:enfile` - フィルテーブルがフル(オペレーティングシステム全体で)\n"
"\n"
"  * `:eacces` - commandが実行可能ファイルを示していない\n"
"\n"
"  * `:enoent` - commandが存在するファイルを示していない\n"
"\n"
"## シェルコマンド\n"
"\n"
"もしシェルの中で信頼されたコマンド、パイプ、リダイレクト、その他\n"
"を実行することを望むなら、\n"
"[Erlang's :os.cmd/1 function](http://www.erlang.org/doc/man/os.html#cmd-1)\n"
"を、チェックしてください。\n"

#. TRANSLATORS: def URI.decode(uri)
#: lib/uri.ex:238
msgid ""
"Percent-unescapes a URI.\n"
"\n"
"## Examples\n"
"\n"
"    iex> URI.decode(\"http%3A%2F%2Felixir-lang.org\")\n"
"    \"http://elixir-lang.org\"\n"
"\n"
msgstr ""
"URIをパーセントアンエスケープします。\n"
"\n"
"## 例\n"
"\n"
"    iex> URI.decode(\"http%3A%2F%2Felixir-lang.org\")\n"
"    \"http://elixir-lang.org\"\n"
"\n"

#. TRANSLATORS: def Code.eval_quoted(quoted, binding \\ [], opts \\ [])
#: lib/code.ex:163
msgid ""
"Evaluates the quoted contents.\n"
"\n"
"See `eval_string/3` for a description of arguments and return values.\n"
"\n"
"## Examples\n"
"\n"
"    iex> contents = quote(do: var!(a) + var!(b))\n"
"    iex> Code.eval_quoted(contents, [a: 1, b: 2], file: __ENV__.file, line: "
"__ENV__.line)\n"
"    {3, [a: 1, b: 2]}\n"
"\n"
"For convenience, you can pass `__ENV__` as the `opts` argument and\n"
"all options will be automatically extracted from the current environment:\n"
"\n"
"    iex> contents = quote(do: var!(a) + var!(b))\n"
"    iex> Code.eval_quoted(contents, [a: 1, b: 2], __ENV__)\n"
"    {3, [a: 1, b: 2]}\n"
"\n"
msgstr ""
"クォートされたコンテンツを評価します。\n"
"\n"
"引数と戻り値の説明は、`eval_string/3`を参照してください。\n"
"\n"
"## 例\n"
"\n"
"    iex> contents = quote(do: var!(a) + var!(b))\n"
"    iex> Code.eval_quoted(contents, [a: 1, b: 2], file: __ENV__.file, line: "
"__ENV__.line)\n"
"    {3, [a: 1, b: 2]}\n"
"\n"
"For convenience, you can pass `__ENV__` as the `opts` argument and\n"
"all options will be automatically extracted from the current environment:\n"
"\n"
"    iex> contents = quote(do: var!(a) + var!(b))\n"
"    iex> Code.eval_quoted(contents, [a: 1, b: 2], __ENV__)\n"
"    {3, [a: 1, b: 2]}\n"
"\n"

#. TRANSLATORS: def Enum.fetch!(collection, n)
#: lib/enum.ex:643
msgid ""
"Finds the element at the given index (zero-based).\n"
"\n"
"Raises `OutOfBoundsError` if the given position\n"
"is outside the range of the collection.\n"
"\n"
"Note this operation takes linear time. In order to access\n"
"the element at index `n`, it will need to traverse `n`\n"
"previous elements.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.fetch!([2, 4, 6], 0)\n"
"    2\n"
"\n"
"    iex> Enum.fetch!([2, 4, 6], 2)\n"
"    6\n"
"\n"
"    iex> Enum.fetch!([2, 4, 6], 4)\n"
"    ** (Enum.OutOfBoundsError) out of bounds error\n"
"\n"
msgstr ""
"与えられた(0始まりの)インデックスの要素を見付けます。\n"
"\n"
"与えられた位置がコレクションの範囲外なら、`OutOfBoundsError`を上げます。\n"
"\n"
"この操作は線形時間がかかることに気を付けてください。\n"
"インデックス`n`の要素へアクセスするために、`n`個の以前の\n"
"要素を渡り歩く必要があります。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.fetch!([2, 4, 6], 0)\n"
"    2\n"
"\n"
"    iex> Enum.fetch!([2, 4, 6], 2)\n"
"    6\n"
"\n"
"    iex> Enum.fetch!([2, 4, 6], 4)\n"
"    ** (Enum.OutOfBoundsError) out of bounds error\n"
"\n"

#. TRANSLATORS: def Enum.filter(collection, fun)
#: lib/enum.ex:661
msgid ""
"Filters the collection, i.e. returns only those elements\n"
"for which `fun` returns `true`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.filter([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    [2]\n"
"\n"
msgstr ""
"コレクションをフィルタします。即ち、`fun`が`true`を返す\n"
"要素のみを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.filter([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    [2]\n"
"\n"

#. TRANSLATORS: def Enum.filter_map(collection, filter, mapper)
#: lib/enum.ex:680
msgid ""
"Filters the collection and maps its values in one pass.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.filter_map([1, 2, 3], fn(x) -> rem(x, 2) == 0 end, &(&1 * 2))\n"
"    [4]\n"
"\n"
msgstr ""
"一度のパスでコレクションをフィルタしてマップします。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.filter_map([1, 2, 3], fn(x) -> rem(x, 2) == 0 end, &(&1 * 2))\n"
"    [4]\n"
"\n"

#. TRANSLATORS: def Exception.format_stacktrace(trace \\ nil)
#: lib/exception.ex:371
msgid ""
"Formats the stacktrace.\n"
"\n"
"A stacktrace must be given as an argument. If not, the stacktrace\n"
"is retrieved from `Process.info/2`.\n"
msgstr ""
"スタックトレースをフォーマットします。\n"
"\n"
"スタックトレースは一つの引数として与えられなければなりません。\n"
"もしそうでないなら、スタックトレースは`Process.info/2`から取得されます。\n"

#. TRANSLATORS: def Exception.format_file_line(file, line)
#: lib/exception.ex:456
msgid ""
"Formats the given file and line as shown in stacktraces.\n"
"If any of the values are nil, they are omitted.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Exception.format_file_line(\"foo\", 1)\n"
"    \"foo:1:\"\n"
"\n"
"    iex> Exception.format_file_line(\"foo\", nil)\n"
"    \"foo:\"\n"
"\n"
"    iex> Exception.format_file_line(nil, nil)\n"
"    \"\"\n"
"\n"
msgstr ""
"与えられたファイルと行番号を、スタックトレースで見えるように\n"
"フォーマットします。\n"
"何れかの値がnilなら、省略されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Exception.format_file_line(\"foo\", 1)\n"
"    \"foo:1:\"\n"
"\n"
"    iex> Exception.format_file_line(\"foo\", nil)\n"
"    \"foo:\"\n"
"\n"
"    iex> Exception.format_file_line(nil, nil)\n"
"    \"\"\n"
"\n"

#. TRANSLATORS: def Exception.format_exit(reason)
#: lib/exception.ex:157
msgid ""
"Formats an exit, returns a string.\n"
"\n"
"Often there are errors/exceptions inside exits. Exits are often\n"
"wrapped by the caller and provide stacktraces too. This function\n"
"formats exits in a way to nicely show the exit reason, caller\n"
"and stacktrace.\n"
msgstr ""
"exitのreasonをフォーマットし、文字列を返します。\n"
"\n"
"しばしばエラーや例外がexitの内部であります。exitはしばしば呼び出し側\n"
"によりラップされ、スタックトレースも提供されます。この関数はexitの\n"
"reason、呼び出し側、スタックトレースを上手く示す方法でフォーマットしま\n"
"す。\n"

#. TRANSLATORS: def IO.ANSI.format(chardata, emit \\ enabled?())
#: lib/io/ansi.ex:157
msgid ""
"Formats a chardata-like argument by converting named ANSI sequences into "
"actual\n"
"ANSI codes.\n"
"\n"
"The named sequences are represented by atoms.\n"
"\n"
"It will also append an `IO.ANSI.reset` to the chardata when a conversion is\n"
"performed. If you don't want this behaviour, use `format_fragment/2`.\n"
"\n"
"An optional boolean parameter can be passed to enable or disable\n"
"emitting actual ANSI codes. When `false`, no ANSI codes will emitted.\n"
"By default checks if ANSI is enabled using the `enabled?/0` function.\n"
"\n"
"## Examples\n"
"\n"
"    iex> IO.ANSI.format([\"Hello, \", :red, :bright, \"world!\"], true)\n"
"    [[[[[[], \"Hello, \"] | \"\\e[31m\"] | \"\\e[1m\"], \"world!\"] | "
"\"\\e[0m\"]\n"
"\n"
msgstr ""
"名前付けられたANSIシーケンスを、実際のANSIコードへ変関することによって、\n"
"文字データライクの引数をフォーマットします。\n"
"\n"
"名前付けられたシーケンスはアトムにより表現されます。\n"
"\n"
"変換が実行されたときに、文字データに`IO.ANSI.reset`を追加することもありま"
"す。\n"
"もしこの振舞いを望まないなら、`format_fragment/2`を使ってください。\n"
"\n"
"実際のANSIコードを発行することを使用可能または使用不可にするために、\n"
"オプションのブーリアンパラメタを渡すこともできます。\n"
"`false`の時、ANSIコードは発行されません。\n"
"デフォルトでは、ANSIが使用可能かどうか`enabled?/0`関数でチェックします。\n"
"\n"
"## 例\n"
"\n"
"    iex> IO.ANSI.format([\"Hello, \", :red, :bright, \"world!\"], true)\n"
"    [[[[[[], \"Hello, \"] | \"\\e[31m\"] | \"\\e[1m\"], \"world!\"] | "
"\"\\e[0m\"]\n"
"\n"

#. TRANSLATORS: def IO.ANSI.format_fragment(chardata, emit \\ enabled?())
#: lib/io/ansi.ex:177
msgid ""
"Formats a chardata-like argument by converting named ANSI sequences into "
"actual\n"
"ANSI codes.\n"
"\n"
"The named sequences are represented by atoms.\n"
"\n"
"An optional boolean parameter can be passed to enable or disable\n"
"emitting actual ANSI codes. When `false`, no ANSI codes will emitted.\n"
"By default checks if ANSI is enabled using the `enabled?/0` function.\n"
"\n"
"## Examples\n"
"\n"
"    iex> IO.ANSI.format_fragment([:bright, 'Word'], true)\n"
"    [[[[[[] | \"\\e[1m\"], 87], 111], 114], 100]\n"
"\n"
msgstr ""
"名前付けられたANSIシーケンスを、実際のANSIコードへ変関することによって、\n"
"文字データライクの引数をフォーマットします。\n"
"\n"
"名前付けられたシーケンスはアトムにより表現されます。\n"
"\n"
"実際のANSIコードを発行することを使用可能または使用不可にするために、\n"
"オプションのブーリアンパラメタを渡すこともできます。\n"
"`false`の時、ANSIコードは発行されません。\n"
"デフォルトでは、ANSIが使用可能かどうか`enabled?/0`関数でチェックします。\n"
"\n"
"## 例\n"
"\n"
"    iex> IO.ANSI.format_fragment([:bright, 'Word'], true)\n"
"    [[[[[[] | \"\\e[1m\"], 87], 111], 114], 100]\n"
"\n"

#. TRANSLATORS: def Module.eval_quoted(module, quoted, binding \\ [], opts \\ [])
#: lib/module.ex:346
msgid ""
"Evaluates the quoted contents in the given module's context.\n"
"\n"
"A list of environment options can also be given as argument.\n"
"See `Code.eval_string/3` for more information.\n"
"\n"
"Raises an error if the module was already compiled.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Foo do\n"
"      contents = quote do: (def sum(a, b), do: a + b)\n"
"      Module.eval_quoted __MODULE__, contents\n"
"    end\n"
"\n"
"    Foo.sum(1, 2) #=> 3\n"
"\n"
"For convenience, you can my pass `__ENV__` as argument and\n"
"all options will be automatically extracted from the environment:\n"
"\n"
"    defmodule Foo do\n"
"      contents = quote do: (def sum(a, b), do: a + b)\n"
"      Module.eval_quoted __MODULE__, contents, [], __ENV__\n"
"    end\n"
"\n"
"    Foo.sum(1, 2) #=> 3\n"
"\n"
msgstr ""
"与えられたモジュールのコンテキストで、quoteされたコンテンツを、評価します。\n"
"\n"
"環境のリストのオプションも引数として与えることができます。\n"
"詳細は、`Code.eval_string/3`を\n"
"参照してください。\n"
"\n"
"もしモジュールがすでにコンパイルされていたら、エラーを上げます。\n"
"\n"
"## 例\n"
"\n"
"    defmodule Foo do\n"
"      contents = quote do: (def sum(a, b), do: a + b)\n"
"      Module.eval_quoted __MODULE__, contents\n"
"    end\n"
"\n"
"    Foo.sum(1, 2) #=> 3\n"
"\n"
"便宜上、引数として`__ENV__`を渡すことができ、その環境から全てのオプショ\n"
"ンが自動的に抽出されます\n"
"\n"
"    defmodule Foo do\n"
"      contents = quote do: (def sum(a, b), do: a + b)\n"
"      Module.eval_quoted __MODULE__, contents, [], __ENV__\n"
"    end\n"
"\n"
"    Foo.sum(1, 2) #=> 3\n"
"\n"

#. TRANSLATORS: def Tuple.insert_at(tuple, index, term)
#: lib/tuple.ex:42
msgid ""
"Inserts an element into a tuple.\n"
"\n"
"Inserts `value` into `tuple` at the given zero-based `index`.\n"
"Raises an `ArgumentError` if `index` is greater than the\n"
"length of `tuple`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> tuple = {:bar, :baz}\n"
"    iex> Tuple.insert_at(tuple, 0, :foo)\n"
"    {:foo, :bar, :baz}\n"
"\n"
msgstr ""
"タプルに要素を挿入します。\n"
"\n"
"与えられた0始まりの`index`の位置へ`value`を`tuple`に挿入します。\n"
"もし`index`が`tuple`の長さより大きいなら、`ArgumentError`を上げます。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> tuple = {:bar, :baz}\n"
"    iex> Tuple.insert_at(tuple, 0, :foo)\n"
"    {:foo, :bar, :baz}\n"
"\n"

#. TRANSLATORS: def IO.ANSI.reverse()
#: lib/io/ansi.ex:69
msgid "Image: Negative. Swap foreground and background"
msgstr "イメージ: 反転。前景色と背景色を入れ替えます"

#. TRANSLATORS: def Inspect.Algebra.space(x, y)
#: lib/inspect/algebra.ex:359
msgid ""
"Inserts a mandatory single space between two document entities.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.space \"Hughes\", \"Wadler\"\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"Hughes\", \" \", \"Wadler\"]\n"
"\n"
msgstr ""
"二つのドキュメントエンティティの間に必須の一つの空白を挿入します。\n"
"\n"
"## 例\n"
"\n"
"    iex> doc = Inspect.Algebra.space \"Hughes\", \"Wadler\"\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"Hughes\", \" \", \"Wadler\"]\n"
"\n"

#. TRANSLATORS: def Inspect.Algebra.line(x, y)
#: lib/inspect/algebra.ex:372
msgid ""
"Inserts a mandatory linebreak between two document entities.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.line \"Hughes\", \"Wadler\"\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"Hughes\", \"\\n\", \"Wadler\"]\n"
"\n"
msgstr ""
"二つのドキュメントエンティティの間に必須の一つの改行を挿入します。\n"
"\n"
"## 例\n"
"\n"
"    iex> doc = Inspect.Algebra.line \"Hughes\", \"Wadler\"\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"Hughes\", \"\\n\", \"Wadler\"]\n"
"\n"

#. TRANSLATORS: def Inspect.Algebra.glue(x, g, y)
#: lib/inspect/algebra.ex:314
msgid ""
"Inserts a break, passed as the second argument, between two docs,\n"
"the first and the third arguments.\n"
msgstr ""
"1番目と3番目の引数で示された二つのドキュメントの間に、2番目の引数として\n"
"パスされたブレークを挿入します。\n"

#. TRANSLATORS: def Inspect.Algebra.glue(x, y)
#: lib/inspect/algebra.ex:307
msgid "Inserts a break between two docs. See `break/1` for more info.\n"
msgstr ""
"二つのドキュメントの間にブレークを挿入します。\n"
"詳細は`break/1`を参照してください。\n"

#. TRANSLATORS: def Keyword.new()
#: lib/keyword.ex:51
msgid "Returns an empty keyword list, i.e. an empty list.\n"
msgstr "空のキーワードリスト、すなわち空のリストを返します。\n"

#. TRANSLATORS: def Kernel.node()
#: lib/kernel.ex:496
msgid ""
"Returns an atom representing the name of the local node.\n"
"If the node is not alive, `:nonode@nohost` is returned instead.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"ローカルノードの名前を表現するアトムを返します。\n"
"もしノードが生きていないなら、`:nonode@nohost`が替わりに返されます。\n"
"\n"
"ガード中のテストで使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.make_ref()
#: lib/kernel.ex:437
msgid ""
"Returns an almost unique reference.\n"
"\n"
"The returned reference will re-occur after approximately 2^82 calls;\n"
"therefore it is unique enough for practical purposes.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    make_ref() #=> #Reference<0.0.0.135>\n"
"\n"
msgstr ""
"ほとんどユニークなリファレンスを返します。\n"
"\n"
"返されたリファレンスはおよそ2^82回の呼び出しの後、再度発生します;\n"
"従ってそれは実際上は十分にユニークです。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    make_ref() #=> #Reference<0.0.0.135>\n"
"\n"

#. TRANSLATORS: def Process.demonitor(monitor_ref, options \\ [])
#: lib/process.ex:221
msgid ""
"If `monitor_ref` is a reference which the calling process\n"
"obtained by calling `monitor/1`, this monitoring is turned off.\n"
"If the monitoring is already turned off, nothing happens.\n"
"\n"
"See http://www.erlang.org/doc/man/erlang.html#demonitor-2 for more info.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"もし`monitor_ref`が`monitor/1`を呼ぶことにより得た参照であるなら、この\n"
"モニタリングはoffにされます。もしモニタリングが既にoffなら、何も起きま\n"
"せん。\n"
"\n"
"詳細は http://www.erlang.org/doc/man/erlang.html#demonitor-2 を参照して\n"
"ください。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.elem(tuple, index)
#: lib/kernel.ex:1083
msgid ""
"Gets the element at the zero-based `index` in `tuple`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Example\n"
"\n"
"    iex> tuple = {:foo, :bar, 3}\n"
"    iex> elem(tuple, 1)\n"
"    :bar\n"
"\n"
msgstr ""
"`tuple`の0始まりの`index`の場所の要素を取得します。\n"
"\n"
"ガードテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> tuple = {:foo, :bar, 3}\n"
"    iex> elem(tuple, 1)\n"
"    :bar\n"
"\n"

#. TRANSLATORS: def Kernel.LexicalTracker.remotes(arg)
#: lib/kernel/lexical_tracker.ex:20
msgid "Returns all remotes linked to in this lexical scope.\n"
msgstr "このレキシカルスコープの中につながる全てのリモートを返します。\n"

#. TRANSLATORS: def Kernel.LexicalTracker.dest(arg)
#: lib/kernel/lexical_tracker.ex:29
msgid ""
"Gets the destination the lexical scope is meant to\n"
"compile to.\n"
msgstr "コンパイルするはずの目的のレキシカルスコープを得ます。\n"

#. TRANSLATORS: def Path.type(name)
#: lib/path.ex:189
msgid ""
"Returns the path type.\n"
"\n"
"## Unix examples\n"
"\n"
"    Path.type(\"/\")                #=> :absolute\n"
"    Path.type(\"/usr/local/bin\")   #=> :absolute\n"
"    Path.type(\"usr/local/bin\")    #=> :relative\n"
"    Path.type(\"../usr/local/bin\") #=> :relative\n"
"    Path.type(\"~/file\")           #=> :relative\n"
"\n"
"## Windows examples\n"
"\n"
"    Path.type(\"D:/usr/local/bin\") #=> :absolute\n"
"    Path.type(\"usr/local/bin\")    #=> :relative\n"
"    Path.type(\"D:bar.ex\")         #=> :volumerelative\n"
"    Path.type(\"/bar/foo.ex\")      #=> :volumerelative\n"
"\n"
msgstr ""
"パスのタイプを返します。\n"
"\n"
"## Unixの例\n"
"\n"
"    Path.type(\"/\")                #=> :absolute\n"
"    Path.type(\"/usr/local/bin\")   #=> :absolute\n"
"    Path.type(\"usr/local/bin\")    #=> :relative\n"
"    Path.type(\"../usr/local/bin\") #=> :relative\n"
"    Path.type(\"~/file\")           #=> :relative\n"
"\n"
"## Windowsの例\n"
"\n"
"    Path.type(\"D:/usr/local/bin\") #=> :absolute\n"
"    Path.type(\"usr/local/bin\")    #=> :relative\n"
"    Path.type(\"D:bar.ex\")         #=> :volumerelative\n"
"    Path.type(\"/bar/foo.ex\")      #=> :volumerelative\n"
"\n"

#. TRANSLATORS: def Keyword.values(keywords)
#: lib/keyword.ex:217
msgid ""
"Returns all values from the keyword list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.values([a: 1, b: 2])\n"
"    [1,2]\n"
"\n"
msgstr ""
"キーワードリストから全ての値を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.values([a: 1, b: 2])\n"
"    [1,2]\n"
"\n"

#. TRANSLATORS: def Module.LocalsTracker.imports_with_dispatch(ref, arg2)
#: lib/module/locals_tracker.ex:54
msgid ""
"Returns all imported modules that had the given\n"
"`{name, arity}` invoked.\n"
msgstr ""
"与えられた`{name, arity}`を呼び出したインポートされたモジュール\n"
"全てを返します。\n"

#. TRANSLATORS: def Module.LocalsTracker.reachable(ref)
#: lib/module/locals_tracker.ex:67
msgid ""
"Returns all locals that are reachable.\n"
"\n"
"By default, all public functions are reachable.\n"
"A private function is only reachable if it has\n"
"a public function that it invokes directly.\n"
msgstr ""
"到達可能な全てのローカルを返します。\n"
"\n"
"デフォルトでは、全ての公開関数は到達可能です。\n"
"プライベート関数は、それをダイレクトに呼び出している\n"
"公開関数があれば到達可能なだけです。\n"

#. TRANSLATORS: def Process.whereis(name)
#: lib/process.ex:298
msgid ""
"Returns the pid or port identifier with the registered name.\n"
"Returns `nil` if the name is not registered.\n"
"\n"
"See http://www.erlang.org/doc/man/erlang.html#whereis-1 for more info.\n"
msgstr ""
"pidまたはnameで登録されたポート識別子を返します。nameが登録されていない\n"
"とき、`nil`を返します。\n"
"\n"
"更なる情報は http://www.erlang.org/doc/man/erlang.html#whereis-1 を参照\n"
"してください。\n"

#. TRANSLATORS: def Process.group_leader()
#: lib/process.ex:306
msgid ""
"Returns the pid of the group leader for the process which evaluates the "
"function.\n"
msgstr "関数を評価しているプロセスのグループリーダのpidを返します。\n"

#. TRANSLATORS: def Node.spawn(node, fun)
#: lib/node.ex:161
msgid ""
"Returns the pid of a new process started by the application of `fun`\n"
"on `node`. If `node` does not exist, a useless pid is returned.\n"
"\n"
"Check http://www.erlang.org/doc/man/erlang.html#spawn-2 for\n"
"the list of available options.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"`node`で`fun`の適用により新しいプロセスを開始してそのpidを返します。\n"
"もし`node`が存在しないなら、返されたpidは役にたちません。\n"
"\n"
"有効なオプションのリストについては\n"
"http://www.erlang.org/doc/man/erlang.html#spawn-2 をチェックしてくださ\n"
"い。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Node.spawn(node, fun, opts)
#: lib/node.ex:176
msgid ""
"Returns the pid of a new process started by the application of `fun`\n"
"on `node`.\n"
"\n"
"If `node` does not exist, a useless pid is returned. Check\n"
"http://www.erlang.org/doc/man/erlang.html#spawn_opt-3 for the list of\n"
"available options.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"`node`で`fun`の適用により新しいプロセスを開始してそのpidを返します。\n"
"\n"
"もし`node`が存在しないなら、返されたpidは役にたちません。有効なオプショ\n"
"ンのリストについては、\n"
"http://www.erlang.org/doc/man/erlang.html#spawn_opt-3 をチェックしてく\n"
"ださい。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Node.spawn(node, module, fun, args, opts)
#: lib/node.ex:206
msgid ""
"Returns the pid of a new process started by the application of\n"
"`module.function(args)` on `node`.\n"
"\n"
"If `node` does not exist, a useless pid is returned. Check\n"
"http://www.erlang.org/doc/man/erlang.html#spawn_opt-5 for the list of\n"
"available options.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"`node`で`module.function(args)`の適用により新しいプロセスを開始してその\n"
"pidを返します。\n"
"\n"
"もし`node`が存在しないなら、返されたpidは役にたちません。有効なオプショ\n"
"ンのリストについては、\n"
"http://www.erlang.org/doc/man/erlang.html#spawn_opt-5 をチェックしてく\n"
"ださい。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Node.spawn(node, module, fun, args)
#: lib/node.ex:191
msgid ""
"Returns the pid of a new process started by the application of\n"
"`module.function(args)` on `node`.\n"
"\n"
"If `node` does not exist, a useless pid is returned. Check\n"
"http://www.erlang.org/doc/man/erlang.html#spawn-4 for the list of\n"
"available options.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"`node`で`module.function(args)`の適用により新しいプロセスを開始してその\n"
"pidを返します。\n"
"\n"
"もし`node`が存在しないなら、返されたpidは役にたちません。有効なオプショ\n"
"ンのリストについては、\n"
"http://www.erlang.org/doc/man/erlang.html#spawn_opt-4 をチェックしてく\n"
"ださい。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Node.spawn_link(node, fun)
#: lib/node.ex:220
msgid ""
"Returns the pid of a new linked process started by the application of `fun` "
"on `node`.\n"
"\n"
"A link is created between the calling process and the new process, "
"atomically.\n"
"If `node` does not exist, a useless pid is returned (and due to the link, an "
"exit\n"
"signal with exit reason `:noconnection` will be received).\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"`node`で`fun`の適用により新しいリンクされたプロセスを開始してそのpidを\n"
"返します。\n"
"\n"
"リンクは呼び出したプロセスと新しいプロセスの間に自動的に作成されます。\n"
"もし`node`が存在しないなら、返されたpidは役にたちません(そしてリンクは\n"
"終了し、終了理由が`:noconnection`のexitシグナルを受信するでしょう)。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Node.spawn_link(node, module, fun, args)
#: lib/node.ex:235
msgid ""
"Returns the pid of a new linked process started by the application of\n"
"`module.function(args)` on `node`.\n"
"\n"
"A link is created between the calling process and the new process, "
"atomically.\n"
"If `node` does not exist, a useless pid is returned (and due to the link, an "
"exit\n"
"signal with exit reason `:noconnection` will be received).\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"`node`で`module.funtion(args)`の適用により新しいリンクされたプロセスを\n"
"開始してそのpidを返します。\n"
"\n"
"リンクは呼び出したプロセスと新しいプロセスの間に自動的に作成されます。\n"
"もし`node`が存在しないなら、返されたpidは役にたちません(そしてリンクは\n"
"終了し、終了理由が`:noconnection`のexitシグナルを受信するでしょう)。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Process.get_keys(value)
#: lib/process.ex:54
msgid "Returns all keys that have the given `value`.\n"
msgstr "与えられた`value`をもつキーを全て返します。\n"

#. TRANSLATORS: def Keyword.keys(keywords)
#: lib/keyword.ex:203
msgid ""
"Returns all keys from the keyword list. \n"
"\n"
"Duplicated keys appear duplicated in the final list of keys.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.keys([a: 1, b: 2])\n"
"    [:a,:b]\n"
"\n"
"    iex> Keyword.keys([a: 1, b: 2, a: 3])\n"
"    [:a,:b,:a]\n"
"\n"
msgstr ""
"キーワードリストから全てのキーを返します。\n"
"\n"
"重複したキーは最終的なキーのリストに重複して現れます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.keys([a: 1, b: 2])\n"
"    [:a,:b]\n"
"\n"
"    iex> Keyword.keys([a: 1, b: 2, a: 3])\n"
"    [:a,:b,:a]\n"
"\n"

#. TRANSLATORS: def Process.get()
#: lib/process.ex:32
msgid "Returns all key-values in the dictionary.\n"
msgstr "プロセス辞書の全てのキー/値の組を全て返します。\n"

#. TRANSLATORS: def URI.encode(str, predicate \\ &(char_unescaped? / 1))
#: lib/uri.ex:196
msgid ""
"Percent-escapes a URI.\n"
"Accepts `predicate` function as an argument to specify if char can be left "
"as is.\n"
"\n"
"## Example\n"
"\n"
"    iex> URI.encode(\"ftp://s-ite.tld/?value=put it+й\")\n"
"    \"ftp://s-ite.tld/?value=put%20it+%D0%B9\"\n"
"\n"
msgstr ""
"URIをパーセントエスケープします。\n"
"文字が現状のまま残されるかどうかを決めるための1引数の`predicate`関数\n"
"を受け付けます。\n"
"\n"
"## 例\n"
"\n"
"    iex> URI.encode(\"ftp://s-ite.tld/?value=put it+й\")\n"
"    \"ftp://s-ite.tld/?value=put%20it+%D0%B9\"\n"
"\n"

#. TRANSLATORS: def Agent.get_and_update(agent, fun, timeout \\ 5000)
#: lib/agent.ex:222
msgid ""
"Gets and updates the agent state in one operation.\n"
"\n"
"The function `fun` is sent to the `agent` which invokes the function\n"
"passing the agent state. The function must return a tuple with two\n"
"elements, the first being the value to return (i.e. the `get` value)\n"
"and the second one is the new state.\n"
"\n"
"A timeout can also be specified (it has a default value of 5000).\n"
msgstr ""
"一つのオペレーションで、エージェントステートを取得して更新します。\n"
"\n"
"`fun`関数は、エージェントステートを渡して実行する`agent`に送られます。\n"
"関数は、最初の要素は返される値(即ち`get`した値)で、二つめの要素は\n"
"新しいステートとなる、二つの要素のタプルを返さなくてはなりません。\n"
"\n"
"タイムアウトも指定することができます(デフォルト値は5000です)。\n"

#. TRANSLATORS: def Agent.get_and_update(agent, module, fun, args, timeout \\ 5000)
#: lib/agent.ex:234
msgid ""
"Gets and updates the agent state in one operation.\n"
"\n"
"Same as `get_and_update/3` but a module, function and args are expected\n"
"instead of an anonymous function. The state is added as first\n"
"argument to the given list of args.\n"
msgstr ""
"一つのオペレーションで、エージェントステートを取得して更新します。\n"
"\n"
"`get_and_update/3`と同じですが、無名関数の替りに、モジュール、関数、そ\n"
"して引数が期待されます。ステートは与えられた引数リストの最初の引数とし\n"
"て追加されます。\n"

#. TRANSLATORS: def Agent.get(agent, fun, timeout \\ 5000)
#: lib/agent.ex:195
msgid ""
"Gets an agent value via the given function.\n"
"\n"
"The function `fun` is sent to the `agent` which invokes the function\n"
"passing the agent state. The result of the function invocation is\n"
"returned.\n"
"\n"
"A timeout can also be specified (it has a default value of 5000).\n"
msgstr ""
"与えられた関数によってエージェントの値を取得します。\n"
"\n"
"`fun`関数は、エージェントステートを渡して実行する`agent`に送られます。\n"
"関数の実行結果が返されます。\n"
"\n"
"タイムアウトも指定することができます(デフォルト値は5000です)。\n"

#. TRANSLATORS: def Agent.get(agent, module, fun, args, timeout \\ 5000)
#: lib/agent.ex:207
msgid ""
"Gets an agent value via the given function.\n"
"\n"
"Same as `get/3` but a module, function and args are expected\n"
"instead of an anonymous function. The state is added as first\n"
"argument to the given list of args.\n"
msgstr ""
"与えられた関数によってエージェントの値を取得します。\n"
"\n"
"`get/3`と同じですが、無名関数の替りに、モジュール、関数、そ\n"
"して引数が期待されます。ステートは与えられた引数リストの最初の引数とし\n"
"て追加されます。\n"

#. TRANSLATORS: def Application.get_all_env(app)
#: lib/application.ex:118
msgid "Returns all key-value pairs for `app`.\n"
msgstr "`app`の環境リストについて全てのキーバリューの組を返します。\n"

#. TRANSLATORS: def Access.get_and_update(container, key, fun)
#: lib/access.ex:44
msgid ""
"Gets a value and updates the given `key` in one pass.\n"
"\n"
"The function must receive the value for the given `key`\n"
"(or `nil` if the key doesn't exist in `container`) and\n"
"the function must return a tuple containing the `get`\n"
"value and the new value to be stored in the `container`.\n"
msgstr ""
"一度のパスで、与えられた`key`の値を取得し、更新します。\n"
"\n"
"関数は、与えられた`key`の値(または、もし`container`にキーが存在しないな\n"
"ら、`nil`)を受け取らなければならず、関数は`get`した値と、`container`に\n"
"保存された新しい値を含むタプルを返さなくてはなりません。\n"

#. TRANSLATORS: def Code.loaded_files()
#: lib/code.ex:12
msgid "Lists all loaded files.\n"
msgstr "全てのロードされたファイルのリストです。\n"

#. TRANSLATORS: def Kernel.get_in(data, keys)
#: lib/kernel.ex:1550
msgid ""
"Gets a value from a nested structure.\n"
"\n"
"Uses the `Access` protocol to traverse the structures\n"
"according to the given `keys`, unless the `key` is a\n"
"function.\n"
"\n"
"If a key is a function, the function will be invoked\n"
"passing three arguments, the operation (`:get`), the\n"
"data to be accessed, and a function to be invoked next.\n"
"\n"
"This means `get_in/2` can be extended to provide\n"
"custom lookups. The downside is that functions cannot be\n"
"stored as keys in the accessed data structures.\n"
"\n"
"## Examples\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> get_in(users, [\"john\", :age])\n"
"    27\n"
"\n"
"In case any of entries in the middle returns `nil`, `nil` will be returned\n"
"as per the Access protocol:\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> get_in(users, [\"unknown\", :age])\n"
"    nil\n"
"\n"
"When one of the keys is a function, the function is invoked.\n"
"In the example below, we use a function to get all the maps\n"
"inside a list:\n"
"\n"
"    iex> users = [%{name: \"john\", age: 27}, %{name: \"meg\", age: 23}]\n"
"    iex> all = fn :get, data, next -> Enum.map(data, next) end\n"
"    iex> get_in(users, [all, :age])\n"
"    [27, 23]\n"
"\n"
"If the previous value before invoking the function is nil,\n"
"the function *will* receive nil as a value and must handle it\n"
"accordingly.\n"
msgstr ""
"ネストした構造から値を取得します。\n"
"\n"
"\n"
"`key`が関数でない限り、与えられた`keys`に従って構造を渡り歩くために、\n"
"`Access`プトロコルを使います。\n"
"\n"
"もしキーが関数なら、関数は、オペレーション(`:get`)、アクセスされるデー\n"
"タ、次に実行される関数の、3個の引数を渡されて実行されます。\n"
"\n"
"この`get_in/2`の手段は、カスタムメイドの検索を提供するために拡張可能です。\n"
"不利な面は、関数がアクセスされたデータ構造のキーとして格納されないという\n"
"ことです。\n"
"\n"
"## 例\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> get_in(users, [\"john\", :age])\n"
"    27\n"
"\n"
"中間のエントリのいずれかが`nil`を返す場合、Accessプロトコルを使うたびに\n"
"`nil`を返します:\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> get_in(users, [\"unknown\", :age])\n"
"    nil\n"
"\n"
"キーの一つが関数のとき、関数は実行されます。\n"
"下の例では、リストの中の全てのマップを取得するために、\n"
"関数を使っています:\n"
"\n"
"    iex> users = [%{name: \"john\", age: 27}, %{name: \"meg\", age: 23}]\n"
"    iex> all = fn :get, data, next -> Enum.map(data, next) end\n"
"    iex> get_in(users, [all, :age])\n"
"    [27, 23]\n"
"\n"
"もし関数を実行する以前の値がnilなら、関数は、値としてnilを受け取る*でしょ\n"
"う*。そしてそれに従って取り扱わなければなりません。\n"

#. TRANSLATORS: def Kernel.get_and_update_in(data, keys, fun)
#: lib/kernel.ex:1657
msgid ""
"Gets a value and updates a nested structure.\n"
"\n"
"It expects a tuple to be returned, containing the value\n"
"retrieved and the update one.\n"
"\n"
"Uses the `Access` protocol to traverse the structures\n"
"according to the given `keys`, unless the `key` is a\n"
"function.\n"
"\n"
"If a key is a function, the function will be invoked\n"
"passing three arguments, the operation (`:get_and_update`),\n"
"the data to be accessed, and a function to be invoked next.\n"
"\n"
"This means `get_and_update_in/3` can be extended to provide\n"
"custom lookups. The downside is that functions cannot be stored\n"
"as keys in the accessed data structures.\n"
"\n"
"## Examples\n"
"\n"
"This function is useful when there is a need to retrieve the current\n"
"value (or something calculated in function of the current value) and\n"
"update it at the same time. For example, it could be used to increase\n"
"the age of a user by one and return the previous age in one pass:\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> get_and_update_in(users, [\"john\", :age], &{&1, &1 + 1})\n"
"    {27, %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}}\n"
"\n"
"When one of the keys is a function, the function is invoked.\n"
"In the example below, we use a function to get and increment all\n"
"ages inside a list:\n"
"\n"
"    iex> users = [%{name: \"john\", age: 27}, %{name: \"meg\", age: 23}]\n"
"    iex> all = fn :get_and_update, data, next ->\n"
"    ...>   Enum.map(data, next) |> :lists.unzip\n"
"    ...> end\n"
"    iex> get_and_update_in(users, [all, :age], &{&1, &1 + 1})\n"
"    {[27, 23], [%{name: \"john\", age: 28}, %{name: \"meg\", age: 24}]}\n"
"\n"
"If the previous value before invoking the function is nil,\n"
"the function *will* receive `nil` as a value and must handle it\n"
"accordingly (be it by failing or providing a sane default).\n"
msgstr ""
"ネストした構造から値を取得し、更新します。\n"
"\n"
"取得した値と、更新した値を含むタプルを返すことが、期待されます。\n"
"\n"
"`keys`が関数でない限り、与えられた`keys`によって\n"
"構造を渡り歩くために、`Access`プロトコルを使います。\n"
"\n"
"もしキーが関数なら、関数は、オペレーション(`:get_and_update`)、アクセス\n"
"されるデータ、次に実行される関数の、3個の引数を渡されて実行されます。\n"
"\n"
"この`get_and_update_in/3`の手段は、カスタムメイドの検索を提供するために\n"
"拡張可能です。不利な面は、関数がアクセスされたデータ構造のキーとして格\n"
"納されないということです。\n"
"\n"
"## 例\n"
"\n"
"この関数は、現在の値(または現在の値で計算される何か)の取得と、更新を同\n"
"時に行いたい場合に、便利です。例えば、ユーザの前の年齢を取得し、年齢を\n"
"増加することを一度に行うために、使うことができます:\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> get_and_update_in(users, [\"john\", :age], &{&1, &1 + 1})\n"
"    {27, %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}}\n"
"\n"
"キーの一つが関数の時、関数が起動されます。\n"
"下の例では、リスト中の全ての年齢を取得し、増加させるために\n"
"関数を使っています:\n"
"\n"
"    iex> users = [%{name: \"john\", age: 27}, %{name: \"meg\", age: 23}]\n"
"    iex> all = fn :get_and_update, data, next ->\n"
"    ...>   Enum.map(data, next) |> List.unzip() |> List.to_tuple()\n"
"    ...> end\n"
"    iex> get_and_update_in(users, [all, :age], &{&1, &1 + 1})\n"
"    {[27, 23], [%{name: \"john\", age: 28}, %{name: \"meg\", age: 24}]}\n"
"\n"
"もし関数を実行する以前の値がnilなら、関数は、値として`nil`を受け取る\n"
"*でしょう*。そしてそれに従って(失敗するか、デフォルトの正しい値を\n"
"提供することによって)取り扱わなければなりません。\n"

#. TRANSLATORS: defmacro Kernel.get_and_update_in(path, fun)
#: lib/kernel.ex:1783
msgid ""
"Gets a value and updates a nested data structure via the given `path`.\n"
"\n"
"This is similar to `get_and_update_in/3`, except the path is extracted\n"
"via a macro rather than passing a list. For example:\n"
"\n"
"    get_and_update_in(opts[:foo][:bar], &{&1, &1 + 1})\n"
"\n"
"Is equivalent to:\n"
"\n"
"    get_and_update_in(opts, [:foo, :bar], &{&1, &1 + 1})\n"
"\n"
"Note that in order for this macro to work, the complete path must always\n"
"be visible by this macro. See the Paths section below.\n"
"\n"
"## Examples\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> get_and_update_in(users[\"john\"].age, &{&1, &1 + 1})\n"
"    {27, %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}}\n"
"\n"
"## Paths\n"
"\n"
"A path may start with a variable, local or remote call, and must be\n"
"followed by one or more:\n"
"\n"
"  * `foo[bar]` - access a field; in case an intermediate field is not\n"
"    present or returns nil, an empty map is used\n"
"\n"
"  * `foo.bar` - access a map/struct field; in case the field is not\n"
"    present, an error is raised\n"
"\n"
"Here are some valid paths:\n"
"\n"
"    users[\"john\"][:age]\n"
"    users[\"john\"].age\n"
"    User.all[\"john\"].age\n"
"    all_users()[\"john\"].age\n"
"\n"
"Here are some invalid ones:\n"
"\n"
"    # Does a remote call after the initial value\n"
"    users[\"john\"].do_something(arg1, arg2)\n"
"\n"
"    # Does not access any field\n"
"    users\n"
"\n"
msgstr ""
"与えられた`path`によってネストしたデータ構造の値を取得、更新します。\n"
"\n"
"pathが、リストを渡しているよりはむしろ、マクロによって抽出される\n"
"こと以外は、`get_and_update_in/3`に似ています。例えば:\n"
"\n"
"    get_and_update_in(opts[:foo][:bar], &{&1, &1 + 1})\n"
"\n"
"は、以下と等しいです:\n"
"\n"
"    get_and_update_in(opts, [:foo, :bar], &{&1, &1 + 1})\n"
"\n"
"このマクロが機能するために、完全なパスが常にこのマクロによって見えてい\n"
"なければならないことに注意してください。以下のパスセクションを参照して\n"
"ください。\n"
"\n"
"## 例\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> get_and_update_in(users[\"john\"].age, &{&1, &1 + 1})\n"
"    {27, %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}}\n"
"\n"
"## パス\n"
"\n"
"パスは変数、ローカルかリモートコールで始まり、以下の一つ以上\n"
"が続かなければなりません:\n"
"\n"
"  * `foo[bar]` - フィールドアクセス; 中間のフィールドが存在しないか、\n"
"                 nilを返す場合、空のマップが使われます\n"
"\n"
"  * `foo.bar` - マップ/構造体フィルドのアクセス; フィールドが存在しない\n"
"                場合、エラーが上ります\n"
"\n"
"これらは正しいパスです:\n"
"\n"
"    users[\"john\"][:age]\n"
"    users[\"john\"].age\n"
"    User.all[\"john\"].age\n"
"    all_users()[\"john\"].age\n"
"\n"
"これらは間違ったパスです:\n"
"\n"
"    # Does a remote call after the initial value\n"
"    users[\"john\"].do_something(arg1, arg2)\n"
"\n"
"    # Does not access any field\n"
"    users\n"
"\n"

#. TRANSLATORS: def Keyword.get_values(keywords, key)
#: lib/keyword.ex:179
msgid ""
"Gets all values for a specific `key`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.get_values([a: 1, a: 2], :a)\n"
"    [1,2]\n"
"\n"
msgstr ""
"特定の`key`の全ての値を取得します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.get_values([a: 1, a: 2], :a)\n"
"    [1,2]\n"
"\n"

#. TRANSLATORS: def IO.getn(prompt, count \\ 1)
#: lib/io.ex:224
msgid ""
"Gets a number of bytes from the io device. If the\n"
"io device is a unicode device, `count` implies\n"
"the number of unicode codepoints to be retrieved.\n"
"Otherwise, `count` is the number of raw bytes to be retrieved.\n"
"It returns:\n"
"\n"
"  * `data` - the input characters\n"
"\n"
"  * `:eof` - end of file was encountered\n"
"\n"
"  * `{:error, reason}` - other (rare) error condition;\n"
"    for instance, `{:error, :estale}` if reading from an\n"
"    NFS volume\n"
msgstr ""
"IOデバイスから幾らかのバイトを取得します。\n"
"もしIOデバイスがunicodeデバイスなら、`count`はunicode\n"
"コードポイントとして取得されることを意味します。\n"
"さもなくば、`count`は取得される生のバイトの数です。\n"
"以下を返します:\n"
"\n"
"  * `data` - 入力された文字列\n"
"\n"
"  * `:eof` - EOF(ファイルの終わり)に遭遇\n"
"\n"
"  * `{:error, reason}` - 他の(希な)エラー条件;\n"
"    例えば、`{:error, :estale}` はNFSボリュームから\n"
"    読み込んでいるときに起きるかもしれません\n"

#. TRANSLATORS: def IO.getn(device, prompt, count)
#: lib/io.ex:241
msgid ""
"Gets a number of bytes from the io device. If the\n"
"io device is a unicode device, `count` implies\n"
"the number of unicode codepoints to be retrieved.\n"
"Otherwise, `count` is the number of raw bytes to be retrieved.\n"
msgstr ""
"IOデバイスから幾らかのバイトを取得します。もし\n"
"もしIOデバイスがunicodeデバイスなら、`count`はunicode\n"
"コードポイントとして取得されることを意味します。\n"
"さもなくば、`count`は取得される生のバイトの数です。\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.try(args)
#: lib/kernel/special_forms.ex:1622
msgid ""
"Evaluates the given expressions and handle any error, exit\n"
"or throw that may have happened.\n"
"\n"
"## Examples\n"
"\n"
"    try do\n"
"      do_something_that_may_fail(some_arg)\n"
"    rescue\n"
"      ArgumentError ->\n"
"        IO.puts \"Invalid argument given\"\n"
"    catch\n"
"      value ->\n"
"        IO.puts \"caught #{value}\"\n"
"    else\n"
"      value ->\n"
"        IO.puts \"Success! The result was #{value}\"\n"
"    after\n"
"      IO.puts \"This is printed regardless if it failed or succeed\"\n"
"    end\n"
"\n"
"The rescue clause is used to handle exceptions, while the catch\n"
"clause can be used to catch thrown values. The else clause can\n"
"be used to control flow based on the result of the expression.\n"
"Catch, rescue and else clauses work based on pattern matching.\n"
"\n"
"Note that calls inside `try` are not tail recursive since the VM\n"
"needs to keep the stacktrace in case an exception happens.\n"
"\n"
"## Rescue clauses\n"
"\n"
"Besides relying on pattern matching, rescue clauses provides some\n"
"conveniences around exceptions that allows one to rescue an\n"
"exception by its name. All the following formats are valid rescue\n"
"expressions:\n"
"\n"
"    try do\n"
"      UndefinedModule.undefined_function\n"
"    rescue\n"
"      UndefinedFunctionError -> nil\n"
"    end\n"
"\n"
"    try do\n"
"      UndefinedModule.undefined_function\n"
"    rescue\n"
"      [UndefinedFunctionError] -> nil\n"
"    end\n"
"\n"
"    # rescue and bind to x\n"
"    try do\n"
"      UndefinedModule.undefined_function\n"
"    rescue\n"
"      x in [UndefinedFunctionError] -> nil\n"
"    end\n"
"\n"
"    # rescue all and bind to x\n"
"    try do\n"
"      UndefinedModule.undefined_function\n"
"    rescue\n"
"      x -> nil\n"
"    end\n"
"\n"
"## Erlang errors\n"
"\n"
"Erlang errors are transformed into Elixir ones during rescue:\n"
"\n"
"    try do\n"
"      :erlang.error(:badarg)\n"
"    rescue\n"
"      ArgumentError -> :ok\n"
"    end\n"
"\n"
"The most common Erlang errors will be transformed into their\n"
"Elixir counter-part. Those which are not will be transformed\n"
"into `ErlangError`:\n"
"\n"
"    try do\n"
"      :erlang.error(:unknown)\n"
"    rescue\n"
"      ErlangError -> :ok\n"
"    end\n"
"\n"
"In fact, ErlangError can be used to rescue any error that is\n"
"not an Elixir error proper. For example, it can be used to rescue\n"
"the earlier `:badarg` error too, prior to transformation:\n"
"\n"
"    try do\n"
"      :erlang.error(:badarg)\n"
"    rescue\n"
"      ErlangError -> :ok\n"
"    end\n"
"\n"
"## Catching throws and exits\n"
"\n"
"The catch clause can be used to catch throws values and exits.\n"
"\n"
"    try do\n"
"      exit(:shutdown)\n"
"    catch\n"
"      :exit, :shutdown -> IO.puts \"Exited with shutdown reason\"\n"
"    end\n"
"\n"
"    try do\n"
"      throw(:sample)\n"
"    catch\n"
"      :throw, :sample ->\n"
"        IO.puts \"sample thrown\"\n"
"    end\n"
"\n"
"catch values also support `:error`, as in Erlang, although it is\n"
"commonly avoided in favor of raise/rescue control mechanisms.\n"
"\n"
"## Else clauses\n"
"\n"
"Else clauses allow the result of the expression to be pattern\n"
"matched on:\n"
"\n"
"    x = 2\n"
"    try do\n"
"      1 / x\n"
"    rescue\n"
"      ArithmeticError ->\n"
"        :infinity\n"
"    else\n"
"      y when y < 1 and y > -1 ->\n"
"        :small\n"
"      _ ->\n"
"        :large\n"
"    end\n"
"\n"
"If an else clause is not present the result of the expression will\n"
"be return, if no exceptions are raised:\n"
"\n"
"    x = 1\n"
"    ^x =\n"
"      try do\n"
"        1 / x\n"
"      rescue\n"
"        ArithmeticError ->\n"
"          :infinity\n"
"      end\n"
"\n"
"However when an else clause is present but the result of the expression\n"
"does not match any of the patterns an exception will be raised. This\n"
"exception will not be caught by a catch or rescue in the same try:\n"
"\n"
"    x = 1\n"
"    try do\n"
"      try do\n"
"        1 / x\n"
"      rescue\n"
"        # The TryClauseError can not be rescued here:\n"
"        TryClauseError ->\n"
"          :error_a\n"
"      else\n"
"        0 ->\n"
"          :small\n"
"      end\n"
"    rescue\n"
"      # The TryClauseError is rescued here:\n"
"      TryClauseError ->\n"
"        :error_b\n"
"    end\n"
"\n"
"Similarly an exception inside an else clause is not caught or rescued\n"
"inside the same try:\n"
"\n"
"    try do\n"
"      try do\n"
"        nil\n"
"      catch\n"
"        # The exit(1) call below can not be caught here:\n"
"        :exit, _ ->\n"
"          :exit_a\n"
"      else\n"
"        _ ->\n"
"          exit(1)\n"
"      end\n"
"    catch\n"
"      # The exit is caught here:\n"
"      :exit, _ ->\n"
"        :exit_b\n"
"    end\n"
"\n"
"This means the VM no longer needs to keep the stacktrace once inside\n"
"an else clause and so tail recursion is possible when using a `try`\n"
"with a tail call as the final call inside an else clause. The same\n"
"is true for rescue and catch clauses.\n"
"\n"
"## Variable handling\n"
"\n"
"Since an expression inside `try` may not have been evaluated\n"
"due to an exception, any variable created inside `try` cannot\n"
"be accessed externally. For instance:\n"
"\n"
"    try do\n"
"      x = 1\n"
"      do_something_that_may_fail(same_arg)\n"
"      :ok\n"
"    catch\n"
"      _, _ -> :failed\n"
"    end\n"
"\n"
"    x #=> unbound variable `x`\n"
"\n"
"In the example above, `x` cannot be accessed since it was defined\n"
"inside the `try` clause. A common practice to address this issue\n"
"is to return the variables defined inside `try`:\n"
"\n"
"    x =\n"
"      try do\n"
"        x = 1\n"
"        do_something_that_may_fail(same_arg)\n"
"        x\n"
"      catch\n"
"        _, _ -> :failed\n"
"      end\n"
"\n"
msgstr ""
"与えられた式を評価し、発生した任意のerror, exit, throwを\n"
"ハンドルします。\n"
"\n"
"## 例\n"
"\n"
"    try do\n"
"      do_something_that_may_fail(some_arg)\n"
"    rescue\n"
"      ArgumentError ->\n"
"        IO.puts \"Invalid argument given\"\n"
"    catch\n"
"      value ->\n"
"        IO.puts \"caught #{value}\"\n"
"    else\n"
"      value ->\n"
"        IO.puts \"Success! The result was #{value}\"\n"
"    after\n"
"      IO.puts \"This is printed regardless if it failed or succeed\"\n"
"    end\n"
"\n"
"rescue節は例外をハンドルするために使われ、catch節は\n"
"投げられた値を捕捉するために使われます。\n"
"else節は式の結果に基いたフロー制御の為に使われます。\n"
"catch, rescue, else節はパターンマッチングに基いて動きます。\n"
"\n"
"`try`の内側の呼び出しは、例外が発生したときに備えて、\n"
"VMがスタックトレースを保持する必要があるため、末尾再帰では\n"
"ないことに、気を付けてください。\n"
"\n"
"## Rescue 節\n"
"\n"
"パターンマッチングに頼る他に、rescue節は\n"
"その名前によって例外をrescueすることを許す、\n"
"例外まわりでいくつかの利便性を提供します。\n"
"下のフォーマットは全て、有効なrescue式です:\n"
"\n"
"    try do\n"
"      UndefinedModule.undefined_function\n"
"    rescue\n"
"      UndefinedFunctionError -> nil\n"
"    end\n"
"\n"
"    try do\n"
"      UndefinedModule.undefined_function\n"
"    rescue\n"
"      [UndefinedFunctionError] -> nil\n"
"    end\n"
"\n"
"    # rescue and bind to x\n"
"    try do\n"
"      UndefinedModule.undefined_function\n"
"    rescue\n"
"      x in [UndefinedFunctionError] -> nil\n"
"    end\n"
"\n"
"    # rescue all and bind to x\n"
"    try do\n"
"      UndefinedModule.undefined_function\n"
"    rescue\n"
"      x -> nil\n"
"    end\n"
"\n"
"## Erlang エラー\n"
"\n"
"Erlangエラーはrescueされる間に、Elixirのフォーマットに変換されます:\n"
"\n"
"    try do\n"
"      :erlang.error(:badarg)\n"
"    rescue\n"
"      ArgumentError -> :ok\n"
"    end\n"
"\n"
"ほとんどの共通的なErlangエラーはElixirの対応するエラーに変換されます。\n"
"それ以外のエラーは`ErlangError`に変換されます:\n"
"\n"
"    try do\n"
"      :erlang.error(:unknown)\n"
"    rescue\n"
"      ErlangError -> :ok\n"
"    end\n"
"\n"
"事実、ErlangErrorは本来のElixirエラーではない、全てのエラーを\n"
"rescueするために使うことができます。例えば、\n"
"変換する前のエラーである`:badarg`エラーをrescueするために\n"
"使うことができます:\n"
"\n"
"    try do\n"
"      :erlang.error(:badarg)\n"
"    rescue\n"
"      ErlangError -> :ok\n"
"    end\n"
"\n"
"## Catching throws and exits\n"
"\n"
"catch節はthrowされた値とexitを捕捉するために使うことができます。\n"
"\n"
"    try do\n"
"      exit(:shutdown)\n"
"    catch\n"
"      :exit, :shutdown -> IO.puts \"Exited with shutdown reason\"\n"
"    end\n"
"\n"
"    try do\n"
"      throw(:sample)\n"
"    catch\n"
"      :throw, :sample ->\n"
"        IO.puts \"sample thrown\"\n"
"    end\n"
"\n"
"捕捉する値は、raise/rescue制御メカニズムを支持して、一般には避けられま\n"
"すが、Erlangでの場合のように`:error`もサポートします。\n"
"\n"
"## Else 節\n"
"\n"
"else 節は式の結果をパターンマッチすることを許します:\n"
"\n"
"    x = 2\n"
"    try do\n"
"      1 / x\n"
"    rescue\n"
"      ArithmeticError ->\n"
"        :infinity\n"
"    else\n"
"      y when y < 1 and y > -1 ->\n"
"        :small\n"
"      _ ->\n"
"        :large\n"
"    end\n"
"\n"
"もしelse節が無いなら、例外が上らなければ、式の結果は返されます:\n"
"\n"
"    x = 1\n"
"    ^x =\n"
"      try do\n"
"        1 / x\n"
"      rescue\n"
"        ArithmeticError ->\n"
"          :infinity\n"
"      end\n"
"\n"
"しかしながら、else節があり、式の結果がどのパターンにもマッチしない場合、\n"
"例外が上ります。\n"
"この例外は、同じtryのcatchやrescueによって捕捉されません:\n"
"\n"
"    x = 1\n"
"    try do\n"
"      try do\n"
"        1 / x\n"
"      rescue\n"
"        # The TryClauseError can not be rescued here:\n"
"        TryClauseError ->\n"
"          :error_a\n"
"      else\n"
"        0 ->\n"
"          :small\n"
"      end\n"
"    rescue\n"
"      # The TryClauseError is rescued here:\n"
"      TryClauseError ->\n"
"        :error_b\n"
"    end\n"
"\n"
"同様に、else節の内側での例外は、同じtryの中でcatchもrescueも\n"
"されません:\n"
"\n"
"    try do\n"
"      try do\n"
"        nil\n"
"      catch\n"
"        # The exit(1) call below can not be caught here:\n"
"        :exit, _ ->\n"
"          :exit_a\n"
"      else\n"
"        _ ->\n"
"          exit(1)\n"
"      end\n"
"    catch\n"
"      # The exit is caught here:\n"
"      :exit, _ ->\n"
"        :exit_b\n"
"    end\n"
"\n"
"これは、else節の内側でVMが最早スタックトレースを保持する必要がないこと\n"
"と、そして、`try`では、else節での最後の呼び出しとなるので、そこで呼び出\n"
"すと、末尾再帰が可能であること、を意味します。\n"
"同じことがrescueとcatch節でも言えます。\n"
"\n"
"## 変数のハンドリング\n"
"\n"
"`try`の内側の式が例外のため評価されなかったかもしれないので、\n"
"`try`の内側で作成された全ての変数は外部からアクセスできません。\n"
"例えば:\n"
"\n"
"    try do\n"
"      x = 1\n"
"      do_something_that_may_fail(same_arg)\n"
"      :ok\n"
"    catch\n"
"      _, _ -> :failed\n"
"    end\n"
"\n"
"    x #=> unbound variable `x`\n"
"\n"
"上の例で、`x`は`try`節の内側で定義されたので、アクセスできません。\n"
"この問題に対処する共通の方法は、`try`の内側で定義された変数を\n"
"返すことです:\n"
"\n"
"    x =\n"
"      try do\n"
"        x = 1\n"
"        do_something_that_may_fail(same_arg)\n"
"        x\n"
"      catch\n"
"        _, _ -> :failed\n"
"      end\n"
"\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.cond(clauses)
#: lib/kernel/special_forms.ex:1401
msgid ""
"Evaluates the expression corresponding to the first clause that\n"
"evaluates to truth value.\n"
"\n"
"Raises an error if all conditions evaluate to to nil or false.\n"
"\n"
"## Examples\n"
"\n"
"    cond do\n"
"      1 + 1 == 1 ->\n"
"        \"This will never match\"\n"
"      2 * 2 != 4 ->\n"
"        \"Nor this\"\n"
"      true ->\n"
"        \"This will\"\n"
"    end\n"
"\n"
msgstr ""
"式の真理値がtrueに一致する最初の節の式を実行します。\n"
"\n"
"もし全ての条件がnilまたはfalseなら、エラーを上げます。\n"
"\n"
"## 例\n"
"\n"
"    cond do\n"
"      1 + 1 == 1 ->\n"
"        \"This will never match\"\n"
"      2 * 2 != 4 ->\n"
"        \"Nor this\"\n"
"      true ->\n"
"        \"This will\"\n"
"    end\n"
"\n"

#. TRANSLATORS: def Macro.var(var, context)
#: lib/macro.ex:146
msgid ""
"Generates an AST node representing the variable given\n"
"by the atoms `var` and `context`.\n"
"\n"
"## Examples\n"
"\n"
"In order to build a variable, a context is expected.\n"
"Most of the times, in order to preserve hygiene, the\n"
"context must be `__MODULE__`:\n"
"\n"
"    iex> Macro.var(:foo, __MODULE__)\n"
"    {:foo, [], __MODULE__}\n"
"\n"
"However, if there is a need to access the user variable,\n"
"nil can be given:\n"
"\n"
"    iex> Macro.var(:foo, nil)\n"
"    {:foo, [], nil}\n"
"\n"
msgstr ""
"アトム`var`と`context`によって与えられた、変数のASTノード表現を\n"
"生成します。\n"
"\n"
"## 例\n"
"\n"
"変数を作るために、contextを使います。\n"
"ほとんどの場合、健全性を保存するために、\n"
"contextは、`__MODULE__`でなくてはなりません:\n"
"\n"
"    iex> Macro.var(:foo, __MODULE__)\n"
"    {:foo, [], __MODULE__}\n"
"\n"
"しかしながら、ユーザ変数にアクセスする必要があるならば、\n"
"nilを与えることができます:\n"
"\n"
"    iex> Macro.var(:foo, nil)\n"
"    {:foo, [], nil}\n"
"\n"

#. TRANSLATORS: Elixir.Exception Summary
#: lib/exception.ex:1
msgid ""
"Functions to format throw/catch/exit and exceptions.\n"
"\n"
"Note that stacktraces in Elixir are updated on throw,\n"
"errors and exits. For example, at any given moment,\n"
"`System.stacktrace` will return the stacktrace for the\n"
"last throw/error/exit that occurred in the current process.\n"
"\n"
"Do not rely on the particular format returned by the `format`\n"
"functions in this module. They may be changed in future releases\n"
"in order to better suit Elixir's tool chain. In other words,\n"
"by using the functions in this module it is guaranteed you will\n"
"format exceptions as in the current Elixir version being used.\n"
msgstr ""
"throw/catch/exitと例外をフォーマットする関数です。\n"
"\n"
"Elixirのスタックトレースは、throw、error, exitで更新されることに、気を\n"
"付けてください。例えば、与えられた任意の瞬間に、`System.stacktrace`は、\n"
"現在のプロセスで最後に起ったthrow/error/exitのスタックトレースを返しま\n"
"す。\n"
"\n"
"このモジュールの`format`関数によって返される特定のフォーマットに\n"
"頼ってはいけません。\n"
"それらは、Elixirのツールチェインによりよく合せるために、\n"
"将来のリリースにおいて変更されるかもしれません。\n"
"言い替えると、このモジュールの関数を用いることによって、\n"
"現在使われているのElixirのバージョンに合せて例外をフォーマット\n"
"することが保証されます。\n"

#. TRANSLATORS: Elixir.Node Summary
#: lib/node.ex:1
msgid ""
"Functions related to VM nodes.\n"
"\n"
"Some of the functions in this module are inlined by the compiler,\n"
"similar to functions in the `Kernel` module and they are explicitly\n"
"marked in their docs as \"inlined by the compiler\". For more information\n"
"about inlined functions, check out the `Kernel` module.\n"
msgstr ""
"VMノードに関連する関数です。\n"
"\n"
"このモジュールの関数のいくつかは、`Kernel`モジュールの関数と同じように、\n"
"コンパイラによりインライン化されます。それらは、明示的に\"コンパイラによ\n"
"りインライン化されます\"とドキュメントに記されます。\n"
"\n"
"インライン化関数についての詳細は、`Kernel`モジュールをチェックしてくだ\n"
"さい。\n"

#. TRANSLATORS: def Node.disconnect(node)
#: lib/node.ex:134
msgid ""
"Forces the disconnection of a node.\n"
"\n"
"This will appear to the `node` as if the local node has crashed.\n"
"This function is mainly used in the Erlang network authentication\n"
"protocols. Returns `true` if disconnection succeeds, otherwise `false`.\n"
"If the local node is not alive, the function returns `:ignored`.\n"
"\n"
"See http://www.erlang.org/doc/man/erlang.html#disconnect_node-1 for more "
"info.\n"
msgstr ""
"ノードの切断を強制します。\n"
"\n"
"これは、ローカルノードがクラッシュしたかのように、`node`に\n"
"表れます。\n"
"この関数は主に、Erlangネットワーク認証プロトコルにおいて使われます。\n"
"切断が成功したら`true`を返し、さもなくば、`false`を返します。\n"
"ローカルノードが生きていないなら、関数は`:ignored`を返します。\n"
"\n"
"詳細は、 http://www.erlang.org/doc/man/erlang.html#disconnect_node-1 \n"
"を参照してください。\n"

#. TRANSLATORS: def Code.eval_string(string, binding \\ [], opts \\ [])
#: lib/code.ex:131
msgid ""
"Evaluates the contents given by `string`.\n"
"\n"
"The `binding` argument is a keyword list of variable bindings.\n"
"The `opts` argument is a keyword list of environment options.\n"
"\n"
"Those options can be:\n"
"\n"
"  * `:file`               - the file to be considered in the evaluation\n"
"  * `:line`               - the line on which the script starts\n"
"  * `:delegate_locals_to` - delegate local calls to the given module,\n"
"                            the default is to not delegate\n"
"\n"
"Additionally, the following scope values can be configured:\n"
"\n"
"  * `:aliases` - a list of tuples with the alias and its target\n"
"\n"
"  * `:requires` - a list of modules required\n"
"\n"
"  * `:functions` - a list of tuples where the first element is a module\n"
"    and the second a list of imported function names and arity; the list\n"
"    of function names and arity must be sorted\n"
"\n"
"  * `:macros` - a list of tuples where the first element is a module\n"
"    and the second a list of imported macro names and arity; the list\n"
"    of function names and arity must be sorted\n"
"\n"
"Notice that setting any of the values above overrides Elixir's default\n"
"values. For example, setting `:requires` to `[]`, will no longer\n"
"automatically require the `Kernel` module; in the same way setting\n"
"`:macros` will no longer auto-import `Kernel` macros like `if`, `case`,\n"
"etc.\n"
"\n"
"Returns a tuple of the form `{value, binding}`,\n"
"where `value` is the value returned from evaluating `string`.\n"
"If an error occurs while evaluating `string` an exception will be raised.\n"
"\n"
"`binding` is a keyword list with the value of all variable bindings\n"
"after evaluating `string`. The binding key is usually an atom, but it\n"
"may be a tuple for variables defined in a different context.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Code.eval_string(\"a + b\", [a: 1, b: 2], file: __ENV__.file, line: "
"__ENV__.line)\n"
"    {3, [a: 1, b: 2]}\n"
"\n"
"    iex> Code.eval_string(\"c = a + b\", [a: 1, b: 2], __ENV__)\n"
"    {3, [a: 1, b: 2, c: 3]}\n"
"\n"
"    iex> Code.eval_string(\"a = a + b\", [a: 1, b: 2])\n"
"    {3, [a: 3, b: 2]}\n"
"\n"
"For convenience, you can pass `__ENV__` as the `opts` argument and\n"
"all imports, requires and aliases defined in the current environment\n"
"will be automatically carried over:\n"
"\n"
"    iex> Code.eval_string(\"a + b\", [a: 1, b: 2], __ENV__)\n"
"    {3, [a: 1, b: 2]}\n"
"\n"
msgstr ""
"`string`によって与えられたコンテンツを評価します。\n"
"\n"
"`binding`引数は変数の束縛のキーワードリストです。\n"
"`opts`引数は環境オプションのキーワードリストです。\n"
"\n"
"オプションは次のとおりです:\n"
"\n"
"  * `:file`               - 評価の間、想定するファイル名を指定します\n"
"  * `:line`               - スクリプトが開始する行番号を指定します\n"
"  * `:delegate_locals_to` - ローカル呼び出しを与えられたモジュールに\n"
"                          移譲します。デフォルトは移譲なしです\n"
"\n"
"加えて、以下のスコープ値も設定できます:\n"
"\n"
"  * `:aliases` - エリアスとそのターゲットのタプルリストです\n"
"\n"
"  * `:requires` - requireするモジュールのリストです\n"
"\n"
"  * `:functions` - 最初の要素がモジュールで、二番目の要素が\n"
"      importされた関数名とアリティのリストとなるタプルのリストです;\n"
"      関数名とアリティのリストはソートされてなければなりません\n"
"\n"
"  * `:macros` - 最初の要素がモジュールで、二番目の要素が\n"
"      importされたマクロ名とアリティのリストとなるタプルのリストです;\n"
"      マクロ名とアリティのリストはソートされてなければなりません\n"
"\n"
"上記の値の設定により、Elixirのデフォルト値を上書きすることに、注意して\n"
"ください。例えば、`:requires`を`[]`に設定すると、もはや`Kernel`モジュー\n"
"ルを自動的にはrequireしません; 同じように、`:macros`を設定すると、もは\n"
"や`if`、`case`等といった`Kernel`マクロは自動importされません。\n"
"\n"
"`{value, binding}`形式のタプルを返します。\n"
"`value`は`string`を評価した戻り値です。もし`string`を評価\n"
"している間にエラーが起きたら、例外が上ります。\n"
"\n"
"`binding`は、`string`を評価した後の全ての変数束縛の値の、\n"
"キーワードリストです。束縛キーは通常アトムですが、\n"
"異るコンテキストで定義された変数を示すタプルであるかもしれません。\n"
"\n"
"## 例\n"
"\n"
"    iex> Code.eval_string(\"a + b\", [a: 1, b: 2], file: __ENV__.file, line: "
"__ENV__.line)\n"
"    {3, [a: 1, b: 2]}\n"
"\n"
"    iex> Code.eval_string(\"c = a + b\", [a: 1, b: 2], __ENV__)\n"
"    {3, [a: 1, b: 2, c: 3]}\n"
"\n"
"    iex> Code.eval_string(\"a = a + b\", [a: 1, b: 2])\n"
"    {3, [a: 3, b: 2]}\n"
"\n"
"便宜上、`opts`引数として`__ENV__`を使うことができます。それは、\n"
"現在の環境で定義された全てのimport、require、aliasを自動的に\n"
"引き継ぎます:\n"
"\n"
"    iex> Code.eval_string(\"a + b\", [a: 1, b: 2], __ENV__)\n"
"    {3, [a: 1, b: 2]}\n"
"\n"

#. TRANSLATORS: def Code.eval_file(file, relative_to \\ nil)
#: lib/code.ex:266
msgid ""
"Evals the given file.\n"
"\n"
"Accepts `relative_to` as an argument to tell where the file is located.\n"
"\n"
"While `load_file` loads a file and returns the loaded modules and their\n"
"byte code, `eval_file` simply evaluates the file contents and returns the\n"
"evaluation result and its bindings.\n"
msgstr ""
"与えられたファイルを評価します。\n"
"\n"
"ファイルが置かれた位置を知らせるための引数として、\n"
"`relative_to`を受け付けます。\n"
"\n"
"`load_file`が、ファイルをロードし、ロードされたモジュールとその\n"
"バイトコードを返す一方、`eval_file`は単にファイルのコンテンツを評価し、\n"
"その評価結果とバインディングを返します。\n"

#. TRANSLATORS: def URI.encode_query(l)
#: lib/uri.ex:85
msgid ""
"Encodes an enumerable into a query string.\n"
"\n"
"Takes an enumerable (containing a sequence of two-item tuples)\n"
"and returns a string of the form \"key1=value1&key2=value2...\" where\n"
"keys and values are URL encoded as per `encode/2`.\n"
"\n"
"Keys and values can be any term that implements the `String.Chars`\n"
"protocol, except lists which are explicitly forbidden.\n"
"\n"
"## Examples\n"
"\n"
"    iex> hd = %{\"foo\" => 1, \"bar\" => 2}\n"
"    iex> URI.encode_query(hd)\n"
"    \"bar=2&foo=1\"\n"
"\n"
msgstr ""
"enumerableをquery stringにエンコードします。\n"
"\n"
"enumerable(2アイテムのタプルのシーケンスを含みます)をとり、\n"
"キーと値がそれぞれ、`encode/2`によりURLエンコードされた、\n"
"フォーム\"key1_value1&key2=value2...\"の文字列を返します。\n"
"\n"
"キーと値は、明確に禁じられているリストを除く、`String.Chars`プロトコル\n"
"を実装した任意のタームが使えます。\n"
"\n"
"## 例\n"
"\n"
"    iex> hd = %{\"foo\" => 1, \"bar\" => 2}\n"
"    iex> URI.encode_query(hd)\n"
"    \"bar=2&foo=1\"\n"
"\n"

#. TRANSLATORS: def URI.encode_www_form(str)
#: lib/uri.ex:209
msgid ""
"Encodes a string as \"x-www-urlencoded\".\n"
"\n"
"## Example\n"
"\n"
"    iex> URI.encode_www_form(\"put: it+й\")\n"
"    \"put%3A+it%2B%D0%B9\"\n"
"\n"
msgstr ""
"\"x-www-urlencoded\"として文字列をエンコードします。\n"
"\n"
"## 例\n"
"\n"
"    iex> URI.encode_www_form(\"put: it+й\")\n"
"    \"put%3A+it%2B%D0%B9\"\n"
"\n"

#. TRANSLATORS: def Version.parse_requirement(string)
#: lib/version.ex:206
msgid ""
"Parses a version requirement string into a `Version.Requirement`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> {:ok, req} = Version.parse_requirement(\"== 2.0.1\")\n"
"    iex> req\n"
"    #Version.Requirement<== 2.0.1>\n"
"\n"
"    iex> Version.parse_requirement(\"== == 2.0.1\")\n"
"    :error\n"
"\n"
msgstr ""
"バージョン要求文字列を`Version.Requirement`にパースします。\n"
"\n"
"## 例\n"
"\n"
"    iex> {:ok, req} = Version.parse_requirement(\"== 2.0.1\")\n"
"    iex> req\n"
"    #Version.Requirement<== 2.0.1>\n"
"\n"
"    iex> Version.parse_requirement(\"== == 2.0.1\")\n"
"    :error\n"
"\n"

#. TRANSLATORS: def Enum.partition(collection, fun)
#: lib/enum.ex:1269
msgid ""
"Partitions `collection` into two collections, where the first one contains "
"elements\n"
"for which `fun` returns a truthy value, and the second one -- for which "
"`fun`\n"
"returns `false` or `nil`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.partition([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    {[2], [1,3]}\n"
"\n"
msgstr ""
"`collection`を二つのコレクションに分割します。最初のものは、`fun`が真を\n"
"返す要素を含み、二つめは`fun`が`false`または`nil`を返すものです。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.partition([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    {[2], [1,3]}\n"
"\n"

#. TRANSLATORS: def URI.parse(uri)
#: lib/uri.ex:311
msgid ""
"Parses a well-formed URI reference into its components.\n"
"\n"
"Note this function expects a well-formed URI and does not perform\n"
"any validation. See the examples section below of how `URI.parse/1`\n"
"can be used to parse a wide range of relative URIs.\n"
"\n"
"This function uses the parsing regular expression as defined\n"
"in the Appendix B of RFC3986.\n"
"\n"
"When a URI is given without a port, the values registered via\n"
"`URI.default_port/1` and `URI.default_port/2` are used.\n"
"\n"
"## Examples\n"
"\n"
"    iex> URI.parse(\"http://elixir-lang.org/\")\n"
"    %URI{scheme: \"http\", path: \"/\", query: nil, fragment: nil,\n"
"         authority: \"elixir-lang.org\", userinfo: nil,\n"
"         host: \"elixir-lang.org\", port: 80}\n"
"\n"
"    iex> URI.parse(\"//elixir-lang.org/\")\n"
"    %URI{authority: \"elixir-lang.org\", fragment: nil, host: \"elixir-lang."
"org\",\n"
"         path: \"/\", port: nil, query: nil, scheme: nil, userinfo: nil}\n"
"\n"
"    iex> URI.parse(\"/foo/bar\")\n"
"    %URI{authority: nil, fragment: nil, host: nil, path: \"/foo/bar\",\n"
"         port: nil, query: nil, scheme: nil, userinfo: nil}\n"
"\n"
"    iex> URI.parse(\"foo/bar\")\n"
"    %URI{authority: nil, fragment: nil, host: nil, path: \"foo/bar\",\n"
"         port: nil, query: nil, scheme: nil, userinfo: nil}\n"
"\n"
msgstr ""
"well-formdedなURI参照を構成要素にパースします。\n"
"\n"
"この関数はwell-formedなURIを期待していて、如何なるバリデーショ\n"
"ンも実施しないことに注意してください。`URI.parse/1`がどのよう\n"
"に広範囲の相対URIをパースするのに用いられるか下の例のセクショ\n"
"ンを参照してください。\n"
"\n"
"この関数は、RFC3986のAppendix Bで定義された正規表現を用いてパース\n"
"します。\n"
"\n"
"URIにポートが与えられないとき、`URI.default_port/1`と\n"
"`URI.default_port/2`で登録された値が使われます。\n"
"\n"
"## 例\n"
"\n"
"    iex> URI.parse(\"http://elixir-lang.org/\")\n"
"    %URI{scheme: \"http\", path: \"/\", query: nil, fragment: nil,\n"
"         authority: \"elixir-lang.org\", userinfo: nil,\n"
"         host: \"elixir-lang.org\", port: 80}\n"
"\n"
"    iex> URI.parse(\"//elixir-lang.org/\")\n"
"    %URI{authority: \"elixir-lang.org\", fragment: nil, host: \"elixir-lang."
"org\",\n"
"         path: \"/\", port: nil, query: nil, scheme: nil, userinfo: nil}\n"
"\n"
"    iex> URI.parse(\"/foo/bar\")\n"
"    %URI{authority: nil, fragment: nil, host: nil, path: \"/foo/bar\",\n"
"         port: nil, query: nil, scheme: nil, userinfo: nil}\n"
"\n"
"    iex> URI.parse(\"foo/bar\")\n"
"    %URI{authority: nil, fragment: nil, host: nil, path: \"foo/bar\",\n"
"         port: nil, query: nil, scheme: nil, userinfo: nil}\n"
"\n"

#. TRANSLATORS: def Version.parse(string)
#: lib/version.ex:181
msgid ""
"Parses a version string into a `Version`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> {:ok, version} = Version.parse(\"2.0.1-alpha1\")\n"
"    iex> version\n"
"    #Version<2.0.1-alpha1>\n"
"\n"
"    iex> Version.parse(\"2.0-alpha1\")\n"
"    :error\n"
"\n"
msgstr ""
"バージョン文字列を`Version`にパースします。\n"
"\n"
"## 例\n"
"\n"
"    iex> {:ok, version} = Version.parse(\"2.0.1-alpha1\")\n"
"    iex> version\n"
"    #Version<2.0.1-alpha1>\n"
"\n"
"    iex> Version.parse(\"2.0-alpha1\")\n"
"    :error\n"
"\n"

#. TRANSLATORS: def Float.parse(binary)
#: lib/float.ex:33
msgid ""
"Parses a binary into a float.\n"
"\n"
"If successful, returns a tuple of the form `{float, remainder_of_binary}`.\n"
"Otherwise `:error`.\n"
"\n"
"If a float formatted string wants to be directly converted to float,\n"
"`String.to_float/1\" can be used instead.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Float.parse(\"34\")\n"
"    {34.0,\"\"}\n"
"\n"
"    iex> Float.parse(\"34.25\")\n"
"    {34.25,\"\"}\n"
"\n"
"    iex> Float.parse(\"56.5xyz\")\n"
"    {56.5,\"xyz\"}\n"
"\n"
"    iex> Float.parse(\"pi\")\n"
"    :error\n"
"\n"
msgstr ""
"浮動小数点数にバイナリをパースします。\n"
"\n"
"成功したら、`{float, remainder_of_bianry}`形式のタプルを返します。\n"
"さもなければ、`:error`を返します。\n"
"\n"
"もし浮動小数点数にフォーマットされた文字列を直接浮動小数点数に変換\n"
"したいなら、代わりに`String.to_float/1`を使うことができます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Float.parse(\"34\")\n"
"    {34.0,\"\"}\n"
"\n"
"    iex> Float.parse(\"34.25\")\n"
"    {34.25,\"\"}\n"
"\n"
"    iex> Float.parse(\"56.5xyz\")\n"
"    {56.5,\"xyz\"}\n"
"\n"
"    iex> Float.parse(\"pi\")\n"
"    :error\n"
"\n"

#. TRANSLATORS: def IO.ANSI.overlined()
#: lib/io/ansi.ex:120
msgid "Overlined"
msgstr "上線を設定"

#. TRANSLATORS: def OptionParser.parse(argv, opts \\ [])
#: lib/option_parser.ex:109
msgid ""
"Parses `argv` into a keywords list.\n"
"\n"
"It returns the parsed values, remaining arguments and the\n"
"invalid options.\n"
"\n"
"## Examples\n"
"\n"
"    iex> OptionParser.parse([\"--debug\"])\n"
"    {[debug: true], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--source\", \"lib\"])\n"
"    {[source: \"lib\"], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--source-path\", \"lib\", \"test/enum_test.exs"
"\", \"--verbose\"])\n"
"    {[source_path: \"lib\", verbose: true], [\"test/enum_test.exs\"], []}\n"
"\n"
"By default, Elixir will try to automatically parse switches.\n"
"Switches without an argument, like `--debug` will automatically\n"
"be set to true. Switches followed by a value will be assigned\n"
"to the value, always as strings.\n"
"\n"
"Note Elixir also converts the switches to underscore atoms, as\n"
"`--source-path` becomes `:source_path`, to better suit Elixir\n"
"conventions. This means that option names on the command line cannot "
"contain\n"
"underscores; such options will be reported as `:undefined` (in strict mode)\n"
"or `:invalid` (in basic mode).\n"
"\n"
"## Switches\n"
"\n"
"Many times though, it is better to explicitly list the available\n"
"switches and their formats. The switches can be specified via two\n"
"different options:\n"
"\n"
"  * `:strict` - the switches are strict. Any switch that does not\n"
"    exist in the switch list is treated as an error.\n"
"\n"
"  * `:switches` - defines some switches. Switches that does not\n"
"    exist in the switch list are still attempted to be parsed.\n"
"\n"
"Note only `:strict` or `:switches` may be given at once.\n"
"\n"
"For each switch, the following types are supported:\n"
"\n"
"  * `:boolean` - marks the given switch as a boolean. Boolean switches\n"
"                 never consume the following value unless it is `true` or\n"
"                 `false`.\n"
"  * `:integer` - parses the switch as an integer.\n"
"  * `:float`   - parses the switch as a float.\n"
"  * `:string`  - returns the switch as a string.\n"
"\n"
"If a switch can't be parsed or is not specified in the strict case,\n"
"the option is returned in the invalid options list (third element\n"
"of the returned tuple).\n"
"\n"
"The following extra \"types\" are supported:\n"
"\n"
"  * `:keep` - keeps duplicated items in the list instead of overriding\n"
"\n"
"Examples:\n"
"\n"
"    iex> OptionParser.parse([\"--unlock\", \"path/to/file\"], strict: "
"[unlock: :boolean])\n"
"    {[unlock: true], [\"path/to/file\"], []}\n"
"\n"
"    iex> OptionParser.parse([\"--unlock\", \"--limit\", \"0\", \"path/to/file"
"\"],\n"
"    ...>                    strict: [unlock: :boolean, limit: :integer])\n"
"    {[unlock: true, limit: 0], [\"path/to/file\"], []}\n"
"\n"
"    iex> OptionParser.parse([\"--limit\", \"3\"], strict: [limit: :"
"integer])\n"
"    {[limit: 3], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--limit\", \"xyz\"], strict: [limit: :"
"integer])\n"
"    {[], [], [{\"--limit\", \"xyz\"}]}\n"
"\n"
"    iex> OptionParser.parse([\"--unknown\", \"xyz\"], strict: [])\n"
"    {[], [\"xyz\"], [{\"--unknown\", nil}]}\n"
"\n"
"    iex> OptionParser.parse([\"--limit\", \"3\", \"--unknown\", \"xyz\"],\n"
"    ...>                    switches: [limit: :integer])\n"
"    {[limit: 3, unknown: \"xyz\"], [], []}\n"
"\n"
"## Negation switches\n"
"\n"
"In case a switch is declared as boolean, it may be passed as `--no-SWITCH`\n"
"which will set the option to false:\n"
"\n"
"    iex> OptionParser.parse([\"--no-op\", \"path/to/file\"], switches: [op: :"
"boolean])\n"
"    {[op: false], [\"path/to/file\"], []}\n"
"\n"
"## Aliases\n"
"\n"
"A set of aliases can be given as options too:\n"
"\n"
"    iex> OptionParser.parse([\"-d\"], aliases: [d: :debug])\n"
"    {[debug: true], [], []}\n"
"\n"
msgstr ""
"`argv`をキーワードリストにパースします。\n"
"\n"
"それはパースされた値、残りの引数、無効なオプションを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> OptionParser.parse([\"--debug\"])\n"
"    {[debug: true], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--source\", \"lib\"])\n"
"    {[source: \"lib\"], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--source-path\", \"lib\", \"test/enum_test.exs"
"\", \"--verbose\"])\n"
"    {[source_path: \"lib\", verbose: true], [\"test/enum_test.exs\"], []}\n"
"\n"
"デフォルトで、Elixirは自動的にスイッチをパースしようとします。\n"
"`--debug`のような引数なしのスイッチは、自動的にtrueにセットされます。\n"
"値が後ろに続くスイッチは、その値が常に文字列としてセットされます。\n"
"\n"
"Elixirもまた、Elixirの慣習により合うようにするため、\n"
"`--source-path`を`:source_path`として、\n"
"スイッチをアンダースコアアトムに変換することに、\n"
"注意してください。\n"
"これはコマンドラインのオプション名はアンダースコアを含むことができない\n"
"ことを意味します; そのようなオプションは(厳格なモードでは)\n"
"`:undefined`として、あるいは、(ベーシックモードでは)`:invalid`\n"
"として報告されます。\n"
"\n"
"## Switches\n"
"\n"
"しばしば、有効なスイッチとそのフォーマットのリストを明確にすることは\n"
"よりよいです。スイッチは二つの異るオプションで指定できます:\n"
"\n"
"  * `:strict` - スイッチは厳格です。\n"
"    スイッチリストに存在していない全てのスイッチは、エラーとして\n"
"    扱われます。\n"
"\n"
"  * `:switches` - いくつかのスイッチを定義します。\n"
"    スイッチリストに存在していないスイッチは、パースされるために\n"
"    まだ試みられます。\n"
"\n"
"`:strict`または`:switches`は一度だけ与えられる\n"
"かもしれないことに、注意してください。\n"
"\n"
"それぞれのスイッチのために、以下のタイプがサポートされています:\n"
"\n"
"  * `:boolean` - 与えられたスイッチをブーリアンとしてマークします。\n"
"                 ブーリアンスイッチは決して`true`か`false`以外の\n"
"                 値を消費しません。\n"
"  * `:integer` - 整数としてスイッチをパースします。\n"
"  * `:float`   - 浮動小数点数としてスイッチをパースします。\n"
"  * `:string`  - 文字列としてスイッチをパースします。\n"
"\n"
"スイッチがパースできないか、厳格なモードで指定されていないかなら、オプ\n"
"ションは無効なオプションリスト(戻りタプルの三番目の要素)の中に返ります。\n"
"\n"
"以下の特別な\"type\"がサポートされています:\n"
"\n"
"  * `:keep` - 上書きするかわりに、重複したアイテムを保持します\n"
"\n"
"例:\n"
"\n"
"    iex> OptionParser.parse([\"--unlock\", \"path/to/file\"], strict: "
"[unlock: :boolean])\n"
"    {[unlock: true], [\"path/to/file\"], []}\n"
"\n"
"    iex> OptionParser.parse([\"--unlock\", \"--limit\", \"0\", \"path/to/file"
"\"],\n"
"    ...>                    strict: [unlock: :boolean, limit: :integer])\n"
"    {[unlock: true, limit: 0], [\"path/to/file\"], []}\n"
"\n"
"    iex> OptionParser.parse([\"--limit\", \"3\"], strict: [limit: :"
"integer])\n"
"    {[limit: 3], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--limit\", \"xyz\"], strict: [limit: :"
"integer])\n"
"    {[], [], [{\"--limit\", \"xyz\"}]}\n"
"\n"
"    iex> OptionParser.parse([\"--unknown\", \"xyz\"], strict: [])\n"
"    {[], [\"xyz\"], [{\"--unknown\", nil}]}\n"
"\n"
"    iex> OptionParser.parse([\"--limit\", \"3\", \"--unknown\", \"xyz\"],\n"
"    ...>                    switches: [limit: :integer])\n"
"    {[limit: 3, unknown: \"xyz\"], [], []}\n"
"\n"
"## Negation switches\n"
"\n"
"ブーリアンとして宣言されたスイッチで、`--no-SWITH`として渡されたら、\n"
"そのオプションはfalseとセットされます:\n"
"\n"
"    iex> OptionParser.parse([\"--no-op\", \"path/to/file\"], switches: [op: :"
"boolean])\n"
"    {[op: false], [\"path/to/file\"], []}\n"
"\n"
"## Aliases\n"
"\n"
"一組のアイリアスをオプションに与えることもできます:\n"
"\n"
"    iex> OptionParser.parse([\"-d\"], aliases: [d: :debug])\n"
"    {[debug: true], [], []}\n"
"\n"

#. TRANSLATORS: @type options
#: lib/supervisor.ex:0
msgid "Options used by the `start*` functions"
msgstr "`start*`関数で使われるオプション"

#. TRANSLATORS: def Enum.unzip(coll)
#: lib/enum.ex:2010
msgid ""
"Opposite of `Enum.zip/2`; takes a list of two-element tuples and returns a\n"
"tuple with two lists, each of which is formed by the first and second "
"element\n"
"of each tuple, respectively.\n"
"\n"
"This function fails unless `coll` is or can be converted into a list of\n"
"tuples with *exactly* two elements in each tuple.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.unzip([{:a, 1}, {:b, 2}, {:c, 3}])\n"
"    {[:a, :b, :c], [1, 2, 3]}\n"
"\n"
"    iex> Enum.unzip(%{a: 1, b: 2})\n"
"    {[:a, :b], [1, 2]}\n"
"\n"
msgstr ""
"`Enum.zip/2`の正反対; 二要素のタプルのリストをとり、二つのリ\n"
"ストをもつタプルを返します(それぞれのリストは各々のタプルの第\n"
"一および第二の要素で作れられます)。\n"
"\n"
"`coll`が各のタプルで *正確に* 二要素のタプルのリストであるか、\n"
"それにコンバート出来ない限り、この関数は失敗します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.unzip([{:a, 1}, {:b, 2}, {:c, 3}])\n"
"    {[:a, :b, :c], [1, 2, 3]}\n"
"\n"
"    iex> Enum.unzip(%{a: 1, b: 2})\n"
"    {[:a, :b], [1, 2]}\n"
"\n"

#. TRANSLATORS: def File.open(path, modes \\ [])
#: lib/file.ex:962
msgid ""
"Opens the given `path` according to the given list of modes.\n"
"\n"
"In order to write and read files, one must use the functions\n"
"in the `IO` module. By default, a file is opened in binary mode\n"
"which requires the functions `IO.binread/2` and `IO.binwrite/2`\n"
"to interact with the file. A developer may pass `:utf8` as an\n"
"option when opening the file and then all other functions from\n"
"`IO` are available, since they work directly with Unicode data.\n"
"\n"
"The allowed modes:\n"
"\n"
"  * `:read` - the file, which must exist, is opened for reading.\n"
"\n"
"  * `:write` - the file is opened for writing. It is created if it does not\n"
"    exist.\n"
"\n"
"    If the file does exists, and if write is not combined with read, the "
"file\n"
"    will be truncated.\n"
"\n"
"  * `:append` - the file will be opened for writing, and it will be created\n"
"    if it does not exist. Every write operation to a file opened with "
"append\n"
"    will take place at the end of the file.\n"
"\n"
"  * `:exclusive` - the file, when opened for writing, is created if it does\n"
"    not exist. If the file exists, open will return `{:error, :eexist}`.\n"
"\n"
"  * `:char_list` - when this term is given, read operations on the file "
"will\n"
"    return char lists rather than binaries.\n"
"\n"
"  * `:compressed` - makes it possible to read or write gzip compressed "
"files.\n"
"\n"
"    The compressed option must be combined with either read or write, but "
"not\n"
"    both. Note that the file size obtained with `stat/1` will most probably\n"
"    not match the number of bytes that can be read from a compressed file.\n"
"\n"
"  * `:utf8` - this option denotes how data is actually stored in the disk\n"
"    file and makes the file perform automatic translation of characters to\n"
"    and from utf-8.\n"
"\n"
"    If data is sent to a file in a format that cannot be converted to the\n"
"    utf-8 or if data is read by a function that returns data in a format "
"that\n"
"    cannot cope with the character range of the data, an error occurs and "
"the\n"
"    file will be closed.\n"
"\n"
"Check http://www.erlang.org/doc/man/file.html#open-2 for more information "
"about\n"
"other options like `:read_ahead` and `:delayed_write`.\n"
"\n"
"This function returns:\n"
"\n"
"  * `{:ok, io_device}` - the file has been opened in the requested mode.\n"
"\n"
"    `io_device` is actually the pid of the process which handles the file.\n"
"    This process is linked to the process which originally opened the file.\n"
"    If any process to which the `io_device` is linked terminates, the file\n"
"    will be closed and the process itself will be terminated.\n"
"\n"
"    An `io_device` returned from this call can be used as an argument to "
"the\n"
"    `IO` module functions.\n"
"\n"
"  * `{:error, reason}` - the file could not be opened.\n"
"\n"
"## Examples\n"
"\n"
"    {:ok, file} = File.open(\"foo.tar.gz\", [:read, :compressed])\n"
"    IO.read(file, :line)\n"
"    File.close(file)\n"
"\n"
msgstr ""
"与えられたモードのリストに従って、与えられた`path`をオープンします。\n"
"\n"
"ファイルを読み書きするために、`IO`モジュールの関数を使わなくてはなりま\n"
"せん。デフォルトではファイルは、`IO.binread/2`と`IO.binwrite/2`で相互作\n"
"用することを要求する、バイナリモードでオープンされます。\n"
"開発者はファイルを開くときに、`:utf8`オプションを渡すこともでき、そうすると\n"
"、ユニコードデータで直接動くので、`IO`からの他の全ての関数が有効にな\n"
"ります。\n"
"\n"
"許されたモードは以下のとおりです:\n"
"\n"
"  * `:read` - ファイルは存在していなくてはならず、読み込みのためにオープンさ"
"れます\n"
"\n"
"  * `:write` - ファイルは書き込みの為にオープンされます。もしなければ、\n"
"              作られます。\n"
"\n"
"    もしファイルが存在して、そして、もしwriteがreadと一緒に指定されないな"
"ら、\n"
"    ファイルはトランケートされます。\n"
"\n"
"  * `:append` - ファイルは書き込みの為にオープンされ、もし存在しないなら、\n"
"    作成されます。appendでオープンされたファイルへの、それぞれの書込み\n"
"    オペレーションは、ファイルの終わりの場所に行われます。\n"
"\n"
"  * `:exclusive` - 書き込みの為にオープンされたファイルは、存在しないなら\n"
"    作成されます。もしファイルが存在したらopenは`{:error, :eexist}`を返しま"
"す。\n"
"\n"
"  * `:char_list` - これが指定されたら、ファイルの読み込み\n"
"    オペレーションはバイナリではなく文字のリストを返します。\n"
"\n"
"  * `:compressed` - gzipで圧縮されたファイルを読み書きすることを可能にしま"
"す。\n"
"\n"
"    compressedオプションはreadかwriteの両方ではなく、どちらか一方と一緒に\n"
"    指定されなければなりません。\n"
"    `stat/1`で得られるファイルサイズは、圧縮ファイルから読み込むことができ"
"る\n"
"     バイト数と、多分マッチしないことに注意してください。\n"
"\n"
"  * `:utf8` - このオプションは、ディスクファイルに実際に保存される方法\n"
"    を意味して、ファイルに対して、自動的にutf8からまたは、utf8への文字\n"
"    の変換を実行させます。\n"
"\n"
"    もし、データがutf8へ変換出来ないフォーマットでファイルに送信されたら、\n"
"    または、データの文字範囲に対処できないフォーマットでデータを返す関数に\n"
"    よってデータが読み込まれたら、エラーが発生し、ファイルはクローズされま"
"す。\n"
"\n"
"`:read_ahead`や`:delayed_write`といった、他のオプションについての詳細は、\n"
"http://www.erlang.org/doc/man/file.html#open-2をチェックしてください。\n"
"\n"
"この関数は以下を返します:\n"
"\n"
"  * `{:ok, io_device}` - 要求されたモードで、ファイルはオープンされました。\n"
"\n"
"    `io_device`は通常、ファイルを扱うプロセスのpidです。\n"
"    このプロセスはファイルをオープンしたオリジナルのプロセスにリンクしていま"
"す。\n"
"    もし`io_device`がリンクされている任意のプロセスが終了したら、\n"
"    ファイルはクローズされ、そのプロセス自身も終了します。\n"
"\n"
"    この関数から返された`io_device`は、`IO`モジュールの関数に引数として渡\n"
"    されることがあります。\n"
"\n"
"  * `{:error, reason}` - ファイルはオープン出来ませんでした。\n"
"\n"
"## 例\n"
"\n"
"    {:ok, file} = File.open(\"foo.tar.gz\", [:read, :compressed])\n"
"    IO.read(file, :line)\n"
"    File.close(file)\n"
"\n"

#. TRANSLATORS: def IO.ANSI.not_overlined()
#: lib/io/ansi.ex:126
msgid "Not overlined"
msgstr "上線を解除"

#. TRANSLATORS: def IO.ANSI.not_italic()
#: lib/io/ansi.ex:89
msgid "Not italic"
msgstr "イタリックを解除"

#. TRANSLATORS: def IO.ANSI.not_framed_encircled()
#: lib/io/ansi.ex:123
msgid "Not framed or encircled"
msgstr "四角囲みまたは丸囲みを解除"

#. TRANSLATORS: def Inspect.Algebra.folddoc(list1, f)
#: lib/inspect/algebra.ex:389
msgid ""
"Folds a list of document entities into a document entity\n"
"using a function that is passed as the first argument.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = [\"A\", \"B\"]\n"
"    iex> doc = Inspect.Algebra.folddoc(doc, fn(x,y) ->\n"
"    ...>   Inspect.Algebra.concat [x, \"!\", y]\n"
"    ...> end)\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"A\", \"!\", \"B\"]\n"
"\n"
msgstr ""
"ドキュメントエンティティのリストを、ドキュメントエンディティに、関数を\n"
"使ってフォールドします。関数には、ドキュメントエンティティを最初の引数とし\n"
"て渡します。\n"
"\n"
"## 例\n"
"\n"
"    iex> doc = [\"A\", \"B\"]\n"
"    iex> doc = Inspect.Algebra.folddoc(doc, fn(x,y) ->\n"
"    ...>   Inspect.Algebra.concat [x, \"!\", y]\n"
"    ...> end)\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"A\", \"!\", \"B\"]\n"
"\n"

#. TRANSLATORS: def Keyword.fetch!(keywords, key)
#: lib/keyword.ex:162
msgid ""
"Fetches the value for specific `key`. \n"
"\n"
"If `key` does not exist, a `KeyError` is raised.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.fetch!([a: 1], :a)\n"
"    1\n"
"\n"
"    iex> Keyword.fetch!([a: 1], :b)\n"
"    ** (KeyError) key :b not found in: [a: 1]\n"
"\n"
msgstr ""
"指定した`key`の値を取り出します。\n"
"\n"
"もし`key`が存在しないなら、`KeyError`を上げます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.fetch!([a: 1], :a)\n"
"    1\n"
"\n"
"    iex> Keyword.fetch!([a: 1], :b)\n"
"    ** (KeyError) key :b not found in: [a: 1]\n"
"\n"

#. TRANSLATORS: def Keyword.fetch(keywords, key)
#: lib/keyword.ex:140
msgid ""
"Fetches the value for a specific `key` and returns it in a tuple.\n"
"\n"
"If the `key` does not exist, returns `:error`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.fetch([a: 1], :a)\n"
"    {:ok, 1}\n"
"\n"
"    iex> Keyword.fetch([a: 1], :b)\n"
"    :error\n"
"\n"
msgstr ""
"指定した`key`の値を取り出し、タプルに入れて返します。\n"
"\n"
"もし`key`が存在しないなら、`:error`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.fetch([a: 1], :a)\n"
"    {:ok, 1}\n"
"\n"
"    iex> Keyword.fetch([a: 1], :b)\n"
"    :error\n"
"\n"

#. TRANSLATORS: def List.foldr(list, acc, function)
#: lib/list.ex:116
msgid ""
"Folds (reduces) the given list from the right with\n"
"a function. Requires an accumulator.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.foldr([1, 2, 3, 4], 0, fn (x, acc) -> x - acc end)\n"
"    -2\n"
"\n"
msgstr ""
"与えられたリストを、関数で右からフォールド(reduce)ます。\n"
"アキュムレータは必須です。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.foldr([1, 2, 3, 4], 0, fn (x, acc) -> x - acc end)\n"
"    -2\n"
"\n"

#. TRANSLATORS: def List.foldl(list, acc, function)
#: lib/list.ex:101
msgid ""
"Folds (reduces) the given list from the left with\n"
"a function. Requires an accumulator.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.foldl([5, 5], 10, fn (x, acc) -> x + acc end)\n"
"    20\n"
"\n"
"    iex> List.foldl([1, 2, 3, 4], 0, fn (x, acc) -> x - acc end)\n"
"    2\n"
"\n"
msgstr ""
"与えられたリストを、関数で左からフォールド(reduce)ます。\n"
"アキュムレータは必須です。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.foldl([5, 5], 10, fn (x, acc) -> x + acc end)\n"
"    20\n"
"\n"
"    iex> List.foldl([1, 2, 3, 4], 0, fn (x, acc) -> x - acc end)\n"
"    2\n"
"\n"

#. TRANSLATORS: def List.flatten(list, tail)
#: lib/list.ex:83
msgid ""
"Flattens the given `list` of nested lists.\n"
"The list `tail` will be added at the end of\n"
"the flattened list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.flatten([1, [[2], 3]], [4, 5])\n"
"    [1,2,3,4,5]\n"
"\n"
msgstr ""
"与えられた、ネストしたリスト`list`をフラット化します。\n"
"リスト`tail`はフラット化されたlistの終わりに追加されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.flatten([1, [[2], 3]], [4, 5])\n"
"    [1,2,3,4,5]\n"
"\n"

#. TRANSLATORS: def List.flatten(list)
#: lib/list.ex:67
msgid ""
"Flattens the given `list` of nested lists.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.flatten([1, [[2], 3]])\n"
"    [1,2,3]\n"
"\n"
msgstr ""
"与えられた、ネストしたリスト`list`をフラット化します。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.flatten([1, [[2], 3]])\n"
"    [1,2,3]\n"
"\n"

#. TRANSLATORS: defmacro Kernel.unless(clause, options)
#: lib/kernel.ex:2178
msgid ""
"Evaluates and returns the do-block passed in as a second argument\n"
"unless clause evaluates to true.\n"
"Returns nil otherwise.\n"
"See also `if`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> unless(Enum.empty?([]), do: \"Hello\")\n"
"    nil\n"
"\n"
"    iex> unless(Enum.empty?([1,2,3]), do: \"Hello\")\n"
"    \"Hello\"\n"
"\n"
msgstr ""
"clauseがtrueでない限り、2番目の引数として渡されたdo-blockを評価して返し\n"
"ます。\n"
"さもなければ、nilを返します。\n"
"`if`も参照してください。\n"
"\n"
"## 例\n"
"\n"
"    iex> unless(Enum.empty?([]), do: \"Hello\")\n"
"    nil\n"
"\n"
"    iex> unless(Enum.empty?([1,2,3]), do: \"Hello\")\n"
"    \"Hello\"\n"
"\n"

#. TRANSLATORS: def Node.connect(node)
#: lib/node.ex:147
msgid ""
"Establishes a connection to `node`.\n"
"\n"
"Returns `true` if successful, `false` if not, and the atom\n"
"`:ignored` if the local node is not alive.\n"
"\n"
"See http://erlang.org/doc/man/net_kernel.html#connect_node-1 for more info.\n"
msgstr ""
"`node`への接続を確立します。\n"
"\n"
"成功すると`true`、失敗すると`false`を、ローカルノードが\n"
"生きていないとアトム`:ignored`を返します。\n"
"\n"
"詳細は、 http://erlang.org/doc/man/net_kernel.html#connect_node-1 を\n"
"参照してください。\n"

#. TRANSLATORS: def Stream.take(enum, n)
#: lib/stream.ex:519
msgid ""
"Lazily takes the next `n` items from the enumerable and stops\n"
"enumeration.\n"
"\n"
"If a negative `n` is given, the last `n` values will be taken.\n"
"For such, the collection is fully enumerated keeping up to `2 * n`\n"
"elements in memory. Once the end of the collection is reached,\n"
"the last `count` elements will be executed. Therefore, using\n"
"a negative `n` on an infinite collection will never return.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.take(1..100, 5)\n"
"    iex> Enum.to_list(stream)\n"
"    [1,2,3,4,5]\n"
"\n"
"    iex> stream = Stream.take(1..100, -5)\n"
"    iex> Enum.to_list(stream)\n"
"    [96,97,98,99,100]\n"
"\n"
"    iex> stream = Stream.cycle([1, 2, 3]) |> Stream.take(5)\n"
"    iex> Enum.to_list(stream)\n"
"    [1,2,3,1,2]\n"
"\n"
msgstr ""
"次の`n`アイテムをenumerableから遅延評価して取り出し、列挙を\n"
"停止します。\n"
"\n"
"もし与えられた`n`が負なら、最後の`n`個が取り出されます。それのために、\n"
"コレクションはすべて列挙され、メモリで`2 * n`要素保持されます。コレクショ\n"
"ンの終わりに到達したら、最後の`count`要素が実行されます。従って、無限の\n"
"コレクションに対して、負の`n`を使うと、決して戻りません。\n"
"\n"
"## 例\n"
"\n"
"    iex> stream = Stream.take(1..100, 5)\n"
"    iex> Enum.to_list(stream)\n"
"    [1,2,3,4,5]\n"
"\n"
"    iex> stream = Stream.take(1..100, -5)\n"
"    iex> Enum.to_list(stream)\n"
"    [96,97,98,99,100]\n"
"\n"
"    iex> stream = Stream.cycle([1, 2, 3]) |> Stream.take(5)\n"
"    iex> Enum.to_list(stream)\n"
"    [1,2,3,1,2]\n"
"\n"

#. TRANSLATORS: def Stream.take_while(enum, fun)
#: lib/stream.ex:588
msgid ""
"Lazily takes elements of the enumerable while the given\n"
"function returns `true`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.take_while(1..100, &(&1 <= 5))\n"
"    iex> Enum.to_list(stream)\n"
"    [1,2,3,4,5]\n"
"\n"
msgstr ""
"与えられた関数を`true`にするenumerableの要素を、\n"
"遅延評価して取り出します。\n"
"\n"
"## 例\n"
"\n"
"    iex> stream = Stream.take_while(1..100, &(&1 <= 5))\n"
"    iex> Enum.to_list(stream)\n"
"    [1,2,3,4,5]\n"
"\n"

#. TRANSLATORS: def Stream.drop(enum, n)
#: lib/stream.ex:224
msgid ""
"Lazily drops the next `n` items from the enumerable.\n"
"\n"
"If a negative `n` is given, it will drop the last `n` items from\n"
"the collection. Note that the mechanism by which this is implemented\n"
"will delay the emission of any item until `n` additional items have\n"
"been emitted by the enum.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.drop(1..10, 5)\n"
"    iex> Enum.to_list(stream)\n"
"    [6,7,8,9,10]\n"
"\n"
"    iex> stream = Stream.drop(1..10, -5)\n"
"    iex> Enum.to_list(stream)\n"
"    [1,2,3,4,5]\n"
"\n"
msgstr ""
"enumerableから次の`n`アイテムを遅延評価して削除します。\n"
"\n"
"もし負の`n`が与えられたら、コレクションの最後の`n`アイテムが削除されま\n"
"す。この実装によるメカニズムは、`n`個のさらなるアイテムがenumによって発\n"
"生されるまで、どんなアイテムの放出も遅延されることに、注意してください。\n"
"\n"
"## 例\n"
"\n"
"    iex> stream = Stream.drop(1..10, 5)\n"
"    iex> Enum.to_list(stream)\n"
"    [6,7,8,9,10]\n"
"\n"
"    iex> stream = Stream.drop(1..10, -5)\n"
"    iex> Enum.to_list(stream)\n"
"    [1,2,3,4,5]\n"
"\n"

#. TRANSLATORS: def Stream.drop_while(enum, fun)
#: lib/stream.ex:264
msgid ""
"Lazily drops elements of the enumerable while the given\n"
"function returns `true`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.drop_while(1..10, &(&1 <= 5))\n"
"    iex> Enum.to_list(stream)\n"
"    [6,7,8,9,10]\n"
"\n"
msgstr ""
"与えられた関数を`true`にするenumerableの要素を遅延評価して削除します。\n"
"\n"
"## 例\n"
"\n"
"    iex> stream = Stream.drop_while(1..10, &(&1 <= 5))\n"
"    iex> Enum.to_list(stream)\n"
"    [6,7,8,9,10]\n"
"\n"

#. TRANSLATORS: def Base.url_encode64(data)
#: lib/base.ex:284
msgid ""
"Encodes a binary string into a base 64 encoded string with URL and filename\n"
"safe alphabet.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Base.url_encode64(<<255,127,254,252>>)\n"
"    \"_3_-_A==\"\n"
"\n"
msgstr ""
"バイナリ文字列を、URLとファイル名で安全なアルファベットのbase64エンコー\n"
"ド文字列に、エンコードします。\n"
"\n"
"## 例\n"
"\n"
"    iex> Base.url_encode64(<<255,127,254,252>>)\n"
"    \"_3_-_A==\"\n"
"\n"

#. TRANSLATORS: def Base.encode32(data, opts \\ [])
#: lib/base.ex:340
msgid ""
"Encodes a binary string into a base 32 encoded string.\n"
"\n"
"Accepts an atom `:upper` (default) for encoding to upper case characters or\n"
"`:lower` for lower case characters.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Base.encode32(\"foobar\")\n"
"    \"MZXW6YTBOI======\"\n"
"\n"
"    iex> Base.encode32(\"foobar\", case: :lower)\n"
"    \"mzxw6ytboi======\"\n"
"\n"
msgstr ""
"バイナリ文字列を、base 32エンコード文字列に、\n"
"エンコードします。\n"
"\n"
"大文字でのエンコードを行う`:upper`(デフォルト)、または、\n"
"小文字でのエンコードを行う`:lower`アトムを、\n"
"case: オプションで受け付けます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Base.encode32(\"foobar\")\n"
"    \"MZXW6YTBOI======\"\n"
"\n"
"    iex> Base.encode32(\"foobar\", case: :lower)\n"
"    \"mzxw6ytboi======\"\n"
"\n"

#. TRANSLATORS: def Base.hex_encode32(data, opts \\ [])
#: lib/base.ex:420
msgid ""
"Encodes a binary string into a base 32 encoded string with an\n"
"extended hexadecimal alphabet.\n"
"\n"
"Accepts an atom `:upper` (default) for encoding to upper case characters or\n"
"`:lower` for lower case characters.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Base.hex_encode32(\"foobar\")\n"
"    \"CPNMUOJ1E8======\"\n"
"\n"
"    iex> Base.hex_encode32(\"foobar\", case: :lower)\n"
"    \"cpnmuoj1e8======\"\n"
"\n"
msgstr ""
"バイナリ文字列を、拡張16進アルファベットによる、base 32エンコード文字列\n"
"に、エンコードします。\n"
"\n"
"大文字でのエンコードを行う`:upper`(デフォルト)、または、\n"
"小文字でのエンコードを行う`:lower`アトムを、\n"
"case: オプションで受け付けます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Base.hex_encode32(\"foobar\")\n"
"    \"CPNMUOJ1E8======\"\n"
"\n"
"    iex> Base.hex_encode32(\"foobar\", case: :lower)\n"
"    \"cpnmuoj1e8======\"\n"
"\n"

#. TRANSLATORS: def Base.encode16(data, opts \\ [])
#: lib/base.ex:161
msgid ""
"Encodes a binary string into a base 16 encoded string.\n"
"\n"
"Accepts an atom `:upper` (default) for encoding to upper case characters or\n"
"`:lower` for lower case characters.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Base.encode16(\"foobar\")\n"
"    \"666F6F626172\"\n"
"\n"
"    iex> Base.encode16(\"foobar\", case: :lower)\n"
"    \"666f6f626172\"\n"
"\n"
msgstr ""
"バイナリ文字列を、base 16エンコード文字列\n"
"に、エンコードします。\n"
"\n"
"大文字でのエンコードを行う`:upper`(デフォルト)、または、\n"
"小文字でのエンコードを行う`:lower`アトムを、\n"
"case: オプションで受け付けます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Base.encode16(\"foobar\")\n"
"    \"666F6F626172\"\n"
"\n"
"    iex> Base.encode16(\"foobar\", case: :lower)\n"
"    \"666f6f626172\"\n"
"\n"

#. TRANSLATORS: def IO.ANSI.encircled()
#: lib/io/ansi.ex:117
msgid "Encircled"
msgstr "丸で囲みます"

#. TRANSLATORS: Elixir.Port Summary
#: lib/port.ex:1
msgid "Functions related to Erlang ports.\n"
msgstr "Erlangポートに関連する関数です。\n"

#. TRANSLATORS: Elixir.IO Summary
#: lib/io.ex:1
msgid ""
"Functions handling IO.\n"
"\n"
"Many functions in this module expect an IO device as an argument.\n"
"An IO device must be a pid or an atom representing a process.\n"
"For convenience, Elixir provides `:stdio` and `:stderr` as\n"
"shortcuts to Erlang's `:standard_io` and `:standard_error`.\n"
"\n"
"The majority of the functions expect char data, i.e. strings or\n"
"lists of characters and strings. In case another type is given,\n"
"it will do a conversion to string via the `String.Chars` protocol\n"
"(as shown in typespecs).\n"
"\n"
"The functions starting with `bin*` expect iodata as an argument,\n"
"i.e. binaries or lists of bytes and binaries.\n"
"\n"
"## IO devices\n"
"\n"
"An IO device may be an atom or a pid. In case it is an atom,\n"
"the atom must be the name of a registered process. However,\n"
"there are three exceptions for this rule:\n"
"\n"
"  * `:standard_io` - when the `:standard_io` atom is given,\n"
"    it is treated as a shortcut for `Process.group_leader`\n"
"\n"
"  * `:stdio` - is a shortcut for `:standard_io`\n"
"\n"
"  * `:stderr` - is a shortcut for `:standard_error`\n"
"\n"
msgstr ""
"IOをハンドリングする関数です。\n"
"\n"
"このモジュールの多くの関数は、IOデバイスを引数として期待します。\n"
"IOデバイスはpidかプロセスを表現するアトムでなければなりません。\n"
"便宜上、Elixirは、Erlangの`:standard_io`と`:standard_error`の\n"
"ショートカットとして、`:stdio`と`:stderr`を提供します。\n"
"\n"
"関数の大多数はchar data、すなわち、文字列か文字また文字列のリスト、\n"
"を期待します。\n"
"他のタイプが与えられた場合、`String.Chars`プロトコルにより文字列に\n"
"変換されます(typespecで示すように)。\n"
"\n"
"`bin*`で始まる関数は、引数としてiodata、\n"
"すなわち、バイナリかバイトとバイナリのリスト、\n"
"を期待します。\n"
"\n"
"## IOデバイス\n"
"\n"
"IOデバイスはアトムかpidです。アトムの場合、\n"
"アトムは登録されたプロセスの名前でなくてはなりません。\n"
"しかしながら、この規則に3つの例外があります:\n"
"\n"
"  * `:standard_io` - アトム`:standard_io`が与えらえると、\n"
"    `Process.group_leader`のショートカットとして扱われます。\n"
"\n"
"  * `:stdio` - `:standard_io`のショートカットです。\n"
"\n"
"  * `:stderr` - `:standard_error`のショートカットです。\n"
"\n"

#. TRANSLATORS: def Regex.escape(string)
#: lib/regex.ex:610
msgid ""
"Escapes a string to be literally matched in a regex.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.escape(\".\")\n"
"    \"\\\\.\"\n"
"\n"
"    iex> Regex.escape(\"\\\\what if\")\n"
"    \"\\\\\\\\what\\\\ if\"\n"
"\n"
msgstr ""
"正規表現に文字通りにマッチした文字列をエスケープします。\n"
"\n"
"## 例\n"
"\n"
"    iex> Regex.escape(\".\")\n"
"    \"\\\\.\"\n"
"\n"
"    iex> Regex.escape(\"\\\\what if\")\n"
"    \"\\\\\\\\what\\\\ if\"\n"
"\n"

#. TRANSLATORS: def StringIO.flush(pid)
#: lib/string_io.ex:72
msgid ""
"Flushes output buffer.\n"
"\n"
"## Examples\n"
"\n"
"    iex> {:ok, pid} = StringIO.open(\"in\")\n"
"    iex> IO.write(pid, \"out\")\n"
"    iex> StringIO.flush(pid)\n"
"    \"out\"\n"
"    iex> StringIO.contents(pid)\n"
"    {\"in\", \"\"}\n"
"\n"
msgstr ""
"出力バッファをフラッシュします。\n"
"\n"
"## 例\n"
"\n"
"    iex> {:ok, pid} = StringIO.open(\"in\")\n"
"    iex> IO.write(pid, \"out\")\n"
"    iex> StringIO.contents(pid)\n"
"    {\"in\", \"out\"}\n"
"\n"

#. TRANSLATORS: def System.get_pid()
#: lib/system.ex:286
msgid ""
"Erlang VM process identifier.\n"
"\n"
"Returns the process identifier of the current Erlang emulator\n"
"in the format most commonly used by the operating system environment.\n"
"\n"
"See http://www.erlang.org/doc/man/os.html#getpid-0 for more info.\n"
msgstr ""
"Erlang VM自体のプロセス識別子です。\n"
"\n"
"そのオペレーティングシステム環境で最も一般的に使われるフォーマット\n"
"で、現在のErlangエミュレータのプロセス識別子を返します。\n"
"\n"
"詳細は http://www.erlang.org/doc/man/os.html#getpid-0 を参照してください。\n"

#. TRANSLATORS: def System.get_env(varname)
#: lib/system.ex:270
msgid ""
"Environment variable value.\n"
"\n"
"Returns the value of the environment variable\n"
"`varname` as a binary, or `nil` if the environment\n"
"variable is undefined.\n"
msgstr ""
"環境変数の値を取得します。\n"
"\n"
"バイナリとして`varname`環境変数の値を返します。\n"
"環境変数が定義されていないなら、`nil`を返します。\n"

#. TRANSLATORS: def Enum.uniq(collection, fun \\ fn x -> x end)
#: lib/enum.ex:1980
msgid ""
"Enumerates the collection, removing all duplicated items.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.uniq([1, 2, 3, 2, 1])\n"
"    [1, 2, 3]\n"
"\n"
"    iex> Enum.uniq([{1, :x}, {2, :y}, {1, :z}], fn {x, _} -> x end)\n"
"    [{1,:x}, {2,:y}]\n"
"\n"
msgstr ""
"重複するアイテムを削除しながら、コレクションを列挙します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.uniq([1, 2, 3, 2, 1])\n"
"    [1, 2, 3]\n"
"\n"
"    iex> Enum.uniq([{1, :x}, {2, :y}, {1, :z}], fn {x, _} -> x end)\n"
"    [{1,:x}, {2,:y}]\n"
"\n"

#. TRANSLATORS: def Stream.iterate(start_value, next_fun)
#: lib/stream.ex:949
msgid ""
"Emits a sequence of values, starting with `start_value`. Successive\n"
"values are generated by calling `next_fun` on the previous value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.iterate(0, &(&1+1)) |> Enum.take(5)\n"
"    [0,1,2,3,4]\n"
"\n"
msgstr ""
"`start_value`で初まる値のシーケンスを放出します。\n"
"連続した値は、前の値で`next_fun`を呼び出すことにより生成されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Stream.iterate(0, &(&1+1)) |> Enum.take(5)\n"
"    [0,1,2,3,4]\n"
"\n"

#. TRANSLATORS: def Stream.resource(start_fun, next_fun, after_fun)
#: lib/stream.ex:1014
msgid ""
"Emits a sequence of values for the given resource.\n"
"\n"
"Similar to `transform/2` but the initial accumulated value is\n"
"computed lazily via `start_fun` and executes an `after_fun` at\n"
"the end of enumeration (both in cases of success and failure).\n"
"\n"
"Successive values are generated by calling `next_fun` with the\n"
"previous accumulator (the initial value being the result returned\n"
"by `start_fun`) and it must return a tuple containing a list\n"
"of items to be emitted and the next accumulator. The enumeration\n"
"finishes if it returns `{:halt, acc}`.\n"
"\n"
"As the name says, this function is useful to stream values from\n"
"resources.\n"
"\n"
"## Examples\n"
"\n"
"    Stream.resource(fn -> File.open!(\"sample\") end,\n"
"                    fn file ->\n"
"                      case IO.read(file, :line) do\n"
"                        data when is_binary(data) -> {[data], file}\n"
"                        _ -> {:halt, file}\n"
"                      end\n"
"                    end,\n"
"                    fn file -> File.close(file) end)\n"
"\n"
msgstr ""
"与えられたリソースから値のシーケンスを放出します。\n"
"\n"
"`transform/2`と似ていますが、初期値は`start_fun`により送れて計算され、\n"
"列挙の終わりに`after_run`を実行します(成功も失敗もどちらの場合でも)。\n"
"\n"
"連続した値は、前のアキュムレータ(初期値は`start_fun`により返って来た結\n"
"果になります)とともに、現在の値と次のアキュムレータのタプルを返さなくて\n"
"はならない`next_fun`を呼ぶことにより、生成されます。`nil`を返すと、列挙\n"
"は終わります。\n"
"\n"
"名前が言うように、この関数は、リソースから値をストリームするのに\n"
"便利です。\n"
"\n"
"## 例\n"
"\n"
"    Stream.resource(fn -> File.open!(\"sample\") end,\n"
"                    fn file ->\n"
"                      case IO.read(file, :line) do\n"
"                        data when is_binary(data) -> {data, file}\n"
"                        _ -> nil\n"
"                      end\n"
"                    end,\n"
"                    fn file -> File.close(file) end)\n"
"\n"

#. TRANSLATORS: def Stream.unfold(next_acc, next_fun)
#: lib/stream.ex:1114
msgid ""
"Emits a sequence of values for the given accumulator.\n"
"\n"
"Successive values are generated by calling `next_fun` with the previous\n"
"accumulator and it must return a tuple with the current value and next\n"
"accumulator. The enumeration finishes if it returns `nil`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.unfold(5, fn 0 -> nil; n -> {n, n-1} end) |> Enum.to_list()\n"
"    [5, 4, 3, 2, 1]\n"
"\n"
msgstr ""
"与えられたアキュムレータから値のシーケンスを放出します。\n"
"\n"
"連続した値は、前のアキュムレータとともに、現在の値と次のアキュムレータ\n"
"のタプルを返さなくてはならない`next_fun`を呼ぶことにより、生成されます。\n"
"`nil`を返すと、列挙は終わります。\n"
"\n"
"## 例\n"
"\n"
"    iex> Stream.unfold(5, fn 0 -> nil; n -> {n, n-1} end) |> Enum.to_list()\n"
"    [5, 4, 3, 2, 1]\n"
"\n"

#. TRANSLATORS: def String.split(string, pattern, options \\ [])
#: lib/string.ex:289
msgid ""
"Divides a string into substrings based on a pattern.\n"
"\n"
"Returns a list of these substrings. The pattern can\n"
"be a string, a list of strings or a regular expression.\n"
"\n"
"The string is split into as many parts as possible by\n"
"default, but can be controlled via the `parts: num` option.\n"
"If you pass `parts: :infinity`, it will return all possible parts.\n"
"\n"
"Empty strings are only removed from the result if the\n"
"`trim` option is set to `true`.\n"
"\n"
"## Examples\n"
"\n"
"Splitting with a string pattern:\n"
"\n"
"    iex> String.split(\"a,b,c\", \",\")\n"
"    [\"a\", \"b\", \"c\"]\n"
"\n"
"    iex> String.split(\"a,b,c\", \",\", parts: 2)\n"
"    [\"a\", \"b,c\"]\n"
"\n"
"    iex> String.split(\" a b c \", \" \", trim: true)\n"
"    [\"a\", \"b\", \"c\"]\n"
"\n"
"A list of patterns:\n"
"\n"
"    iex> String.split(\"1,2 3,4\", [\" \", \",\"])\n"
"    [\"1\", \"2\", \"3\", \"4\"]\n"
"\n"
"A regular expression:\n"
"\n"
"    iex> String.split(\"a,b,c\", ~r{,})\n"
"    [\"a\", \"b\", \"c\"]\n"
"\n"
"    iex> String.split(\"a,b,c\", ~r{,}, parts: 2)\n"
"    [\"a\", \"b,c\"]\n"
"\n"
"    iex> String.split(\" a b c \", ~r{\\s}, trim: true)\n"
"    [\"a\", \"b\", \"c\"]\n"
"\n"
"Splitting on empty patterns returns codepoints:\n"
"\n"
"    iex> String.split(\"abc\", ~r{})\n"
"    [\"a\", \"b\", \"c\", \"\"]\n"
"\n"
"    iex> String.split(\"abc\", \"\")\n"
"    [\"a\", \"b\", \"c\", \"\"]\n"
"\n"
"    iex> String.split(\"abc\", \"\", trim: true)\n"
"    [\"a\", \"b\", \"c\"]\n"
"\n"
"    iex> String.split(\"abc\", \"\", parts: 2)\n"
"    [\"a\", \"bc\"]\n"
"\n"
msgstr ""
"文字列をpatternに基いて部分文字列に分割します。\n"
"\n"
"部分文字列のリストを返します。パターンは、\n"
"文字列、文字列のリストあるいは、正規表現が使えます。\n"
"\n"
"文字列はデフォルトでは出来るだけ多くの部分になるように\n"
"分割されますが、`parts: num`オプションにより制御すること\n"
"できます。\n"
"もし`parts: :infinity`を渡すと、出来るだけ多くの部分を返します。\n"
"\n"
"`trim`オプションが`true`にセットされると、\n"
"分割の結果の空の文字列は削除されます。\n"
"\n"
"## 例\n"
"\n"
"文字列パターンによる分割:\n"
"\n"
"    iex> String.split(\"a,b,c\", \",\")\n"
"    [\"a\", \"b\", \"c\"]\n"
"\n"
"    iex> String.split(\"a,b,c\", \",\", parts: 2)\n"
"    [\"a\", \"b,c\"]\n"
"\n"
"    iex> String.split(\" a b c \", \" \", trim: true)\n"
"    [\"a\", \"b\", \"c\"]\n"
"\n"
"パターンのリスト:\n"
"\n"
"    iex> String.split(\"1,2 3,4\", [\" \", \",\"])\n"
"    [\"1\", \"2\", \"3\", \"4\"]\n"
"\n"
"正規表現:\n"
"\n"
"    iex> String.split(\"a,b,c\", ~r{,})\n"
"    [\"a\", \"b\", \"c\"]\n"
"\n"
"    iex> String.split(\"a,b,c\", ~r{,}, parts: 2)\n"
"    [\"a\", \"b,c\"]\n"
"\n"
"    iex> String.split(\" a b c \", ~r{\\s}, trim: true)\n"
"    [\"a\", \"b\", \"c\"]\n"
"\n"
"空のパターンによる分割はコードポイントのリストを返します:\n"
"\n"
"    iex> String.split(\"abc\", ~r{})\n"
"    [\"a\", \"b\", \"c\", \"\"]\n"
"\n"
"    iex> String.split(\"abc\", \"\")\n"
"    [\"a\", \"b\", \"c\", \"\"]\n"
"\n"
"    iex> String.split(\"abc\", \"\", trim: true)\n"
"    [\"a\", \"b\", \"c\"]\n"
"\n"
"    iex> String.split(\"abc\", \"\", parts: 2)\n"
"    [\"a\", \"bc\"]\n"
"\n"

#. TRANSLATORS: def String.split(binary)
#: lib/string.ex:228
msgid ""
"Divides a string into substrings at each Unicode whitespace\n"
"occurrence with leading and trailing whitespace ignored.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.split(\"foo bar\")\n"
"    [\"foo\", \"bar\"]\n"
"\n"
"    iex> String.split(\"foo\" <> <<194, 133>> <> \"bar\")\n"
"    [\"foo\", \"bar\"]\n"
"\n"
"    iex> String.split(\" foo bar \")\n"
"    [\"foo\", \"bar\"]\n"
"\n"
msgstr ""
"文字列を、先頭と末尾の空白を無視して、Unicode空白ごとに部分文字列に分割\n"
"します。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.split(\"foo bar\")\n"
"    [\"foo\", \"bar\"]\n"
"\n"
"    iex> String.split(\"foo\" <> <<194, 133>> <> \"bar\")\n"
"    [\"foo\", \"bar\"]\n"
"\n"
"    iex> String.split(\" foo bar \")\n"
"    [\"foo\", \"bar\"]\n"
"\n"

#. TRANSLATORS: def System.version()
#: lib/system.ex:56
msgid ""
"Elixir version information.\n"
"\n"
"Returns Elixir's version as binary.\n"
msgstr ""
"Elixirバージョン情報です。\n"
"\n"
"バイナリとしてElixirのバージョンを返します。\n"

#. TRANSLATORS: def System.build_info()
#: lib/system.ex:64
msgid ""
"Elixir build information.\n"
"\n"
"Returns a keyword list with Elixir version, git tag info and compilation "
"date.\n"
msgstr ""
"Elixirビルドインフォメーションです。\n"
"\n"
"Elixirバージョン、git tag 情報および、コンパイル日時を返します。\n"

#. TRANSLATORS: defmacro Integer.is_odd(n)
#: lib/integer.ex:15
msgid ""
"Determines if an integer is odd.\n"
"\n"
"Returns `true` if `n` is an odd number, otherwise `false`.\n"
"\n"
"Allowed in guard clauses.\n"
msgstr ""
"整数が奇数かどうかを決定します。\n"
"\n"
"`n`が奇数なら、`true`を返し、さもなければ`false`を返します。\n"
"\n"
"ガード節で使えます。\n"

#. TRANSLATORS: defmacro Integer.is_even(n)
#: lib/integer.ex:26
msgid ""
"Determines if an integer is even.\n"
"\n"
"Returns `true` if `n` is an even number, otherwise `false`.\n"
"\n"
"Allowed in guard clauses.\n"
msgstr ""
"整数が偶数かどうかを決定します。\n"
"\n"
"`n`が偶数なら、`true`を返し、さもなければ`false`を返します。\n"
"\n"
"ガード節で使えます。\n"

#. TRANSLATORS: defmacro Kernel.Typespec.defopaque(type)
#: lib/kernel/typespec.ex:234
msgid ""
"Defines an opaque type.\n"
"This macro is responsible for handling the attribute `@opaque`.\n"
"\n"
"## Examples\n"
"\n"
"    @opaque my_type :: atom\n"
"\n"
msgstr ""
"不透明(opaque)なタイプを定義します。\n"
"このマクロは`@opaque`属性をハンドルする役割りを果します。\n"
"\n"
"## 例\n"
"\n"
"    @opaque my_type :: atom\n"
"\n"

#. TRANSLATORS: def List.delete(list, item)
#: lib/list.ex:36
msgid ""
"Deletes the given item from the list. Returns a list without\n"
"the item. If the item occurs more than once in the list, just\n"
"the first occurrence is removed.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.delete([1, 2, 3], 1)\n"
"    [2,3]\n"
"\n"
"    iex> List.delete([1, 2, 2, 3], 2)\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
"リストから与えられたアイテムを削除します。\n"
"そのアイテムを除いたリストを返します。\n"
"もしリストに一つより多くのアイテムがあったら、\n"
"最初の一つだけが削除されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.delete([1, 2, 3], 1)\n"
"    [2,3]\n"
"\n"
"    iex> List.delete([1, 2, 2, 3], 2)\n"
"    [1, 2, 3]\n"
"\n"

#. TRANSLATORS: def Process.delete(key)
#: lib/process.ex:70
msgid "Deletes the given `key` from the dictionary.\n"
msgstr "プロセス辞書から与えられた`key`を削除します。\n"

#. TRANSLATORS: def Keyword.delete_first(keywords, key)
#: lib/keyword.ex:282
msgid ""
"Deletes the first entry in the keyword list for a specific `key`.\n"
"\n"
"If the `key` does not exist, returns the keyword list unchanged.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.delete_first([a: 1, b: 2, a: 3], :a)\n"
"    [b: 2, a: 3]\n"
"\n"
"    iex> Keyword.delete_first([b: 2], :a)\n"
"    [b: 2]\n"
"\n"
msgstr ""
"キーワードリスト中の指定された`key`の最初のエントリを削除します。\n"
"\n"
"もし`key`が存在しないなら、変更せずにキーワードリストを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.delete_first([a: 1, b: 2, a: 3], :a)\n"
"    [b: 2, a: 3]\n"
"\n"
"    iex> Keyword.delete_first([b: 2], :a)\n"
"    [b: 2]\n"
"\n"

#. TRANSLATORS: def Keyword.delete(keywords, key)
#: lib/keyword.ex:263
msgid ""
"Deletes the entries in the keyword list for a specific `key`.\n"
"\n"
"If the `key` does not exist, returns the keyword list unchanged.\n"
"Use `delete_first/2` to delete just the first entry in case of\n"
"duplicated keys.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.delete([a: 1, b: 2], :a)\n"
"    [b: 2]\n"
"\n"
"    iex> Keyword.delete([a: 1, b: 2, a: 3], :a)\n"
"    [b: 2]\n"
"\n"
"    iex> Keyword.delete([b: 2], :a)\n"
"    [b: 2]\n"
"\n"
msgstr ""
"キーワードリスト中の指定された`key`のエントリ全てを削除します。\n"
"\n"
"もし`key`が存在しないなら、変更せずにキーワードリストを返します。\n"
"重複したキーの最初のエントリだけを削除するためには、\n"
"`delete_first/2`を使ってください。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.delete([a: 1, b: 2], :a)\n"
"    [b: 2]\n"
"\n"
"    iex> Keyword.delete([a: 1, b: 2, a: 3], :a)\n"
"    [b: 2]\n"
"\n"
"    iex> Keyword.delete([b: 2], :a)\n"
"    [b: 2]\n"
"\n"

#. TRANSLATORS: def Keyword.delete(keywords, key, value)
#: lib/keyword.ex:239
msgid ""
"Deletes the entries in the keyword list for a `key` with `value`.\n"
"\n"
"If no `key` with `value` exists, returns the keyword list unchanged.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.delete([a: 1, b: 2], :a, 1)\n"
"    [b: 2]\n"
"\n"
"    iex> Keyword.delete([a: 1, b: 2, a: 3], :a, 3)\n"
"    [a: 1, b: 2]\n"
"\n"
"    iex> Keyword.delete([b: 2], :a, 5)\n"
"    [b: 2]\n"
"\n"
msgstr ""
"キーワードリスト中の`value`を持つ`key`のエントリ全てを削除します。\n"
"\n"
"もし`value`を持つ`key`が存在しないなら、\n"
"変更せずにキーワードリストを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.delete([a: 1, b: 2], :a, 1)\n"
"    [b: 2]\n"
"\n"
"    iex> Keyword.delete([a: 1, b: 2, a: 3], :a, 3)\n"
"    [a: 1, b: 2]\n"
"\n"
"    iex> Keyword.delete([b: 2], :a, 5)\n"
"    [b: 2]\n"
"\n"

#. TRANSLATORS: defmacro Protocol.derive(protocol, module, options \\ [])
#: lib/protocol.ex:120
msgid "Derives the `protocol` for `module` with the given options.\n"
msgstr "与えられたオプションで、`module`のために`protocol`を導出します。\n"

#. TRANSLATORS: def Supervisor.delete_child(supervisor, child_id)
#: lib/supervisor.ex:313
msgid ""
"Deletes the child specification identified by `child_id`.\n"
"\n"
"The corresponding child process must not be running, use "
"`terminate_child/2`\n"
"to terminate it.\n"
"\n"
"If successful, the function returns `:ok`. This function may error with an\n"
"appropriate error tuple if the `child_id` is not found, or if the current\n"
"process is running or being restarted.\n"
"\n"
"This operation is not supported by `simple_one_for_one` supervisors.\n"
msgstr ""
"`child_id`によって識別される子仕様を削除します。\n"
"\n"
"対応する子プロセスは動作していてはいけません。それを終了するために、\n"
"`terminate_child/2`を使ってください。\n"
"\n"
"成功すると、関数は`:ok`を返します。この関数は`child_id`が見付からないか、\n"
"現在のプロセスがそれを走らせているか、再起動中なら、適切なerrorタプルと\n"
"ともにエラーとなります。\n"
"\n"
"この操作は、`simple_one_for_one`スーパバイザはサポートされません。\n"

#. TRANSLATORS: def Application.delete_env(app, key, opts \\ [])
#: lib/application.ex:178
msgid ""
"Deletes the `key` from the given `app` environment.\n"
"\n"
"See `put_env/4` for a description of the options.\n"
msgstr ""
"与えられた`app`環境から`key`を削除します。\n"
"\n"
"オプションの詳細は`put_env/4`を参照してください。\n"

#. TRANSLATORS: def Module.delete_attribute(module, key)
#: lib/module.ex:791
msgid ""
"Deletes all attributes that match the given key.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule MyModule do\n"
"      Module.put_attribute __MODULE__, :custom_threshold_for_lib, 10\n"
"      Module.delete_attribute __MODULE__, :custom_threshold_for_lib\n"
"    end\n"
"\n"
msgstr ""
"与えられたkeyにマッチする属性を全て削除します。\n"
"\n"
"## 例\n"
"\n"
"    defmodule MyModule do\n"
"      Module.put_attribute __MODULE__, :custom_threshold_for_lib, 10\n"
"      Module.delete_attribute __MODULE__, :custom_threshold_for_lib\n"
"    end\n"
"\n"

#. TRANSLATORS: def System.delete_env(varname)
#: lib/system.ex:316
msgid ""
"Deletes an environment variable.\n"
"\n"
"Removes the variable `varname` from the environment.\n"
msgstr ""
"環境変数を削除します。\n"
"\n"
"環境から変数`varname`を取り除きます。\n"

#. TRANSLATORS: def Code.delete_path(path)
#: lib/code.ex:50
msgid ""
"Deletes a path from the Erlang VM code path.\n"
"\n"
"The path is expanded with `Path.expand/1` before being deleted.\n"
msgstr ""
"Erlang VMコードパスからpathを削除します。\n"
"\n"
"pathは削除される前に、`Path.expand/1`で展開されます。\n"

#. TRANSLATORS: defmacro Kernel.defdelegate(funs, opts)
#: lib/kernel.ex:3302
msgid ""
"Defines the given functions in the current module that will\n"
"delegate to the given `target`. Functions defined with\n"
"`defdelegate` are public and are allowed to be invoked\n"
"from external. If you find yourself wishing to define a\n"
"delegation as private, you should likely use import\n"
"instead.\n"
"\n"
"Delegation only works with functions, delegating to macros\n"
"is not supported.\n"
"\n"
"## Options\n"
"\n"
"  * `:to` - the expression to delegate to. Any expression\n"
"    is allowed and its results will be calculated on runtime.\n"
"\n"
"  * `:as` - the function to call on the target given in `:to`.\n"
"    This parameter is optional and defaults to the name being\n"
"    delegated.\n"
"\n"
"  * `:append_first` - if true, when delegated, first argument\n"
"    passed to the delegate will be relocated to the end of the\n"
"    arguments when dispatched to the target.\n"
"\n"
"    The motivation behind this is because Elixir normalizes\n"
"    the \"handle\" as a first argument and some Erlang modules\n"
"    expect it as last argument.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule MyList do\n"
"      defdelegate reverse(list), to: :lists\n"
"      defdelegate [reverse(list), map(callback, list)], to: :lists\n"
"      defdelegate other_reverse(list), to: :lists, as: :reverse\n"
"    end\n"
"\n"
"    MyList.reverse([1, 2, 3])\n"
"    #=> [3,2,1]\n"
"\n"
"    MyList.other_reverse([1, 2, 3])\n"
"    #=> [3,2,1]\n"
"\n"
msgstr ""
"与えられた`target`へ移譲する、\n"
"現在のモジュールで与えられた関数を\n"
"定義します。\n"
"`defdelegate`で定義された関数は、\n"
"パブリックで、外部から起動することができます。\n"
"もしプライベートとして移譲を定義したいと\n"
"思うなら、importを代りに使うべきです。\n"
"\n"
"移譲は関数でのみ動きます。マクロの移譲はサポートしていません。\n"
"\n"
"## オプション\n"
"\n"
"  * `:to` -  移譲先の式。\n"
"    任意の式が許され、戻値は実行時に計算されます。\n"
"\n"
"  * `:as` -  `:to`で与えられたターゲットを呼ぶ関数です。\n"
"    このパラメタはオプションで、デフォルトは移譲された名前です。\n"
"\n"
"  * `:append_first` -  trueなら、移譲されたとき、\n"
"    移譲先へ渡す最初の引数は、ターゲットへディスパッチするときに\n"
"    引数の最後に再配置されます。\n"
"\n"
"    この背後の動機は、\n"
"    Elixirは最初の引数として、\n"
"    いくつかのErlangモジュールが最後の\n"
"    引数として期待している\"handle\"を、正規化するからです。\n"
"\n"
"## 例\n"
"\n"
"    defmodule MyList do\n"
"      defdelegate reverse(list), to: :lists\n"
"      defdelegate [reverse(list), map(callback, list)], to: :lists\n"
"      defdelegate other_reverse(list), to: :lists, as: :reverse\n"
"    end\n"
"\n"
"    MyList.reverse([1, 2, 3])\n"
"    #=> [3,2,1]\n"
"\n"
"    MyList.other_reverse([1, 2, 3])\n"
"    #=> [3,2,1]\n"
"\n"

#. TRANSLATORS: def Set.delete(set, value)
#: lib/set.ex:74
msgid ""
"Deletes `value` from `set`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> s = Enum.into([1, 2, 3], set_impl.new)\n"
"    iex> Set.delete(s, 4) |> Enum.sort\n"
"    [1, 2, 3]\n"
"\n"
"    iex> s = Enum.into([1, 2, 3], set_impl.new)\n"
"    iex> Set.delete(s, 2) |> Enum.sort\n"
"    [1, 3]\n"
"\n"
msgstr ""
"`set`から`value`を削除します。\n"
"\n"
"## 例\n"
"\n"
"    iex> s = Enum.into([1, 2, 3], set_impl.new)\n"
"    iex> Set.delete(s, 4) |> Enum.sort\n"
"    [1, 2, 3]\n"
"\n"
"    iex> s = Enum.into([1, 2, 3], set_impl.new)\n"
"    iex> Set.delete(s, 2) |> Enum.sort\n"
"    [1, 3]\n"
"\n"

#. TRANSLATORS: def Supervisor.Spec.worker(module, args, options \\ [])
#: lib/supervisor/spec.ex:206
msgid ""
"Defines the given `module` as a worker which will be started\n"
"with the given arguments.\n"
"\n"
"    worker ExUnit.Runner, [], restart: :permanent\n"
"\n"
"By default, the function `start_link` is invoked on the given\n"
"module. Overall, the default values for the options are:\n"
"\n"
"    [id: module,\n"
"     function: :start_link,\n"
"     restart: :permanent,\n"
"     shutdown: 5000,\n"
"     modules: [module]]\n"
"\n"
"Check `Supervisor.Spec` module docs for more information on\n"
"the options.\n"
msgstr ""
"与えられた引数で開始するワーカーとして、\n"
"与えられた`module`を定義します。\n"
"\n"
"    worker ExUnit.Runner, [], restart: :permanent\n"
"\n"
"デフォルトで、`start_link`関数が与えられたモジュールで\n"
"起動されます。全体として、オプションのデフォルト値は以下の通りです:\n"
"\n"
"    [id: module,\n"
"     function: :start_link,\n"
"     restart: :permanent,\n"
"     shutdown: 5000,\n"
"     modules: [module]]\n"
"\n"
"オプションの詳細は `Supervisor.Spec` モジュールドキュメントを\n"
"チェックしてください。\n"

#. TRANSLATORS: def Supervisor.Spec.supervisor(module, args, options \\ [])
#: lib/supervisor/spec.ex:230
msgid ""
"Defines the given `module` as a supervisor which will be started\n"
"with the given arguments.\n"
"\n"
"    supervisor ExUnit.Runner, [], restart: :permanent\n"
"\n"
"By default, the function `start_link` is invoked on the given\n"
"module. Overall, the default values for the options are:\n"
"\n"
"    [id: module,\n"
"     function: :start_link,\n"
"     restart: :permanent,\n"
"     shutdown: :infinity,\n"
"     modules: [module]]\n"
"\n"
"Check `Supervisor.Spec` module docs for more information on\n"
"the options.\n"
msgstr ""
"与えられた引数で開始するスーパバイザとして、\n"
"与えられた`module`を定義します。\n"
"\n"
"    supervisor ExUnit.Runner, [], restart: :permanent\n"
"\n"
"デフォルトで、`start_link`関数が与えられたモジュールで\n"
"起動されます。全体として、オプションのデフォルト値は以下の通りです:\n"
"\n"
"    [id: module,\n"
"     function: :start_link,\n"
"     restart: :permanent,\n"
"     shutdown: :infinity,\n"
"     modules: [module]]\n"
"\n"
"オプションの詳細は `Supervisor.Spec` モジュールドキュメントを\n"
"チェックしてください。\n"

#. TRANSLATORS: Elixir.Tuple Summary
#: lib/tuple.ex:1
msgid "Functions for working with tuples.\n"
msgstr "タプルで動く関数です。\n"

#. TRANSLATORS: Elixir.Protocol Summary
#: lib/protocol.ex:1
msgid "Functions for working with protocols.\n"
msgstr "プロトコルで動く関数です。\n"

#. TRANSLATORS: Elixir.Integer Summary
#: lib/integer.ex:1
msgid "Functions for working with integers.\n"
msgstr "整数で動く関数です\n"

#. TRANSLATORS: Elixir.Float Summary
#: lib/float.ex:3
msgid "Functions for working with floating point numbers.\n"
msgstr "浮動小数点数で動く関数です。\n"

#. TRANSLATORS: Elixir.Version Summary
#: lib/version.ex:1
msgid ""
"Functions for parsing and matching versions against requirements.\n"
"\n"
"A version is a string in a specific format or a `Version`\n"
"generated after parsing via `Version.parse/1`.\n"
"\n"
"`Version` parsing and requirements follow\n"
"[SemVer 2.0 schema](http://semver.org/).\n"
"\n"
"## Versions\n"
"\n"
"In a nutshell, a version is given by three numbers:\n"
"\n"
"    MAJOR.MINOR.PATCH\n"
"\n"
"Pre-releases are supported by appending `-[0-9A-Za-z-\\.]`:\n"
"\n"
"    \"1.0.0-alpha.3\"\n"
"\n"
"Build information can be added by appending `+[0-9A-Za-z-\\.]`:\n"
"\n"
"    \"1.0.0-alpha.3+20130417140000\"\n"
"\n"
"## Struct\n"
"\n"
"The version is represented by the Version struct and it has its\n"
"fields named according to Semver: `:major`, `:minor`, `:patch`,\n"
"`:pre` and `:build`.\n"
"\n"
"## Requirements\n"
"\n"
"Requirements allow you to specify which versions of a given\n"
"dependency you are willing to work against. It supports common\n"
"operators like `>=`, `<=`, `>`, `==` and friends that\n"
"work as one would expect:\n"
"\n"
"    # Only version 2.0.0\n"
"    \"== 2.0.0\"\n"
"\n"
"    # Anything later than 2.0.0\n"
"    \"> 2.0.0\"\n"
"\n"
"Requirements also support `and` and `or` for complex conditions:\n"
"\n"
"    # 2.0.0 and later until 2.1.0\n"
"    \">= 2.0.0 and < 2.1.0\"\n"
"\n"
"Since the example above is such a common requirement, it can\n"
"be expressed as:\n"
"\n"
"    \"~> 2.0.0\"\n"
"\n"
msgstr ""
"バージョンを必要条件に対してパースとマッチングをする\n"
"関数です。\n"
"\n"
"バージョンは指定されたフォーマットの文字列または、\n"
"`Version.parse/1`によってパースされて生成された、\n"
"`Version`です。\n"
"\n"
"`Version`のパースと要求条件は\n"
"[SemVer 2.0 schema](http://semver.org/)\n"
"に従います。\n"
"\n"
"## Versions\n"
"\n"
"簡単に言えば、バージョンは3つの番号により与えられます:\n"
"\n"
"    MAJOR.MINOR.PATCH\n"
"\n"
"`-[0-9A-Za-z-\\.]`を追加することによって、プレリリースがサポートされます:\n"
"\n"
"    \"1.0.0-alpha.3\"\n"
"\n"
"`+[0-9A-Za-z-\\.]`の追加によってビルドインフォメーションを付け加えること\n"
"が出来ます:\n"
"\n"
"    \"1.0.0-alpha.3+20130417140000\"\n"
"\n"
"## Struct\n"
"\n"
"バージョンはVersion構造体により表現され、Semverに従って\n"
"名付けられたフィールドを持っています: `:major`, `:minor`, `:patch`, \n"
"`:pre`, `:build`\n"
"\n"
"## Requirements\n"
"\n"
"必要条件は、与えられた依存関係のどのバージョンに対して対応する気がある\n"
"かを、指定することが出来ます。`>=`, `<=`, `>`, `==`とその仲間のような、\n"
"人が動くと予想するような一般的なオペレータをサポートしています:\n"
"\n"
"    # Only version 2.0.0\n"
"    \"== 2.0.0\"\n"
"\n"
"    # Anything later than 2.0.0\n"
"    \"> 2.0.0\"\n"
"\n"
"必要条件は複雑な条件のため、`and`や`or`もサポートしています:\n"
"\n"
"    # 2.0.0 and later until 2.1.0\n"
"    \">= 2.0.0 and < 2.1.0\"\n"
"\n"
"上記の例は、一般的な必要条件なので、以下のように表現できます:\n"
"\n"
"    \"~> 2.0.0\"\n"
"\n"

#. TRANSLATORS: Elixir.IO.ANSI Summary
#: lib/io/ansi.ex:17
msgid ""
"Functionality to render ANSI escape sequences\n"
"(http://en.wikipedia.org/wiki/ANSI_escape_code) —  characters embedded\n"
"in text used to control formatting, color, and other output options\n"
"on video text terminals.\n"
msgstr ""
"ANSIエスケープシーケンス\n"
"(http://en.wikipedia.org/wiki/ANSI_escape_code)\n"
"  —  \n"
"ビデオ・テキスト端末に、フォーマット、色、その他出力オプションを制御す\n"
"るためにテキストに埋め込まれる文字、をレンダリングする関数群です\n"

#. TRANSLATORS: def IO.ANSI.framed()
#: lib/io/ansi.ex:114
msgid "Framed"
msgstr "フレーム化"

#. TRANSLATORS: def Set.put(set, value)
#: lib/set.ex:237
msgid ""
"Inserts `value` into `set` if it does not already contain it.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Set.put(Enum.into([1, 2, 3], set_impl.new), 3) |> Enum.sort\n"
"    [1, 2, 3]\n"
"\n"
"    iex> Set.put(Enum.into([1, 2, 3], set_impl.new), 4) |> Enum.sort\n"
"    [1, 2, 3, 4]\n"
"\n"
msgstr ""
"もしまだそれを含んでいないなら、`set`に`value`を挿入します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Set.put(Enum.into([1, 2, 3], set_impl.new), 3) |> Enum.sort\n"
"    [1, 2, 3]\n"
"\n"
"    iex> Set.put(Enum.into([1, 2, 3], set_impl.new), 4) |> Enum.sort\n"
"    [1, 2, 3, 4]\n"
"\n"

#. TRANSLATORS: def Stream.into(enum, collectable, transform \\ fn x -> x end)
#: lib/stream.ex:371
msgid ""
"Injects the stream values into the given collectable as a side-effect.\n"
"\n"
"This function is often used with `run/1` since any evaluation\n"
"is delayed until the stream is executed. See `run/1` for an example.\n"
msgstr ""
"副作用として、与えられたcollectableにストリームの値を注入します。\n"
"\n"
"この関数は、ストリームが実行されるまでは、任意の評価が\n"
"遅延されるため、しばしば`run/1`と一緒に使われます。\n"
"例は`run/1`を参照してください。\n"

#. TRANSLATORS: defmacro Kernel.sigil_w(arg1, modifiers)
#: lib/kernel.ex:3473
msgid ""
"Handles the sigil ~w. It returns a list of \"words\" split by whitespace.\n"
"\n"
"## Modifiers\n"
"\n"
"  * `s`: strings (default)\n"
"  * `a`: atoms\n"
"  * `c`: char lists\n"
"\n"
"## Examples\n"
"\n"
"    iex> ~w(foo #{:bar} baz)\n"
"    [\"foo\", \"bar\", \"baz\"]\n"
"\n"
"    iex> ~w(--source test/enum_test.exs)\n"
"    [\"--source\", \"test/enum_test.exs\"]\n"
"\n"
"    iex> ~w(foo bar baz)a\n"
"    [:foo, :bar, :baz]\n"
"\n"
msgstr ""
"sigil ~wをハンドルします。空白によって区切られた\"words\"のリストを返しま"
"す。\n"
"\n"
"## モディファイア\n"
"\n"
"  * `s`: 文字列 (デフォルト)\n"
"  * `a`: アトム\n"
"  * `c`: 文字のリスト\n"
"\n"
"## 例\n"
"\n"
"    iex> ~w(foo #{:bar} baz)\n"
"    [\"foo\", \"bar\", \"baz\"]\n"
"\n"
"    iex> ~w(--source test/enum_test.exs)\n"
"    [\"--source\", \"test/enum_test.exs\"]\n"
"\n"
"    iex> ~w(foo bar baz)a\n"
"    [:foo, :bar, :baz]\n"
"\n"

#. TRANSLATORS: defmacro Kernel.sigil_s(arg1, list2)
#: lib/kernel.ex:3367
msgid ""
"Handles the sigil ~s. It returns a string as if it was double quoted\n"
"string, unescaping characters and replacing interpolations.\n"
"\n"
"## Examples\n"
"\n"
"    iex> ~s(foo)\n"
"    \"foo\"\n"
"\n"
"    iex> ~s(f#{:o}o)\n"
"    \"foo\"\n"
"\n"
"    iex> ~s(f\\#{:o}o)\n"
"    \"f\\#{:o}o\"\n"
"\n"
msgstr ""
"sigil ~sをハンドルします。\n"
"まるで二重引用苻付きの文字列であるかのように、文字列を\n"
"返します。そして文字のアンエスケープと、内挿の置き換えをします。\n"
"\n"
"## 例\n"
"\n"
"    iex> ~s(foo)\n"
"    \"foo\"\n"
"\n"
"    iex> ~s(f#{:o}o)\n"
"    \"foo\"\n"
"\n"
"    iex> ~s(f\\#{:o}o)\n"
"    \"f\\#{:o}o\"\n"
"\n"

#. TRANSLATORS: defmacro Kernel.sigil_r(arg1, options)
#: lib/kernel.ex:3425
msgid ""
"Handles the sigil ~r. It returns a Regex pattern.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.match?(~r(foo), \"foo\")\n"
"    true\n"
"\n"
msgstr ""
"sigil ~rをハンドルします。\n"
"Regexパターンを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Regex.match?(~r(foo), \"foo\")\n"
"    true\n"
"\n"

#. TRANSLATORS: defmacro Kernel.sigil_c(arg1, list2)
#: lib/kernel.ex:3407
msgid ""
"Handles the sigil ~c. It returns a char list as if it were a single\n"
"quoted string, unescaping characters and replacing interpolations.\n"
"\n"
"## Examples\n"
"\n"
"    iex> ~c(foo)\n"
"    'foo'\n"
"\n"
"    iex> ~c(f#{:o}o)\n"
"    'foo'\n"
"\n"
"    iex> ~c(f\\#{:o}o)\n"
"    'f\\#{:o}o'\n"
"\n"
msgstr ""
"sigil ~cをハンドルします。\n"
"まるで一重引用苻付きの文字列であるかのように、文字のリストを\n"
"返します。そして文字のアンエスケープと、内挿の置き換えをします。\n"
"\n"
"## 例\n"
"\n"
"    iex> ~c(foo)\n"
"    'foo'\n"
"\n"
"    iex> ~c(f#{:o}o)\n"
"    'foo'\n"
"\n"
"    iex> ~c(f\\#{:o}o)\n"
"    'f\\#{:o}o'\n"
"\n"

#. TRANSLATORS: defmacro Kernel.sigil_W(arg1, modifiers)
#: lib/kernel.ex:3498
msgid ""
"Handles the sigil ~W. It returns a list of \"words\" split by whitespace\n"
"without escaping nor interpreting interpolations.\n"
"\n"
"## Modifiers\n"
"\n"
"  * `s`: strings (default)\n"
"  * `a`: atoms\n"
"  * `c`: char lists\n"
"\n"
"## Examples\n"
"\n"
"    iex> ~W(foo #{bar} baz)\n"
"    [\"foo\", \"\\#{bar}\", \"baz\"]\n"
"\n"
msgstr ""
"sigil ~Wをハンドルします。エスケープも内挿の解釈もすることなく、空白に\n"
"よって区切られた\"words\"のリストを返します。\n"
"\n"
"## モディファイア\n"
"\n"
"  * `s`: 文字列 (デフォルト)\n"
"  * `a`: アトム\n"
"  * `c`: 文字のリスト\n"
"\n"
"## 例\n"
"\n"
"    iex> ~W(foo #{bar} baz)\n"
"    [\"foo\", \"\\#{bar}\", \"baz\"]\n"
"\n"

#. TRANSLATORS: defmacro Kernel.sigil_S(string, list2)
#: lib/kernel.ex:3347
msgid ""
"Handles the sigil ~S. It simply returns a string\n"
"without escaping characters and without interpolations.\n"
"\n"
"## Examples\n"
"\n"
"    iex> ~S(foo)\n"
"    \"foo\"\n"
"\n"
"    iex> ~S(f#{o}o)\n"
"    \"f\\#{o}o\"\n"
"\n"
msgstr ""
"sigil ~Sをハンドルします。エスケープも内挿の解釈もすることなく、単に文\n"
"字列を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> ~S(foo)\n"
"    \"foo\"\n"
"\n"
"    iex> ~S(f#{o}o)\n"
"    \"f\\#{o}o\"\n"
"\n"

#. TRANSLATORS: defmacro Kernel.sigil_R(arg1, options)
#: lib/kernel.ex:3446
msgid ""
"Handles the sigil ~R. It returns a Regex pattern without escaping\n"
"nor interpreting interpolations.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.match?(~R(f#{1,3}o), \"f#o\")\n"
"    true\n"
"\n"
msgstr ""
"sigil ~Rをハンドルします。エスケープも内挿の解釈もすることなく、Regexパ\n"
"ターンを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Regex.match?(~R(f#{1,3}o), \"f#o\")\n"
"    true\n"
"\n"

#. TRANSLATORS: defmacro Kernel.sigil_C(arg1, list2)
#: lib/kernel.ex:3384
msgid ""
"Handles the sigil ~C. It simply returns a char list\n"
"without escaping characters and without interpolations.\n"
"\n"
"## Examples\n"
"\n"
"    iex> ~C(foo)\n"
"    'foo'\n"
"\n"
"    iex> ~C(f#{o}o)\n"
"    'f\\#{o}o'\n"
"\n"
msgstr ""
"sigil ~Cをハンドルします。エスケープも内挿の解釈もすることなく、単に\n"
"文字のリストを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> ~C(foo)\n"
"    'foo'\n"
"\n"
"    iex> ~C(f#{o}o)\n"
"    'f\\#{o}o'\n"
"\n"

#. TRANSLATORS: Elixir.Kernel.SpecialForms Summary
#: lib/kernel/special_forms.ex:1
msgid ""
"In this module we define Elixir special forms. Special forms\n"
"cannot be overridden by the developer and are the basic\n"
"building blocks of Elixir code.\n"
"\n"
"Some of those forms are lexical (like `alias`, `case`, etc).\n"
"The macros `{}` and `<<>>` are also special forms used to define\n"
"tuple and binary data structures respectively.\n"
"\n"
"This module also documents Elixir's pseudo variables (`__ENV__`,\n"
"`__MODULE__`, `__DIR__` and `__CALLER__`). Pseudo variables return\n"
"information about Elixir's compilation environment and can only\n"
"be read, never assigned to.\n"
"\n"
"Finally, it also documents 2 special forms, `__block__` and\n"
"`__aliases__`, which are not intended to be called directly by the\n"
"developer but they appear in quoted contents since they are essential\n"
"in Elixir's constructs.\n"
msgstr ""
"このモジュールで、Elixirのスペシャルフォームを定義します。\n"
"スペシャルフォームは開発者によってオーバライド出来ず、\n"
"Elixirコードの基本的なビルディングブロックです。\n"
"\n"
"それらのフォームの幾つかは、レキシカル( `alias` 、 `case` など)です。\n"
"マクロ `{}` と `<<>>` もまた、タプルとバイナリデータ構造を表現するために\n"
"使われる、スペシャルフォームです。\n"
"\n"
"このモジュールはElixirの仮想変数(`__ENV__`、`__MODULE__`、`__DIR__`そして\n"
"`__CALLER__`)についてドキュメント化しています。\n"
"仮想変数はElixirのコンパイル環境についての情報を返し、\n"
"リードオンリーで、代入は決してできません。\n"
"\n"
"最後に、2つのスペシャルフォーム`__block__`と`__aliases__`についても\n"
"ドキュメント化しています。それらは、開発者から直接呼ばれることを\n"
"目的としていませんが、Elixirの構成概念にとって本質的な、\n"
"quoteされたコンテンツで表れます。\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.import(module, opts)
#: lib/kernel/special_forms.ex:579
msgid ""
"Imports function and macros from other modules.\n"
"\n"
"`import` allows one to easily access functions or macros from\n"
"others modules without using the qualified name.\n"
"\n"
"## Examples\n"
"\n"
"If you are using several functions from a given module, you can\n"
"import those functions and reference them as local functions,\n"
"for example:\n"
"\n"
"    iex> import List\n"
"    iex> flatten([1, [2], 3])\n"
"    [1,2,3]\n"
"\n"
"## Selector\n"
"\n"
"By default, Elixir imports functions and macros from the given\n"
"module, except the ones starting with underscore (which are\n"
"usually callbacks):\n"
"\n"
"    import List\n"
"\n"
"A developer can filter to import only macros or functions via\n"
"the only option:\n"
"\n"
"    import List, only: :functions\n"
"    import List, only: :macros\n"
"\n"
"Alternatively, Elixir allows a developer to pass pairs of\n"
"name/arities to `:only` or `:except` as a fine grained control\n"
"on what to import (or not):\n"
"\n"
"    import List, only: [flatten: 1]\n"
"    import String, except: [split: 2]\n"
"\n"
"Notice that calling `except` for a previously declared `import`\n"
"simply filters the previously imported elements. For example:\n"
"\n"
"    import List, only: [flatten: 1, keyfind: 3]\n"
"    import List, except: [flatten: 1]\n"
"\n"
"After the two import calls above, only `List.keyfind/3` will be\n"
"imported.\n"
"\n"
"## Lexical scope\n"
"\n"
"It is important to notice that `import` is lexical. This means you\n"
"can import specific macros inside specific functions:\n"
"\n"
"    defmodule Math do\n"
"      def some_function do\n"
"        # 1) Disable `if/2` from Kernel\n"
"        import Kernel, except: [if: 2]\n"
"\n"
"        # 2) Require the new `if` macro from MyMacros\n"
"        import MyMacros\n"
"\n"
"        # 3) Use the new macro\n"
"        if do_something, it_works\n"
"      end\n"
"    end\n"
"\n"
"In the example above, we imported macros from `MyMacros`,\n"
"replacing the original `if/2` implementation by our own\n"
"within that specific function. All other functions in that\n"
"module will still be able to use the original one.\n"
"\n"
"## Warnings\n"
"\n"
"If you import a module and you don't use any of the imported\n"
"functions or macros from this module, Elixir is going to issue\n"
"a warning implying the import is not being used.\n"
"\n"
"In case the import is generated automatically by a macro,\n"
"Elixir won't emit any warnings though, since the import\n"
"was not explicitly defined.\n"
"\n"
"Both warning behaviours could be changed by explicitly\n"
"setting the `:warn` option to true or false.\n"
"\n"
"## Ambiguous function/macro names\n"
"\n"
"If two modules `A` and `B` are imported and they both contain\n"
"a `foo` function with an arity of `1`, an error is only emitted\n"
"if an ambiguous call to `foo/1` is actually made; that is, the\n"
"errors are emitted lazily, not eagerly.\n"
msgstr ""
"関数とマクロを他のモジュールからインポートします。\n"
"\n"
"`import`は修飾された名前を使うことなく他のモジュールから\n"
"関数やマクロに容易にアクセスすることを許します。\n"
"\n"
"## 例\n"
"\n"
"もし与えられたモジュールから、いくつかの関数を使っているなら、\n"
"それらの関数をimportしてローカル関数としてそれらを参照することが\n"
"できます。例えば:\n"
"\n"
"    iex> import List\n"
"    iex> flatten([1, [2], 3])\n"
"    [1,2,3]\n"
"\n"
"## セレクタ\n"
"\n"
"デフォルトでは、Elixirは与えられたモジュールから、下線で始まるもの(それ\n"
"は通常コールバックです)以外の関数とマクロをインポートします:\n"
"\n"
"    import List\n"
"\n"
"開発者はマクロだけ、あるいは関数だけをインポートするために、\n"
"onlyオプションにより、フィルタすることが出来ます:\n"
"\n"
"    import List, only: :functions\n"
"    import List, only: :macros\n"
"\n"
"あるいは、Elixirは開発者に、何をインポートするか(また、何をしないか)の\n"
"きめ細かい制御として、`:only`あるいは`:except`に名前/アリティのペアを\n"
"渡すことを許しています:\n"
"\n"
"    import List, only: [flatten: 1]\n"
"    import String, except: [split: 2]\n"
"\n"
"以前に宣言された`import`のために`except`を呼ぶことは、単に以前にインポー\n"
"トされた要素をフィルタすることに、注意してください。例えば:\n"
"\n"
"    import List, only: [flatten: 1, keyfind: 3]\n"
"    import List, except: [flatten: 1]\n"
"\n"
"上の二つのimportの呼び出しの後で、`List.keyfind/3`だけがインポート\n"
"されます。\n"
"\n"
"## レキシカルスコープ\n"
"\n"
"`import`がレキシカルであることに注意することは重要です。\n"
"これは特定の関数の中で特定のマクロをインポートできることを\n"
"意味します:\n"
"\n"
"    defmodule Math do\n"
"      def some_function do\n"
"        # 1) Disable `if/2` from Kernel\n"
"        import Kernel, except: [if: 2]\n"
"\n"
"        # 2) Require the new `if` macro from MyMacros\n"
"        import MyMacros\n"
"\n"
"        # 3) Use the new macro\n"
"        if do_something, it_works\n"
"      end\n"
"    end\n"
"\n"
"上の例では、`MyMacros`からマクロをインポートし、\n"
"特定の関数の範囲内で、オリジナルの`if/2`実装を取り替えました。\n"
"そのモジュールの他の全ての関数は、まだオリジナルのものを\n"
"使うことができます。\n"
"\n"
"## 警告\n"
"\n"
"もしモジュールをインポートし、そのモジュールから\n"
"インポートされた関数やマクロを全く使わなかったら、Elixirは\n"
"インポートが使われていないことを意味する警告を発するでしょう。\n"
"\n"
"インポートがマクロによって自動的に生成された場合に備えて、\n"
"Elixirは明示的にimportが定義されない時は、いかなる警告も\n"
"発しません。\n"
"\n"
"両方の警告の振る舞いは`:warn`オプションをtrueかfalseに\n"
"明示的に設定することで変更できます。\n"
"\n"
"## 曖昧な関数/マクロ名\n"
"\n"
"もし、二つのモジュール`A`と`B`がインポートされ、それら両方が\n"
"アリティ1の`foo`関数を含んでいたら、\n"
"曖昧な`foo/1`への呼び出しが実際に起きたとき、エラーが発生します;\n"
"つまり、エラーはeagerではなく、lazyで発行されます。\n"

#. TRANSLATORS: def Keyword.get(keywords, key, default \\ nil)
#: lib/keyword.ex:118
msgid ""
"Gets the value for a specific `key`.\n"
"\n"
"If `key` does not exist, return the default value (`nil` if no default "
"value).\n"
"\n"
"If duplicated entries exist, the first one is returned.\n"
"Use `get_values/2` to retrieve all entries.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.get([a: 1], :a)\n"
"    1\n"
"\n"
"    iex> Keyword.get([a: 1], :b)\n"
"    nil\n"
"\n"
"    iex> Keyword.get([a: 1], :b, 3)\n"
"    3\n"
"\n"
msgstr ""
"指定された`key`の値を取得します。\n"
"\n"
"`key`が存在しないなら、デフォルト値(デフォルト値が\n"
"ないなら、`nil`)を返します。\n"
"\n"
"もし重複したエントリが存在したら、最初のものが返ります。\n"
"全てのエントリを取り出すには`get_values/2`を使用してください。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.get([a: 1], :a)\n"
"    1\n"
"\n"
"    iex> Keyword.get([a: 1], :b)\n"
"    nil\n"
"\n"
"    iex> Keyword.get([a: 1], :b, 3)\n"
"    3\n"
"\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.quote(opts, block)
#: lib/kernel/special_forms.ex:1098
msgid ""
"Gets the representation of any expression.\n"
"\n"
"## Examples\n"
"\n"
"    quote do: sum(1, 2, 3)\n"
"    #=> {:sum, [], [1, 2, 3]}\n"
"\n"
"## Explanation\n"
"\n"
"Any Elixir code can be represented using Elixir data structures.\n"
"The building block of Elixir macros is a tuple with three elements,\n"
"for example:\n"
"\n"
"    {:sum, [], [1, 2, 3]}\n"
"\n"
"The tuple above represents a function call to `sum` passing 1, 2 and\n"
"3 as arguments. The tuple elements are:\n"
"\n"
"  * The first element of the tuple is always an atom or\n"
"    another tuple in the same representation.\n"
"\n"
"  * The second element of the tuple represents metadata.\n"
"\n"
"  * The third element of the tuple are the arguments for the\n"
"    function call. The third argument may be an atom, which is\n"
"    usually a variable (or a local call).\n"
"\n"
"## Options\n"
"\n"
"  * `:unquote` - when false, disables unquoting. Useful when you have a "
"quote\n"
"    inside another quote and want to control what quote is able to unquote.\n"
"\n"
"  * `:location` - when set to `:keep`, keeps the current line and file from\n"
"    quote. Read the Stacktrace information section below for more\n"
"    information.\n"
"\n"
"  * `:context` - sets the resolution context.\n"
"\n"
"  * `:bind_quoted` - passes a binding to the macro. Whenever a binding is\n"
"    given, `unquote` is automatically disabled.\n"
"\n"
"## Quote literals\n"
"\n"
"Besides the tuple described above, Elixir has a few literals that\n"
"when quoted return themselves. They are:\n"
"\n"
"    :sum         #=> Atoms\n"
"    1            #=> Integers\n"
"    2.0          #=> Floats\n"
"    [1, 2]       #=> Lists\n"
"    \"strings\"    #=> Strings\n"
"    {key, value} #=> Tuples with two elements\n"
"\n"
"## Quote and macros\n"
"\n"
"`quote` is commonly used with macros for code generation. As an exercise,\n"
"let's define a macro that multiplies a number by itself (squared). Note\n"
"there is no reason to define such as a macro (and it would actually be\n"
"seen as a bad practice), but it is simple enough that it allows us to focus\n"
"on the important aspects of quotes and macros:\n"
"\n"
"    defmodule Math do\n"
"      defmacro squared(x) do\n"
"        quote do\n"
"          unquote(x) * unquote(x)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"We can invoke it as:\n"
"\n"
"    import Math\n"
"    IO.puts \"Got #{squared(5)}\"\n"
"\n"
"At first, there is nothing in this example that actually reveals it is a\n"
"macro. But what is happening is that, at compilation time, `squared(5)`\n"
"becomes `5 * 5`. The argument `5` is duplicated in the produced code, we\n"
"can see this behaviour in practice though because our macro actually has\n"
"a bug:\n"
"\n"
"    import Math\n"
"    my_number = fn ->\n"
"      IO.puts \"Returning 5\"\n"
"      5\n"
"    end\n"
"    IO.puts \"Got #{squared(my_number.())}\"\n"
"\n"
"The example above will print:\n"
"\n"
"    Returning 5\n"
"    Returning 5\n"
"    25\n"
"\n"
"Notice how \"Returning 5\" was printed twice, instead of just once. This is\n"
"because a macro receives an expression and not a value (which is what we\n"
"would expect in a regular function). This means that:\n"
"\n"
"    squared(my_number.())\n"
"\n"
"Actually expands to:\n"
"\n"
"    my_number.() * my_number.()\n"
"\n"
"Which invokes the function twice, explaining why we get the printed value\n"
"twice! In the majority of the cases, this is actually unexpected behaviour,\n"
"and that's why one of the first things you need to keep in mind when it\n"
"comes to macros is to **not unquote the same value more than once**.\n"
"\n"
"Let's fix our macro:\n"
"\n"
"    defmodule Math do\n"
"      defmacro squared(x) do\n"
"        quote do\n"
"          x = unquote(x)\n"
"          x * x\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"Now invoking `square(my_number.())` as before will print the value just\n"
"once.\n"
"\n"
"In fact, this pattern is so common that most of the times you will want\n"
"to use the `bind_quoted` option with `quote`:\n"
"\n"
"    defmodule Math do\n"
"      defmacro squared(x) do\n"
"        quote bind_quoted: [x: x] do\n"
"          x * x\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"`:bind_quoted` will translate to the same code as the example above.\n"
"`:bind_quoted` can be used in many cases and is seen as good practice,\n"
"not only because it helps us from running into common mistakes but also\n"
"because it allows us to leverage other tools exposed by macros, such as\n"
"unquote fragments discussed in some sections below.\n"
"\n"
"Before we finish this brief introduction, you will notice that, even though\n"
"we defined a variable `x` inside our quote:\n"
"\n"
"    quote do\n"
"      x = unquote(x)\n"
"      x * x\n"
"    end\n"
"\n"
"When we call:\n"
"\n"
"    import Math\n"
"    squared(5)\n"
"    x #=> ** (RuntimeError) undefined function or variable: x\n"
"\n"
"We can see that `x` did not leak to the user context. This happens\n"
"because Elixir macros are hygienic, a topic we will discuss at length\n"
"in the next sections as well.\n"
"\n"
"## Hygiene in variables\n"
"\n"
"Consider the following example:\n"
"\n"
"    defmodule Hygiene do\n"
"      defmacro no_interference do\n"
"        quote do: a = 1\n"
"      end\n"
"    end\n"
"\n"
"    require Hygiene\n"
"\n"
"    a = 10\n"
"    Hygiene.no_interference\n"
"    a #=> 10\n"
"\n"
"In the example above, `a` returns 10 even if the macro\n"
"is apparently setting it to 1 because variables defined\n"
"in the macro does not affect the context the macro is executed in.\n"
"If you want to set or get a variable in the caller's context, you\n"
"can do it with the help of the `var!` macro:\n"
"\n"
"    defmodule NoHygiene do\n"
"      defmacro interference do\n"
"        quote do: var!(a) = 1\n"
"      end\n"
"    end\n"
"\n"
"    require NoHygiene\n"
"\n"
"    a = 10\n"
"    NoHygiene.interference\n"
"    a #=> 1\n"
"\n"
"Note that you cannot even access variables defined in the same\n"
"module unless you explicitly give it a context:\n"
"\n"
"    defmodule Hygiene do\n"
"      defmacro write do\n"
"        quote do\n"
"          a = 1\n"
"        end\n"
"      end\n"
"\n"
"      defmacro read do\n"
"        quote do\n"
"          a\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    Hygiene.write\n"
"    Hygiene.read\n"
"    #=> ** (RuntimeError) undefined function or variable: a\n"
"\n"
"For such, you can explicitly pass the current module scope as\n"
"argument:\n"
"\n"
"    defmodule ContextHygiene do\n"
"      defmacro write do\n"
"        quote do\n"
"          var!(a, ContextHygiene) = 1\n"
"        end\n"
"      end\n"
"\n"
"      defmacro read do\n"
"        quote do\n"
"          var!(a, ContextHygiene)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    ContextHygiene.write\n"
"    ContextHygiene.read\n"
"    #=> 1\n"
"\n"
"## Hygiene in aliases\n"
"\n"
"Aliases inside quote are hygienic by default.\n"
"Consider the following example:\n"
"\n"
"    defmodule Hygiene do\n"
"      alias HashDict, as: D\n"
"\n"
"      defmacro no_interference do\n"
"        quote do: D.new\n"
"      end\n"
"    end\n"
"\n"
"    require Hygiene\n"
"    Hygiene.no_interference #=> #HashDict<[]>\n"
"\n"
"Notice that, even though the alias `D` is not available\n"
"in the context the macro is expanded, the code above works\n"
"because `D` still expands to `HashDict`.\n"
"\n"
"Similarly, even if we defined an alias with the same name\n"
"before invoking a macro, it won't affect the macro's result:\n"
"\n"
"    defmodule Hygiene do\n"
"      alias HashDict, as: D\n"
"\n"
"      defmacro no_interference do\n"
"        quote do: D.new\n"
"      end\n"
"    end\n"
"\n"
"    require Hygiene\n"
"    alias SomethingElse, as: D\n"
"    Hygiene.no_interference #=> #HashDict<[]>\n"
"\n"
"In some cases, you want to access an alias or a module defined\n"
"in the caller. For such, you can use the `alias!` macro:\n"
"\n"
"    defmodule Hygiene do\n"
"      # This will expand to Elixir.Nested.hello\n"
"      defmacro no_interference do\n"
"        quote do: Nested.hello\n"
"      end\n"
"\n"
"      # This will expand to Nested.hello for\n"
"      # whatever is Nested in the caller\n"
"      defmacro interference do\n"
"        quote do: alias!(Nested).hello\n"
"      end\n"
"    end\n"
"\n"
"    defmodule Parent do\n"
"      defmodule Nested do\n"
"        def hello, do: \"world\"\n"
"      end\n"
"\n"
"      require Hygiene\n"
"      Hygiene.no_interference\n"
"      #=> ** (UndefinedFunctionError) ...\n"
"\n"
"      Hygiene.interference\n"
"      #=> \"world\"\n"
"    end\n"
"\n"
"## Hygiene in imports\n"
"\n"
"Similar to aliases, imports in Elixir are hygienic. Consider the\n"
"following code:\n"
"\n"
"    defmodule Hygiene do\n"
"      defmacrop get_size do\n"
"        quote do\n"
"          size(\"hello\")\n"
"        end\n"
"      end\n"
"\n"
"      def return_size do\n"
"        import Kernel, except: [size: 1]\n"
"        get_size\n"
"      end\n"
"    end\n"
"\n"
"    Hygiene.return_size #=> 5\n"
"\n"
"Notice how `return_size` returns 5 even though the `size/1`\n"
"function is not imported. In fact, even if `return_size` imported\n"
"a function from another module, it wouldn't affect the function\n"
"result:\n"
"\n"
"    def return_size do\n"
"      import Dict, only: [size: 1]\n"
"      get_size\n"
"    end\n"
"\n"
"Calling this new `return_size` will still return 5 as result.\n"
"\n"
"Elixir is smart enough to delay the resolution to the latest\n"
"moment possible. So, if you call `size(\"hello\")` inside quote,\n"
"but no `size/1` function is available, it is then expanded in\n"
"the caller:\n"
"\n"
"    defmodule Lazy do\n"
"      defmacrop get_size do\n"
"        import Kernel, except: [size: 1]\n"
"\n"
"        quote do\n"
"          size([a: 1, b: 2])\n"
"        end\n"
"      end\n"
"\n"
"      def return_size do\n"
"        import Kernel, except: [size: 1]\n"
"        import Dict, only: [size: 1]\n"
"        get_size\n"
"      end\n"
"    end\n"
"\n"
"    Lazy.return_size #=> 2\n"
"\n"
"## Stacktrace information\n"
"\n"
"When defining functions via macros, developers have the option of\n"
"choosing if runtime errors will be reported from the caller or from\n"
"inside the quote. Let's see an example:\n"
"\n"
"    # adder.ex\n"
"    defmodule Adder do\n"
"      @doc \"Defines a function that adds two numbers\"\n"
"      defmacro defadd do\n"
"        quote location: :keep do\n"
"          def add(a, b), do: a + b\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    # sample.ex\n"
"    defmodule Sample do\n"
"      import Adder\n"
"      defadd\n"
"    end\n"
"\n"
"When using `location: :keep` and invalid arguments are given to\n"
"`Sample.add/2`, the stacktrace information will point to the file\n"
"and line inside the quote. Without `location: :keep`, the error is\n"
"reported to where `defadd` was invoked. Note `location: :keep` affects\n"
"only definitions inside the quote.\n"
"\n"
"## Binding and unquote fragments\n"
"\n"
"Elixir quote/unquote mechanisms provides a functionality called\n"
"unquote fragments. Unquote fragments provide an easy way to generate\n"
"functions on the fly. Consider this example:\n"
"\n"
"    kv = [foo: 1, bar: 2]\n"
"    Enum.each kv, fn {k, v} ->\n"
"      def unquote(k)(), do: unquote(v)\n"
"    end\n"
"\n"
"In the example above, we have generated the functions `foo/0` and\n"
"`bar/0` dynamically. Now, imagine that, we want to convert this\n"
"functionality into a macro:\n"
"\n"
"    defmacro defkv(kv) do\n"
"      Enum.map kv, fn {k, v} ->\n"
"        quote do\n"
"          def unquote(k)(), do: unquote(v)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"We can invoke this macro as:\n"
"\n"
"    defkv [foo: 1, bar: 2]\n"
"\n"
"However, we can't invoke it as follows:\n"
"\n"
"    kv = [foo: 1, bar: 2]\n"
"    defkv kv\n"
"\n"
"This is because the macro is expecting its arguments to be a\n"
"keyword list at **compilation** time. Since in the example above\n"
"we are passing the representation of the variable `kv`, our\n"
"code fails.\n"
"\n"
"This is actually a common pitfall when developing macros. We are\n"
"assuming a particular shape in the macro. We can work around it\n"
"by unquoting the variable inside the quoted expression:\n"
"\n"
"    defmacro defkv(kv) do\n"
"      quote do\n"
"        Enum.each unquote(kv), fn {k, v} ->\n"
"          def unquote(k)(), do: unquote(v)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"If you try to run our new macro, you will notice it won't\n"
"even compile, complaining that the variables `k` and `v`\n"
"does not exist. This is because of the ambiguity: `unquote(k)`\n"
"can either be an unquote fragment, as previously, or a regular\n"
"unquote as in `unquote(kv)`.\n"
"\n"
"One solution to this problem is to disable unquoting in the\n"
"macro, however, doing that would make it impossible to inject the\n"
"`kv` representation into the tree. That's when the `:bind_quoted`\n"
"option comes to the rescue (again!). By using `:bind_quoted`, we\n"
"can automatically disable unquoting while still injecting the\n"
"desired variables into the tree:\n"
"\n"
"    defmacro defkv(kv) do\n"
"      quote bind_quoted: [kv: kv] do\n"
"        Enum.each kv, fn {k, v} ->\n"
"          def unquote(k)(), do: unquote(v)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"In fact, the `:bind_quoted` option is recommended every time\n"
"one desires to inject a value into the quote.\n"
msgstr ""
"任意の式の表現を取得します。\n"
"\n"
"## 例\n"
"\n"
"    quote do: sum(1, 2, 3)\n"
"    #=> {:sum, [], [1, 2, 3]}\n"
"\n"
"## 説明\n"
"\n"
"任意のElixirコードはElixirデータ構造を使って表現することができます。\n"
"Elixirマクロの素材は、3要素のタプルで、例えば:\n"
"\n"
"    {:sum, [], [1, 2, 3]}\n"
"\n"
"上のタプルは、`sum`を、引数として1, 2, 3を渡して関数呼び出していることを\n"
"表現しています。タプルの要素は以下の通りです:\n"
"\n"
"  * タプルの最初の要素は、通常アトムまたは、同様の表現の\n"
"    他のタプルです。\n"
"\n"
"  * タプルの2番目の要素は、メタデータを表現します。\n"
"\n"
"  * タプルの3番目の要素は、関数呼び出しの引数です。\n"
"    3番目の引数はアトムの場合があります。それは\n"
"    通常変数(またはローカル呼び出し)です。\n"
"\n"
"## オプション\n"
"\n"
"  * `:unquote` - falseの時、unquoteが無効になります。\n"
"    quoteの内側に他のquoteがあり、どのquoteをunquoteするかを\n"
"    制御したい時、便利です。\n"
"\n"
"  * `:location` -  `:keep`にセットする時、quoteされた\n"
"    現在の行とファイルを保存します。詳細は、\n"
"    スタックトレース情報セクションを\n"
"    参照してください。\n"
"\n"
"  * `:context` -  解決コンテキストをセットします。\n"
"\n"
"  * `:bind_quoted` - マクロにバインディングを渡します。\n"
"    バインディングが与えられたときはいつでも、`unquote`は自動的に\n"
"    無効になります。\n"
"\n"
"## リテラルのquote\n"
"\n"
"上で説明したタプルの他に、Elixirはquoteされたときそれ自身を返す、\n"
"少しのリテラルを持ちます。それは、以下の通りです:\n"
"\n"
"    :sum         #=> Atoms\n"
"    1            #=> Integers\n"
"    2.0          #=> Floats\n"
"    [1, 2]       #=> Lists\n"
"    \"strings\"    #=> Strings\n"
"    {key, value} #=> Tuples with two elements\n"
"\n"
"## quoteとマクロ\n"
"\n"
"`quote`はコード生成のためのマクロで一般的に用いられます。\n"
"演習として、数をそれ自身で乗算(二乗)するマクロを定義してみましょう。\n"
"\n"
"そのようなマクロを定義する理由はない(そして、それは実は\n"
"悪い実践とみなされます)ことに気を付けてください。\n"
"しかし、quoteとマクロの重要な面に集中するのに、十分に単純です:\n"
"\n"
"    defmodule Math do\n"
"      defmacro squared(x) do\n"
"        quote do\n"
"          unquote(x) * unquote(x)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"それを以下のように起動できます:\n"
"\n"
"    import Math\n"
"    IO.puts \"Got #{squared(5)}\"\n"
"\n"
"最初は、それがマクロであることを実際に明かにすることは、この例には何も\n"
"ありません。しかし、起こっていることは、コンパイル時で、`squared(5)`が\n"
"`5 * 5`になったということです。引数`5`は生成されたコードで\n"
"複製される、私達のマクロには実際にはバグがありますが、\n"
"この振る舞いを見ることができます:\n"
"\n"
"    import Math\n"
"    my_number = fn ->\n"
"      IO.puts \"Returning 5\"\n"
"      5\n"
"    end\n"
"    IO.puts \"Got #{squared(my_number.())}\"\n"
"\n"
"上の例は以下のように表示されます:\n"
"\n"
"    Returning 5\n"
"    Returning 5\n"
"    25\n"
"\n"
"\"Returning 5\"が一度ではなく、どのようにして2度表示されたかに、\n"
"注意してください。\n"
"これは、マクロが値(通常の関数では値ですが)ではなく、式を受け取るためです。\n"
"この意味は:\n"
"\n"
"    squared(my_number.())\n"
"\n"
"実際には以下のように展開されます:\n"
"\n"
"    my_number.() * my_number.()\n"
"\n"
"なぜ2回値が表示されたについて説明して、2回関数を実行します! 大部分のケー\n"
"スで、これは実際に想定外の振る舞いで、マクロに関して、心にとめていく必\n"
"要がある最初のものの一つが、**同じ値を何度も`unquote`しない**ことです。\n"
"\n"
"私達のマクロを修正しましょう:\n"
"\n"
"    defmodule Math do\n"
"      defmacro squared(x) do\n"
"        quote do\n"
"          x = unquote(x)\n"
"          x * x\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"今や前と同じように`square(my_number.())`を起動しても一度だけ\n"
"値が表示されます。\n"
"\n"
"実際、このパターンは一般的で、ほとんどの時に、\n"
"`quote`で`bind_quote`オプションを使いたくなるでしょう:\n"
"\n"
"    defmodule Math do\n"
"      defmacro squared(x) do\n"
"        quote bind_quoted: [x: x] do\n"
"          x * x\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"`:bind_quoted`は上の例では同じコードに翻訳します。`:bind_quoted`は多く\n"
"のケースで使え、良い実践と見做されています。それが一般的な間違いにぶつ\n"
"かることから私達を助けるからだけでなく、下のいくつかのセクションで論じ\n"
"られるunquoteフラグメントの様な、マクロによって公開される他のツールを導\n"
"入するのを許すからです。\n"
"\n"
"この短かい導入を終える前に、例えquoteの内側で変数`x`を定義しても、\n"
"気付くでしょう:\n"
"\n"
"    quote do\n"
"      x = unquote(x)\n"
"      x * x\n"
"    end\n"
"\n"
"呼び出したとき:\n"
"\n"
"    import Math\n"
"    squared(5)\n"
"    x #=> ** (RuntimeError) undefined function or variable: x\n"
"\n"
"`x`はユーザコンテキストに漏れないことが分ります。これは\n"
"Elixirマクロは健全(hygienic)だからです。これは次のセクションで\n"
"同様に詳細に論ずるトピックです。\n"
"\n"
"## 変数の健全性(Hygiene in variables)\n"
"\n"
"以下の例を考えてください:\n"
"\n"
"    defmodule Hygiene do\n"
"      defmacro no_interference do\n"
"        quote do: a = 1\n"
"      end\n"
"    end\n"
"\n"
"    require Hygiene\n"
"\n"
"    a = 10\n"
"    Hygiene.no_interference\n"
"    a #=> 10\n"
"\n"
"上の例で、`a`は10を返します。\n"
"マクロが明かにそれを1に設定していますが、マクロの\n"
"中で定義された変数は、マクロを実行しているコンテキストに影響を\n"
"及ぼしません。\n"
"もし呼び出し側コンテキストで変数を設定あるいは取得したいなら、\n"
"`var!`マクロの助けを借りて、それをすることができます:\n"
"\n"
"    defmodule NoHygiene do\n"
"      defmacro interference do\n"
"        quote do: var!(a) = 1\n"
"      end\n"
"    end\n"
"\n"
"    require NoHygiene\n"
"\n"
"    a = 10\n"
"    NoHygiene.interference\n"
"    a #=> 1\n"
"\n"
"\n"
"明示的にコンテキストを与えない限り、同じモジュールで定義された\n"
"変数へアクセスすることさえ出来無いことに、\n"
"注意してください:\n"
"\n"
"    defmodule Hygiene do\n"
"      defmacro write do\n"
"        quote do\n"
"          a = 1\n"
"        end\n"
"      end\n"
"\n"
"      defmacro read do\n"
"        quote do\n"
"          a\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    Hygiene.write\n"
"    Hygiene.read\n"
"    #=> ** (RuntimeError) undefined function or variable: a\n"
"\n"
"そのために、引数として現在のモジュールのスコープを明示的に渡す\n"
"ことが出来ます:\n"
"\n"
"    defmodule ContextHygiene do\n"
"      defmacro write do\n"
"        quote do\n"
"          var!(a, ContextHygiene) = 1\n"
"        end\n"
"      end\n"
"\n"
"      defmacro read do\n"
"        quote do\n"
"          var!(a, ContextHygiene)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    ContextHygiene.write\n"
"    ContextHygiene.read\n"
"    #=> 1\n"
"\n"
"## エイリアスの健全性(Hygiene in aliases)\n"
"\n"
"quoteの内側のエイリアスはデフォルトで健全です。\n"
"下の例を考えてください:\n"
"\n"
"    defmodule Hygiene do\n"
"      alias HashDict, as: D\n"
"\n"
"      defmacro no_interference do\n"
"        quote do: D.new\n"
"      end\n"
"    end\n"
"\n"
"    require Hygiene\n"
"    Hygiene.no_interference #=> #HashDict<[]>\n"
"\n"
"例えエイリアス`D`がコンテキストで無効でも、マクロが展開され、`D`がまだ\n"
"`HashDict`に展開されるので、上のコードは動くことに、注意してください。\n"
"\n"
"同様に、マクロを起動する前に、例え同じ名前でエイリアスを定義しても、そ\n"
"れはマクロの結果に影響を及ぼしません:\n"
"\n"
"    defmodule Hygiene do\n"
"      alias HashDict, as: D\n"
"\n"
"      defmacro no_interference do\n"
"        quote do: D.new\n"
"      end\n"
"    end\n"
"\n"
"    require Hygiene\n"
"    alias SomethingElse, as: D\n"
"    Hygiene.no_interference #=> #HashDict<[]>\n"
"\n"
"場合によっては、呼び出し側で、定義されたエイリアスまたはモジュールへ、\n"
"アクセスしたいこともあるでしょう。そのために、`alias!`マクロを使うことが\n"
"できます:\n"
"\n"
"    defmodule Hygiene do\n"
"      # This will expand to Elixir.Nested.hello\n"
"      defmacro no_interference do\n"
"        quote do: Nested.hello\n"
"      end\n"
"\n"
"      # This will expand to Nested.hello for\n"
"      # whatever is Nested in the caller\n"
"      defmacro interference do\n"
"        quote do: alias!(Nested).hello\n"
"      end\n"
"    end\n"
"\n"
"    defmodule Parent do\n"
"      defmodule Nested do\n"
"        def hello, do: \"world\"\n"
"      end\n"
"\n"
"      require Hygiene\n"
"      Hygiene.no_interference\n"
"      #=> ** (UndefinedFunctionError) ...\n"
"\n"
"      Hygiene.interference\n"
"      #=> \"world\"\n"
"    end\n"
"\n"
"## importの健全性(Hygiene in imports)\n"
"\n"
"エイリアスと同様に、Elixirのimportは健全です。以下のコードを\n"
"考えてください:\n"
"\n"
"    defmodule Hygiene do\n"
"      defmacrop get_size do\n"
"        quote do\n"
"          size(\"hello\")\n"
"        end\n"
"      end\n"
"\n"
"      def return_size do\n"
"        import Kernel, except: [size: 1]\n"
"        get_size\n"
"      end\n"
"    end\n"
"\n"
"    Hygiene.return_size #=> 5\n"
"\n"
"たとえ`size/1`関数がインポートされていないとしても、\n"
"`return_size`がどのように5を返したか注意してください。\n"
"実際、`return_size`が他のモジュールから関数をインポートしたと\n"
"しても、関数の結果には影響を及ぼしません:\n"
"\n"
"    def return_size do\n"
"      import Dict, only: [size: 1]\n"
"      get_size\n"
"    end\n"
"\n"
"この新しい`return_size`の呼び出しは、結果としてまだ5を返します。\n"
"\n"
"Elixirは、\n"
"可能な限り最新の瞬間まで解決を遅らせるため、十分スマートです。\n"
"それで、もしquoteの内部で`size(\"hello\")`を呼び出したら、\n"
"`size/1`関数が有効でないが、呼び出し側で展開されます:\n"
"\n"
"    defmodule Lazy do\n"
"      defmacrop get_size do\n"
"        import Kernel, except: [size: 1]\n"
"\n"
"        quote do\n"
"          size([a: 1, b: 2])\n"
"        end\n"
"      end\n"
"\n"
"      def return_size do\n"
"        import Kernel, except: [size: 1]\n"
"        import Dict, only: [size: 1]\n"
"        get_size\n"
"      end\n"
"    end\n"
"\n"
"    Lazy.return_size #=> 2\n"
"\n"
"## スタックトレース情報\n"
"\n"
"マクロによって関数を定義するとき、開発者は、\n"
"実行時エラーを呼び出し側からレポートされるか、\n"
"quoteの内部からレポートされるかを、選択するオプションを持っています。\n"
"例をみましょう:\n"
"\n"
"    # adder.ex\n"
"    defmodule Adder do\n"
"      @doc \"Defines a function that adds two numbers\"\n"
"      defmacro defadd do\n"
"        quote location: :keep do\n"
"          def add(a, b), do: a + b\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    # sample.ex\n"
"    defmodule Sample do\n"
"      import Adder\n"
"      defadd\n"
"    end\n"
"\n"
"`location: :keep`とを使い、無効な引数が`Sample.add/2`に与えられた時、ス\n"
"タックトレース情報が、quoteの内部のファイルと行を示します。`location:\n"
":keep`なしでは、エラーは`defadd`が起動された場所でレポートされます。\n"
"`location: keep`は、quoteの内側の定義にのみ影響を及ぼすことに、注意して\n"
"ください。\n"
"\n"
"## Binding and unquote fragments\n"
"\n"
"Eliirのquote/unquoteメカニズムはunquoteフラグメントと呼ばれる機能を\n"
"提供します。\n"
"unquoteフラグメントは、自動的にその場で関数を生み出す簡単な\n"
"方法を提供します。この例を考えてください:\n"
"\n"
"    kv = [foo: 1, bar: 2]\n"
"    Enum.each kv, fn {k, v} ->\n"
"      def unquote(k)(), do: unquote(v)\n"
"    end\n"
"\n"
"上の例では、動的に関数`foo/0`と`bar/2`を生成しました。\n"
"今、この機能をマクロに変換したいと、想像してください:\n"
"\n"
"    defmacro defkv(kv) do\n"
"      Enum.map kv, fn {k, v} ->\n"
"        quote do\n"
"          def unquote(k)(), do: unquote(v)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"このマクロを以下のように起動できます:\n"
"\n"
"    defkv [foo: 1, bar: 2]\n"
"\n"
"しかしながら、以下のようには起動できません:\n"
"\n"
"    kv = [foo: 1, bar: 2]\n"
"    defkv kv\n"
"\n"
"これはマクロが **コンパイル時** に、引数がキーワードリストであることを\n"
"想定しているからです。上の例で、変数`kv`の表現を渡しているので、\n"
"コードは失敗します。\n"
"\n"
"マクロを開発するとき、これは実は一般的な落とし穴です。私達は、はマクロ\n"
"で特定の形を想定します。quoteされた式の中で、変数をunquoteすることで、\n"
"ワークアラウンドが出来ます:\n"
"\n"
"    defmacro defkv(kv) do\n"
"      quote do\n"
"        Enum.each unquote(kv), fn {k, v} ->\n"
"          def unquote(k)(), do: unquote(v)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"もし私達の新しいマクロを実行しようとするなら、\n"
"変数`k`と`v`が存在しないと不平をいわれ、コンパイルさえできない\n"
"ことに、気が付くでしょう。\n"
"これは、曖昧さのためです:\n"
"`unquote(k)`は、前のようにunquoteフラグメントでもあり、あるいは、\n"
"`unquote(kv)`のように標準のunquoteでもありえます。\n"
"\n"
"この問題の一つの解決法は、マクロでのunquoteを無効にすることで、\n"
"しかしながら、これは、ツリーの中へ`kv`表現の注入することを不可能にします。\n"
"これは、`:bind_quote`オプションが救出してくれます(再び!)。\n"
"`:bind_quoted`を使うことにより、ツリーに望み通りの変数を\n"
"注入する間、自動的にunquoteを無効にすることが出来ます:\n"
"\n"
"    defmacro defkv(kv) do\n"
"      quote bind_quoted: [kv: kv] do\n"
"        Enum.each kv, fn {k, v} ->\n"
"          def unquote(k)(), do: unquote(v)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"実際のところ、quoteに値を注入することを望むたびに、`:bind_quoted`オプショ\n"
"ンは推奨されます。\n"

#. TRANSLATORS: Elixir.List Summary
#: lib/list.ex:1
msgid ""
"Implements functions that only make sense for lists\n"
"and cannot be part of the Enum protocol. In general,\n"
"favor using the Enum API instead of List.\n"
"\n"
"Some functions in this module expect an index. Index\n"
"access for list is linear. Negative indexes are also\n"
"supported but they imply the list will be iterated twice,\n"
"one to calculate the proper index and another to the\n"
"operation.\n"
"\n"
"A decision was taken to delegate most functions to\n"
"Erlang's standard library but follow Elixir's convention\n"
"of receiving the target (in this case, a list) as the\n"
"first argument.\n"
msgstr ""
"リストとしての意味だけをなし、Enumプロトコルの一部に\n"
"することは出来ない、関数を実装します。\n"
"一般にListの代りにEnum APIを使うほうを支持します。\n"
"\n"
"このモジュールのいくつかの関数は、インデックスを期待します。\n"
"リストでのインデックスへのアクセスは線形です。負のインデックスも\n"
"サポートされますが、リストが、適切なインデックスの計算のためと、\n"
"操作の為の、2回繰り返されることを意味します。\n"
"\n"
"大部分の関数をErlangの標準ライブラリに移譲しますが、\n"
"ターゲット(この場合、リスト)を最初の引数とするElixirの\n"
"慣例に従うことを、決定しました。\n"

#. TRANSLATORS: def Module.get_attribute(module, key)
#: lib/module.ex:775
msgid ""
"Gets the given attribute from a module. If the attribute\n"
"was marked with `accumulate` with `Module.register_attribute/3`,\n"
"a list is always returned.\n"
"\n"
"The `@` macro compiles to a call to this function. For example,\n"
"the following code:\n"
"\n"
"    @foo\n"
"\n"
"Expands close to:\n"
"\n"
"    Module.get_attribute(__MODULE__, :foo)\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Foo do\n"
"      Module.put_attribute __MODULE__, :value, 1\n"
"      Module.get_attribute __MODULE__, :value #=> 1\n"
"\n"
"      Module.register_attribute __MODULE__, :value, accumulate: true\n"
"      Module.put_attribute __MODULE__, :value, 1\n"
"      Module.get_attribute __MODULE__, :value #=> [1]\n"
"    end\n"
"\n"
msgstr ""
"モジュールから与えられた属性を取得します。もし属性が\n"
"`Module.register_attribute/3`で`accumulate`とマークされていたら、\n"
"常にリストを返します。\n"
"\n"
"`@`マクロは、この関数の呼び出しに、コンパイルします。\n"
"例えば以下のコードは:\n"
"\n"
"    @foo\n"
"\n"
"以下に展開されます:\n"
"\n"
"    Module.get_attribute(__MODULE__, :foo)\n"
"\n"
"## 例\n"
"\n"
"    defmodule Foo do\n"
"      Module.put_attribute __MODULE__, :value, 1\n"
"      Module.get_attribute __MODULE__, :value #=> 1\n"
"\n"
"      Module.register_attribute __MODULE__, :value, accumulate: true\n"
"      Module.put_attribute __MODULE__, :value, 1\n"
"      Module.get_attribute __MODULE__, :value #=> [1]\n"
"    end\n"
"\n"

#. TRANSLATORS: def Path.join(list1)
#: lib/path.ex:448
msgid ""
"Joins a list of strings.\n"
"\n"
"This function should be used to convert a list of strings to a path.\n"
"Note that any trailing slash is removed on join.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.join([\"~\", \"foo\"])\n"
"    \"~/foo\"\n"
"\n"
"    iex> Path.join([\"foo\"])\n"
"    \"foo\"\n"
"\n"
"    iex> Path.join([\"/\", \"foo\", \"bar/\"])\n"
"    \"/foo/bar\"\n"
"\n"
msgstr ""
"文字列のリストを結合します。\n"
"\n"
"この関数は文字列のリストをパスに変関するために使われるべきです。結合の\n"
"際、末尾のスラッシュはすべて削除されることに注意してください。\n"
"\n"
"## 例\n"
"\n"
"    iex> Path.join([\"~\", \"foo\"])\n"
"    \"~/foo\"\n"
"\n"
"    iex> Path.join([\"foo\"])\n"
"    \"foo\"\n"
"\n"
"    iex> Path.join([\"/\", \"foo\", \"bar/\"])\n"
"    \"/foo/bar\"\n"
"\n"

#. TRANSLATORS: def System.halt(status \\ 0)
#: lib/system.ex:363
msgid ""
"Halts the Erlang runtime system.\n"
"\n"
"Halts the Erlang runtime system where the argument `status` must be a\n"
"non-negative integer, the atom `:abort` or a binary.\n"
"\n"
"  * If an integer, the runtime system exits with the integer value which\n"
"    is returned to the operating system.\n"
"\n"
"  * If `:abort`, the runtime system aborts producing a core dump, if that "
"is\n"
"    enabled in the operating system.\n"
"\n"
"  * If a string, an erlang crash dump is produced with status as slogan,\n"
"    and then the runtime system exits with status code 1.\n"
"\n"
"Note that on many platforms, only the status codes 0-255 are supported\n"
"by the operating system.\n"
"\n"
"For more information, check: http://www.erlang.org/doc/man/erlang."
"html#halt-1\n"
"\n"
"## Examples\n"
"\n"
"    System.halt(0)\n"
"    System.halt(1)\n"
"    System.halt(:abort)\n"
"\n"
msgstr ""
"Erlangランタイムシステムを停止します。\n"
"\n"
"Erlangランタイムシステムを停止します。その引数`status`は非負の整数か、アト\n"
"ム`:abort`か、バイナリでなくなてはなりません。\n"
"\n"
"  * もし整数ならランタイムシステムはその整数値でexitし、\n"
"    オペレーティングシステムにその値を返します。\n"
"\n"
"  * もし`:abort`なら、ランタイムシステムはアボートし、オペレーティング\n"
"    システムがコアダンプを有効にしていれば、コアダンプを生成します。\n"
"\n"
"  * もし文字列なら、erlang crash dumpがその文字列とともに生成され、\n"
"    ランタイムシステムはステータスコード 1としてexitします。\n"
"\n"
"なお、多くのプラットフォームでは、オペレーティングシステムによるステー\n"
"タスコードは、0-255だけがサポートされます。\n"
"\n"
"詳細は、 http://www.erlang.org/doc/man/erlang.html#halt-1 \n"
"をチェックしてください。\n"
"\n"
"## 例\n"
"\n"
"    System.halt(0)\n"
"    System.halt(1)\n"
"    System.halt(:abort)\n"
"\n"

#. TRANSLATORS: def URI.normalize_scheme(scheme)
#: lib/uri.ex:26
msgid "Normalizes the scheme according to the spec by downcasing it.\n"
msgstr "小文字化することにより仕様に従って、schemeを正規化します。\n"

#. TRANSLATORS: def Path.relative(name)
#: lib/path.ex:211
msgid ""
"Forces the path to be a relative path.\n"
"\n"
"## Unix examples\n"
"\n"
"    Path.relative(\"/usr/local/bin\")   #=> \"usr/local/bin\"\n"
"    Path.relative(\"usr/local/bin\")    #=> \"usr/local/bin\"\n"
"    Path.relative(\"../usr/local/bin\") #=> \"../usr/local/bin\"\n"
"\n"
"## Windows examples\n"
"\n"
"    Path.relative(\"D:/usr/local/bin\") #=> \"usr/local/bin\"\n"
"    Path.relative(\"usr/local/bin\")    #=> \"usr/local/bin\"\n"
"    Path.relative(\"D:bar.ex\")         #=> \"bar.ex\"\n"
"    Path.relative(\"/bar/foo.ex\")      #=> \"bar/foo.ex\"\n"
"\n"
msgstr ""
"パスを相対パスに強制します。\n"
"\n"
"## Unixの例\n"
"\n"
"    Path.relative(\"/usr/local/bin\")   #=> \"usr/local/bin\"\n"
"    Path.relative(\"usr/local/bin\")    #=> \"usr/local/bin\"\n"
"    Path.relative(\"../usr/local/bin\") #=> \"../usr/local/bin\"\n"
"\n"
"## Windowsの例\n"
"\n"
"    Path.relative(\"D:/usr/local/bin\") #=> \"usr/local/bin\"\n"
"    Path.relative(\"usr/local/bin\")    #=> \"usr/local/bin\"\n"
"    Path.relative(\"D:bar.ex\")         #=> \"bar.ex\"\n"
"    Path.relative(\"/bar/foo.ex\")      #=> \"bar/foo.ex\"\n"
"\n"

#. TRANSLATORS: def System.stacktrace()
#: lib/system.ex:330
msgid ""
"Last exception stacktrace.\n"
"\n"
"Note that the Erlang VM (and therefore this function) does not\n"
"return the current stacktrace but rather the stacktrace of the\n"
"latest exception.\n"
"\n"
"Inlined by the compiler into `:erlang.get_stacktrace/0`.\n"
msgstr ""
"最後の例外のスタックトレースです。\n"
"\n"
"Erlang VM(と従ってこの関数)が現在のスタックトレースではなく、\n"
"むしろ、最後の例外のスタックトレースを返すことに、注意してください。\n"
"\n"
"コンパイラにより`:erlang.get_stacktrace/0`にインライン化されます。\n"

#. TRANSLATORS: Elixir.Enumerable Summary
#: lib/enum.ex:1
msgid ""
"Enumerable protocol used by `Enum` and `Stream` modules.\n"
"\n"
"When you invoke a function in the `Enum` module, the first argument\n"
"is usually a collection that must implement this protocol. For example,\n"
"the expression\n"
"\n"
"    Enum.map([1, 2, 3], &(&1 * 2))\n"
"\n"
"invokes underneath `Enumerable.reduce/3` to perform the reducing\n"
"operation that builds a mapped list by calling the mapping function\n"
"`&(&1 * 2)` on every element in the collection and cons'ing the\n"
"element with an accumulated list.\n"
"\n"
"Internally, `Enum.map/2` is implemented as follows:\n"
"\n"
"    def map(enum, fun) do\n"
"      reducer = fn x, acc -> {:cont, [fun.(x)|acc]} end\n"
"      Enumerable.reduce(enum, {:cont, []}, reducer) |> elem(1) |> :lists."
"reverse()\n"
"    end\n"
"\n"
"Notice the user given function is wrapped into a `reducer` function.\n"
"The `reducer` function must return a tagged tuple after each step,\n"
"as described in the `acc/0` type.\n"
"\n"
"The reason the accumulator requires a tagged tuple is to allow the\n"
"reducer function to communicate to the underlying enumerable the end\n"
"of enumeration, allowing any open resource to be properly closed. It\n"
"also allows suspension of the enumeration, which is useful when\n"
"interleaving between many enumerables is required (as in zip).\n"
"\n"
"Finally, `Enumerable.reduce/3` will return another tagged tuple,\n"
"as represented by the `result/0` type.\n"
msgstr ""
"`Enum`と`Stream`モジュールで使われる、Enumerableプロトコルです。\n"
"\n"
"`Enum`モジュールの関数を起動したとき、最初の引数は通常はコレクションで、\n"
"このプロトコルを実装していなければなりません。\n"
"例えば、式\n"
"\n"
"    Enum.map([1, 2, 3], &(&1 * 2))\n"
"\n"
"は、コレクションのそれぞれのアイテムに関数`&(&1 * 2)`を呼び出し、その結\n"
"果を累積リストにコンシングすることにより、マップされたリストを構築する、\n"
"reduceオペレーションを実行するために、下層にある`Enumerable.reduce/3`を\n"
"起動します。\n"
"\n"
"内部的に、`Enum.map/2`は、以下のように実装されています:\n"
"\n"
"    def map(enum, fun) do\n"
"      reducer = fn x, acc -> {:cont, [fun.(x)|acc]} end\n"
"      Enumerable.reduce(enum, {:cont, []}, reducer) |> elem(1) |> :lists."
"reverse()\n"
"    end\n"
"\n"
"ユーザに与えられた関数は、`reducer`関数にラップされていることに、注意し\n"
"てください。`reducer`関数は、それぞれのステップの後で、`acc/0`タイプで\n"
"記述されるタグづけされたタプルを返さなければなりません。\n"
"\n"
"アキュムレータがタグづけされたタプルを要求する理由は、\n"
"reducer関数に、下層のenumerableと列挙の終わりを知らせ、\n"
"オープンした任意のリソースをクローズさせるることを許すためです。\n"
"列挙の中断も許します。それは、\n"
"多くのenumerable間のインターリーブが必要とされる時(zipの時のような)に\n"
"便利です。\n"
"\n"
"最後に、`Enumerable.reduce/3`は、`result/0`タイプにより表現される、\n"
"もう一つのタグづけされたタプルを返します。\n"

#. TRANSLATORS: Elixir.Inspect.Opts Summary
#: lib/inspect/algebra.ex:1
msgid ""
"Defines the Inspect.Opts used by the Inspect protocol.\n"
"\n"
"The following fields are available:\n"
"\n"
"  * `:structs` - when false, structs are not formatted by the inspect\n"
"    protocol, they are instead printed as maps, defaults to true.\n"
"\n"
"  * `:binaries` - when `:as_strings` all binaries will be printed as "
"strings,\n"
"    non-printable bytes will be escaped.\n"
"\n"
"    When `:as_binaries` all binaries will be printed in bit syntax.\n"
"\n"
"    When the default `:infer`, the binary will be printed as a string if it\n"
"    is printable, otherwise in bit syntax.\n"
"\n"
"  * `:char_lists` - when `:as_char_lists` all lists will be printed as char\n"
"    lists, non-printable elements will be escaped.\n"
"\n"
"    When `:as_lists` all lists will be printed as lists.\n"
"\n"
"    When the default `:infer`, the list will be printed as a char list if "
"it\n"
"    is printable, otherwise as list.\n"
"\n"
"  * `:limit` - limits the number of items that are printed for tuples,\n"
"    bitstrings, and lists, does not apply to strings nor char lists, "
"defaults\n"
"    to 50.\n"
"\n"
"  * `:pretty` - if set to true enables pretty printing, defaults to false.\n"
"\n"
"  * `:width` - defaults to the 80 characters, used when pretty is true or\n"
"    when printing to IO devices.\n"
"\n"
"  * `:base` - print integers as :binary, :octal, :decimal, or :hex, "
"defaults\n"
"    to :decimal\n"
"\n"
msgstr ""
"Inspectプロトコルで使われる、Inspect.Optsを定義します。\n"
"\n"
"以下のフィールドが有効です:\n"
"\n"
"  * `:structs` -  falseの時、構造体はinspectプロトコルでフォーマット\n"
"    されません。代りにマップとして表示されます。デフォルトはtrueです。\n"
"\n"
"  * `:binaries` -  `:as_strings`の時、全てのバイナリは文字列として\n"
"    表示され、印字不能なバイトはエスケープされます。\n"
"\n"
"    `:as_binaries`の時、全てのバイナリはビット構文で表示されます。\n"
"\n"
"    デフォルトの`:infer`の時、バイナリはそれが印字可能なら\n"
"    文字列として表示され、さもなければビット構文になります。\n"
"\n"
"  * `:char_lists` -  `:as_char_lists`の時、全てのリストは文字リストとして\n"
"    表示され、印字不能な要素はエスケープされます。\n"
"\n"
"    `:as_lists`の時、全てのリストは、リストとして表示されます。\n"
"\n"
"    デフォルトの`:infer`の時、リストはそれが印字可能なら文字リストして\n"
"    表示され、さもなければリストとして表示されます。\n"
"\n"
"  * `:limit` - タプル、ビットストリング、リストを表示する\n"
"    要素の数を制限します。文字列、文字リストは適用されません。\n"
"    デフォルトは50です。\n"
"\n"
"  * `:pretty` -  trueにセットすると、プリティプリンティングを有効にします。\n"
"     デフォルトはfalseです。\n"
"\n"
"  * `:width` -  デフォルトは80文字です。prettyがtrueか、IOデバイスへの\n"
"    プリント時に使われます。\n"
"\n"
"  * `:base` -  整数を:binary, :octal, :decimal, :hexとして表示します。\n"
"    デフォルトは:decimalです\n"
"\n"

#. TRANSLATORS: defmacro Kernel.defimpl(name, opts, do_block \\ [])
#: lib/kernel.ex:3172
msgid ""
"Defines an implementation for the given protocol. See\n"
"`defprotocol/2` for examples.\n"
"\n"
"Inside an implementation, the name of the protocol can be accessed\n"
"via `@protocol` and the current target as `@for`.\n"
msgstr ""
"与えられたプロトコルの実装を定義します。\n"
"例は`defprotocol/2`を参照してください。\n"
"\n"
"実装の中で、プロトコルの名前は`@protocol`でアクセスでき、\n"
"現在のターゲットは`@for`でアクセスできます。\n"

#. TRANSLATORS: defmacro Kernel.defexception(fields)
#: lib/kernel.ex:2985
msgid ""
"Defines an exception.\n"
"\n"
"Exceptions are structs backed by a module that implements\n"
"the Exception behaviour. The Exception behaviour requires\n"
"two functions to be implemented:\n"
"\n"
"  * `exception/1` - that receives the arguments given to `raise/2`\n"
"     and returns the exception struct. The default implementation\n"
"     accepts a set of keyword arguments that is merged into the\n"
"     struct.\n"
"\n"
"  * `message/1` - receives the exception struct and must return its\n"
"    message. Most commonly exceptions have a message field which\n"
"    by default is accessed by this function. However, if your exception\n"
"    does not have a message field, this function must be explicitly\n"
"    implemented.\n"
"\n"
"Since exceptions are structs, all the API supported by `defstruct/1`\n"
"is also available in `defexception/1`.\n"
"\n"
"## Raising exceptions\n"
"\n"
"The most common way to raise an exception is via the `raise/2`\n"
"function:\n"
"\n"
"    defmodule MyAppError do\n"
"      defexception [:message]\n"
"    end\n"
"\n"
"    value = [:hello]\n"
"\n"
"    raise MyAppError,\n"
"      message: \"did not get what was expected, got: #{inspect value}\"\n"
"\n"
"In many cases it is more convenient to pass the expected value to\n"
"`raise` and generate the message in the `exception/1` callback:\n"
"\n"
"    defmodule MyAppError do\n"
"      defexception [:message]\n"
"\n"
"      def exception(value) do\n"
"        msg = \"did not get what was expected, got: #{inspect value}\"\n"
"        %MyAppError{message: msg}\n"
"      end\n"
"    end\n"
"\n"
"    raise MyAppError, value\n"
"\n"
"The example above is the preferred mechanism for customizing\n"
"exception messages.\n"
msgstr ""
"例外を定義します。\n"
"\n"
"例外は、Exceptionビヘイビアを実装するモジュールで支持される、\n"
"構造体です。\n"
"Exceptionビヘイビアは二つの関数の実装を要求します:\n"
"\n"
"  * `exception/1` -  `raise/2`へ与えられる引数を受けて、\n"
"     例外構造体を返します。デフォルト実装は、構造体に\n"
"     合併される、一組のキーワード引数を受け入れます。\n"
"\n"
"  * `message/1` -  例外構造体を受けて、そのメッセージを\n"
"     返さなければなりません。最も一般的な例外は、\n"
"     この関数によってデフォルトでアクセスされるメッセージ\n"
"     フィールドを持ちます。しかしながら、\n"
"     例外がメッセージフィールドを持っていないなら、\n"
"     この関数は明示的に実装されなければなりません。\n"
"\n"
"例外は構造体なので、`defstruct/1`によりサポートされる\n"
"全てのAPIもまた`defexception/1`で有効です。\n"
"\n"
"## Raising exceptions\n"
"\n"
"例外を上げる最も一般的な方法は、`raise/2`関数によってです:\n"
"\n"
"    defmodule MyAppError do\n"
"      defexception [:message]\n"
"    end\n"
"\n"
"    value = [:hello]\n"
"\n"
"    raise MyAppError,\n"
"      message: \"did not get what was expected, got: #{inspect value}\"\n"
"\n"
"多くの場合、`raise`に期待される値を渡し、\n"
"`exception/1`コールバックにおいてメッセージを生成することは、\n"
"より便利です:\n"
"\n"
"    defmodule MyAppError do\n"
"      defexception [:message]\n"
"\n"
"      def exception(value) do\n"
"        msg = \"did not get what was expected, got: #{inspect value}\"\n"
"        %MyAppError{message: msg}\n"
"      end\n"
"    end\n"
"\n"
"    raise MyAppError, value\n"
"\n"
"上の例は、例外メッセージをカスタマイズするための好ましいメカニズムです。\n"

#. TRANSLATORS: defmacro Kernel.defstruct(fields)
#: lib/kernel.ex:2899
msgid ""
"Defines a struct for the current module.\n"
"\n"
"A struct is a tagged map that allows developers to provide\n"
"default values for keys, tags to be used in polymorphic\n"
"dispatches and compile time assertions.\n"
"\n"
"To define a struct, a developer needs to only define\n"
"a function named `__struct__/0` that returns a map with the\n"
"structs field. This macro is a convenience for defining such\n"
"function, with the addition of a type `t` and deriving\n"
"conveniences.\n"
"\n"
"For more information about structs, please check\n"
"`Kernel.SpecialForms.%/2`.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule User do\n"
"      defstruct name: nil, age: nil\n"
"    end\n"
"\n"
"Struct fields are evaluated at definition time, which allows\n"
"them to be dynamic. In the example below, `10 + 11` will be\n"
"evaluated at compilation time and the age field will be stored\n"
"with value `21`:\n"
"\n"
"    defmodule User do\n"
"      defstruct name: nil, age: 10 + 11\n"
"    end\n"
"\n"
"## Deriving\n"
"\n"
"Although structs are maps, by default structs do not implement\n"
"any of the protocols implemented for maps. For example, if you\n"
"attempt to use the access protocol with the User struct, it\n"
"will lead to an error:\n"
"\n"
"    %User{}[:age]\n"
"    ** (Protocol.UndefinedError) protocol Access not implemented for "
"%User{...}\n"
"\n"
"However, `defstruct/1` allows implementation for protocols to\n"
"derived by defining a `@derive` attribute as a list before `defstruct/1`\n"
"is invoked:\n"
"\n"
"    defmodule User do\n"
"      @derive [Access]\n"
"      defstruct name: nil, age: 10 + 11\n"
"    end\n"
"\n"
"    %User{}[:age] #=> 21\n"
"\n"
"For each protocol given to `@derive`, Elixir will assert there is an\n"
"implementation of that protocol for maps and check if the map\n"
"implementation defines a `__deriving__/3` callback. If so, the callback\n"
"is invoked, otherwise an implementation that simply points to the map\n"
"one is automatically derived.\n"
"\n"
"## Types\n"
"\n"
"It is recommended to define types for structs, by convention this type\n"
"is called `t`. To define a struct in a type the struct literal syntax\n"
"is used:\n"
"\n"
"    defmodule User do\n"
"      defstruct name: \"john\", age: 25\n"
"      @type t :: %User{name: String.t, age: integer}\n"
"    end\n"
"\n"
"It is recommended to only use the struct syntax when defining the struct's\n"
"type. When referring to another struct use `User.t`, not `%User{}`. Fields\n"
"in the struct not included in the type defaults to `term`.\n"
"\n"
"Private structs that are not used outside its module should use the private\n"
"type attribute `@typep`. Public structs whose internal structure is private\n"
"to the local module (you are not allowed to pattern match it or directly\n"
"access fields) should use the `@opaque` attribute. Structs whose internal\n"
"structure is public should use `@type`.\n"
msgstr ""
"現在のモジュールに構造体を定義します。\n"
"\n"
"構造体はタグ付けされたマップです。それは、開発者に、\n"
"キーにデフォルト値と、ポリモーフィックディスパッチに\n"
"使われるタグ、そしてコンパイル時のアサーションを提供します。\n"
"\n"
"構造体を定義するために、開発者は構造体のフィールドを\n"
"マップで返す、`__struct__/0`という名前の関数を定義する\n"
"ことだけが必要です。このマクロは、その関数の定義に便利で、\n"
"タイプ`t`と派生する便利さを追加します。\n"
"\n"
"構造体についての詳細は、`Kernel.SpecialForms.%/2`\n"
"をチェックしてください。\n"
"\n"
"## 例\n"
"\n"
"    defmodule User do\n"
"      defstruct name: nil, age: nil\n"
"    end\n"
"\n"
"構造体のフィールドは定義時に評価されます。そしてそれは\n"
"動的であることを許します。下の例では、`10 + 11`はコンパイル時に\n"
"評価され、ageフィールドは値`21`が格納されます:\n"
"\n"
"    defmodule User do\n"
"      defstruct name: nil, age: 10 + 11\n"
"    end\n"
"\n"
"## Deriving\n"
"\n"
"構造体はマップですが、デフォルトでは、構造体はマップが\n"
"実装しているプロトコルをなにも実装していません。例えば、\n"
"User構造体でAccessプロトコルを使おうとすると、エラーに\n"
"なります:\n"
"\n"
"    %User{}[:age]\n"
"    ** (Protocol.UndefinedError) protocol Access not implemented for "
"%User{...}\n"
"\n"
"しかしながら、`defstruct/1`は\n"
"`defstruct/1`が起動される前にリストとして`@derive`属性を\n"
"定義することで、それに由来するプロトコルを実装を許します:\n"
"\n"
"    defmodule User do\n"
"      @derive [Access]\n"
"      defstruct name: nil, age: 10 + 11\n"
"    end\n"
"\n"
"    %User{}[:age] #=> 21\n"
"\n"
"`@derive`に与えられるそれぞれのプロトコル毎に、Elixirは\n"
"それがマップのためのプロトコルであると主張して、\n"
"マップ実装が`__deriving__/3`コールバックを定義しているかどうかを\n"
"チェックします。\n"
"もしそうならコールバックは起動され、さもなければ、単にマップの\n"
"実装が、自動的に引き出されます。\n"
"\n"
"## Types\n"
"\n"
"構造体のタイプを定義することが推奨され、慣例により、このタイプは`t`と呼\n"
"ばれます。構造体のタイプを定義するために、構造体リテラル構文が\n"
"使われます:\n"
"\n"
"    defmodule User do\n"
"      defstruct name: \"john\", age: 25\n"
"      @type t :: %User{name: String.t, age: integer}\n"
"    end\n"
"\n"
"構造体タイプを定義するときに、構造構文を使うことだけが推奨されています。\n"
"他の構造体を参照する時は、`%User{}`ではなく、`User.t`を使ってください。\n"
"タイプを含まない構造体のフィールドはデフォルトの`term`になります。\n"
"\n"
"そのモジュールの外で使われないプライベートな構造体は、\n"
"プライベートタイプ属性`@typep`を使うべきです。\n"
"パターンマッチや、直接フィールドへのアクセスを許さない、ローカル\n"
"モジュールに内部構造がプライベートであるパブリック構造体は、\n"
"`@opaque`属性を使うべきです。\n"
"内部構造がパブリックである構造体は`@type`を使うべきです。\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.fn(clauses)
#: lib/kernel/special_forms.ex:1216
msgid ""
"Defines an anonymous function.\n"
"\n"
"## Examples\n"
"\n"
"    iex> add = fn a, b -> a + b end\n"
"    iex> add.(1, 2)\n"
"    3\n"
"\n"
msgstr ""
"無名関数を定義します。\n"
"\n"
"## 例\n"
"\n"
"    iex> add = fn a, b -> a + b end\n"
"    iex> add.(1, 2)\n"
"    3\n"
"\n"

#. TRANSLATORS: defmacro Kernel.Typespec.deftype(type)
#: lib/kernel/typespec.ex:219
msgid ""
"Defines a type.\n"
"This macro is responsible for handling the attribute `@type`.\n"
"\n"
"## Examples\n"
"\n"
"    @type my_type :: atom\n"
"\n"
msgstr ""
"タイプを定義します。\n"
"このマクロは属性`@type`をハンドルする役割りを果します。\n"
"\n"
"## 例\n"
"\n"
"    @type my_type :: atom\n"
"\n"

#. TRANSLATORS: defmacro Kernel.Typespec.defspec(spec)
#: lib/kernel/typespec.ex:264
msgid ""
"Defines a spec.\n"
"This macro is responsible for handling the attribute `@spec`.\n"
"\n"
"## Examples\n"
"\n"
"    @spec add(number, number) :: number\n"
"\n"
msgstr ""
"specを定義します。\n"
"このマクロは属性`@spec`をハンドルする役割りを果します。\n"
"\n"
"## 例\n"
"\n"
"    @spec add(number, number) :: number\n"
"\n"

#. TRANSLATORS: def List.duplicate(elem, n)
#: lib/list.ex:53
msgid ""
"Duplicates the given element `n` times in a list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.duplicate(\"hello\", 3)\n"
"    [\"hello\",\"hello\",\"hello\"]\n"
"\n"
"    iex> List.duplicate([1, 2], 2)\n"
"    [[1,2],[1,2]]\n"
"\n"
msgstr ""
"リストの与えられた要素を`n`回複製します。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.duplicate(\"hello\", 3)\n"
"    [\"hello\",\"hello\",\"hello\"]\n"
"\n"
"    iex> List.duplicate([1, 2], 2)\n"
"    [[1,2],[1,2]]\n"
"\n"

#. TRANSLATORS: defmacro Record.defrecord(name, tag \\ nil, kv)
#: lib/record.ex:160
msgid ""
"Defines a set of macros to create and access a record.\n"
"\n"
"The macros are going to have `name`, a tag (which defaults)\n"
"to the name if none is given, and a set of fields given by\n"
"`kv`.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule User do\n"
"      require Record\n"
"      Record.defrecord :user, [name: \"meg\", age: \"25\"]\n"
"    end\n"
"\n"
"In the example above, a set of macros named `user` but with different\n"
"arities will be defined to manipulate the underlying record:\n"
"\n"
"    # To create records\n"
"    record = user()        #=> {:user, \"meg\", 25}\n"
"    record = user(age: 26) #=> {:user, \"meg\", 26}\n"
"\n"
"    # To get a field from the record\n"
"    user(record, :name) #=> \"meg\"\n"
"\n"
"    # To update the record\n"
"    user(record, age: 26) #=> {:user, \"meg\", 26}\n"
"\n"
"    # Convert a record to a keyword list\n"
"    user(record) #=> [name: \"meg\", age: 26]\n"
"\n"
"By default, Elixir uses the record name as the first element of\n"
"the tuple (the tag). But it can be changed to something else:\n"
"\n"
"    defmodule User do\n"
"      require Record\n"
"      Record.defrecord :user, User, name: nil\n"
"    end\n"
"\n"
"    require User\n"
"    User.user() #=> {User, nil}\n"
"\n"
msgstr ""
"レコードを作成し、アクセスする為の一組のマクロを定義します。\n"
"\n"
"マクロは`name`、与えられなければ(デフォルトで)名前と同じタグ、\n"
"`kv`により与えられた一組のフィールドを持ちます。\n"
"\n"
"## 例\n"
"\n"
"    defmodule User do\n"
"      require Record\n"
"      Record.defrecord :user, [name: \"meg\", age: \"25\"]\n"
"    end\n"
"\n"
"上の例で、一組のマクロは`user`と名付けられたが、\n"
"異るアリティで下にあるレコードを操作するために\n"
"定義されます:\n"
"\n"
"    # To create records\n"
"    record = user()        #=> {:user, \"meg\", 25}\n"
"    record = user(age: 26) #=> {:user, \"meg\", 26}\n"
"\n"
"    # To get a field from the record\n"
"    user(record, :name) #=> \"meg\"\n"
"\n"
"    # To update the record\n"
"    user(record, age: 26) #=> {:user, \"meg\", 26}\n"
"\n"
"    # Convert a record to a keyword list\n"
"    user(record) #=> [name: \"meg\", age: 26]\n"
"\n"
"デフォルトで、Elixirはタプルの最初の要素(タグ)としてレコード名を\n"
"使用します。しかし、何か他のものに変えることもできます:\n"
"\n"
"    defmodule User do\n"
"      require Record\n"
"      Record.defrecord :user, User, name: nil\n"
"    end\n"
"\n"
"    require User\n"
"    User.user() #=> {User, nil}\n"
"\n"

#. TRANSLATORS: def Supervisor.start_child(supervisor, child_spec_or_args)
#: lib/supervisor.ex:271
msgid ""
"Dynamically adds and starts a child specification to the supervisor.\n"
"\n"
"`child_spec` should be a valid child specification (unless the supervisor\n"
"is a `:simple_one_for_one` supervisor, see below). The child process will\n"
"be started as defined in the child specification.\n"
"\n"
"In the case of `:simple_one_for_one`, the child specification defined in\n"
"the supervisor will be used and instead of a `child_spec`, an arbitrary "
"list\n"
"of terms is expected. The child process will then be started by appending\n"
"the given list to the existing function arguments in the child "
"specification.\n"
"\n"
"If there already exists a child specification with the specified id,\n"
"`child_spec` is discarded and the function returns an error with `:"
"already_started`\n"
"or `:already_present` if the corresponding child process is running or not.\n"
"\n"
"If the child process start function returns `{:ok, child}` or `{:ok, child, "
"info}`,\n"
"the child specification and pid is added to the supervisor and the function "
"returns\n"
"the same value.\n"
"\n"
"If the child process start function returns `:ignore, the child "
"specification is\n"
"added to the supervisor, the pid is set to undefined and the function "
"returns\n"
"`{:ok, :undefined}`.\n"
"\n"
"If the child process start function returns an error tuple or an erroneous "
"value,\n"
"or if it fails, the child specification is discarded and the function "
"returns\n"
"`{:error, error}` where `error` is a term containing information about the "
"error\n"
"and child specification.\n"
msgstr ""
"スーパバイザに、子プロセス仕様を\n"
"動的に追加し、開始します。\n"
"\n"
"`child_spec`は有効な子プロセス仕様でなければなりません(スーパバイザが\n"
"`:simple_one_for_one`スーパバイザでない限り。下を参照してください)。\n"
"子プロセスは、子プロセス仕様に定義されているように開始されます。\n"
"\n"
"`:simple_one_for_one`の場合、スーパバイザで定義された子プロセス仕様が使\n"
"われ、`child_spec`のかわりに、任意の語のリストが予想されます。それから、\n"
"子プロセス仕様に存在する関数引数に与えられたリストを追加することによっ\n"
"て、子プロセスは開始します。\n"
"\n"
"指定されたIDの子プロセス仕様が既に存在していたら、\n"
"`child_spec`は捨てられ、関数は、\n"
"対応する子プロセスが動作しているか否かで、\n"
"`:already_started`か`:already_present`のエラーを返します。\n"
"\n"
"子プロセスのスタート関数が`{:ok, child}`か`{:ok, child, info}`を返したら、\n"
"子プロセス仕様とpidはスーパバイザに追加され、関数は\n"
"同じ値を返します。\n"
"\n"
"子プロセスのスタート関数が`:ignore`を返したら、\n"
"子プロセス仕様はスーパバイザに追加され、pidは`:undefined`にセットされ、\n"
"関数は`{:ok, :undefined}`を返します。\n"
"\n"
"子プロセスのスタート関数が、エラータプルか正しくない値を返すか、\n"
"あるいは、失敗したら、子プロセス仕様は捨てられ、関数は、\n"
"`error`を上記のエラーと子プロセス仕様についての情報を含む語として、\n"
"`{:error, error}`を返します。\n"

#. TRANSLATORS: Elixir.IO.Stream Summary
#: lib/io/stream.ex:11
msgid ""
"Defines a `IO.Stream` struct returned by `IO.stream/2` and `IO."
"binstream/2`.\n"
"\n"
"The following fields are public:\n"
"\n"
"  * `device`        - the IO device\n"
"  * `raw`           - a boolean indicating if bin functions should be used\n"
"  * `line_or_bytes` - if reading should read lines or a given amount of "
"bytes\n"
"\n"
msgstr ""
"`IO.stream/2`と`IO.binstream/2`によって返される、`IO.Stream`構造体を定義しま"
"す。\n"
"\n"
"以下のフィールドがパブリックです:\n"
"\n"
"  * `device`        - IOデバイス\n"
"  * `raw`           - bin関数が使われるべきかを指定するブーリアン\n"
"  * `line_or_bytes` - 読み込み時に行を読む、指定されたバイト数を読むか\n"
"\n"

#. TRANSLATORS: Elixir.GenEvent.Stream Summary
#: lib/gen_event/stream.ex:1
msgid ""
"Defines a `GenEvent` stream.\n"
"\n"
"This is a struct returned by `stream/2`. The struct is public and\n"
"contains the following fields:\n"
"\n"
"  * `:manager`  - the manager reference given to `GenEvent.stream/2`\n"
"  * `:timeout`  - the timeout in between events, defaults to `:infinity`\n"
"\n"
msgstr ""
"`GenEvent`ストリームを定義します。\n"
"\n"
"これは`stream/2`により返される構造体です。構造体はパブリックで、\n"
"以下のフィールドを含みます:\n"
"\n"
"  * `:manager`  - `GenEvent.stream/2`に与えられたマネージャリファレンス\n"
"  * `:timeout`  -  イベント間のタイムアウトで、デフォルトは`:infinity`\n"
"\n"

#. TRANSLATORS: Elixir.File.Stream Summary
#: lib/file/stream.ex:1
msgid ""
"Defines a `File.Stream` struct returned by `File.stream!/3`.\n"
"\n"
"The following fields are public:\n"
"\n"
"  * `path`          - the file path\n"
"  * `modes`         - the file modes\n"
"  * `raw`           - a boolean indicating if bin functions should be used\n"
"  * `line_or_bytes` - if reading should read lines or a given amount of "
"bytes\n"
"\n"
msgstr ""
"`File.stream!/3`により返される`File.Stream`構造体を定義します。\n"
"\n"
"以下のフィールドがパブリックです:\n"
"\n"
"  * `path`          - ファイルパス\n"
"  * `modes`         - ファイルのモード\n"
"  * `raw`           - bin関数を使うべきかどうかを指定するブーリアン\n"
"  * `line_or_bytes` - 読み込み時に行を読む、指定されたバイト数を読むか\n"
"\n"

#. TRANSLATORS: def Module.create(module, quoted, opts)
#: lib/module.ex:395
msgid ""
"Creates a module with the given name and defined by\n"
"the given quoted expressions.\n"
"\n"
"The line where the module is defined and its file **must**\n"
"be passed as options.\n"
"\n"
"## Examples\n"
"\n"
"    contents =\n"
"      quote do\n"
"        def world, do: true\n"
"      end\n"
"\n"
"    Module.create(Hello, contents, Macro.Env.location(__ENV__))\n"
"\n"
"    Hello.world #=> true\n"
"\n"
"## Differences from `defmodule`\n"
"\n"
"`Module.create` works similarly to `defmodule` and\n"
"return the same results. While one could also use\n"
"`defmodule` to define modules dynamically, this\n"
"function is preferred when the module body is given\n"
"by a quoted expression.\n"
"\n"
"Another important distinction is that `Module.create`\n"
"allows you to control the environment variables used\n"
"when defining the module, while `defmodule` automatically\n"
"shares the same environment.\n"
msgstr ""
"与えられた名前とquoteされた式により定義されるモジュールを\n"
"作ります。\n"
"\n"
"モジュールが定義された行とそのファイル名は、オプションとして\n"
"**渡されなければなりません**。\n"
"\n"
"## 例\n"
"\n"
"    contents =\n"
"      quote do\n"
"        def world, do: true\n"
"      end\n"
"\n"
"    Module.create(Hello, contents, Macro.Env.location(__ENV__))\n"
"\n"
"    Hello.world #=> true\n"
"\n"
"## `defmodule`との違い\n"
"\n"
"`Module.create`は`defmodule`と似た働きをし、同じ戻り値を返します。\n"
"`defmodule`がモジュールを動的に定義するために使われる一方、この関数はモ\n"
"ジュール本体がquoteされた式により与えられた時に好まれます。\n"
"\n"
"もう一つの重要な違いは、モジュールを定義するときに、`defmodule`は自動的\n"
"におなじ環境を共有する一方、`Module.create`が環境変数を制御することを許\n"
"します。\n"

#. TRANSLATORS: Elixir.Range Summary
#: lib/range.ex:1
msgid ""
"Defines a Range.\n"
"\n"
"A Range is represented internally as a struct. However,\n"
"the most common form of creating and matching on ranges\n"
"is via the `../2` macro, auto-imported from Kernel:\n"
"\n"
"    iex> range = 1..3\n"
"    1..3\n"
"    iex> first .. last = range\n"
"    iex> first\n"
"    1\n"
"    iex> last\n"
"    3\n"
"\n"
msgstr ""
"範囲(Range)を定義します。\n"
"\n"
"Rangeは内部では構造体として表現されます。しかしながら、\n"
"範囲(range)の作成とマッチングの最も一般的なフォームは、\n"
"Kernelから自動インポートされる`../2`マクロによってです。\n"
"\n"
"    iex> range = 1..3\n"
"    1..3\n"
"    iex> first .. last = range\n"
"    iex> first\n"
"    1\n"
"    iex> last\n"
"    3\n"
"\n"

#. TRANSLATORS: def URI.decode_www_form(str)
#: lib/uri.ex:254
msgid ""
"Decodes a string as \"x-www-urlencoded\".\n"
"\n"
"## Examples\n"
"\n"
"    iex> URI.decode_www_form(\"%3Call+in%2F\")\n"
"    \"<all in/\"\n"
"\n"
msgstr ""
"\"x-www-urlencoded\"として文字列をデコードします。\n"
"\n"
"## 例\n"
"\n"
"    iex> URI.decode_www_form(\"%3Call+in%2F\")\n"
"    \"<all in/\"\n"
"\n"

#. TRANSLATORS: def URI.decode_query(q, dict \\ %{})
#: lib/uri.ex:102
msgid ""
"Decodes a query string into a dictionary (by default uses a map).\n"
"\n"
"Given a query string of the form \"key1=value1&key2=value2...\", produces a\n"
"map with one entry for each key-value pair. Each key and value will be a\n"
"binary. Keys and values will be percent-unescaped.\n"
"\n"
"Use `query_decoder/1` if you want to iterate over each value manually.\n"
"\n"
"## Examples\n"
"\n"
"    iex> URI.decode_query(\"foo=1&bar=2\")\n"
"    %{\"bar\" => \"2\", \"foo\" => \"1\"}\n"
"\n"
msgstr ""
"query stringを辞書(デフォルトではmapを使います)にデコードします。\n"
"\n"
"\"key1=value1&key2=value2...\"形式のquery stringがあれば、\n"
"キー-バリューペア毎に一つのエントリとなるマップを生成します。\n"
"キーと値それぞれはバイナリです。キーと値はパーセントアンエスケープされま"
"す。\n"
"\n"
"それぞれの値を手動で繰り返したいなら、`query_decoder/1`を使ってください。\n"
"\n"
"## 例\n"
"\n"
"    iex> URI.decode_query(\"foo=1&bar=2\")\n"
"    %{\"bar\" => \"2\", \"foo\" => \"1\"}\n"
"\n"

#. TRANSLATORS: def Base.url_decode64!(string)
#: lib/base.ex:319
msgid ""
"Decodes a base 64 encoded string with URL and filename safe alphabet\n"
"into a binary string.\n"
"\n"
"An `ArgumentError` exception is raised if the padding is incorrect or\n"
"a non-alphabet character is present in the string.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Base.url_decode64!(\"_3_-_A==\")\n"
"    <<255,127,254,252>>\n"
"\n"
msgstr ""
"URLとファイル名で安全なアルファベットなbase64エンコードされた文字列を、\n"
"バイナリ文字列へデコードします。\n"
"\n"
"`ArgumentError`例外は、パディングが不正、あるいは、文字列に\n"
"非アルファベット文字が表れたら、上げられます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Base.url_decode64!(\"_3_-_A==\")\n"
"    <<255,127,254,252>>\n"
"\n"

#. TRANSLATORS: def Base.url_decode64(string)
#: lib/base.ex:299
msgid ""
"Decodes a base 64 encoded string with URL and filename safe alphabet\n"
"into a binary string.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Base.url_decode64(\"_3_-_A==\")\n"
"    {:ok, <<255,127,254,252>>}\n"
"\n"
msgstr ""
"URLとファイル名で安全なアルファベットなbase64エンコードされた文字列を、\n"
"バイナリ文字列へデコードします。\n"
"\n"
"## 例\n"
"\n"
"    iex> Base.url_decode64(\"_3_-_A==\")\n"
"    {:ok, <<255,127,254,252>>}\n"
"\n"

#. TRANSLATORS: def Base.decode64!(string)
#: lib/base.ex:269
msgid ""
"Decodes a base 64 encoded string into a binary string.\n"
"\n"
"The following alphabet is used both for encoding and decoding:\n"
"\n"
"An `ArgumentError` exception is raised if the padding is incorrect or\n"
"a non-alphabet character is present in the string.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Base.decode64!(\"Zm9vYmFy\")\n"
"    \"foobar\"\n"
"\n"
msgstr ""
"base64エンコードされた文字列を、バイナリ文字列へデコードします。\n"
"\n"
"以下のアルファベットがエンコードとデコードの両方で使われます:\n"
"\n"
"`ArgumentError`例外は、パディングが不正、あるいは、文字列に\n"
"非アルファベット文字が表れたら、上げられます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Base.decode64!(\"Zm9vYmFy\")\n"
"    \"foobar\"\n"
"\n"

#. TRANSLATORS: def Base.decode64(string)
#: lib/base.ex:248
msgid ""
"Decodes a base 64 encoded string into a binary string.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Base.decode64(\"Zm9vYmFy\")\n"
"    {:ok, \"foobar\"}\n"
"\n"
msgstr ""
"base64エンコードされた文字列を、バイナリ文字列へデコードします。\n"
"\n"
"## 例\n"
"\n"
"    iex> Base.decode64(\"Zm9vYmFy\")\n"
"    {:ok, \"foobar\"}\n"
"\n"

#. TRANSLATORS: def Base.hex_decode32!(string, opts \\ [])
#: lib/base.ex:479
msgid ""
"Decodes a base 32 encoded string with extended hexadecimal alphabet\n"
"into a binary string.\n"
"\n"
"Accepts an atom `:upper` (default) for decoding from upper case characters "
"or\n"
"`:lower` for lower case characters. `:mixed` can be given for mixed case\n"
"characters.\n"
"\n"
"An `ArgumentError` exception is raised if the padding is incorrect or\n"
"a non-alphabet character is present in the string.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Base.hex_decode32!(\"CPNMUOJ1E8======\")\n"
"    \"foobar\"\n"
"\n"
"    iex> Base.hex_decode32!(\"cpnmuoj1e8======\", case: :lower)\n"
"    \"foobar\"\n"
"\n"
"    iex> Base.hex_decode32!(\"cpnMuOJ1E8======\", case: :mixed)\n"
"    \"foobar\"\n"
"\n"
msgstr ""
"拡張16進数アルファベットのbase 32エンコードされた文字列をバイナリ文字列へ\n"
"デコードします。\n"
"\n"
"大文字からデコードするアトム`:upper`(デフォルト)と、\n"
"小文字からデコードする`:lower`を受け付けます。\n"
"混在した文字列に`:mixed`を与えることもできます。\n"
"\n"
"`ArgumentError`例外は、パディングが不正、あるいは、文字列に\n"
"非アルファベット文字が表れたら、上げられます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Base.hex_decode32!(\"CPNMUOJ1E8======\")\n"
"    \"foobar\"\n"
"\n"
"    iex> Base.hex_decode32!(\"cpnmuoj1e8======\", case: :lower)\n"
"    \"foobar\"\n"
"\n"
"    iex> Base.hex_decode32!(\"cpnMuOJ1E8======\", case: :mixed)\n"
"    \"foobar\"\n"
"\n"

#. TRANSLATORS: def Base.hex_decode32(string, opts \\ [])
#: lib/base.ex:447
msgid ""
"Decodes a base 32 encoded string with extended hexadecimal alphabet\n"
"into a binary string.\n"
"\n"
"Accepts an atom `:upper` (default) for decoding from upper case characters "
"or\n"
"`:lower` for lower case characters. `:mixed` can be given for mixed case\n"
"characters.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Base.hex_decode32(\"CPNMUOJ1E8======\")\n"
"    {:ok, \"foobar\"}\n"
"\n"
"    iex> Base.hex_decode32(\"cpnmuoj1e8======\", case: :lower)\n"
"    {:ok, \"foobar\"}\n"
"\n"
"    iex> Base.hex_decode32(\"cpnMuOJ1E8======\", case: :mixed)\n"
"    {:ok, \"foobar\"}\n"
"\n"
msgstr ""
"拡張16進数アルファベットのbase 32エンコードされた文字列をバイナリ文字列へ\n"
"デコードします。\n"
"\n"
"大文字からデコードするアトム`:upper`(デフォルト)と、\n"
"小文字からデコードする`:lower`を受け付けます。\n"
"混在した文字列に`:mixed`を与えることもできます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Base.hex_decode32(\"CPNMUOJ1E8======\")\n"
"    {:ok, \"foobar\"}\n"
"\n"
"    iex> Base.hex_decode32(\"cpnmuoj1e8======\", case: :lower)\n"
"    {:ok, \"foobar\"}\n"
"\n"
"    iex> Base.hex_decode32(\"cpnMuOJ1E8======\", case: :mixed)\n"
"    {:ok, \"foobar\"}\n"
"\n"

#. TRANSLATORS: def Base.decode32!(string, opts \\ [])
#: lib/base.ex:397
msgid ""
"Decodes a base 32 encoded string into a binary string.\n"
"\n"
"Accepts an atom `:upper` (default) for decoding from upper case characters "
"or\n"
"`:lower` for lower case characters. `:mixed` can be given for mixed case\n"
"characters.\n"
"\n"
"An `ArgumentError` exception is raised if the padding is incorrect or\n"
"a non-alphabet character is present in the string.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Base.decode32!(\"MZXW6YTBOI======\")\n"
"    \"foobar\"\n"
"\n"
"    iex> Base.decode32!(\"mzxw6ytboi======\", case: :lower)\n"
"    \"foobar\"\n"
"\n"
"    iex> Base.decode32!(\"mzXW6ytBOi======\", case: :mixed)\n"
"    \"foobar\"\n"
"\n"
msgstr ""
"base 32エンコードされた文字列をバイナリ文字列へ\n"
"デコードします。\n"
"\n"
"大文字からデコードするアトム`:upper`(デフォルト)と、\n"
"小文字からデコードする`:lower`を受け付けます。\n"
"混在した文字列に`:mixed`を与えることもできます。\n"
"\n"
"`ArgumentError`例外は、パディングが不正、あるいは、文字列に\n"
"非アルファベット文字が表れたら、上げられます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Base.decode32!(\"MZXW6YTBOI======\")\n"
"    \"foobar\"\n"
"\n"
"    iex> Base.decode32!(\"mzxw6ytboi======\", case: :lower)\n"
"    \"foobar\"\n"
"\n"
"    iex> Base.decode32!(\"mzXW6ytBOi======\", case: :mixed)\n"
"    \"foobar\"\n"
"\n"

#. TRANSLATORS: def Base.decode32(string, opts \\ [])
#: lib/base.ex:366
msgid ""
"Decodes a base 32 encoded string into a binary string.\n"
"\n"
"Accepts an atom `:upper` (default) for decoding from upper case characters "
"or\n"
"`:lower` for lower case characters. `:mixed` can be given for mixed case\n"
"characters.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Base.decode32(\"MZXW6YTBOI======\")\n"
"    {:ok, \"foobar\"}\n"
"\n"
"    iex> Base.decode32(\"mzxw6ytboi======\", case: :lower)\n"
"    {:ok, \"foobar\"}\n"
"\n"
"    iex> Base.decode32(\"mzXW6ytBOi======\", case: :mixed)\n"
"    {:ok, \"foobar\"}\n"
"\n"
msgstr ""
"base 32エンコードされた文字列をバイナリ文字列へ\n"
"デコードします。\n"
"\n"
"大文字からデコードするアトム`:upper`(デフォルト)と、\n"
"小文字からデコードする`:lower`を受け付けます。\n"
"混在した文字列に`:mixed`を与えることもできます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Base.decode32(\"MZXW6YTBOI======\")\n"
"    {:ok, \"foobar\"}\n"
"\n"
"    iex> Base.decode32(\"mzxw6ytboi======\", case: :lower)\n"
"    {:ok, \"foobar\"}\n"
"\n"
"    iex> Base.decode32(\"mzXW6ytBOi======\", case: :mixed)\n"
"    {:ok, \"foobar\"}\n"
"\n"

#. TRANSLATORS: def Base.decode16!(string, opts \\ [])
#: lib/base.ex:219
msgid ""
"Decodes a base 16 encoded string into a binary string.\n"
"\n"
"Accepts an atom `:upper` (default) for decoding from upper case characters "
"or\n"
"`:lower` for lower case characters. `:mixed` can be given for mixed case\n"
"characters.\n"
"\n"
"An `ArgumentError` exception is raised if the padding is incorrect or\n"
"a non-alphabet character is present in the string.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Base.decode16!(\"666F6F626172\")\n"
"    \"foobar\"\n"
"\n"
"    iex> Base.decode16!(\"666f6f626172\", case: :lower)\n"
"    \"foobar\"\n"
"\n"
"    iex> Base.decode16!(\"666f6F626172\", case: :mixed)\n"
"    \"foobar\"\n"
"\n"
msgstr ""
"base 16エンコードされた文字列をバイナリ文字列へ\n"
"デコードします。\n"
"\n"
"大文字からデコードするアトム`:upper`(デフォルト)と、\n"
"小文字からデコードする`:lower`を受け付けます。\n"
"混在した文字列に`:mixed`を与えることもできます。\n"
"\n"
"`ArgumentError`例外は、パディングが不正、あるいは、文字列に\n"
"非アルファベット文字が表れたら、上げられます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Base.decode16!(\"666F6F626172\")\n"
"    \"foobar\"\n"
"\n"
"    iex> Base.decode16!(\"666f6f626172\", case: :lower)\n"
"    \"foobar\"\n"
"\n"
"    iex> Base.decode16!(\"666f6F626172\", case: :mixed)\n"
"    \"foobar\"\n"
"\n"

#. TRANSLATORS: def Base.decode16(string, opts \\ [])
#: lib/base.ex:188
msgid ""
"Decodes a base 16 encoded string into a binary string.\n"
"\n"
"Accepts an atom `:upper` (default) for decoding from upper case characters "
"or\n"
"`:lower` for lower case characters. `:mixed` can be given for mixed case\n"
"characters.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Base.decode16(\"666F6F626172\")\n"
"    {:ok, \"foobar\"}\n"
"\n"
"    iex> Base.decode16(\"666f6f626172\", case: :lower)\n"
"    {:ok, \"foobar\"}\n"
"\n"
"    iex> Base.decode16(\"666f6F626172\", case: :mixed)\n"
"    {:ok, \"foobar\"}\n"
"\n"
msgstr ""
"base 16エンコードされた文字列をバイナリ文字列へ\n"
"デコードします。\n"
"\n"
"大文字からデコードするアトム`:upper`(デフォルト)と、\n"
"小文字からデコードする`:lower`を受け付けます。\n"
"混在した文字列に`:mixed`を与えることもできます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Base.decode16(\"666F6F626172\")\n"
"    {:ok, \"foobar\"}\n"
"\n"
"    iex> Base.decode16(\"666f6f626172\", case: :lower)\n"
"    {:ok, \"foobar\"}\n"
"\n"
"    iex> Base.decode16(\"666f6F626172\", case: :mixed)\n"
"    {:ok, \"foobar\"}\n"
"\n"

#. TRANSLATORS: def IO.ANSI.crossed_out()
#: lib/io/ansi.ex:75
msgid ""
"Crossed-out. Characters legible, but marked for deletion. Not widely "
"supported."
msgstr ""
"打消し線。文字は判読可能だが、削除として指定する。広くはサポートされていな"
"い。"

#. TRANSLATORS: def System.cwd()
#: lib/system.ex:95
msgid ""
"Current working directory.\n"
"\n"
"Returns the current working directory or `nil` if one\n"
"is not available.\n"
msgstr ""
"カレントワーキングディレクトリ。\n"
"\n"
"カレントワーキングディレクトリを返します。\n"
"もしそれが利用できないなら、`nil`を返します。\n"

#. TRANSLATORS: def System.cwd!()
#: lib/system.ex:116
msgid ""
"Current working directory, exception on error.\n"
"\n"
"Returns the current working directory or raises `RuntimeError`.\n"
msgstr ""
"カレントワーキングディレクトリ。エラー時に例外。\n"
"\n"
"カレントワーキングディレクトリを返します。または、`RuntimeError`を上げま"
"す。\n"

#. TRANSLATORS: def File.ln_s(existing, new)
#: lib/file.ex:399
msgid ""
"Creates a symbolic link `new` to the file or directory `existing`.\n"
"\n"
"Returns `:ok` if successful, `{:error, reason}` otherwise.\n"
"If the operating system does not support symlinks, returns\n"
"`{:error, :enotsup}`.\n"
msgstr ""
"シンボリックリンク`new`をファイルかディレクトリ`existing`に対して\n"
"作成します。\n"
"\n"
"成功すると`:ok`を返し、さもなければ`{:error, reason}`を返します。\n"
"もしオペレーティングシステムがシンボリックリンクをサポートしていないなら、\n"
"`{:error, :enotsup}`を返します。\n"

#. TRANSLATORS: def Kernel.struct(struct, kv \\ [])
#: lib/kernel.ex:1489
msgid ""
"Creates and updates structs.\n"
"\n"
"The struct argument may be an atom (which defines `defstruct`)\n"
"or a struct itself. The second argument is any Enumerable that\n"
"emits two-item tuples (key-value) during enumeration.\n"
"\n"
"If one of the keys in the Enumerable does not exist in the struct,\n"
"they are automatically discarded.\n"
"\n"
"This function is useful for dynamically creating and updating\n"
"structs.\n"
"\n"
"## Example\n"
"\n"
"    defmodule User do\n"
"      defstruct name: \"john\"\n"
"    end\n"
"\n"
"    struct(User)\n"
"    #=> %User{name: \"john\"}\n"
"\n"
"    opts = [name: \"meg\"]\n"
"    user = struct(User, opts)\n"
"    #=> %User{name: \"meg\"}\n"
"\n"
"    struct(user, unknown: \"value\")\n"
"    #=> %User{name: \"meg\"}\n"
"\n"
msgstr ""
"構造体を作成し、更新します。\n"
"\n"
"struct引数は(`defstruct`で定義された)アトムか、構造体自身です。\n"
"2番目の引数は、列挙のあいだ任意の2アイテムのタプル(キーバリュー)を\n"
"発するEnumerableです。\n"
"\n"
"Enumerableの中のキーの一つが構造体に存在しないなら、それは自動的に\n"
"捨てられます。\n"
"\n"
"この関数は動的に構造体を作成し、更新するのに便利です。\n"
"\n"
"## 例\n"
"\n"
"    defmodule User do\n"
"      defstruct name: \"john\"\n"
"    end\n"
"\n"
"    struct(User)\n"
"    #=> %User{name: \"john\"}\n"
"\n"
"    opts = [name: \"meg\"]\n"
"    user = struct(User, opts)\n"
"    #=> %User{name: \"meg\"}\n"
"\n"
"    struct(user, unknown: \"value\")\n"
"    #=> %User{name: \"meg\"}\n"
"\n"

#. TRANSLATORS: def StringIO.open(string, options \\ [])
#: lib/string_io.ex:38
msgid ""
"Creates an IO device.\n"
"\n"
"If the `:capture_prompt` option is set to `true`,\n"
"prompts (specified as arguments to `IO.get*` functions)\n"
"are captured.\n"
"\n"
"## Examples\n"
"\n"
"    iex> {:ok, pid} = StringIO.open(\"foo\")\n"
"    iex> IO.gets(pid, \">\")\n"
"    \"foo\"\n"
"    iex> StringIO.contents(pid)\n"
"    {\"\", \"\"}\n"
"\n"
"    iex> {:ok, pid} = StringIO.open(\"foo\", capture_prompt: true)\n"
"    iex> IO.gets(pid, \">\")\n"
"    \"foo\"\n"
"    iex> StringIO.contents(pid)\n"
"    {\"\", \">\"}\n"
"\n"
msgstr ""
"IOデバイスを作成します。\n"
"\n"
"もし`:capture_prompt`オプションが`true`にセットされたら、\n"
"(`IO.get*`関数に引数として指定された)プロンプトが捕捉されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> {:ok, pid} = StringIO.open(\"foo\")\n"
"    iex> IO.gets(pid, \">\")\n"
"    \"foo\"\n"
"    iex> StringIO.contents(pid)\n"
"    {\"\", \"\"}\n"
"\n"
"    iex> {:ok, pid} = StringIO.open(\"foo\", capture_prompt: true)\n"
"    iex> IO.gets(pid, \">\")\n"
"    \"foo\"\n"
"    iex> StringIO.contents(pid)\n"
"    {\"\", \">\"}\n"
"\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.{}(args)
#: lib/kernel/special_forms.ex:43
msgid ""
"Creates a tuple.\n"
"\n"
"Only two item tuples are considered literals in Elixir.\n"
"Therefore all other tuples are represented in the AST\n"
"as a call to the special form `:{}`.\n"
"\n"
"Conveniences for manipulating tuples can be found in the\n"
"`Tuple` module. Some functions for working with tuples are\n"
"also available in `Kernel`, namely `Kernel.elem/2`,\n"
"`Kernel.put_elem/3` and `Kernel.tuple_size/1`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> {1, 2, 3}\n"
"    {1, 2, 3}\n"
"\n"
"    iex> quote do: {1, 2, 3}\n"
"    {:{}, [], [1,2,3]}\n"
"\n"
msgstr ""
"タプルを作成します。\n"
"\n"
"2要素のタプルのみがElixirのリテラルと考えれれます。\n"
"従って、他の全てのタプルはスペシャルフォーム`:{}`への\n"
"呼び出しとしてASTにおいて表現されます。\n"
"\n"
"タプルを操作するための利器は`Tuple`モジュールで見付けることができます。\n"
"タプルで働くいくつかの関数は`Kernel`(すなわち、`Kernel.elem/2`、\n"
"`Kernel.put_elem/3`、`Kernel.tuple_size/1`)でも利用できます。\n"
"\n"
"## 例\n"
"\n"
"    iex> {1, 2, 3}\n"
"    {1, 2, 3}\n"
"\n"
"    iex> quote do: {1, 2, 3}\n"
"    {:{}, [], [1,2,3]}\n"
"\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.%(struct, map)
#: lib/kernel/special_forms.ex:165
msgid ""
"Creates a struct.\n"
"\n"
"A struct is a tagged map that allows developers to provide\n"
"default values for keys, tags to be used in polymorphic\n"
"dispatches and compile time assertions.\n"
"\n"
"To define a struct, you just need to implement the `__struct__/0`\n"
"function in a module:\n"
"\n"
"    defmodule User do\n"
"      def __struct__ do\n"
"        %{name: \"john\", age: 27}\n"
"      end\n"
"    end\n"
"\n"
"In practice though, structs are usually defined with the\n"
"`Kernel.defstruct/1` macro:\n"
"\n"
"    defmodule User do\n"
"      defstruct name: \"john\", age: 27\n"
"    end\n"
"\n"
"Now a struct can be created as follows:\n"
"\n"
"    %User{}\n"
"\n"
"Underneath a struct is just a map with a `__struct__` field\n"
"pointing to the `User` module:\n"
"\n"
"    %User{} == %{__struct__: User, name: \"john\", age: 27}\n"
"\n"
"A struct also validates that the given keys are part of the defined\n"
"struct. The example below will fail because there is no key\n"
"`:full_name` in the `User` struct:\n"
"\n"
"    %User{full_name: \"john doe\"}\n"
"\n"
"Note that a struct specifies a minimum set of keys required\n"
"for operations. Other keys can be added to structs via the\n"
"regular map operations:\n"
"\n"
"    user = %User{}\n"
"    Map.put(user, :a_non_struct_key, :value)\n"
"\n"
"An update operation specific for structs is also available:\n"
"\n"
"    %User{user | age: 28}\n"
"\n"
"The syntax above will guarantee the given keys are valid at\n"
"compilation time and it will guarantee at runtime the given\n"
"argument is a struct, failing with `BadStructError` otherwise.\n"
"\n"
"Although structs are maps, by default structs do not implement\n"
"any of the protocols implemented for maps. Check\n"
"`Kernel.defprotocol/2` for more information on how structs\n"
"can be used with protocols for polymorphic dispatch. Also\n"
"see `Kernel.struct/2` for examples on how to create and update\n"
"structs dynamically.\n"
msgstr ""
"構造体を作成します。\n"
"\n"
"構造体は、開発者にキーのデフォルト値を提供し、\n"
"ポリモーフィックにディスパッチされ、コンパイル時に\n"
"アサーションされる、タグづけされたマップです。\n"
"\n"
"構造体を定義するために、モジュールで関数`__struct__/0`を実装する必要が\n"
"あります:\n"
"\n"
"    defmodule User do\n"
"      def __struct__ do\n"
"        %{name: \"john\", age: 27}\n"
"      end\n"
"    end\n"
"\n"
"しかし実践的には、構造体は通常`Kernel.defstruct/1`マクロで定義されます:\n"
"\n"
"    defmodule User do\n"
"      defstruct name: \"john\", age: 27\n"
"    end\n"
"\n"
"今や、構造体は以下のように作成することができます:\n"
"\n"
"    %User{}\n"
"\n"
"構造体の下には、`__struct__`フィールドが`User`モジュールを示しているマップ\n"
"があります:\n"
"\n"
"    %User{} == %{__struct__: User, name: \"john\", age: 27}\n"
"\n"
"構造体は、所定のキーが定義済の構造体の一部であることの確認もします。\n"
"下の例は、`User`構造体には`:full_name`キーがないので、\n"
"失敗します:\n"
"\n"
"    %User{full_name: \"john doe\"}\n"
"\n"
"構造体は、操作のために必要とされるキーの最小限のセットを指定することに、\n"
"注意してください。他のキーは標準のマップ操作により追加できます:\n"
"\n"
"    user = %User{}\n"
"    Map.put(user, :a_non_struct_key, :value)\n"
"\n"
"構造体に特有の更新操作も利用できます:\n"
"\n"
"    %User{user | age: 28}\n"
"\n"
"上の構文は、与えられたキーがコンパイル時に有効であることを保証し、\n"
"実行時に与えられた引数が構造体であることを保証します。\n"
"さもなくば、`BadStructError`で失敗します。\n"
"\n"
"構造体はマップですが、デフォルトで構造体はマップのために実装されるべき、\n"
"いかなるプロトコルも実装していません。ポリモーフィックなディスパッチの\n"
"ために、プロトコルがどのように使われるかの詳細は、\n"
"`Kernel.defprotocol/2`をチェックしてください。どのように構造体を動的に\n"
"作成して更新するかの例については、`Kernel.struct/2`も参照してください。\n"

#. TRANSLATORS: def Stream.with_index(enum)
#: lib/stream.ex:763
msgid ""
"Creates a stream where each item in the enumerable will\n"
"be wrapped in a tuple alongside its index.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.with_index([1, 2, 3])\n"
"    iex> Enum.to_list(stream)\n"
"    [{1,0},{2,1},{3,2}]\n"
"\n"
msgstr ""
"enumerableのそれぞれのアイテムが、\n"
"そのインデックスと一緒にタプルにラップされた、\n"
"ストリームを作成します。\n"
"\n"
"## 例\n"
"\n"
"    iex> stream = Stream.with_index([1, 2, 3])\n"
"    iex> Enum.to_list(stream)\n"
"    [{1,0},{2,1},{3,2}]\n"
"\n"

#. TRANSLATORS: def Stream.reject(enum, fun)
#: lib/stream.ex:430
msgid ""
"Creates a stream that will reject elements according to\n"
"the given function on enumeration.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.reject([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    iex> Enum.to_list(stream)\n"
"    [1,3]\n"
"\n"
msgstr ""
"与えられた関数に従って、列挙中の要素を拒否する\n"
"ストリームを作成します。\n"
"\n"
"## 例\n"
"\n"
"    iex> stream = Stream.reject([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    iex> Enum.to_list(stream)\n"
"    [1,3]\n"
"\n"

#. TRANSLATORS: def Stream.flat_map(enum, mapper)
#: lib/stream.ex:307
msgid ""
"Creates a stream that will apply the given function on enumeration and\n"
"flatten the result.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.flat_map([1, 2, 3], fn(x) -> [x, x * 2] end)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 2, 4, 3, 6]\n"
"\n"
msgstr ""
"列挙において、与えられた関数を適用し、結果をフラット化するストリームを\n"
"作成します。\n"
"\n"
"## 例\n"
"\n"
"    iex> stream = Stream.flat_map([1, 2, 3], fn(x) -> [x, x * 2] end)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 2, 4, 3, 6]\n"
"\n"

#. TRANSLATORS: def Stream.map(enum, fun)
#: lib/stream.ex:414
msgid ""
"Creates a stream that will apply the given function on\n"
"enumeration.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.map([1, 2, 3], fn(x) -> x * 2 end)\n"
"    iex> Enum.to_list(stream)\n"
"    [2,4,6]\n"
"\n"
msgstr ""
"列挙において、与えられた関数を適用するストリームを\n"
"作成します。\n"
"\n"
"## 例\n"
"\n"
"    iex> stream = Stream.map([1, 2, 3], fn(x) -> x * 2 end)\n"
"    iex> Enum.to_list(stream)\n"
"    [2,4,6]\n"
"\n"

#. TRANSLATORS: def Stream.take_every(enum, n)
#: lib/stream.ex:570
msgid ""
"Creates a stream that takes every `n` item from the enumerable.\n"
"\n"
"The first item is always included, unless `n` is 0.\n"
"\n"
"`n` must be a non-negative integer, or `FunctionClauseError` will be "
"thrown.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.take_every(1..10, 2)\n"
"    iex> Enum.to_list(stream)\n"
"    [1,3,5,7,9]\n"
"\n"
msgstr ""
"enumerableから`n`アイテム毎に取り出すストリームを\n"
"作成します。\n"
"\n"
"`n`は0でないかぎり、最初のアイテムは常に含まれます。\n"
"\n"
"`n`は非負の整数でなければなりません。さもなくば、\n"
"`FunctionClauseError`を投げます。\n"
"\n"
"## 例\n"
"\n"
"    iex> stream = Stream.take_every(1..10, 2)\n"
"    iex> Enum.to_list(stream)\n"
"    [1,3,5,7,9]\n"
"\n"

#. TRANSLATORS: def Stream.uniq(enum, fun \\ fn x -> x end)
#: lib/stream.ex:747
msgid ""
"Creates a stream that only emits elements if they are unique.\n"
"\n"
"Keep in mind that, in order to know if an element is unique\n"
"or not, this function needs to store all unique values emitted\n"
"by the stream. Therefore, if the stream is infinite, the number\n"
"of items stored will grow infinitely, never being garbage collected.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.uniq([1, 2, 3, 2, 1]) |> Enum.to_list\n"
"    [1, 2, 3]\n"
"\n"
"    iex> Stream.uniq([{1, :x}, {2, :y}, {1, :z}], fn {x, _} -> x end) |> "
"Enum.to_list\n"
"    [{1,:x}, {2,:y}]\n"
"\n"
msgstr ""
"ユニークな要素だけを発するストリームを作成します。\n"
"\n"
"要素がユニークかそうでないかを知るために、この関数は、\n"
"ストリームから発せられた全てのユニークな値を保存する必要が\n"
"あることを心にとめておいていください。\n"
"従って、ストリームが無限であるなら、保存された値の数は無現に\n"
"増大し、決してガーベジコレクションされません。\n"
"\n"
"## 例\n"
"\n"
"    iex> Stream.uniq([1, 2, 3, 2, 1]) |> Enum.to_list\n"
"    [1, 2, 3]\n"
"\n"
"    iex> Stream.uniq([{1, :x}, {2, :y}, {1, :z}], fn {x, _} -> x end) |> "
"Enum.to_list\n"
"    [{1,:x}, {2,:y}]\n"
"\n"

#. TRANSLATORS: def Stream.filter(enum, fun)
#: lib/stream.ex:323
msgid ""
"Creates a stream that filters elements according to\n"
"the given function on enumeration.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.filter([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    iex> Enum.to_list(stream)\n"
"    [2]\n"
"\n"
msgstr ""
"列挙において、与えられた関数に従って要素をフィルタする\n"
"ストリームを作成します。\n"
"\n"
"## 例\n"
"\n"
"    iex> stream = Stream.filter([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    iex> Enum.to_list(stream)\n"
"    [2]\n"
"\n"

#. TRANSLATORS: def Stream.filter_map(enum, filter, mapper)
#: lib/stream.ex:341
msgid ""
"Creates a stream that filters and then maps elements according\n"
"to given functions.\n"
"\n"
"Exists for symmetry with `Enum.filter_map/3`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.filter_map(1..6, fn(x) -> rem(x, 2) == 0 end, &(&1 "
"* 2))\n"
"    iex> Enum.to_list(stream)\n"
"    [4,8,12]\n"
"\n"
msgstr ""
"与えられた関数に従って、要素をフィルタしてマップする\n"
"ストリームを作成します。\n"
"\n"
"`Enum.filter_map/3`との対称性の為に存在します。\n"
"\n"
"## 例\n"
"\n"
"    iex> stream = Stream.filter_map(1..6, fn(x) -> rem(x, 2) == 0 end, &(&1 "
"* 2))\n"
"    iex> Enum.to_list(stream)\n"
"    [4,8,12]\n"
"\n"

#. TRANSLATORS: def Stream.concat(first, second)
#: lib/stream.ex:801
msgid ""
"Creates a stream that enumerates the first argument, followed by the "
"second.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.concat(1..3, 4..6)\n"
"    iex> Enum.to_list(stream)\n"
"    [1,2,3,4,5,6]\n"
"\n"
"    iex> stream1 = Stream.cycle([1, 2, 3])\n"
"    iex> stream2 = Stream.cycle([4, 5, 6])\n"
"    iex> stream = Stream.concat(stream1, stream2)\n"
"    iex> Enum.take(stream, 6)\n"
"    [1,2,3,1,2,3]\n"
"\n"
msgstr ""
"最初の引数を列挙し、それから2番目を続ける\n"
"ストリームを作成します。\n"
"\n"
"## 例\n"
"\n"
"    iex> stream = Stream.concat(1..3, 4..6)\n"
"    iex> Enum.to_list(stream)\n"
"    [1,2,3,4,5,6]\n"
"\n"
"    iex> stream1 = Stream.cycle([1, 2, 3])\n"
"    iex> stream2 = Stream.cycle([4, 5, 6])\n"
"    iex> stream = Stream.concat(stream1, stream2)\n"
"    iex> Enum.take(stream, 6)\n"
"    [1,2,3,1,2,3]\n"
"\n"

#. TRANSLATORS: def Stream.concat(enumerables)
#: lib/stream.ex:780
msgid ""
"Creates a stream that enumerates each enumerable in an enumerable.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.concat([1..3, 4..6, 7..9])\n"
"    iex> Enum.to_list(stream)\n"
"    [1,2,3,4,5,6,7,8,9]\n"
"\n"
msgstr ""
"enumerableの中のそれぞれのenumerableを列挙する、\n"
"ストリームを作成します。\n"
"\n"
"## 例\n"
"\n"
"    iex> stream = Stream.concat([1..3, 4..6, 7..9])\n"
"    iex> Enum.to_list(stream)\n"
"    [1,2,3,4,5,6,7,8,9]\n"
"\n"

#. TRANSLATORS: def Stream.interval(n)
#: lib/stream.ex:357
msgid ""
"Creates a stream that emits a value every `n` milliseconds.\n"
"\n"
"The values emitted are an increasing counter starting at `0`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.interval(10) |> Enum.take(10)\n"
"    [0,1,2,3,4,5,6,7,8,9]\n"
"\n"
msgstr ""
"`n`ミリセカンド毎に値を発生するストリームを作成します。\n"
"\n"
"発生される値は`0`から開始されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Stream.interval(10) |> Enum.take(10)\n"
"    [0,1,2,3,4,5,6,7,8,9]\n"
"\n"

#. TRANSLATORS: def Stream.timer(n)
#: lib/stream.ex:604
msgid ""
"Creates a stream that emits a single value after `n` milliseconds.\n"
"\n"
"The value emitted is `0`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.timer(10) |> Enum.to_list\n"
"    [0]\n"
"\n"
msgstr ""
"`n`ミリセカンド後に一つの値を発生するストリームを作成します。\n"
"\n"
"発生する値は`0`です。\n"
"\n"
"## 例\n"
"\n"
"    iex> Stream.timer(10) |> Enum.to_list\n"
"    [0]\n"
"\n"

#. TRANSLATORS: def Stream.cycle(enumerable)
#: lib/stream.ex:892
msgid ""
"Creates a stream that cycles through the given enumerable,\n"
"infinitely.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.cycle([1,2,3])\n"
"    iex> Enum.take(stream, 5)\n"
"    [1,2,3,1,2]\n"
"\n"
msgstr ""
"与えられたenumerableを通して、無現に循環する\n"
"ストリームを作成します。\n"
"\n"
"## 例\n"
"\n"
"    iex> stream = Stream.cycle([1,2,3])\n"
"    iex> Enum.take(stream, 5)\n"
"    [1,2,3,1,2]\n"
"\n"

#. TRANSLATORS: def Stream.scan(enum, acc, fun)
#: lib/stream.ex:489
msgid ""
"Creates a stream that applies the given function to each\n"
"element, emits the result and uses the same result as the accumulator\n"
"for the next computation. Uses the given `acc` as the starting value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.scan(1..5, 0, &(&1 + &2))\n"
"    iex> Enum.to_list(stream)\n"
"    [1,3,6,10,15]\n"
"\n"
msgstr ""
"与えられた関数をそれぞれの要素とアキュムレータに適用し、\n"
"結果を発行するストリームを作成します。\n"
"その結果は、次の計算のためのアキュムレータとしても使われます。\n"
"\n"
"初期値は与えられた`acc`を使います。\n"
"\n"
"## 例\n"
"\n"
"    iex> stream = Stream.scan(1..5, 0, &(&1 + &2))\n"
"    iex> Enum.to_list(stream)\n"
"    [1,3,6,10,15]\n"
"\n"

#. TRANSLATORS: def Stream.scan(enum, fun)
#: lib/stream.ex:472
msgid ""
"Creates a stream that applies the given function to each\n"
"element, emits the result and uses the same result as the accumulator\n"
"for the next computation.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.scan(1..5, &(&1 + &2))\n"
"    iex> Enum.to_list(stream)\n"
"    [1,3,6,10,15]\n"
"\n"
msgstr ""
"与えられた関数をそれぞれの要素とアキュムレータに適用し、\n"
"結果を発行するストリームを作成します。\n"
"その結果は、次の計算のためのアキュムレータとしても使われます。\n"
"\n"
"## 例\n"
"\n"
"    iex> stream = Stream.scan(1..5, &(&1 + &2))\n"
"    iex> Enum.to_list(stream)\n"
"    [1,3,6,10,15]\n"
"\n"

#. TRANSLATORS: def Tuple.duplicate(data, size)
#: lib/tuple.ex:21
msgid ""
"Creates a new tuple.\n"
"\n"
"Creates a tuple of size `size` containing the\n"
"given `data` at every position.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Tuple.duplicate(:hello, 3)\n"
"    {:hello, :hello, :hello}\n"
"\n"
msgstr ""
"新しいタプルを作成します。\n"
"\n"
"全ての位置に与えられた`data`を含む、\n"
"`size`サイズのタプルを作成します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Tuple.duplicate(:hello, 3)\n"
"    {:hello, :hello, :hello}\n"
"\n"

#. TRANSLATORS: def Range.new(first, last)
#: lib/range.ex:27
msgid "Creates a new range.\n"
msgstr "新しい範囲(range)を作成します。\n"

#. TRANSLATORS: def HashSet.new()
#: lib/hash_set.ex:36
msgid "Creates a new empty set.\n"
msgstr "新しい、空のsetを作成します。\n"

#. TRANSLATORS: def HashDict.new()
#: lib/hash_dict.ex:36
msgid "Creates a new empty dict.\n"
msgstr "新しい、空のdictを作成します。\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.%{}(args)
#: lib/kernel/special_forms.ex:103
msgid ""
"Creates a map.\n"
"\n"
"Maps are key-value stores where keys are compared\n"
"using the match operator (`===`). Maps can be created with\n"
"the `%{}` special form where keys are associated via `=>`:\n"
"\n"
"    %{1 => 2}\n"
"\n"
"Maps also support the keyword notation, as other special forms,\n"
"as long as they are at the end of the argument list:\n"
"\n"
"    %{hello: :world, with: :keywords}\n"
"    %{:hello => :world, with: :keywords}\n"
"\n"
"If a map has duplicated keys, the last key will always have\n"
"higher precedence:\n"
"\n"
"    iex> %{a: :b, a: :c}\n"
"    %{a: :c}\n"
"\n"
"Conveniences for manipulating maps can be found in the\n"
"`Map` module.\n"
"\n"
"## Access syntax\n"
"\n"
"Besides the access functions available in the `Map` module,\n"
"like `Map.get/3` and `Map.fetch/2`, a map can be accessed using the\n"
"`.` operator:\n"
"\n"
"    iex> map = %{a: :b}\n"
"    iex> map.a\n"
"    :b\n"
"\n"
"Note that the `.` operator expects the field to exist in the map.\n"
"If not, an `ArgumentError` is raised.\n"
"\n"
"## Update syntax\n"
"\n"
"Maps also support an update syntax:\n"
"\n"
"    iex> map = %{:a => :b}\n"
"    iex> %{map | :a => :c}\n"
"    %{:a => :c}\n"
"\n"
"Notice the update syntax requires the given keys to exist.\n"
"Trying to update a key that does not exist will raise an `ArgumentError`.\n"
"\n"
"## AST representation\n"
"\n"
"Regardless if `=>` or the keywords syntax is used, Maps are\n"
"always represented internally as a list of two-items tuples\n"
"for simplicity:\n"
"\n"
"    iex> quote do: %{:a => :b, c: :d}\n"
"    {:%{}, [], [{:a, :b}, {:c, :d}]}\n"
"\n"
msgstr ""
"マップを作成します。\n"
"\n"
"マップは、キーをマッチオペレータ(`===`)で比較する、\n"
"キーバリューストアです。マップは、キーを`=>`で関連付けた\n"
"`%{}`スペシャルフォームで、作成することができます:\n"
"\n"
"    %{1 => 2}\n"
"\n"
"引数リストの終わりにいる限り、マップは、他のスペシャルフォーム\n"
"として、キーワード記法もサポートします:\n"
"\n"
"    %{hello: :world, with: :keywords}\n"
"    %{:hello => :world, with: :keywords}\n"
"\n"
"もしマップが重複したキーをもったら、最後のキーが常に高い優先度を持ちま\n"
"す:\n"
"\n"
"    iex> %{a: :b, a: :c}\n"
"    %{a: :c}\n"
"\n"
"マップ操作のための便利さは`Map`モジュールで見付けることができます。\n"
"\n"
"## アクセス構文\n"
"\n"
"`Map.get/3`や`Map.fetch/2`のような、`Map`モジュールで有効なアクセス関数\n"
"の他に、マップは`.`オペレータを使ってアクセスすることが出来ます:\n"
"\n"
"    iex> map = %{a: :b}\n"
"    iex> map.a\n"
"    :b\n"
"\n"
"なお、`.`オペレータはマップの中にフィールドが存在することを期待してます。\n"
"もしないなら、`ArgumentError`が上ります。\n"
"\n"
"## 更新構文\n"
"\n"
"マップは更新構文もサポートします:\n"
"\n"
"    iex> map = %{:a => :b}\n"
"    iex> %{map | :a => :c}\n"
"    %{:a => :c}\n"
"\n"
"更新構文は、与えられたキーが存在することを要求することに、\n"
"注意してください。\n"
"存在しないキーを更新しようとすると、`ArgumentError`が上ります。\n"
"\n"
"## AST表現\n"
"\n"
"`=>`またはキーワード構文が使われたかを気にせずに、マップは、\n"
"常に内部的には単純さの為に2要素のタプルのリストとして表現されます:\n"
"\n"
"    iex> quote do: %{:a => :b, c: :d}\n"
"    {:%{}, [], [{:a, :b}, {:c, :d}]}\n"
"\n"

#. TRANSLATORS: def File.copy(source, destination, bytes_count \\ :infinity)
#: lib/file.ex:426
msgid ""
"Copies the contents of `source` to `destination`.\n"
"\n"
"Both parameters can be a filename or an io device opened\n"
"with `open/2`. `bytes_count` specifies the number of\n"
"bytes to copy, the default being `:infinity`.\n"
"\n"
"If file `destination` already exists, it is overwritten\n"
"by the contents in `source`.\n"
"\n"
"Returns `{:ok, bytes_copied}` if successful,\n"
"`{:error, reason}` otherwise.\n"
"\n"
"Compared to the `cp/3`, this function is more low-level,\n"
"allowing a copy from device to device limited by a number of\n"
"bytes. On the other hand, `cp/3` performs more extensive\n"
"checks on both source and destination and it also preserves\n"
"the file mode after copy.\n"
"\n"
"Typical error reasons are the same as in `open/2`,\n"
"`read/1` and `write/3`.\n"
msgstr ""
"`source`の内容を`destination`にコピーします。\n"
"\n"
"両方のパラメタは、ファイル名か、`open/2`でオープンされたIOデバイスです。\n"
"`bytes_count`はコピーするバイト数を指定します。デフォルトは\n"
"`:infinity`です。\n"
"\n"
"もしファイル`destination`が既に存在していたら、`source`の\n"
"内容によって上書きされます。\n"
"\n"
"成功すれば、`{:ok, bytes_copied}`を返し、さもなくば、\n"
"`{:error, reason}`を返します。\n"
"\n"
"`cp/3`と比較して、この関数はより低レベルで、デバイスからデバイスへの\n"
"コピーについて、バイト数で制限することを許します。\n"
"一方で、`cp/3`は、\n"
"ソースとデスティネーションの両方でより広範位なチェックを実行し、\n"
"コピーの後で、ファイルモードを維持します。\n"
"\n"
"典型的なエラーreasonは`open/2`、`read/2`、`write/3`と同じです。\n"

#. TRANSLATORS: def Process.link(pid)
#: lib/process.ex:249
msgid ""
"Creates a link between the calling process and another process\n"
"(or port) `pid`, if there is not such a link already.\n"
"\n"
"See http://www.erlang.org/doc/man/erlang.html#link-1 for more info.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"呼び出し側プロセスと他のプロセス(またはport)`pid`の間に、まだ\n"
"リンクがなければ、リンクを作成します。\n"
"\n"
"詳細は、\n"
" http://www.erlang.org/doc/man/erlang.html#link-1 を参照してください。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Keyword.new(pairs)
#: lib/keyword.ex:69
msgid ""
"Creates a keyword from an enumerable.\n"
"\n"
"Duplicated entries are removed, the latest one prevails.\n"
"Unlike `Enum.into(enumerable, [])`,\n"
"`Keyword.new(enumerable)` guarantees the keys are unique.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.new([{:b, 1}, {:a, 2}])\n"
"    [a: 2, b: 1]\n"
"\n"
msgstr ""
"enumerableからキーワードリストを作成します。\n"
"\n"
"重複したエントリは削除され、最後のものが勝ちます。\n"
"`Enum.into(enumerable, [])`と異なり、`Keyword.new(enumerable)`は\n"
"キーのユニーク性を保証します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.new([{:b, 1}, {:a, 2}])\n"
"    [a: 2, b: 1]\n"
"\n"

#. TRANSLATORS: def Keyword.new(pairs, transform)
#: lib/keyword.ex:89
msgid ""
"Creates a keyword from an enumerable via the transformation function.\n"
"\n"
"Duplicated entries are removed, the latest one prevails.\n"
"Unlike `Enum.into(enumerable, [], fun)`,\n"
"`Keyword.new(enumerable, fun)` guarantees the keys are unique.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.new([:a, :b], fn (x) -> {x, x} end) |> Enum.sort\n"
"    [a: :a, b: :b]\n"
"\n"
msgstr ""
"enumerableから変形関数によって、キーワードリストを作成します。\n"
"\n"
"重複したエントリは削除され、最後のものが勝ちます。\n"
"`Enum.into(enumerable, [])`と異なり、`Keyword.new(enumerable)`は\n"
"キーのユニーク性を保証します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.new([:a, :b], fn (x) -> {x, x} end) |> Enum.sort\n"
"    [a: :a, b: :b]\n"
"\n"

#. TRANSLATORS: def Range.Iterator.count(first, range)
#: lib/range.ex:60
msgid "Counts how many items are in the range.\n"
msgstr "範囲(range)のアイテムの数を数えます。\n"

#. TRANSLATORS: def File.cp_r(source, destination, callback \\ fn _, _ -> true end)
#: lib/file.ex:537
msgid ""
"Copies the contents in source to destination.\n"
"\n"
"If the source is a file, it copies `source` to\n"
"`destination`. If the source is a directory, it copies\n"
"the contents inside source into the destination.\n"
"\n"
"If a file already exists in the destination,\n"
"it invokes a callback which should return\n"
"`true` if the existing file should be overwritten,\n"
"`false` otherwise. It defaults to return `true`.\n"
"\n"
"If a directory already exists in the destination\n"
"where a file is meant to be (or otherwise), this\n"
"function will fail.\n"
"\n"
"This function may fail while copying files,\n"
"in such cases, it will leave the destination\n"
"directory in a dirty state, where already\n"
"copied files won't be removed.\n"
"\n"
"It returns `{:ok, files_and_directories}` in case of\n"
"success with all files and directories copied in no\n"
"specific order, `{:error, reason, file}` otherwise.\n"
"\n"
"Note: The command `cp` in Unix systems behaves differently\n"
"depending if `destination` is an existing directory or not.\n"
"We have chosen to explicitly disallow this behaviour.\n"
"\n"
"## Examples\n"
"\n"
"    # Copies \"a.txt\" to \"tmp\"\n"
"    File.cp_r \"a.txt\", \"tmp.txt\"\n"
"\n"
"    # Copies all files in \"samples\" to \"tmp\"\n"
"    File.cp_r \"samples\", \"tmp\"\n"
"\n"
"    # Same as before, but asks the user how to proceed in case of conflicts\n"
"    File.cp_r \"samples\", \"tmp\", fn(source, destination) ->\n"
"      IO.gets(\"Overwriting #{destination} by #{source}. Type y to confirm."
"\") == \"y\"\n"
"    end\n"
"\n"
msgstr ""
"sourceの内容をdestinationへコピーします。\n"
"\n"
"Copies the contents in source to destination.\n"
"\n"
"もしsourceがファイルなら、`source`を`destination`へコピーします。\n"
"もしsourceがディレクトリなら、sourceの中のコンテンツを\n"
"destinationにコピーします。\n"
"\n"
"もしデスティネーションにファイルが存在したら、\n"
"callbackが起動され、そのファイルは上書きされる\n"
"べきなら、`true`を返し、さもなくば、\n"
"`false`を返すようにします。デフォルトのコールバック\n"
"は`true`を返します。\n"
"\n"
"ファイルがあるはずであるデスティネーションに\n"
"ディレクトリが既に存在するか、ファイルがないなら、\n"
"この関数は失敗します。\n"
"\n"
"この関数はファイルのコピー中に失敗するかもしれません。そのような場合、\n"
"デスティネーションディレクトリをダーティステートのままです。つまり、既\n"
"にコピーしたファイルは削除されません。\n"
"\n"
"成功すると、順不同でコピーされたファイルとディレクトリすべてを`{:ok,\n"
"files_and_directories}`で返します。\n"
"さもなければ、`{:error, reason, file}`を返します。\n"
"\n"
"注意: Unixシステムの`cp`コマンドは、`destination`が既存の\n"
"ディレクトリか否かで異った振る舞いをします。我々は、この振る舞いを\n"
"明確に認めないほうを選びました。\n"
"\n"
"## 例\n"
"\n"
"    # Copies \"a.txt\" to \"tmp\"\n"
"    File.cp_r \"a.txt\", \"tmp.txt\"\n"
"\n"
"    # Copies all files in \"samples\" to \"tmp\"\n"
"    File.cp_r \"samples\", \"tmp\"\n"
"\n"
"    # Same as before, but asks the user how to proceed in case of conflicts\n"
"    File.cp_r \"samples\", \"tmp\", fn(source, destination) ->\n"
"      IO.gets(\"Overwriting #{destination} by #{source}. Type y to confirm."
"\") == \"y\"\n"
"    end\n"
"\n"

#. TRANSLATORS: def File.cp(source, destination, callback \\ fn _, _ -> true end)
#: lib/file.ex:466
msgid ""
"Copies the contents in `source` to `destination` preserving its mode.\n"
"\n"
"If a file already exists in the destination, it invokes a\n"
"callback which should return `true` if the existing file\n"
"should be overwritten, `false` otherwise. It defaults to return `true`.\n"
"\n"
"It returns `:ok` in case of success, returns\n"
"`{:error, reason}` otherwise.\n"
"\n"
"If you want to copy contents from an io device to another device\n"
"or do a straight copy from a source to a destination without\n"
"preserving modes, check `copy/3` instead.\n"
"\n"
"Note: The command `cp` in Unix systems behaves differently depending\n"
"if `destination` is an existing directory or not. We have chosen to\n"
"explicitly disallow this behaviour. If destination is a directory, an\n"
"error will be returned.\n"
msgstr ""
"sourceの内容をdestinationへ、モードを維持してコピーします。\n"
"\n"
"もしデスティネーションにファイルが存在したら、\n"
"callbackが起動され、そのファイルは上書きされる\n"
"べきなら、`true`を返し、さもなくば、\n"
"`false`を返すようにします。デフォルトのコールバック\n"
"は`true`を返します。\n"
"\n"
"成功すると、`{:ok}を返し、さもなければ、`{:error, reason}`を返します。\n"
"\n"
"もしIOデバイスから他のデバイスへコピーしたいとか、直接\n"
"sourceからdestinationへモードの維持なしでコピーしたいなら、代りに\n"
"`copy/3`をチェックしてください。\n"
"\n"
"注意: Unixシステムの`cp`コマンドは、`destination`が既存の\n"
"ディレクトリか否かで異った振る舞いをします。我々は、この振る舞いを\n"
"明確に認めないほうを選びました。もしdestinationがディレクトリなら、\n"
"エラーを返します。\n"

#. TRANSLATORS: def Path.expand(path)
#: lib/path.ex:138
msgid ""
"Converts the path to an absolute one and expands\n"
"any `.` and `..` characters and a leading `~`.\n"
"\n"
"## Examples\n"
"\n"
"    Path.expand(\"/foo/bar/../bar\")\n"
"    \"/foo/bar\"\n"
"\n"
msgstr ""
"pathを`.`と`..`、先頭の`~`を展開し、絶対パスに変換します。\n"
"\n"
"## 例\n"
"\n"
"    Path.expand(\"/foo/bar/../bar\")\n"
"    \"/foo/bar\"\n"
"\n"

#. TRANSLATORS: def IO.stream(device, line_or_codepoints)
#: lib/io.ex:287
msgid ""
"Converts the io device into a `IO.Stream`.\n"
"\n"
"An `IO.Stream` implements both `Enumerable` and\n"
"`Collectable`, allowing it to be used for both read\n"
"and write.\n"
"\n"
"The device is iterated line by line if `:line` is given or\n"
"by a given number of codepoints.\n"
"\n"
"This reads the IO as utf-8. Check out\n"
"`IO.binstream/2` to handle the IO as a raw binary.\n"
"\n"
"Note that an IO stream has side effects and every time\n"
"you go over the stream you may get different results.\n"
"\n"
"## Examples\n"
"\n"
"Here is an example on how we mimic an echo server\n"
"from the command line:\n"
"\n"
"    Enum.each IO.stream(:stdio, :line), &IO.write(&1)\n"
"\n"
msgstr ""
"IOデバイスをを`IO.Stream`に変換します。\n"
"\n"
"`IO.Stream`は、読み書きの両方で使えるように、`Enumerable`と\n"
"`Collectable`の両方を実装します。\n"
"\n"
"deviceは`:line`が与えられたら、行ごとに繰り返され、\n"
"そうでないなら、コードポイントの数毎に繰り返されます。\n"
"\n"
"これはutf-8としてIOを読み込みます。rawバイナリとして\n"
"IOをハンドルするために、`IO.binstream/2`をチェックしてください。\n"
"\n"
"IOストリームは副作用を持つことに注意してください。\n"
"ストリームを調べるたびに、異る結果を得るでしょう。\n"
"\n"
"## 例\n"
"\n"
"どのようにコマンドラインからechoサーバに擬態するかという\n"
"例です:\n"
"\n"
"    Enum.each IO.stream(:stdio, :line), &IO.write(&1)\n"
"\n"

#. TRANSLATORS: def Code.string_to_quoted(string, opts \\ [])
#: lib/code.ex:235
msgid ""
"Converts the given string to its quoted form.\n"
"\n"
"Returns `{:ok, quoted_form}`\n"
"if it succeeds, `{:error, {line, error, token}}` otherwise.\n"
"\n"
"## Options\n"
"\n"
"  * `:file` - the filename to be used in stacktraces\n"
"    and the file reported in the `__ENV__` variable\n"
"\n"
"  * `:line` - the line reported in the `__ENV__` variable\n"
"\n"
"  * `:existing_atoms_only` - when `true`, raises an error\n"
"    when non-existing atoms are found by the tokenizer\n"
"\n"
"## Macro.to_string/2\n"
"\n"
"The opposite of converting a string to its quoted form is\n"
"`Macro.to_string/2`, which converts a quoted form to a string/binary\n"
"representation.\n"
msgstr ""
"与えられた文字列をquoteされたフォームに変換します。\n"
"\n"
"成功すれば、`{:ok, quoted_form}`を返し、さもなければ、`{:error, {line,\n"
"error, token}}`を返します。\n"
"\n"
"## オプション\n"
"\n"
"  * `:file` - スタックトレースと、`__ENV__`変数に格納されるファイル名を\n"
"    指定します\n"
"\n"
"  * `:line` - `__ENV__`変数に格納される行番号を指定します\n"
"\n"
"  * `:existing_atoms_only` - `true`の時、トークナイザーにより、存在しな\n"
"    いatomが見付かったとき、エラーを上げます\n"
"\n"
"## Macro.to_string/2\n"
"\n"
"文字列をquoteされたフォームに変換することの反対は`Macro.to_string/2`で\n"
"す。それはquoteされたフォームを文字列/バイナリの表現に変換します。\n"

#. TRANSLATORS: def Code.string_to_quoted!(string, opts \\ [])
#: lib/code.ex:251
msgid ""
"Converts the given string to its quoted form.\n"
"\n"
"It returns the ast if it succeeds,\n"
"raises an exception otherwise. The exception is a `TokenMissingError`\n"
"in case a token is missing (usually because the expression is incomplete),\n"
"`SyntaxError` otherwise.\n"
"\n"
"Check `string_to_quoted/2` for options information.\n"
msgstr ""
"与えられた文字列をquoteされたフォームに変換します。\n"
"\n"
"成功すれば、`{:ok, quoted_form}`を返し、さもなければ、\n"
"例外を上げます。例外は、トークンが足りない場合に(通常は式が\n"
"不完全の時です)、`TokenMissingError`で、さもなくば`SyntaxError`です。\n"
"\n"
"オプション情報は `string_to_quoted/2` を参照してください。\n"

#. TRANSLATORS: def Path.absname(path)
#: lib/path.ex:39
msgid ""
"Converts the given path to an absolute one. Unlike\n"
"`expand/1`, no attempt is made to resolve `..`, `.` or `~`.\n"
"\n"
"## Unix examples\n"
"\n"
"    Path.absname(\"foo\")\n"
"    #=> \"/usr/local/foo\"\n"
"\n"
"    Path.absname(\"../x\")\n"
"    #=> \"/usr/local/../x\"\n"
"\n"
"## Windows\n"
"\n"
"    Path.absname(\"foo\").\n"
"    \"D:/usr/local/foo\"\n"
"    Path.absname(\"../x\").\n"
"    \"D:/usr/local/../x\"\n"
"\n"
msgstr ""
"与えられたpathを絶対パスにに変換します。\n"
"`expand/1`と違って、`..`、`.`、`~`を解決しません。\n"
"\n"
"## Unixの例\n"
"\n"
"    Path.absname(\"foo\")\n"
"    #=> \"/usr/local/foo\"\n"
"\n"
"    Path.absname(\"../x\")\n"
"    #=> \"/usr/local/../x\"\n"
"\n"
"## Windows\n"
"\n"
"    Path.absname(\"foo\").\n"
"    \"D:/usr/local/foo\"\n"
"    Path.absname(\"../x\").\n"
"    \"D:/usr/local/../x\"\n"
"\n"

#. TRANSLATORS: def IO.binstream(device, line_or_bytes)
#: lib/io.ex:308
msgid ""
"Converts the IO device into a `IO.Stream`.\n"
"\n"
"An `IO.Stream` implements both `Enumerable` and\n"
"`Collectable`, allowing it to be used for both read\n"
"and write.\n"
"\n"
"The device is iterated line by line or by a number of bytes.\n"
"This reads the IO device as a raw binary.\n"
"\n"
"Note that an IO stream has side effects and every time\n"
"you go over the stream you may get different results.\n"
"\n"
"Finally, do not use this function on IO devices in unicode\n"
"mode as it will return the wrong result.\n"
msgstr ""
"IOデバイスをを`IO.Stream`に変換します。\n"
"\n"
"`IO.Stream`は、読み書きの両方で使えるように、`Enumerable`と\n"
"`Collectable`の両方を実装します。\n"
"\n"
"deviceは`:line`が与えられたら、行ごとか、バイトごとに繰り返さます。\n"
"これはrawバイナリとしてIOデバイスを読み込みます。\n"
"\n"
"IOストリームは副作用を持つことに注意してください。\n"
"ストリームを調べるたびに、異る結果を得るでしょう。\n"
"\n"
"最後に、unicodeモードのIOデバイスでこの関数を使わないでください。\n"
"間違った結果を返すかもしれません。\n"

#. TRANSLATORS: def Macro.to_string(tree, fun \\ fn _ast, string -> string end)
#: lib/macro.ex:453
msgid ""
"Converts the given expression to a binary.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Macro.to_string(quote do: foo.bar(1, 2, 3))\n"
"    \"foo.bar(1, 2, 3)\"\n"
"\n"
msgstr ""
"与えられた式をバイナリに変換します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Macro.to_string(quote do: foo.bar(1, 2, 3))\n"
"    \"foo.bar(1, 2, 3)\"\n"
"\n"

#. TRANSLATORS: def String.capitalize(string)
#: lib/string.ex:443
msgid ""
"Converts the first character in the given string to\n"
"uppercase and the remaining to lowercase.\n"
"\n"
"This relies on the titlecase information provided\n"
"by the Unicode Standard. Note this function makes\n"
"no attempt to capitalize all words in the string\n"
"(usually known as titlecase).\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.capitalize(\"abcd\")\n"
"    \"Abcd\"\n"
"\n"
"    iex> String.capitalize(\"ﬁn\")\n"
"    \"Fin\"\n"
"\n"
"    iex> String.capitalize(\"olá\")\n"
"    \"Olá\"\n"
"\n"
msgstr ""
"与えられた文字列の最初の文字を大文字に、残りを\n"
"小文字に変換します。\n"
"\n"
"これはUnicode標準により提供される、titlecase情報に依存しています。\n"
"この関数は、(通常titlecaseとして知られる)文字列の全ての語を\n"
"大文字にしようとしない点に、注意してください。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.capitalize(\"abcd\")\n"
"    \"Abcd\"\n"
"\n"
"    iex> String.capitalize(\"ﬁn\")\n"
"    \"Fin\"\n"
"\n"
"    iex> String.capitalize(\"olá\")\n"
"    \"Olá\"\n"
"\n"

#. TRANSLATORS: def IO.iodata_to_binary(item)
#: lib/io.ex:373
msgid ""
"Converts iodata (a list of integers representing bytes, lists\n"
"and binaries) into a binary.\n"
"\n"
"Notice that this function treats lists of integers as raw bytes\n"
"and does not perform any kind of encoding conversion. If you want\n"
"to convert from a char list to a string (UTF-8 encoded), please\n"
"use `chardata_to_string/1` instead.\n"
"\n"
"If this function receives a binary, the same binary is returned.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> bin1 = <<1, 2, 3>>\n"
"    iex> bin2 = <<4, 5>>\n"
"    iex> bin3 = <<6>>\n"
"    iex> IO.iodata_to_binary([bin1, 1, [2, 3, bin2], 4|bin3])\n"
"    <<1,2,3,1,2,3,4,5,4,6>>\n"
"\n"
"    iex> bin = <<1, 2, 3>>\n"
"    iex> IO.iodata_to_binary(bin)\n"
"    <<1,2,3>>\n"
"\n"
msgstr ""
"iodata(バイト表現している整数、リスト、バイナリのリスト)を\n"
"バイナリに変換します。\n"
"\n"
"この関数がrawバイトとして整数のリストを扱い、いかなるエンコーディングの\n"
"変換も実行しないことに注意してください。\n"
"もし文字リストから(UTF-8エンコードされた)文字列へ変換したいなら、\n"
"`chardata_to_string/1`を代りに使ってください。\n"
"\n"
"この関数がバイナリを受け取ったら、同じバイナリを返します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> bin1 = <<1, 2, 3>>\n"
"    iex> bin2 = <<4, 5>>\n"
"    iex> bin3 = <<6>>\n"
"    iex> IO.iodata_to_binary([bin1, 1, [2, 3, bin2], 4|bin3])\n"
"    <<1,2,3,1,2,3,4,5,4,6>>\n"
"\n"
"    iex> bin = <<1, 2, 3>>\n"
"    iex> IO.iodata_to_binary(bin)\n"
"    <<1,2,3>>\n"
"\n"

#. TRANSLATORS: def IO.chardata_to_string(string)
#: lib/io.ex:329
msgid ""
"Converts chardata (a list of integers representing codepoints,\n"
"lists and strings) into a string.\n"
"\n"
"In case the conversion fails, it raises a `UnicodeConversionError`.\n"
"If a string is given, returns the string itself.\n"
"\n"
"## Examples\n"
"\n"
"    iex> IO.chardata_to_string([0x00E6, 0x00DF])\n"
"    \"æß\"\n"
"\n"
"    iex> IO.chardata_to_string([0x0061, \"bc\"])\n"
"    \"abc\"\n"
"\n"
msgstr ""
"chardata(コードポイント表現している整数、リスト、バイナリのリスト)を\n"
"文字列に変換します。\n"
"\n"
"変換に失敗したばあい、`UnicodeConversionError`を上げます。\n"
"もし文字列が与えられたら、その文字列自身を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> IO.chardata_to_string([0x00E6, 0x00DF])\n"
"    \"æß\"\n"
"\n"
"    iex> IO.chardata_to_string([0x0061, \"bc\"])\n"
"    \"abc\"\n"
"\n"

#. TRANSLATORS: def Atom.to_string(atom)
#: lib/atom.ex:12
msgid ""
"Converts an atom to string.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"アトムを文字列に変換します。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Atom.to_char_list(atom)
#: lib/atom.ex:22
msgid ""
"Converts an atom to a char list.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"アトムを文字のリストに変換します。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def File.close(io_device)
#: lib/file.ex:1153
msgid ""
"Closes the file referenced by `io_device`. It mostly returns `:ok`, except\n"
"for some severe errors such as out of memory.\n"
"\n"
"Note that if the option `:delayed_write` was used when opening the file,\n"
"`close/1` might return an old write error and not even try to close the "
"file.\n"
"See `open/2`.\n"
msgstr ""
"`io_device`により参照されるファイルをクローズします。\n"
"out of memoryのようないくつかの深刻なエラーを除いて、\n"
"殆ど`:ok`を返します。\n"
"\n"
"ファイルをオープンするときに、`:delayed_write`オプションが使われていたら、\n"
"`close/1`は古い書き込みエラーを返し、ファイルを閉じようとしないかもしれない\n"
"ことに、注意してください。`open/2`を参照してください。\n"

#. TRANSLATORS: def File.chgrp(path, gid)
#: lib/file.ex:1216
msgid ""
"Changes the user group given by the group id `gid`\n"
"for a given `file`. Returns `:ok` on success, or\n"
"`{:error, reason}` on failure.\n"
msgstr ""
"与えられた`file`について、ユーザグループを\n"
"与えられたグループID`gid`に、変更します。\n"
"成功したら`:ok`を返し、失敗したら`{:error, reason}`を\n"
"返します。\n"

#. TRANSLATORS: def File.chmod(path, mode)
#: lib/file.ex:1193
msgid ""
"Changes the unix file `mode` for a given `file`.\n"
"Returns `:ok` on success, or `{:error, reason}`\n"
"on failure.\n"
msgstr ""
"与えられた`file`について、unixファイル`mode`に変更します。\n"
"成功したら`:ok`を返し、失敗したら`{:error, reason}`を\n"
"返します。\n"

#. TRANSLATORS: def File.chown(path, uid)
#: lib/file.ex:1239
msgid ""
"Changes the owner given by the user id `uid`\n"
"for a given `file`. Returns `:ok` on success,\n"
"or `{:error, reason}` on failure.\n"
msgstr ""
"与えられた`file`について、オーナを、ユーザID`uid`に変更します。成功した\n"
"ら`:ok`を返し、失敗したら`{:error, reason}`を返します。\n"

#. TRANSLATORS: def File.cd!(path, function)
#: lib/file.ex:1106
msgid ""
"Changes the current directory to the given `path`,\n"
"executes the given function and then revert back\n"
"to the previous path regardless if there is an exception.\n"
"\n"
"Raises an error if retrieving or changing the current\n"
"directory fails.\n"
msgstr ""
"与えられた`path`に、カレントディレクトリを変更し、\n"
"与えられた関数を実行します。そして、例外が\n"
"あったら、とにかく以前のパスに戻ります。\n"
"\n"
"もしカレントディレクトリを取得するか変更するかに失敗したら、\n"
"エラーが上ります。\n"

#. TRANSLATORS: def GenServer.abcast(nodes \\ nodes(), name, request)
#: lib/gen_server.ex:420
msgid ""
"Casts all servers locally registered as `name` at the specified nodes.\n"
"\n"
"The function returns immediately and ignores nodes that do not exist, or "
"where the\n"
"server name does not exist.\n"
"\n"
"See `multi_call/4` for more information.\n"
msgstr ""
"指定されたノードに`name`としてローカルに登録された、全てのサーバに\n"
"キャストします。\n"
"\n"
"関数は直ちに戻り、存在しないノード、存在しない\n"
"サーバ名が存在しないノードを無視します。\n"
"\n"
"詳細は、 `multi_call/4` を参照してください。\n"

#. TRANSLATORS: def IO.ANSI.conceal()
#: lib/io/ansi.ex:72
msgid "Conceal. Not widely supported"
msgstr "文字色と背景色を同じにします。広くはサポートされていません"

#. TRANSLATORS: def Kernel.++(left, right)
#: lib/kernel.ex:864
msgid ""
"Concatenates two lists.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> [1] ++ [2, 3]\n"
"    [1,2,3]\n"
"\n"
"    iex> 'foo' ++ 'bar'\n"
"    'foobar'\n"
"\n"
msgstr ""
"二つのリストを連結します。\n"
"\n"
"ガードテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> [1] ++ [2, 3]\n"
"    [1,2,3]\n"
"\n"
"    iex> 'foo' ++ 'bar'\n"
"    'foobar'\n"
"\n"

#. TRANSLATORS: def IO.ANSI.clear()
#: lib/io/ansi.ex:132
msgid "Clear screen"
msgstr "全画面消去"

#. TRANSLATORS: def Inspect.Algebra.concat(x, y)
#: lib/inspect/algebra.ex:241
msgid ""
"Concatenates two document entities.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.concat \"hello\", \"world\"\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"hello\", \"world\"]\n"
"\n"
msgstr ""
"二つのドキュメントエンティティを連結します。\n"
"\n"
"## 例\n"
"\n"
"    iex> doc = Inspect.Algebra.concat \"hello\", \"world\"\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"hello\", \"world\"]\n"
"\n"

#. TRANSLATORS: defmacro Kernel.<>(left, right)
#: lib/kernel.ex:1188
msgid ""
"Concatenates two binaries.\n"
"\n"
"## Examples\n"
"\n"
"    iex> \"foo\" <> \"bar\"\n"
"    \"foobar\"\n"
"\n"
"The `<>` operator can also be used in guard clauses as\n"
"long as the first part is a literal binary:\n"
"\n"
"    iex> \"foo\" <> x = \"foobar\"\n"
"    iex> x\n"
"    \"bar\"\n"
"\n"
msgstr ""
"二つのバイナリを連結します。\n"
"\n"
"## 例\n"
"\n"
"    iex> \"foo\" <> \"bar\"\n"
"    \"foobar\"\n"
"\n"
"`<>`演算子は最初の部分がリテラルバイナリである限り、\n"
"ガード節で使うこともできます:\n"
"\n"
"    iex> \"foo\" <> x = \"foobar\"\n"
"    iex> x\n"
"    \"bar\"\n"
"\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.&(expr)
#: lib/kernel/special_forms.ex:1298
msgid ""
"Captures or creates an anonymous function.\n"
"\n"
"## Capture\n"
"\n"
"The capture operator is most commonly used to capture a\n"
"function with given name and arity from a module:\n"
"\n"
"    iex> fun = &Kernel.is_atom/1\n"
"    iex> fun.(:atom)\n"
"    true\n"
"    iex> fun.(\"string\")\n"
"    false\n"
"\n"
"In the example above, we captured `Kernel.is_atom/1` as an\n"
"anonymous function and then invoked it.\n"
"\n"
"The capture operator can also be used to capture local functions,\n"
"including private ones, and imported functions by omitting the\n"
"module name:\n"
"\n"
"    &local_function/1\n"
"\n"
"## Anonymous functions\n"
"\n"
"The capture operator can also be used to partially apply\n"
"functions, where `&1`, `&2` and so on can be used as value\n"
"placeholders. For example:\n"
"\n"
"    iex> double = &(&1 * 2)\n"
"    iex> double.(2)\n"
"    4\n"
"\n"
"In other words, `&(&1 * 2)` is equivalent to `fn x -> x * 2 end`.\n"
"Another example using a local function:\n"
"\n"
"    iex> fun = &is_atom(&1)\n"
"    iex> fun.(:atom)\n"
"    true\n"
"\n"
"The `&` operator can be used with more complex expressions:\n"
"\n"
"    iex> fun = &(&1 + &2 + &3)\n"
"    iex> fun.(1, 2, 3)\n"
"    6\n"
"\n"
"As well as with lists and tuples:\n"
"\n"
"    iex> fun = &{&1, &2}\n"
"    iex> fun.(1, 2)\n"
"    {1, 2}\n"
"\n"
"    iex> fun = &[&1|&2]\n"
"    iex> fun.(1, 2)\n"
"    [1|2]\n"
"\n"
"The only restrictions when creating anonymous functions is that at\n"
"least one placeholder must be present, i.e. it must contain at least\n"
"`&1`:\n"
"\n"
"    # No placeholder fails to compile\n"
"    &var\n"
"\n"
"    # Block expressions are also not supported\n"
"    &(foo(&1, &2); &3 + &4)\n"
"\n"
msgstr ""
"無名関数を捕捉あるいは作成します。\n"
"\n"
"## 捕捉\n"
"\n"
"捕捉オペレータは、モジュールから与えられた名前とアリティで\n"
"関数を捕捉するために、最もよく使われます:\n"
"\n"
"    iex> fun = &Kernel.is_atom/1\n"
"    iex> fun.(:atom)\n"
"    true\n"
"    iex> fun.(\"string\")\n"
"    false\n"
"\n"
"上の例で、無名関数として`Kernel.is_atom/1`を捕捉し、それから\n"
"それを起動しました。\n"
"\n"
"捕捉オペレータはプライベート関数を含むローカル関数を捕捉するために\n"
"使うこともでき、モジュール名を省略することによって関数を\n"
"インポートできます:\n"
"\n"
"    &local_function/1\n"
"\n"
"## 無名関数\n"
"\n"
"捕捉オペレータは、部分的に関数を適用するために使うこともでき、\n"
"値のプレースホルダとして`&1`, `&2`などを使うことができます。\n"
"例えば:\n"
"\n"
"    iex> double = &(&1 * 2)\n"
"    iex> double.(2)\n"
"    4\n"
"\n"
"言い替えると、`&(&1 * 2)`は、`fn x -> x * 2 end`に等しいです。\n"
"もう一つ、ローカル関数を使った例です:\n"
"\n"
"    iex> fun = &is_atom(&1)\n"
"    iex> fun.(:atom)\n"
"    true\n"
"\n"
"`&`オペレータはもっと複雑な式で使うことができます:\n"
"\n"
"    iex> fun = &(&1 + &2 + &3)\n"
"    iex> fun.(1, 2, 3)\n"
"    6\n"
"\n"
"リストとタプルと同じように使えます:\n"
"\n"
"    iex> fun = &{&1, &2}\n"
"    iex> fun.(1, 2)\n"
"    {1, 2}\n"
"\n"
"    iex> fun = &[&1|&2]\n"
"    iex> fun.(1, 2)\n"
"    [1|2]\n"
"\n"
"無名関数を作成するときの唯一の制限は、少なくとも一つのプレースホルダが\n"
"なければならないことです。即ち、最低`&1`を含まなければなりません:\n"
"\n"
"    # プレースホルダがないのでコンパイルに失敗します\n"
"    &var\n"
"\n"
"    # ブロック式もサポートされていません\n"
"    &(foo(&1, &2); &3 + &4)\n"
"\n"

#. TRANSLATORS: def Module.concat(left, right)
#: lib/module.ex:438
msgid ""
"Concatenates two aliases and returns a new alias.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Module.concat(Foo, Bar)\n"
"    Foo.Bar\n"
"\n"
"    iex> Module.concat(Foo, \"Bar\")\n"
"    Foo.Bar\n"
"\n"
msgstr ""
"二つのエイリアスを連結し、新しいエイリアスを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Module.concat(Foo, Bar)\n"
"    Foo.Bar\n"
"\n"
"    iex> Module.concat(Foo, \"Bar\")\n"
"    Foo.Bar\n"
"\n"

#. TRANSLATORS: def Enum.concat(left, right)
#: lib/enum.ex:406
msgid ""
"Concatenates the enumerable on the right with the enumerable on the left.\n"
"\n"
"This function produces the same result as the `Kernel.++/2` operator for "
"lists.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.concat(1..3, 4..6)\n"
"    [1,2,3,4,5,6]\n"
"\n"
"    iex> Enum.concat([1, 2, 3], [4, 5, 6])\n"
"    [1,2,3,4,5,6]\n"
"\n"
msgstr ""
"左辺のenumerableと右辺のenumerableを連結します。\n"
"\n"
"この関数はリストのための`Kernel.++/2`演算子と同じ結果を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.concat(1..3, 4..6)\n"
"    [1,2,3,4,5,6]\n"
"\n"
"    iex> Enum.concat([1, 2, 3], [4, 5, 6])\n"
"    [1,2,3,4,5,6]\n"
"\n"

#. TRANSLATORS: def Inspect.Algebra.concat(docs)
#: lib/inspect/algebra.ex:249
msgid "Concatenates a list of documents.\n"
msgstr "ドキュメントのリストを連結します。\n"

#. TRANSLATORS: def Module.concat(list)
#: lib/module.ex:421
msgid ""
"Concatenates a list of aliases and returns a new alias.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Module.concat([Foo, Bar])\n"
"    Foo.Bar\n"
"\n"
"    iex> Module.concat([Foo, \"Bar\"])\n"
"    Foo.Bar\n"
"\n"
msgstr ""
"エイリアスのリストを連結し、新しいエイリアスを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Module.concat([Foo, Bar])\n"
"    Foo.Bar\n"
"\n"
"    iex> Module.concat([Foo, \"Bar\"])\n"
"    Foo.Bar\n"
"\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.for(args)
#: lib/kernel/special_forms.ex:1204
msgid ""
"Comprehensions allow you to quickly build a data structure from\n"
"an enumerable or a bitstring.\n"
"\n"
"Let's start with an example:\n"
"\n"
"    iex> for n <- [1, 2, 3, 4], do: n * 2\n"
"    [2, 4, 6, 8]\n"
"\n"
"A comprehension accepts many generators and filters. Enumerable\n"
"generators are defined using `<-`:\n"
"\n"
"    # A list generator:\n"
"    iex> for n <- [1, 2, 3, 4], do: n * 2\n"
"    [2, 4, 6, 8]\n"
"\n"
"    # A comprehension with two generators\n"
"    iex> for x <- [1, 2], y <- [2, 3], do: x*y\n"
"    [2, 3, 4, 6]\n"
"\n"
"Filters can also be given:\n"
"\n"
"    # A comprehension with a generator and a filter\n"
"    iex> for n <- [1, 2, 3, 4, 5, 6], rem(n, 2) == 0, do: n\n"
"    [2, 4, 6]\n"
"\n"
"Note generators can also be used to filter as it removes any value\n"
"that doesn't match the left side of `<-`:\n"
"\n"
"    iex> for {:user, name} <- [user: \"john\", admin: \"john\", user: \"meg"
"\"] do\n"
"    ...>   String.upcase(name)\n"
"    ...> end\n"
"    [\"JOHN\", \"MEG\"]\n"
"\n"
"Bitstring generators are also supported and are very useful when you\n"
"need to organize bitstring streams:\n"
"\n"
"    iex> pixels = <<213, 45, 132, 64, 76, 32, 76, 0, 0, 234, 32, 15>>\n"
"    iex> for <<r::8, g::8, b::8 <- pixels >>, do: {r, g, b}\n"
"    [{213,45,132},{64,76,32},{76,0,0},{234,32,15}]\n"
"\n"
"Variable assignments inside the comprehension, be it in generators,\n"
"filters or inside the block, are not reflected outside of the\n"
"comprehension.\n"
"\n"
"## Into\n"
"\n"
"In the examples above, the result returned by the comprehension was\n"
"always a list. The returned result can be configured by passing an\n"
"`:into` option, that accepts any structure as long as it implements\n"
"the `Collectable` protocol.\n"
"\n"
"For example, we can use bitstring generators with the `:into` option\n"
"to easily remove all spaces in a string:\n"
"\n"
"    iex> for <<c <- \" hello world \">>, c != ?\\s, into: \"\", do: <<c>>\n"
"    \"helloworld\"\n"
"\n"
"The `IO` module provides streams, that are both `Enumerable` and\n"
"`Collectable`, here is an upcase echo server using comprehensions:\n"
"\n"
"    for line <- IO.stream(:stdio, :line), into: IO.stream(:stdio, :line) do\n"
"      String.upcase(line)\n"
"    end\n"
"\n"
msgstr ""
"内包はenumerableやbitstringから素早くデータ構造を構築することができます。\n"
"\n"
"例から始めてみましょう:\n"
"\n"
"    iex> for n <- [1, 2, 3, 4], do: n * 2\n"
"    [2, 4, 6, 8]\n"
"\n"
"内包は多くのジェネレータとフィルタを受け付けます。enumerableジェネレー\n"
"タは`<-`を使って定義されています:\n"
"\n"
"    # リストジェネレータ:\n"
"    iex> for n <- [1, 2, 3, 4], do: n * 2\n"
"    [2, 4, 6, 8]\n"
"\n"
"    # 二つのジェネレータを持つ内包\n"
"    iex> for x <- [1, 2], y <- [2, 3], do: x*y\n"
"    [2, 3, 4, 6]\n"
"\n"
"フィルタを与えることもできます:\n"
"\n"
"    # ジェネレータとフィルタを持つ内包\n"
"    iex> for n <- [1, 2, 3, 4, 5, 6], rem(n, 2) == 0, do: n\n"
"    [2, 4, 6]\n"
"\n"
"ジェネレータは、`<-`の左辺にマッチしない値を全て削除するので、\n"
"フィルタとして使われることもあることに、\n"
"注意してください:\n"
"\n"
"    iex> for {:user, name} <- [user: \"john\", admin: \"john\", user: \"meg"
"\"] do\n"
"    ...>   String.upcase(name)\n"
"    ...> end\n"
"    [\"JOHN\", \"MEG\"]\n"
"\n"
"bitstringジェネレータもまたサポートされていて、bitstringストリーム\n"
"を組織する必要があるときに非常に便利です:\n"
"\n"
"    iex> pixels = <<213, 45, 132, 64, 76, 32, 76, 0, 0, 234, 32, 15>>\n"
"    iex> for <<r::8, g::8, b::8 <- pixels >>, do: {r, g, b}\n"
"    [{213,45,132},{64,76,32},{76,0,0},{234,32,15}]\n"
"\n"
"内包の内側での変数代入は、ジェネレータ、フィルタ、またはブロックの内側\n"
"で使えますが、内包の外側には反映されません。\n"
"\n"
"## Into\n"
"\n"
"上の例では、内包により返された結果は通常リストでした。戻り値は\n"
"`:into`オプションを渡すことによって構成することができます。\n"
"`:into`オプションは、`Collectable`プロトコルを実装するかぎり、\n"
"任意の構造を受け付けます。\n"
"\n"
"例えば、文字列から全ての空白を簡単に削除するために、\n"
"`:into`オプション付きのbitstringジェネレータを使うことができます:\n"
"\n"
"    iex> for <<c <- \" hello world \">>, c != ?\\s, into: \"\", do: <<c>>\n"
"    \"helloworld\"\n"
"\n"
"`IO`モジュールは、`Enumerable`と`Collectable`の両方である、\n"
"ストリームを提供します。以下は、内包を使った大文字化エコーサーバです:\n"
"\n"
"    for line <- IO.stream(:stdio, :line), into: IO.stream(:stdio, :line) do\n"
"      String.upcase(line)\n"
"    end\n"
"\n"

#. TRANSLATORS: def GenServer.multi_call(nodes \\ nodes(), name, request, timeout \\ :infinity)
#: lib/gen_server.ex:453
msgid ""
"Calls all servers locally registered as `name` at the specified `nodes`.\n"
"\n"
"The `request` is first sent to every node and then we wait for the\n"
"replies. This function returns a tuple containing the node and its reply\n"
"as first element and all bad nodes as second element. The bad nodes is a\n"
"list of nodes that either did not exist, or where a server with the given\n"
"`name` did not exist or did not reply.\n"
"\n"
"Nodes is a list of node names to which the request is sent. The default\n"
"value is the list of all known nodes.\n"
"\n"
"To avoid that late answers (after the timeout) pollute the caller's message\n"
"queue, a middleman process is used to do the actual calls. Late answers "
"will\n"
"then be discarded when they arrive to a terminated process.\n"
msgstr ""
"指定された`nodes`で`name`としてローカルに登録された全てのサーバ\n"
"を呼び出します。\n"
"\n"
"`request`は最初にそれぞれのノードへ送られ、それから、応答を待ちます。\n"
"この関数は、最初の要素として応答したノードとその応答を、2番目の\n"
"要素として全ての悪いノードを含む、\n"
"タプルを返します。\n"
"悪いノードは、\n"
"存在しなかかったか、与えられた`name`のサーバが存在しなかったか、応答が\n"
"なかったノードのリストです。\n"
"\n"
"nodesはrequestが送られる、ノード名のリストです。デフォルト値は\n"
"知っている全てのノード(nodes())です。\n"
"\n"
"(タイムアウトの後での)遲い応答が、呼び出し側のメッセージ\n"
"キューを汚染することを避けるために、実際の呼び出しには仲介者プロセスが使われ"
"ます。\n"
"遲い応答が終了したプロセスに届いたとき、それらは捨てられます。\n"

#. TRANSLATORS: def Kernel.rem(left, right)
#: lib/kernel.ex:526
msgid ""
"Calculates the remainder of an integer division.\n"
"\n"
"Raises an error if one of the arguments is not an integer.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> rem(5, 2)\n"
"    1\n"
"\n"
msgstr ""
"整数で割った余りを計算します。\n"
"\n"
"引数の一つが整数でないなら、エラーを上げます。\n"
"\n"
"ガードテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> rem(5, 2)\n"
"    1\n"
"\n"

#. TRANSLATORS: def Module.safe_concat(list)
#: lib/module.ex:458
msgid ""
"Concatenates a list of aliases and returns a new alias only\n"
"if the alias was already referenced. If the alias was not\n"
"referenced yet, fails with `ArgumentError`.\n"
"It handles char lists, binaries and atoms.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Module.safe_concat([Unknown, Module])\n"
"    ** (ArgumentError) argument error\n"
"\n"
"    iex> Module.safe_concat([List, Chars])\n"
"    List.Chars\n"
"\n"
msgstr ""
"エイリアスのリストを連結し、出来た新しいエイリアスが、\n"
"それが既に参照されていた時だけ、それを返します。\n"
"もしそのエイリアスがまだ参照されていなかったなら、`ArgumentError`で失敗しま"
"す。\n"
"文字リスト、バイナリ、アトムをハンドルします。\n"
"\n"
"## 例\n"
"\n"
"    iex> Module.safe_concat([Unknown, Module])\n"
"    ** (ArgumentError) argument error\n"
"\n"
"    iex> Module.safe_concat([List, Chars])\n"
"    List.Chars\n"
"\n"

#. TRANSLATORS: def Regex.compile(source, options \\ "")
#: lib/regex.ex:108
msgid ""
"Compiles the regular expression.\n"
"\n"
"The given options can either be a binary with the characters\n"
"representing the same regex options given to the `~r` sigil,\n"
"or a list of options, as expected by the [Erlang `re` docs](http://www."
"erlang.org/doc/man/re.html).\n"
"\n"
"It returns `{:ok, regex}` in case of success,\n"
"`{:error, reason}` otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.compile(\"foo\")\n"
"    {:ok, ~r\"foo\"}\n"
"\n"
"    iex> Regex.compile(\"*foo\")\n"
"    {:error, {'nothing to repeat', 0}}\n"
"\n"
msgstr ""
"正規表現をコンパイルします。\n"
"\n"
"与えられたオプションは、`~r` sigilのための正規表現オプションである、\n"
"文字列表現でも、[Erlang `re` docs](http://www.erlang.org/doc/man/re.html)\n"
"によって想定されるオプションのリストでも有り得ます。\n"
"\n"
"成功したら、`{:ok, regex}`を返し、さもなければ`{:error, reason}`を返し\n"
"ます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Regex.compile(\"foo\")\n"
"    {:ok, ~r\"foo\"}\n"
"\n"
"    iex> Regex.compile(\"*foo\")\n"
"    {:error, {'nothing to repeat', 0}}\n"
"\n"

#. TRANSLATORS: def Regex.compile!(source, options \\ "")
#: lib/regex.ex:138
msgid ""
"Compiles the regular expression according to the given options.\n"
"Fails with `Regex.CompileError` if the regex cannot be compiled.\n"
msgstr ""
"正規表現を与えられたオプションに従って、コンパイルします。\n"
"regexがコンパイル出来なかったら、`Regex.CompileError`で失敗します。\n"

#. TRANSLATORS: def Code.compile_quoted(quoted, file \\ "nofile")
#: lib/code.ex:388
msgid ""
"Compiles the quoted expression.\n"
"\n"
"Returns a list of tuples where the first element is the module name and\n"
"the second one is its byte code (as a binary).\n"
msgstr ""
"quoteされた式をコンパイルします。\n"
"\n"
"最初の要素はモジュール名で、2番目の要素はその(バイナリとしての)バイトコード\n"
"となる、タプルのリストを返します。\n"

#. TRANSLATORS: def Code.compile_string(string, file \\ "nofile")
#: lib/code.ex:378
msgid ""
"Compiles the given string.\n"
"\n"
"Returns a list of tuples where the first element is the module name\n"
"and the second one is its byte code (as a binary).\n"
"\n"
"For compiling many files at once, check `Kernel.ParallelCompiler.files/2`.\n"
msgstr ""
"与えられた文字列をコンパイルします。\n"
"\n"
"最初の要素はモジュール名で、2番目の要素はその(バイナリとしての)バイトコード\n"
"となる、タプルのリストを返します。\n"
"\n"
"一度に多くのファイルをコンパイルするためには、\n"
"`Kernel.ParallelCompiler.files/2`をチェックしてください。\n"

#. TRANSLATORS: def Kernel.ParallelCompiler.files(files, options \\ [])
#: lib/kernel/parallel_compiler.ex:33
msgid ""
"Compiles the given files.\n"
"\n"
"Those files are compiled in parallel and can automatically\n"
"detect dependencies between them. Once a dependency is found,\n"
"the current file stops being compiled until the dependency is\n"
"resolved.\n"
"\n"
"If there is an error during compilation or if `warnings_as_errors`\n"
"is set to `true` and there is a warning, this function will fail\n"
"with an exception.\n"
"\n"
"This function accepts the following options:\n"
"\n"
"  * `:each_file` - for each file compiled, invokes the callback passing the\n"
"    file\n"
"\n"
"  * `:each_module` - for each module compiled, invokes the callback passing\n"
"    the file, module and the module bytecode\n"
"\n"
"  * `:dest` - the destination directory for the beam files. When using "
"`files/2`,\n"
"    this information is only used to properly annotate the beam files "
"before\n"
"    they are loaded into memory. If you want a file to actually be written "
"to\n"
"    `dest`, use `files_to_path/3` instead.\n"
"\n"
"Returns the modules generated by each compiled file.\n"
msgstr ""
"与えられた複数のファイルをコンパイルします。\n"
"\n"
"ファイルは並列にコンパイルされ、それらの間の依存性を自動的に解決します。\n"
"依存性が見付かると、現在のファイルは、依存性が解決するまで\n"
"コンパイルを停止します。\n"
"\n"
"コンパイルの間にエラーがあるか、`warning_as_errors`が`true`にセット\n"
"されている時にワーニングがあったら、この関数は例外とともに失敗します。\n"
"\n"
"この関数はオプションとしてコールバックの集合を受け付けます:\n"
"\n"
"  * `:each_file` - コンパイルしたファイル毎に、そのファイルを引数に\n"
"     コールバックを起動します\n"
"\n"
"  * `:each_module` - コンパイルしたモジュール毎に、\n"
"     ファイルとモジュール、モジュールのバイトコードを引数にコールバックを\n"
"     起動します\n"
"\n"
"  * `:dest` - beamファイルのデスティネーションディレクトリです。\n"
"     `files/2`を使うとき、メモリにロードされる前に、\n"
"     この情報はきちんとbeamファイルに注釈を\n"
"     付けるのに使われるだけです。\n"
"     もし実際に`dest`へ書込みをさせたいなら、`files_to_path/3`を代わりに\n"
"     使ってください。\n"
"\n"
"コンパイルされたそれぞれのファイルにより生成されたモジュールを\n"
"返します。\n"

#. TRANSLATORS: def Kernel.ParallelCompiler.files_to_path(files, path, options \\ [])
#: lib/kernel/parallel_compiler.ex:43
msgid ""
"Compiles the given files to the given path.\n"
"Read `files/2` for more information.\n"
msgstr ""
"与えられたパスで与えられたファイルをコンパイルします。\n"
"詳細は `files/2` を参照してください。\n"

#. TRANSLATORS: def Protocol.assert_protocol!(module)
#: lib/protocol.ex:62
msgid ""
"Checks if the given module is loaded and is protocol.\n"
"\n"
"Returns `:ok` if so, otherwise raises ArgumentError.\n"
msgstr ""
"与えられたモジュールがロードされ、プロトコルかどうかをチェックします。\n"
"\n"
"もしそうなら`:ok`を返し、さもなくばArgumentErrorを上げます。\n"

#. TRANSLATORS: def Protocol.assert_impl!(protocol, base)
#: lib/protocol.ex:89
msgid ""
"Checks if the given module is loaded and is an implementation\n"
"of the given protocol.\n"
"\n"
"Returns `:ok` if so, otherwise raises ArgumentError.\n"
msgstr ""
"与えられたモジュールがロードされ、与えられたプロトコルを\n"
"実装しているかチェックします。\n"
"\n"
"もしそうなら`:ok`を返し、さもなくばArgumentErrorを上げます。\n"

#. TRANSLATORS: def Stream.chunk_by(enum, fun)
#: lib/stream.ex:190
msgid ""
"Chunks the `enum` by buffering elements for which `fun` returns\n"
"the same value and only emit them when `fun` returns a new value\n"
"or the `enum` finishes.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.chunk_by([1, 2, 2, 3, 4, 4, 6, 7, 7], &(rem(&1, 2) "
"== 1))\n"
"    iex> Enum.to_list(stream)\n"
"    [[1], [2, 2], [3], [4, 4, 6], [7, 7]]\n"
"\n"
msgstr ""
"`fun`が同じ値を返す要素をバッファリングにより`enum`をチャンク\n"
"にします。`fun`が新しい値を返すか、`enum`が終了したときのみ\n"
"発行します。\n"
"\n"
"## 例\n"
"\n"
"    iex> stream = Stream.chunk_by([1, 2, 2, 3, 4, 4, 6, 7, 7], &(rem(&1, 2) "
"== 1))\n"
"    iex> Enum.to_list(stream)\n"
"    [[1], [2, 2], [3], [4, 4, 6], [7, 7]]\n"
"\n"

#. TRANSLATORS: def Set.equal?(set1, set2)
#: lib/set.ex:161
msgid ""
"Checks if two sets are equal using `===`.\n"
"\n"
"Notice this function is polymorphic as it compares sets of\n"
"any type. Each set implementation also provides an `equal?`\n"
"function, but they can only work with sets of the same type.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Set.equal?(Enum.into([1, 2], set_impl.new), Enum.into([2, 1, 1], "
"set_impl.new))\n"
"    true\n"
"\n"
"    iex> Set.equal?(Enum.into([1, 2], set_impl.new), Enum.into([3, 4], "
"set_impl.new))\n"
"    false\n"
"\n"
msgstr ""
"`===`を使って二つのsetが等しいかを\n"
"チェックします。\n"
"\n"
"任意のタイプのsetの比較をするので、この関数はポリモーフィック(多態的)\n"
"であることに注意してください。\n"
"それぞれのset実装も、`equal?`関数を提供しますが、それらは同じタイプの\n"
"set同士で動作するだけです。\n"
"\n"
"## 例\n"
"\n"
"    iex> Set.equal?(Enum.into([1, 2], set_impl.new), Enum.into([2, 1, 1], "
"set_impl.new))\n"
"    true\n"
"\n"
"    iex> Set.equal?(Enum.into([1, 2], set_impl.new), Enum.into([3, 4], "
"set_impl.new))\n"
"    false\n"
"\n"

#. TRANSLATORS: def Keyword.equal?(left, right)
#: lib/keyword.ex:340
msgid ""
"Checks if two keywords are equal. \n"
"\n"
"Two keywords are considered to be equal if they contain\n"
"the same keys and those keys contain the same values.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.equal?([a: 1, b: 2], [b: 2, a: 1])\n"
"    true\n"
"\n"
msgstr ""
"二つのキーワードリストが等しいかチェックします。\n"
"\n"
"二つのキーワードリストは、\n"
"同じキーを含んでいること、それらのキーに同じ値を含んでいる\n"
"かどうかで等しいかを考慮します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.equal?([a: 1, b: 2], [b: 2, a: 1])\n"
"    true\n"
"\n"

#. TRANSLATORS: def Dict.equal?(dict1, dict2)
#: lib/dict.ex:663
msgid ""
"Checks if two dicts are equal using `===`.\n"
"\n"
"Notice this function is polymorphic as it compares dicts of any\n"
"type. Each dict implementation also provides an `equal?` function,\n"
"but they can only compare dicts of the same type.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict1 = Enum.into([a: 2, b: 3, f: 5, c: 123], dict_impl.new)\n"
"    iex> dict2 = [a: 2, b: 3, f: 5, c: 123]\n"
"    iex> Dict.equal?(dict1, dict2)\n"
"    true\n"
"\n"
"    iex> dict1 = Enum.into([a: 2, b: 3, f: 5, c: 123], dict_impl.new)\n"
"    iex> dict2 = []\n"
"    iex> Dict.equal?(dict1, dict2)\n"
"    false\n"
"\n"
msgstr ""
"`===`を使って二つのdictが等しいかを\n"
"チェックします。\n"
"\n"
"任意のタイプのdictの比較をするので、この関数はポリモーフィック(多態的)\n"
"であることに注意してください。\n"
"それぞれのdict実装も、`equal?`関数を提供しますが、それらは同じタイプの\n"
"dict同士で動作するだけです。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict1 = Enum.into([a: 2, b: 3, f: 5, c: 123], dict_impl.new)\n"
"    iex> dict2 = [a: 2, b: 3, f: 5, c: 123]\n"
"    iex> Dict.equal?(dict1, dict2)\n"
"    true\n"
"\n"
"    iex> dict1 = Enum.into([a: 2, b: 3, f: 5, c: 123], dict_impl.new)\n"
"    iex> dict2 = []\n"
"    iex> Dict.equal?(dict1, dict2)\n"
"    false\n"
"\n"

#. TRANSLATORS: defmacro Kernel.in(left, right)
#: lib/kernel.ex:2441
msgid ""
"Checks if the element on the left side is member of the\n"
"collection on the right side.\n"
"\n"
"## Examples\n"
"\n"
"    iex> x = 1\n"
"    iex> x in [1, 2, 3]\n"
"    true\n"
"\n"
"This macro simply translates the expression above to:\n"
"\n"
"    Enum.member?([1,2,3], x)\n"
"\n"
"## Guards\n"
"\n"
"The `in` operator can be used on guard clauses as long as the\n"
"right side is a range or a list. Elixir will then expand the\n"
"operator to a valid guard expression. For example:\n"
"\n"
"    when x in [1,2,3]\n"
"\n"
"Translates to:\n"
"\n"
"    when x === 1 or x === 2 or x === 3\n"
"\n"
"When using ranges:\n"
"\n"
"    when x in 1..3\n"
"\n"
"Translates to:\n"
"\n"
"    when x >= 1 and x <= 3\n"
"\n"
msgstr ""
"左辺の要素が、右辺のコレクションのメンバであるかを\n"
"チェックします。\n"
"\n"
"## 例\n"
"\n"
"    iex> x = 1\n"
"    iex> x in [1, 2, 3]\n"
"    true\n"
"\n"
"このマクロは、単に上の式を以下に展開します:\n"
"\n"
"    Enum.member?([1,2,3], x)\n"
"\n"
"## ガード\n"
"\n"
"`in`オペレータは、右辺が範囲(range)かリストであるかぎり、\n"
"ガード節で使うことができます。Elixirはそのオペレータを\n"
"有効なガード式に展開します。例えば:\n"
"\n"
"    when x in [1,2,3]\n"
"\n"
"は以下のように展開します:\n"
"\n"
"    when x === 1 or x === 2 or x === 3\n"
"\n"
"範囲(range)を使うとき:\n"
"\n"
"    when x in 1..3\n"
"\n"
"は以下のように展開します:\n"
"\n"
"    when x >= 1 and x <= 3\n"
"\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.receive(args)
#: lib/kernel/special_forms.ex:1671
msgid ""
"Checks if there is a message matching the given clauses\n"
"in the current process mailbox.\n"
"\n"
"In case there is no such message, the current process hangs\n"
"until a message arrives or waits until a given timeout value.\n"
"\n"
"## Examples\n"
"\n"
"    receive do\n"
"      {:selector, i, value} when is_integer(i) ->\n"
"        value\n"
"      value when is_atom(value) ->\n"
"        value\n"
"      _ ->\n"
"        IO.puts :stderr, \"Unexpected message received\"\n"
"    end\n"
"\n"
"An optional after clause can be given in case the message was not\n"
"received after the specified period of time:\n"
"\n"
"    receive do\n"
"      {:selector, i, value} when is_integer(i) ->\n"
"        value\n"
"      value when is_atom(value) ->\n"
"        value\n"
"      _ ->\n"
"        IO.puts :stderr, \"Unexpected message received\"\n"
"    after\n"
"      5000 ->\n"
"        IO.puts :stderr, \"No message in 5 seconds\"\n"
"    end\n"
"\n"
"The `after` clause can be specified even if there are no match clauses.\n"
"There are two special cases for the timeout value given to `after`\n"
"\n"
"  * `:infinity` - the process should wait indefinitely for a matching\n"
"    message, this is the same as not using a timeout\n"
"\n"
"  * 0 - if there is no matching message in the mailbox, the timeout\n"
"    will occur immediately\n"
"\n"
"## Variables handling\n"
"\n"
"The `receive` special form handles variables exactly as the `case`\n"
"special macro. For more information, check the docs for `case/2`.\n"
msgstr ""
"現在のプロセスのメールボックスに、\n"
"与えられた節にマッチするメッセージがあるかどうかを\n"
"チェックします。\n"
"\n"
"そんなメッセージがない場合、現在のプロセスは、メッセージが到着するまで\n"
"ハングするか、与えられたタイムアウト値まで待ちます。\n"
"\n"
"## 例\n"
"\n"
"    receive do\n"
"      {:selector, i, value} when is_integer(i) ->\n"
"        value\n"
"      value when is_atom(value) ->\n"
"        value\n"
"      _ ->\n"
"        IO.puts :stderr, \"Unexpected message received\"\n"
"    end\n"
"\n"
"オプションのafter節は、指定された期間にメッセージを受信\n"
"しなかった時の為に与えることができます:\n"
"\n"
"    receive do\n"
"      {:selector, i, value} when is_integer(i) ->\n"
"        value\n"
"      value when is_atom(value) ->\n"
"        value\n"
"      _ ->\n"
"        IO.puts :stderr, \"Unexpected message received\"\n"
"    after\n"
"      5000 ->\n"
"        IO.puts :stderr, \"No message in 5 seconds\"\n"
"    end\n"
"\n"
"`after`節はマッチ節がなくても指定することができます。\n"
"`after`へ与えるタイムアウト値として、二つの特別な場合があります\n"
"\n"
"  * `:infinity` - プロセスは無期限にマッチするメッセージを\n"
"     待ちます。タイムアウトを使わないことと同じです\n"
"\n"
"  * 0 - メールボックスにマッチするメッセージがないなら、\n"
"    直ちにタイムアウトします。\n"
"\n"
"## 変数ハンドリング\n"
"\n"
"`receive`スペシャルフォームは`case`スペシャルマクロと全く同じように使い\n"
"ます。詳細は、`case/2`のドキュメントをチェックしてください。\n"

#. TRANSLATORS: def Module.defines?(module, tuple)
#: lib/module.ex:613
msgid ""
"Checks if the module defines the given function or macro.\n"
"Use `defines?/3` to assert for a specific type.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Example do\n"
"      Module.defines? __MODULE__, {:version, 0} #=> false\n"
"      def version, do: 1\n"
"      Module.defines? __MODULE__, {:version, 0} #=> true\n"
"    end\n"
"\n"
msgstr ""
"与えられた関数かマクロがmoduleで定義されているかチェックします。\n"
"特定のタイプを主張するためには、`defines?/3`を使ってください。\n"
"\n"
"## 例\n"
"\n"
"    defmodule Example do\n"
"      Module.defines? __MODULE__, {:version, 0} #=> false\n"
"      def version, do: 1\n"
"      Module.defines? __MODULE__, {:version, 0} #=> true\n"
"    end\n"
"\n"

#. TRANSLATORS: def Module.defines?(module, tuple, kind)
#: lib/module.ex:633
msgid ""
"Checks if the module defines a function or macro of the\n"
"given `kind`. `kind` can be any of `:def`, `:defp`,\n"
"`:defmacro` or `:defmacrop`.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Example do\n"
"      Module.defines? __MODULE__, {:version, 0}, :defp #=> false\n"
"      def version, do: 1\n"
"      Module.defines? __MODULE__, {:version, 0}, :defp #=> false\n"
"    end\n"
"\n"
msgstr ""
"与えられた`kind`の関数かマクロがmoduleで定義されているかチェックします。\n"
"`kind`は`:def`、`:defp`、`:defmacro`、`:defmacrop`の何れかです。\n"
"\n"
"## 例\n"
"\n"
"    defmodule Example do\n"
"      Module.defines? __MODULE__, {:version, 0}, :defp #=> false\n"
"      def version, do: 1\n"
"      Module.defines? __MODULE__, {:version, 0}, :defp #=> false\n"
"    end\n"
"\n"

#. TRANSLATORS: def Keyword.keyword?(arg1)
#: lib/keyword.ex:40
msgid "Checks if the given argument is a keyword list or not.\n"
msgstr ""
"与えられた引数がキーワードリストか否かを、\n"
"チェックします。\n"

#. TRANSLATORS: defmacro Record.is_record(data)
#: lib/record.ex:102
msgid ""
"Checks if the given `data` is a record.\n"
"\n"
"This is implemented as a macro so it can be used in guard clauses.\n"
"\n"
"## Examples\n"
"\n"
"    iex> record = {User, \"john\", 27}\n"
"    iex> Record.is_record(record)\n"
"    true\n"
"    iex> tuple = {}\n"
"    iex> Record.is_record(tuple)\n"
"    false\n"
"\n"
msgstr ""
"与えらえれた`data`がレコードかどうかをチェックします。\n"
"\n"
"ガード節で使うことができるように、これはマクロとして実装されています。\n"
"\n"
"## 例\n"
"\n"
"    iex> record = {User, \"john\", 27}\n"
"    iex> Record.is_record(record)\n"
"    true\n"
"    iex> tuple = {}\n"
"    iex> Record.is_record(tuple)\n"
"    false\n"
"\n"

#. TRANSLATORS: defmacro Record.is_record(data, kind)
#: lib/record.ex:71
msgid ""
"Checks if the given `data` is a record of `kind`.\n"
"\n"
"This is implemented as a macro so it can be used in guard clauses.\n"
"\n"
"## Examples\n"
"\n"
"    iex> record = {User, \"john\", 27}\n"
"    iex> Record.is_record(record, User)\n"
"    true\n"
"\n"
msgstr ""
"与えらえれた`data`が`kind`のレコードかどうかをチェックします。\n"
"\n"
"ガード節で使うことができるように、これはマクロとして実装されています。\n"
"\n"
"## 例\n"
"\n"
"    iex> record = {User, \"john\", 27}\n"
"    iex> Record.is_record(record, User)\n"
"    true\n"
"\n"

#. TRANSLATORS: def URI.char_unescaped?(c)
#: lib/uri.ex:182
msgid ""
"Checks if the character is allowed unescaped in a URI.\n"
"\n"
"This is the default used by `URI.encode/2` where both\n"
"reserved and unreserved characters are kept unescaped.\n"
msgstr ""
"文字がURIでアンエスケープが許されるかどうかをチェックします。\n"
"\n"
"予約、実予約文字の両方がアンエスケープでおかれるように、\n"
"これはデフォルトで`URI.encode/2`によって使われます。\n"

#. TRANSLATORS: def URI.char_unreserved?(c)
#: lib/uri.ex:169
msgid ""
"Checks if the character is a \"unreserved\" character in a URI.\n"
"\n"
"Unreserved characters are specified in RFC3986, section 2.3.\n"
msgstr ""
"文字が、URIの\"非予約(unreserved)\"文字かどうかをチェックします。\n"
"\n"
"非予約(unreserved)文字は、 RFC3986 section 2.3に定められています。\n"

#. TRANSLATORS: def URI.char_reserved?(c)
#: lib/uri.ex:160
msgid ""
"Checks if the character is a \"reserved\" character in a URI.\n"
"\n"
"Reserved characters are specified in RFC3986, section 2.2.\n"
msgstr ""
"文字が、URIの\"予約(reserved)\"文字かどうかをチェックします。\n"
"\n"
"予約(reserved)文字は、 RFC3986 section 2.2に定められています。\n"

#. TRANSLATORS: def Version.compare(vsn1, vsn2)
#: lib/version.ex:151
msgid ""
"Compares two versions. Returns `:gt` if first version is greater than\n"
"the second and `:lt` for vice versa. If the two versions are equal `:eq`\n"
"is returned\n"
"\n"
"Raises a `Version.InvalidVersionError` exception if `version` is not "
"parseable.\n"
"If given an already parsed version this function won't raise.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Version.compare(\"2.0.1-alpha1\", \"2.0.0\")\n"
"    :gt\n"
"\n"
"    iex> Version.compare(\"2.0.1+build0\", \"2.0.1\")\n"
"    :eq\n"
"\n"
"    iex> Version.compare(\"invalid\", \"2.0.1\")\n"
"    ** (Version.InvalidVersionError) invalid\n"
"\n"
msgstr ""
"二つのバージョンを比較します。もし、最初のバージョンが\n"
"二つめより大きいなら、`:gt`を返し、反対なら`:lt`を返します。\n"
"もし二つのバージョンが等しいなら、`:eq`が返されます。\n"
"\n"
"もし`version`が解析不能なら、`Version.InvalidVersionError`例外を上げます。\n"
"もし既に解析されたバージョンが与えられたら、この関数は例外を上げません。\n"
"\n"
"## 例\n"
"\n"
"    iex> Version.compare(\"2.0.1-alpha1\", \"2.0.0\")\n"
"    :gt\n"
"\n"
"    iex> Version.compare(\"2.0.1+build0\", \"2.0.1\")\n"
"    :eq\n"
"\n"
"    iex> Version.compare(\"invalid\", \"2.0.1\")\n"
"    ** (Version.InvalidVersionError) invalid\n"
"\n"

#. TRANSLATORS: def Version.match?(vsn, req)
#: lib/version.ex:116
msgid ""
"Checks if the given version matches the specification.\n"
"\n"
"Returns `true` if `version` satisfies `requirement`, `false` otherwise.\n"
"Raises a `Version.InvalidRequirementError` exception if `requirement` is "
"not\n"
"parseable, or `Version.InvalidVersionError` if `version` is not parseable.\n"
"If given an already parsed version and requirement this function won't\n"
"raise.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Version.match?(\"2.0.0\", \">1.0.0\")\n"
"    true\n"
"\n"
"    iex> Version.match?(\"2.0.0\", \"==1.0.0\")\n"
"    false\n"
"\n"
"    iex> Version.match?(\"foo\", \"==1.0.0\")\n"
"    ** (Version.InvalidVersionError) foo\n"
"\n"
"    iex> Version.match?(\"2.0.0\", \"== ==1.0.0\")\n"
"    ** (Version.InvalidRequirementError) == ==1.0.0\n"
"\n"
msgstr ""
"与えられたバージョンが仕様にマッチするかチェックします。\n"
"\n"
"`version`が`requirement`を満足するなら`true`を返し、さもなければ、\n"
"`false`を返します。もし`requirement`がパースできないなら、\n"
"`Version.InvalidRequirementError`例外を上げます。あるいは、もし\n"
"`version`がパースできないなら、`Version.InvalidVersionError`を上げます。\n"
"もし既にバースされたversionとrequirementが与えらえれたら、\n"
"この関数は例外を上げません。\n"
"\n"
"## 例\n"
"\n"
"    iex> Version.match?(\"2.0.0\", \">1.0.0\")\n"
"    true\n"
"\n"
"    iex> Version.match?(\"2.0.0\", \"==1.0.0\")\n"
"    false\n"
"\n"
"    iex> Version.match?(\"foo\", \"==1.0.0\")\n"
"    ** (Version.InvalidVersionError) foo\n"
"\n"
"    iex> Version.match?(\"2.0.0\", \"== ==1.0.0\")\n"
"    ** (Version.InvalidRequirementError) == ==1.0.0\n"
"\n"

#. TRANSLATORS: def Enumerable.member?(collection, value)
#: lib/enum.ex:126
msgid ""
"Checks if a value exists within the collection.\n"
"\n"
"It should return `{:ok, boolean}`.\n"
"\n"
"If `{:error, __MODULE__}` is returned a default algorithm using `reduce` "
"and\n"
"the match (`===`) operator is used. This algorithm runs in linear time.\n"
"\n"
"Please force use of the default algorithm unless you can implement an\n"
"algorithm that is significantly faster.\n"
msgstr ""
"値がコレクションの中に存在するかチェックします。\n"
"\n"
"`{:ok, boolean}`を返すべきです。\n"
"\n"
"`{:error, __MODULE__}`を返したら、`reduce`とマッチオペレータ(`===`)を使う\n"
"デフォルトアルゴリズムが使われます。このアルゴリズムは線形に時間がかかりま"
"す。\n"
"\n"
"より速いアルゴリズムのを実装することができない限り、デフォルトアルゴリ\n"
"ズムの使用を強制してください。\n"

#. TRANSLATORS: def Enum.member?(collection, value)
#: lib/enum.ex:1114
msgid ""
"Checks if `value` exists within the `collection`.\n"
"\n"
"Membership is tested with the match (`===`) operator, although\n"
"enumerables like ranges may include floats inside the given\n"
"range.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.member?(1..10, 5)\n"
"    true\n"
"\n"
"    iex> Enum.member?([:a, :b, :c], :d)\n"
"    false\n"
"\n"
msgstr ""
"値がコレクションの中に存在するかチェックします。\n"
"\n"
"`{:ok, boolean}`を返すべきです。\n"
"\n"
"`{:error, __MODULE__}`を返したら、`reduce`とマッチオペレータ(`===`)を使う\n"
"デフォルトアルゴリズムが使われます。このアルゴリズムは線形に時間がかかりま"
"す。\n"
"\n"
"より速いアルゴリズムのを実装することができない限り、デフォルトアルゴリ\n"
"ズムの使用を強制してください。\n"
"\n"
"メンバーシップはマッチオペレータ(`===`)でテストされます。\n"
"しかし、範囲(range)のようなenumerableは浮動少数点数を所定の範囲(range)に\n"
"含むかもしれません。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.member?(1..10, 5)\n"
"    true\n"
"\n"
"    iex> Enum.member?([:a, :b, :c], :d)\n"
"    false\n"
"\n"

#. TRANSLATORS: def Module.open?(module)
#: lib/module.ex:314
msgid ""
"Checks if a module is open, i.e. it is currently being defined\n"
"and its attributes and functions can be modified.\n"
msgstr ""
"moduleがオープンされたかをチェックします。\n"
"即ち、オープンされているとは、現在定義されていて、\n"
"属性と関数は修正可能ということです。\n"

#. TRANSLATORS: def String.printable?(b)
#: lib/string.ex:190
msgid ""
"Checks if a string is printable considering it is encoded\n"
"as UTF-8. Returns `true` if so, `false` otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.printable?(\"abc\")\n"
"    true\n"
"\n"
msgstr ""
"文字列がUTC-8でエンコードされているとみなし、印字可能かどうか\n"
"チェックします。そうなら`true`を返し、さもなくば`false`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.printable?(\"abc\")\n"
"    true\n"
"\n"

#. TRANSLATORS: def String.match?(string, regex)
#: lib/string.ex:1280
msgid ""
"Checks if `string` matches the given regular expression.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.match?(\"foo\", ~r/foo/)\n"
"    true\n"
"\n"
"    iex> String.match?(\"bar\", ~r/foo/)\n"
"    false\n"
"\n"
msgstr ""
"`string`が与えられた正規表現にマッチするかをチェックします。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.match?(\"foo\", ~r/foo/)\n"
"    true\n"
"\n"
"    iex> String.match?(\"bar\", ~r/foo/)\n"
"    false\n"
"\n"

#. TRANSLATORS: def String.contains?(string, contents)
#: lib/string.ex:1303
msgid ""
"Checks if `string` contains any of the given `contents`.\n"
"\n"
"`matches` can be either a single string or a list of strings.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.contains? \"elixir of life\", \"of\"\n"
"    true\n"
"\n"
"    iex> String.contains? \"elixir of life\", [\"life\", \"death\"]\n"
"    true\n"
"\n"
"    iex> String.contains? \"elixir of life\", [\"death\", \"mercury\"]\n"
"    false\n"
"\n"
msgstr ""
"`string`が与えられた`contents`のどれかを含んでいるかをチェックします。\n"
"\n"
"`matches`は単一の文字列でも文字列のリストでも構いません。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.contains? \"elixir of life\", \"of\"\n"
"    true\n"
"\n"
"    iex> String.contains? \"elixir of life\", [\"life\", \"death\"]\n"
"    true\n"
"\n"
"    iex> String.contains? \"elixir of life\", [\"death\", \"mercury\"]\n"
"    false\n"
"\n"

#. TRANSLATORS: def Set.member?(set, value)
#: lib/set.ex:220
msgid ""
"Checks if `set` contains `value`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Set.member?(Enum.into([1, 2, 3], set_impl.new), 2)\n"
"    true\n"
"\n"
"    iex> Set.member?(Enum.into([1, 2, 3], set_impl.new), 4)\n"
"    false\n"
"\n"
msgstr ""
"`set`が`value`を含んでいるかをチェックします。\n"
"\n"
"## 例\n"
"\n"
"    iex> Set.member?(Enum.into([1, 2, 3], set_impl.new), 2)\n"
"    true\n"
"\n"
"    iex> Set.member?(Enum.into([1, 2, 3], set_impl.new), 4)\n"
"    false\n"
"\n"

#. TRANSLATORS: def Set.subset?(set1, set2)
#: lib/set.ex:272
msgid ""
"Checks if `set1`'s members are all contained in `set2`.\n"
"\n"
"Notice this function is polymorphic as it checks the subset for\n"
"any type. Each set implementation also provides a `subset?` function,\n"
"but they can only work with sets of the same type.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Set.subset?(Enum.into([1, 2], set_impl.new), Enum.into([1, 2, 3], "
"set_impl.new))\n"
"    true\n"
"\n"
"    iex> Set.subset?(Enum.into([1, 2, 3], set_impl.new), Enum.into([1, 2], "
"set_impl.new))\n"
"    false\n"
"\n"
msgstr ""
"`set1`のメンバが`set2`に全て含まれているかチェックします。\n"
"\n"
"任意のタイプのsubsetをチェックするので、この関数はポリモーフィック(多態的)\n"
"であることに注意してください。\n"
"それぞれのset実装も、`subset?`関数を提供しますが、それらは同じタイプの\n"
"set同士で動作するだけです。\n"
"\n"
"## 例\n"
"\n"
"    iex> Set.subset?(Enum.into([1, 2], set_impl.new), Enum.into([1, 2, 3], "
"set_impl.new))\n"
"    true\n"
"\n"
"    iex> Set.subset?(Enum.into([1, 2, 3], set_impl.new), Enum.into([1, 2], "
"set_impl.new))\n"
"    false\n"
"\n"

#. TRANSLATORS: def Set.disjoint?(set1, set2)
#: lib/set.ex:122
msgid ""
"Checks if `set1` and `set2` have no members in common.\n"
"\n"
"Notice this function is polymorphic as it checks for disjoint sets of\n"
"any type. Each set implementation also provides a `disjoint?` function,\n"
"but they can only work with sets of the same type.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Set.disjoint?(Enum.into([1, 2], set_impl.new), Enum.into([3, 4], "
"set_impl.new))\n"
"    true\n"
"\n"
"    iex> Set.disjoint?(Enum.into([1, 2], set_impl.new), Enum.into([2, 3], "
"set_impl.new))\n"
"    false\n"
"\n"
msgstr ""
"`set1`と`set2`が共通のメンバを持っていないかを\n"
"チェックします。\n"
"\n"
"任意のタイプのdisjointをチェックするので、この関数はポリモーフィック(多態"
"的)\n"
"であることに注意してください。\n"
"それぞれのset実装も、`disjoint?`関数を提供しますが、それらは同じタイプの\n"
"set同士で動作するだけです。\n"
"\n"
"## 例\n"
"\n"
"    iex> Set.disjoint?(Enum.into([1, 2], set_impl.new), Enum.into([3, 4], "
"set_impl.new))\n"
"    true\n"
"\n"
"    iex> Set.disjoint?(Enum.into([1, 2], set_impl.new), Enum.into([2, 3], "
"set_impl.new))\n"
"    false\n"
"\n"

#. TRANSLATORS: def IO.ANSI.enabled?()
#: lib/io/ansi.ex:40
msgid ""
"Checks if ANSI coloring is supported and enabled on this machine.\n"
"\n"
"This function simply reads the configuration value for\n"
"`:ansi_enabled` in the `:elixir` application. The value is by\n"
"default false unless Elixir can detect during startup that\n"
"both `stdout` and `stderr` are terminals.\n"
msgstr ""
"ANSIカラーがサポートされて、この計算機で有効かどうかをチェックします。\n"
"\n"
"この関数は、単に`:elixir`アプリケーションの`:ansi_enabled`の構成値を読\n"
"むだけです。Elixirがスタートアップの間に、`stdout`と`stderr`の両方が端\n"
"末(terminal)と検出できない限り、その値はデフォルトでfalseです。\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.super(args)
#: lib/kernel/special_forms.ex:1334
msgid ""
"Calls the overriden function when overriding it with `defoverridable`.\n"
"See `Kernel.defoverridable` for more information and documentation.\n"
msgstr ""
"`defoverridable`でオーバライドしたときに、オーバライドされた関数を呼び\n"
"出します。\n"
"詳細とトキュメントは`Kernel.defoverridable`を参照してください。\n"

#. TRANSLATORS: def Macro.unpipe(expr)
#: lib/macro.ex:60
msgid ""
"Breaks a pipeline expression into a list.\n"
"\n"
"Raises if the pipeline is ill-formed.\n"
msgstr ""
"パイプライン式をリストにします。\n"
"\n"
"パイプラインが不適格なら、エラーを上げます。\n"

#. TRANSLATORS: def Path.absname(path, relative_to)
#: lib/path.ex:60
msgid ""
"Builds a path from `relative_to` to `path`. If `path` is already\n"
"an absolute path, `relative_to` is ignored. See also `relative_to/2`.\n"
"\n"
"Unlike `expand/2`, no attempt is made to\n"
"resolve `..`, `.` or `~`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.absname(\"foo\", \"bar\")\n"
"    \"bar/foo\"\n"
"\n"
"    iex> Path.absname(\"../x\", \"bar\")\n"
"    \"bar/../x\"\n"
"\n"
msgstr ""
"`relative_to`から`path`へパスを組み立てます。\n"
"もし`path`が既に絶対パスなら、`relative_to`は無視されます。\n"
"`relative_to/2`も参照してください。\n"
"\n"
"`expand/2`と違い、`..`、`.`、`~`の解決を試みません。\n"
"\n"
"## 例\n"
"\n"
"    iex> Path.absname(\"foo\", \"bar\")\n"
"    \"bar/foo\"\n"
"\n"
"    iex> Path.absname(\"../x\", \"bar\")\n"
"    \"bar/../x\"\n"
"\n"

#. TRANSLATORS: def IO.ANSI.bright()
#: lib/io/ansi.ex:48
msgid "Bright (increased intensity) or Bold"
msgstr "高輝度/太文字に設定"

#. TRANSLATORS: defmacro Kernel.or(left, right)
#: lib/kernel.ex:1118
msgid ""
"Boolean or. Requires only the first argument to be a\n"
"boolean since it short-circuits.\n"
"\n"
"Allowed in guard tests.\n"
"\n"
"## Examples\n"
"\n"
"    iex> true or false\n"
"    true\n"
"\n"
msgstr ""
"ブール代数のor です。ショートサーキットなので、\n"
"booleanであることを最初の引数だけに要求します。\n"
"\n"
"ガードテストで使えます。\n"
"\n"
"## 例\n"
"\n"
"    iex> true or false\n"
"    true\n"
"\n"

#. TRANSLATORS: def Kernel.not(arg)
#: lib/kernel.ex:900
msgid ""
"Boolean not. Argument must be a boolean.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> not false\n"
"    true\n"
"\n"
msgstr ""
"ブール代数のnot です。引数はbooleanでなくてはなりません。\n"
"\n"
"ガードテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> not false\n"
"    true\n"
"\n"

#. TRANSLATORS: defmacro Kernel.and(left, right)
#: lib/kernel.ex:1134
msgid ""
"Boolean and. Requires only the first argument to be a\n"
"boolean since it short-circuits.\n"
"\n"
"Allowed in guard tests.\n"
"\n"
"## Examples\n"
"\n"
"    iex> true and false\n"
"    false\n"
"\n"
msgstr ""
"ブール代数のand です。ショートサーキットなので、\n"
"booleanであることを最初の引数だけに要求します。\n"
"\n"
"ガードテストで使えます。\n"
"\n"
"## 例\n"
"\n"
"    iex> true and false\n"
"    false\n"
"\n"

#. TRANSLATORS: def IO.ANSI.blink_off()
#: lib/io/ansi.ex:95
msgid "Blink: off"
msgstr "ブリンク: off"

#. TRANSLATORS: def IO.ANSI.blink_slow()
#: lib/io/ansi.ex:60
msgid "Blink: Slow. Less than 150 per minute"
msgstr "ブリンク: Slow. 150回/分未満"

#. TRANSLATORS: def IO.ANSI.blink_rapid()
#: lib/io/ansi.ex:63
msgid ""
"Blink: Rapid. MS-DOS ANSI.SYS; 150 per minute or more; not widely supported"
msgstr ""
"Blink: Rapid. MS-DOS ANSI.SYS; 150回/分以上; 広くはサポートされていません"

#. TRANSLATORS: defmacro Bitwise.bxor(left, right)
#: lib/bitwise.ex:90
msgid "Bitwise xor.\n"
msgstr "Bitwise xor.\n"

#. TRANSLATORS: defmacro Bitwise.^^^(left, right)
#: lib/bitwise.ex:97
msgid "Bitwise xor as operator.\n"
msgstr "演算子としてのBitwise xorです。\n"

#. TRANSLATORS: defmacro Bitwise.bor(left, right)
#: lib/bitwise.ex:76
msgid "Bitwise or.\n"
msgstr "Bitwise orです。\n"

#. TRANSLATORS: def String.valid_character?(codepoint)
#: lib/string.ex:828
msgid ""
"Checks whether `str` is a valid character.\n"
"\n"
"All characters are codepoints, but some codepoints\n"
"are not valid characters. They may be reserved, private,\n"
"or other.\n"
"\n"
"More info at: http://en.wikipedia.org/wiki/"
"Mapping_of_Unicode_characters#Noncharacters\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.valid_character?(\"a\")\n"
"    true\n"
"\n"
"    iex> String.valid_character?(\"ø\")\n"
"    true\n"
"\n"
"    iex> String.valid_character?(\"\\x{ffff}\")\n"
"    false\n"
"\n"
msgstr ""
"`str`が有効な文字かどうかをチェックします。\n"
"全て文字がコードポイントですが、いくつかのコードポイントは\n"
"有効な文字ではありません。それらは予約、プライベート、あるいは\n"
"その他であるかもしれません。\n"
"\n"
"詳細は以下を参照してください:\n"
"http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Noncharacters\n"
"\n"
"## 例\n"
"\n"
"    iex> String.valid_character?(\"a\")\n"
"    true\n"
"\n"
"    iex> String.valid_character?(\"ø\")\n"
"    true\n"
"\n"
"    iex> String.valid_character?(\"\\x{ffff}\")\n"
"    false\n"
"\n"

#. TRANSLATORS: def String.valid?(arg1)
#: lib/string.ex:798
msgid ""
"Checks whether `str` contains only valid characters.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.valid?(\"a\")\n"
"    true\n"
"\n"
"    iex> String.valid?(\"ø\")\n"
"    true\n"
"\n"
"    iex> String.valid?(<<0xffff :: 16>>)\n"
"    false\n"
"\n"
"    iex> String.valid?(\"asd\" <> <<0xffff :: 16>>)\n"
"    false\n"
"\n"
msgstr ""
"`str`が有効な文字だけを含んでいるかどうかをチェックします。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.valid?(\"a\")\n"
"    true\n"
"\n"
"    iex> String.valid?(\"ø\")\n"
"    true\n"
"\n"
"    iex> String.valid?(<<0xffff :: 16>>)\n"
"    false\n"
"\n"
"    iex> String.valid?(\"asd\" <> <<0xffff :: 16>>)\n"
"    false\n"
"\n"

#. TRANSLATORS: defmacro Bitwise.|||(left, right)
#: lib/bitwise.ex:83
msgid "Bitwise or as operator.\n"
msgstr "演算子としてのBitwise or です。\n"

#. TRANSLATORS: defmacro Bitwise.bnot(expr)
#: lib/bitwise.ex:48
msgid "Bitwise not.\n"
msgstr "Bitwise notです。\n"

#. TRANSLATORS: defmacro Bitwise.~~~(expr)
#: lib/bitwise.ex:55
msgid "Bitwise not as operator.\n"
msgstr "演算子としてのBitwise notです。\n"

#. TRANSLATORS: defmacro Bitwise.band(left, right)
#: lib/bitwise.ex:62
msgid "Bitwise and.\n"
msgstr "Bitwise andです。\n"

#. TRANSLATORS: defmacro Bitwise.&&&(left, right)
#: lib/bitwise.ex:69
msgid "Bitwise and as operator.\n"
msgstr "演算子としてのBitwise andです。\n"

#. TRANSLATORS: defmacro Kernel...(first, last)
#: lib/kernel.ex:2251
msgid ""
"Returns a range with the specified start and end.\n"
"Includes both ends.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 0 in 1..3\n"
"    false\n"
"\n"
"    iex> 1 in 1..3\n"
"    true\n"
"\n"
"    iex> 2 in 1..3\n"
"    true\n"
"\n"
"    iex> 3 in 1..3\n"
"    true\n"
"\n"
msgstr ""
"指定された始まりと終わりの範囲を返します。\n"
"両端を含みます。\n"
"\n"
"## 例\n"
"\n"
"    iex> 0 in 1..3\n"
"    false\n"
"\n"
"    iex> 1 in 1..3\n"
"    true\n"
"\n"
"    iex> 2 in 1..3\n"
"    true\n"
"\n"
"    iex> 3 in 1..3\n"
"    true\n"
"\n"

#. TRANSLATORS: def Kernel.+(value)
#: lib/kernel.ex:791
msgid ""
"Arithmetic unary plus.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> +1\n"
"    1\n"
"\n"
msgstr ""
"算術的単項プラスです。\n"
"\n"
"ガードテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> +1\n"
"    1\n"
"\n"

#. TRANSLATORS: def Kernel.-(value)
#: lib/kernel.ex:807
msgid ""
"Arithmetic unary minus.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> -2\n"
"    -2\n"
"\n"
msgstr ""
"算術的単項マイナスです。\n"
"\n"
"ガードテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> -2\n"
"    -2\n"
"\n"

#. TRANSLATORS: def Kernel.+(left, right)
#: lib/kernel.ex:759
msgid ""
"Arithmetic plus.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 + 2\n"
"    3\n"
"\n"
msgstr ""
"算術的加算です。\n"
"\n"
"ガードテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> 1 + 2\n"
"    3\n"
"\n"

#. TRANSLATORS: def Kernel.*(left, right)
#: lib/kernel.ex:823
msgid ""
"Arithmetic multiplication.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 * 2\n"
"    2\n"
"\n"
msgstr ""
"算術的乗算です。\n"
"\n"
"ガードテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> 1 * 2\n"
"    2\n"
"\n"

#. TRANSLATORS: def Kernel.-(left, right)
#: lib/kernel.ex:775
msgid ""
"Arithmetic minus.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 - 2\n"
"    -1\n"
"\n"
msgstr ""
"算術的減算です。\n"
"\n"
"ガードテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> 1 - 2\n"
"    -1\n"
"\n"

#. TRANSLATORS: def Kernel./(left, right)
#: lib/kernel.ex:845
msgid ""
"Arithmetic division.\n"
"\n"
"The result is always a float. Use `div` and `rem` if you want\n"
"a natural division or the remainder.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 / 2\n"
"    0.5\n"
"\n"
"    iex> 2 / 1\n"
"    2.0\n"
"\n"
msgstr ""
"算術的除算です。\n"
"\n"
"結果は常に浮動小数点数です。自然数の除算と余りには、\n"
"`div`と`rem`を使ってください。\n"
"\n"
"ガードテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> 1 / 2\n"
"    0.5\n"
"\n"
"    iex> 2 / 1\n"
"    2.0\n"
"\n"

#. TRANSLATORS: defmacro Bitwise.bsr(left, right)
#: lib/bitwise.ex:118
msgid "Arithmetic bitshift right.\n"
msgstr "算術的右ビットシフトです。\n"

#. TRANSLATORS: defmacro Bitwise.>>>(left, right)
#: lib/bitwise.ex:125
msgid "Arithmetic bitshift right as operator.\n"
msgstr "演算子としての算術的右ビットシフトです。\n"

#. TRANSLATORS: defmacro Bitwise.bsl(left, right)
#: lib/bitwise.ex:104
msgid "Arithmetic bitshift left.\n"
msgstr "算術的左ビットシフトです。\n"

#. TRANSLATORS: defmacro Bitwise.<<<(left, right)
#: lib/bitwise.ex:111
msgid "Arithmetic bitshift left as operator.\n"
msgstr "演算子としての算術的左ビットシフトです。\n"

#. TRANSLATORS: def Code.available_compiler_options()
#: lib/code.ex:336
msgid ""
"Returns a list with the available compiler options.\n"
"\n"
"See `Code.compiler_options/1` for more info.\n"
msgstr ""
"有効なコンパイラオプションのリストを返します。\n"
"\n"
"更なる情報は `Code.compiler_options/1` を参照してください。\n"

#. TRANSLATORS: def Process.flag(flag, value)
#: lib/process.ex:337
msgid ""
"Sets certain flags for the process which calls this function.\n"
"Returns the old value of the flag.\n"
"\n"
"See http://www.erlang.org/doc/man/erlang.html#process_flag-2 for more info.\n"
msgstr ""
"特定のフラグをこの関数を呼び出したプロセスにセットします。\n"
"そのフラグの古い値を返します。\n"
"\n"
"更なる情報は\n"
"http://www.erlang.org/doc/man/erlang.html#process_flag-2\n"
"を参照してください。\n"

#. TRANSLATORS: def Process.flag(pid, flag, value)
#: lib/process.ex:349
msgid ""
"Sets certain flags for the process `pid`, in the same manner as `flag/2`.\n"
"Returns the old value of the flag. The allowed values for `flag` are\n"
"only a subset of those allowed in `flag/2`, namely: `save_calls`.\n"
"\n"
"See http://www.erlang.org/doc/man/erlang.html#process_flag-3 for more info.\n"
msgstr ""
"`flag/2`と同じマナーで、特定のフラグを`pid`プロセスにセットします。\n"
"そのフラグの古い値を返します。`flag`の許された値は`flag/2`のサブセット\n"
"である`save_calls`だけです。\n"
"\n"
"更なる情報は\n"
" http://www.erlang.org/doc/man/erlang.html#process_flag-3 \n"
"を参照してください。\n"

#. TRANSLATORS: def IO.ANSI.yellow_background()
#: lib/io/ansi.ex:104
msgid "Sets background color to yellow"
msgstr "背景色を黄色にセットします"

#. TRANSLATORS: def IO.ANSI.white_background()
#: lib/io/ansi.ex:104
msgid "Sets background color to white"
msgstr "背景色を白にセットします"

#. TRANSLATORS: def IO.ANSI.red_background()
#: lib/io/ansi.ex:104
msgid "Sets background color to red"
msgstr "背景色を赤にセットします"

#. TRANSLATORS: def IO.ANSI.magenta_background()
#: lib/io/ansi.ex:104
msgid "Sets background color to magenta"
msgstr "背景色をマゼンタにセットします"

#. TRANSLATORS: def IO.ANSI.green_background()
#: lib/io/ansi.ex:104
msgid "Sets background color to green"
msgstr "背景色を緑にセットします"

#. TRANSLATORS: def IO.ANSI.cyan_background()
#: lib/io/ansi.ex:104
msgid "Sets background color to cyan"
msgstr "背景色をシアンにセットします"

#. TRANSLATORS: def IO.ANSI.blue_background()
#: lib/io/ansi.ex:104
msgid "Sets background color to blue"
msgstr "背景色を青にセットします"

#. TRANSLATORS: def IO.ANSI.black_background()
#: lib/io/ansi.ex:104
msgid "Sets background color to black"
msgstr "背景色を黒にセットします"

#. TRANSLATORS: def IO.ANSI.font_9()
#: lib/io/ansi.ex:82
msgid "Sets alternative font 9"
msgstr "選択肢フォント9にセットします。"

#. TRANSLATORS: def IO.ANSI.font_8()
#: lib/io/ansi.ex:82
msgid "Sets alternative font 8"
msgstr "選択肢フォント8にセットします。"

#. TRANSLATORS: def IO.ANSI.font_7()
#: lib/io/ansi.ex:82
msgid "Sets alternative font 7"
msgstr "選択肢フォント7にセットします。"

#. TRANSLATORS: def IO.ANSI.font_6()
#: lib/io/ansi.ex:82
msgid "Sets alternative font 6"
msgstr "選択肢フォント6にセットします。"

#. TRANSLATORS: def IO.ANSI.font_5()
#: lib/io/ansi.ex:82
msgid "Sets alternative font 5"
msgstr "選択肢フォント5にセットします。"

#. TRANSLATORS: def IO.ANSI.font_4()
#: lib/io/ansi.ex:82
msgid "Sets alternative font 4"
msgstr "選択肢フォント4にセットします。"

#. TRANSLATORS: def IO.ANSI.font_3()
#: lib/io/ansi.ex:82
msgid "Sets alternative font 3"
msgstr "選択肢フォント3にセットします。"

#. TRANSLATORS: def IO.ANSI.font_2()
#: lib/io/ansi.ex:82
msgid "Sets alternative font 2"
msgstr "選択肢フォント2にセットします。"

#. TRANSLATORS: def IO.ANSI.font_1()
#: lib/io/ansi.ex:82
msgid "Sets alternative font 1"
msgstr "選択肢フォント1にセットします。"

#. TRANSLATORS: def Process.exit(pid, reason)
#: lib/process.ex:100
msgid ""
"Sends an exit signal with the given reason to the pid.\n"
"\n"
"The following behaviour applies if reason is any term except `:normal` or `:"
"kill`:\n"
"\n"
"  1. If pid is not trapping exits, pid will exit with the given reason.\n"
"\n"
"  2. If pid is trapping exits, the exit signal is transformed into a "
"message\n"
"     `{:EXIT, from, reason}` and delivered to the message queue of pid.\n"
"\n"
"  3. If reason is the atom `:normal`, pid will not exit. If it is trapping\n"
"     exits, the exit signal is transformed into a message `{:EXIT, from,\n"
"     :normal}` and delivered to its message queue.\n"
"\n"
"  4. If reason is the atom `:kill`, that is if `exit(pid, :kill)` is "
"called,\n"
"     an untrappable exit signal is sent to pid which will unconditionally\n"
"     exit with exit reason `:killed`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    Process.exit(pid, :kill)\n"
"\n"
msgstr ""
"与えられたreasonとともにexitシグナルをpidに送ります。\n"
"\n"
"reasonが`:normal`または`:kill`を除いた任意の語なら、以下の振舞いが適用\n"
"されます:\n"
"\n"
"  1. pidがexitをトラップなければ、pidは与えられたreasonで終了します。\n"
"\n"
"  2. pidがexitをトラップしていたら、exitシグナルは`{:EXIT, from, reason}`\n"
"     というメッセージに変換され、pidのメッセージキューに配送されます。\n"
"\n"
"  3. reasonがアトム`:normal`なら、pidは終了しないでしょう。もし\n"
"     pidがexitをトラップしていたら、exitシグナルは`{:EXIT, from, :normal}`"
"と\n"
"     いうメッセージに変換され、メッセージキューに配送されます。\n"
"\n"
"  4. reasonがアトム`:kill`なら、つまり、`exit(pid, :kill)`が呼ばれたら、\n"
"     exitをトラップ出来ないシグナルがpidへ送られ、pidは無条件で\n"
"     exit reasonとして`:killed`で終了します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    Process.exit(pid, :kill)\n"
"\n"

#. TRANSLATORS: def GenEvent.notify(manager, event)
#: lib/gen_event.ex:376
msgid ""
"Sends an event notification to the event `manager`.\n"
"\n"
"The event manager will call `handle_event/2` for each\n"
"installed event handler.\n"
"\n"
"`notify` is asynchronous and will return immediately after the\n"
"notification is sent. `notify` will not fail even if the specified\n"
"event manager does not exist, unless it is specified as an atom.\n"
msgstr ""
"イベント`manager`へイベント通知を送ります。\n"
"\n"
"イベントマネージャはそれぞれインストールされたイベントハンドラのために\n"
"`handle_event/2`を呼び出します。\n"
"\n"
"`notify`は非同期で通知を送信したらす直ちに戻ります。`notify`はもし\n"
"`name`(アトム)として指定されないかぎり、指定されたイベントマネージャが\n"
"存在しないときでも失敗しないでしょう。\n"

#. TRANSLATORS: def GenServer.cast(server, request)
#: lib/gen_server.ex:385
msgid ""
"Sends an asynchronous request to the `server`.\n"
"\n"
"This function returns `:ok` without waiting for the\n"
"destination `server` to handle the message. Therefore it\n"
"is unknown whether the destination `server` successfully\n"
"handled the message. If the `server` is an atom without\n"
"an associated process an `ArgumentError` is raised. In\n"
"all other cases the function returns `:ok` regardless of\n"
"whether the destination `server` (or node) exists. Note\n"
"that `{name, node()}` can be used when an exception is\n"
"not desired if no process is locally associated with the\n"
"atom `name`.\n"
"\n"
"`handle_cast/2` will be called on the server to handle\n"
"the request. In case the `server` is on a node which is\n"
"not yet connected to the caller one, the call is going to\n"
"block until a connection happens. This is different than\n"
"the behaviour in OTP's `:gen_server` where the message\n"
"is sent by another process in this case, which could cause\n"
"messages to other nodes to arrive out of order.\n"
msgstr ""
"`server`へ非同期要求を送信します。\n"
"\n"
"この関数は、送信先の`server`がメッセージを処理するのを\n"
"待つことなく`:ok`を返します。従って、送信先の`server`が\n"
"メッセージを処理に成功したかどうかは分りません。もし、\n"
"`server`が関連付けられたプロセスがないアトムなら、\n"
"`ArgumentError`が上がります。\n"
"送信先の`server`(またはノード)が存在するか否かを問わず、\n"
"他の全てのケースでは、関数は`:ok`を返します。\n"
"アトム`name`が関連しているローカルプロセスがなくて、\n"
"例外の発生を望まない場合、`{name, node()}`を使うことが\n"
"できることに注意してください。\n"
"\n"
"`handle_cast/2`は要求を処理するためにサーバで呼ばれます。\n"
"`server`が呼び出し側にまだ接続していないノードである場\n"
"合に備えて、接続が起こるまでは呼出しはブロックします。\n"
"これは、OTPの`:gen_server`ビヘイビアとは異なります(OTP\n"
"の`:gen_server`ビヘイビアでは、この場合、メッセージはも\n"
"う一つのプロセスまで送られ、その結果、他のノードへのメッ\n"
"セージの順序が乱れて到着するかもしれません)。\n"

#. TRANSLATORS: def File.rmdir!(path)
#: lib/file.ex:778
msgid ""
"Same as `rmdir/1`, but raises an exception in case of failure. Otherwise `:"
"ok`.\n"
msgstr ""
"`rmdir/1`と同じですが、失敗すると例外を上げます。さもなくば`:ok`を\n"
"返します。\n"

#. TRANSLATORS: def File.rm_rf!(path)
#: lib/file.ex:881
msgid ""
"Same as `rm_rf/1` but raises `File.Error` in case of failures,\n"
"otherwise the list of files or directories removed.\n"
msgstr ""
"`rm_rf/1`と同じですが、失敗すると`File.Error`を上げます。\n"
"さもなくば削除されたファイルやディレクトリのリストを返します。\n"

#. TRANSLATORS: def File.rm!(path)
#: lib/file.ex:747
msgid ""
"Same as `rm/1`, but raises an exception in case of failure. Otherwise `:"
"ok`.\n"
msgstr ""
"`rm/1`と同じですが、失敗すると例外を上げます。さもなくば`:ok`を返し\n"
"ます。\n"

#. TRANSLATORS: def File.open!(path, modes, function)
#: lib/file.ex:1028
msgid ""
"Same as `open/3` but raises an error if file could not be opened.\n"
"\n"
"Returns the function result otherwise.\n"
msgstr ""
"`open/3`と同じですが、オープンできないとエラーを上げます。\n"
"\n"
"さもないと関数の実行結果を返します。\n"

#. TRANSLATORS: def File.open!(path, modes \\ [])
#: lib/file.ex:1013
msgid ""
"Same as `open/2` but raises an error if file could not be opened.\n"
"\n"
"Returns the `io_device` otherwise.\n"
msgstr ""
"`open/2`と同じですが、オープンできないとエラーを上げます。\n"
"\n"
"さもなければ`io_device`を返します。\n"

#. TRANSLATORS: def File.mkdir_p!(path)
#: lib/file.ex:204
msgid ""
"Same as `mkdir_p/1`, but raises an exception in case of failure. Otherwise `:"
"ok`.\n"
msgstr ""
"`mkdir_p/1`と同じですが、失敗すると例外を上げます。さもなくば\n"
"`:ok`を返します。\n"

#. TRANSLATORS: def File.mkdir!(path)
#: lib/file.ex:151
msgid ""
"Same as `mkdir/1`, but raises an exception in case of failure. Otherwise `:"
"ok`.\n"
msgstr ""
"`mkdir/1`と同じですが、失敗すると例外を上げます。さもなくば\n"
"`:ok`を返します。\n"

#. TRANSLATORS: def File.lstat!(path, opts \\ [])
#: lib/file.ex:326
msgid ""
"Same as `lstat/2` but returns the `File.Stat` directly and\n"
"throws `File.Error` if an error is returned.\n"
msgstr ""
"`stat/2`と同じですが、もしエラーが帰って来たら`File.Stat`を\n"
"直接返さず、`File.Errorを投げます。\n"

#. TRANSLATORS: def File.chown!(path, uid)
#: lib/file.ex:1247
msgid ""
"Same as `chown/2`, but raises an exception in case of failure. Otherwise `:"
"ok`.\n"
msgstr ""
"`chown/2`と同じですが、失敗すると例外を上げます。さもなくば\n"
"`:ok`を返します。\n"

#. TRANSLATORS: def File.chmod!(path, mode)
#: lib/file.ex:1201
msgid ""
"Same as `chmod/2`, but raises an exception in case of failure. Otherwise `:"
"ok`.\n"
msgstr ""
"`chmod/2`と同じですが、失敗すると例外を上げます。さもなくば\n"
"`:ok`を返します。\n"

#. TRANSLATORS: def File.chgrp!(path, gid)
#: lib/file.ex:1224
msgid ""
"Same as `chgrp/2`, but raises an exception in case of failure. Otherwise `:"
"ok`.\n"
msgstr ""
"`chgrp/2`と同じですが、失敗すると例外を上げます。さもなくば\n"
"`:ok`を返します。\n"

#. TRANSLATORS: def Float.round(number, precision \\ 0)
#: lib/float.ex:152
msgid ""
"Rounds a floating point value to an arbitrary number of fractional digits\n"
"(between 0 and 15).\n"
"\n"
"This function only accepts floats and returns floats. Use `Kernel.round/1`\n"
"if you want a function that accepts both floats and integers and always\n"
"returns an integer.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Float.round(5.5674, 3)\n"
"    5.567\n"
"\n"
"    iex> Float.round(5.5675, 3)\n"
"    5.568\n"
"\n"
"    iex> Float.round(-5.5674, 3)\n"
"    -5.567\n"
"\n"
"    iex> Float.round(-5.5675, 3)\n"
"    -5.568\n"
"\n"
msgstr ""
"浮動小数点値を小数点以下任意の桁数(0から15の間)に丸めます。\n"
"\n"
"この関数は小数のみを受け付けて少数を返します。もし小数と整数の両方を受\n"
"付て、常に整数を返す関数を望むなら、`Kernel.round/1`を使用してください。\n"
"\n"
"\n"
"## 例\n"
"\n"
"    iex> Float.round(5.5674, 3)\n"
"    5.567\n"
"\n"
"    iex> Float.round(5.5675, 3)\n"
"    5.568\n"
"\n"
"    iex> Float.round(-5.5674, 3)\n"
"    -5.567\n"
"\n"
"    iex> Float.round(-5.5675, 3)\n"
"    -5.568\n"
"\n"

#. TRANSLATORS: def Float.floor(number, precision \\ 0)
#: lib/float.ex:90
msgid ""
"Rounds a float to the largest integer less than or equal to `num`.\n"
"\n"
"Floor also accepts a precision to round a floating point value down\n"
"to an arbitrary number of fractional digits (between 0 and 15).\n"
"\n"
"This function always returns floats. One may use `Kernel.trunc/1` to\n"
"truncate the result to an integer afterwards.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Float.floor(34.25)\n"
"    34.0\n"
"\n"
"    iex> Float.floor(-56.5)\n"
"    -57.0\n"
"\n"
"    iex> Float.floor(34.253, 2)\n"
"    34.25\n"
"\n"
msgstr ""
"`num`と等しいか小さい最大の整数に小数を丸めます。\n"
"\n"
"floorは任意の小数点の桁数(0から15)を切り下げるための精度を受け付けま\n"
"す。\n"
"\n"
"この関数は常に小数を返します。整数の結果を得るためには\n"
"`Kernel.trunc/1`を使用してください。\n"
"\n"
"## 例\n"
"\n"
"    iex> Float.floor(34.25)\n"
"    34.0\n"
"\n"
"    iex> Float.floor(-56.5)\n"
"    -57.0\n"
"\n"
"    iex> Float.floor(34.253, 2)\n"
"    34.25\n"
"\n"

#. TRANSLATORS: def Float.ceil(number, precision \\ 0)
#: lib/float.ex:120
msgid ""
"Rounds a float to the largest integer greater than or equal to `num`.\n"
"\n"
"Ceil also accepts a precision to round a floating point value down to\n"
"an arbitrary number of fractional digits (between 0 and 15).\n"
"\n"
"This function always returns floats. One may use `Kernel.trunc/1` to\n"
"truncate the result to an integer afterwards.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Float.ceil(34.25)\n"
"    35.0\n"
"\n"
"    iex> Float.ceil(-56.5)\n"
"    -56.0\n"
"\n"
"    iex> Float.ceil(34.253, 2)\n"
"    34.26\n"
"\n"
msgstr ""
"`num`以上の最小の整数に小数を丸めます。\n"
"\n"
"ceilは任意の小数点の桁数(0から15)を切り上げるための精度を受付ます。\n"
"\n"
"この関数は常に小数を返します。整数の結果を得るために`Kernel.trunc/1`が\n"
"使えるかもしれない。\n"
"\n"
"## 例\n"
"\n"
"    iex> Float.ceil(34.25)\n"
"    35.0\n"
"\n"
"    iex> Float.ceil(-56.5)\n"
"    -56.0\n"
"\n"
"    iex> Float.ceil(34.253, 2)\n"
"    34.26\n"
"\n"

#. TRANSLATORS: def Dict.has_key?(dict, key)
#: lib/dict.ex:345
msgid ""
"Returns whether the given `key` exists in the given `dict`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> Dict.has_key?(dict, :a)\n"
"    true\n"
"    iex> Dict.has_key?(dict, :b)\n"
"    false\n"
"\n"
msgstr ""
"与えられた`key`が`dict`に存在するかを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict = Enum.into([a: 1], dict_impl.new)\n"
"    iex> Dict.has_key?(dict, :a)\n"
"    true\n"
"    iex> Dict.has_key?(dict, :b)\n"
"    false\n"
"\n"

#. TRANSLATORS: def Regex.run(regex, string, options \\ [])
#: lib/regex.ex:202
msgid ""
"Runs the regular expression against the given string until the first match.\n"
"It returns a list with all captures or `nil` if no match occurred.\n"
"\n"
"## Options\n"
"\n"
"  * `:return`  - set to `:index` to return indexes. Defaults to `:binary`.\n"
"  * `:capture` - what to capture in the result. Check the moduledoc for "
"`Regex`\n"
"                 to see the possible capture values.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.run(~r/c(d)/, \"abcd\")\n"
"    [\"cd\", \"d\"]\n"
"\n"
"    iex> Regex.run(~r/e/, \"abcd\")\n"
"    nil\n"
"\n"
"    iex> Regex.run(~r/c(d)/, \"abcd\", return: :index)\n"
"    [{2,2},{3,1}]\n"
"\n"
msgstr ""
"最初にマッチするまで、与えられた文字列に対して正規表現を走らせます。全\n"
"てのキャプチャされたリストまたは、マッチがなかった場合は`nil`を返します。\n"
"\n"
"## オプション\n"
"\n"
"  * `:return`  - `:index`をセットするとindexを返します。デフォルト\n"
"                 は`:binary`です。\n"
"  * `:capture` - 結果にキャプチャを含めます。可能なキャプチャの値\n"
"                 を見るために`Regex`のドキュメントをチェックしてください。\n"
"\n"
"## 例\n"
"\n"
"    iex> Regex.run(~r/c(d)/, \"abcd\")\n"
"    [\"cd\", \"d\"]\n"
"\n"
"    iex> Regex.run(~r/e/, \"abcd\")\n"
"    nil\n"
"\n"
"    iex> Regex.run(~r/c(d)/, \"abcd\", return: :index)\n"
"    [{2,2},{3,1}]\n"
"\n"

#. TRANSLATORS: def Stream.run(stream)
#: lib/stream.ex:454
msgid ""
"Runs the given stream.\n"
"\n"
"This is useful when a stream needs to be run, for side effects,\n"
"and there is no interest in its return result.\n"
"\n"
"## Examples\n"
"\n"
"Open up a file, replace all `#` by `%` and stream to another file\n"
"without loading the whole file in memory:\n"
"\n"
"    stream = File.stream!(\"code\")\n"
"    |> Stream.map(&String.replace(&1, \"#\", \"%\"))\n"
"    |> Stream.into(File.stream!(\"new\"))\n"
"    |> Stream.run\n"
"\n"
"No computation will be done until we call one of the Enum functions\n"
"or `Stream.run/1`.\n"
msgstr ""
"与えられたストリームを走らせます。\n"
"\n"
"これは返される結果に関心がなく、副作用を期待してストリームを走らせる必\n"
"要があるとき役に立ちます。\n"
"\n"
"## 例\n"
"\n"
"ファイルをオープンして、すべての`#`を`%`に置き換え、メモリにファイル全\n"
"体をロードせずに他のファイルへ流します:\n"
"\n"
"    stream = File.stream!(\"code\")\n"
"    |> Stream.map(&String.replace(&1, \"#\", \"%\"))\n"
"    |> Stream.into(File.stream!(\"new\"))\n"
"    |> Stream.run\n"
"\n"
"Enumモジュールの関数か、`Stream.run/1`のいずれかを呼び出すまでは\n"
"計算はされません。\n"

#. TRANSLATORS: def Kernel.CLI.run(fun, halt \\ true)
#: lib/kernel/cli.ex:36
msgid ""
"Runs the given function by catching any failure\n"
"and printing them to stdout. `at_exit` hooks are\n"
"also invoked before exiting.\n"
"\n"
"This function is used by Elixir's CLI and also\n"
"by escripts generated by Elixir.\n"
msgstr ""
"標準出力に表示し、失敗をキャッチして与えられた関数を実行します。\n"
"`at_exit`フックは終了する前に呼び出されます。\n"
"\n"
"この関数はElixir CLIと、Elixirにより生成されたescriptによって使用されま\n"
"す。\n"

#. TRANSLATORS: def String.graphemes(string)
#: lib/string.ex:902
msgid ""
"Returns unicode graphemes in the string as per Extended Grapheme\n"
"Cluster algorithm outlined in the [Unicode Standard Annex #29,\n"
"Unicode Text Segmentation](http://www.unicode.org/reports/tr29/).\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.graphemes(\"Ńaïve\")\n"
"    [\"Ń\", \"a\", \"ï\", \"v\", \"e\"]\n"
"\n"
msgstr ""
"[Unicode Text Segmentation](http://www.unicode.org/reports/tr29/)\n"
"に概説されている、Extended Grapheme Cluster アルゴリズムに従って\n"
"文字列のユニコード書記素を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.graphemes(\"Ńaïve\")\n"
"    [\"Ń\", \"a\", \"ï\", \"v\", \"e\"]\n"
"\n"

#. TRANSLATORS: def String.reverse(string)
#: lib/string.ex:701
msgid ""
"Reverses the given string. Works on graphemes.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.reverse(\"abcd\")\n"
"    \"dcba\"\n"
"\n"
"    iex> String.reverse(\"hello world\")\n"
"    \"dlrow olleh\"\n"
"\n"
"    iex> String.reverse(\"hello ∂og\")\n"
"    \"go∂ olleh\"\n"
"\n"
msgstr ""
"与えられた文字列を逆順にします。書記素ベースで働きます。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.reverse(\"abcd\")\n"
"    \"dcba\"\n"
"\n"
"    iex> String.reverse(\"hello world\")\n"
"    \"dlrow olleh\"\n"
"\n"
"    iex> String.reverse(\"hello ∂og\")\n"
"    \"go∂ olleh\"\n"
"\n"

#. TRANSLATORS: def Enum.reverse(collection)
#: lib/enum.ex:1397
msgid ""
"Reverses the collection.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reverse([1, 2, 3])\n"
"    [3, 2, 1]\n"
"\n"
msgstr ""
"コレクションを逆順にします。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.reverse([1, 2, 3])\n"
"    [3, 2, 1]\n"
"\n"

#. TRANSLATORS: def Enum.reverse_slice(coll, start, count)
#: lib/enum.ex:1440
msgid ""
"Reverses the collection in the range from initial position `first`\n"
"through `count` elements. If `count` is greater than the size of\n"
"the rest of the collection, then this function will reverse the rest\n"
"of the collection.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reverse_slice([1, 2, 3, 4, 5, 6], 2, 4)\n"
"    [1, 2, 6, 5, 4, 3]\n"
"\n"
msgstr ""
"初期位置が`first`からの`count`要素の範囲(range)のコレクションを\n"
"逆転させます。\n"
"もし`count`がコレクションの残りの大きさより大きい場合、\n"
"この関数はコレクションの残り全部を逆転させます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.reverse_slice([1, 2, 3, 4, 5, 6], 2, 4)\n"
"    [1, 2, 6, 5, 4, 3]\n"
"\n"

#. TRANSLATORS: def Enum.reverse(collection, tail)
#: lib/enum.ex:1417
msgid ""
"Reverses the collection and appends the tail.\n"
"This is an optimization for\n"
"`Enum.concat(Enum.reverse(collection), tail)`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reverse([1, 2, 3], [4, 5, 6])\n"
"    [3, 2, 1, 4, 5, 6]\n"
"\n"
msgstr ""
"コレクションを逆順にしてtailを追加します。これは\n"
"`Enum.concat(Enum.reverse(collection), tail)`の最適化です。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.reverse([1, 2, 3], [4, 5, 6])\n"
"    [3, 2, 1, 4, 5, 6]\n"
"\n"

#. TRANSLATORS: def Kernel.Typespec.beam_callbacks(module)
#: lib/kernel/typespec.ex:469
msgid ""
"Returns all callbacks available from the module's beam code.\n"
"\n"
"The result is returned as a list of tuples where the first\n"
"element is spec name and arity and the second is the spec.\n"
"\n"
"The module must have a corresponding beam file\n"
"which can be located by the runtime system.\n"
msgstr ""
"モジュールのbeamコードから全ての有効なコールバックを返します。\n"
"\n"
"返された結果は最初の要素がspec nameとarityで次の要素がspecとなるタプ\n"
"ルのリストです。\n"
"\n"
"モジュールは実行時システムによって配置された対応するbeamファイルを\n"
"持っていなければなりません。\n"

#. TRANSLATORS: def Module.definitions_in(module)
#: lib/module.ex:653
msgid ""
"Returns all functions defined in `module`.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Example do\n"
"      def version, do: 1\n"
"      Module.definitions_in __MODULE__ #=> [{:version,0}]\n"
"    end\n"
"\n"
msgstr ""
"`module`で定義されている全ての関数を返します。\n"
"\n"
"## 例\n"
"\n"
"    defmodule Example do\n"
"      def version, do: 1\n"
"      Module.definitions_in __MODULE__ #=> [{:version,0}]\n"
"    end\n"
"\n"

#. TRANSLATORS: def Module.definitions_in(module, kind)
#: lib/module.ex:672
msgid ""
"Returns all functions defined in `module`, according\n"
"to its kind.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Example do\n"
"      def version, do: 1\n"
"      Module.definitions_in __MODULE__, :def  #=> [{:version,0}]\n"
"      Module.definitions_in __MODULE__, :defp #=> []\n"
"    end\n"
"\n"
msgstr ""
"その種別(kind)によって、`module`で定義されている全ての関数を返します。\n"
"\n"
"## 例\n"
"\n"
"    defmodule Example do\n"
"      def version, do: 1\n"
"      Module.definitions_in __MODULE__, :def  #=> [{:version,0}]\n"
"      Module.definitions_in __MODULE__, :defp #=> []\n"
"    end\n"
"\n"

#. TRANSLATORS: def String.length(string)
#: lib/string.ex:979
msgid ""
"Returns the number of unicode graphemes in an utf8 string.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.length(\"elixir\")\n"
"    6\n"
"\n"
"    iex> String.length(\"եոգլի\")\n"
"    5\n"
"\n"
msgstr ""
"utf8文字列中のunicode書記素の数を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.length(\"elixir\")\n"
"    6\n"
"\n"
"    iex> String.length(\"եոգլի\")\n"
"    5\n"
"\n"

#. TRANSLATORS: def Set.size(set)
#: lib/set.ex:251
msgid ""
"Returns the number of elements in `set`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Set.size(Enum.into([1, 2, 3], set_impl.new))\n"
"    3\n"
"\n"
msgstr ""
"`set`の要素の数を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Set.size(Enum.into([1, 2, 3], set_impl.new))\n"
"    3\n"
"\n"

#. TRANSLATORS: def Dict.size(dict)
#: lib/dict.ex:328
msgid ""
"Returns the number of elements in `dict`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> Dict.size(dict)\n"
"    2\n"
"\n"
msgstr ""
"`dict`の要素の数を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> Dict.size(dict)\n"
"    2\n"
"\n"

#. TRANSLATORS: def Kernel.byte_size(binary)
#: lib/kernel.ex:154
msgid ""
"Returns the number of bytes needed to contain `bitstring`.\n"
"\n"
"That is, if the number of bits in `bitstring` is not divisible by 8,\n"
"the resulting number of bytes will be rounded up. This operation\n"
"happens in constant time.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> byte_size(<<433::16, 3::3>>)\n"
"    3\n"
"\n"
"    iex> byte_size(<<1, 2, 3>>)\n"
"    3\n"
"\n"
msgstr ""
"`bitstring`を格納するために必要なバイト数を返します。\n"
"\n"
"これは、もし`bitstring`のbit数が8で割り切れない場合、結果として生じるバ\n"
"イト数は切り上げられます。このオペレーションは定数時間で実行されます。\n"
"\n"
"ガード中でテストに使うことができます。コンパイラによってインライン化さ\n"
"れます。\n"
"\n"
"## 例\n"
"\n"
"    iex> byte_size(<<433::16, 3::3>>)\n"
"    3\n"
"\n"
"    iex> byte_size(<<1, 2, 3>>)\n"
"    3\n"
"\n"

#. TRANSLATORS: def Enum.min(collection)
#: lib/enum.ex:1141
msgid ""
"Returns the minimum value.\n"
"Raises `EmptyError` if the collection is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.min([1, 2, 3])\n"
"    1\n"
"\n"
msgstr ""
"最小の値を返します。\n"
"もしコレクションが空なら、`EmptyError`を上げます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.min([1, 2, 3])\n"
"    1\n"
"\n"

#. TRANSLATORS: def Enum.min_by(collection, fun)
#: lib/enum.ex:1156
msgid ""
"Returns the minimum value as calculated by the given function.\n"
"Raises `EmptyError` if the collection is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.min_by([\"a\", \"aa\", \"aaa\"], fn(x) -> String.length(x) "
"end)\n"
"    \"a\"\n"
"\n"
msgstr ""
"与えられた関数により計算した値が最小となる要素を返します。\n"
"もしコレクションが空なら、`EmptyError`を上げます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.min_by([\"a\", \"aa\", \"aaa\"], fn(x) -> String.length(x) "
"end)\n"
"    \"a\"\n"
"\n"

#. TRANSLATORS: def Enum.max(collection)
#: lib/enum.ex:1055
msgid ""
"Returns the maximum value.\n"
"Raises `EmptyError` if the collection is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.max([1, 2, 3])\n"
"    3\n"
"\n"
msgstr ""
"最大の値を返します。\n"
"もしコレクションが空なら、`EmptyError`を上げます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.max([1, 2, 3])\n"
"    3\n"
"\n"

#. TRANSLATORS: def Enum.max_by(collection, fun)
#: lib/enum.ex:1070
msgid ""
"Returns the maximum value as calculated by the given function.\n"
"Raises `EmptyError` if the collection is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.max_by([\"a\", \"aa\", \"aaa\"], fn(x) -> String.length(x) "
"end)\n"
"    \"aaa\"\n"
"\n"
msgstr ""
"与えられた関数により計算した値が最大となる要素を返します。\n"
"もしコレクションが空なら、`EmptyError`を上げます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.max_by([\"a\", \"aa\", \"aaa\"], fn(x) -> String.length(x) "
"end)\n"
"    \"aaa\"\n"
"\n"

#. TRANSLATORS: def GenEvent.sync_notify(manager, event)
#: lib/gen_event.ex:410
msgid ""
"Sends a sync event notification to the event `manager`.\n"
"\n"
"In other words, this function only returns `:ok` after the event manager\n"
"invokes the `handle_event/2` on each installed event handler.\n"
"\n"
"See `notify/2` for more info.\n"
msgstr ""
"同期イベント通知をイベント`manager`へ送信します。\n"
"\n"
"言い替えると、この関数は、イベントマネージャで各々のインストールされた\n"
"イベントハンドラ`handle_event/2`が呼び出されたあと、`:ok`を返すだけです。\n"
"\n"
"更なる情報は、`notify/2`を参照してください。\n"

#. TRANSLATORS: def Process.send(dest, msg, options)
#: lib/process.ex:127
msgid ""
"Sends a message to the given process.\n"
"\n"
"If the option `:noconnect` is used and sending the message would require an\n"
"auto-connection to another node the message is not sent and `:noconnect` is\n"
"returned.\n"
"\n"
"If the option `:nosuspend` is used and sending the message would cause the\n"
"sender to be suspended the message is not sent and `:nosuspend` is "
"returned.\n"
"\n"
"Otherwise the message is sent and `:ok` is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Process.send({:name, :node_does_not_exist}, :hi, [:noconnect])\n"
"    :noconnect\n"
"\n"
msgstr ""
"与えられたプロセスへメッセージを送信します。\n"
"\n"
"`:noconnect`オプションが使われ、送信するメッセージがもう一つのノードへ\n"
"の自動接続を要求するならば、メッセージは送信されず、`:noconnect`が返さ\n"
"れます。\n"
"\n"
"`:nosuspend`オプションが使われ、送信するメッセージが送信者をサスペンド\n"
"させることにことになる場合、メッセージは送信されず、`:nosuspend`が返さ\n"
"れます。\n"
"\n"
"さもなくば、メッセージは送信され、`:ok`が返されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Process.send({:name, :node_does_not_exist}, :hi, [:noconnect])\n"
"    :noconnect\n"
"\n"

#. TRANSLATORS: def Kernel.send(dest, msg)
#: lib/kernel.ex:562
msgid ""
"Sends a message to the given `dest` and returns the message.\n"
"\n"
"`dest` may be a remote or local pid, a (local) port, a locally\n"
"registered name, or a tuple `{registered_name, node}` for a registered\n"
"name at another node.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> send self(), :hello\n"
"    :hello\n"
"\n"
msgstr ""
"与えられた`dest`へメッセージを送信し、そのメッセージを返します。\n"
"\n"
"`dest`はリモートまたはローカルのpid、(ローカル)ポート、ローカルレジスター\n"
"された名前もしくは他のノードで登録された名前のタプル`{registered_name,\n"
"node}`です。\n"
"\n"
"コンパイラにより、インライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> send self(), :hello\n"
"    :hello\n"
"\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.__MODULE__()
#: lib/kernel/special_forms.ex:595
msgid ""
"Returns the current module name as an atom or `nil` otherwise.\n"
"\n"
"Although the module can be accessed in the `__ENV__`, this macro\n"
"is a convenient shortcut.\n"
msgstr ""
"現在のモジュール名をアトムとして返します。さもなくば`nil`を返します。\n"
"\n"
"`__ENV__`の中でモジュールはアクセスできますが、このマクロは\n"
"便利なショートカットです。\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.__ENV__()
#: lib/kernel/special_forms.ex:587
msgid ""
"Returns the current environment information as a `Macro.Env` struct.\n"
"\n"
"In the environment you can access the current filename,\n"
"line numbers, set up aliases, the current function and others.\n"
msgstr ""
"`Macro.Env`構造体として現在の環境情報を返します。\n"
"\n"
"環境では現在のファイル名、行番号、セットアップされた別名、\n"
"および現在の関数などにアクセスできます。\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.__DIR__()
#: lib/kernel/special_forms.ex:603
msgid ""
"Returns the current directory as a binary.\n"
"\n"
"Although the directory can be accessed as `Path.dirname(__ENV__.file)`,\n"
"this macro is a convenient shortcut.\n"
msgstr ""
"バイナリとして現在のディレクトリを返します。\n"
"\n"
"そのディレクトリには`Path.dirname(__ENV__.file)`としてもアクセスできま\n"
"すが、このマクロは便利なショートカットです。\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.__CALLER__()
#: lib/kernel/special_forms.ex:611
msgid ""
"Returns the current calling environment as a `Macro.Env` struct.\n"
"\n"
"In the environment you can access the filename, line numbers,\n"
"set up aliases, the function and others.\n"
msgstr ""
"`Macro.Env`構造体として現在の呼び出し側の環境を返します。\n"
"\n"
"環境では現在のファイル名、行番号、セットアップされた別名、\n"
"および現在の関数などにアクセスできます。\n"

#. TRANSLATORS: defmacro Bitwise.__using__(options)
#: lib/bitwise.ex:31
msgid ""
"Allows a developer to use this module in their programs with\n"
"the following options:\n"
"\n"
"  * `:only_operators` - include only operators\n"
"  * `:skip_operators` - skip operators\n"
"\n"
msgstr ""
"開発者に、彼らのプログラムで、\n"
"このモジュールに以下のオプションを使うことを許します:\n"
"\n"
"  * `:only_operators` - 演算子のみインクルードします\n"
"  * `:skip_operators` - 演算子をスキップします\n"
"\n"

#. TRANSLATORS: def Keyword.has_key?(keywords, key)
#: lib/keyword.ex:400
msgid ""
"Returns whether a given `key` exists in the given `keywords`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.has_key?([a: 1], :a)\n"
"    true\n"
"\n"
"    iex> Keyword.has_key?([a: 1], :b)\n"
"    false\n"
"\n"
msgstr ""
"与えられた`keywords`中に与えられた`key`があるかどうかを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.has_key?([a: 1], :a)\n"
"    true\n"
"\n"
"    iex> Keyword.has_key?([a: 1], :b)\n"
"    false\n"
"\n"

#. TRANSLATORS: def Macro.Env.in_match?(arg1)
#: lib/macro/env.ex:116
msgid ""
"Returns whether the compilation environment is currently\n"
"inside a match clause.\n"
msgstr "コンパイル環境が現在のマッチ節の内部かどうかを返します。\n"

#. TRANSLATORS: def Macro.Env.in_guard?(arg1)
#: lib/macro/env.ex:110
msgid ""
"Returns whether the compilation environment is currently\n"
"inside a guard.\n"
msgstr "コンパイル環境が現在ガードの内部かどうかを返します。\n"

#. TRANSLATORS: def Process.send_after(dest, msg, time)
#: lib/process.ex:149
msgid ""
"Sends `msg` to `dest` after `time` milliseconds.\n"
"\n"
"If `dest` is a pid, it must be the pid of a local process, dead or alive.\n"
"If `dest` is an atom, it must be the name of a registered process\n"
"which is looked up at the time of delivery. No error is given if the name "
"does\n"
"not refer to a process.\n"
"\n"
"This function returns a timer reference, which can be read or canceled with\n"
"`:erlang.read_timer/1`, `:erlang.start_timer/3` and `:erlang."
"cancel_timer/1`.\n"
"Note `time` cannot be greater than `4294967295`.\n"
"\n"
"Finally, the timer will be automatically canceled if the given `dest` is a "
"pid\n"
"which is not alive or when the given pid exits. Note that timers will not "
"be\n"
"automatically canceled when `dest` is an atom (as the atom resolution is "
"done\n"
"on delivery).\n"
msgstr ""
"`msg`を`dest`へ`time`ミリ秒後に送信します。\n"
"\n"
"もし`dest`がpidなら、ローカルプロセスのpidで死んでいるか生きているかで\n"
"なければなりません。もし`dest`がアトムなら、配送時に調べられる登録済み\n"
"プロセスの名前でなければなりません。名前がプロセスを差さないならば、エ\n"
"ラーとなりません。\n"
"\n"
"この関数は`:erlang.read_timer/1`、`:erlang.start_timer/3`,\n"
"`:erlang.cancel_timer/1`で読み込み、キャンセルができるタイマリファレン\n"
"スを返します。\n"
"`time`は`4294967295`より大きくできないことに注意してください。\n"
"\n"
"最後に、与えられた`pid`が生きていなかったり、存在しなかったりした場合、\n"
"タイマは自動的にキャンセルされます。タイマは`dest`がアトム(アトムは配送\n"
"時に解決されます)の場合、自動的にキャンセルされないことに注意してくださ\n"
"い。\n"

#. TRANSLATORS: def Process.alive?(pid)
#: lib/process.ex:24
msgid ""
"Returns true if the process exists and is alive, that is,\n"
"is not exiting and has not exited. Otherwise, returns false.\n"
"\n"
"`pid` must refer to a process at the local node.\n"
msgstr ""
"プロセスが存在して生きている、つまり、終了中でなく、\n"
"終了完了していないということですが、そのとき、trueを返します。\n"
"さもなければfalseを返します。\n"
"\n"
"`pid`はローカルノードのプロセスの参照でなければなりません。\n"

#. TRANSLATORS: def Enum.count(collection, fun)
#: lib/enum.ex:455
msgid ""
"Returns the count of items in the collection for which\n"
"`fun` returns `true`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.count([1, 2, 3, 4, 5], fn(x) -> rem(x, 2) == 0 end)\n"
"    2\n"
"\n"
msgstr ""
"コレクションの中で`fun`が`true`を返す要素の数を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.count([1, 2, 3, 4, 5], fn(x) -> rem(x, 2) == 0 end)\n"
"    2\n"
"\n"

#. TRANSLATORS: def Enum.count(collection)
#: lib/enum.ex:429
msgid ""
"Returns the collection's size.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.count([1, 2, 3])\n"
"    3\n"
"\n"
msgstr ""
"コレクションのサイズを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.count([1, 2, 3])\n"
"    3\n"
"\n"

#. TRANSLATORS: def Node.get_cookie()
#: lib/node.ex:256
msgid ""
"Returns the magic cookie of the local node.\n"
"\n"
"Returns the cookie if the node is alive, otherwise `:nocookie`.\n"
msgstr ""
"ローカルノードのマジッククッキーを返します。\n"
"\n"
"もしノードが生きていればクッキーを、さもなくば`:nocookie`を返します。\n"

#. TRANSLATORS: def Kernel.length(list)
#: lib/kernel.ex:419
msgid ""
"Returns the length of `list`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> length([1, 2, 3, 4, 5, 6, 7, 8, 9])\n"
"    9\n"
"\n"
msgstr ""
"`list`の長さを返します。\n"
"\n"
"ガード中のテストに使うことができます。コンパイラによりインライン化され\n"
"ます。\n"
"\n"
"## 例\n"
"\n"
"    iex> length([1, 2, 3, 4, 5, 6, 7, 8, 9])\n"
"    9\n"
"\n"

#. TRANSLATORS: def String.last(string)
#: lib/string.ex:956
msgid ""
"Returns the last grapheme from an utf8 string,\n"
"`nil` if the string is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.last(\"elixir\")\n"
"    \"r\"\n"
"\n"
"    iex> String.last(\"եոգլի\")\n"
"    \"ի\"\n"
"\n"
msgstr ""
"utf8文字列から最後の書記素を返します。\n"
"文字列が空なら`nil`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.last(\"elixir\")\n"
"    \"r\"\n"
"\n"
"    iex> String.last(\"եոգլի\")\n"
"    \"ի\"\n"
"\n"

#. TRANSLATORS: def List.last(list1)
#: lib/list.ex:155
msgid ""
"Returns the last element in `list` or `nil` if `list` is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.last([])\n"
"    nil\n"
"\n"
"    iex> List.last([1])\n"
"    1\n"
"\n"
"    iex> List.last([1, 2, 3])\n"
"    3\n"
"\n"
msgstr ""
"`list`の最後の要素、または`list`が空なら`nil`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.last([])\n"
"    nil\n"
"\n"
"    iex> List.last([1])\n"
"    1\n"
"\n"
"    iex> List.last([1, 2, 3])\n"
"    3\n"
"\n"

#. TRANSLATORS: def Path.basename(path)
#: lib/path.ex:335
msgid ""
"Returns the last component of the path or the path\n"
"itself if it does not contain any directory separators.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.basename(\"foo\")\n"
"    \"foo\"\n"
"\n"
"    iex> Path.basename(\"foo/bar\")\n"
"    \"bar\"\n"
"\n"
"    iex> Path.basename(\"/\")\n"
"    \"\"\n"
"\n"
msgstr ""
"パスの最後の構成要素、またはディレクトリセパレータを含んでいないならパ\n"
"スそのものを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Path.basename(\"foo\")\n"
"    \"foo\"\n"
"\n"
"    iex> Path.basename(\"foo/bar\")\n"
"    \"bar\"\n"
"\n"
"    iex> Path.basename(\"/\")\n"
"    \"\"\n"
"\n"

#. TRANSLATORS: def Path.basename(path, extension)
#: lib/path.ex:357
msgid ""
"Returns the last component of `path` with the `extension`\n"
"stripped. This function should be used to remove a specific\n"
"extension which may, or may not, be there.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.basename(\"~/foo/bar.ex\", \".ex\")\n"
"    \"bar\"\n"
"\n"
"    iex> Path.basename(\"~/foo/bar.exs\", \".ex\")\n"
"    \"bar.exs\"\n"
"\n"
"    iex> Path.basename(\"~/foo/bar.old.ex\", \".ex\")\n"
"    \"bar.old\"\n"
"\n"
msgstr ""
"`extension`を取り除いた`path`の最後の構成要素を返します。この関数は、あ\n"
"るかないかわからない特定の拡張子を取り除くために使うべきです。\n"
"\n"
"## 例\n"
"\n"
"    iex> Path.basename(\"~/foo/bar.ex\", \".ex\")\n"
"    \"bar\"\n"
"\n"
"    iex> Path.basename(\"~/foo/bar.exs\", \".ex\")\n"
"    \"bar.exs\"\n"
"\n"
"    iex> Path.basename(\"~/foo/bar.old.ex\", \".ex\")\n"
"    \"bar.old\"\n"
"\n"

#. TRANSLATORS: def Integer.undigits(digits, base \\ 10)
#: lib/integer.ex:71
msgid ""
"Returns the integer represented by the ordered digits.\n"
"\n"
"An optional base value may be provided representing the radix for the "
"digits.\n"
"\n"
" ## Examples\n"
"\n"
"     iex> Integer.undigits([1, 0, 1])\n"
"     101\n"
"\n"
"     iex> Integer.undigits([1, 4], 16)\n"
"     20\n"
msgstr ""
"桁のリストによって表現された整数を返します。\n"
"\n"
"オプションで桁のリストの基数を指定することができます。\n"
"\n"
" ## 例\n"
"\n"
"     iex> Integer.undigits([1, 0, 1])\n"
"     101\n"
"\n"
"     iex> Integer.undigits([1, 4], 16)\n"
"     20\n"

#. TRANSLATORS: def Kernel.hd(list)
#: lib/kernel.ex:248
msgid ""
"Returns the head of a list, raises `badarg` if the list is empty.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"リストの先頭(ヘッド)を返します。もしリストが空なら`badarg`を上げます。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def String.at(string, position)
#: lib/string.ex:1013
msgid ""
"Returns the grapheme in the `position` of the given utf8 `string`.\n"
"If `position` is greater than `string` length, then it returns `nil`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.at(\"elixir\", 0)\n"
"    \"e\"\n"
"\n"
"    iex> String.at(\"elixir\", 1)\n"
"    \"l\"\n"
"\n"
"    iex> String.at(\"elixir\", 10)\n"
"    nil\n"
"\n"
"    iex> String.at(\"elixir\", -1)\n"
"    \"r\"\n"
"\n"
"    iex> String.at(\"elixir\", -10)\n"
"    nil\n"
"\n"
msgstr ""
"与えられたutf8の`string`の`position`の位置の書記素を返します。\n"
"`position`が`string`の長さより大きいなら、`nil`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.at(\"elixir\", 0)\n"
"    \"e\"\n"
"\n"
"    iex> String.at(\"elixir\", 1)\n"
"    \"l\"\n"
"\n"
"    iex> String.at(\"elixir\", 10)\n"
"    nil\n"
"\n"
"    iex> String.at(\"elixir\", -1)\n"
"    \"r\"\n"
"\n"
"    iex> String.at(\"elixir\", -10)\n"
"    nil\n"
"\n"

#. TRANSLATORS: def Enum.find(collection, ifnone \\ nil, fun)
#: lib/enum.ex:706
msgid ""
"Returns the first item for which `fun` returns a truthy value. If no such\n"
"item is found, returns `ifnone`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.find([2, 4, 6], fn(x) -> rem(x, 2) == 1 end)\n"
"    nil\n"
"\n"
"    iex> Enum.find([2, 4, 6], 0, fn(x) -> rem(x, 2) == 1 end)\n"
"    0\n"
"\n"
"    iex> Enum.find([2, 3, 4], fn(x) -> rem(x, 2) == 1 end)\n"
"    3\n"
"\n"
msgstr ""
"`fun`を実行してtrueを返す最初のアイテムを返します。もしアイテムが見つか\n"
"らないなら、`ifnone`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.find([2, 4, 6], fn(x) -> rem(x, 2) == 1 end)\n"
"    nil\n"
"\n"
"    iex> Enum.find([2, 4, 6], 0, fn(x) -> rem(x, 2) == 1 end)\n"
"    0\n"
"\n"
"    iex> Enum.find([2, 3, 4], fn(x) -> rem(x, 2) == 1 end)\n"
"    3\n"
"\n"

#. TRANSLATORS: def Regex.named_captures(regex, string, options \\ [])
#: lib/regex.ex:233
msgid ""
"Returns the given captures as a map or `nil` if no captures are\n"
"found. The option `:return` can be set to `:index` to get indexes\n"
"back.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.named_captures(~r/c(?<foo>d)/, \"abcd\")\n"
"    %{\"foo\" => \"d\"}\n"
"\n"
"    iex> Regex.named_captures(~r/a(?<foo>b)c(?<bar>d)/, \"abcd\")\n"
"    %{\"bar\" => \"d\", \"foo\" => \"b\"}\n"
"\n"
"    iex> Regex.named_captures(~r/a(?<foo>b)c(?<bar>d)/, \"efgh\")\n"
"    nil\n"
"\n"
msgstr ""
"与えられたキャプチャをマップとして返します。キャプチャが見付からないな\n"
"ら、`nil`を返します。インデックスを戻すために`:return`オプションを\n"
"`:index`にセットすることができます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Regex.named_captures(~r/c(?<foo>d)/, \"abcd\")\n"
"    %{\"foo\" => \"d\"}\n"
"\n"
"    iex> Regex.named_captures(~r/a(?<foo>b)c(?<bar>d)/, \"abcd\")\n"
"    %{\"bar\" => \"d\", \"foo\" => \"b\"}\n"
"\n"
"    iex> Regex.named_captures(~r/a(?<foo>b)c(?<bar>d)/, \"efgh\")\n"
"    nil\n"
"\n"

#. TRANSLATORS: def List.Chars.BitString.to_char_list(thing)
#: lib/list/chars.ex:23
msgid "Returns the given binary converted to a char list.\n"
msgstr "与えられたバイナリを文字のリストに変換したものを返します。\n"

#. TRANSLATORS: def Path.relative_to(path, from)
#: lib/path.ex:288
msgid ""
"Returns the given `path` relative to the given `from` path.\n"
"In other words, it tries to strip the `from` prefix from `path`.\n"
"\n"
"This function does not query the file system, so it assumes\n"
"no symlinks in between the paths.\n"
"\n"
"In case a direct relative path cannot be found, it returns\n"
"the original path.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.relative_to(\"/usr/local/foo\", \"/usr/local\")\n"
"    \"foo\"\n"
"\n"
"    iex> Path.relative_to(\"/usr/local/foo\", \"/\")\n"
"    \"usr/local/foo\"\n"
"\n"
"    iex> Path.relative_to(\"/usr/local/foo\", \"/etc\")\n"
"    \"/usr/local/foo\"\n"
"\n"
msgstr ""
"与えられた`path`の与えられた`from`パスからの相対パスを返します。\n"
"言い替えると、`from`プレフィックスを`path`から取り除こうとします。\n"
"\n"
"この関数はファイルシステムへの問合せはしませんので、\n"
"パスの間のシンボリックリンクを考慮しません。\n"
"\n"
"直接的な相対パスが見付からないと、オリジナルパスを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Path.relative_to(\"/usr/local/foo\", \"/usr/local\")\n"
"    \"foo\"\n"
"\n"
"    iex> Path.relative_to(\"/usr/local/foo\", \"/\")\n"
"    \"usr/local/foo\"\n"
"\n"
"    iex> Path.relative_to(\"/usr/local/foo\", \"/etc\")\n"
"    \"/usr/local/foo\"\n"
"\n"

#. TRANSLATORS: def Range.Iterator.next(first, range)
#: lib/range.ex:55
msgid "Returns the function that calculates the next item.\n"
msgstr "次のアイテムを計算する関数を返します。\n"

#. TRANSLATORS: def Keyword.pop_first(keywords, key, default \\ nil)
#: lib/keyword.ex:597
msgid ""
"Returns the first value associated with `key` in the keyword\n"
"list as well as the keyword list without that particular occurrence\n"
"of `key`.\n"
"\n"
"Duplicated keys are not removed.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.pop_first [a: 1], :a\n"
"    {1,[]}\n"
"\n"
"    iex> Keyword.pop_first [a: 1], :b\n"
"    {nil,[a: 1]}\n"
"\n"
"    iex> Keyword.pop_first [a: 1], :b, 3\n"
"    {3,[a: 1]}\n"
"\n"
"    iex> Keyword.pop_first [a: 1], :b, 3\n"
"    {3,[a: 1]}\n"
"\n"
"    iex> Keyword.pop_first [a: 1, a: 2], :a\n"
"    {1,[a: 2]}\n"
"\n"
msgstr ""
"キーワードリストの中の`key`に関連付けられた最初の値\n"
"と、その`key`を取り除いたキーワードリストを返します。\n"
"\n"
"重複したキーは削除されません。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.pop_first [a: 1], :a\n"
"    {1,[]}\n"
"\n"
"    iex> Keyword.pop_first [a: 1], :b\n"
"    {nil,[a: 1]}\n"
"\n"
"    iex> Keyword.pop_first [a: 1], :b, 3\n"
"    {3,[a: 1]}\n"
"\n"
"    iex> Keyword.pop_first [a: 1], :b, 3\n"
"    {3,[a: 1]}\n"
"\n"
"    iex> Keyword.pop_first [a: 1, a: 2], :a\n"
"    {1,[a: 2]}\n"
"\n"

#. TRANSLATORS: def Keyword.pop(keywords, key, default \\ nil)
#: lib/keyword.ex:568
msgid ""
"Returns the first value associated with `key` in the keyword\n"
"list as well as the keyword list without `key`.\n"
"\n"
"All duplicated keys are removed. See `pop_first/3` for\n"
"removing only the first entry.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.pop [a: 1], :a\n"
"    {1,[]}\n"
"\n"
"    iex> Keyword.pop [a: 1], :b\n"
"    {nil,[a: 1]}\n"
"\n"
"    iex> Keyword.pop [a: 1], :b, 3\n"
"    {3,[a: 1]}\n"
"\n"
"    iex> Keyword.pop [a: 1], :b, 3\n"
"    {3,[a: 1]}\n"
"\n"
"    iex> Keyword.pop [a: 1, a: 2], :a\n"
"    {1,[]}\n"
"\n"
msgstr ""
"キーワードリストの中の`key`に関連付けられた最初の値\n"
"と、その`key`を取り除いたキーワードリストを返します。\n"
"\n"
"全ての重複したキーは削除されます。最初のエントリだけを\n"
"削除するためには `pop_first/3`を参照してください。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.pop [a: 1], :a\n"
"    {1,[]}\n"
"\n"
"    iex> Keyword.pop [a: 1], :b\n"
"    {nil,[a: 1]}\n"
"\n"
"    iex> Keyword.pop [a: 1], :b, 3\n"
"    {3,[a: 1]}\n"
"\n"
"    iex> Keyword.pop [a: 1], :b, 3\n"
"    {3,[a: 1]}\n"
"\n"
"    iex> Keyword.pop [a: 1, a: 2], :a\n"
"    {1,[]}\n"
"\n"

#. TRANSLATORS: def String.first(string)
#: lib/string.ex:935
msgid ""
"Returns the first grapheme from an utf8 string,\n"
"nil if the string is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.first(\"elixir\")\n"
"    \"e\"\n"
"\n"
"    iex> String.first(\"եոգլի\")\n"
"    \"ե\"\n"
"\n"
msgstr ""
"utf8文字列から最初の書記素を返します。\n"
"文字列が空ならnilを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.first(\"elixir\")\n"
"    \"e\"\n"
"\n"
"    iex> String.first(\"եոգլի\")\n"
"    \"ե\"\n"
"\n"

#. TRANSLATORS: def List.first(list1)
#: lib/list.ex:136
msgid ""
"Returns the first element in `list` or `nil` if `list` is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.first([])\n"
"    nil\n"
"\n"
"    iex> List.first([1])\n"
"    1\n"
"\n"
"    iex> List.first([1, 2, 3])\n"
"    1\n"
"\n"
msgstr ""
"`list`の最初の要素を返します。`list`が空なら`nil`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.first([])\n"
"    nil\n"
"\n"
"    iex> List.first([1])\n"
"    1\n"
"\n"
"    iex> List.first([1, 2, 3])\n"
"    1\n"
"\n"

#. TRANSLATORS: def Path.extname(path)
#: lib/path.ex:390
msgid ""
"Returns the extension of the last component of `path`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.extname(\"foo.erl\")\n"
"    \".erl\"\n"
"\n"
"    iex> Path.extname(\"~/foo/bar\")\n"
"    \"\"\n"
"\n"
msgstr ""
"`path`の最後の構成要素の拡張子を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Path.extname(\"foo.erl\")\n"
"    \".erl\"\n"
"\n"
"    iex> Path.extname(\"~/foo/bar\")\n"
"    \"\"\n"
"\n"

#. TRANSLATORS: def Code.get_docs(module, kind)
#: lib/code.ex:506
msgid ""
"Returns the docs for the given module.\n"
"\n"
"When given a module name, it finds its BEAM code and reads the docs from "
"it.\n"
"\n"
"When given a path to a .beam file, it will load the docs directly from that\n"
"file.\n"
"\n"
"The return value depends on the `kind` value:\n"
"\n"
"  * `:docs` - list of all docstrings attached to functions and macros\n"
"    using the `@doc` attribute\n"
"\n"
"  * `:moduledoc` - tuple `{<line>, <doc>}` where `line` is the line on\n"
"    which module definition starts and `doc` is the string\n"
"    attached to the module using the `@moduledoc` attribute\n"
"\n"
"  * `:all` - a keyword list with both `:docs` and `:moduledoc`\n"
"\n"
msgstr ""
"与えられたモジュールのドキュメントを返します。\n"
"\n"
"モジュール名が与えられたとき、そこからbeamコードを見付け、ドキュメントを\n"
"読み出します。\n"
"\n"
".beamファイルへのパスが与えられたとき、そのファイルからダイレクトに\n"
"ドキュメントをロードします。\n"
"\n"
"`kind`の値に依存して返される値は以下のようになります:\n"
"\n"
"  * `:docs` - `@doc`アトリビュートを使って関数とマクロにアタッチ\n"
"              されたドキュメント文字列の全てのリストです。\n"
"\n"
"  * `:moduledoc` - タプル `{<line>, <doc>}`、ただし、\n"
"                `line`はモジュールの定義が開始される行で、`doc`は\n"
"               `@moduledoc`アトリビュートを使ってモジュールにアタッチされた\n"
"               文字列です。\n"
"\n"
"  * `:all` - `:docs`と`:moduledoc`の両方のキーワードリストです。\n"
"\n"

#. TRANSLATORS: def Code.append_path(path)
#: lib/code.ex:32
msgid ""
"Appends a path to the Erlang VM code path.\n"
"\n"
"The path is expanded with `Path.expand/1` before being appended.\n"
msgstr ""
"Erlang VMコードパスにpathを後ろに追加します。\n"
"\n"
"pathは付加される前に、`Path.expand/1`で展開されます。\n"

#. TRANSLATORS: def Macro.Env.stacktrace(env)
#: lib/macro/env.ex:121
msgid "Returns the environment stacktrace.\n"
msgstr "その環境のスタックトレースを返します。\n"

#. TRANSLATORS: def Path.dirname(path)
#: lib/path.ex:373
msgid ""
"Returns the directory component of `path`.\n"
"\n"
"## Examples\n"
"\n"
"    Path.dirname(\"/foo/bar.ex\")\n"
"    #=> \"/foo\"\n"
"    Path.dirname(\"/foo/bar/baz.ex\")\n"
"    #=> \"/foo/bar\"\n"
"\n"
msgstr ""
"`path`のディレクトリ部分を返します。\n"
"\n"
"## 例\n"
"\n"
"    Path.dirname(\"/foo/bar.ex\")\n"
"    #=> \"/foo\"\n"
"    Path.dirname(\"/foo/bar/baz.ex\")\n"
"    #=> \"/foo/bar\"\n"
"\n"

#. TRANSLATORS: def String.codepoints(string)
#: lib/string.ex:747
msgid ""
"Returns all codepoints in the string.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.codepoints(\"olá\")\n"
"    [\"o\", \"l\", \"á\"]\n"
"\n"
"    iex> String.codepoints(\"оптими зации\")\n"
"    [\"о\",\"п\",\"т\",\"и\",\"м\",\"и\",\" \",\"з\",\"а\",\"ц\",\"и\",\"и"
"\"]\n"
"\n"
"    iex> String.codepoints(\"ἅἪῼ\")\n"
"    [\"ἅ\",\"Ἢ\",\"ῼ\"]\n"
"\n"
msgstr ""
"文字列の全てのコードポイントを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.codepoints(\"olá\")\n"
"    [\"o\", \"l\", \"á\"]\n"
"\n"
"    iex> String.codepoints(\"оптими зации\")\n"
"    [\"о\",\"п\",\"т\",\"и\",\"м\",\"и\",\" \",\"з\",\"а\",\"ц\",\"и\",\"и"
"\"]\n"
"\n"
"    iex> String.codepoints(\"ἅἪῼ\")\n"
"    [\"ἅ\",\"Ἢ\",\"ῼ\"]\n"
"\n"

#. TRANSLATORS: def Task.Supervisor.children(supervisor)
#: lib/task/supervisor.ex:86
msgid "Returns all children pids.\n"
msgstr "全ての子プロセスのpidを返します。\n"

#. TRANSLATORS: def URI.default_port(scheme)
#: lib/uri.ex:27
msgid ""
"Returns the default port for a given scheme.\n"
"\n"
"If the scheme is unknown to URI, returns `nil`.\n"
"Any scheme may be registered via `default_port/2`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> URI.default_port(\"ftp\")\n"
"    21\n"
"\n"
"    iex> URI.default_port(\"ponzi\")\n"
"    nil\n"
"\n"
msgstr ""
"与えられたプロトコルスキームのデフォルトポートを返します。\n"
"\n"
"もしスキームがURIにとって知られていないなら、`nil`を返します。\n"
"任意のスキームは`default_port/2`で登録することができます。\n"
"\n"
"## 例\n"
"\n"
"    iex> URI.default_port(\"ftp\")\n"
"    21\n"
"\n"
"    iex> URI.default_port(\"ponzi\")\n"
"    nil\n"
"\n"

#. TRANSLATORS: def Enum.minmax(collection)
#: lib/enum.ex:1194
msgid ""
"Returns a tuple with the minimum and maximum values.\n"
"Raises `EmptyError` if the collection is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.minmax([2, 3, 1])\n"
"    {1, 3}\n"
"\n"
msgstr ""
"最小と最大の値のタプルを返します。\n"
"もしコレクションが空なら、`EmptyError`を上げます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.minmax([2, 3, 1])\n"
"    {1, 3}\n"
"\n"

#. TRANSLATORS: def Enum.minmax_by(collection, fun)
#: lib/enum.ex:1220
msgid ""
"Returns a tuple with the minimum and maximum values as calculated by the "
"given function.\n"
"Raises `EmptyError` if the collection is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.minmax_by([\"aaa\", \"bb\", \"c\"], fn(x) -> String.length(x) "
"end)\n"
"    {\"c\", \"aaa\"}\n"
"\n"
msgstr ""
"与えられた関数により計算した値が最小と最大となる要素のタプルを\n"
"返します。\n"
"もしコレクションが空なら、`EmptyError`を上げます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.minmax_by([\"aaa\", \"bb\", \"c\"], fn(x) -> String.length(x) "
"end)\n"
"    {\"c\", \"aaa\"}\n"
"\n"

#. TRANSLATORS: def Node.self()
#: lib/node.ex:44
msgid ""
"Returns the current node.\n"
"\n"
"It returns the same as the built-in `node()`.\n"
msgstr ""
"現在のノードを返します。\n"
"\n"
"ビルトインの`node()`と同じように返します。\n"

#. TRANSLATORS: def Dict.split(dict, keys)
#: lib/dict.ex:589
msgid ""
"Returns a tuple of two dicts, where the first dict contains only\n"
"entries from `dict` with keys in `keys`, and the second dict\n"
"contains only entries from `dict` with keys not in `keys`.\n"
"\n"
"All non-member keys are ignored.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2, c: 3, d: 4], dict_impl.new)\n"
"    iex> {dict1, dict2} = Dict.split(dict, [:a, :c, :e])\n"
"    iex> {Dict.to_list(dict1) |> Enum.sort, Dict.to_list(dict2) |> Enum."
"sort}\n"
"    {[a: 1, c: 3], [b: 2, d: 4]}\n"
"\n"
"    iex> dict = Enum.into([], dict_impl.new)\n"
"    iex> {dict1, dict2} = Dict.split(dict, [:a, :c])\n"
"    iex> {Dict.to_list(dict1), Dict.to_list(dict2)}\n"
"    {[], []}\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> {dict1, dict2} = Dict.split(dict, [:a, :b, :c])\n"
"    iex> {Dict.to_list(dict1) |> Enum.sort, Dict.to_list(dict2)}\n"
"    {[a: 1, b: 2], []}\n"
"\n"
msgstr ""
"二つのdictのタプルを返します。最初のdictは`dict`からキーのリスト\n"
"`keys`を含むエントリだけのdictで、二つめのdictは`dict`からキーのリスト\n"
"`keys`を含まないエントリのだけのdictです。\n"
"\n"
"メンバーでないkeysは全て無視されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2, c: 3, d: 4], dict_impl.new)\n"
"    iex> {dict1, dict2} = Dict.split(dict, [:a, :c, :e])\n"
"    iex> {Dict.to_list(dict1) |> Enum.sort, Dict.to_list(dict2) |> Enum."
"sort}\n"
"    {[a: 1, c: 3], [b: 2, d: 4]}\n"
"\n"
"    iex> dict = Enum.into([], dict_impl.new)\n"
"    iex> {dict1, dict2} = Dict.split(dict, [:a, :c])\n"
"    iex> {Dict.to_list(dict1), Dict.to_list(dict2)}\n"
"    {[], []}\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> {dict1, dict2} = Dict.split(dict, [:a, :b, :c])\n"
"    iex> {Dict.to_list(dict1) |> Enum.sort, Dict.to_list(dict2)}\n"
"    {[a: 1, b: 2], []}\n"
"\n"

#. TRANSLATORS: def Enum.with_index(collection)
#: lib/enum.ex:2053
msgid ""
"Returns the collection with each element wrapped in a tuple\n"
"alongside its index.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.with_index [1,2,3]\n"
"    [{1,0},{2,1},{3,2}]\n"
"\n"
msgstr ""
"それぞれの要素をそのインデックスと一緒にタプルで包んだ\n"
"コレクションを、返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.with_index [1,2,3]\n"
"    [{1,0},{2,1},{3,2}]\n"
"\n"

#. TRANSLATORS: defmacro Kernel.binding(context \\ nil)
#: lib/kernel.ex:2100
msgid ""
"Returns the binding for the given context as a keyword list.\n"
"\n"
"The variable name is the key and the variable value is the value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> x = 1\n"
"    iex> binding()\n"
"    [x: 1]\n"
"    iex> x = 2\n"
"    iex> binding()\n"
"    [x: 2]\n"
"\n"
"    iex> binding(:foo)\n"
"    []\n"
"    iex> var!(x, :foo) = 1\n"
"    1\n"
"    iex> binding(:foo)\n"
"    [x: 1]\n"
"\n"
msgstr ""
"キーワードリストとして与えられたコンテキストのバインディングを\n"
"返します。\n"
"\n"
"変数名はキーでその変数の値がバリューになります。\n"
"\n"
"## 例\n"
"\n"
"    iex> x = 1\n"
"    iex> binding()\n"
"    [x: 1]\n"
"    iex> x = 2\n"
"    iex> binding()\n"
"    [x: 2]\n"
"\n"
"    iex> binding(:foo)\n"
"    []\n"
"    iex> var!(x, :foo) = 1\n"
"    1\n"
"    iex> binding(:foo)\n"
"    [x: 1]\n"
"\n"

#. TRANSLATORS: def Protocol.consolidated?(protocol)
#: lib/protocol.ex:233
msgid "Returns true if the protocol was consolidated.\n"
msgstr "プロトコルが合成(consolidate)されていればtrueを返します。\n"

#. TRANSLATORS: defmacro Record.defrecordp(name, tag \\ nil, kv)
#: lib/record.ex:178
msgid "Same as `defrecord/3` but generates private macros.\n"
msgstr "`defrecord/3`と同じですが、プライベートマクロを生成します。\n"

#. TRANSLATORS: def File.ls(path \\ ".")
#: lib/file.ex:1123
msgid ""
"Returns list of files in the given directory.\n"
"\n"
"It returns `{:ok, [files]}` in case of success,\n"
"`{:error, reason}` otherwise.\n"
msgstr ""
"与えられたディレクトリの中のファイルのリストを返します。\n"
"\n"
"成功すると、`{:ok, [files]}`を、さもなくば、\n"
"`{:error, reason}`を返します。\n"

#. TRANSLATORS: def Kernel.max(first, second)
#: lib/kernel.ex:467
msgid ""
"Returns the biggest of the two given terms according to\n"
"Erlang's term ordering. If the terms compare equal, the\n"
"first one is returned.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> max(1, 2)\n"
"    2\n"
"\n"
msgstr ""
"与えられた二つのtermのうち、Erlangのtermの順序について、大きいほうを\n"
"返します。termが等しいなら、firstを返します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> max(1, 2)\n"
"    2\n"
"\n"

#. TRANSLATORS: def Path.rootname(path, extension)
#: lib/path.ex:425
msgid ""
"Returns the `path` with the `extension` stripped. This function should be "
"used to\n"
"remove a specific extension which might, or might not, be there.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.rootname(\"/foo/bar.erl\", \".erl\")\n"
"    \"/foo/bar\"\n"
"\n"
"    iex> Path.rootname(\"/foo/bar.erl\", \".ex\")\n"
"    \"/foo/bar.erl\"\n"
"\n"
msgstr ""
"`extension`を取り去った`path`を返します。\n"
"この関数は、そこにあるかもしれないか、ないかもしれない特定の拡張子を、\n"
"取り除くために使われるべきです。\n"
"\n"
"## 例\n"
"\n"
"    iex> Path.rootname(\"/foo/bar.erl\", \".erl\")\n"
"    \"/foo/bar\"\n"
"\n"
"    iex> Path.rootname(\"/foo/bar.erl\", \".ex\")\n"
"    \"/foo/bar.erl\"\n"
"\n"

#. TRANSLATORS: def Path.rootname(path)
#: lib/path.ex:407
msgid ""
"Returns the `path` with the `extension` stripped.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.rootname(\"/foo/bar\")\n"
"    \"/foo/bar\"\n"
"\n"
"    iex> Path.rootname(\"/foo/bar.ex\")\n"
"    \"/foo/bar\"\n"
"\n"
msgstr ""
"`拡張子`を取り去った`path`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Path.rootname(\"/foo/bar\")\n"
"    \"/foo/bar\"\n"
"\n"
"    iex> Path.rootname(\"/foo/bar.ex\")\n"
"    \"/foo/bar\"\n"
"\n"

#. TRANSLATORS: def Process.info(pid)
#: lib/process.ex:361
msgid ""
"Returns information about the process identified by `pid` or `nil` if the "
"process\n"
"is not alive.\n"
"Use this only for debugging information.\n"
"\n"
"See http://www.erlang.org/doc/man/erlang.html#process_info-1 for more info.\n"
msgstr ""
"`pid`によるプロセス識別子についての情報を返します。\n"
"プロセスが生きていないなら、`nil`を返します。\n"
"これはデバッギング情報のためにだけ使います。\n"
"\n"
"詳細は、http://www.erlang.org/doc/man/erlang.html#process_info-1 \n"
"を参照してください。\n"

#. TRANSLATORS: def Process.info(pid, spec)
#: lib/process.ex:372
msgid ""
"Returns information about the process identified by `pid`\n"
"or `nil` if the process is not alive.\n"
"\n"
"See http://www.erlang.org/doc/man/erlang.html#process_info-2 for more info.\n"
msgstr ""
"`pid`によるプロセス識別子についての情報を返します。\n"
"プロセスが生きていないなら、`nil`を返します。\n"
"\n"
"詳細は、http://www.erlang.org/doc/man/erlang.html#process_info-2\n"
"を参照してください。\n"

#. TRANSLATORS: def File.lstat(path, opts \\ [])
#: lib/file.ex:312
msgid ""
"Returns information about the `path`. If the file is a symlink sets \n"
"the `type` to `:symlink` and returns `File.Stat` for the link. For any\n"
"other file, returns exactly the same values as `stat/2`. For more details\n"
"see http://www.erlang.org/doc/man/file.html#read_link_info-2 \n"
"\n"
"## Options\n"
"\n"
"The accepted options are:\n"
"\n"
"  * `:time` - configures how the file timestamps are returned\n"
"\n"
"The values for `:time` can be:\n"
"\n"
"  * `:local` - returns a `{date, time}` tuple using the machine time\n"
"  * `:universal` - returns a `{date, time}` tuple in UTC\n"
"  * `:posix` - returns the time as integer seconds since epoch\n"
"\n"
msgstr ""
"`path`についての、情報を返します。もしファイルがシンボリックリング\n"
"なら、`type`を`:symlink`にセットして、リンクについての`File.Stat`を\n"
"返します。その他のファイルの場合、`stat/2`と全く同じ値を返します。\n"
"詳細は、 http://www.erlang.org/doc/man/file.html#read_link_info-2 を\n"
"参照してください。\n"
"\n"
"## オプション\n"
"\n"
"以下のオプションを受け付けます:\n"
"\n"
"  * `:time` - ファイルのタイムタンプを\n"
"             どのように返すかを構成します\n"
"\n"
"`:time`の値は以下のものが可能です:\n"
"\n"
"  * `:local` - マシンタイムを使い、`{date, time}`タプルを返します。\n"
"  * `:universal` - UTCの`{date, time}`タプルを返します。\n"
"  * `:posix` - epochからの整数の秒数として時刻を返します。\n"
"\n"

#. TRANSLATORS: def Kernel.node(arg)
#: lib/kernel.ex:508
msgid ""
"Returns the node where the given argument is located.\n"
"The argument can be a pid, a reference, or a port.\n"
"If the local node is not alive, `nonode@nohost` is returned.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"与えられた引数の場所のノードを返します。\n"
"引数はpid、リファレンス、又はポートです。\n"
"ローカルノードが生きていなければ、`nonode@nohost`が返ります。\n"
"\n"
"ガードテストに使えます。\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Set.difference(set1, set2)
#: lib/set.ex:92
msgid ""
"Returns a set that is `set1` without the members of `set2`.\n"
"\n"
"Notice this function is polymorphic as it calculates the difference\n"
"for of any type. Each set implementation also provides a `difference`\n"
"function, but they can only work with sets of the same type.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Set.difference(Enum.into([1,2], set_impl.new), Enum.into([2,3,4], "
"set_impl.new)) |> Enum.sort\n"
"    [1]\n"
"\n"
msgstr ""
"`set1`から`set2`のメンバを取り除いた集合を返します。\n"
"\n"
"この関数は、任意のタイプの差を計算するので、polymorphic(多態的) であること"
"に\n"
"注意してください。集合のそれぞれの実装は、`difference`関数も\n"
"提供しますが、それらは同じタイプの集合で動くことができる\n"
"だけです。\n"
"\n"
"## 例\n"
"\n"
"    iex> Set.difference(Enum.into([1,2], set_impl.new), Enum.into([2,3,4], "
"set_impl.new)) |> Enum.sort\n"
"    [1]\n"
"\n"

#. TRANSLATORS: def Dict.drop(dict, keys)
#: lib/dict.ex:611
msgid ""
"Returns a new dict where the given `keys` are removed from `dict`.\n"
"All non-member keys are ignored.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.drop(dict, [:a, :c, :d])\n"
"    iex> Dict.to_list(dict)\n"
"    [b: 2]\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.drop(dict, [:c, :d])\n"
"    iex> Dict.to_list(dict) |> Enum.sort\n"
"    [a: 1, b: 2]\n"
"\n"
msgstr ""
"与えられた`keys`を`dict`から取り除いた新しいdictを返します。\n"
"メンバーでないキーは全て無視されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.drop(dict, [:a, :c, :d])\n"
"    iex> Dict.to_list(dict)\n"
"    [b: 2]\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.drop(dict, [:c, :d])\n"
"    iex> Dict.to_list(dict) |> Enum.sort\n"
"    [a: 1, b: 2]\n"
"\n"

#. TRANSLATORS: def Exception.exception?(arg1)
#: lib/exception.ex:37
msgid "Returns true if the given argument is an exception.\n"
msgstr "与えられた引数が例外ならtrueを返します。\n"

#. TRANSLATORS: def String.next_grapheme(string)
#: lib/string.ex:919
msgid ""
"Returns the next grapheme in a String.\n"
"\n"
"The result is a tuple with the grapheme and the\n"
"remaining of the string or `nil` in case\n"
"the String reached its end.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.next_grapheme(\"olá\")\n"
"    {\"o\", \"lá\"}\n"
"\n"
msgstr ""
"文字列の中の次の書記素を返します。\n"
"\n"
"結果は、書記素と、文字列の残りまたは、文字列がその終わりに到達したとき\n"
"は`nil`、のタプルです。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.next_grapheme(\"olá\")\n"
"    {\"o\", \"lá\"}\n"
"\n"

#. TRANSLATORS: def String.next_codepoint(string)
#: lib/string.ex:769
msgid ""
"Returns the next codepoint in a String.\n"
"\n"
"The result is a tuple with the codepoint and the\n"
"remaining of the string or `nil` in case\n"
"the string reached its end.\n"
"\n"
"As with other functions in the String module, this\n"
"function does not check for the validity of the codepoint.\n"
"That said, if an invalid codepoint is found, it will\n"
"be returned by this function.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.next_codepoint(\"olá\")\n"
"    {\"o\", \"lá\"}\n"
"\n"
msgstr ""
"文字列の中の次のコードポイントを返します。\n"
"\n"
"結果は、コードポイントと、文字列の残りまたは、文字列がその終わりに到達したと"
"き\n"
"は`nil`、のタプルです。\n"
"\n"
"Stringモジュールの他の関数と同様に、この関数はコードポイントの\n"
"有効性についてチェックしません。\n"
"それは、もし無効なコードポイントを見付けたら、それは\n"
"この関数によって返される、ということを言っています。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.next_codepoint(\"olá\")\n"
"    {\"o\", \"lá\"}\n"
"\n"

#. TRANSLATORS: def Enum.reject(collection, fun)
#: lib/enum.ex:1379
msgid ""
"Returns elements of collection for which `fun` returns `false`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reject([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    [1, 3]\n"
"\n"
msgstr ""
"`fun`が`false`となるコレクションの要素を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.reject([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    [1, 3]\n"
"\n"

#. TRANSLATORS: def File.stat(path, opts \\ [])
#: lib/file.ex:269
msgid ""
"Returns information about the `path`. If it exists, it\n"
"returns a `{:ok, info}` tuple, where info is a\n"
"`File.Stat` struct. Returns `{:error, reason}` with\n"
"the same reasons as `read/1` if a failure occurs.\n"
"\n"
"## Options\n"
"\n"
"The accepted options are:\n"
"\n"
"  * `:time` - configures how the file timestamps are returned\n"
"\n"
"The values for `:time` can be:\n"
"\n"
"  * `:local` - returns a `{date, time}` tuple using the machine time\n"
"  * `:universal` - returns a `{date, time}` tuple in UTC\n"
"  * `:posix` - returns the time as integer seconds since epoch\n"
"\n"
msgstr ""
"`path`についての、情報を返します。もしあれば、infoが`File.Stat`構造体と\n"
"して、`{:ok, info}`タプルを返します。失敗が発生したら、`read/1`と同じ\n"
"reasonで、`{:error, reason}`を返します。\n"
"\n"
"## オプション\n"
"\n"
"以下のオプションを受け付けます:\n"
"\n"
"  * `:time` - ファイルのタイムタンプを\n"
"             どのように返すかを構成します\n"
"\n"
"`:time`の値は以下のものが可能です:\n"
"\n"
"  * `:local` - マシンタイムを使い、`{date, time}`タプルを返します。\n"
"  * `:universal` - UTCの`{date, time}`タプルを返します。\n"
"  * `:posix` - epochからの整数の秒数として時刻を返します。\n"
"\n"

#. TRANSLATORS: def StringIO.contents(pid)
#: lib/string_io.ex:54
msgid ""
"Returns current buffers.\n"
"\n"
"## Examples\n"
"\n"
"    iex> {:ok, pid} = StringIO.open(\"in\")\n"
"    iex> IO.write(pid, \"out\")\n"
"    iex> StringIO.contents(pid)\n"
"    {\"in\", \"out\"}\n"
"\n"
msgstr ""
"現在のバッファを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> {:ok, pid} = StringIO.open(\"in\")\n"
"    iex> IO.write(pid, \"out\")\n"
"    iex> StringIO.contents(pid)\n"
"    {\"in\", \"out\"}\n"
"\n"

#. TRANSLATORS: def File.read!(path)
#: lib/file.ex:239
msgid ""
"Returns binary with the contents of the given filename or raises\n"
"`File.Error` if an error occurs.\n"
msgstr ""
"与えられたファイル名の内容をバイナリで返します。\n"
"あるいは、エラーが起きたら`File.Error`を上げます。\n"

#. TRANSLATORS: def List.to_float(char_list)
#: lib/list.ex:484
msgid ""
"Returns the float whose text representation is `char_list`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.to_float('2.2017764e+0')\n"
"    2.2017764\n"
"\n"
msgstr ""
"テキスト表現が`char_list`である浮動小数点数を返します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.to_float('2.2017764e+0')\n"
"    2.2017764\n"
"\n"

#. TRANSLATORS: def URI.query_decoder(q)
#: lib/uri.ex:116
msgid ""
"Returns an iterator function over the query string that decodes\n"
"the query string in steps.\n"
"\n"
"## Examples\n"
"\n"
"    iex> URI.query_decoder(\"foo=1&bar=2\") |> Enum.map &(&1)\n"
"    [{\"foo\", \"1\"}, {\"bar\", \"2\"}]\n"
"\n"
msgstr ""
"query stringを一つずつデコードする、\n"
"イテレータ関数を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> URI.query_decoder(\"foo=1&bar=2\") |> Enum.map &(&1)\n"
"    [{\"foo\", \"1\"}, {\"bar\", \"2\"}]\n"
"\n"

#. TRANSLATORS: def String.to_integer(string)
#: lib/string.ex:1399
msgid ""
"Returns an integer whose text representation is `string`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.to_integer(\"123\")\n"
"    123\n"
"\n"
msgstr ""
"テキスト表現が`string`となる整数を返します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.to_integer(\"123\")\n"
"    123\n"
"\n"

#. TRANSLATORS: def String.to_integer(string, base)
#: lib/string.ex:1415
msgid ""
"Returns an integer whose text representation is `string` in base `base`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.to_integer(\"3FF\", 16)\n"
"    1023\n"
"\n"
msgstr ""
"テキスト表現が基数`base`の`string`である整数を返します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.to_integer(\"3FF\", 16)\n"
"    1023\n"
"\n"

#. TRANSLATORS: def List.to_integer(char_list)
#: lib/list.ex:500
msgid ""
"Returns an integer whose text representation is `char_list`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.to_integer('123')\n"
"    123\n"
"\n"
msgstr ""
"テキスト表現が`char_list`である整数を返します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.to_integer('123')\n"
"    123\n"
"\n"

#. TRANSLATORS: def List.to_integer(char_list, base)
#: lib/list.ex:516
msgid ""
"Returns an integer whose text representation is `char_list` in base `base`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.to_integer('3FF', 16)\n"
"    1023\n"
"\n"
msgstr ""
"テキスト表現が基数`base`の`char_list`である整数を返します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.to_integer('3FF', 16)\n"
"    1023\n"
"\n"

#. TRANSLATORS: def String.slice(string, start, len)
#: lib/string.ex:1074
msgid ""
"Returns a substring starting at the offset given by the first, and\n"
"a length given by the second.\n"
"\n"
"If the offset is greater than string length, then it returns `\"\"`.\n"
"\n"
"Remember this function works with unicode codepoints and considers\n"
"the slices to represent codepoints offsets. If you want to split\n"
"on raw bytes, check `Kernel.binary_part/3` instead.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.slice(\"elixir\", 1, 3)\n"
"    \"lix\"\n"
"\n"
"    iex> String.slice(\"elixir\", 1, 10)\n"
"    \"lixir\"\n"
"\n"
"    iex> String.slice(\"elixir\", 10, 3)\n"
"    \"\"\n"
"\n"
"    iex> String.slice(\"elixir\", -4, 4)\n"
"    \"ixir\"\n"
"\n"
"    iex> String.slice(\"elixir\", -10, 3)\n"
"    \"\"\n"
"\n"
"    iex> String.slice(\"a\", 0, 1500)\n"
"    \"a\"\n"
"\n"
"    iex> String.slice(\"a\", 1, 1500)\n"
"    \"\"\n"
"\n"
"    iex> String.slice(\"a\", 2, 1500)\n"
"    \"\"\n"
"\n"
msgstr ""
"最初に与えられたオフセットからスタートして\n"
"二番めに与えらえた長さの部分文字列を返します。\n"
"\n"
"文字列の長さよりオフセットが大きいなら、`\"\"`を返します。\n"
"\n"
"この関数はunicodeコードポイントで動作すること、そして、コードポイントオ\n"
"フセットを表現するためにスライスを考慮していることを忘れないでください。\n"
"もし生のバイト列で分割したいなら、`Kernel.binary_part/3`を替わりにチェッ\n"
"クしてください。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.slice(\"elixir\", 1, 3)\n"
"    \"lix\"\n"
"\n"
"    iex> String.slice(\"elixir\", 1, 10)\n"
"    \"lixir\"\n"
"\n"
"    iex> String.slice(\"elixir\", 10, 3)\n"
"    \"\"\n"
"\n"
"    iex> String.slice(\"elixir\", -4, 4)\n"
"    \"ixir\"\n"
"\n"
"    iex> String.slice(\"elixir\", -10, 3)\n"
"    \"\"\n"
"\n"
"    iex> String.slice(\"a\", 0, 1500)\n"
"    \"a\"\n"
"\n"
"    iex> String.slice(\"a\", 1, 1500)\n"
"    \"\"\n"
"\n"
"    iex> String.slice(\"a\", 2, 1500)\n"
"    \"\"\n"
"\n"

#. TRANSLATORS: def String.slice(string, range)
#: lib/string.ex:1152
msgid ""
"Returns a substring from the offset given by the start of the\n"
"range to the offset given by the end of the range.\n"
"\n"
"If the start of the range is not a valid offset for the given\n"
"string or if the range is in reverse order, returns `\"\"`.\n"
"\n"
"If the start or end of the range is negative, the whole string\n"
"is traversed first in order to convert the negative indices into\n"
"positive ones.\n"
"\n"
"Remember this function works with unicode codepoints and considers\n"
"the slices to represent codepoints offsets. If you want to split\n"
"on raw bytes, check `Kernel.binary_part/3` instead.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.slice(\"elixir\", 1..3)\n"
"    \"lix\"\n"
"\n"
"    iex> String.slice(\"elixir\", 1..10)\n"
"    \"lixir\"\n"
"\n"
"    iex> String.slice(\"elixir\", 10..3)\n"
"    \"\"\n"
"\n"
"    iex> String.slice(\"elixir\", -4..-1)\n"
"    \"ixir\"\n"
"\n"
"    iex> String.slice(\"elixir\", 2..-1)\n"
"    \"ixir\"\n"
"\n"
"    iex> String.slice(\"elixir\", -4..6)\n"
"    \"ixir\"\n"
"\n"
"    iex> String.slice(\"elixir\", -1..-4)\n"
"    \"\"\n"
"\n"
"    iex> String.slice(\"elixir\", -10..-7)\n"
"    \"\"\n"
"\n"
"    iex> String.slice(\"a\", 0..1500)\n"
"    \"a\"\n"
"\n"
"    iex> String.slice(\"a\", 1..1500)\n"
"    \"\"\n"
"\n"
msgstr ""
"範囲(range)の始まりによって与えられるオフセットから\n"
"範囲の終りまでに与えられるオフセットまで部分文字列を返します。\n"
"\n"
"範囲の始まりが与えられた文字列のオフセットとして正しくない、\n"
"あるいは、範囲が逆順であったら、`\"\"`を返します。\n"
"\n"
"範囲の始まりや終わりが負の場合、負のインデックスを正に変えるために\n"
"文字列全体が最初に走査されます。\n"
"\n"
"この関数はunicodeコードポイントで動作すること、そして、コードポイントオ\n"
"フセットを表現するためにスライスを考慮していることを忘れないでください。\n"
"もし生のバイト列で分割したいなら、`Kernel.binary_part/3`を替わりにチェッ\n"
"クしてください。\n"
"\n"
"\n"
"## 例\n"
"\n"
"    iex> String.slice(\"elixir\", 1..3)\n"
"    \"lix\"\n"
"\n"
"    iex> String.slice(\"elixir\", 1..10)\n"
"    \"lixir\"\n"
"\n"
"    iex> String.slice(\"elixir\", 10..3)\n"
"    \"\"\n"
"\n"
"    iex> String.slice(\"elixir\", -4..-1)\n"
"    \"ixir\"\n"
"\n"
"    iex> String.slice(\"elixir\", 2..-1)\n"
"    \"ixir\"\n"
"\n"
"    iex> String.slice(\"elixir\", -4..6)\n"
"    \"ixir\"\n"
"\n"
"    iex> String.slice(\"elixir\", -1..-4)\n"
"    \"\"\n"
"\n"
"    iex> String.slice(\"elixir\", -10..-7)\n"
"    \"\"\n"
"\n"
"    iex> String.slice(\"a\", 0..1500)\n"
"    \"a\"\n"
"\n"
"    iex> String.slice(\"a\", 1..1500)\n"
"    \"\"\n"
"\n"

#. TRANSLATORS: def Enum.slice(coll, start, count)
#: lib/enum.ex:1609
msgid ""
"Returns a subset list of the given collection. Drops elements\n"
"until element position `start`, then takes `count` elements.\n"
"\n"
"If the count is greater than collection length, it returns as\n"
"much as possible. If zero, then it returns `[]`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.slice(1..100, 5, 10)\n"
"    [6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n"
"\n"
"    iex> Enum.slice(1..10, 5, 100)\n"
"    [6, 7, 8, 9, 10]\n"
"\n"
"    iex> Enum.slice(1..10, 5, 0)\n"
"    []\n"
"\n"
msgstr ""
"与えられたコレクションのサブセットのリストを返します。`start`番目の要素\n"
"まで削除され、そこから`count`個の要素のリストになります。\n"
"\n"
"もしコレクションの長さよりcountが大きいなら、可能な最大値が\n"
"帰って来ます。もし0なら、`[]`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.slice(1..100, 5, 10)\n"
"    [6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n"
"\n"
"    iex> Enum.slice(1..10, 5, 100)\n"
"    [6, 7, 8, 9, 10]\n"
"\n"
"    iex> Enum.slice(1..10, 5, 0)\n"
"    []\n"
"\n"

#. TRANSLATORS: def Enum.slice(coll, arg2)
#: lib/enum.ex:1668
msgid ""
"Returns a subset list of the given collection. Drops elements\n"
"until element position `range.first`, then takes elements until element\n"
"position `range.last` (inclusive).\n"
"\n"
"Positions are calculated by adding the number of items in the collection to\n"
"negative positions (so position -3 in a collection with count 5 becomes\n"
"position 2).\n"
"\n"
"The first position (after adding count to negative positions) must be "
"smaller\n"
"or equal to the last position.\n"
"\n"
"If the start of the range is not a valid offset for the given\n"
"collection or if the range is in reverse order, returns `[]`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.slice(1..100, 5..10)\n"
"    [6, 7, 8, 9, 10, 11]\n"
"\n"
"    iex> Enum.slice(1..10, 5..20)\n"
"    [6, 7, 8, 9, 10]\n"
"\n"
"    iex> Enum.slice(1..10, 11..20)\n"
"    []\n"
"\n"
"    iex> Enum.slice(1..10, 6..5)\n"
"    []\n"
"\n"
msgstr ""
"与えられたコレクションのサブセットのリストを返します。\n"
"\n"
"与えられたコレクションのサブセットのリストを返します。`range.first`番目\n"
"の要素まで削除され、そこから`range.last`番目の要素(要素自身を含みます)\n"
"のリストになります。\n"
"\n"
"負の位置については、位置はコレクション中のアイテムの数を加えることによっ\n"
"て計算されます(だから、カウント5によるコレクションの位置-3は位置2になり\n"
"ます)。\n"
"\n"
"最初の位置(カウントに負の位置を加えた後)は最後の位置と同じか小くなけれ\n"
"ばなりません。\n"
"\n"
"もし範囲の始まりが与えられたコレクションの正しいオフセットで\n"
"ない、あるいは、範囲が逆順であるなら、`[]`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.slice(1..100, 5..10)\n"
"    [6, 7, 8, 9, 10, 11]\n"
"\n"
"    iex> Enum.slice(1..10, 5..20)\n"
"    [6, 7, 8, 9, 10]\n"
"\n"
"    iex> Enum.slice(1..10, 11..20)\n"
"    []\n"
"\n"
"    iex> Enum.slice(1..10, 6..5)\n"
"    []\n"
"\n"

#. TRANSLATORS: def Set.intersection(set1, set2)
#: lib/set.ex:194
msgid ""
"Returns a set containing only members in common between `set1` and `set2`.\n"
"\n"
"Notice this function is polymorphic as it calculates the intersection of\n"
"any type. Each set implementation also provides a `intersection` function,\n"
"but they can only work with sets of the same type.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Set.intersection(Enum.into([1,2], set_impl.new), Enum.into([2,3,4], "
"set_impl.new)) |> Enum.sort\n"
"    [2]\n"
"\n"
"    iex> Set.intersection(Enum.into([1,2], set_impl.new), Enum.into([3,4], "
"set_impl.new)) |> Enum.sort\n"
"    []\n"
"\n"
msgstr ""
"`set1`と`set2`の共通のメンバを含む集合を返します。\n"
"\n"
"この関数は、任意のタイプの共通部分を計算するので、polymorphic であることに\n"
"注意してください。集合のそれぞれの実装は、`intersection`関数も\n"
"提供しますが、それらは同じタイプの集合で動くことができる\n"
"だけです。\n"
"\n"
"## 例\n"
"\n"
"    iex> Set.intersection(Enum.into([1,2], set_impl.new), Enum.into([2,3,4], "
"set_impl.new)) |> Enum.sort\n"
"    [2]\n"
"\n"
"    iex> Set.intersection(Enum.into([1,2], set_impl.new), Enum.into([3,4], "
"set_impl.new)) |> Enum.sort\n"
"    []\n"
"\n"

#. TRANSLATORS: def Enum.sample(collection, count)
#: lib/enum.ex:1505
msgid ""
"Returns a random sublist of a collection.\n"
"\n"
"Notice this function will traverse the whole collection to\n"
"get the random sublist of collection. If you want the random\n"
"number between two integers, the best option is to use the\n"
":random module.\n"
"\n"
"See `sample/1` for notes on implementation and random seed.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.sample(1..10, 2)\n"
"    [1, 5]\n"
"    iex> Enum.sample(?a..?z, 5)\n"
"    'tfesm'\n"
"\n"
msgstr ""
"コレクションのランダムなサブリストを返します。\n"
"\n"
"コレクションのランダムなサブリストを取得するために、この関数は\n"
"コレクション全体をトラバースすることに気を付けてください。\n"
"もし二つの整数の間のランダムな数を望むなら、:randomモジュールを\n"
"使うことがベストな選択です。\n"
"\n"
"実装とランダムシードについてのメモについては`sample/1`を\n"
"参照してください。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.sample(1..10, 2)\n"
"    [1, 5]\n"
"    iex> Enum.sample(?a..?z, 5)\n"
"    'tfesm'\n"
"\n"

#. TRANSLATORS: def Enum.sample(collection)
#: lib/enum.ex:1479
msgid ""
"Returns a random element of a collection.\n"
"Raises `EmptyError` if the collection is empty.\n"
"\n"
"Notice that you need to explicitly call `:random.seed/1` and\n"
"set a seed value for the random algorithm. Otherwise, the\n"
"default seed will be set which will always return the same\n"
"result. For example, one could do the following to set a seed\n"
"dynamically:\n"
"\n"
"    :random.seed(:os.timestamp)\n"
"\n"
"The implementation is based on the\n"
"[reservoir sampling](http://en.wikipedia.org/wiki/"
"Reservoir_sampling#Relation_to_Fisher-Yates_shuffle)\n"
"algorithm.\n"
"It assumes that the sample being returned can fit into memory;\n"
"the input collection doesn't have to - it is traversed just once.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.sample([1,2,3])\n"
"    1\n"
"    iex> Enum.sample([1,2,3])\n"
"    2\n"
"\n"
msgstr ""
"コレクションの要素をランダム化して返します。\n"
"もしコレクションが空なら、`EmptyError`が上ります。\n"
"\n"
"明示的に`:random.seed/1`を呼び出して、乱数アルゴリズムのシード値を設定\n"
"する必要があることに注意してください。さもないと、常に同じデフォルトシー\n"
"ドが設定され、同じ結果が帰って来ます。例えば、以下の様にして一度呼び出\n"
"すと、シードを動的に設定することができます:\n"
"\n"
"    :random.seed(:os.timestamp)\n"
"\n"
"実装は、\n"
"[reservoir sampling](http://en.wikipedia.org/wiki/\n"
"Reservoir_sampling#Relation_to_Fisher-Yates_shuffle)\n"
"アルゴリズムに基いています。\n"
"それは返されるサンプルがメモリに収まると仮定します; 入力の\n"
"コレクションはその必要はありません。それは丁度一度だけトラバース\n"
"されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.shuffle([1, 2, 3])\n"
"    [3, 2, 1]\n"
"    iex> Enum.shuffle([1, 2, 3])\n"
"    [3, 1, 2]\n"
"\n"

#. TRANSLATORS: def String.rjust(subject, len, pad \\ 32)
#: lib/string.ex:583
msgid ""
"Returns a new string of length `len` with `subject` right justified and\n"
"padded with `padding`. If `padding` is not present, it defaults to\n"
"whitespace. When `len` is less than the length of `subject`, `subject` is\n"
"returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.rjust(\"abc\", 5)\n"
"    \"  abc\"\n"
"\n"
"    iex> String.rjust(\"abc\", 5, ?-)\n"
"    \"--abc\"\n"
"\n"
msgstr ""
"`subject`を右寄して、`padding`でパディングした、長さ`len`の新しい文字列\n"
"を返します。もし`padding`がなければ、空白文字がデフォルトです。\n"
"`len`が`subject`の長さより小さいとき、`subject`が返されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.rjust(\"abc\", 5)\n"
"    \"  abc\"\n"
"\n"
"    iex> String.rjust(\"abc\", 5, ?-)\n"
"    \"--abc\"\n"
"\n"

#. TRANSLATORS: def String.ljust(subject, len, pad \\ 32)
#: lib/string.ex:604
msgid ""
"Returns a new string of length `len` with `subject` left justified and "
"padded\n"
"with `padding`. If `padding` is not present, it defaults to whitespace. "
"When\n"
"`len` is less than the length of `subject`, `subject` is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.ljust(\"abc\", 5)\n"
"    \"abc  \"\n"
"\n"
"    iex> String.ljust(\"abc\", 5, ?-)\n"
"    \"abc--\"\n"
"\n"
msgstr ""
"`subject`を左寄して、`padding`でパディングした、長さ`len`の新しい文字列\n"
"を返します。もし`padding`がなければ、空白文字がデフォルトです。\n"
"`len`が`subject`の長さより小さいとき、`subject`が返されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.ljust(\"abc\", 5)\n"
"    \"abc  \"\n"
"\n"
"    iex> String.ljust(\"abc\", 5, ?-)\n"
"    \"abc--\"\n"
"\n"

#. TRANSLATORS: def Map.new()
#: lib/map.ex:23
msgid "Returns a new empty map.\n"
msgstr "新しい空のマップを返します。\n"

#. TRANSLATORS: def Dict.take(dict, keys)
#: lib/dict.ex:632
msgid ""
"Returns a new dict where only the keys in `keys` from `dict` are included.\n"
"\n"
"All non-member keys are ignored.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.take(dict, [:a, :c, :d])\n"
"    iex> Dict.to_list(dict)\n"
"    [a: 1]\n"
"    iex> dict = Dict.take(dict, [:c, :d])\n"
"    iex> Dict.to_list(dict)\n"
"    []\n"
"\n"
msgstr ""
"`dict`から`keys`だけを含む新しいdictを作成して返します。\n"
"\n"
"メンバーでないキーは全て無視されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> dict = Enum.into([a: 1, b: 2], dict_impl.new)\n"
"    iex> dict = Dict.take(dict, [:a, :c, :d])\n"
"    iex> Dict.to_list(dict)\n"
"    [a: 1]\n"
"    iex> dict = Dict.take(dict, [:c, :d])\n"
"    iex> Dict.to_list(dict)\n"
"    []\n"
"\n"

#. TRANSLATORS: def Enum.map(collection, fun)
#: lib/enum.ex:973
msgid ""
"Returns a new collection, where each item is the result\n"
"of invoking `fun` on each corresponding item of `collection`.\n"
"\n"
"For dicts, the function expects a key-value tuple.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.map([1, 2, 3], fn(x) -> x * 2 end)\n"
"    [2, 4, 6]\n"
"\n"
"    iex> Enum.map([a: 1, b: 2], fn({k, v}) -> {k, -v} end)\n"
"    [a: -1, b: -2]\n"
"\n"
msgstr ""
"`collection`のそれぞれのアイテムについて、`fun`を実行した結果を\n"
"要素とする、新しいコレクションを返します。\n"
"\n"
"dictの場合、関数はKey-valueタプルを期待します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.map([1, 2, 3], fn(x) -> x * 2 end)\n"
"    [2, 4, 6]\n"
"\n"
"    iex> Enum.map([a: 1, b: 2], fn({k, v}) -> {k, -v} end)\n"
"    [a: -1, b: -2]\n"
"\n"

#. TRANSLATORS: def Enum.flat_map(collection, fun)
#: lib/enum.ex:791
msgid ""
"Returns a new collection appending the result of invoking `fun`\n"
"on each corresponding item of `collection`.\n"
"\n"
"The given function should return an enumerable.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.flat_map([:a, :b, :c], fn(x) -> [x, x] end)\n"
"    [:a, :a, :b, :b, :c, :c]\n"
"\n"
"    iex> Enum.flat_map([{1,3}, {4,6}], fn({x,y}) -> x..y end)\n"
"    [1, 2, 3, 4, 5, 6]\n"
"\n"
msgstr ""
"`collection`のそれぞれのアイテムに、`fun`を実行した結果を\n"
"追加した、新しいコレクションを返します。\n"
"\n"
"与えられた関数はenumerableを返さなければなりません。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.flat_map([:a, :b, :c], fn(x) -> [x, x] end)\n"
"    [:a, :a, :b, :b, :c, :c]\n"
"\n"
"    iex> Enum.flat_map([{1,3}, {4,6}], fn({x,y}) -> x..y end)\n"
"    [1, 2, 3, 4, 5, 6]\n"
"\n"

#. TRANSLATORS: def Inspect.Algebra.to_doc(map, opts)
#: lib/inspect/algebra.ex:182
msgid ""
"Converts an Elixir structure to an algebra document\n"
"according to the inspect protocol.\n"
msgstr ""
"Elixirの構造を、Inspectプロトコルに従って、\n"
"algebraドキュメントに変換します。\n"

#. TRANSLATORS: def Integer.parse(binary, base \\ 10)
#: lib/integer.ex:119
msgid ""
"Converts a binary from a text representation of an integer\n"
"in an optional base `base` to the corresponding integer.\n"
"\n"
"If the base `base` is not given, base 10 will be used.\n"
"\n"
"If successful, returns a tuple of the form `{integer, remainder_of_binary}"
"`.\n"
"Otherwise `:error`.\n"
"\n"
"Raises an error if `base` is less than 2 or more than 36.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Integer.parse(\"34\")\n"
"    {34,\"\"}\n"
"\n"
"    iex> Integer.parse(\"34.5\")\n"
"    {34,\".5\"}\n"
"\n"
"    iex> Integer.parse(\"three\")\n"
"    :error\n"
"\n"
"    iex> Integer.parse(\"34\", 10)\n"
"    {34, \"\"}\n"
"\n"
"    iex> Integer.parse(\"f4\", 16)\n"
"    {244, \"\"}\n"
"\n"
"    iex> Integer.parse(\"Awww++\", 36)\n"
"    {509216, \"++\"}\n"
"\n"
"    iex> Integer.parse(\"fab\", 10)\n"
"    :error\n"
"\n"
"    iex> Integer.parse(\"a2\", 38)\n"
"    ** (ArgumentError) invalid base 38\n"
"\n"
msgstr ""
"オプションで指定した基数`base`の整数のテキスト表現のバイナリ\n"
"から、対応する整数へ変換します。\n"
"\n"
"基数`base`が与えられないなら、10が使われます。\n"
"\n"
"成功すると、`{integer, remainder_of_binary}`形式のタプルを返し、\n"
"さもなくば、`:error`を返します。\n"
"\n"
"`base`が2より小さいか、36より大きい場合、エラーを上げます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Integer.parse(\"34\")\n"
"    {34,\"\"}\n"
"\n"
"    iex> Integer.parse(\"34.5\")\n"
"    {34,\".5\"}\n"
"\n"
"    iex> Integer.parse(\"three\")\n"
"    :error\n"
"\n"
"    iex> Integer.parse(\"34\", 10)\n"
"    {34, \"\"}\n"
"\n"
"    iex> Integer.parse(\"f4\", 16)\n"
"    {244, \"\"}\n"
"\n"
"    iex> Integer.parse(\"Awww++\", 36)\n"
"    {509216, \"++\"}\n"
"\n"
"    iex> Integer.parse(\"fab\", 10)\n"
"    :error\n"
"\n"
"    iex> Integer.parse(\"a2\", 38)\n"
"    ** (ArgumentError) invalid base 38\n"
"\n"

#. TRANSLATORS: def Kernel.Typespec.spec_to_ast(name, arg2)
#: lib/kernel/typespec.ex:338
msgid "Converts a spec clause back to Elixir AST.\n"
msgstr "spec節をElixir ASTへコンバートします。\n"

#. TRANSLATORS: def List.to_tuple(list)
#: lib/list.ex:532
msgid ""
"Converts a list to a tuple.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.to_tuple([:share, [:elixir, 163]])\n"
"    {:share, [:elixir, 163]}\n"
"\n"
msgstr ""
"リストをタプルに変換します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.to_tuple([:share, [:elixir, 163]])\n"
"    {:share, [:elixir, 163]}\n"
"\n"

#. TRANSLATORS: def List.to_string(list)
#: lib/list.ex:554
msgid ""
"Converts a list of integers representing codepoints, lists or\n"
"strings into a string.\n"
"\n"
"Notice that this function expects a list of integers representing\n"
"UTF-8 codepoints. If you have a list of bytes, you must instead use\n"
"[the `:binary` module](http://erlang.org/doc/man/binary.html).\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.to_string([0x00E6, 0x00DF])\n"
"    \"æß\"\n"
"\n"
"    iex> List.to_string([0x0061, \"bc\"])\n"
"    \"abc\"\n"
"\n"
msgstr ""
"コードポイントで表現された整数、リスト、文字列のリストを、\n"
"文字列に変換します。\n"
"\n"
"\n"
"この関数は、UTF-8コードポイントで表現される整数のリストを期待している\n"
"ことに、注意してください。\n"
"もしバイトのリストをもっていたら、\n"
"[`:binary`モジュール](http://erlang.org/doc/man/binary.html)\n"
"を代りに使わなければなりません。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.to_string([0x00E6, 0x00DF])\n"
"    \"æß\"\n"
"\n"
"    iex> List.to_string([0x0061, \"bc\"])\n"
"    \"abc\"\n"
"\n"

#. TRANSLATORS: def List.to_existing_atom(char_list)
#: lib/list.ex:468
msgid ""
"Converts a char list to an existing atom.\n"
"\n"
"Currently Elixir does not support conversions from char lists\n"
"which contains Unicode codepoints greater than 0xFF.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"文字リストを存在するアトムに変換します。\n"
"\n"
"現在のElixirは、0xFFを越えるUnicodeコードポイントを含む\n"
"文字リストからの変換をサポートしていません。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def List.to_atom(char_list)
#: lib/list.ex:455
msgid ""
"Converts a char list to an atom.\n"
"\n"
"Currently Elixir does not support conversions from char lists\n"
"which contains Unicode codepoints greater than 0xFF.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.to_atom('elixir')\n"
"    :elixir\n"
"\n"
msgstr ""
"文字リストをアトムに変換します。\n"
"\n"
"現在のElixirは、0xFFを越えるUnicodeコードポイントを含む\n"
"文字リストからの変換をサポートしていません。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.to_atom('elixir')\n"
"    :elixir\n"
"\n"

#. TRANSLATORS: def File.Stat.to_record(stat)
#: lib/file/stat.ex:65
msgid "Converts a `File.Stat` struct to a `:file_info` record.\n"
msgstr "`File.Stat`構造体を`:file_info`レコードに変換します。\n"

#. TRANSLATORS: def File.Stat.from_record(arg1)
#: lib/file/stat.ex:72
msgid "Converts a `:file_info` record into a `File.Stat`.\n"
msgstr "`:file_info`レコードを`File.Stat`に変換します。\n"

#. TRANSLATORS: def Enum.scan(enum, acc, fun)
#: lib/enum.ex:1555
msgid ""
"Applies the given function to each element in the collection,\n"
"storing the result in a list and passing it as the accumulator\n"
"for the next computation. Uses the given `acc` as the starting value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.scan(1..5, 0, &(&1 + &2))\n"
"    [1,3,6,10,15]\n"
"\n"
msgstr ""
"与えられた関数を、コレクションのそれぞれの要素に適用し、\n"
"リストに結果を保存し、次の計算のためのアキュムレータとして\n"
"渡します。与えられた`acc`は、初期値として使います。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.scan(1..5, 0, &(&1 + &2))\n"
"    [1,3,6,10,15]\n"
"\n"

#. TRANSLATORS: def Enum.scan(enum, fun)
#: lib/enum.ex:1537
msgid ""
"Applies the given function to each element in the collection,\n"
"storing the result in a list and passing it as the accumulator\n"
"for the next computation.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.scan(1..5, &(&1 + &2))\n"
"    [1,3,6,10,15]\n"
"\n"
msgstr ""
"与えられた関数を、コレクションのそれぞれの要素に適用し、\n"
"リストに結果を保存し、次の計算のためのアキュムレータとして\n"
"渡します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.scan(1..5, &(&1 + &2))\n"
"    [1,3,6,10,15]\n"
"\n"

#. TRANSLATORS: defmacro Kernel.destructure(left, right)
#: lib/kernel.ex:2217
msgid ""
"Allows you to destructure two lists, assigning each term in the right to "
"the\n"
"matching term in the left. Unlike pattern matching via `=`, if the sizes of\n"
"the left and right lists don't match, destructuring simply stops instead of\n"
"raising an error.\n"
"\n"
"## Examples\n"
"\n"
"    iex> destructure([x, y, z], [1, 2, 3, 4, 5])\n"
"    iex> {x, y, z}\n"
"    {1, 2, 3}\n"
"\n"
"Notice in the example above, even though the right\n"
"size has more entries than the left, destructuring works\n"
"fine. If the right size is smaller, the remaining items\n"
"are simply assigned to nil:\n"
"\n"
"    iex> destructure([x, y, z], [1])\n"
"    iex> {x, y, z}\n"
"    {1, nil, nil}\n"
"\n"
"The left side supports any expression you would use\n"
"on the left side of a match:\n"
"\n"
"    x = 1\n"
"    destructure([^x, y, z], [1, 2, 3])\n"
"\n"
"The example above will only work if x matches\n"
"the first value from the right side. Otherwise,\n"
"it will raise a CaseClauseError.\n"
msgstr ""
"二つのリストを非構造化することを許し、\n"
"右のそれぞれのtermを左にマッチングするtermに代入します。\n"
"`=`によるパターンマッチングと違って、右と左のリストの大きさが\n"
"一致していなくても、エラーを上げるかわりに\n"
"処理を単に停止します。\n"
"\n"
"## 例\n"
"\n"
"    iex> destructure([x, y, z], [1, 2, 3, 4, 5])\n"
"    iex> {x, y, z}\n"
"    {1, 2, 3}\n"
"\n"
"上の例で、左より右のサイズが大きいにも拘わらず、\n"
"destructureは正しく動くことに注意してください。\n"
"もし右の大きさが小さいなら、残ったアイテムは単に\n"
"nilが代入されます:\n"
"\n"
"    iex> destructure([x, y, z], [1])\n"
"    iex> {x, y, z}\n"
"    {1, nil, nil}\n"
"\n"
"左側は、マッチの左辺で使うことができる、\n"
"任意の式をサポートします:\n"
"\n"
"    x = 1\n"
"    destructure([^x, y, z], [1, 2, 3])\n"
"\n"
"上の例は x が右側からの最初の値とマッチする場合のみ\n"
"動作します。さもなければCaseClauseErrorを上げます。\n"

#. TRANSLATORS: def Macro.update_meta(quoted, fun)
#: lib/macro.ex:115
msgid ""
"Applies the given function to the node metadata if it contains one.\n"
"\n"
"This is often useful when used with `Macro.prewalk/1` to remove\n"
"information like lines and hygienic counters from the expression\n"
"for either storage or comparison.\n"
"\n"
"## Examples\n"
"\n"
"    iex> quoted = quote line: 10, do: sample()\n"
"    {:sample, [line: 10], []}\n"
"    iex> Macro.update_meta(quoted, &Keyword.delete(&1, :line))\n"
"    {:sample, [], []}\n"
"\n"
msgstr ""
"メタデータを含んでいたら、ノードに与えられた関数を\n"
"適用します。\n"
"\n"
"これは、保管または比較の目的で、式から行番号と健全性カウンタの様な情報\n"
"を削除するために、`Macro.prewalk/1`を使うときに便利です。\n"
"\n"
"## 例\n"
"\n"
"    iex> quoted = quote line: 10, do: sample()\n"
"    {:sample, [line: 10], []}\n"
"    iex> Macro.update_meta(quoted, &Keyword.delete(&1, :line))\n"
"    {:sample, [], []}\n"
"\n"

#. TRANSLATORS: Elixir.Agent Summary
#: lib/agent.ex:1
msgid ""
"Agents are a simple abstraction around state.\n"
"\n"
"Often in Elixir there is a need to share or store state that\n"
"must be accessed from different processes or by the same process\n"
"at different points in time.\n"
"\n"
"The Agent module provides a basic server implementation that\n"
"allows state to be retrieved and updated via a simple API.\n"
"\n"
"## Examples\n"
"\n"
"For example, in the Mix tool that ships with Elixir, we need\n"
"to keep a set of all tasks executed by a given project. Since\n"
"this set is shared, we can implement it with an Agent:\n"
"\n"
"    defmodule Mix.TasksServer do\n"
"      def start_link do\n"
"        Agent.start_link(fn -> HashSet.new end, name: __MODULE__)\n"
"      end\n"
"\n"
"      @doc \"Checks if the task has already executed\"\n"
"      def executed?(task, project) do\n"
"        item = {task, project}\n"
"        Agent.get(__MODULE__, fn set ->\n"
"          item in set\n"
"        end)\n"
"      end\n"
"\n"
"      @doc \"Marks a task as executed\"\n"
"      def put_task(task, project) do\n"
"        item = {task, project}\n"
"        Agent.update(__MODULE__, &Set.put(&1, item))\n"
"      end\n"
"    end\n"
"\n"
"Note that agents still provide a segregation between the\n"
"client and server APIs, as seen in GenServers. In particular,\n"
"all code inside the function passed to the agent is executed\n"
"by the agent. This distinction is important because you may\n"
"want to avoid expensive operations inside the agent, as it will\n"
"effectively block the agent until the request is fulfilled.\n"
"\n"
"Consider these two examples:\n"
"\n"
"    # Compute in the agent/server\n"
"    def get_something(agent) do\n"
"      Agent.get(agent, fn state -> do_something_expensive(state) end)\n"
"    end\n"
"\n"
"    # Compute in the agent/client\n"
"    def get_something(agent) do\n"
"      Agent.get(agent, &(&1)) |> do_something_expensive()\n"
"    end\n"
"\n"
"The first one blocks the agent while the second one copies\n"
"all the state to the client and executes the operation in the client.\n"
"The trade-off here is exactly if the data is small enough to be\n"
"sent to the client cheaply or large enough to require processing on\n"
"the server (or at least some initial processing).\n"
"\n"
"## Name Registration\n"
"\n"
"An Agent is bound to the same name registration rules as GenServers.\n"
"Read more about it in the `GenServer` docs.\n"
"\n"
"## A word on distributed agents\n"
"\n"
"It is important to consider the limitations of distributed agents. Agents\n"
"provides two APIs, one that works with anonymous functions and another\n"
"that expects explicit module, function and arguments.\n"
"\n"
"In a distributed setup with multiple nodes, the API that accepts anonymous\n"
"functions only works if the caller (client) and the agent have the same\n"
"version of the caller module.\n"
"\n"
"Keep in mind this issue also shows up when performing \"rolling upgrades\"\n"
"with agents. By rolling upgrades we mean the following situation: you wish\n"
"to deploy a new version of your software by *shutting down* some of your\n"
"nodes and replacing them with nodes running a new version of the software.\n"
"In this setup, part of your environment will have one version of a given\n"
"module and the other part another version (the newer one) of the same "
"module.\n"
"\n"
"The best solution is to simply use the explicit module, function and "
"arguments\n"
"APIs when working with distributed agents.\n"
"\n"
"## Hot code swapping\n"
"\n"
"An agent can have its code hot swapped live by simply passing a module,\n"
"function and args tuple to the update instruction. For example, imagine\n"
"you have an agent named `:sample` and you want to convert its inner state\n"
"from some dict structure to a map. It can be done with the following\n"
"instruction:\n"
"\n"
"    {:update, :sample, {:advanced, {Enum, :into, [%{}]}}}\n"
"\n"
"The agent's state will be added to the given list as the first argument.\n"
msgstr ""
"Agentはステートまわりの単純な抽象です。\n"
"\n"
"Elixirではしばしば、異るプロセスから、または、異る時の同じ\n"
"プロセスにより、アクセスされなければならないステートを、\n"
"保存または共有する必要があります。\n"
"\n"
"Agentモジュールは、シンプルなAPIによりステートを取り出したり更新される\n"
"のを許す、基本的なサーバ実装を提供します。\n"
"\n"
"## 例\n"
"\n"
"例えば、Elixirに同梱されているMixツールでは、与えられたプロジェクトによ\n"
"り実行された全てのタスクの集合を、保持しておく必要があります。\n"
"この集合が共有されるので、それをAgentで実装できます:\n"
"\n"
"    defmodule Mix.TasksServer do\n"
"      def start_link do\n"
"        Agent.start_link(fn -> HashSet.new end, name: __MODULE__)\n"
"      end\n"
"\n"
"      @doc \"Checks if the task has already executed\"\n"
"      def executed?(task, project) do\n"
"        item = {task, project}\n"
"        Agent.get(__MODULE__, fn set ->\n"
"          item in set\n"
"        end)\n"
"      end\n"
"\n"
"      @doc \"Marks a task as executed\"\n"
"      def put_task(task, project) do\n"
"        item = {task, project}\n"
"        Agent.update(__MODULE__, &Set.put(&1, item))\n"
"      end\n"
"    end\n"
"\n"
"GenServerで見られるように、まだエージェントはクライアントとサーバAPIの\n"
"間で分離を提供する点に注意してください。特に、エージェントに渡される関\n"
"数の内側の全てのコードはエージェントによって実行されます。要求が満され\n"
"るまで、それがエージェントを効果的にブロックするため、高価なオペレーショ\n"
"ンを避けたいと、あなたは思うかもしれないので、この区別は重要です。\n"
"\n"
"二つの例を考えてみてください:\n"
"\n"
"    # Compute in the agent/server\n"
"    def get_something(agent) do\n"
"      Agent.get(agent, fn state -> do_something_expensive(state) end)\n"
"    end\n"
"\n"
"    # Compute in the agent/client\n"
"    def get_something(agent) do\n"
"      Agent.get(agent, &(&1)) |> do_something_expensive()\n"
"    end\n"
"\n"
"第2のものが全てのステートをクライアントへコピーして、\n"
"クライアントでオペレーションを実行する間、最初のものはエージェントを\n"
"ブロックします。\n"
"データが安くクライアントに送信されるのに十分に小さいか、\n"
"サーバで要求を処理(あるいは少なくとも初期処理)するのに十分に大きいかの、\n"
"これは正にトレードオフです。\n"
"\n"
"## Name Registration\n"
"\n"
"AgentはGenServerと同じ名前登録規則に束縛されます。\n"
"それについては`GenServer`のドキュメントを参照してください。\n"
"\n"
"## A word on distributed agents\n"
"\n"
"分散されたエージェントの制限を考慮することは重要です。Agentは、\n"
"二つのAPIを提供します。一つは無名関数で動くものと、もう一つは\n"
"明示的なモジュール、関数、引数を期待するものです。\n"
"\n"
"複数のノードによる分散セットアップにおいて、呼び出し側(クライアント)と\n"
"エージェントが呼び出し側と同じバージョンのモジュールをもっていれば、\n"
"そのときだけ、無名関数を受け付けるAPIは動作します。\n"
"\n"
"エージェントで\"ローリングアップグレード\"を実行する時にも、この問題が表\n"
"れることを心にとめておいてください。ローリングアップグレードにより、以\n"
"下のシチュエーションを意味しています:あなたは、ノードの幾つかを*シャッ\n"
"トダウン*して、ソフトウエアの新しいバージョンを走らせているノードと入れ\n"
"替えることによって、ソフトウエアの新しいバージョンをデプロイしたい。こ\n"
"のセットアップにおいて、あなたの環境の一部は与えられたモジュールの一つ\n"
"のバージョンを持ち、他の一部は、同じモジュールのもう一つのバージョン(よ\n"
"り新しいもの)を持ちます。\n"
"\n"
"最高の解決策は、単に、分散されたエージェントで動かすとき、明示的なモ\n"
"ジュール、関数、引数APIを使うことです。\n"
"\n"
"## Hot code swapping\n"
"\n"
"エージェントは、単にupdate命令にモジュール、関数、引数タプルを送ること\n"
"で、ホットコードスワッピングができます。例えば、`:sample`と名付けられた\n"
"エージェントを持っていて、その内部ステートのいくつかをdict構造から\n"
"mapへ変換したいとします。以下の命令でそれができます:\n"
"\n"
"    {:update, :sample, {:advanced, {Enum, :into, [%{}]}}}\n"
"\n"
"エージェントのステートは最初の引数として与えられたリストに\n"
"加えられます。\n"

#. TRANSLATORS: def GenEvent.add_handler(manager, handler, args)
#: lib/gen_event.ex:316
msgid ""
"Adds a new event handler to the event `manager`.\n"
"\n"
"The event manager will call the `init/1` callback with `args` to\n"
"initiate the event handler and its internal state.\n"
"\n"
"If `init/1` returns a correct value indicating successful completion,\n"
"the event manager adds the event handler and this function returns\n"
"`:ok`. If the callback fails with `reason` or returns `{:error, reason}`,\n"
"the event handler is ignored and this function returns `{:error, reason}`.\n"
"\n"
"If the given handler was previously installed at the manager, this\n"
"function returns `{:error, :already_present}`.\n"
msgstr ""
"イベント`manager`へ新しいイベントハンドラを追加します。\n"
"\n"
"イベントマネージャは、イベントハンドラと内部ステートの初期化を\n"
"するために、`args`で`init/1`コールバックを呼び出します。\"\n"
"\n"
"`init/1`が完全に成功したことを示す正しい値を返したら、イベント\n"
"マネージャはそのイベントハンドラを追加し、この関数は`:ok`を返します。\n"
"もしコールバックが`reason`で失敗したり、`{:error, reason}`を返したら、\n"
"イベントハンドラは無視され、この関数は`{:error, reason}`を返します。\n"
"\n"
"もし与えられたハンドラが、マネージャにより前にインストールされて\n"
"いたら、この関数は`{:error, :already_present}`を返します。\n"

#. TRANSLATORS: def GenEvent.add_mon_handler(manager, handler, args)
#: lib/gen_event.ex:361
msgid ""
"Adds a monitored event handler to the event `manager`.\n"
"\n"
"Expects the same input and returns the same values as `add_handler/3`.\n"
"\n"
"## Monitored handlers\n"
"\n"
"A monitored handler implies the calling process will now be monitored\n"
"by the GenEvent manager.\n"
"\n"
"If the calling process later terminates with `reason`, the event manager\n"
"will delete the event handler by calling the `terminate/2` callback with\n"
"`{:stop, reason}` as argument. If the event handler later is deleted,\n"
"the event manager sends a message `{:gen_event_EXIT, handler, reason}`\n"
"to the calling process. Reason is one of the following:\n"
"\n"
"  * `:normal` - if the event handler has been removed due to a call to\n"
"    `remove_handler/3`, or `:remove_handler` has been returned by a "
"callback\n"
"    function\n"
"\n"
"  * `:shutdown` - if the event handler has been removed because the event\n"
"    manager is terminating\n"
"\n"
"  * `{:swapped, new_handler, pid}` - if the process pid has replaced the\n"
"    event handler by another\n"
"\n"
"  * a term - if the event handler is removed due to an error. Which term\n"
"    depends on the error\n"
"\n"
"Keep in mind that the `{:gen_event_EXIT, handler, reason}` message is not\n"
"guaranteed to be delivered in case the manager crashes. If you want to\n"
"guarantee the message is delivered, you have two options:\n"
"\n"
"  * monitor the event manager\n"
"  * link to the event manager and then set `Process.flag(:trap_exit, true)`\n"
"    in your handler callback\n"
"\n"
"Finally, this functionality only works with GenEvent started via this\n"
"module (it is not backwards compatible with Erlang's `:gen_event`).\n"
msgstr ""
"モニタされたイベントハンドラをイベント`manager`に追加します。\n"
"\n"
"`add_handler/3`と同じ入力と戻値を期待します。\n"
"\n"
"## Monitored handlers\n"
"\n"
"呼出し側プロセスが現在、GenEventマネージャによりモニタされている\n"
"ことを、モニタされたハンドラは意味します。\n"
"\n"
"もし呼出し側プロセスが後で`reason`で終了したら、イベントマネージャは、\n"
"引数として`{:stop, reason}`とともに、`terminate/2`コールバックを\n"
"呼び出すことにより、イベントハンドラを削除します。\n"
"\n"
"もしイベントハンドラが後で削除されたら、イベントマネージャは、\n"
"`{:gen_event_EXIT,handler, reason}`メッセージを、呼出し側プロセス\n"
"へ送信します。reasonは以下のいずれかです:\n"
"\n"
"  * `:normal` - イベントハンドラが、`remove_handler/3`の呼び出しにより\n"
"     削除されたか、あるいは、コールバック関数により、`:remove_handler`が\n"
"     戻されたか\n"
"\n"
"  * `:shutdown` - イベントマネージャが終了したことによりイベント\n"
"     ハンドラが削除された\n"
"\n"
"  * `{:swapped, new_handler, pid}` - 他のプロセスにより、イベント\n"
"     ハンドラのpidが置き換えられた\n"
"\n"
"  * a term - エラーによりイベントハンドラが削除された。termは\n"
"    エラーに依ります。\n"
"\n"
"マネージャがクラッシュする場合に、`{:gen_event_EXIT, handler, reason}`\n"
"メッセージが、届けられる保証がないことを、心にとめてください。\n"
"もしメッセージが届けられることを保証したいなら、二つのオプションが\n"
"あります:\n"
"\n"
"  * イベントマネージャをモニタします\n"
"  * イベントマネージャをリンクし、ハンドラコールバックで、\n"
"    `Process.flag(:trap_exit, true)`をセットします\n"
"\n"
"最後に、この機能は、このモジュールにより開始されるGenEventでのみ\n"
"動作します(Erlangの`:gen_event`との後方互換性はありません)。\n"

#. TRANSLATORS: def container[key]
#: lib/access.ex:33
msgid "Accesses the given key in the container.\n"
msgstr "コンテナに与えられたキーでアクセスします。\n"

#. TRANSLATORS: defmacro Kernel.to_string(arg)
#: lib/kernel.ex:1861
msgid ""
"Converts the argument to a string according to the\n"
"`String.Chars` protocol.\n"
"\n"
"This is the function invoked when there is string interpolation.\n"
"\n"
"## Examples\n"
"\n"
"    iex> to_string(:foo)\n"
"    \"foo\"\n"
"\n"
msgstr ""
"`String.Chars`プロトコルに従って、引数を文字列に変換します。\n"
"\n"
"これは、文字列展開がある時、起動される関数です。\n"
"\n"
"## 例\n"
"\n"
"    iex> to_string(:foo)\n"
"    \"foo\"\n"
"\n"

#. TRANSLATORS: defmacro Kernel.to_char_list(arg)
#: lib/kernel.ex:1876
msgid ""
"Converts the argument to a list according to the List.Chars protocol.\n"
"\n"
"## Examples\n"
"\n"
"    iex> to_char_list(:foo)\n"
"    'foo'\n"
"\n"
msgstr ""
"引数をList.Charsプロトコルに従って、リストに変換します。\n"
"\n"
"## 例\n"
"\n"
"    iex> to_char_list(:foo)\n"
"    'foo'\n"
"\n"

#. TRANSLATORS: def Set.to_list(set)
#: lib/set.ex:293
msgid ""
"Converts `set` to a list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> set_impl.to_list(Enum.into([1, 2, 3], set_impl.new)) |> Enum.sort\n"
"    [1,2,3]\n"
"\n"
msgstr ""
"`set`をリストに変換します。\n"
"\n"
"## 例\n"
"\n"
"    iex> set_impl.to_list(Enum.into([1, 2, 3], set_impl.new)) |> Enum.sort\n"
"    [1,2,3]\n"
"\n"

#. TRANSLATORS: def Enum.to_list(collection)
#: lib/enum.ex:1958
msgid ""
"Converts `collection` to a list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.to_list(1 .. 3)\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
"`collection`をリストに変換します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.to_list(1 .. 3)\n"
"    [1, 2, 3]\n"
"\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.^(var)
#: lib/kernel/special_forms.ex:642
msgid ""
"Accesses an already bound variable in match clauses.\n"
"\n"
"## Examples\n"
"\n"
"Elixir allows variables to be rebound via static single assignment:\n"
"\n"
"    iex> x = 1\n"
"    iex> x = 2\n"
"    iex> x\n"
"    2\n"
"\n"
"However, in some situations, it is useful to match against an existing\n"
"value, instead of rebinding. This can be done with the `^` special form:\n"
"\n"
"    iex> x = 1\n"
"    iex> ^x = List.first([1])\n"
"    iex> ^x = List.first([2])\n"
"    ** (MatchError) no match of right hand side value: 2\n"
"\n"
"Note that `^` always refers to the value of x prior to the match. The\n"
"following example will match:\n"
"\n"
"    iex> x = 0\n"
"    iex> {x, ^x} = {1, 0}\n"
"    iex> x\n"
"    1\n"
"\n"
msgstr ""
"マッチ節で既に束縛された変数へアクセスします。\n"
"\n"
"## 例\n"
"\n"
"Elixirは、静的な単一代入によって、変数の再束縛を許します:\n"
"\n"
"    iex> x = 1\n"
"    iex> x = 2\n"
"    iex> x\n"
"    2\n"
"\n"
"しかしながら、いくつかのシチュエーションでは、再束縛するかわりに、\n"
"既存の値に対してマッチすることが便利です。これは`^`スペシャルフォームで\n"
"できます:\n"
"\n"
"    iex> x = 1\n"
"    iex> ^x = List.first([1])\n"
"    iex> ^x = List.first([2])\n"
"    ** (MatchError) no match of right hand side value: 2\n"
"\n"
"`^`が常にマッチの前にxの値を参照することに、注意してください。\n"
"下の例のようにマッチします:\n"
"\n"
"    iex> x = 0\n"
"    iex> {x, ^x} = {1, 0}\n"
"    iex> x\n"
"    1\n"
"\n"

#. TRANSLATORS: def Module.add_doc(module, line, kind, tuple, signature \\ [], doc)
#: lib/module.ex:498
msgid ""
"Attaches documentation to a given function or type. It expects\n"
"the module the function/type belongs to, the line (a non negative\n"
"integer), the kind (`def` or `defmacro`), a tuple representing\n"
"the function and its arity, the function signature (the signature\n"
"should be omitted for types) and the documentation, which should\n"
"be either a binary or a boolean.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule MyModule do\n"
"      Module.add_doc(__MODULE__, __ENV__.line + 1, :def, {:version, 0}, [], "
"\"Manually added docs\")\n"
"      def version, do: 1\n"
"    end\n"
"\n"
msgstr ""
"与えられた関数あるいはタイプにドキュメントをアタッチします。\n"
"\n"
"関数/タイプが属しているモジュール、行(非負の整数)、種類(`def`か"
"`defmacro`)、\n"
"関数とアリティのタプル表現、関数のシグネチャ(シグネチャはタイプでは\n"
"省略されなければなりません)、そしてドキュメント(それはバイナリかブーリアン\n"
"でなければなりません)を期待します。\n"
"\n"
"## 例\n"
"\n"
"    defmodule MyModule do\n"
"      Module.add_doc(__MODULE__, __ENV__.line + 1, :def, {:version, 0}, [], "
"\"Manually added docs\")\n"
"      def version, do: 1\n"
"    end\n"
"\n"

#. TRANSLATORS: def Node.monitor(node, flag, options)
#: lib/node.ex:103
msgid ""
"Behaves as `monitor/2` except that it allows an extra\n"
"option to be given, namely `:allow_passive_connect`.\n"
"\n"
"See http://www.erlang.org/doc/man/erlang.html#monitor_node-3 for more info.\n"
msgstr ""
"特別なオプション`:allow_passive_connect`を与えることが\n"
"できる以外は、`monitor/2`として振る舞います。\n"
"\n"
"詳細は、\n"
"http://www.erlang.org/doc/man/erlang.html#monitor_node-3 \n"
"を参照してください。\n"

#. TRANSLATORS: def Task.await(task, timeout \\ 5000)
#: lib/task.ex:194
msgid ""
"Awaits a task reply.\n"
"\n"
"A timeout, in milliseconds, can be given with default value\n"
"of `5000`. In case the task process dies, this function will\n"
"exit with the same reason as the task.\n"
msgstr ""
"タスクの応答を待ちます。\n"
"\n"
"タイムアウト(ミリ秒)を与えることができ、デフォルト値は`5000`です。\n"
"タスクプロセスが死んだ場合、この関数は、\n"
"そのタスクと同じreasonでexitします。\n"

#. TRANSLATORS: @type t
#: lib/macro.ex:0
msgid "Abstract Syntax Tree (AST)"
msgstr "抽象構文木(AST)"

#. TRANSLATORS: Elixir.Task.Supervisor Summary
#: lib/task/supervisor.ex:1
msgid ""
"A tasks supervisor.\n"
"\n"
"This module defines a supervisor which can be used to dynamically\n"
"supervise tasks. Behind the scenes, this module is implemented as a\n"
"`:simple_one_for_one` supervisor where the workers are temporary\n"
"(i.e. they are not restarted after they die).\n"
"\n"
"The functions in this module allow tasks to be spawned and awaited\n"
"from a supervisor, similar to the functions defined in the `Task` module.\n"
"\n"
"## Name Registration\n"
"\n"
"A `Task.Supervisor` is bound to the same name registration rules as a\n"
"`GenServer`. Read more about it in the `GenServer` docs.\n"
msgstr ""
"タスクスーパバイザです。\n"
"\n"
"このモジュールは、動的にタスクをスーパバイズする\n"
"ために使うことができる、スーパバイザを定義します。\n"
"\n"
"舞台裏では、このモジュールは、ワーカがtemporaryの\n"
"`:simple_one_for_one`スーパバイザとして実装されます(即ち、ワーカが死ん\n"
"でも再起動されません)。\n"
"\n"
"`Task`モジュールで定義された関数と似て、\n"
"このモジュールの関数はスーパバイザからタスクを生成し、待つことを\n"
"許します。\n"
"\n"
"## 名前の登録\n"
"\n"
"`Task.Supervisor`は`GenServer`と同じ名前登録規則に従います。\n"
"それについてはの詳細は、`GenServer`のドキュメントを参照してください。\n"

#. TRANSLATORS: Elixir.Macro.Env Summary
#: lib/macro/env.ex:1
msgid ""
"A struct that holds compile time environment information.\n"
"\n"
"The current environment can be accessed at any time as\n"
"`__ENV__`. Inside macros, the caller environment can be\n"
"accessed as `__CALLER__`.\n"
"\n"
"An instance of `Macro.Env` must not be modified by hand. If you need to\n"
"create a custom environment to pass to `Code.eval_quoted/3`, use the\n"
"following trick:\n"
"\n"
"    def make_custom_env do\n"
"      import SomeModule, only: [some_function: 2]\n"
"      alias A.B.C\n"
"      __ENV__\n"
"    end\n"
"\n"
"You may then call `make_custom_env()` to get a struct with the desired\n"
"imports and aliases included.\n"
"\n"
"It contains the following fields:\n"
"\n"
"  * `module` - the current module name\n"
"  * `file` - the current file name as a binary\n"
"  * `line` - the current line as an integer\n"
"  * `function` - a tuple as `{atom, integer`}, where the first\n"
"    element is the function name and the seconds its arity; returns\n"
"    `nil` if not inside a function\n"
"  * `context` - the context of the environment; it can be `nil`\n"
"    (default context), inside a guard or inside an assign\n"
"  * `aliases` -  a list of two item tuples, where the first\n"
"    item is the aliased name and the second the actual name\n"
"  * `requires` - the list of required modules\n"
"  * `functions` - a list of functions imported from each module\n"
"  * `macros` - a list of macros imported from each module\n"
"  * `macro_aliases` - a list of aliases defined inside the current macro\n"
"  * `context_modules` - a list of modules defined in the current context\n"
"  * `vars` - a list keeping all defined variables as `{var, context}`\n"
"  * `export_vars` - a list keeping all variables to be exported in a\n"
"    construct (may be `nil`)\n"
"  * `lexical_tracker` - PID of the lexical tracker which is responsible to\n"
"    keep user info\n"
"  * `local` - the module to expand local functions to\n"
msgstr ""
"コンパイル時の環境情報を保持する構造体です。\n"
"\n"
"現在の環境は`__ENV__`として何時でもアクセスできます。\n"
"マクロの内側では、呼出し側環境は`__CALLER__`としてアクセス\n"
"できます。\n"
"\n"
"`Macro.Env`のインスタンスは手で変更してはいけません。もし\n"
"カスタム環境を作る必要があれば、以下のトリックを使って、\n"
"`Code.eval_quoted/3`へ渡してください:\n"
"\n"
"    def make_custom_env do\n"
"      import SomeModule, only: [some_function: 2]\n"
"      alias A.B.C\n"
"      __ENV__\n"
"    end\n"
"\n"
"要求されたimportとaliasを含んだ構造を取得するtめに、\n"
"`make_custom_env()`を呼べます。\n"
"\n"
"以下のフィールドを含んでいます:\n"
"\n"
"  * `module` - 現在のモジュール名\n"
"  * `file` -  バイナリとしての現在のファイル名\n"
"  * `line` -  整数としての現在の行番号\n"
"  * `function` - `{atom, integer}`としてのタプルで\n"
"     最初の要素は関数名で二つめはアリティ; 関数の内部でないならnil\n"
"  * `context` - 環境のコンテキスト; `nil`(デフォルトコンテキスト)、\n"
"     ガードの内側か、代入の内側\n"
"  * `aliases` -  2アイテムのタプルのリストで、最初のアイテムは\n"
"     エイリアスの名前、二つめは実際の名前\n"
"  * `requires` - requireされたモジュールのリスト\n"
"  * `functions` - それぞれのモジュールからimportされた関数のリスト\n"
"  * `macros` - それぞれのモジュールからimportされたマクロのリスト\n"
"  * `macro_aliases` - 現在のマクロの内側で定義されたエイリアスのリスト\n"
"  * `context_modules` - 現在のコンテキストで定義されたモジュールのリスト\n"
"  * `vars` - `{var, context}`として定義された全ての変数を保持したリスト\n"
"  * `export_vars` - constructでexportされた全ての変数を保持したリスト\n"
"     (`nil`の場合もあります)\n"
"  * `lexical_tracker` - ユーザ情報を保つために責任があるレキシカル\n"
"     トラッカーのpid\n"
"  * `local` - ローカル関数を拡大するモジュール\n"

#. TRANSLATORS: Elixir.File.Stat Summary
#: lib/file/stat.ex:3
msgid ""
"A struct responsible to hold file information.\n"
"\n"
"In Erlang, this struct is represented by a `:file_info` record.\n"
"Therefore this module also provides functions for converting\n"
"in between the Erlang record and the Elixir struct.\n"
"\n"
"Its fields are:\n"
"\n"
"  * `size` - size of file in bytes.\n"
"\n"
"  * `type` - `:device | :directory | :regular | :other`; the type of the\n"
"    file.\n"
"\n"
"  * `access` - `:read | :write | :read_write | :none`; the current system\n"
"    access to the file.\n"
"\n"
"  * `atime` - the last time the file was read.\n"
"\n"
"  * `mtime` - the last time the file was written.\n"
"\n"
"  * `ctime` - the interpretation of this time field depends on the "
"operating\n"
"    system. On Unix, it is the last time the file or the inode was changed.\n"
"    In Windows, it is the time of creation.\n"
"\n"
"  * `mode` - the file permissions.\n"
"\n"
"  * `links` - the number of links to this file. This is always 1 for file\n"
"    systems which have no concept of links.\n"
"\n"
"  * `major_device` - identifies the file system where the file is located.\n"
"    In windows, the number indicates a drive as follows: 0 means A:, 1 "
"means\n"
"    B:, and so on.\n"
"\n"
"  * `minor_device` - only valid for character devices on Unix. In all other\n"
"    cases, this field is zero.\n"
"\n"
"  * `inode` - gives the inode number. On non-Unix file systems, this field\n"
"    will be zero.\n"
"\n"
"  * `uid` - indicates the owner of the file.\n"
"\n"
"  * `gid` - gives the group that the owner of the file belongs to. Will be\n"
"    zero for non-Unix file systems.\n"
"\n"
"The time type returned in `atime`, `mtime`, and `ctime` is dependent on the\n"
"time type set in options. `{:time, type}` where type can be `:local`,\n"
"`:universal`, or `:posix`. Default is `:local`.\n"
msgstr ""
"ファイル情報を保持することに責任を果す構造体です。\n"
"\n"
"Erlangでは、この構造体は`:file_info`レコードによって表現されています。\n"
"従って、このモジュールは、ErlangレコードとElixir構造体の間を変関する関\n"
"数も提供します。\n"
"\n"
"フィールドは以下の通りです:\n"
"\n"
"  * `size` - バイト単位でのファイルの大きさ\n"
"\n"
"  * `type` - `:device | :directory | :regular | :other`; ファイルのタイプ\n"
"\n"
"  * `access` - `:read | :write | :read_write | :none`; \n"
"    現在のシステムがファイルにアクセスする仕方\n"
"\n"
"  * `atime` - 最後にファイルが読まれた時刻\n"
"\n"
"  * `mtime` - 最後にファイルが書かれた時刻\n"
"\n"
"  * `ctime` - この時刻フィールドの解釈はオペレーティングシステムに依存しま"
"す。\n"
"    Unixでは、ファイルまたはそのinodeが変更された最後の時刻です。\n"
"    Windowsでは、作成された時刻です。\n"
"\n"
"  * `mode` - ファイルのパーミッション\n"
"\n"
"  * `links` - このファイルのリンクの数です。リンクの概念がない\n"
"    ファイルシステムでは通常1です。\n"
"\n"
"  * `major_device` - ファイルが置かれているファイルシステムの識別子です。\n"
"    Windowsでは、数字は次のようにドライブを指定します; 0 は A:, 1 は B:, 等\n"
"\n"
"  * `minor_device` - Unixのキャラクタデバイスでのみ有効です。他の場合、\n"
"     このフィールドは0です。\n"
"\n"
"  * `inode` - inode番号です。非Unixファイルシステムでは、このフィールドは\n"
"     0になるでしょう。\n"
"\n"
"  * `uid` - ファイルの所有者を示します。\n"
"\n"
"  * `gid` - ファイルの所有者が属しているグループを与えます。\n"
"    非Unixファイルシステムでは0になるでしょう。\n"
"\n"
"`atime`, `mtime`, `ctime`で返される時刻タイプは、オプションで\n"
"セットされる時刻タイプに依存しています。`{:time, type}`において、\n"
"typeは`:local`、`:universal`あるいは、`:posix`をとることができます。\n"
"デフォルトは`:local`です。\n"

#. TRANSLATORS: Elixir.HashSet Summary
#: lib/hash_set.ex:1
msgid ""
"A set store.\n"
"\n"
"The `HashSet` is represented internally as a struct, therefore\n"
"`%HashSet{}` can be used whenever there is a need to match\n"
"on any `HashSet`. Note though the struct fields are private and\n"
"must not be accessed directly. Instead, use the functions on this\n"
"or in the `Set` module.\n"
"\n"
"The `HashSet` is implemented using tries, which grows in\n"
"space as the number of keys grows, working well with both\n"
"small and large set of keys. For more information about the\n"
"functions and their APIs, please consult the `Set` module.\n"
msgstr ""
"集合ストアです。\n"
"\n"
"`HashSet`は内部的には構造体として表現されています、従って、\n"
"任意の`HashSet`にマッチする必要があるときは何時でも、`%HashSet{}`が\n"
"使えます。\n"
"しかし構造体のフィールドはプライベートで\n"
"直接アクセスしてはならないことに、気を付けてください。\n"
"かわりに、このモジュールか、あるいは`Set`モジュールの関数を使ってください。\n"
"\n"
"`HashSet`は、キーの数の増大にしたがってスペースも増大し、\n"
"キーが少くても多くても、よく動作するように実装されています。\n"
"関数とAPIの詳細は、`Set`モジュールを参照してください。\n"

#. TRANSLATORS: Elixir.Inspect.Algebra Summary
#: lib/inspect/algebra.ex:58
msgid ""
"A set of functions for creating and manipulating algebra\n"
"documents, as described in [\"Strictly Pretty\" (2000) by Christian Lindig]"
"[0].\n"
"\n"
"An algebra document is represented by an `Inspect.Algebra` node\n"
"or a regular string.\n"
"\n"
"    iex> Inspect.Algebra.empty\n"
"    :doc_nil\n"
"\n"
"    iex> \"foo\"\n"
"    \"foo\"\n"
"\n"
"With the functions in this module, we can concatenate different\n"
"elements together and render them:\n"
"\n"
"    iex> doc = Inspect.Algebra.concat(Inspect.Algebra.empty, \"foo\")\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"foo\"]\n"
"\n"
"The functions `nest/2`, `space/2` and `line/2` help you put the\n"
"document together into a rigid structure. However, the document\n"
"algebra gets interesting when using functions like `break/2`, which\n"
"converts the given string into a line break depending on how much space\n"
"there is to print. Let's glue two docs together with a break and then\n"
"render it:\n"
"\n"
"    iex> doc = Inspect.Algebra.glue(\"a\", \" \", \"b\")\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"a\", \" \", \"b\"]\n"
"\n"
"Notice the break was represented as is, because we haven't reached\n"
"a line limit. Once we do, it is replaced by a newline:\n"
"\n"
"    iex> doc = Inspect.Algebra.glue(String.duplicate(\"a\", 20), \" \", \"b"
"\")\n"
"    iex> Inspect.Algebra.format(doc, 10)\n"
"    [\"aaaaaaaaaaaaaaaaaaaa\", \"\\n\", \"b\"]\n"
"\n"
"Finally, this module also contains Elixir related functions, a bit\n"
"tied to Elixir formatting, namely `surround/3` and `surround_many/5`.\n"
"\n"
"## Implementation details\n"
"\n"
"The original Haskell implementation of the algorithm by [Wadler][1]\n"
"relies on lazy evaluation to unfold document groups on two alternatives:\n"
"`:flat` (breaks as spaces) and `:break` (breaks as newlines).\n"
"Implementing the same logic in a strict language such as Elixir leads\n"
"to an exponential growth of possible documents, unless document groups\n"
"are encoded explictly as `:flat` or `:break`. Those groups are then reduced\n"
"to a simple document, where the layout is already decided, per [Lindig][0].\n"
"\n"
"This implementation slightly changes the semantic of Lindig's algorithm\n"
"to allow elements that belong to the same group to be printed together\n"
"in the same line, even if they do not fit the line fully. This was achieved\n"
"by changing `:break` to mean a possible break and `:flat` to force a flat\n"
"structure. Then deciding if a break works as a newline is just a matter\n"
"of checking if we have enough space until the next break that is not\n"
"inside a group (which is still flat).\n"
"\n"
"Custom pretty printers can be implemented using the documents returned\n"
"by this module and by providing their own rendering functions.\n"
"\n"
"  [0]: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.2200\n"
"  [1]: http://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf\n"
"\n"
msgstr ""
"[\"Strictly Pretty\" (2000) by Christian Lindig][0]で記述された、\n"
"代数学的ドキュメントを作成、操作するための一組の関数です。\n"
"\n"
"代数学的ドキュメントは、\n"
"`Inspect.Algebra`ノードか標準の文字列により表現されます。\n"
"\n"
"    iex> Inspect.Algebra.empty\n"
"    :doc_nil\n"
"\n"
"    iex> \"foo\"\n"
"    \"foo\"\n"
"\n"
"このモジュールの関数で、ころなる要素を一緒に連結したり、レンダリング\n"
"できます:\n"
"\n"
"    iex> doc = Inspect.Algebra.concat(Inspect.Algebra.empty, \"foo\")\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"foo\"]\n"
"\n"
"`nest/2`、`space/2`、`line/2`関数は、\n"
"あなたが堅い構造にドキュメントをまとめるのを助けます。\n"
"しかしながら、`break/2`のような関数を使用するとき、\n"
"ドキュメント代数は面白くなります。そしてこのスペースが\n"
"どのくらい印字することになっているかに依存して、与えられた\n"
"文字列に改行を入れ、変換します。\n"
"breakとともに二つのドキュメントを接着し、それからそれをレンダリング\n"
"してみましょう:\n"
"\n"
"    iex> doc = Inspect.Algebra.glue(\"a\", \" \", \"b\")\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"a\", \" \", \"b\"]\n"
"\n"
"breakはそのまま表現されたことに注意してください。というのは、\n"
"行制限に達していなかったからです。もう一度、こんどは改行で置き換えられます:\n"
"\n"
"    iex> doc = Inspect.Algebra.glue(String.duplicate(\"a\", 20), \" \", \"b"
"\")\n"
"    iex> Inspect.Algebra.format(doc, 10)\n"
"    [\"aaaaaaaaaaaaaaaaaaaa\", \"\\n\", \"b\"]\n"
"\n"
"最後に、このモジュールはElixir関連の関数も含みます。Elixirのフォーマッ\n"
"トと結び付く、`surround/3`と`surround_many/5`といった名前の若干の関数で\n"
"す。\n"
"\n"
"## 実装の詳細\n"
"\n"
"[Wadler][1]によるアルゴリズムのオリジナルのHaskel実装は、二つの選択肢の\n"
"上でドキュメントグループを展開するために遅延評価に頼っています:\n"
"`:flat`(スペースとしてbreak)と`:break`(改行としてbreak)。ドキュメントグ\n"
"ループが`:flat`か`:break`として明示的にエンコードされていない限り、\n"
"Elixirのようなstrictな言語で同じロジックを実装することは可能性のあるド\n"
"キュメントの指数関数的成長に至ります。それらのグループは、それから、レ\n"
"イアウトはすでに[Lindig][0] によって決定されている、単一のドキュメント\n"
"に簡約されます。\n"
"\n"
"例えそれらが完全にはラインに合わないにしても、同じグループに属する要素\n"
"を、同じラインで印字されることを許すために、この実装は、Lindingのアルゴ\n"
"リズムの意味論を僅かに変ました。\n"
"これは有り得るbreakを意味するように`:break`を変更し、\n"
"`:flat`はフラットな構造を強制することを意味するよう変更することで、\n"
"達成されました。\n"
"それから、breakという単語が改行として働くかどうかについて決めることが、\n"
"ちょうどグループ(まだflat)の中にない、次のbreakまで十分なスペースを\n"
"もっているかどうかのチェックの問題です。\n"
"\n"
"このモジュールで返されるドキュメントを使って、そして、彼ら自身のレンダ\n"
"リング関数を提供することにより、カスタムのプリティプリンタを実装するこ\n"
"とができます。\n"
"\n"
"  [0]: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.2200\n"
"  [1]: http://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf\n"
"\n"

#. TRANSLATORS: Elixir.Range.Iterator Summary
#: lib/range.ex:47
msgid "A protocol used for iterating range elements.\n"
msgstr "範囲(range)の要素の繰返しのために使われるプロトコルです。\n"

#. TRANSLATORS: Elixir.Collectable Summary
#: lib/collectable.ex:1
msgid ""
"A protocol to traverse data structures.\n"
"\n"
"The `Enum.into/2` function uses this protocol to insert an\n"
"enumerable into a collection:\n"
"\n"
"    iex> Enum.into([a: 1, b: 2], %{})\n"
"    %{a: 1, b: 2}\n"
"\n"
"## Why Collectable?\n"
"\n"
"The `Enumerable` protocol is useful to take values out of a collection.\n"
"In order to support a wide range of values, the functions provided by\n"
"the `Enumerable` protocol do not keep shape. For example, passing a\n"
"dictionary to `Enum.map/2` always returns a list.\n"
"\n"
"This design is intentional. `Enumerable` was designed to support infinite\n"
"collections, resources and other structures with fixed shape. For example,\n"
"it doesn't make sense to insert values into a range, as it has a fixed\n"
"shape where just the range limits are stored.\n"
"\n"
"The `Collectable` module was designed to fill the gap left by the\n"
"`Enumerable` protocol. `into/1` can be seen as the opposite of\n"
"`Enumerable.reduce/3`. If `Enumerable` is about taking values out,\n"
"`Collectable.into/1` is about collecting those values into a structure.\n"
msgstr ""
"データ構造をトラバースするプロトコルです。\n"
"\n"
"`Enum.into/2`関数は、コレクションにenumerableを挿入するために、\n"
"このプロトコルを使います:\n"
"\n"
"    iex> Enum.into([a: 1, b: 2], %{})\n"
"    %{a: 1, b: 2}\n"
"\n"
"## Why Collectable?\n"
"\n"
"`Enumerable`プロトコルはコレクションから値を取り出すのに役立ちます。\n"
"広範囲にわたる値をサポートするために、\n"
"`Enumerable`プロトコルによって提供される関数は、形を持ちません。\n"
"例えば、`Enum.map/2`に辞書を渡すことは、常にリストを返します。\n"
"\n"
"このデザインは意図的です。\n"
"`Enumerable`は、一定の形で、無限のコレクション、リソース、\n"
"その他の構造をサポートするためにデザインさました。例えば、\n"
"それだけで範囲の制限が格納されている固定された形状しているので、\n"
"範囲に値を挿入しても意味をなしません。\n"
"\n"
"`Collectable`モジュールは`Enumerable`による残りのギャップを\n"
"埋めるためにデザインされました。それは二つの関数を提供します:\n"
"`into/1`と`empty/1`です。\n"
"\n"
"`into/1`は`Enumerable.reduce/3`の正反対と見做すことができます。\n"
"`Enumerable`が値の取り出しなら、`Collectable.into/1`は\n"
"値を構造に収集することです。\n"

#. TRANSLATORS: @type continuation
#: lib/enum.ex:0
msgid ""
"A partially applied reduce function.\n"
"\n"
"The continuation is the closure returned as a result when\n"
"the enumeration is suspended. When invoked, it expects\n"
"a new accumulator and it returns the result.\n"
"\n"
"A continuation is easily implemented as long as the reduce\n"
"function is defined in a tail recursive fashion. If the function\n"
"is tail recursive, all the state is passed as arguments, so\n"
"the continuation would simply be the reducing function partially\n"
"applied.\n"
msgstr ""
"reduce関数の部分適用です。\n"
"\n"
"継続は数え上げ(enumeration)が中断(suspended)された時に結果\n"
"として返されるクロージャです。起動されるとき、新しいアキュ\n"
"ムレータを期待して、結果を返します。\n"
"\n"
"継続はreduce関数が末尾再帰様式で定義されているかぎり、韓単\n"
"に実装されます。もし関数が末尾再帰なら、全てのステートは引\n"
"数としてパスされ、継続は単に部分的に適用されるreduce関数に\n"
"なるでしょう。"

#. TRANSLATORS: def Range.range?(range)
#: lib/range.ex:43
msgid ""
"Returns true if the given argument is a range.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Range.range?(1..3)\n"
"    true\n"
"\n"
"    iex> Range.range?(0)\n"
"    false\n"
"\n"
msgstr ""
"与えられた引数が範囲(range)ならtrueを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Range.range?(1..3)\n"
"    true\n"
"\n"
"    iex> Range.range?(0)\n"
"    false\n"
"\n"

#. TRANSLATORS: def Regex.scan(regex, string, options \\ [])
#: lib/regex.ex:316
msgid ""
"Same as `run/3`, but scans the target several times collecting all\n"
"matches of the regular expression. A list of lists is returned,\n"
"where each entry in the primary list represents a match and each\n"
"entry in the secondary list represents the captured contents.\n"
"\n"
"## Options\n"
"\n"
"  * `:return`  - set to `:index` to return indexes. Defaults to `:binary`.\n"
"  * `:capture` - what to capture in the result. Check the moduledoc for "
"`Regex`\n"
"                 to see the possible capture values.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.scan(~r/c(d|e)/, \"abcd abce\")\n"
"    [[\"cd\", \"d\"], [\"ce\", \"e\"]]\n"
"\n"
"    iex> Regex.scan(~r/c(?:d|e)/, \"abcd abce\")\n"
"    [[\"cd\"], [\"ce\"]]\n"
"\n"
"    iex> Regex.scan(~r/e/, \"abcd\")\n"
"    []\n"
"\n"
msgstr ""
"`run/3`と同じですが、正規表現にマッチしたもの全てを集めるため何回かスキャ\n"
"ンします。\n"
"\n"
"それぞれのリストの最初の要素はマッチを表現し、それぞれのリストの次の要\n"
"素はキャプチャされたコンテンツを表現する、リストのリストを返します。\n"
"\n"
"\n"
"## オプション\n"
"\n"
"  * `:return`  - `:index`をセットするとindexを返します。デフォルト\n"
"                 は`:binary`です。\n"
"  * `:capture` - 結果にキャプチャを含めます。可能なキャプチャの値\n"
"                 を見るために`Regex`のドキュメントをチェックしてください。\n"
"\n"
"## 例\n"
"\n"
"    iex> Regex.scan(~r/c(d|e)/, \"abcd abce\")\n"
"    [[\"cd\", \"d\"], [\"ce\", \"e\"]]\n"
"\n"
"    iex> Regex.scan(~r/c(?:d|e)/, \"abcd abce\")\n"
"    [[\"cd\"], [\"ce\"]]\n"
"\n"
"    iex> Regex.scan(~r/e/, \"abcd\")\n"
"    []\n"
"\n"

#. TRANSLATORS: def Regex.regex?(regex)
#: lib/regex.ex:176
msgid ""
"Returns true if the given argument is a regex.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.regex?(~r/foo/)\n"
"    true\n"
"\n"
"    iex> Regex.regex?(0)\n"
"    false\n"
"\n"
msgstr ""
"与えられた引数が正規表現ならtrueを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Regex.regex?(~r/foo/)\n"
"    true\n"
"\n"
"    iex> Regex.regex?(0)\n"
"    false\n"
"\n"

#. TRANSLATORS: def String.rstrip(string, char)
#: lib/string.ex:472
msgid ""
"Returns a string where trailing `char` have been removed.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.rstrip(\"   abc _\", ?_)\n"
"    \"   abc \"\n"
"\n"
msgstr ""
"末尾の`char`を取り除いた文字列を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.rstrip(\"   abc _\", ?_)\n"
"    \"   abc \"\n"
"\n"

#. TRANSLATORS: def String.rstrip(binary)
#: lib/string.ex:459
msgid ""
"Returns a string where trailing Unicode whitespace\n"
"has been removed.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.rstrip(\"   abc  \")\n"
"    \"   abc\"\n"
"\n"
msgstr ""
"末尾のUnicodeのホワイトスペース文字を取り除いた文字列を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.rstrip(\"   abc  \")\n"
"    \"   abc\"\n"
"\n"

#. TRANSLATORS: def String.strip(string, char)
#: lib/string.ex:561
msgid ""
"Returns a string where leading/trailing `char` have been\n"
"removed.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.strip(\"a  abc  a\", ?a)\n"
"    \"  abc  \"\n"
"\n"
msgstr ""
"先頭、末尾の`char`を取り除いた文字列を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.strip(\"a  abc  a\", ?a)\n"
"    \"  abc  \"\n"
"\n"

#. TRANSLATORS: def String.strip(string)
#: lib/string.ex:545
msgid ""
"Returns a string where leading/trailing Unicode whitespace\n"
"has been removed.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.strip(\"   abc  \")\n"
"    \"abc\"\n"
"\n"
msgstr ""
"先頭、末尾のUnicodeホワイトスペース文字を取り除いた文字列を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.strip(\"   abc  \")\n"
"    \"abc\"\n"
"\n"

#. TRANSLATORS: def String.lstrip(other, char)
#: lib/string.ex:525
msgid ""
"Returns a string where leading `char` have been removed.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.lstrip(\"_  abc  _\", ?_)\n"
"    \"  abc  _\"\n"
"\n"
msgstr ""
"先頭の`char`を取り除いた文字列を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.lstrip(\"_  abc  _\", ?_)\n"
"    \"  abc  _\"\n"
"\n"

#. TRANSLATORS: def String.lstrip(binary)
#: lib/string.ex:511
msgid ""
"Returns a string where leading Unicode whitespace\n"
"has been removed.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.lstrip(\"   abc  \")\n"
"    \"abc  \"\n"
"\n"
msgstr ""
"先頭のUnicodeホワイトスペース文字を取り除いた文字列を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.lstrip(\"   abc  \")\n"
"    \"abc  \"\n"
"\n"

#. TRANSLATORS: def GenEvent.stream(manager, options \\ [])
#: lib/gen_event.ex:295
msgid ""
"Returns a stream that consumes events from the `manager`.\n"
"\n"
"The stream is a `GenEvent` struct that implements the `Enumerable`\n"
"protocol. Consumption of events only begins when enumeration starts.\n"
"\n"
"Note streaming is specific to Elixir's GenEvent and does not work\n"
"with Erlang ones.\n"
"\n"
"## Options\n"
"\n"
"  * `:timeout` - raises if no event arrives in X milliseconds\n"
"    (defaults to `:infinity`)\n"
"\n"
msgstr ""
"`manager`からのイベントを消費するストリームを返します。\n"
"\n"
"ストリームは`GenEvent`構造体で`Enumerable`プロトコルの実装です。\n"
"イベントの消費は数え上げの開始をしたときにだけ始まります。\n"
"\n"
"ストリーミングはElixirのGenEvent特有であり、Erlangでは\n"
"動作しないことに注意してください。\n"
"\n"
"## オプション\n"
"\n"
"  * `:timeout` - Xミリ秒の間にイベントが到着しないと\n"
"                 例外を上げます(デフォルトは `:infinity`)\n"
"\n"

#. TRANSLATORS: def Kernel.tl(list)
#: lib/kernel.ex:715
msgid ""
"Returns the tail of a list. Raises `ArgumentError` if the list is empty.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"リストのtail(リストから先頭要素を取り除いたもの)を返します。\n"
"もしリストが空なら`ArgumentError`を上げます。\n"
"\n"
"ガード中のテストに使うことができます。コンパイラによりインライン化され\n"
"ます。\n"

#. TRANSLATORS: def String.replace(subject, pattern, replacement, options \\ [])
#: lib/string.ex:666
msgid ""
"Returns a new binary based on `subject` by replacing the parts\n"
"matching `pattern` by `replacement`. By default, it replaces\n"
"all entries, except if the `global` option is set to `false`.\n"
"\n"
"A `pattern` may be a string or a regex.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.replace(\"a,b,c\", \",\", \"-\")\n"
"    \"a-b-c\"\n"
"\n"
"    iex> String.replace(\"a,b,c\", \",\", \"-\", global: false)\n"
"    \"a-b,c\"\n"
"\n"
"The pattern can also be a regex. In those cases, one can give `\\N` or\n"
"`\\g{N}` in the `replacement` string to access a specific capture in the\n"
"regex:\n"
"\n"
"    iex> String.replace(\"a,b,c\", ~r/,(.)/, \",\\\\1\\\\1\")\n"
"    \"a,bb,cc\"\n"
"\n"
"Notice we had to escape the escape character `\\`. By giving `\\0`,\n"
"one can inject the whole matched pattern in the replacement string.\n"
"\n"
"When strings are used as a pattern, a developer can also use the\n"
"replaced part inside the `replacement` via the `:insert_replaced` option:\n"
"\n"
"    iex> String.replace(\"a,b,c\", \"b\", \"[]\", insert_replaced: 1)\n"
"    \"a,[b],c\"\n"
"\n"
"    iex> String.replace(\"a,b,c\", \",\", \"[]\", insert_replaced: 2)\n"
"    \"a[],b[],c\"\n"
"\n"
"    iex> String.replace(\"a,b,c\", \",\", \"[]\", insert_replaced: [1, 1])\n"
"    \"a[,,]b[,,]c\"\n"
"\n"
msgstr ""
"`subject`に基いて`pattern`にマッチした部分を`replacement`で置き換えた、\n"
"新しいバイナリを返します。`global`オプションを`false`にしないかぎり、デ\n"
"フォルトでは、全部のエントリを置き換えます。\n"
"\n"
"`pattern`は文字列か正規表現です。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.replace(\"a,b,c\", \",\", \"-\")\n"
"    \"a-b-c\"\n"
"\n"
"    iex> String.replace(\"a,b,c\", \",\", \"-\", global: false)\n"
"    \"a-b,c\"\n"
"\n"
"パターンは正規表現でもよいです。それらのケースでは、`replacement`文字列\n"
"中で、正規表現中で捕捉した文字列にアクセスするために`\\N`または`\\g{N}`を\n"
"使うことができます:\n"
"\n"
"    iex> String.replace(\"a,b,c\", ~r/,(.)/, \",\\\\1\\\\1\")\n"
"    \"a,bb,cc\"\n"
"\n"
"エスケープ文字`\\`を使わなくてはならないことに注意してください。\n"
"`\\0`を与えることにより、置き換え文字列の中でパターンにマッチした\n"
"全体を捕捉することができます。\n"
"\n"
"パターンとして文字列が使われたとき、開発者は`replacement`の\n"
"内側に、`:insert_replaced`オプションによりパターンを埋め込む\n"
"ことが出来ます: \n"
"\n"
"    iex> String.replace(\"a,b,c\", \"b\", \"[]\", insert_replaced: 1)\n"
"    \"a,[b],c\"\n"
"\n"
"    iex> String.replace(\"a,b,c\", \",\", \"[]\", insert_replaced: 2)\n"
"    \"a[],b[],c\"\n"
"\n"
"    iex> String.replace(\"a,b,c\", \",\", \"[]\", insert_replaced: [1, 1])\n"
"    \"a[,,]b[,,]c\"\n"
"\n"

#. TRANSLATORS: def Supervisor.count_children(supervisor)
#: lib/supervisor.ex:396
msgid ""
"Returns a map containing count values for the supervisor.\n"
"\n"
"The map contains the following keys:\n"
"\n"
"  * `:specs` - the total count of children, dead or alive\n"
"\n"
"  * `:active` - the count of all actively running child processes managed "
"by\n"
"    this supervisor\n"
"\n"
"  * `:supervisors` - the count of all supervisors whether or not the child\n"
"    process is still alive\n"
"\n"
"  * `:workers` - the count of all workers, whether or not the child process\n"
"    is still alive\n"
"\n"
msgstr ""
"スーパバイザの子の数を含むマップを返します。\n"
"\n"
"マップは以下のキーを含みます:\n"
"\n"
"  * `:specs` - 生死を問わず、子の全数\n"
"\n"
"  * `:active` - このスーパバイザで管理された実行中のアクティブな\n"
"     子プロセスの数\n"
"\n"
"  * `:supervisors` - 子プロセスが生きているかは問わず、全ての\n"
"     スーパバイザの数\n"
"\n"
"  * `:workers` - 子プロセスが生きているかは問わず、全ての\n"
"     ワーカの数\n"
"\n"

#. TRANSLATORS: def Macro.Env.location(arg1)
#: lib/macro/env.ex:102
msgid ""
"Returns a keyword list containing the file and line\n"
"information as keys.\n"
msgstr ""
"引数から、キーとしてファイルと行番号情報を含むキーワードリストを返\n"
"します。\n"

#. TRANSLATORS: def String.upcase(binary)
#: lib/string.ex:401
msgid ""
"Converts all characters on the given string to uppercase.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.upcase(\"abcd\")\n"
"    \"ABCD\"\n"
"\n"
"    iex> String.upcase(\"ab 123 xpto\")\n"
"    \"AB 123 XPTO\"\n"
"\n"
"    iex> String.upcase(\"olá\")\n"
"    \"OLÁ\"\n"
"\n"
msgstr ""
"与えられた文字列の全ての文字を大文字に変換します。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.upcase(\"abcd\")\n"
"    \"ABCD\"\n"
"\n"
"    iex> String.upcase(\"ab 123 xpto\")\n"
"    \"AB 123 XPTO\"\n"
"\n"
"    iex> String.upcase(\"olá\")\n"
"    \"OLÁ\"\n"
"\n"

#. TRANSLATORS: def String.downcase(binary)
#: lib/string.ex:419
msgid ""
"Converts all characters on the given string to lowercase.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.downcase(\"ABCD\")\n"
"    \"abcd\"\n"
"\n"
"    iex> String.downcase(\"AB 123 XPTO\")\n"
"    \"ab 123 xpto\"\n"
"\n"
"    iex> String.downcase(\"OLÁ\")\n"
"    \"olá\"\n"
"\n"
msgstr ""
"与えられた文字列の全ての文字を小文字に変換します。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.downcase(\"ABCD\")\n"
"    \"abcd\"\n"
"\n"
"    iex> String.downcase(\"AB 123 XPTO\")\n"
"    \"ab 123 xpto\"\n"
"\n"
"    iex> String.downcase(\"OLÁ\")\n"
"    \"olá\"\n"
"\n"

#. TRANSLATORS: def Kernel.Typespec.type_to_ast(arg1)
#: lib/kernel/typespec.ex:385
msgid "Converts a type clause back to Elixir AST.\n"
msgstr "タイプ節をElixir ASTへ変換します。\n"

#. TRANSLATORS: def Map.from_struct(struct)
#: lib/map.ex:60
msgid ""
"Converts a struct to map.\n"
"\n"
"It accepts the struct module or a struct itself and\n"
"simply removes the `__struct__` field from the struct.\n"
"\n"
"## Example\n"
"\n"
"    defmodule User do\n"
"      defstruct [:name]\n"
"    end\n"
"\n"
"    Map.from_struct(User)\n"
"    #=> %{name: nil}\n"
"\n"
"    Map.from_struct(%User{name: \"john\"})\n"
"    #=> %{name: \"john\"}\n"
"\n"
msgstr ""
"構造体をマップに変換します。\n"
"\n"
"構造体モジュールか構造体自身を受け付け、\n"
"単に、構造体から`__struct__`フィールドを取り除きます。\n"
"\n"
"## 例\n"
"\n"
"    defmodule User do\n"
"      defstruct [:name]\n"
"    end\n"
"\n"
"    Map.from_struct(User)\n"
"    #=> %{name: nil}\n"
"\n"
"    Map.from_struct(%User{name: \"john\"})\n"
"    #=> %{name: \"john\"}\n"
"\n"

#. TRANSLATORS: def Kernel.throw(term)
#: lib/kernel.ex:705
msgid ""
"A non-local return from a function. Check `Kernel.SpecialForms.try/1` for "
"more information.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"関数から非ローカルに戻ります。\n"
"詳細は`Kernel.SpecialForms.try/1`をチェックしてください。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: Elixir.Kernel.ParallelRequire Summary
#: lib/kernel/parallel_require.ex:1
msgid "A module responsible for requiring files in parallel.\n"
msgstr "並列にファイルをrequireすることに責任をもつモジュールです。\n"

#. TRANSLATORS: Elixir.Kernel.ParallelCompiler Summary
#: lib/kernel/parallel_compiler.ex:1
msgid "A module responsible for compiling files in parallel.\n"
msgstr "並列にファイルをコンパイルすることに責任を持つモジュールです。\n"

#. TRANSLATORS: Elixir.Application Summary
#: lib/application.ex:1
msgid ""
"A module for working with applications and defining application callbacks.\n"
"\n"
"In Elixir (actually, in Erlang/OTP), an application is a component\n"
"implementing some specific functionality, that can be started and stopped\n"
"as a unit, and which can be re-used in other systems as well.\n"
"\n"
"Applications are defined with an application file named `APP.app` where\n"
"`APP` is the APP name, usually in `underscore_case` convention. The\n"
"application file must reside in the same `ebin` directory as the\n"
"application's modules bytecode.\n"
"\n"
"In Elixir, Mix is responsible for compiling your source code and\n"
"generating your application `.app` file. Furthermore, Mix is also\n"
"responsible for configuring, starting and stopping your application\n"
"and its dependencies. For this reason, this documentation will focus\n"
"on the remaining aspects of your application: the application environment,\n"
"and the application callback module.\n"
"\n"
"You can learn more about Mix compilation of `.app` files by typing\n"
"`mix help compile.app`.\n"
"\n"
"## Application environment\n"
"\n"
"Once an application is started, OTP provides an application environment\n"
"that can be used to configure applications.\n"
"\n"
"Assuming you are inside a Mix project, you can edit your application\n"
"function in the `mix.exs` file to the following:\n"
"\n"
"    def application do\n"
"      [env: [hello: :world]]\n"
"    end\n"
"\n"
"In the application function, we can define the default environment values\n"
"for our application. By starting your application with `iex -S mix`, you\n"
"can access the default value:\n"
"\n"
"    Application.get_env(:APP_NAME, :hello)\n"
"    #=> :world\n"
"\n"
"It is also possible to put and delete values from the application value,\n"
"including new values that are not defined in the environment file (although\n"
"those should be avoided).\n"
"\n"
"In the future, we plan to support configuration files which allows\n"
"developers to configure the environment of their dependencies.\n"
"\n"
"Keep in mind that each application is responsible for its environment.\n"
"Do not use the functions in this module for directly access or modify\n"
"the environment of other application (as it may lead to inconsistent\n"
"data in the application environment).\n"
"\n"
"## Application module callback\n"
"\n"
"Often times, an application defines a supervision tree that must be started\n"
"and stopped when the application starts and stops. For such, we need to\n"
"define an application module callback. The first step is to define the\n"
"module callback in the application definition in the `mix.exs` file:\n"
"\n"
"    def application do\n"
"      [mod: {MyApp, []}]\n"
"    end\n"
"\n"
"Our application now requires the `MyApp` module to provide an application\n"
"callback. This can be done by invoking `use Application` in that module\n"
"and defining a `start/2` callback, for example:\n"
"\n"
"    defmodule MyApp do\n"
"      use Application\n"
"\n"
"      def start(_type, _args) do\n"
"        MyApp.Supervisor.start_link()\n"
"      end\n"
"    end\n"
"\n"
"`start/2` most commonly returns `{:ok, pid}` or `{:ok, pid, state}` where\n"
"`pid` identifies the supervision tree and the state is the application "
"state.\n"
"`args` is second element of the tuple given to the `:mod` option.\n"
"\n"
"The `type` passed into `start/2` is usually `:normal` unless in a "
"distributed\n"
"setup where applications takeovers and failovers are configured. This "
"particular\n"
"aspect of applications can be read with more detail in the OTP "
"documentation:\n"
"\n"
"  * http://www.erlang.org/doc/man/application.html\n"
"  * http://www.erlang.org/doc/design_principles/applications.html\n"
"\n"
"A developer may also implement the `stop/1` callback (automatically defined\n"
"by `use Application`) which does any application cleanup. It receives the\n"
"application state and can return any value. Notice that shutting down the\n"
"supervisor is automatically handled by the VM.\n"
msgstr ""
"アプリケーションで動き、アプリケーションコールバックを定義するモジュールで"
"す。\n"
"\n"
"Elixirでは(実際には、Erlang/OTPでは)、アプリケーションとは、いくつかの\n"
"特定の機能(単位としてスタートやストップができ、他のシステムでも\n"
"再利用できるような)を実装したコンポーネントです。\n"
"\n"
"アプリケーションは、`APP.app`と名付けられたアプリケーションファイルで\n"
"定義されます。`APP`は通常`underscore_case`変換されたアプリケーションの名前で"
"す。\n"
"アプリケーションファイルは、アプリケーションモジュールの\n"
"バイトコードと同じ`ebin`ディレクトリに置かれなければなりません。\n"
"\n"
"Elixirでは、Mixはソースコードのコンパイルとアプリケーション`.app`ファイ\n"
"ルの生成に責任をもちます。さらにまた、Mixはアプリケーションの依存関係を\n"
"構成し、開始と停止を行う役割を果します。この理由から、このドキュメント\n"
"はあなたのアプリケーションの残りの面に集中します: アプリケーション環境、\n"
"アプリケーションコールバックモジュールです。\n"
"\n"
"Mixの`.app`ファイルをコンパイルすることについては、`mix help\n"
"compile.app`とタイプすることで学ぶことができます。\n"
"\n"
"## Application environment\n"
"\n"
"アプリケーションが開始したら、OTPは、アプリケーションを構成するために\n"
"使うことができる、アプリケーション環境を提供します。\n"
"\n"
"Mixプロジェクトにあるならば、`mix.exs`ファイルの中のapplication関数を\n"
"次のように編集することができます:\n"
"\n"
"    def application do\n"
"      [env: [hello: :world]]\n"
"    end\n"
"\n"
"application関数で、アプリケーションのためのデフォルトの環境の値を定義できま"
"す。\n"
"`iex -S mix`でアプリケーションを開始することによって、そのデフォルト値に\n"
"アクセスできます:\n"
"\n"
"    Application.get_env(:APP_NAME, :hello)\n"
"    #=> {:ok, :hello}\n"
"\n"
"(避けるべきことですが)環境ファイルで定義されない新しい値を含み、アプリ\n"
"ケーションから値をputし、deleteすることも可能です。\n"
"\n"
"将来、我々は、開発者がそれらの依存関係の環境を構成することができる\n"
"構成ファイルをサポートすることを計画しています。\n"
"\n"
"それぞれのアプリケーションがその環境に責任を果すことを心にとめておいて\n"
"ください。(アプリケーション環境で矛盾しているデータに至るかもしれないの\n"
"で)他のアプリケーションの環境への直接アクセスや変更のために、このモジュー\n"
"ルの関数を使わないでください。\n"
"\n"
"## Application module callback\n"
"\n"
"しばしば、アプリケーションは、アプリケーションが開始と停止するときに、\n"
"開始と停止する、スーパビジョンツリーを定義します。\n"
"それで、アプリケーションモジュールコールバックを定義する必要があります。\n"
"最初のステップは`mix.exs`ファイルのapplicationの定義に、モジュール\n"
"コールバックを定義することです:\n"
"\n"
"    def application do\n"
"      [mod: {MyApp, []}]\n"
"    end\n"
"\n"
"今や、私達のアプリケーションは、アプリケーションコールバックを\n"
"提供することを`MyApp`モジュールに要求します。\n"
"これは、そのモジュールで`use Application`を実行することによりなされ、\n"
"`start/2`コールバックを定義します。例えば:\n"
"\n"
"    defmodule MyApp do\n"
"      use Application\n"
"\n"
"      def start(_type, _args) do\n"
"        MyApp.Supervisor.start_link()\n"
"      end\n"
"    end\n"
"\n"
"`start/2`は最も一般的には`{:ok, pid}`か`{:ok, pid, state}`を返します。\n"
"`pid`はスーパビジョンツリーの識別子で、stateはアプリケーションのステート\n"
"です。\n"
"`args`は`:mod`オプションに与えたタプルの2番目の要素です。\n"
"\n"
"`start/2`へ送る`type`は、アプリケーションのテイクオーバーとフェイルオーバが\n"
"構成される分散セットアップでないかぎり、通常`:normal`です。\n"
"アプリケーションのこの特定の側面は、OTPドキュメントでより多く詳細に読む\n"
"ことができます:\n"
"\n"
"  * http://www.erlang.org/doc/man/application.html\n"
"  * http://www.erlang.org/doc/design_principles/applications.html\n"
"\n"
"開発者は、`stop/1`コールバック(`use Application`により自動的に定義され\n"
"ています)を、アプリケーションのなんらかのクリーンアップの為に、実装する\n"
"かもしれません。それは、アプリケーションステートを受け取り、任意の値を\n"
"返すことができます。スーパバイザのシャットダウンは、VMにより自動的にハ\n"
"ンドルされることに注意してください。\n"

#. TRANSLATORS: Elixir.Keyword Summary
#: lib/keyword.ex:1
msgid ""
"A keyword is a list of tuples where the first element\n"
"of the tuple is an atom and the second element can be\n"
"any value.\n"
"\n"
"A keyword may have duplicated keys so it is not strictly\n"
"a dictionary. However most of the functions in this module\n"
"behave exactly as a dictionary and mimic the API defined\n"
"by the `Dict` behaviour.\n"
"\n"
"For example, `Keyword.get/3` will get the first entry matching\n"
"the given key, regardless if duplicated entries exist.\n"
"Similarly, `Keyword.put/3` and `Keyword.delete/3` ensure all\n"
"duplicated entries for a given key are removed when invoked.\n"
"\n"
"A handful of functions exist to handle duplicated keys, in\n"
"particular, `Enum.into/2` allows creating new keywords without\n"
"removing duplicated keys, `get_values/2` returns all values for\n"
"a given key and `delete_first/2` deletes just one of the existing\n"
"entries.\n"
"\n"
"Since a keyword list is simply a list, all the operations defined\n"
"in `Enum` and `List` can be applied.\n"
msgstr ""
"キーワードは、最初の要素がアトムで2番目の要素が任意の\n"
"値を取れる、タプルのリストです。\n"
"\n"
"キワードは、それが厳しい辞書でないように、キーの重複を持つかもしれませ\n"
"ん。しかしながら、このモジュールのほとんどの関数は、辞書として\n"
"正確に振る舞って、`Dict`ビヘイビアにより定義されるAPIを模倣します。\n"
"\n"
"例えば、`Keyword.get/3`は、与えられたキーにマッチする最初のエントリを取\n"
"得し、重複したエントリの存在を気にしません。\n"
"同様に、`Keyword.put/3`と`Keyword.delete/3`は、実行されたとき、\n"
"与えられたキーの重複した全てのエントリが削除されることを、確実にします。\n"
"\n"
"小数の関数が、重複したキーを取り扱うために存在します。特に、\n"
"`Enum.into/2`は重複したキーを削除することなく新しいキーワードの作成を許\n"
"し、`get_values/2`は与えられたキーの全ての値を返し、`delete_first/2`は\n"
"存在するエントリの一つだけを削除します。\n"
"\n"
"キーワドリストは単なるリストなので、`Enum`と`List`で定義された全ての\n"
"操作が適用できます。\n"

#. TRANSLATORS: Elixir.HashDict Summary
#: lib/hash_dict.ex:1
msgid ""
"A key-value store.\n"
"\n"
"The `HashDict` is represented internally as a struct, therefore\n"
"`%HashDict{}` can be used whenever there is a need to match\n"
"on any `HashDict`. Note though the struct fields are private and\n"
"must not be accessed directly. Instead, use the functions on this\n"
"or in the `Dict` module.\n"
"\n"
"Implementation-wise, `HashDict` is implemented using tries, which\n"
"grows in space as the number of keys grows, working well with both\n"
"small and large set of keys. For more information about the\n"
"functions and their APIs, please consult the `Dict` module.\n"
msgstr ""
"キーバリューストアです。\n"
"\n"
"`HashDict`は内部的には構造体として表現されています、従って、\n"
"任意の`HashDict`にマッチする必要があるときは何時でも、`%HashDict{}`が\n"
"使えます。\n"
"しかし構造体のフィールドはプライベートで\n"
"直接アクセスしてはならないことに、気を付けてください。\n"
"かわりに、このモジュールか、あるいは`Dict`モジュールの関数を使ってくださ"
"い。\n"
"\n"
"`HashDict`は、キーの数の増大にしたがってスペースも増大し、\n"
"キーが少くても多くても、よく動作するように実装されています。\n"
"関数とAPIの詳細は、`Dict`モジュールを参照してください。\n"

#. TRANSLATORS: defmacro Kernel.match?(pattern, expr)
#: lib/kernel.ex:1933
msgid ""
"A convenience macro that checks if the right side (an expression)\n"
"matches the left side (a pattern).\n"
"\n"
"## Examples\n"
"\n"
"    iex> match?(1, 1)\n"
"    true\n"
"\n"
"    iex> match?(1, 2)\n"
"    false\n"
"\n"
"    iex> match?({1, _}, {1, 2})\n"
"    true\n"
"\n"
"Match can also be used to filter or find a value in an enumerable:\n"
"\n"
"    list = [{:a, 1}, {:b, 2}, {:a, 3}]\n"
"    Enum.filter list, &match?({:a, _}, &1)\n"
"\n"
"Guard clauses can also be given to the match:\n"
"\n"
"    list = [{:a, 1}, {:b, 2}, {:a, 3}]\n"
"    Enum.filter list, &match?({:a, x} when x < 2, &1)\n"
"\n"
"However, variables assigned in the match will not be available\n"
"outside of the function call:\n"
"\n"
"    iex> match?(x, 1)\n"
"    true\n"
"\n"
"    iex> binding([:x]) == []\n"
"    true\n"
"\n"
msgstr ""
"右辺(式)が左辺(パターン)にマッチするかどうかをチェックする、便利なマクロで"
"す。\n"
"\n"
"## 例\n"
"\n"
"    iex> match?(1, 1)\n"
"    true\n"
"\n"
"    iex> match?(1, 2)\n"
"    false\n"
"\n"
"    iex> match?({1, _}, {1, 2})\n"
"    true\n"
"\n"
"enumerableの中の値をフィルタするまたは、見付けるためにマッチを\n"
"使うこともできます:\n"
"\n"
"    list = [{:a, 1}, {:b, 2}, {:a, 3}]\n"
"    Enum.filter list, &match?({:a, _}, &1)\n"
"\n"
"ガード節もまたマッチで与えることができます:\n"
"\n"
"    list = [{:a, 1}, {:b, 2}, {:a, 3}]\n"
"    Enum.filter list, &match?({:a, x} when x < 2, &1)\n"
"\n"
"しかしながら、マッチで代入される変数は、関数呼びだしの\n"
"外側で利用できません:\n"
"\n"
"    iex> match?(x, 1)\n"
"    true\n"
"\n"
"    iex> binding([:x]) == []\n"
"    true\n"
"\n"

#. TRANSLATORS: def String.to_existing_atom(string)
#: lib/string.ex:1383
msgid ""
"Converts a string to an existing atom.\n"
"\n"
"Currently Elixir does not support conversions from strings\n"
"which contains Unicode codepoints greater than 0xFF.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> :my_atom\n"
"    iex> String.to_existing_atom(\"my_atom\")\n"
"    :my_atom\n"
"\n"
"    iex> String.to_existing_atom(\"this_atom_will_never_exist\")\n"
"    ** (ArgumentError) argument error\n"
"\n"
msgstr ""
"文字列を存在するアトムに変換します。\n"
"\n"
"現在のElixirは、0xFFを越えるUnicodeコードポイントを含む\n"
"文字列からの変換をサポートしていません。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> :my_atom\n"
"    iex> String.to_existing_atom(\"my_atom\")\n"
"    :my_atom\n"
"\n"
"    iex> String.to_existing_atom(\"this_atom_will_never_exist\")\n"
"    ** (ArgumentError) argument error\n"
"\n"

#. TRANSLATORS: def String.to_atom(string)
#: lib/string.ex:1360
msgid ""
"Converts a string to an atom.\n"
"\n"
"Currently Elixir does not support conversions from strings\n"
"which contain Unicode codepoints greater than 0xFF.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.to_atom(\"my_atom\")\n"
"    :my_atom\n"
"\n"
msgstr ""
"文字列をアトムに変換します。\n"
"\n"
"現在のElixirは、0xFFを越えるUnicodeコードポイントを含む\n"
"文字列からの変換をサポートしていません。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.to_atom(\"my_atom\")\n"
"    :my_atom\n"
"\n"

#. TRANSLATORS: def String.to_char_list(string)
#: lib/string.ex:1332
msgid ""
"Converts a string into a char list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> String.to_char_list(\"æß\")\n"
"    'æß'\n"
"\n"
"Notice that this function expects a list of integers representing\n"
"UTF-8 codepoints. If you have a raw binary, you must instead use\n"
"[the `:binary` module](http://erlang.org/doc/man/binary.html).\n"
msgstr ""
"文字列を文字リストに変換します。\n"
"\n"
"## 例\n"
"\n"
"    iex> String.to_char_list(\"æß\")\n"
"    'æß'\n"
"\n"
"この関数は、UTF-8コードポイントで表現される整数のリストを期待している\n"
"ことに、注意してください。もしrawバイナリをもっていたら、\n"
"[`:binary`モジュール](http://erlang.org/doc/man/binary.html)\n"
"を代りに使わなければなりません。\n"

#. TRANSLATORS: Elixir.Task Summary
#: lib/task.ex:1
msgid ""
"Conveniences for spawning and awaiting for tasks.\n"
"\n"
"Tasks are processes meant to execute one particular\n"
"action throughout their life-cycle, often with little or no\n"
"communication with other processes. The most common use case\n"
"for tasks is to compute a value asynchronously:\n"
"\n"
"    task = Task.async(fn -> do_some_work() end)\n"
"    res  = do_some_other_work()\n"
"    res + Task.await(task)\n"
"\n"
"Tasks spawned with `async` can be awaited on by its caller\n"
"process (and only its caller) as shown in the example above.\n"
"They are implemented by spawning a process that sends a message\n"
"to the caller once the given computation is performed.\n"
"\n"
"Besides `async/1` and `await/2`, tasks can also be\n"
"started as part of supervision trees and dynamically spawned\n"
"in remote nodes. We will explore all three scenarios next.\n"
"\n"
"## async and await\n"
"\n"
"The most common way to spawn a task is with `Task.async/1`. A new\n"
"process will be created, linked and monitored by the caller. Once\n"
"the task action finishes, a message will be sent to the caller\n"
"with the result.\n"
"\n"
"`Task.await/2` is used to read the message sent by the task. On\n"
"`await`, Elixir will also setup a monitor to verify if the process\n"
"exited for any abnormal reason (or in case exits are being\n"
"trapped by the caller).\n"
"\n"
"## Supervised tasks\n"
"\n"
"It is also possible to spawn a task inside a supervision tree\n"
"with `start_link/1` and `start_link/3`:\n"
"\n"
"    Task.start_link(fn -> IO.puts \"ok\" end)\n"
"\n"
"Such tasks can be mounted in your supervision tree as:\n"
"\n"
"    import Supervisor.Spec\n"
"\n"
"    children = [\n"
"      worker(Task, [fn -> IO.puts \"ok\" end])\n"
"    ]\n"
"\n"
"Since these tasks are supervised and not directly linked to\n"
"the caller, they cannot be awaited on. Note `start_link/1`,\n"
"unlike `async/1`, returns `{:ok, pid}` (which is\n"
"the result expected by supervision trees).\n"
"\n"
"## Supervision trees\n"
"\n"
"The `Task.Supervisor` module allows developers to start supervisors\n"
"that dynamically supervise tasks:\n"
"\n"
"    {:ok, pid} = Task.Supervisor.start_link()\n"
"    Task.Supervisor.async(pid, MyMod, :my_fun, [arg1, arg2, arg3])\n"
"\n"
"`Task.Supervisor` also makes it possible to spawn tasks in remote nodes as\n"
"long as the supervisor is registered locally or globally:\n"
"\n"
"    # In the remote node\n"
"    Task.Supervisor.start_link(name: :tasks_sup)\n"
"\n"
"    # In the client\n"
"    Task.Supervisor.async({:tasks_sup, :remote@local}, MyMod, :my_fun, "
"[arg1, arg2, arg3])\n"
"\n"
"`Task.Supervisor` is more often started in your supervision tree as:\n"
"\n"
"    import Supervisor.Spec\n"
"\n"
"    children = [\n"
"      supervisor(Task.Supervisor, [[name: :tasks_sup]])\n"
"    ]\n"
"\n"
"Note that, when working with distributed tasks, one should use the `async/3` "
"API,\n"
"that expects explicit module, function and arguments, instead of `async/1` "
"that\n"
"works with anonymous functions. That's because the anonymous function API "
"expects\n"
"the same module version to exist on all involved nodes. Check the `Agent` "
"module\n"
"documentation for more information on distributed processes, as the "
"limitations\n"
"described in the agents documentation apply to the whole ecosystem.\n"
"\n"
"Finally, check `Task.Supervisor` for other operations supported by the Task\n"
"supervisor.\n"
msgstr ""
"タスクの生成と、待ち受けに便利なものです。\n"
"\n"
"タスクは、そのライフサイクルを通して、一つの特定の活動を実行するはずの\n"
"プロセスです。そのプロセスは、しばしば、少しだけ、または全く他のプロセ\n"
"スとコミュニケーションをとりません。\n"
"タスクのための最も一般的なユースケースは、\n"
"非同期的に値を計算することです:\n"
"\n"
"    task = Task.async(fn -> do_some_work() end)\n"
"    res  = do_some_other_work()\n"
"    res + Task.await(task)\n"
"\n"
"`async`により生み出されたタスクは、上の例で見られるように、\n"
"呼び出しプロセス(そしてその呼び出し側だけに)により待たれます。\n"
"一度与えられた計算が実行されるなら、呼び出し側に\n"
"メッセージを送信するプロセスを生み出すことによって、それらは\n"
"実装されます。\n"
"\n"
"`async/1`と`await/2`の他に、タスクはスーパビジョンツリー\n"
"の一部として開始したり、リモートノードで動的に生み出すことも\n"
"出来ます。次に、全3つのシナリオを調査します。\n"
"\n"
"## async and await\n"
"\n"
"タスクを生む最も一般的な方法は`Task.async/1`です。新しい\n"
"プロセスが作成され、呼び出し側によりリンクされ、モニタされます。\n"
"一度タスクのアクションが終了したら、結果として呼び出し側に\n"
"メッセージが送信されます。\n"
"\n"
"`Task.await/2`はタスクにより送信されたメッセージを読み出すために使われ\n"
"ます。`await`で、Elixirは、プロセスが異常な理由でexitしているかどうか\n"
"(または、呼び出し側によりトラップされるexitしているかどうか)、検証する\n"
"ためのモニタをセットアップします。\n"
"\n"
"## Supervised tasks\n"
"\n"
"`start_link/2`と`start_link/3`でスーパビジョンツリーの内でタスクを\n"
"生み出すこともできます:\n"
"\n"
"    Task.start_link(fn -> IO.puts \"ok\" end)\n"
"\n"
"そのようなタスクは以下のようにして、スーパビジョンツリーに\n"
"取り付けることもできます:\n"
"\n"
"    import Supervisor.Spec\n"
"\n"
"    children = [\n"
"      worker(Task, [fn -> IO.puts \"ok\" end])\n"
"    ]\n"
"\n"
"これらのタスクはスーパバイズされ、直接呼び出し側にリンクされて\n"
"いないので、awaitで待つことが出来ません。\n"
"`start_link/1`(`async/1`と違って)は、`{:ok, pid}`\n"
"(スーバビジョンツリーにより期待される結果です)を返すことに\n"
"注意してください。\n"
"\n"
"## Supervision trees\n"
"\n"
"`Task.Supervisor`モジュールは、開発者に、\n"
"動的にタスクをスーパバイズするスーパバイザを開始することを許します:\n"
"\n"
"    {:ok, pid} = Task.Supervisor.start_link()\n"
"    Task.Supervisor.async(pid, MyMod, :my_fun, [arg1, arg2, arg3])\n"
"\n"
"スーパバイザがローカルまたは、グローバルに登録される限り、\n"
"`Task.Supervisor`もまた、リモートノードでタスクを生むことを可能にします:\n"
"\n"
"    # In the remote node\n"
"    Task.Supervisor.start_link(name: :tasks_sup)\n"
"\n"
"    # In the client\n"
"    Task.Supervisor.async({:tasks_sup, :remote@local}, MyMod, :my_fun, "
"[arg1, arg2, arg3])\n"
"\n"
"`Task.Supervisor`は、スーバビジョンツリーでよりしばしば開始されます:\n"
"\n"
"    import Supervisor.Spec\n"
"\n"
"    children = [\n"
"      supervisor(Task.Supervisor, [[name: :tasks_sup]])\n"
"    ]\n"
"\n"
"なお、分散されたタスクで動くとき、無名関数を動かす`async/1`のかわりに、\n"
"モジュール、関数、引数を明示的に期待する、`async/3`APIを使うべきです。\n"
"これは、無名関数APIは全ての起動されたノードで同じモジュールバージョンが\n"
"存在することを期待するためです。\n"
"全エコシステムに適用される、エージェントドキュメントで記述される制限として"
"の、\n"
"分散プロセスの詳細は、`Agent`モジュールドキュメントをチェックしてください。\n"
"\n"
"最後に、他のタスクスーパバイザによりサポートされるオペレーションについて\n"
"の詳細は、 `Task.Supervisor` をチェックしてください。\n"

#. TRANSLATORS: Elixir.Process Summary
#: lib/process.ex:1
msgid ""
"Conveniences for working with processes and the process dictionary.\n"
"\n"
"Besides the functions available in this module, the `Kernel` module\n"
"exposes and auto-imports some basic functionality related to processes\n"
"available through the functions:\n"
"\n"
"  * `Kernel.spawn/1` and `Kernel.spawn/3`\n"
"  * `Kernel.spawn_link/1` and `Kernel.spawn_link/3`\n"
"  * `Kernel.spawn_monitor/1` and `Kernel.spawn_monitor/3`\n"
"  * `Kernel.self/0`\n"
"  * `Kernel.send/2`\n"
"\n"
msgstr ""
"プロセスとプロセス辞書で働くための便利なものです。\n"
"\n"
"このモジュールで利用できる関数の他に、`Kernel`モジュールは、以下の関数\n"
"を通じて利用できるプロセス関連の、基本的機能を公開し、自動インポートし\n"
"ます。\n"
"\n"
"  * `Kernel.spawn/1` 、 `Kernel.spawn/3`\n"
"  * `Kernel.spawn_link/1` 、 `Kernel.spawn_link/3`\n"
"  * `Kernel.spawn_monitor/1` 、 `Kernel.spawn_monitor/3`\n"
"  * `Kernel.self/0`\n"
"  * `Kernel.send/2`\n"
"\n"

#. TRANSLATORS: Elixir.Macro Summary
#: lib/macro.ex:3
msgid "Conveniences for working with macros.\n"
msgstr "マクロで働くための便利なものです。\n"

#. TRANSLATORS: def Path.relative_to_cwd(path)
#: lib/path.ex:311
msgid ""
"Convenience to get the path relative to the current working\n"
"directory. If, for some reason, the current working directory\n"
"cannot be retrieved, returns the full path.\n"
msgstr ""
"カレントワーキングディレクトリからの相対パスを取得するのに\n"
"便利なものです。\n"
"いくつかの理由で、カレントワーキングディレクトリが取得できなかったら、\n"
"絶対パスを返します。\n"

#. TRANSLATORS: def Module.safe_concat(left, right)
#: lib/module.ex:478
msgid ""
"Concatenates two aliases and returns a new alias only\n"
"if the alias was already referenced. If the alias was not\n"
"referenced yet, fails with `ArgumentError`.\n"
"It handles char lists, binaries and atoms.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Module.safe_concat(Unknown, Module)\n"
"    ** (ArgumentError) argument error\n"
"\n"
"    iex> Module.safe_concat(List, Chars)\n"
"    List.Chars\n"
"\n"
msgstr ""
"二つのエイリアスを連結し、それが既に参照されているなら、新しいエイリア\n"
"スを返します。もしエイリアスがまだ参照されていなかったら、\n"
"`ArgumentError`で失敗します。\n"
"文字のリスト、バイナリ、アトムを取り扱います。\n"
"\n"
"## 例\n"
"\n"
"    iex> Module.safe_concat(Unknown, Module)\n"
"    ** (ArgumentError) argument error\n"
"\n"
"    iex> Module.safe_concat(List, Chars)\n"
"    List.Chars\n"
"\n"

#. TRANSLATORS: def Process.register(pid, name)
#: lib/process.ex:277
msgid ""
"Associates the name with a pid or a port identifier. `name`, which must\n"
"be an atom, can be used instead of the pid / port identifier with the\n"
"`Kernel.send/2` function.\n"
"\n"
"`Process.register/2` will fail with `ArgumentError` if the pid supplied\n"
"is no longer alive, (check with `alive?/1`) or if the name is\n"
"already registered (check with `whereis/1`).\n"
msgstr ""
"名前をpidまたはポート識別子と関連付けます。`name`(それはアトムでなくては\n"
"なりません)が、`Kernel.send/2`関数でpid/ポート識別子のかわりに使うことが\n"
"できます。\n"
"\n"
"`Process.register/2`は、供給された(`alive?/1`でチェックして)pidが最早生\n"
"きていない、あるいは、(`whereis/1`でチェックして)名前がすでに登録ずみな\n"
"ら、`ArgumentError`で失敗します。\n"

#. TRANSLATORS: def Stream.repeatedly(generator_fun)
#: lib/stream.ex:969
msgid ""
"Returns a stream generated by calling `generator_fun` repeatedly.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.repeatedly(&:random.uniform/0) |> Enum.take(3)\n"
"    [0.4435846174457203, 0.7230402056221108, 0.94581636451987]\n"
"\n"
msgstr ""
"`generator_fun`を繰り返し呼ぶことで生成されたストリームを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Stream.repeatedly(&:random.uniform/0) |> Enum.take(3)\n"
"    [0.4435846174457203, 0.7230402056221108, 0.94581636451987]\n"
"\n"

#. TRANSLATORS: def Set.union(set1, set2)
#: lib/set.ex:311
msgid ""
"Returns a set containing all members of `set1` and `set2`.\n"
"\n"
"Notice this function is polymorphic as it calculates the union of\n"
"any type. Each set implementation also provides a `union` function,\n"
"but they can only work with sets of the same type.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Set.union(Enum.into([1,2], set_impl.new), Enum.into([2,3,4], "
"set_impl.new)) |> Enum.sort\n"
"    [1,2,3,4]\n"
"\n"
msgstr ""
"`set1`と`set2`の全てのメンバを含む集合を返します。\n"
"\n"
"この関数は、任意のタイプの和集合を計算するので、polymorphic であることに\n"
"注意してください。集合のそれぞれの実装は、`union`関数も\n"
"提供しますが、それらは同じタイプの集合で動くことができる\n"
"だけです。\n"
"\n"
"## 例\n"
"\n"
"    iex> Set.union(Enum.into([1,2], set_impl.new), Enum.into([2,3,4], "
"set_impl.new)) |> Enum.sort\n"
"    [1,2,3,4]\n"
"\n"

#. TRANSLATORS: def Supervisor.which_children(supervisor)
#: lib/supervisor.ex:372
msgid ""
"Returns a list with information about all children.\n"
"\n"
"Note that calling this function when supervising a large number of children\n"
"under low memory conditions can cause an out of memory exception.\n"
"\n"
"This function returns a list of tuples containing:\n"
"\n"
"  * `id` - as defined in the child specification or `:undefined` in the "
"case\n"
"    of a `simple_one_for_one` supervisor\n"
"\n"
"  * `child` - the pid of the corresponding child process, the atom\n"
"    `:restarting` if the process is about to be restarted, or `:undefined` "
"if\n"
"    there is no such process\n"
"\n"
"  * `type` - `:worker` or `:supervisor` as defined in the child "
"specification\n"
"\n"
"  * `modules` – as defined in the child specification\n"
msgstr ""
"全ての子についての情報のリストを返します。\n"
"\n"
"この関数をローメモリ状況の下で、多数の子を監督している時にこの関数を\n"
"呼び出すことが、アウトオブメモリ例外を引き起すことが有り得ることに\n"
"注意してください。\n"
"\n"
"この関数は以下を含んだタプルのリストを返します:\n"
"\n"
"  * `id` - 子仕様で定義されたidまたは、`simple_one_for_one`スーパバイザでは\n"
"      `:undefined`です\n"
"\n"
"  * `child` - 子プロセスに対応したpidです。\n"
"    もしプロセスが再起動されていたら`:restarting`を、もしそのような\n"
"    プロセスがなければ`:undefined`を返します\n"
"\n"
"  * `type` - 子仕様で定義された、`:worker` または `:supervisor` です\n"
"\n"
"  * `modules` – 子仕様が定義されたモジュールです。\n"
"\n"

#. TRANSLATORS: def Tuple.to_list(tuple)
#: lib/tuple.ex:73
msgid ""
"Converts a tuple to a list.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"タプルをリストに変換します。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: Elixir.Supervisor.Spec Summary
#: lib/supervisor/spec.ex:1
msgid ""
"Convenience functions for defining a supervision specification.\n"
"\n"
"## Example\n"
"\n"
"By using the functions in this module one can define a supervisor\n"
"and start it with `Supervisor.start_link/2`:\n"
"\n"
"    import Supervisor.Spec\n"
"\n"
"    children = [\n"
"      worker(MyWorker, [arg1, arg2, arg3]),\n"
"      supervisor(MySupervisor, [arg1])\n"
"    ]\n"
"\n"
"    Supervisor.start_link(children, strategy: :one_for_one)\n"
"\n"
"In many situations, it may be handy to define supervisors backed\n"
"by a module:\n"
"\n"
"    defmodule MySupervisor do\n"
"      use Supervisor\n"
"\n"
"      def start_link(arg) do\n"
"        Supervisor.start_link(__MODULE__, arg)\n"
"      end\n"
"\n"
"      def init(arg) do\n"
"        children = [\n"
"          worker(MyWorker, [arg], restart: :temporary)\n"
"        ]\n"
"\n"
"        supervise(children, strategy: :simple_one_for_one)\n"
"      end\n"
"    end\n"
"\n"
"Notice in this case we don't have to explicitly import\n"
"`Supervisor.Spec` as `use Supervisor` automatically does so.\n"
"\n"
"Explicit supervisors as above are required when there is a need to:\n"
"\n"
"  1. Partially change the supervision tree during hot-code swaps.\n"
"\n"
"  2. Define supervisors inside other supervisors.\n"
"\n"
"  3. Perform actions inside the supervision `init/1` callback.\n"
"\n"
"     For example, you may want to start an ETS table that is linked to\n"
"     the supervisor (i.e. if the supervision tree needs to be restarted,\n"
"     the ETS table must be restarted too).\n"
"\n"
"## Supervisor and worker options\n"
"\n"
"In the example above, we have defined workers and supervisors\n"
"and each accepts the following options:\n"
"\n"
"  * `:id` - a name used to identify the child specification\n"
"    internally by the supervisor; defaults to the given module\n"
"    name\n"
"\n"
"  * `:function` - the function to invoke on the child to start it\n"
"\n"
"  * `:restart` - defines when the child process should restart\n"
"\n"
"  * `:shutdown` - defines how a child process should be terminated\n"
"\n"
"  * `:modules` - it should be a list with one element `[module]`,\n"
"    where module is the name of the callback module only if the\n"
"    child process is a `Supervisor` or `GenServer`; if the child\n"
"    process is a `GenEvent`, modules should be `:dynamic`\n"
"\n"
"### Restart values (:restart)\n"
"\n"
"The following restart values are supported:\n"
"\n"
"  * `:permanent` - the child process is always restarted\n"
"\n"
"  * `:temporary` - the child process is never restarted (not even\n"
"    when the supervisor's strategy is `:rest_for_one` or `:one_for_all`)\n"
"\n"
"  * `:transient` - the child process is restarted only if it\n"
"    terminates abnormally, i.e. with another exit reason than\n"
"    `:normal`, `:shutdown` or `{:shutdown, term}`\n"
"\n"
"### Shutdown values (:shutdown)\n"
"\n"
"The following shutdown values are supported:\n"
"\n"
"  * `:brutal_kill` - the child process is unconditionally terminated\n"
"    using `exit(child, :kill)`.\n"
"\n"
"  * `:infinity` - if the child process is a supervisor, it is a mechanism\n"
"    to give the subtree enough time to shutdown. It can also be used with\n"
"    workers with care.\n"
"\n"
"  * Finally, it can also be any integer meaning that the supervisor tells\n"
"    the child process to terminate by calling `Process.exit(child, :"
"shutdown)`\n"
"    and then waits for an exit signal back. If no exit signal is received\n"
"    within the specified time (in milliseconds), the child process is\n"
"    unconditionally terminated using `Process.exit(child, :kill)`.\n"
msgstr ""
"supervision仕様を定義するのに、便利な関数です。\n"
"\n"
"## 例\n"
"\n"
"このモジュールの関数を使うことによって、スーババイザの定義と、\n"
"`Supervisor.start_link/2`で開始することができます:\n"
"\n"
"    import Supervisor.Spec\n"
"\n"
"    children = [\n"
"      worker(MyWorker, [arg1, arg2, arg3]),\n"
"      supervisor(MySupervisor, [arg1])\n"
"    ]\n"
"\n"
"    Supervisor.start_link(children, strategy: :one_for_one)\n"
"\n"
"多くのシチュエーションで、一つのモジュールにより\n"
"支持されるスーパーバイザを定義することは、便利です:\n"
"\n"
"    defmodule MySupervisor do\n"
"      use Supervisor\n"
"\n"
"      def start_link(arg) do\n"
"        Supervisor.start_link(__MODULE__, arg)\n"
"      end\n"
"\n"
"      def init(arg) do\n"
"        children = [\n"
"          worker(MyWorker, [arg], restart: :temporary)\n"
"        ]\n"
"\n"
"        supervise(children, strategy: :simple_one_for_one)\n"
"      end\n"
"    end\n"
"\n"
"この場合、\n"
"明示的に`Supervicor.Spec`をインポートする必要がないことに\n"
"注意してください。`use Supervisor`が自動的に行ってくれます。\n"
"\n"
"以下の必要があるとき、上記の明示的なスーパバイザは要求されます。\n"
"\n"
"  1. ホットコードスワップ中にsupervisionツリーを部分的に変更する。\n"
"\n"
"  2. 他のスーパバイザの内側で、スーパバイザを定義する。\n"
"\n"
"  3. supervisionの`init/1`コールバックの内側でアクションを実行する。\n"
"\n"
"     例えば、スーパバイザにリンクされたETSテーブルを開始したいかも\n"
"     しれません(即ち、スーバビジョンツリーが再起動される必要があるなら、\n"
"     ETSテーブルもまた、再起動されなければなりません)。\n"
"\n"
"## supervisor と worker オプション\n"
"\n"
"上の例で、workerと、supervisorを定義し、それぞれは以下のオプションを\n"
"以下のオプションを受け付けます:\n"
"\n"
"  * `:id` - スーパバイザにより内部的に、\n"
"    子プロセス仕様を定義するために使う名前; デフォルトは与えられた\n"
"    モジュール名\n"
"\n"
"  * `:function` - 子プロセスを開始したときに起動する関数\n"
"\n"
"  * `:restart` -  子プロセスを再起動すべきときの定義\n"
"\n"
"  * `:shutdown` -  どのように子プロセスが終了されるべきかの定義\n"
"\n"
"  * `:modules` -   1要素の`[module]`のようなリストであるべきで、\n"
"     moduleは、子プロセスが`Supervisor`か`GenServer`ならば、\n"
"     コールバックモジュールの名前で、子プロセスが`GenEvent`なら、\n"
"     moduleは`:dynamic`でなければなりません。\n"
"\n"
"### Restart values (:restart)\n"
"\n"
"restart の値は以下がサポートされています:\n"
"\n"
"  * `:permanent` - 子プロセスは常に再起動されます\n"
"\n"
"  * `:temporary` - 子プロセスは決して再起動されません(\n"
"     スーパバイザの戦略が`rest_for_one`、`:one_for_all`のときも)\n"
"\n"
"  * `:transient` - 異常終了(即ち、`:normal`, `:shutdown`, \n"
"    `{:shutdown, term}`以外ののexit reason)したときだけ、\n"
"    子プロセスは再起動されます。\n"
"\n"
"### Shutdown values (:shutdown)\n"
"\n"
"以下のshutdown値がサポートされます:\n"
"\n"
"  * `:brutal_kill` - `exit(child, :kill)`を使い、子プロセスは無条件で\n"
"     終了されます。\n"
"\n"
"  * `:infinity` - 子プロセスがsupervisorなら、サブツリーにshutdownに\n"
"    十分な時間を与えるメカニズムです。注意してworkerに対して使われる\n"
"    こともあります。\n"
"\n"
"  * 最後に、スーパバイザが子プロセスに\n"
"    呼び出し`Process.exit(child, :shutdown)`によて終了するようにいい、\n"
"    それから、exitシグナルバックを待つことは、任意の整数で有り得ます。\n"
"    もしexitシグナルが指定された時間(ミリ秒)に受信されないなら、\n"
"    子プロセスは無条件に`Process.exit(child, :kill)`を使って終了\n"
"    されます。\n"

#. TRANSLATORS: Elixir.GenServer Summary
#: lib/gen_server.ex:1
msgid ""
"A behaviour module for implementing the server of a client-server relation.\n"
"\n"
"A GenServer is a process as any other Elixir process and it can be used\n"
"to keep state, execute code asynchronously and so on. The advantage of "
"using\n"
"a generic server process (GenServer) implemented using this module is that "
"it\n"
"will have a standard set of interface functions and include functionality "
"for\n"
"tracing and error reporting. It will also fit into a supervision tree.\n"
"\n"
"## Example\n"
"\n"
"The GenServer behaviour abstracts the common client-server interaction.\n"
"Developers are only required to implement the callbacks and functionality "
"they are\n"
"interested in.\n"
"\n"
"Let's start with a code example and then explore the available callbacks.\n"
"Imagine we want a GenServer that works like a stack, allowing us to push\n"
"and pop items:\n"
"\n"
"    defmodule Stack do\n"
"      use GenServer\n"
"\n"
"      # Callbacks\n"
"\n"
"      def handle_call(:pop, _from, [h|t]) do\n"
"        {:reply, h, t}\n"
"      end\n"
"\n"
"      def handle_cast({:push, item}, state) do\n"
"        {:noreply, [item|state]}\n"
"      end\n"
"    end\n"
"\n"
"    # Start the server\n"
"    {:ok, pid} = GenServer.start_link(Stack, [:hello])\n"
"\n"
"    # This is the client\n"
"    GenServer.call(pid, :pop)\n"
"    #=> :hello\n"
"\n"
"    GenServer.cast(pid, {:push, :world})\n"
"    #=> :ok\n"
"\n"
"    GenServer.call(pid, :pop)\n"
"    #=> :world\n"
"\n"
"We start our `Stack` by calling `start_link/3`, passing the module\n"
"with the server implementation and its initial argument (a list\n"
"representing the stack containing the item `:hello`). We can primarily\n"
"interact with the server by sending two types of messages. **call**\n"
"messages expect a reply from the server (and are therefore synchronous)\n"
"while **cast** messages do not.\n"
"\n"
"Every time you do a `GenServer.call/3`, the client will send a message\n"
"that must be handled by the `handle_call/3` callback in the GenServer.\n"
"A `cast/2` message must be handled by `handle_cast/2`.\n"
"\n"
"## Callbacks\n"
"\n"
"There are 6 callbacks required to be implemented in a `GenServer`. By\n"
"adding `use GenServer` to your module, Elixir will automatically define\n"
"all 6 callbacks for you, leaving it up to you to implement the ones\n"
"you want to customize. The callbacks are:\n"
"\n"
"  * `init(args)` - invoked when the server is started.\n"
"\n"
"    It must return:\n"
"\n"
"    -  `{:ok, state}`\n"
"    -  `{:ok, state, timeout}`\n"
"    -  `:ignore`\n"
"    -  `{:stop, reason}`\n"
"\n"
"  * `handle_call(msg, {from, ref}, state)` and `handle_cast(msg, state)` -\n"
"    invoked to handle call (sync) and cast (async) messages.\n"
"\n"
"    It must return:\n"
"\n"
"    -  `{:reply, reply, new_state}`\n"
"    -  `{:reply, reply, new_state, timeout}`\n"
"    -  `{:reply, reply, new_state, :hibernate}`\n"
"    -  `{:noreply, new_state}`\n"
"    -  `{:noreply, new_state, timeout}`\n"
"    -  `{:noreply, new_state, :hibernate}`\n"
"    -  `{:stop, reason, new_state}`\n"
"    -  `{:stop, reason, reply, new_state}`\n"
"\n"
"  * `handle_info(msg, state)` - invoked to handle all other messages which\n"
"    are received by the process.\n"
"\n"
"    It must return:\n"
"\n"
"    -  `{:noreply, state}`\n"
"    -  `{:noreply, state, timeout}`\n"
"    -  `{:stop, reason, state}`\n"
"\n"
"  * `terminate(reason, state)` - called when the server is about to\n"
"    terminate, useful for cleaning up. It must return `:ok`.\n"
"\n"
"  * `code_change(old_vsn, state, extra)` - called when the application\n"
"    code is being upgraded live (hot code swapping).\n"
"\n"
"    It must return:\n"
"\n"
"    -  `{:ok, new_state}`\n"
"    -  `{:error, reason}`\n"
"\n"
"## Name Registration\n"
"\n"
"Both `start_link/3` and `start/3` support the `GenServer` to register\n"
"a name on start via the `:name` option. Registered names are also\n"
"automatically cleaned up on termination. The supported values are:\n"
"\n"
"  * an atom - the GenServer is registered locally with the given name\n"
"    using `Process.register/2`.\n"
"\n"
"  * `{:global, term}`- the GenServer is registered globally with the given\n"
"    term using the functions in the `:global` module.\n"
"\n"
"  * `{:via, module, term}` - the GenServer is registered with the given\n"
"    mechanism and name. The `:via` option expects a module name to control\n"
"    the registration mechanism alongside a name which can be any term.\n"
"\n"
"For example, we could start and register our Stack server locally as "
"follows:\n"
"\n"
"    # Start the server and register it locally with name MyStack\n"
"    {:ok, _} = GenServer.start_link(Stack, [:hello], name: MyStack)\n"
"\n"
"    # Now messages can be sent directly to MyStack\n"
"    GenServer.call(MyStack, :pop) #=> :hello\n"
"\n"
"Once the server is started, the remaining functions in this module "
"(`call/3`,\n"
"`cast/2`, and friends) will also accept an atom, or any `:global` or `:via`\n"
"tuples. In general, the following formats are supported:\n"
"\n"
"  * a `pid`\n"
"  * an `atom` if the server is locally registered\n"
"  * `{atom, node}` if the server is locally registered at another node\n"
"  * `{:global, term}` if the server is globally registered\n"
"  * `{:via, module, name}` if the server is registered through an "
"alternative\n"
"    registry\n"
"\n"
"## Client / Server APIs\n"
"\n"
"Although in the example above we have used `GenServer.start_link/3` and\n"
"friends to directly start and communicate with the server, most of the\n"
"time we don't call the `GenServer` functions directly. Instead, we wrap\n"
"the calls in new functions representing the public API of the server.\n"
"\n"
"Here is a better implementation of our Stack module:\n"
"\n"
"    defmodule Stack do\n"
"      use GenServer\n"
"\n"
"      # Client\n"
"\n"
"      def start_link(default) do\n"
"        GenServer.start_link(__MODULE__, default)\n"
"      end\n"
"\n"
"      def push(pid, item) do\n"
"        GenServer.cast(pid, {:push, item})\n"
"      end\n"
"\n"
"      def pop(pid) do\n"
"        GenServer.call(pid, :pop)\n"
"      end\n"
"\n"
"      # Server (callbacks)\n"
"\n"
"      def handle_call(:pop, _from, [h|t]) do\n"
"        {:reply, h, t}\n"
"      end\n"
"\n"
"      def handle_call(request, from, state) do\n"
"        # Call the default implementation from GenServer\n"
"        super(request, from, state)\n"
"      end\n"
"\n"
"      def handle_cast({:push, item}, state) do\n"
"        {:noreply, [item|state]}\n"
"      end\n"
"\n"
"      def handle_cast(request, state) do\n"
"        super(request, state)\n"
"      end\n"
"    end\n"
"\n"
"In practice, it is common to have both server and client functions in\n"
"the same module. If the server and/or client implementations are growing\n"
"complex, you may want to have them in different modules.\n"
"\n"
"## Learn more\n"
"\n"
"If you wish to find out more about gen servers, Elixir getting started\n"
"guides provide a tutorial-like introduction. The documentation and links\n"
"in Erlang can also provide extra insight.\n"
"\n"
"  * http://elixir-lang.org/getting_started/mix_otp/1.html\n"
"  * http://www.erlang.org/doc/man/gen_server.html\n"
"  * http://www.erlang.org/doc/design_principles/gen_server_concepts.html\n"
"  * http://learnyousomeerlang.com/clients-and-servers\n"
msgstr ""
"クライアント-サーバ関係のサーバを実装するためのビヘイビアモジュールです。\n"
"\n"
"GenServerは、\n"
"他の任意のElixirプロセスを使い、ステートを保持し、非同期にコードを実行、\n"
"その他を行う、プロセスです。\n"
"コノモジュールによる一般的なサーバプロセス(GenServer)実装の長所は、\n"
"それがインタフェース関数の標準的なセットを持っていて、\n"
"トレースとエラーレポートの為の機能を含んでいることです。\n"
"それは、スーパビジョンツリーにも適合します。\n"
"\n"
"## 例\n"
"\n"
"GenServerビヘイビアは一般のクライアント-サーバインタラクションを抽象化しま"
"す。\n"
"開発者は彼らが興味がある機能とコールバックの実装が要求されるだけです。\n"
"\n"
"コード例から始めましょう。それから有効なコールバックを\n"
"調査しましょう。\n"
"私達はGenServerが、アイテムをプッシュしたりポップしたりする、\n"
"スタックのように、動いて欲しいとします:\n"
"\n"
"    defmodule Stack do\n"
"      use GenServer\n"
"\n"
"      # Callbacks\n"
"\n"
"      def handle_call(:pop, _from, [h|t]) do\n"
"        {:reply, h, t}\n"
"      end\n"
"\n"
"      def handle_cast({:push, item}, state) do\n"
"        {:noreply, [item|state]}\n"
"      end\n"
"    end\n"
"\n"
"    # Start the server\n"
"    {:ok, pid} = GenServer.start_link(Stack, [:hello])\n"
"\n"
"    # This is the client\n"
"    GenServer.call(pid, :pop)\n"
"    #=> :hello\n"
"\n"
"    GenServer.cast(pid, {:push, :world})\n"
"    #=> :ok\n"
"\n"
"    GenServer.call(pid, :pop)\n"
"    #=> :world\n"
"\n"
"サーバ実装モジュールと、初期値(アイテム`:hello`を含むスタックを\n"
"表現したリスト)を渡し、`start_link/3`を呼び出すことで私達の`Stack`は開始しま"
"す。\n"
"私達は、主に二種類のメッセージを送信することで、\n"
"サーバと対話することができます。\n"
"**call**メッセージはサーバからの応答を期待します(従って同期しています)が、\n"
"**calst**メッセージはそうではありません。\n"
"\n"
"`GenServer.call/3`を呼ぶたびに、クライアントは、GenServerの\n"
"`handle_call/3`コールバックによりハンドルされなければならない、メッセー\n"
"ジを送信します。`cast/2`メッセージは`handle_cast/2`によりハンドルされな\n"
"ければなりません。\n"
"\n"
"## Callbacks\n"
"\n"
"`GenServer`で実装することが要求されている6個のコールバックがあります。\n"
"`use GenServer`をあなたのモジュールに追加することにより、Elixir自動的に\n"
"6個のコールバックを定義し、カスタマイズしたいものの実装をあなたに任せます:\n"
"コールバックは:\n"
"\n"
"  * `init(args)` - サーバが開始したときに実行されます。\n"
"\n"
"    以下を返さなければなりません:\n"
"\n"
"    -  `{:ok, state}`\n"
"    -  `{:ok, state, timeout}`\n"
"    -  `:ignore`\n"
"    -  `{:stop, reason}`\n"
"\n"
"  * `handle_call(msg, {from, ref}, state)` and `handle_cast(msg, state)` -\n"
"    call(同期)とcast(非同期)メッセージをハンドルするために起動されます。\n"
"\n"
"    以下を返さなければなりません:\n"
"\n"
"    -  `{:reply, reply, new_state}`\n"
"    -  `{:reply, reply, new_state, timeout}`\n"
"    -  `{:reply, reply, new_state, :hibernate}`\n"
"    -  `{:noreply, new_state}`\n"
"    -  `{:noreply, new_state, timeout}`\n"
"    -  `{:noreply, new_state, :hibernate}`\n"
"    -  `{:stop, reason, new_state}`\n"
"    -  `{:stop, reason, reply, new_state}`\n"
"\n"
"  * `handle_info(msg, state)` - プロセスにより受信された他の全ての\n"
"    メッセージをハンドルするために起動されます。\n"
"\n"
"    以下を返さなければなりません:\n"
"\n"
"    -  `{:noreply, state}`\n"
"    -  `{:noreply, state, timeout}`\n"
"    -  `{:stop, reason, state}`\n"
"\n"
"  * `terminate(reason, state)` - \n"
"    サーバが終了しようとしている時に呼び出され、クリーンアップに\n"
"    役立ちます。`:ok`を返さなければなりません。\n"
"\n"
"  * `code_change(old_vsn, state, extra)` - アプリケーションコードが\n"
"    ライブアップグレードされた時に呼び出されます\n"
"    (ホットコードスワッピング)。\n"
"\n"
"    以下を返さなければなりません:\n"
"\n"
"    -  `{:ok, new_state}`\n"
"    -  `{:error, reason}`\n"
"\n"
"## Name Registration\n"
"\n"
"`start_link/3`と`start/3`の両方は、`GenServer`で\n"
"`:name`オプションにより開始する時に名前を登録することをサポートします。\n"
"登録されたなまえは、終了時に自動的にクリーンアップされます。サポート\n"
"された値は以下の通りです:\n"
"\n"
"  * an atom - GenServerは`Process.register/2`を使い、与えられた名前を\n"
"    ローカルに登録されます。\n"
"\n"
"  * `{:global, term}`- GenServerは`:global`オジュールの関数を使い、\n"
"    与えられたtermをグローバルに登録されます。\n"
"\n"
"  * `{:via, module, term}` - GenServerは与えられたメカニズムと名前で\n"
"    登録されます。`:via`オプションは、\n"
"    登録メカニズムを制御する\n"
"    モジュール名moduleと、任意の語をとることができるnameを期待します。\n"
"\n"
"例えば、私達のStackサーバを以下のようにローカルとして登録して\n"
"開始できます:\n"
"\n"
"    # Start the server and register it locally with name MyStack\n"
"    {:ok, _} = GenServer.start_link(Stack, [:hello], name: MyStack)\n"
"\n"
"    # Now messages can be sent directly to MyStack\n"
"    GenServer.call(MyStack, :pop) #=> :hello\n"
"\n"
"一旦サーバが開始したら、このモジュールの残りの関数\n"
"(`call/3`、`cast/2`とその他)も、アトムまたは、任意の`:global`、`:via`タプル\n"
"を受け付けます。一般的に、以下のフォーマットがサポートされています:\n"
"\n"
"  * `pid`\n"
"  * `atom` サーバがローカルに登録されている場合\n"
"  * `{atom, node}` ローカルに登録されているサーバが他のノードにある場合\n"
"  * `{:global, term}` サーバがグローバルに登録されている場合\n"
"  * `{:via, module, name}` サーバが代わりの登録方法を通して登録された場合\n"
"\n"
"## Client / Server APIs\n"
"\n"
"上の例を通じて、\n"
"サーバを直接開始したり通信するために、`GenServer.start_link/3`とそのフレンド"
"を、\n"
"使いましたが、\n"
"殆ど、私達は`GenServer`関数を直接には呼び出しません。\n"
"代わりに、サーバの公式なAPIを表現する新しい関数で呼び出しを\n"
"ラップします。\n"
"\n"
"これは、私達のStackモジュールのよりよい実装です:\n"
"\n"
"    defmodule Stack do\n"
"      use GenServer\n"
"\n"
"      # Client\n"
"\n"
"      def start_link(default) do\n"
"        GenServer.start_link(__MODULE__, default)\n"
"      end\n"
"\n"
"      def push(pid, item) do\n"
"        GenServer.cast(pid, {:push, item})\n"
"      end\n"
"\n"
"      def pop(pid) do\n"
"        GenServer.call(pid, :pop)\n"
"      end\n"
"\n"
"      # Server (callbacks)\n"
"\n"
"      def handle_call(:pop, _from, [h|t]) do\n"
"        {:reply, h, t}\n"
"      end\n"
"\n"
"      def handle_call(request, from, state) do\n"
"        # Call the default implementation from GenServer\n"
"        super(request, from, state)\n"
"      end\n"
"\n"
"      def handle_cast({:push, item}, state) do\n"
"        {:noreply, [item|state]}\n"
"      end\n"
"\n"
"      def handle_cast(request, state) do\n"
"        super(request, state)\n"
"      end\n"
"    end\n"
"\n"
"実際、同じモジュール内でサーバとクライアントの両方の関数を持つことは、\n"
"一般的です。サーバとクライアント実装が複雑になっていくならば、\n"
"それらを別のモジュールにしたくなるかもしれません。\n"
"\n"
"## Learn more\n"
"\n"
"gen serverについてもっと知りたいなら、Elixir getting started guide\n"
"がチュートリアルライクの導入を提供します。Erlangのドキュメントとリンク\n"
"もまた、追加の洞察を提供することができます。\n"
"\n"
"  * http://elixir-lang.org/getting_started/mix_otp/1.html\n"
"  * http://www.erlang.org/doc/man/gen_server.html\n"
"  * http://www.erlang.org/doc/design_principles/gen_server_concepts.html\n"
"  * http://learnyousomeerlang.com/clients-and-servers\n"

#. TRANSLATORS: Elixir.Supervisor Summary
#: lib/supervisor.ex:1
msgid ""
"A behaviour module for implementing supervision functionality.\n"
"\n"
"A supervisor is a process which supervises other processes called\n"
"child processes. Supervisors are used to build an hierarchical process\n"
"structure called a supervision tree, a nice way to structure fault-tolerant\n"
"applications.\n"
"\n"
"A supervisor implemented using this module will have a standard set\n"
"of interface functions and include functionality for tracing and error\n"
"reporting. It will also fit into a supervision tree.\n"
"\n"
"## Example\n"
"\n"
"In order to define a supervisor, we need to first define a child process\n"
"that is going to be supervised. In order to do so, we will define a "
"GenServer\n"
"that represents a stack:\n"
"\n"
"    defmodule Stack do\n"
"      use GenServer\n"
"\n"
"      def start_link(state) do\n"
"        GenServer.start_link(__MODULE__, state, [name: :sup_stack])\n"
"      end\n"
"\n"
"      def handle_call(:pop, _from, [h|t]) do\n"
"        {:reply, h, t}\n"
"      end\n"
"\n"
"      def handle_cast({:push, h}, t) do\n"
"        {:noreply, [h|t]}\n"
"      end\n"
"    end\n"
"\n"
"We can now define our supervisor and start it as follows:\n"
"\n"
"    # Import helpers for defining supervisors\n"
"    import Supervisor.Spec\n"
"\n"
"    # We are going to supervise the Stack server which will\n"
"    # be started with a single argument [:hello]\n"
"    children = [\n"
"      worker(Stack, [[:hello]])\n"
"    ]\n"
"\n"
"    # Start the supervisor with our one child\n"
"    {:ok, pid} = Supervisor.start_link(children, strategy: :one_for_one)\n"
"\n"
"Notice that when starting the GenServer, we have registered it\n"
"with name `:sup_stack`, which allows us to call it directly and\n"
"get what is on the stack:\n"
"\n"
"    GenServer.call(:sup_stack, :pop)\n"
"    #=> :hello\n"
"\n"
"    GenServer.cast(:sup_stack, {:push, :world})\n"
"    #=> :ok\n"
"\n"
"    GenServer.call(:sup_stack, :pop)\n"
"    #=> :world\n"
"\n"
"However, there is a bug in our stack server. If we call `:pop` and\n"
"the stack is empty, it is going to crash because no clause matches.\n"
"Let's try it:\n"
"\n"
"    GenServer.call(:sup_stack, :pop)\n"
"    =ERROR REPORT====\n"
"\n"
"Luckily, since the server is being supervised by a supervisor, the\n"
"supervisor will automatically start a new one, with the default stack\n"
"of `[:hello]` like before:\n"
"\n"
"    GenServer.call(:sup_stack, :pop) == :hello\n"
"\n"
"Supervisors support different strategies; in the example above, we\n"
"have chosen `:one_for_one`. Furthermore, each supervisor can have many\n"
"workers and supervisors as children, each of them with their specific\n"
"configuration, shutdown values, and restart strategies.\n"
"\n"
"Continue reading this moduledoc to learn more about supervision strategies\n"
"and then follow to the `Supervisor.Spec` module documentation to learn\n"
"about the specification for workers and supervisors.\n"
"\n"
"## Module-based supervisors\n"
"\n"
"In the example above, a supervisor was dynamically created by passing\n"
"the supervision structure to `start_link/2`. However, supervisors\n"
"can also be created by explicitly defining a supervision module:\n"
"\n"
"    defmodule MyApp.Supervisor do\n"
"      use Supervisor\n"
"\n"
"      def start_link do\n"
"        Supervisor.start_link(__MODULE__, [])\n"
"      end\n"
"\n"
"      def init([]) do\n"
"        children = [\n"
"          worker(Stack, [[:hello]])\n"
"        ]\n"
"\n"
"        supervise(children, strategy: :one_for_one)\n"
"      end\n"
"    end\n"
"\n"
"You may want to use a module-based supervisor if:\n"
"\n"
"  * You need to do some particular action on supervisor\n"
"    initialization, like setting up a ETS table.\n"
"\n"
"  * You want to perform partial hot-code swapping of the\n"
"    tree. For example, if you add or remove a children,\n"
"    the module-based supervision will add and remove the\n"
"    new children directly, while the dynamic supervision\n"
"    requires the whole tree to be restarted in order to\n"
"    perform such swaps.\n"
"\n"
"## Strategies\n"
"\n"
"  * `:one_for_one` - if a child process terminates, only that\n"
"    process is restarted.\n"
"\n"
"  * `:one_for_all` - if a child process terminates, all other child\n"
"    processes are terminated and then all child processes (including\n"
"    the terminated one) are restarted.\n"
"\n"
"  * `:rest_for_one` - if a child process terminates, the \"rest\" of\n"
"    the child processes, i.e. the child processes after the terminated\n"
"    one in start order, are terminated. Then the terminated child\n"
"    process and the rest of the child processes are restarted.\n"
"\n"
"  * `:simple_one_for_one` - similar to `:one_for_one` but suits better\n"
"    when dynamically attaching children. This strategy requires the\n"
"    supervisor specification to contain only one child. Many functions\n"
"    in this module behave slightly differently when this strategy is\n"
"    used.\n"
"\n"
"## Name Registration\n"
"\n"
"A supervisor is bound to the same name registration rules as a `GenServer`.\n"
"Read more about it in the `GenServer` docs.\n"
msgstr ""
"スーパビジョン機能を実装するためのビヘイビアモジュールです。\n"
"\n"
"スーパバイザは、子プロセスと呼ばれる他のプロセスをスーパバイズするプロ\n"
"セスです。スーパバイザは、フォールトトレラントアプリケーションを構築す\n"
"るための良い方法である、スーパビジョンツリーと呼ばれる、プロセスの階層\n"
"構造を作るために使われます。\n"
"\n"
"このモジュールを使って実装されたスーパバイザは、\n"
"標準的なインタフェース関数のセットを持ち、トレースと\n"
"エラーレポートの機能を含みます。それはスーパビジョンツリーにも\n"
"適合します。\n"
"\n"
"## 例\n"
"\n"
"スーパバイザを定義するために、スーパバイズされる子プロセスを最初に定義する\n"
"必要があります。それをするために、スタックを表現するGenServerを定義します:\n"
"\n"
"    defmodule Stack do\n"
"      use GenServer\n"
"\n"
"      def start_link(state) do\n"
"        GenServer.start_link(__MODULE__, state, [name: :sup_stack])\n"
"      end\n"
"\n"
"      def handle_call(:pop, _from, [h|t]) do\n"
"        {:reply, h, t}\n"
"      end\n"
"\n"
"      def handle_cast({:push, h}, t) do\n"
"        {:noreply, [h|t]}\n"
"      end\n"
"    end\n"
"\n"
"今や、私達のスーパバイザを定義し、それを下の様にして開始できます:\n"
"\n"
"    # Import helpers for defining supervisors\n"
"    import Supervisor.Spec\n"
"\n"
"    # We are going to supervise the Stack server which will\n"
"    # be started with a single argument [:hello]\n"
"    children = [\n"
"      worker(Stack, [[:hello]])\n"
"    ]\n"
"\n"
"    # Start the supervisor with our one child\n"
"    {:ok, pid} = Supervisor.start_link(children, strategy: :one_for_one)\n"
"\n"
"`:sup_stack`という名前で登録してGenServerをスタートするとき、\n"
"それを直接呼び出したり呼び出してスタックの値を得ることができる\n"
"ことに注意してください:\n"
"\n"
"    GenServer.call(:sup_stack, :pop)\n"
"    #=> :hello\n"
"\n"
"    GenServer.cast(:sup_stack, {:push, :world})\n"
"    #=> :ok\n"
"\n"
"    GenServer.call(:sup_stack, :pop)\n"
"    #=> :world\n"
"\n"
"しかしながら、私達のスタックサーバにはバグがあります。スタックが\n"
"空のときに`:pop`を呼び出したら、no clause matchesでクラッシュします:\n"
"\n"
"    GenServer.call(:sup_stack, :pop)\n"
"    =ERROR REPORT====\n"
"\n"
"幸運にも、サーバがスーパバイザによりスーパバイズされていたら、\n"
"スーパバイザは自動的に新しいサーバを開始します。前のような\n"
"`[:hello]`のデフォルトスタックもセットされます:\n"
"\n"
"    GenServer.call(:sup_stack, :pop) == :hello\n"
"\n"
"スーパバイザは異る戦略をサポートします; 上の例では、`:one_for_one`を選\n"
"択しました。更にまた、それぞれのスーパバイザは多くのワーカとスーパバイ\n"
"ザを子供として持つことができ、それぞれ特定のshutdown値やrestart戦略といっ\n"
"た構成を持つことができます。\n"
"\n"
"スーパビジョン戦略についてより学ぶために、このモジュールドキュメント\n"
"の続きを読んでください。そして、それから\n"
"workerとsupervisorのための子プロセス仕様について\n"
"学ぶために`Supervisor.Spec`モジュールドキュメントを読んでください。\n"
"\n"
"## Module-based supervisors\n"
"\n"
"上の例では、スーパバイザは、`start_link/2`へスーパビジョン構造を\n"
"送ることにより、動的に作成されました。しかしながら、スーパバイザは\n"
"スーパビジョンモジュールを明示的に定義することによって作成することも\n"
"出来ます:\n"
"\n"
"    defmodule MyApp.Supervisor do\n"
"      use Supervisor\n"
"\n"
"      def start_link do\n"
"        Supervisor.start_link(__MODULE__, [])\n"
"      end\n"
"\n"
"      def init([]) do\n"
"        children = [\n"
"          worker(Stack, [[:hello]])\n"
"        ]\n"
"\n"
"        supervise(children, strategy: :one_for_one)\n"
"      end\n"
"    end\n"
"\n"
"以下のようなとき、module-basedスーパバイザを使いたくなるかもしれません:\n"
"\n"
"  * ETSテーブルのセットアップのような、\n"
"    スーパバイザの初期化の特定のアクションをしたい。\n"
"\n"
"  * ツリーの部分的なホットコードスワッピングを実行したい。\n"
"    例えば、子プロセスを追加あるいは削除したとき、\n"
"    module-basedスーパビジョンは、直接、子プロセスを\n"
"    追加、削除します。一方、\n"
"    動的なスーパビジョンは、そのスワップを実行するために\n"
"    木全体の再起動を要求します。\n"
"\n"
"## Strategies\n"
"\n"
"  * `:one_for_one` - \n"
"    子プロセスが終了したら、そのプロセスだけが再起動されます\n"
"\n"
"  * `:one_for_all` - \n"
"    子プロセスが終了したら、他の全てのプロセスが終了され、\n"
"    それから、全ての子プロセス(終了したものも含みます)が、\n"
"    再起動されます。\n"
"\n"
"  * `:rest_for_one` - \n"
"    子プロセスが終了したら、子プロセスの\"rest\"(即ち、\n"
"    その子プロセスが開始した後にに開始した子プロセス)は終了します。\n"
"\n"
"  * `:simple_one_for_one` - `:one_for_one`に似ていますが、動的に\n"
"    子プロセスをアタッチする時には、より適合します。このストラテジは\n"
"    一種類の子プロセスだけを含むことをスーパバイザ仕様に要求します。\n"
"    このストラテジが使われるとき、このモジュールの多くの関数は僅かに\n"
"    異る振る舞いをします。\n"
"\n"
"## Name Registration\n"
"\n"
"Supervisorは、`GenServer`と同じ名前登録規則に従います。\n"
"それについてはの詳細は、`GenServer`のドキュメントを参照してください。\n"

#. TRANSLATORS: Elixir.GenEvent Summary
#: lib/gen_event.ex:1
msgid ""
"A behaviour module for implementing event handling functionality.\n"
"\n"
"The event handling model consists of a generic event manager\n"
"process with an arbitrary number of event handlers which are\n"
"added and deleted dynamically.\n"
"\n"
"An event manager implemented using this module will have a standard\n"
"set of interface functions and include functionality for tracing and\n"
"error reporting. It will also fit into a supervision tree.\n"
"\n"
"## Example\n"
"\n"
"There are many use cases for event handlers. For example, a logging\n"
"system can be built using event handlers where each log message is\n"
"an event and different event handlers can be plugged to handle the\n"
"log messages. One handler may print error messages on the terminal,\n"
"another can write it to a file, while a third one can keep the\n"
"messages in memory (like a buffer) until they are read.\n"
"\n"
"As an example, let's have a GenEvent that accumulates messages until\n"
"they are collected by an explicit call.\n"
"\n"
"    defmodule LoggerHandler do\n"
"      use GenEvent\n"
"\n"
"      # Callbacks\n"
"\n"
"      def handle_event({:log, x}, messages) do\n"
"        {:ok, [x|messages]}\n"
"      end\n"
"\n"
"      def handle_call(:messages, messages) do\n"
"        {:ok, Enum.reverse(messages), []}\n"
"      end\n"
"    end\n"
"\n"
"    {:ok, pid} = GenEvent.start_link()\n"
"\n"
"    GenEvent.add_handler(pid, LoggerHandler, [])\n"
"    #=> :ok\n"
"\n"
"    GenEvent.notify(pid, {:log, 1})\n"
"    #=> :ok\n"
"\n"
"    GenEvent.notify(pid, {:log, 2})\n"
"    #=> :ok\n"
"\n"
"    GenEvent.call(pid, LoggerHandler, :messages)\n"
"    #=> [1, 2]\n"
"\n"
"    GenEvent.call(pid, LoggerHandler, :messages)\n"
"    #=> []\n"
"\n"
"We start a new event manager by calling `GenEvent.start_link/0`.\n"
"Notifications can be sent to the event manager which will then\n"
"invoke `handle_event/2` for each registered handler.\n"
"\n"
"We can add new handlers with `add_handler/3` and `add_mon_handler/3`.\n"
"Calls can also be made to specific handlers by using `call/3`.\n"
"\n"
"## Callbacks\n"
"\n"
"There are 6 callbacks required to be implemented in a `GenEvent`. By\n"
"adding `use GenEvent` to your module, Elixir will automatically define\n"
"all 6 callbacks for you, leaving it up to you to implement the ones\n"
"you want to customize. The callbacks are:\n"
"\n"
"  * `init(args)` - invoked when the event handler is added.\n"
"\n"
"    It must return:\n"
"\n"
"    -  `{:ok, state}`\n"
"    -  `{:ok, state, :hibernate}`\n"
"    -  `{:error, reason}`\n"
"\n"
"  * `handle_event(msg, state)` - invoked whenever an event is sent via\n"
"    `notify/2`, `ack_notify/2` or `sync_notify/2`.\n"
"\n"
"    It must return:\n"
"\n"
"    -  `{:ok, new_state}`\n"
"    -  `{:ok, new_state, :hibernate}`\n"
"    -  `:remove_handler`\n"
"\n"
"  * `handle_call(msg, state)` - invoked when a `call/3` is done to a "
"specific\n"
"    handler.\n"
"\n"
"    It must return:\n"
"\n"
"    -  `{:ok, reply, new_state}`\n"
"    -  `{:ok, reply, new_state, :hibernate}`\n"
"    -  `{:remove_handler, reply}`\n"
"\n"
"  * `handle_info(msg, state)` - invoked to handle all other messages which\n"
"    are received by the process. Must return the same values as\n"
"    `handle_event/2`.\n"
"\n"
"  * `terminate(reason, state)` - called when the event handler is removed "
"or\n"
"    the event manager is terminating. It can return any term.\n"
"\n"
"    The reason is one of:\n"
"\n"
"    -  `:stop` - manager is terminating\n"
"    -  `{:stop, reason}` - monitored process terminated (for monitored "
"handlers)\n"
"    -  `:remove_handler` - handler is being removed\n"
"    -  `{:error, term}` - handler crashed or returned a bad value\n"
"    -  `term` - any term passed to functions like `GenEvent."
"remove_handler/2`\n"
"\n"
"  * `code_change(old_vsn, state, extra)` - called when the application\n"
"    code is being upgraded live (hot code swapping).\n"
"\n"
"    It must return:\n"
"\n"
"    -  `{:ok, new_state}`\n"
"\n"
"## Name Registration\n"
"\n"
"A GenEvent is bound to the same name registration rules as a `GenServer`.\n"
"Read more about it in the `GenServer` docs.\n"
"\n"
"## Modes\n"
"\n"
"GenEvent stream supports three different notifications.\n"
"\n"
"On `GenEvent.ack_notify/2`, the manager acknowledges each event,\n"
"providing back pressure, but processing of the message happens\n"
"asynchronously.\n"
"\n"
"On `GenEvent.sync_notify/2`, the manager acknowledges an event\n"
"just after it was processed by all event handlers.\n"
"\n"
"On `GenEvent.notify/2`, all events are processed asynchronously and\n"
"there is no ack (which means there is no backpressure).\n"
"\n"
"## Streaming\n"
"\n"
"`GenEvent` messages can be streamed with the help of `stream/2`.\n"
"Here are some examples:\n"
"\n"
"    stream = GenEvent.stream(pid)\n"
"\n"
"    # Discard the next 10 events\n"
"    _ = Enum.drop(stream, 10)\n"
"\n"
"    # Print all remaining events\n"
"    for event <- stream do\n"
"      IO.inspect event\n"
"    end\n"
"\n"
"## Learn more and compatibility\n"
"\n"
"If you wish to find out more about gen events, Elixir getting started\n"
"guides provide a tutorial-like introduction. The documentation and links\n"
"in Erlang can also provide extra insight.\n"
"\n"
"  * http://elixir-lang.org/getting_started/mix_otp/1.html\n"
"  * http://www.erlang.org/doc/man/gen_event.html\n"
"  * http://learnyousomeerlang.com/event-handlers\n"
"\n"
"Keep in mind though Elixir and Erlang gen events are not 100% compatible.\n"
"The `:gen_event.add_sup_handler/3` is not supported by Elixir's GenEvent,\n"
"which in turn supports `GenEvent.add_mon_handler/3`.\n"
"\n"
"The benefits of the monitoring approach are described in the \"Don't drink\n"
"too much kool aid\" section of the \"Learn you some Erlang\" link above. "
"Due\n"
"to those changes, Elixir's GenEvent does not trap exits by default.\n"
"\n"
"Furthermore, Elixir's also normalizes the `{:error, _}` tuples returned\n"
"by many functions, in order to be more consistent with themselves and\n"
"the `GenServer` module.\n"
msgstr ""
"イベントハンドリング機能を実装するためのビヘイビアモジュールです。\n"
"\n"
"動的に追加・削除を行われる、任意の数のイベントハンドラで、\n"
"イベント処理モデルは一般的なイベントマネージャプロセスから\n"
"なります。\n"
"\n"
"このモジュールを用いて実装されるイベントマネージャは、標準的な\n"
"インタフェース関数のセットを持ち、トレースとエラーレポートの為の\n"
"機能を含みます。\n"
"それはsupervisionツリーにも適合します。\n"
"\n"
"## Example\n"
"\n"
"イベントハンドラのための多くのユースケースがあります。例えば、\n"
"各のログメッセージがイベントであるイベントハンドラを用いて、\n"
"ログシステムは構築することができ、異るログメッセージを処理する\n"
"イベントハンドラをプラグすることも出来ます。\n"
"一つのハンドラはエラーメッセージをターミナルに印字し、\n"
"もう一つのものはファイルに書き込み、第3のものは(バッファのような)\n"
"メモリに、それらが読まれるまで、保存しておくことが出来ます。\n"
"\n"
"例として、明示的に呼び出すまで、メッセージを集めるGenEventを作ってみま\n"
"しょう。\n"
"\n"
"    defmodule LoggerHandler do\n"
"      use GenEvent\n"
"\n"
"      # Callbacks\n"
"\n"
"      def handle_event({:log, x}, messages) do\n"
"        {:ok, [x|messages]}\n"
"      end\n"
"\n"
"      def handle_call(:messages, messages) do\n"
"        {:ok, Enum.reverse(messages), []}\n"
"      end\n"
"    end\n"
"\n"
"    {:ok, pid} = GenEvent.start_link()\n"
"\n"
"    GenEvent.add_handler(pid, LoggerHandler, [])\n"
"    #=> :ok\n"
"\n"
"    GenEvent.notify(pid, {:log, 1})\n"
"    #=> :ok\n"
"\n"
"    GenEvent.notify(pid, {:log, 2})\n"
"    #=> :ok\n"
"\n"
"    GenEvent.call(pid, LoggerHandler, :messages)\n"
"    #=> [1, 2]\n"
"\n"
"    GenEvent.call(pid, LoggerHandler, :messages)\n"
"    #=> []\n"
"\n"
"私達は`GenEvent.start_link/0`を呼ぶことで、新しいイベントマネージャを\n"
"開始します。\n"
"それから、登録されたハンドラ毎に`handle_event/2`を実行するイベント\n"
"マネージャに通知を送ることができます。\n"
"\n"
"私達は`add_handler/3`と`add_mon_handler/3`で新しいハンドラを\n"
"追加します。\n"
"`call/3`を使って特定のハンドラを呼び出すことができます。\n"
"\n"
"## Callbacks\n"
"\n"
"`GenEvent`で実装することが要求されている6個のコールバックがあります。\n"
"`use GenEvent`をあなたのモジュールに追加することにより、Elixir自動的に\n"
"6個のコールバックを定義し、カスタマイズしたいものの実装をあなたに任せます。\n"
"コールバックは:\n"
"\n"
"  * `init(args)` - イベントハンドラが追加されたとき起動されます。\n"
"\n"
"    以下を返さなければなりません:\n"
"\n"
"    -  `{:ok, state}`\n"
"    -  `{:ok, state, :hibernate}`\n"
"    -  `{:error, reason}`\n"
"\n"
"  * `handle_event(msg, state)` - イベントが`notify/2`か\n"
"     `ack_notiry/2'か、`sync_notify/2`により送られたときは\n"
"     何時でも起動されます。\n"
"\n"
"    以下を返さなければなりません:\n"
"\n"
"    -  `{:ok, new_state}`\n"
"    -  `{:ok, new_state, :hibernate}`\n"
"    -  `:remove_handler`\n"
"\n"
"  * `handle_call(msg, state)` - `call/3`が特定のハンドラにされたとき、\n"
"     起動されます。\n"
"\n"
"    以下を返さなければなりません:\n"
"\n"
"    -  `{:ok, reply, new_state}`\n"
"    -  `{:ok, reply, new_state, :hibernate}`\n"
"    -  `{:remove_handler, reply}`\n"
"\n"
"  * `handle_info(msg, state)` - プロセスで受信した他の全てのメッセージを\n"
"    ハンドルするために起動されます。`handle_event/2`と同じ値を返さなければ\n"
"    なりません。\n"
"\n"
"  * `terminate(reason, state)` - イベントハンドラが削除される、あるいは、\n"
"    イベントマネージャが終了されるときに呼び出されます。任意の語を\n"
"    返すことができます。reasonは以下の何れかです:\n"
"\n"
"    -  `:stop` - マネージャが終了します\n"
"    -  `{:stop, reason}` - モニタされたプロセスが終了されました(\n"
"       モニタされたハンドラによって)\n"
"    -  `:remove_handler` - ハンドラが削除されました\n"
"    -  `{:error, term}` - ハンドラがクラッシュしたか、\n"
"       異常な値を返しました\n"
"    -  `term` - 任意のtermは`GenEvent.remove_handler/2`のような関数へ\n"
"       渡されます\n"
"\n"
"  * `code_change(old_vsn, state, extra)` - アプリケーションコードが\n"
"    ライブアップグレード(ホットコードスワッピング)されるときに\n"
"    呼び出されます。\n"
"\n"
"    以下を返さなければなりません:\n"
"\n"
"    -  `{:ok, new_state}`\n"
"\n"
"## Name Registration\n"
"\n"
"GenEventは`GenServer`と同じ名前登録規則に従います。\n"
"それについてはの詳細は、`GenServer`のドキュメントを参照してください。\n"
"\n"
"## Modes\n"
"\n"
"GenEventストリームは3つの異る通知をサポートします。\n"
"\n"
"`GenEvent.ack_notiry/2`では、マネージャがそれぞれのイベントをack\n"
"するバックプレッシャーを提供しますが、メッセージの処理は非同期で\n"
"起ります。\n"
"\n"
"`GenEvent.sync_notiry/2`では、マネージャが、全てのイベントハンド\n"
"ラにより処理されたあと、それぞれのイベントをackします。\n"
"\n"
"`GenEvent.notify/2`では、全てのイベントは非同期で処理され、\n"
"ackはありません(バックプレッシャーがないことを意味します)。\n"
"\n"
"## Streaming\n"
"\n"
"`GenEvent`メッセージは`stream/2`の助けを借りて、ストリーム化\n"
"出来ます。いくつかの例です:\n"
"\n"
"    stream = GenEvent.stream(pid)\n"
"\n"
"    # Discard the next 10 events\n"
"    _ = Enum.drop(stream, 10)\n"
"\n"
"    # Print all remaining events\n"
"    for event <- stream do\n"
"      IO.inspect event\n"
"    end\n"
"\n"
"\n"
"## Learn more and compatibility\n"
"\n"
"gen eventについてもっと知りたいなら、Elixir getting started guide\n"
"がチュートリアルライクの導入を提供します。Erlangのドキュメントとリンク\n"
"もまた、追加の洞察を提供することができます。\n"
"\n"
"  * http://elixir-lang.org/getting_started/mix_otp/1.html\n"
"  * http://www.erlang.org/doc/man/gen_event.html\n"
"  * http://learnyousomeerlang.com/event-handlers\n"
"\n"
"ElixirとErlangのgen eventは100%の互換性がないことを心に留めてお\n"
"いてください。\n"
"`:gen_event.add_sup_handler/3`はElixirのGenEventではサポートされません、\n"
"代わりに`GenEvent.add_mon_handler/3`をサポートします。\n"
"\n"
"モニタアプローチの利点は上のリンク \"Learn you some Erlang\" の \"Don't\n"
"drink too much kool aid\" セクションに記述されています。それらの変更によ\n"
"り、ElixirのGenEventはデフォルトではexitをトラップしません。\n"
"\n"
"さらにまた、Elixirは、`GenEvent`モジュールにあわせるために、\n"
"多くの関数により返される`{:error, _}`タプルを正規化します。\n"

#. TRANSLATORS: Elixir.String Summary
#: lib/string.ex:3
msgid ""
"A String in Elixir is a UTF-8 encoded binary.\n"
"\n"
"## Codepoints and graphemes\n"
"\n"
"The functions in this module act according to the Unicode\n"
"Standard, version 6.3.0. As per the standard, a codepoint is\n"
"an Unicode Character, which may be represented by one or more\n"
"bytes. For example, the character \"é\" is represented with two\n"
"bytes:\n"
"\n"
"    iex> byte_size(\"é\")\n"
"    2\n"
"\n"
"However, this module returns the proper length:\n"
"\n"
"    iex> String.length(\"é\")\n"
"    1\n"
"\n"
"Furthermore, this module also presents the concept of\n"
"graphemes, which are multiple characters that may be\n"
"\"perceived as a single character\" by readers. For example,\n"
"the same \"é\" character written above could be represented\n"
"by the letter \"e\" followed by the accent ́:\n"
"\n"
"    iex> string = \"\\x{0065}\\x{0301}\"\n"
"    iex> byte_size(string)\n"
"    3\n"
"    iex> String.length(string)\n"
"    1\n"
"\n"
"Although the example above is made of two characters, it is\n"
"perceived by users as one.\n"
"\n"
"Graphemes can also be two characters that are interpreted\n"
"as one by some languages. For example, some languages may\n"
"consider \"ch\" as a grapheme. However, since this information\n"
"depends on the locale, it is not taken into account by this\n"
"module.\n"
"\n"
"In general, the functions in this module rely on the Unicode\n"
"Standard, but do not contain any of the locale specific behaviour.\n"
"\n"
"More information about graphemes can be found in the [Unicode\n"
"Standard Annex #29](http://www.unicode.org/reports/tr29/).\n"
"This current Elixir version implements Extended Grapheme Cluster\n"
"algorithm.\n"
"\n"
"## String and binary operations\n"
"\n"
"To act accordingly to the Unicode Standard, many functions\n"
"in this module runs in linear time, as it needs to traverse\n"
"the whole string considering the proper Unicode codepoints.\n"
"\n"
"For example, `String.length/1` is going to take longer as\n"
"the input grows. On the other hand, `Kernel.byte_size/1` always runs\n"
"in constant time (i.e. regardless of the input size).\n"
"\n"
"This means often there are performance costs in using the\n"
"functions in this module, compared to the more low-level\n"
"operations that work directly with binaries:\n"
"\n"
"  * `Kernel.binary_part/3` - retrieves part of the binary\n"
"  * `Kernel.bit_size/1` and `Kernel.byte_size/1` - size related functions\n"
"  * `Kernel.is_bitstring/1` and `Kernel.is_binary/1` - type checking "
"function\n"
"  * Plus a number of functions for working with binaries (bytes)\n"
"    [in the `:binary` module](http://erlang.org/doc/man/binary.html)\n"
"\n"
"There are many situations where using the `String` module can\n"
"be avoided in favor of binary functions or pattern matching.\n"
"For example, imagine you have a string `prefix` and you want to\n"
"remove this prefix from another string named `full`.\n"
"\n"
"One may be tempted to write:\n"
"\n"
"    iex> take_prefix = fn full, prefix ->\n"
"    ...>   base = String.length(prefix)\n"
"    ...>   String.slice(full, base, String.length(full) - base)\n"
"    ...> end\n"
"    iex> take_prefix.(\"Mr. John\", \"Mr. \")\n"
"    \"John\"\n"
"\n"
"Although the function above works, it performs poorly. To\n"
"calculate the length of the string, we need to traverse it\n"
"fully, so we traverse both `prefix` and `full` strings, then\n"
"slice the `full` one, traversing it again.\n"
"\n"
"A first attempting at improving it could be with ranges:\n"
"\n"
"    iex> take_prefix = fn full, prefix ->\n"
"    ...>   base = String.length(prefix)\n"
"    ...>   String.slice(full, base..-1)\n"
"    ...> end\n"
"    iex> take_prefix.(\"Mr. John\", \"Mr. \")\n"
"    \"John\"\n"
"\n"
"While this is much better (we don't traverse `full` twice),\n"
"it could still be improved. In this case, since we want to\n"
"extract a substring from a string, we can use `byte_size/1`\n"
"and `binary_part/3` as there is no chance we will slice in\n"
"the middle of a codepoint made of more than one byte:\n"
"\n"
"    iex> take_prefix = fn full, prefix ->\n"
"    ...>   base = byte_size(prefix)\n"
"    ...>   binary_part(full, base, byte_size(full) - base)\n"
"    ...> end\n"
"    iex> take_prefix.(\"Mr. John\", \"Mr. \")\n"
"    \"John\"\n"
"\n"
"Or simply use pattern matching:\n"
"\n"
"    iex> take_prefix = fn full, prefix ->\n"
"    ...>   base = byte_size(prefix)\n"
"    ...>   <<_ :: binary-size(base), rest :: binary>> = full\n"
"    ...>   rest\n"
"    ...> end\n"
"    iex> take_prefix.(\"Mr. John\", \"Mr. \")\n"
"    \"John\"\n"
"\n"
"On the other hand, if you want to dynamically slice a string\n"
"based on an integer value, then using `String.slice/3` is the\n"
"best option as it guarantees we won't incorrectly split a valid\n"
"codepoint in multiple bytes.\n"
"\n"
"## Integer codepoints\n"
"\n"
"Although codepoints could be represented as integers, this\n"
"module represents all codepoints as strings. For example:\n"
"\n"
"    iex> String.codepoints(\"olá\")\n"
"    [\"o\", \"l\", \"á\"]\n"
"\n"
"There are a couple of ways to retrieve a character integer\n"
"codepoint. One may use the `?` construct:\n"
"\n"
"    iex> ?o\n"
"    111\n"
"\n"
"    iex> ?á\n"
"    225\n"
"\n"
"Or also via pattern matching:\n"
"\n"
"    iex> << eacute :: utf8 >> = \"á\"\n"
"    iex> eacute\n"
"    225\n"
"\n"
"As we have seen above, codepoints can be inserted into\n"
"a string by their hexadecimal code:\n"
"\n"
"    \"ol\\x{0061}\\x{0301}\" #=>\n"
"    \"olá\"\n"
"\n"
"## Self-synchronization\n"
"\n"
"The UTF-8 encoding is self-synchronizing. This means that\n"
"if malformed data (i.e., data that is not possible according\n"
"to the definition of the encoding) is encountered, only one\n"
"codepoint needs to be rejected.\n"
"\n"
"This module relies on this behaviour to ignore such invalid\n"
"characters. For example, `length/1` is going to return\n"
"a correct result even if an invalid codepoint is fed into it.\n"
"\n"
"In other words, this module expects invalid data to be detected\n"
"when retrieving data from the external source. For example, a\n"
"driver that reads strings from a database will be the one\n"
"responsible to check the validity of the encoding.\n"
msgstr ""
"Elixirでの文字列はUTF-8でエンコードされたバイナリです。\n"
"\n"
"## Codepoints and graphemes\n"
"\n"
"このモジュールの関数はUnicode標準 version 6.3.0に\n"
"準拠して動作します。\n"
"Unicode標準に従って、コードポイントはUnicode文字で、1つ以上の\n"
"バイトにより表現されます。例えば、文字 \\\"é\\\" は2バイトで\n"
"表現されます:\n"
"\n"
"    iex> byte_size(\\\"é\\\")\n"
"    2\n"
"\n"
"しかしながら、このモジュールは正しい長さを返します:\n"
"\n"
"    iex> String.length(\\\"é\\\")\n"
"    1\n"
"\n"
"さらにまた、このモジュールは書記素の概念も示します。それは\n"
"読者により、\\\"ひとつの文字として認められる\\\"\n"
"複数の文字です。\n"
"例えば、上で書かれた同じ \\\"é\\\" 文字は、アクセント  ́ が\n"
"続く、文字 \\\"e\\\" によっても表現できます:\n"
"\n"
"    iex> string = \\\"\\\\x{0065}\\\\x{0301}\\\"\n"
"    iex> byte_size(string)\n"
"    3\n"
"    iex> String.length(string)\n"
"    1\n"
"\n"
"上の例は二つの文字で作られているが、それは一体となって\n"
"ユーザにより認められます。\n"
"\n"
"書記素は、いくつかの言語によっては、一体となって解釈される\n"
"二つの文字でも有り得ます。例えば、いくつかの言語は、\n"
"\\\"ch\\\"を書記素として考えるかもしれません。\n"
"しかしながら、この情報がロケールに依存するので、このモジュール\n"
"では考慮されません。\n"
"\n"
"一般には、このモジュールの関数は、Unicode標準を\n"
"信頼しますが、ロケールに特有のいかなる振る舞いも含みません。\n"
"\n"
"書記素についての詳細情報は、[Unicode Standard Annex\n"
"#29](http://www.unicode.org/reports/tr29/)で見つかります。現在のElixir\n"
"のバージョンは拡張書記素クラスタ(Extended Grapheme Cluster algorithm)を\n"
"実装しています。\n"
"\n"
"## 文字列とバイナリの操作\n"
"\n"
"Unicode標準に準拠するために、このモジュールの多くの関数は、\n"
"適当なUnicodeコードポイントを考慮するのに、\n"
"文字列全体の取り出しが必要になる場合があるため、線形の時間が\n"
"かかります。\n"
"\n"
"例えば、`String.length/1`は、入力の増大に従って、時間が\n"
"かかります。一方、`byte_size/1`は常に定数時間で\n"
"動作します(即ち、入力の大きさを気にしません)。\n"
"\n"
"以下のような、より低レベルのバイナリを直接操作することと\n"
"比較して、このモジュールの関数を使うことに、パフォーマンス上の\n"
"コストがあることを、しばしば、意味します:\n"
"\n"
"  * `Kernel.binary_part/3` - バイナリの一部の取り出し\n"
"  * `Kernel.bit_size/1` と `Kernel.byte_size/1` - サイズ関連関数\n"
"  * `Kernel.is_bitstring/1` と `Kernel.is_binary/1` - タイプチェック関数\n"
"  * 加えて、\n"
"    バイナリ(バイト)で動作する[`:binary` モジュールにある]\n"
"    (http://erlang.org/doc/man/binary.html)、いくつかの関数\n"
"\n"
"バイナリ関数やパターンマッチングのほうを選んで、\n"
"`String`モジュールを使うことを避けられる、\n"
"多くのシチュエーションがあります。\n"
"例えば、文字列`prefix`を持っていて、`full`に名付けられたもう一つの\n"
"文字列からプレフィックスを削除したい場合があります。\n"
"\n"
"以下のように書きたくなるかもしれません:\n"
"\n"
"    iex> take_prefix = fn full, prefix ->\n"
"    ...>   base = String.length(prefix)\n"
"    ...>   String.slice(full, base, String.length(full) - base)\n"
"    ...> end\n"
"    iex> take_prefix.(\"Mr. John\", \"Mr. \")\n"
"    \"John\"\n"
"\n"
"上の関数は動作しますが、パフォーマンスは貧弱です。\n"
"文字列の長さを計算するために、全てをトラバースする必\n"
"要があり、`prefix`と`full`の文字列をどちらもトラバース\n"
"し、それから`full`を再びトラバースしてスライスします。\n"
"\n"
"良くするための最初の試みは、範囲(range)を使うことです:\n"
"\n"
"    iex> take_prefix = fn full, prefix ->\n"
"    ...>   base = String.length(prefix)\n"
"    ...>   String.slice(full, base..-1)\n"
"    ...> end\n"
"    iex> take_prefix.(\"Mr. John\", \"Mr. \")\n"
"    \"John\"\n"
"\n"
"これはより良いです(`full`を二度トラバースしません)が、\n"
"まだ良くできます。この場合、\n"
"文字列から部分文字列を抽出したいので、複数のバイトから\n"
"なるコードポイントの中央でスライスする危険性がないので、\n"
"`byte_size/1`と`binary_patr/3`を使うことができます:\n"
"\n"
"    iex> take_prefix = fn full, prefix ->\n"
"    ...>   base = byte_size(prefix)\n"
"    ...>   binary_part(full, base, byte_size(full) - base)\n"
"    ...> end\n"
"    iex> take_prefix.(\"Mr. John\", \"Mr. \")\n"
"    \"John\"\n"
"\n"
"または単にパターンマッチングを使えます:\n"
"\n"
"    iex> take_prefix = fn full, prefix ->\n"
"    ...>   base = byte_size(prefix)\n"
"    ...>   <<_ :: binary-size(base), rest :: binary>> = full\n"
"    ...>   rest\n"
"    ...> end\n"
"    iex> take_prefix.(\"Mr. John\", \"Mr. \")\n"
"    \"John\"\n"
"\n"
"一方、整数値により文字列を動的にスライスしたいなら、\n"
"複数バイトでの有効なコードポイントを、誤ってに分割しない\n"
"ように保証するために、`String.slice/3`がベストの選択肢です。\n"
"\n"
"## Integer codepoints\n"
"\n"
"コードポイントは整数として表現されることが出来ますが、\n"
"このモジュールは、全てのコードポイントを文字列として\n"
"表現します。例えば:\n"
"\n"
"    iex> String.codepoints(\\\"olá\\\")\n"
"    [\\\"o\\\", \\\"l\\\", \\\"á\\\"]\n"
"   \n"
"文字の整数のコードポイントを取り出す方法はいくつかあります。一つは\n"
"`?`文法構造を使う方法です:\n"
"\n"
"    iex> ?o\n"
"    111\n"
"\n"
"    iex> ?á\n"
"    225\n"
"\n"
"あるいは、パターンマッチングによる方法もあります:\n"
"\n"
"    iex> << eacute :: utf8 >> = \\\"á\\\"\n"
"    iex> eacute\n"
"    225\n"
"\n"
"上で見たように、コードポイントは16進コードにより文字列に\n"
"挿入することができます:\n"
"\n"
"    \\\"ol\\\\x{0061}\\\\x{0301}\\\" #=>\n"
"    \\\"olá\\\"\n"
"\n"
"## Self-synchronization\\n\"\n"
"\n"
"UTF-8エンコーディングは自己同期しています。これは、不正な形式のデータ\n"
"(即ち、エンコーディングの定義によって可能でないデータ)が遭遇したなら、\n"
"そのコードポイントだけが拒否される必要があるだけということを、意味して\n"
"います。\n"
"\n"
"このモジュールは、そのような無効な文字を無視するために\n"
"この振る舞いに頼ります。例えば、例え無効なコードポイントが\n"
"それに入れられていても、`length/1`は正しい結果を返すでしょう。\n"
"\n"
"言い替えると、外部ソースからデータを取り出すとき、無効な\n"
"データが見つけられることを、このモジュールは予想します。\n"
"例えば、データベースから文字列を読み出すドライバは\"\n"
"エンコーディングの有効性をチェックする責任があります。\n"

#. TRANSLATORS: Elixir.Map Summary
#: lib/map.ex:1
msgid ""
"A Dict implementation that works on maps.\n"
"\n"
"Maps are key-value stores where keys are compared using\n"
"the match operator (`===`). Maps can be created with\n"
"the `%{}` special form defined in the `Kernel.SpecialForms`\n"
"module.\n"
"\n"
"For more information about the functions in this module and\n"
"their APIs, please consult the `Dict` module.\n"
msgstr ""
"マップで動作するDict実装です。\n"
"\n"
"マップは、キーをマッチオペレータ(`===`)で比較する、\n"
"キーバリューストアです。マップは、\n"
"`Kernel.SpecilForms`で定義された`%{}`スペシャルフォームで、\n"
"作成することができます\n"
"\n"
"このモジュールの関数と、そのAPIについての詳細は、`Dict`モジュール\n"
"を参照してください。\n"
